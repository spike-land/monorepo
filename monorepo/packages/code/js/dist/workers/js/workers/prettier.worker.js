(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // ../../node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "../../node_modules/prettier/standalone.js"(exports, module) {
      !function(e, t) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).prettier = t();
      }(exports, function() {
        "use strict";
        var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
        function t(e2) {
          return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
        }
        var n = { version: "2.5.1" }, r = {}, o = {};
        !function(e2) {
          function t2() {
          }
          function n2(e3, t3, n3, r3, o2) {
            for (var i2 = 0, u2 = t3.length, s2 = 0, a2 = 0; i2 < u2; i2++) {
              var c2 = t3[i2];
              if (c2.removed) {
                if (c2.value = e3.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, i2 && t3[i2 - 1].added) {
                  var l2 = t3[i2 - 1];
                  t3[i2 - 1] = t3[i2], t3[i2] = l2;
                }
              } else {
                if (!c2.added && o2) {
                  var p2 = n3.slice(s2, s2 + c2.count);
                  p2 = p2.map(function(e4, t4) {
                    var n4 = r3[a2 + t4];
                    return n4.length > e4.length ? n4 : e4;
                  }), c2.value = e3.join(p2);
                } else
                  c2.value = e3.join(n3.slice(s2, s2 + c2.count));
                s2 += c2.count, c2.added || (a2 += c2.count);
              }
            }
            var f2 = t3[u2 - 1];
            return u2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e3.equals("", f2.value) && (t3[u2 - 2].value += f2.value, t3.pop()), t3;
          }
          function r2(e3) {
            return { newPos: e3.newPos, components: e3.components.slice(0) };
          }
          Object.defineProperty(e2, "__esModule", { value: true }), e2.default = t2, t2.prototype = { diff: function(e3, t3) {
            var o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = o2.callback;
            typeof o2 == "function" && (i2 = o2, o2 = {}), this.options = o2;
            var u2 = this;
            function s2(e4) {
              return i2 ? (setTimeout(function() {
                i2(void 0, e4);
              }, 0), true) : e4;
            }
            e3 = this.castInput(e3), t3 = this.castInput(t3), e3 = this.removeEmpty(this.tokenize(e3));
            var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e3.length, l2 = 1, p2 = a2 + c2, f2 = [{ newPos: -1, components: [] }], d2 = this.extractCommon(f2[0], t3, e3, 0);
            if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
              return s2([{ value: this.join(t3), count: t3.length }]);
            function h2() {
              for (var o3 = -1 * l2; o3 <= l2; o3 += 2) {
                var i3 = void 0, p3 = f2[o3 - 1], d3 = f2[o3 + 1], h3 = (d3 ? d3.newPos : 0) - o3;
                p3 && (f2[o3 - 1] = void 0);
                var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
                if (g3 || m2) {
                  if (!g3 || m2 && p3.newPos < d3.newPos ? (i3 = r2(d3), u2.pushComponent(i3.components, void 0, true)) : ((i3 = p3).newPos++, u2.pushComponent(i3.components, true, void 0)), h3 = u2.extractCommon(i3, t3, e3, o3), i3.newPos + 1 >= a2 && h3 + 1 >= c2)
                    return s2(n2(u2, i3.components, t3, e3, u2.useLongestToken));
                  f2[o3] = i3;
                } else
                  f2[o3] = void 0;
              }
              l2++;
            }
            if (i2)
              !function e4() {
                setTimeout(function() {
                  if (l2 > p2)
                    return i2();
                  h2() || e4();
                }, 0);
              }();
            else
              for (; l2 <= p2; ) {
                var g2 = h2();
                if (g2)
                  return g2;
              }
          }, pushComponent: function(e3, t3, n3) {
            var r3 = e3[e3.length - 1];
            r3 && r3.added === t3 && r3.removed === n3 ? e3[e3.length - 1] = { count: r3.count + 1, added: t3, removed: n3 } : e3.push({ count: 1, added: t3, removed: n3 });
          }, extractCommon: function(e3, t3, n3, r3) {
            for (var o2 = t3.length, i2 = n3.length, u2 = e3.newPos, s2 = u2 - r3, a2 = 0; u2 + 1 < o2 && s2 + 1 < i2 && this.equals(t3[u2 + 1], n3[s2 + 1]); )
              u2++, s2++, a2++;
            return a2 && e3.components.push({ count: a2 }), e3.newPos = u2, s2;
          }, equals: function(e3, t3) {
            return this.options.comparator ? this.options.comparator(e3, t3) : e3 === t3 || this.options.ignoreCase && e3.toLowerCase() === t3.toLowerCase();
          }, removeEmpty: function(e3) {
            for (var t3 = [], n3 = 0; n3 < e3.length; n3++)
              e3[n3] && t3.push(e3[n3]);
            return t3;
          }, castInput: function(e3) {
            return e3;
          }, tokenize: function(e3) {
            return e3.split("");
          }, join: function(e3) {
            return e3.join("");
          } };
        }(o);
        var i, u = {};
        Object.defineProperty(u, "__esModule", { value: true }), u.diffChars = function(e2, t2, n2) {
          return s.diff(e2, t2, n2);
        }, u.characterDiff = void 0;
        var s = new ((i = o) && i.__esModule ? i : { default: i }).default();
        u.characterDiff = s;
        var a = {}, c = {};
        Object.defineProperty(c, "__esModule", { value: true }), c.generateOptions = function(e2, t2) {
          if (typeof e2 == "function")
            t2.callback = e2;
          else if (e2)
            for (var n2 in e2)
              e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
          return t2;
        }, Object.defineProperty(a, "__esModule", { value: true }), a.diffWords = function(e2, t2, n2) {
          return n2 = (0, p.generateOptions)(n2, { ignoreWhitespace: true }), h.diff(e2, t2, n2);
        }, a.diffWordsWithSpace = function(e2, t2, n2) {
          return h.diff(e2, t2, n2);
        }, a.wordDiff = void 0;
        var l = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o), p = c;
        var f = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, d = /\S/, h = new l.default();
        a.wordDiff = h, h.equals = function(e2, t2) {
          return this.options.ignoreCase && (e2 = e2.toLowerCase(), t2 = t2.toLowerCase()), e2 === t2 || this.options.ignoreWhitespace && !d.test(e2) && !d.test(t2);
        }, h.tokenize = function(e2) {
          for (var t2 = e2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n2 = 0; n2 < t2.length - 1; n2++)
            !t2[n2 + 1] && t2[n2 + 2] && f.test(t2[n2]) && f.test(t2[n2 + 2]) && (t2[n2] += t2[n2 + 2], t2.splice(n2 + 1, 2), n2--);
          return t2;
        };
        var g = {};
        Object.defineProperty(g, "__esModule", { value: true }), g.diffLines = function(e2, t2, n2) {
          return D.diff(e2, t2, n2);
        }, g.diffTrimmedLines = function(e2, t2, n2) {
          var r2 = (0, y.generateOptions)(n2, { ignoreWhitespace: true });
          return D.diff(e2, t2, r2);
        }, g.lineDiff = void 0;
        var m = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o), y = c;
        var D = new m.default();
        g.lineDiff = D, D.tokenize = function(e2) {
          var t2 = [], n2 = e2.split(/(\n|\r\n)/);
          n2[n2.length - 1] || n2.pop();
          for (var r2 = 0; r2 < n2.length; r2++) {
            var o2 = n2[r2];
            r2 % 2 && !this.options.newlineIsToken ? t2[t2.length - 1] += o2 : (this.options.ignoreWhitespace && (o2 = o2.trim()), t2.push(o2));
          }
          return t2;
        };
        var E = {};
        Object.defineProperty(E, "__esModule", { value: true }), E.diffSentences = function(e2, t2, n2) {
          return b.diff(e2, t2, n2);
        }, E.sentenceDiff = void 0;
        var C = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o);
        var b = new C.default();
        E.sentenceDiff = b, b.tokenize = function(e2) {
          return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
        };
        var v = {};
        Object.defineProperty(v, "__esModule", { value: true }), v.diffCss = function(e2, t2, n2) {
          return F.diff(e2, t2, n2);
        }, v.cssDiff = void 0;
        var A = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o);
        var F = new A.default();
        v.cssDiff = F, F.tokenize = function(e2) {
          return e2.split(/([{}:;,]|\s+)/);
        };
        var x = function(e2) {
          return e2 && e2.Math == Math && e2;
        }, S = x(typeof globalThis == "object" && globalThis) || x(typeof window == "object" && window) || x(typeof self == "object" && self) || x(typeof e == "object" && e) || function() {
          return this;
        }() || Function("return this")(), w = {}, T = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        }, B = !T(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        }), N = Function.prototype.call, k = N.bind ? N.bind(N) : function() {
          return N.apply(N, arguments);
        }, P = {}, O = {}.propertyIsEnumerable, I = Object.getOwnPropertyDescriptor, L = I && !O.call({ 1: 2 }, 1);
        P.f = L ? function(e2) {
          var t2 = I(this, e2);
          return !!t2 && t2.enumerable;
        } : O;
        var j, _, M = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        }, R = Function.prototype, V = R.bind, $ = R.call, W = V && V.bind($), q = V ? function(e2) {
          return e2 && W($, e2);
        } : function(e2) {
          return e2 && function() {
            return $.apply(e2, arguments);
          };
        }, U = q, z = U({}.toString), G = U("".slice), H = function(e2) {
          return G(z(e2), 8, -1);
        }, J = q, X = T, Y = H, K = S.Object, Q = J("".split), Z = X(function() {
          return !K("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return Y(e2) == "String" ? Q(e2, "") : K(e2);
        } : K, ee = S.TypeError, te = function(e2) {
          if (e2 == null)
            throw ee("Can't call method on " + e2);
          return e2;
        }, ne = Z, re = te, oe = function(e2) {
          return ne(re(e2));
        }, ie = function(e2) {
          return typeof e2 == "function";
        }, ue = ie, se = function(e2) {
          return typeof e2 == "object" ? e2 !== null : ue(e2);
        }, ae = S, ce = ie, le = function(e2) {
          return ce(e2) ? e2 : void 0;
        }, pe = function(e2, t2) {
          return arguments.length < 2 ? le(ae[e2]) : ae[e2] && ae[e2][t2];
        }, fe = q({}.isPrototypeOf), de = pe("navigator", "userAgent") || "", he = S, ge = de, me = he.process, ye = he.Deno, De = me && me.versions || ye && ye.version, Ee = De && De.v8;
        Ee && (_ = (j = Ee.split("."))[0] > 0 && j[0] < 4 ? 1 : +(j[0] + j[1])), !_ && ge && (!(j = ge.match(/Edge\/(\d+)/)) || j[1] >= 74) && (j = ge.match(/Chrome\/(\d+)/)) && (_ = +j[1]);
        var Ce = _, be = Ce, ve = T, Ae = !!Object.getOwnPropertySymbols && !ve(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && be && be < 41;
        }), Fe = Ae && !Symbol.sham && typeof Symbol.iterator == "symbol", xe = pe, Se = ie, we = fe, Te = Fe, Be = S.Object, Ne = Te ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var t2 = xe("Symbol");
          return Se(t2) && we(t2.prototype, Be(e2));
        }, ke = S.String, Pe = function(e2) {
          try {
            return ke(e2);
          } catch (e3) {
            return "Object";
          }
        }, Oe = ie, Ie = Pe, Le = S.TypeError, je = function(e2) {
          if (Oe(e2))
            return e2;
          throw Le(Ie(e2) + " is not a function");
        }, _e = je, Me = function(e2, t2) {
          var n2 = e2[t2];
          return n2 == null ? void 0 : _e(n2);
        }, Re = k, Ve = ie, $e = se, We = S.TypeError, qe = { exports: {} }, Ue = S, ze = Object.defineProperty, Ge = function(e2, t2) {
          try {
            ze(Ue, e2, { value: t2, configurable: true, writable: true });
          } catch (n2) {
            Ue[e2] = t2;
          }
          return t2;
        }, He = Ge, Je = "__core-js_shared__", Xe = S[Je] || He(Je, {}), Ye = Xe;
        (qe.exports = function(e2, t2) {
          return Ye[e2] || (Ye[e2] = t2 !== void 0 ? t2 : {});
        })("versions", []).push({ version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
        var Ke = te, Qe = S.Object, Ze = function(e2) {
          return Qe(Ke(e2));
        }, et = Ze, tt = q({}.hasOwnProperty), nt = Object.hasOwn || function(e2, t2) {
          return tt(et(e2), t2);
        }, rt = q, ot = 0, it = Math.random(), ut = rt(1 .toString), st = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + ut(++ot + it, 36);
        }, at = S, ct = qe.exports, lt = nt, pt = st, ft = Ae, dt = Fe, ht = ct("wks"), gt = at.Symbol, mt = gt && gt.for, yt = dt ? gt : gt && gt.withoutSetter || pt, Dt = function(e2) {
          if (!lt(ht, e2) || !ft && typeof ht[e2] != "string") {
            var t2 = "Symbol." + e2;
            ft && lt(gt, e2) ? ht[e2] = gt[e2] : ht[e2] = dt && mt ? mt(t2) : yt(t2);
          }
          return ht[e2];
        }, Et = k, Ct = se, bt = Ne, vt = Me, At = function(e2, t2) {
          var n2, r2;
          if (t2 === "string" && Ve(n2 = e2.toString) && !$e(r2 = Re(n2, e2)))
            return r2;
          if (Ve(n2 = e2.valueOf) && !$e(r2 = Re(n2, e2)))
            return r2;
          if (t2 !== "string" && Ve(n2 = e2.toString) && !$e(r2 = Re(n2, e2)))
            return r2;
          throw We("Can't convert object to primitive value");
        }, Ft = Dt, xt = S.TypeError, St = Ft("toPrimitive"), wt = function(e2, t2) {
          if (!Ct(e2) || bt(e2))
            return e2;
          var n2, r2 = vt(e2, St);
          if (r2) {
            if (t2 === void 0 && (t2 = "default"), n2 = Et(r2, e2, t2), !Ct(n2) || bt(n2))
              return n2;
            throw xt("Can't convert object to primitive value");
          }
          return t2 === void 0 && (t2 = "number"), At(e2, t2);
        }, Tt = Ne, Bt = function(e2) {
          var t2 = wt(e2, "string");
          return Tt(t2) ? t2 : t2 + "";
        }, Nt = se, kt = S.document, Pt = Nt(kt) && Nt(kt.createElement), Ot = function(e2) {
          return Pt ? kt.createElement(e2) : {};
        }, It = Ot, Lt = !B && !T(function() {
          return Object.defineProperty(It("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        }), jt = B, _t = k, Mt = P, Rt = M, Vt = oe, $t = Bt, Wt = nt, qt = Lt, Ut = Object.getOwnPropertyDescriptor;
        w.f = jt ? Ut : function(e2, t2) {
          if (e2 = Vt(e2), t2 = $t(t2), qt)
            try {
              return Ut(e2, t2);
            } catch (e3) {
            }
          if (Wt(e2, t2))
            return Rt(!_t(Mt.f, e2, t2), e2[t2]);
        };
        var zt = {}, Gt = S, Ht = se, Jt = Gt.String, Xt = Gt.TypeError, Yt = function(e2) {
          if (Ht(e2))
            return e2;
          throw Xt(Jt(e2) + " is not an object");
        }, Kt = B, Qt = Lt, Zt = Yt, en = Bt, tn = S.TypeError, nn = Object.defineProperty;
        zt.f = Kt ? nn : function(e2, t2, n2) {
          if (Zt(e2), t2 = en(t2), Zt(n2), Qt)
            try {
              return nn(e2, t2, n2);
            } catch (e3) {
            }
          if ("get" in n2 || "set" in n2)
            throw tn("Accessors not supported");
          return "value" in n2 && (e2[t2] = n2.value), e2;
        };
        var rn = zt, on = M, un = B ? function(e2, t2, n2) {
          return rn.f(e2, t2, on(1, n2));
        } : function(e2, t2, n2) {
          return e2[t2] = n2, e2;
        }, sn = { exports: {} }, an = ie, cn = Xe, ln = q(Function.toString);
        an(cn.inspectSource) || (cn.inspectSource = function(e2) {
          return ln(e2);
        });
        var pn, fn, dn, hn = cn.inspectSource, gn = ie, mn = hn, yn = S.WeakMap, Dn = gn(yn) && /native code/.test(mn(yn)), En = qe.exports, Cn = st, bn = En("keys"), vn = function(e2) {
          return bn[e2] || (bn[e2] = Cn(e2));
        }, An = {}, Fn = Dn, xn = S, Sn = q, wn = se, Tn = un, Bn = nt, Nn = Xe, kn = vn, Pn = An, On = "Object already initialized", In = xn.TypeError, Ln = xn.WeakMap;
        if (Fn || Nn.state) {
          var jn = Nn.state || (Nn.state = new Ln()), _n = Sn(jn.get), Mn = Sn(jn.has), Rn = Sn(jn.set);
          pn = function(e2, t2) {
            if (Mn(jn, e2))
              throw new In(On);
            return t2.facade = e2, Rn(jn, e2, t2), t2;
          }, fn = function(e2) {
            return _n(jn, e2) || {};
          }, dn = function(e2) {
            return Mn(jn, e2);
          };
        } else {
          var Vn = kn("state");
          Pn[Vn] = true, pn = function(e2, t2) {
            if (Bn(e2, Vn))
              throw new In(On);
            return t2.facade = e2, Tn(e2, Vn, t2), t2;
          }, fn = function(e2) {
            return Bn(e2, Vn) ? e2[Vn] : {};
          }, dn = function(e2) {
            return Bn(e2, Vn);
          };
        }
        var $n = { set: pn, get: fn, has: dn, enforce: function(e2) {
          return dn(e2) ? fn(e2) : pn(e2, {});
        }, getterFor: function(e2) {
          return function(t2) {
            var n2;
            if (!wn(t2) || (n2 = fn(t2)).type !== e2)
              throw In("Incompatible receiver, " + e2 + " required");
            return n2;
          };
        } }, Wn = B, qn = nt, Un = Function.prototype, zn = Wn && Object.getOwnPropertyDescriptor, Gn = qn(Un, "name"), Hn = Gn && function() {
        }.name === "something", Jn = Gn && (!Wn || Wn && zn(Un, "name").configurable), Xn = S, Yn = ie, Kn = nt, Qn = un, Zn = Ge, er = hn, tr = { EXISTS: Gn, PROPER: Hn, CONFIGURABLE: Jn }.CONFIGURABLE, nr = $n.get, rr = $n.enforce, or = String(String).split("String");
        (sn.exports = function(e2, t2, n2, r2) {
          var o2, i2 = !!r2 && !!r2.unsafe, u2 = !!r2 && !!r2.enumerable, s2 = !!r2 && !!r2.noTargetGet, a2 = r2 && r2.name !== void 0 ? r2.name : t2;
          Yn(n2) && (String(a2).slice(0, 7) === "Symbol(" && (a2 = "[" + String(a2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Kn(n2, "name") || tr && n2.name !== a2) && Qn(n2, "name", a2), (o2 = rr(n2)).source || (o2.source = or.join(typeof a2 == "string" ? a2 : ""))), e2 !== Xn ? (i2 ? !s2 && e2[t2] && (u2 = true) : delete e2[t2], u2 ? e2[t2] = n2 : Qn(e2, t2, n2)) : u2 ? e2[t2] = n2 : Zn(t2, n2);
        })(Function.prototype, "toString", function() {
          return Yn(this) && nr(this).source || er(this);
        });
        var ir = {}, ur = Math.ceil, sr = Math.floor, ar = function(e2) {
          var t2 = +e2;
          return t2 != t2 || t2 === 0 ? 0 : (t2 > 0 ? sr : ur)(t2);
        }, cr = ar, lr = Math.max, pr = Math.min, fr = ar, dr = Math.min, hr = function(e2) {
          return e2 > 0 ? dr(fr(e2), 9007199254740991) : 0;
        }, gr = function(e2) {
          return hr(e2.length);
        }, mr = oe, yr = function(e2, t2) {
          var n2 = cr(e2);
          return n2 < 0 ? lr(n2 + t2, 0) : pr(n2, t2);
        }, Dr = gr, Er = function(e2) {
          return function(t2, n2, r2) {
            var o2, i2 = mr(t2), u2 = Dr(i2), s2 = yr(r2, u2);
            if (e2 && n2 != n2) {
              for (; u2 > s2; )
                if ((o2 = i2[s2++]) != o2)
                  return true;
            } else
              for (; u2 > s2; s2++)
                if ((e2 || s2 in i2) && i2[s2] === n2)
                  return e2 || s2 || 0;
            return !e2 && -1;
          };
        }, Cr = { includes: Er(true), indexOf: Er(false) }, br = nt, vr = oe, Ar = Cr.indexOf, Fr = An, xr = q([].push), Sr = function(e2, t2) {
          var n2, r2 = vr(e2), o2 = 0, i2 = [];
          for (n2 in r2)
            !br(Fr, n2) && br(r2, n2) && xr(i2, n2);
          for (; t2.length > o2; )
            br(r2, n2 = t2[o2++]) && (~Ar(i2, n2) || xr(i2, n2));
          return i2;
        }, wr = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Tr = Sr, Br = wr.concat("length", "prototype");
        ir.f = Object.getOwnPropertyNames || function(e2) {
          return Tr(e2, Br);
        };
        var Nr = {};
        Nr.f = Object.getOwnPropertySymbols;
        var kr = pe, Pr = ir, Or = Nr, Ir = Yt, Lr = q([].concat), jr = kr("Reflect", "ownKeys") || function(e2) {
          var t2 = Pr.f(Ir(e2)), n2 = Or.f;
          return n2 ? Lr(t2, n2(e2)) : t2;
        }, _r = nt, Mr = jr, Rr = w, Vr = zt, $r = T, Wr = ie, qr = /#|\.prototype\./, Ur = function(e2, t2) {
          var n2 = Gr[zr(e2)];
          return n2 == Jr || n2 != Hr && (Wr(t2) ? $r(t2) : !!t2);
        }, zr = Ur.normalize = function(e2) {
          return String(e2).replace(qr, ".").toLowerCase();
        }, Gr = Ur.data = {}, Hr = Ur.NATIVE = "N", Jr = Ur.POLYFILL = "P", Xr = Ur, Yr = S, Kr = w.f, Qr = un, Zr = sn.exports, eo = Ge, to = function(e2, t2) {
          for (var n2 = Mr(t2), r2 = Vr.f, o2 = Rr.f, i2 = 0; i2 < n2.length; i2++) {
            var u2 = n2[i2];
            _r(e2, u2) || r2(e2, u2, o2(t2, u2));
          }
        }, no = Xr, ro = function(e2, t2) {
          var n2, r2, o2, i2, u2, s2 = e2.target, a2 = e2.global, c2 = e2.stat;
          if (n2 = a2 ? Yr : c2 ? Yr[s2] || eo(s2, {}) : (Yr[s2] || {}).prototype)
            for (r2 in t2) {
              if (i2 = t2[r2], o2 = e2.noTargetGet ? (u2 = Kr(n2, r2)) && u2.value : n2[r2], !no(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e2.forced) && o2 !== void 0) {
                if (typeof i2 == typeof o2)
                  continue;
                to(i2, o2);
              }
              (e2.sham || o2 && o2.sham) && Qr(i2, "sham", true), Zr(n2, r2, i2, e2);
            }
        }, oo = {};
        oo[Dt("toStringTag")] = "z";
        var io = S, uo = String(oo) === "[object z]", so = ie, ao = H, co = Dt("toStringTag"), lo = io.Object, po = ao(function() {
          return arguments;
        }()) == "Arguments", fo = uo ? ao : function(e2) {
          var t2, n2, r2;
          return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (n2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = lo(e2), co)) == "string" ? n2 : po ? ao(t2) : (r2 = ao(t2)) == "Object" && so(t2.callee) ? "Arguments" : r2;
        }, ho = fo, go = S.String, mo = q([].slice), yo = Math.floor, Do = function(e2, t2) {
          var n2 = e2.length, r2 = yo(n2 / 2);
          return n2 < 8 ? Eo(e2, t2) : Co(e2, Do(mo(e2, 0, r2), t2), Do(mo(e2, r2), t2), t2);
        }, Eo = function(e2, t2) {
          for (var n2, r2, o2 = e2.length, i2 = 1; i2 < o2; ) {
            for (r2 = i2, n2 = e2[i2]; r2 && t2(e2[r2 - 1], n2) > 0; )
              e2[r2] = e2[--r2];
            r2 !== i2++ && (e2[r2] = n2);
          }
          return e2;
        }, Co = function(e2, t2, n2, r2) {
          for (var o2 = t2.length, i2 = n2.length, u2 = 0, s2 = 0; u2 < o2 || s2 < i2; )
            e2[u2 + s2] = u2 < o2 && s2 < i2 ? r2(t2[u2], n2[s2]) <= 0 ? t2[u2++] : n2[s2++] : u2 < o2 ? t2[u2++] : n2[s2++];
          return e2;
        }, bo = Do, vo = T, Ao = de.match(/firefox\/(\d+)/i), Fo = !!Ao && +Ao[1], xo = /MSIE|Trident/.test(de), So = de.match(/AppleWebKit\/(\d+)\./), wo = !!So && +So[1], To = ro, Bo = q, No = je, ko = Ze, Po = gr, Oo = function(e2) {
          if (ho(e2) === "Symbol")
            throw TypeError("Cannot convert a Symbol value to a string");
          return go(e2);
        }, Io = T, Lo = bo, jo = function(e2, t2) {
          var n2 = [][e2];
          return !!n2 && vo(function() {
            n2.call(null, t2 || function() {
              throw 1;
            }, 1);
          });
        }, _o = Fo, Mo = xo, Ro = Ce, Vo = wo, $o = [], Wo = Bo($o.sort), qo = Bo($o.push), Uo = Io(function() {
          $o.sort(void 0);
        }), zo = Io(function() {
          $o.sort(null);
        }), Go = jo("sort"), Ho = !Io(function() {
          if (Ro)
            return Ro < 70;
          if (!(_o && _o > 3)) {
            if (Mo)
              return true;
            if (Vo)
              return Vo < 603;
            var e2, t2, n2, r2, o2 = "";
            for (e2 = 65; e2 < 76; e2++) {
              switch (t2 = String.fromCharCode(e2), e2) {
                case 66:
                case 69:
                case 70:
                case 72:
                  n2 = 3;
                  break;
                case 68:
                case 71:
                  n2 = 4;
                  break;
                default:
                  n2 = 2;
              }
              for (r2 = 0; r2 < 47; r2++)
                $o.push({ k: t2 + r2, v: n2 });
            }
            for ($o.sort(function(e3, t3) {
              return t3.v - e3.v;
            }), r2 = 0; r2 < $o.length; r2++)
              t2 = $o[r2].k.charAt(0), o2.charAt(o2.length - 1) !== t2 && (o2 += t2);
            return o2 !== "DGBEFHACIJK";
          }
        });
        To({ target: "Array", proto: true, forced: Uo || !zo || !Go || !Ho }, { sort: function(e2) {
          e2 !== void 0 && No(e2);
          var t2 = ko(this);
          if (Ho)
            return e2 === void 0 ? Wo(t2) : Wo(t2, e2);
          var n2, r2, o2 = [], i2 = Po(t2);
          for (r2 = 0; r2 < i2; r2++)
            r2 in t2 && qo(o2, t2[r2]);
          for (Lo(o2, function(e3) {
            return function(t3, n3) {
              return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, n3) || 0 : Oo(t3) > Oo(n3) ? 1 : -1;
            };
          }(e2)), n2 = o2.length, r2 = 0; r2 < n2; )
            t2[r2] = o2[r2++];
          for (; r2 < i2; )
            delete t2[r2++];
          return t2;
        } });
        var Jo = {};
        Object.defineProperty(Jo, "__esModule", { value: true }), Jo.diffJson = function(e2, t2, n2) {
          return Zo.diff(e2, t2, n2);
        }, Jo.canonicalize = ei, Jo.jsonDiff = void 0;
        var Xo = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o), Yo = g;
        function Ko(e2) {
          return Ko = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          }, Ko(e2);
        }
        var Qo = Object.prototype.toString, Zo = new Xo.default();
        function ei(e2, t2, n2, r2, o2) {
          var i2, u2;
          for (t2 = t2 || [], n2 = n2 || [], r2 && (e2 = r2(o2, e2)), i2 = 0; i2 < t2.length; i2 += 1)
            if (t2[i2] === e2)
              return n2[i2];
          if (Qo.call(e2) === "[object Array]") {
            for (t2.push(e2), u2 = new Array(e2.length), n2.push(u2), i2 = 0; i2 < e2.length; i2 += 1)
              u2[i2] = ei(e2[i2], t2, n2, r2, o2);
            return t2.pop(), n2.pop(), u2;
          }
          if (e2 && e2.toJSON && (e2 = e2.toJSON()), Ko(e2) === "object" && e2 !== null) {
            t2.push(e2), u2 = {}, n2.push(u2);
            var s2, a2 = [];
            for (s2 in e2)
              e2.hasOwnProperty(s2) && a2.push(s2);
            for (a2.sort(), i2 = 0; i2 < a2.length; i2 += 1)
              u2[s2 = a2[i2]] = ei(e2[s2], t2, n2, r2, s2);
            t2.pop(), n2.pop();
          } else
            u2 = e2;
          return u2;
        }
        Jo.jsonDiff = Zo, Zo.useLongestToken = true, Zo.tokenize = Yo.lineDiff.tokenize, Zo.castInput = function(e2) {
          var t2 = this.options, n2 = t2.undefinedReplacement, r2 = t2.stringifyReplacer, o2 = r2 === void 0 ? function(e3, t3) {
            return t3 === void 0 ? n2 : t3;
          } : r2;
          return typeof e2 == "string" ? e2 : JSON.stringify(ei(e2, null, null, o2), o2, "  ");
        }, Zo.equals = function(e2, t2) {
          return Xo.default.prototype.equals.call(Zo, e2.replace(/,([\r\n])/g, "$1"), t2.replace(/,([\r\n])/g, "$1"));
        };
        var ti = {};
        Object.defineProperty(ti, "__esModule", { value: true }), ti.diffArrays = function(e2, t2, n2) {
          return ri.diff(e2, t2, n2);
        }, ti.arrayDiff = void 0;
        var ni = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(o);
        var ri = new ni.default();
        ti.arrayDiff = ri, ri.tokenize = function(e2) {
          return e2.slice();
        }, ri.join = ri.removeEmpty = function(e2) {
          return e2;
        };
        var oi = {}, ii = {};
        Object.defineProperty(ii, "__esModule", { value: true }), ii.parsePatch = function(e2) {
          var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], o2 = [], i2 = 0;
          function u2() {
            var e3 = {};
            for (o2.push(e3); i2 < n2.length; ) {
              var r3 = n2[i2];
              if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
                break;
              var u3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
              u3 && (e3.index = u3[1]), i2++;
            }
            for (s2(e3), s2(e3), e3.hunks = []; i2 < n2.length; ) {
              var c2 = n2[i2];
              if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
                break;
              if (/^@@/.test(c2))
                e3.hunks.push(a2());
              else {
                if (c2 && t2.strict)
                  throw new Error("Unknown line " + (i2 + 1) + " " + JSON.stringify(c2));
                i2++;
              }
            }
          }
          function s2(e3) {
            var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[i2]);
            if (t3) {
              var r3 = t3[1] === "---" ? "old" : "new", o3 = t3[2].split("	", 2), u3 = o3[0].replace(/\\\\/g, "\\");
              /^".*"$/.test(u3) && (u3 = u3.substr(1, u3.length - 2)), e3[r3 + "FileName"] = u3, e3[r3 + "Header"] = (o3[1] || "").trim(), i2++;
            }
          }
          function a2() {
            var e3 = i2, o3 = n2[i2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), u3 = { oldStart: +o3[1], oldLines: o3[2] === void 0 ? 1 : +o3[2], newStart: +o3[3], newLines: o3[4] === void 0 ? 1 : +o3[4], lines: [], linedelimiters: [] };
            u3.oldLines === 0 && (u3.oldStart += 1), u3.newLines === 0 && (u3.newStart += 1);
            for (var s3 = 0, a3 = 0; i2 < n2.length && !(n2[i2].indexOf("--- ") === 0 && i2 + 2 < n2.length && n2[i2 + 1].indexOf("+++ ") === 0 && n2[i2 + 2].indexOf("@@") === 0); i2++) {
              var c2 = n2[i2].length == 0 && i2 != n2.length - 1 ? " " : n2[i2][0];
              if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
                break;
              u3.lines.push(n2[i2]), u3.linedelimiters.push(r2[i2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
            }
            if (s3 || u3.newLines !== 1 || (u3.newLines = 0), a3 || u3.oldLines !== 1 || (u3.oldLines = 0), t2.strict) {
              if (s3 !== u3.newLines)
                throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
              if (a3 !== u3.oldLines)
                throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
            }
            return u3;
          }
          for (; i2 < n2.length; )
            u2();
          return o2;
        };
        var ui = {};
        !function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true }), e2.default = function(e3, t2, n2) {
            var r2 = true, o2 = false, i2 = false, u2 = 1;
            return function s2() {
              if (r2 && !i2) {
                if (o2 ? u2++ : r2 = false, e3 + u2 <= n2)
                  return u2;
                i2 = true;
              }
              if (!o2)
                return i2 || (r2 = true), t2 <= e3 - u2 ? -u2++ : (o2 = true, s2());
            };
          };
        }(ui), Object.defineProperty(oi, "__esModule", { value: true }), oi.applyPatch = ci, oi.applyPatches = function(e2, t2) {
          typeof e2 == "string" && (e2 = (0, si.parsePatch)(e2));
          var n2 = 0;
          !function r2() {
            var o2 = e2[n2++];
            if (!o2)
              return t2.complete();
            t2.loadFile(o2, function(e3, n3) {
              if (e3)
                return t2.complete(e3);
              var i2 = ci(n3, o2, t2);
              t2.patched(o2, i2, function(e4) {
                if (e4)
                  return t2.complete(e4);
                r2();
              });
            });
          }();
        };
        var si = ii, ai = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }(ui);
        function ci(e2, t2) {
          var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (typeof t2 == "string" && (t2 = (0, si.parsePatch)(t2)), Array.isArray(t2)) {
            if (t2.length > 1)
              throw new Error("applyPatch only works with a single input.");
            t2 = t2[0];
          }
          var r2, o2, i2 = e2.split(/\r\n|[\n\v\f\r\x85]/), u2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e3, t3, n3, r3) {
            return t3 === r3;
          }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
          function d2(e3, t3) {
            for (var n3 = 0; n3 < e3.lines.length; n3++) {
              var r3 = e3.lines[n3], o3 = r3.length > 0 ? r3[0] : " ", u3 = r3.length > 0 ? r3.substr(1) : r3;
              if (o3 === " " || o3 === "-") {
                if (!a2(t3 + 1, i2[t3], o3, u3) && ++c2 > l2)
                  return false;
                t3++;
              }
            }
            return true;
          }
          for (var h2 = 0; h2 < s2.length; h2++) {
            for (var g2 = s2[h2], m2 = i2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, ai.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
              if (d2(g2, D2 + y2)) {
                g2.offset = f2 += y2;
                break;
              }
            if (y2 === void 0)
              return false;
            p2 = g2.offset + g2.oldStart + g2.oldLines;
          }
          for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
            var v2 = s2[b2], A2 = v2.oldStart + v2.offset + C2 - 1;
            C2 += v2.newLines - v2.oldLines;
            for (var F2 = 0; F2 < v2.lines.length; F2++) {
              var x2 = v2.lines[F2], S2 = x2.length > 0 ? x2[0] : " ", w2 = x2.length > 0 ? x2.substr(1) : x2, T2 = v2.linedelimiters[F2];
              if (S2 === " ")
                A2++;
              else if (S2 === "-")
                i2.splice(A2, 1), u2.splice(A2, 1);
              else if (S2 === "+")
                i2.splice(A2, 0, w2), u2.splice(A2, 0, T2), A2++;
              else if (S2 === "\\") {
                var B2 = v2.lines[F2 - 1] ? v2.lines[F2 - 1][0] : null;
                B2 === "+" ? r2 = true : B2 === "-" && (o2 = true);
              }
            }
          }
          if (r2)
            for (; !i2[i2.length - 1]; )
              i2.pop(), u2.pop();
          else
            o2 && (i2.push(""), u2.push("\n"));
          for (var N2 = 0; N2 < i2.length - 1; N2++)
            i2[N2] = i2[N2] + u2[N2];
          return i2.join("");
        }
        var li = {}, pi = {};
        Object.defineProperty(pi, "__esModule", { value: true }), pi.structuredPatch = gi, pi.formatPatch = mi, pi.createTwoFilesPatch = yi, pi.createPatch = function(e2, t2, n2, r2, o2, i2) {
          return yi(e2, e2, t2, n2, r2, o2, i2);
        };
        var fi = g;
        function di(e2) {
          return function(e3) {
            if (Array.isArray(e3))
              return hi(e3);
          }(e2) || function(e3) {
            if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || function(e3, t2) {
            if (!e3)
              return;
            if (typeof e3 == "string")
              return hi(e3, t2);
            var n2 = Object.prototype.toString.call(e3).slice(8, -1);
            n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
            if (n2 === "Map" || n2 === "Set")
              return Array.from(e3);
            if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
              return hi(e3, t2);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function hi(e2, t2) {
          (t2 == null || t2 > e2.length) && (t2 = e2.length);
          for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
            r2[n2] = e2[n2];
          return r2;
        }
        function gi(e2, t2, n2, r2, o2, i2, u2) {
          u2 || (u2 = {}), u2.context === void 0 && (u2.context = 4);
          var s2 = (0, fi.diffLines)(n2, r2, u2);
          function a2(e3) {
            return e3.map(function(e4) {
              return " " + e4;
            });
          }
          s2.push({ value: "", lines: [] });
          for (var c2 = [], l2 = 0, p2 = 0, f2 = [], d2 = 1, h2 = 1, g2 = function(e3) {
            var t3 = s2[e3], o3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
            if (t3.lines = o3, t3.added || t3.removed) {
              var i3;
              if (!l2) {
                var g3 = s2[e3 - 1];
                l2 = d2, p2 = h2, g3 && (f2 = u2.context > 0 ? a2(g3.lines.slice(-u2.context)) : [], l2 -= f2.length, p2 -= f2.length);
              }
              (i3 = f2).push.apply(i3, di(o3.map(function(e4) {
                return (t3.added ? "+" : "-") + e4;
              }))), t3.added ? h2 += o3.length : d2 += o3.length;
            } else {
              if (l2)
                if (o3.length <= 2 * u2.context && e3 < s2.length - 2) {
                  var m3;
                  (m3 = f2).push.apply(m3, di(a2(o3)));
                } else {
                  var y2, D2 = Math.min(o3.length, u2.context);
                  (y2 = f2).push.apply(y2, di(a2(o3.slice(0, D2))));
                  var E2 = { oldStart: l2, oldLines: d2 - l2 + D2, newStart: p2, newLines: h2 - p2 + D2, lines: f2 };
                  if (e3 >= s2.length - 2 && o3.length <= u2.context) {
                    var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), v2 = o3.length == 0 && f2.length > E2.oldLines;
                    !C2 && v2 && n2.length > 0 && f2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || v2) && b2 || f2.push("\\ No newline at end of file");
                  }
                  c2.push(E2), l2 = 0, p2 = 0, f2 = [];
                }
              d2 += o3.length, h2 += o3.length;
            }
          }, m2 = 0; m2 < s2.length; m2++)
            g2(m2);
          return { oldFileName: e2, newFileName: t2, oldHeader: o2, newHeader: i2, hunks: c2 };
        }
        function mi(e2) {
          var t2 = [];
          e2.oldFileName == e2.newFileName && t2.push("Index: " + e2.oldFileName), t2.push("==================================================================="), t2.push("--- " + e2.oldFileName + (e2.oldHeader === void 0 ? "" : "	" + e2.oldHeader)), t2.push("+++ " + e2.newFileName + (e2.newHeader === void 0 ? "" : "	" + e2.newHeader));
          for (var n2 = 0; n2 < e2.hunks.length; n2++) {
            var r2 = e2.hunks[n2];
            r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
          }
          return t2.join("\n") + "\n";
        }
        function yi(e2, t2, n2, r2, o2, i2, u2) {
          return mi(gi(e2, t2, n2, r2, o2, i2, u2));
        }
        var Di = {};
        function Ei(e2, t2) {
          if (t2.length > e2.length)
            return false;
          for (var n2 = 0; n2 < t2.length; n2++)
            if (t2[n2] !== e2[n2])
              return false;
          return true;
        }
        Object.defineProperty(Di, "__esModule", { value: true }), Di.arrayEqual = function(e2, t2) {
          if (e2.length !== t2.length)
            return false;
          return Ei(e2, t2);
        }, Di.arrayStartsWith = Ei, Object.defineProperty(li, "__esModule", { value: true }), li.calcLineCount = xi, li.merge = function(e2, t2, n2) {
          e2 = Si(e2, n2), t2 = Si(t2, n2);
          var r2 = {};
          (e2.index || t2.index) && (r2.index = e2.index || t2.index);
          (e2.newFileName || t2.newFileName) && (wi(e2) ? wi(t2) ? (r2.oldFileName = Ti(r2, e2.oldFileName, t2.oldFileName), r2.newFileName = Ti(r2, e2.newFileName, t2.newFileName), r2.oldHeader = Ti(r2, e2.oldHeader, t2.oldHeader), r2.newHeader = Ti(r2, e2.newHeader, t2.newHeader)) : (r2.oldFileName = e2.oldFileName, r2.newFileName = e2.newFileName, r2.oldHeader = e2.oldHeader, r2.newHeader = e2.newHeader) : (r2.oldFileName = t2.oldFileName || e2.oldFileName, r2.newFileName = t2.newFileName || e2.newFileName, r2.oldHeader = t2.oldHeader || e2.oldHeader, r2.newHeader = t2.newHeader || e2.newHeader));
          r2.hunks = [];
          var o2 = 0, i2 = 0, u2 = 0, s2 = 0;
          for (; o2 < e2.hunks.length || i2 < t2.hunks.length; ) {
            var a2 = e2.hunks[o2] || { oldStart: 1 / 0 }, c2 = t2.hunks[i2] || { oldStart: 1 / 0 };
            if (Bi(a2, c2))
              r2.hunks.push(Ni(a2, u2)), o2++, s2 += a2.newLines - a2.oldLines;
            else if (Bi(c2, a2))
              r2.hunks.push(Ni(c2, s2)), i2++, u2 += c2.newLines - c2.oldLines;
            else {
              var l2 = { oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + u2, c2.oldStart + s2), newLines: 0, lines: [] };
              ki(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), i2++, o2++, r2.hunks.push(l2);
            }
          }
          return r2;
        };
        var Ci = pi, bi = ii, vi = Di;
        function Ai(e2) {
          return function(e3) {
            if (Array.isArray(e3))
              return Fi(e3);
          }(e2) || function(e3) {
            if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || function(e3, t2) {
            if (!e3)
              return;
            if (typeof e3 == "string")
              return Fi(e3, t2);
            var n2 = Object.prototype.toString.call(e3).slice(8, -1);
            n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
            if (n2 === "Map" || n2 === "Set")
              return Array.from(e3);
            if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
              return Fi(e3, t2);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function Fi(e2, t2) {
          (t2 == null || t2 > e2.length) && (t2 = e2.length);
          for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
            r2[n2] = e2[n2];
          return r2;
        }
        function xi(e2) {
          var t2 = Vi(e2.lines), n2 = t2.oldLines, r2 = t2.newLines;
          n2 !== void 0 ? e2.oldLines = n2 : delete e2.oldLines, r2 !== void 0 ? e2.newLines = r2 : delete e2.newLines;
        }
        function Si(e2, t2) {
          if (typeof e2 == "string") {
            if (/^@@/m.test(e2) || /^Index:/m.test(e2))
              return (0, bi.parsePatch)(e2)[0];
            if (!t2)
              throw new Error("Must provide a base reference or pass in a patch");
            return (0, Ci.structuredPatch)(void 0, void 0, t2, e2);
          }
          return e2;
        }
        function wi(e2) {
          return e2.newFileName && e2.newFileName !== e2.oldFileName;
        }
        function Ti(e2, t2, n2) {
          return t2 === n2 ? t2 : (e2.conflict = true, { mine: t2, theirs: n2 });
        }
        function Bi(e2, t2) {
          return e2.oldStart < t2.oldStart && e2.oldStart + e2.oldLines < t2.oldStart;
        }
        function Ni(e2, t2) {
          return { oldStart: e2.oldStart, oldLines: e2.oldLines, newStart: e2.newStart + t2, newLines: e2.newLines, lines: e2.lines };
        }
        function ki(e2, t2, n2, r2, o2) {
          var i2 = { offset: t2, lines: n2, index: 0 }, u2 = { offset: r2, lines: o2, index: 0 };
          for (Li(e2, i2, u2), Li(e2, u2, i2); i2.index < i2.lines.length && u2.index < u2.lines.length; ) {
            var s2 = i2.lines[i2.index], a2 = u2.lines[u2.index];
            if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
              if (s2[0] === "+" && a2[0] === " ") {
                var c2;
                (c2 = e2.lines).push.apply(c2, Ai(_i(i2)));
              } else if (a2[0] === "+" && s2[0] === " ") {
                var l2;
                (l2 = e2.lines).push.apply(l2, Ai(_i(u2)));
              } else
                s2[0] === "-" && a2[0] === " " ? Oi(e2, i2, u2) : a2[0] === "-" && s2[0] === " " ? Oi(e2, u2, i2, true) : s2 === a2 ? (e2.lines.push(s2), i2.index++, u2.index++) : Ii(e2, _i(i2), _i(u2));
            else
              Pi(e2, i2, u2);
          }
          ji(e2, i2), ji(e2, u2), xi(e2);
        }
        function Pi(e2, t2, n2) {
          var r2 = _i(t2), o2 = _i(n2);
          if (Mi(r2) && Mi(o2)) {
            var i2, u2;
            if ((0, vi.arrayStartsWith)(r2, o2) && Ri(n2, r2, r2.length - o2.length))
              return void (i2 = e2.lines).push.apply(i2, Ai(r2));
            if ((0, vi.arrayStartsWith)(o2, r2) && Ri(t2, o2, o2.length - r2.length))
              return void (u2 = e2.lines).push.apply(u2, Ai(o2));
          } else if ((0, vi.arrayEqual)(r2, o2)) {
            var s2;
            return void (s2 = e2.lines).push.apply(s2, Ai(r2));
          }
          Ii(e2, r2, o2);
        }
        function Oi(e2, t2, n2, r2) {
          var o2, i2 = _i(t2), u2 = function(e3, t3) {
            var n3 = [], r3 = [], o3 = 0, i3 = false, u3 = false;
            for (; o3 < t3.length && e3.index < e3.lines.length; ) {
              var s2 = e3.lines[e3.index], a2 = t3[o3];
              if (a2[0] === "+")
                break;
              if (i3 = i3 || s2[0] !== " ", r3.push(a2), o3++, s2[0] === "+")
                for (u3 = true; s2[0] === "+"; )
                  n3.push(s2), s2 = e3.lines[++e3.index];
              a2.substr(1) === s2.substr(1) ? (n3.push(s2), e3.index++) : u3 = true;
            }
            (t3[o3] || "")[0] === "+" && i3 && (u3 = true);
            if (u3)
              return n3;
            for (; o3 < t3.length; )
              r3.push(t3[o3++]);
            return { merged: r3, changes: n3 };
          }(n2, i2);
          u2.merged ? (o2 = e2.lines).push.apply(o2, Ai(u2.merged)) : Ii(e2, r2 ? u2 : i2, r2 ? i2 : u2);
        }
        function Ii(e2, t2, n2) {
          e2.conflict = true, e2.lines.push({ conflict: true, mine: t2, theirs: n2 });
        }
        function Li(e2, t2, n2) {
          for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
            var r2 = t2.lines[t2.index++];
            e2.lines.push(r2), t2.offset++;
          }
        }
        function ji(e2, t2) {
          for (; t2.index < t2.lines.length; ) {
            var n2 = t2.lines[t2.index++];
            e2.lines.push(n2);
          }
        }
        function _i(e2) {
          for (var t2 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length; ) {
            var r2 = e2.lines[e2.index];
            if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
              break;
            t2.push(r2), e2.index++;
          }
          return t2;
        }
        function Mi(e2) {
          return e2.reduce(function(e3, t2) {
            return e3 && t2[0] === "-";
          }, true);
        }
        function Ri(e2, t2, n2) {
          for (var r2 = 0; r2 < n2; r2++) {
            var o2 = t2[t2.length - n2 + r2].substr(1);
            if (e2.lines[e2.index + r2] !== " " + o2)
              return false;
          }
          return e2.index += n2, true;
        }
        function Vi(e2) {
          var t2 = 0, n2 = 0;
          return e2.forEach(function(e3) {
            if (typeof e3 != "string") {
              var r2 = Vi(e3.mine), o2 = Vi(e3.theirs);
              t2 !== void 0 && (r2.oldLines === o2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === o2.newLines ? n2 += r2.newLines : n2 = void 0);
            } else
              n2 === void 0 || e3[0] !== "+" && e3[0] !== " " || n2++, t2 === void 0 || e3[0] !== "-" && e3[0] !== " " || t2++;
          }), { oldLines: t2, newLines: n2 };
        }
        var $i = {};
        Object.defineProperty($i, "__esModule", { value: true }), $i.convertChangesToDMP = function(e2) {
          for (var t2, n2, r2 = [], o2 = 0; o2 < e2.length; o2++)
            t2 = e2[o2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
          return r2;
        };
        var Wi = {};
        function qi(e2) {
          var t2 = e2;
          return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
        }
        function Ui(e2) {
          return { type: "concat", parts: e2 };
        }
        function zi(e2) {
          return { type: "indent", contents: e2 };
        }
        function Gi(e2, t2) {
          return { type: "align", contents: t2, n: e2 };
        }
        function Hi(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return { type: "group", id: t2.id, contents: e2, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates };
        }
        Object.defineProperty(Wi, "__esModule", { value: true }), Wi.convertChangesToXML = function(e2) {
          for (var t2 = [], n2 = 0; n2 < e2.length; n2++) {
            var r2 = e2[n2];
            r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(qi(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
          }
          return t2.join("");
        }, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true }), Object.defineProperty(e2, "Diff", { enumerable: true, get: function() {
            return t2.default;
          } }), Object.defineProperty(e2, "diffChars", { enumerable: true, get: function() {
            return n2.diffChars;
          } }), Object.defineProperty(e2, "diffWords", { enumerable: true, get: function() {
            return r2.diffWords;
          } }), Object.defineProperty(e2, "diffWordsWithSpace", { enumerable: true, get: function() {
            return r2.diffWordsWithSpace;
          } }), Object.defineProperty(e2, "diffLines", { enumerable: true, get: function() {
            return i2.diffLines;
          } }), Object.defineProperty(e2, "diffTrimmedLines", { enumerable: true, get: function() {
            return i2.diffTrimmedLines;
          } }), Object.defineProperty(e2, "diffSentences", { enumerable: true, get: function() {
            return s2.diffSentences;
          } }), Object.defineProperty(e2, "diffCss", { enumerable: true, get: function() {
            return c2.diffCss;
          } }), Object.defineProperty(e2, "diffJson", { enumerable: true, get: function() {
            return l2.diffJson;
          } }), Object.defineProperty(e2, "canonicalize", { enumerable: true, get: function() {
            return l2.canonicalize;
          } }), Object.defineProperty(e2, "diffArrays", { enumerable: true, get: function() {
            return p2.diffArrays;
          } }), Object.defineProperty(e2, "applyPatch", { enumerable: true, get: function() {
            return f2.applyPatch;
          } }), Object.defineProperty(e2, "applyPatches", { enumerable: true, get: function() {
            return f2.applyPatches;
          } }), Object.defineProperty(e2, "parsePatch", { enumerable: true, get: function() {
            return d2.parsePatch;
          } }), Object.defineProperty(e2, "merge", { enumerable: true, get: function() {
            return h2.merge;
          } }), Object.defineProperty(e2, "structuredPatch", { enumerable: true, get: function() {
            return m2.structuredPatch;
          } }), Object.defineProperty(e2, "createTwoFilesPatch", { enumerable: true, get: function() {
            return m2.createTwoFilesPatch;
          } }), Object.defineProperty(e2, "createPatch", { enumerable: true, get: function() {
            return m2.createPatch;
          } }), Object.defineProperty(e2, "convertChangesToDMP", { enumerable: true, get: function() {
            return y2.convertChangesToDMP;
          } }), Object.defineProperty(e2, "convertChangesToXML", { enumerable: true, get: function() {
            return D2.convertChangesToXML;
          } });
          var t2 = function(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }(o), n2 = u, r2 = a, i2 = g, s2 = E, c2 = v, l2 = Jo, p2 = ti, f2 = oi, d2 = ii, h2 = li, m2 = pi, y2 = $i, D2 = Wi;
        }(r);
        const Ji = { type: "break-parent" }, Xi = { type: "line", hard: true }, Yi = { type: "line", hard: true, literal: true }, Ki = Ui([Xi, Ji]), Qi = Ui([Yi, Ji]);
        var Zi = { concat: Ui, join: function(e2, t2) {
          const n2 = [];
          for (let r2 = 0; r2 < t2.length; r2++)
            r2 !== 0 && n2.push(e2), n2.push(t2[r2]);
          return Ui(n2);
        }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: Ki, literalline: Qi, group: Hi, conditionalGroup: function(e2, t2) {
          return Hi(e2[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e2 }));
        }, fill: function(e2) {
          return { type: "fill", parts: e2 };
        }, lineSuffix: function(e2) {
          return { type: "line-suffix", contents: e2 };
        }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: Ji, ifBreak: function(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return { type: "if-break", breakContents: e2, flatContents: t2, groupId: n2.groupId };
        }, trim: { type: "trim" }, indent: zi, indentIfBreak: function(e2, t2) {
          return { type: "indent-if-break", contents: e2, groupId: t2.groupId, negate: t2.negate };
        }, align: Gi, addAlignmentToDoc: function(e2, t2, n2) {
          let r2 = e2;
          if (t2 > 0) {
            for (let e3 = 0; e3 < Math.floor(t2 / n2); ++e3)
              r2 = zi(r2);
            r2 = Gi(t2 % n2, r2), r2 = Gi(Number.NEGATIVE_INFINITY, r2);
          }
          return r2;
        }, markAsRoot: function(e2) {
          return Gi({ type: "root" }, e2);
        }, dedentToRoot: function(e2) {
          return Gi(Number.NEGATIVE_INFINITY, e2);
        }, dedent: function(e2) {
          return Gi(-1, e2);
        }, hardlineWithoutBreakParent: Xi, literallineWithoutBreakParent: Yi, label: function(e2, t2) {
          return { type: "label", label: e2, contents: t2 };
        } }, eu = { exports: {} };
        const tu = function() {
          let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t2, e2 ? void 0 : "g");
        };
        var nu = { exports: {} };
        const ru = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
        nu.exports = ru, nu.exports.default = ru;
        const ou = (e2) => typeof e2 == "string" ? e2.replace(tu(), "") : e2, iu = nu.exports, uu = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        }, su = (e2) => {
          if (typeof e2 != "string" || e2.length === 0)
            return 0;
          if ((e2 = ou(e2)).length === 0)
            return 0;
          e2 = e2.replace(uu(), "  ");
          let t2 = 0;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const r2 = e2.codePointAt(n2);
            r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += iu(r2) ? 2 : 1));
          }
          return t2;
        };
        eu.exports = su, eu.exports.default = su;
        var au = (e2) => e2[e2.length - 1];
        function cu(e2, t2) {
          if (e2 == null)
            return {};
          var n2, r2, o2 = function(e3, t3) {
            if (e3 == null)
              return {};
            var n3, r3, o3 = {}, i3 = Object.keys(e3);
            for (r3 = 0; r3 < i3.length; r3++)
              n3 = i3[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e3[n3]);
            return o3;
          }(e2, t2);
          if (Object.getOwnPropertySymbols) {
            var i2 = Object.getOwnPropertySymbols(e2);
            for (r2 = 0; r2 < i2.length; r2++)
              n2 = i2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, n2) && (o2[n2] = e2[n2]);
          }
          return o2;
        }
        function lu(e2, t2) {
          return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(t2) } }));
        }
        var pu = H, fu = Array.isArray || function(e2) {
          return pu(e2) == "Array";
        }, du = je, hu = q(q.bind), gu = function(e2, t2) {
          return du(e2), t2 === void 0 ? e2 : hu ? hu(e2, t2) : function() {
            return e2.apply(t2, arguments);
          };
        }, mu = fu, yu = gr, Du = gu, Eu = S.TypeError, Cu = function(e2, t2, n2, r2, o2, i2, u2, s2) {
          for (var a2, c2, l2 = o2, p2 = 0, f2 = !!u2 && Du(u2, s2); p2 < r2; ) {
            if (p2 in n2) {
              if (a2 = f2 ? f2(n2[p2], p2, t2) : n2[p2], i2 > 0 && mu(a2))
                c2 = yu(a2), l2 = Cu(e2, t2, a2, c2, l2, i2 - 1) - 1;
              else {
                if (l2 >= 9007199254740991)
                  throw Eu("Exceed the acceptable array length");
                e2[l2] = a2;
              }
              l2++;
            }
            p2++;
          }
          return l2;
        }, bu = Cu, vu = q, Au = T, Fu = ie, xu = fo, Su = hn, wu = function() {
        }, Tu = [], Bu = pe("Reflect", "construct"), Nu = /^\s*(?:class|function)\b/, ku = vu(Nu.exec), Pu = !Nu.exec(wu), Ou = function(e2) {
          if (!Fu(e2))
            return false;
          try {
            return Bu(wu, Tu, e2), true;
          } catch (e3) {
            return false;
          }
        }, Iu = !Bu || Au(function() {
          var e2;
          return Ou(Ou.call) || !Ou(Object) || !Ou(function() {
            e2 = true;
          }) || e2;
        }) ? function(e2) {
          if (!Fu(e2))
            return false;
          switch (xu(e2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          return Pu || !!ku(Nu, Su(e2));
        } : Ou, Lu = S, ju = fu, _u = Iu, Mu = se, Ru = Dt("species"), Vu = Lu.Array, $u = function(e2) {
          var t2;
          return ju(e2) && (t2 = e2.constructor, (_u(t2) && (t2 === Vu || ju(t2.prototype)) || Mu(t2) && (t2 = t2[Ru]) === null) && (t2 = void 0)), t2 === void 0 ? Vu : t2;
        }, Wu = function(e2, t2) {
          return new ($u(e2))(t2 === 0 ? 0 : t2);
        }, qu = bu, Uu = je, zu = Ze, Gu = gr, Hu = Wu;
        ro({ target: "Array", proto: true }, { flatMap: function(e2) {
          var t2, n2 = zu(this), r2 = Gu(n2);
          return Uu(e2), (t2 = Hu(n2, 0)).length = qu(t2, n2, n2, r2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
        } });
        var Ju = {}, Xu = Ju, Yu = Dt("iterator"), Ku = Array.prototype, Qu = fo, Zu = Me, es = Ju, ts = Dt("iterator"), ns = function(e2) {
          if (e2 != null)
            return Zu(e2, ts) || Zu(e2, "@@iterator") || es[Qu(e2)];
        }, rs = k, os = je, is = Yt, us = Pe, ss = ns, as = S.TypeError, cs = k, ls = Yt, ps = Me, fs = gu, ds = k, hs = Yt, gs = Pe, ms = function(e2) {
          return e2 !== void 0 && (Xu.Array === e2 || Ku[Yu] === e2);
        }, ys = gr, Ds = fe, Es = function(e2, t2) {
          var n2 = arguments.length < 2 ? ss(e2) : t2;
          if (os(n2))
            return is(rs(n2, e2));
          throw as(us(e2) + " is not iterable");
        }, Cs = ns, bs = function(e2, t2, n2) {
          var r2, o2;
          ls(e2);
          try {
            if (!(r2 = ps(e2, "return"))) {
              if (t2 === "throw")
                throw n2;
              return n2;
            }
            r2 = cs(r2, e2);
          } catch (e3) {
            o2 = true, r2 = e3;
          }
          if (t2 === "throw")
            throw n2;
          if (o2)
            throw r2;
          return ls(r2), n2;
        }, vs = S.TypeError, As = function(e2, t2) {
          this.stopped = e2, this.result = t2;
        }, Fs = As.prototype, xs = Bt, Ss = zt, ws = M, Ts = function(e2, t2, n2) {
          var r2, o2, i2, u2, s2, a2, c2, l2 = n2 && n2.that, p2 = !(!n2 || !n2.AS_ENTRIES), f2 = !(!n2 || !n2.IS_ITERATOR), d2 = !(!n2 || !n2.INTERRUPTED), h2 = fs(t2, l2), g2 = function(e3) {
            return r2 && bs(r2, "normal", e3), new As(true, e3);
          }, m2 = function(e3) {
            return p2 ? (hs(e3), d2 ? h2(e3[0], e3[1], g2) : h2(e3[0], e3[1])) : d2 ? h2(e3, g2) : h2(e3);
          };
          if (f2)
            r2 = e2;
          else {
            if (!(o2 = Cs(e2)))
              throw vs(gs(e2) + " is not iterable");
            if (ms(o2)) {
              for (i2 = 0, u2 = ys(e2); u2 > i2; i2++)
                if ((s2 = m2(e2[i2])) && Ds(Fs, s2))
                  return s2;
              return new As(false);
            }
            r2 = Es(e2, o2);
          }
          for (a2 = r2.next; !(c2 = ds(a2, r2)).done; ) {
            try {
              s2 = m2(c2.value);
            } catch (e3) {
              bs(r2, "throw", e3);
            }
            if (typeof s2 == "object" && s2 && Ds(Fs, s2))
              return s2;
          }
          return new As(false);
        }, Bs = function(e2, t2, n2) {
          var r2 = xs(t2);
          r2 in e2 ? Ss.f(e2, r2, ws(0, n2)) : e2[r2] = n2;
        };
        ro({ target: "Object", stat: true }, { fromEntries: function(e2) {
          var t2 = {};
          return Ts(e2, function(e3, n2) {
            Bs(t2, e3, n2);
          }, { AS_ENTRIES: true }), t2;
        } });
        var Ns = Ns !== void 0 ? Ns : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
        function ks() {
          throw new Error("setTimeout has not been defined");
        }
        function Ps() {
          throw new Error("clearTimeout has not been defined");
        }
        var Os = ks, Is = Ps;
        function Ls(e2) {
          if (Os === setTimeout)
            return setTimeout(e2, 0);
          if ((Os === ks || !Os) && setTimeout)
            return Os = setTimeout, setTimeout(e2, 0);
          try {
            return Os(e2, 0);
          } catch (t2) {
            try {
              return Os.call(null, e2, 0);
            } catch (t3) {
              return Os.call(this, e2, 0);
            }
          }
        }
        typeof Ns.setTimeout == "function" && (Os = setTimeout), typeof Ns.clearTimeout == "function" && (Is = clearTimeout);
        var js, _s = [], Ms = false, Rs = -1;
        function Vs() {
          Ms && js && (Ms = false, js.length ? _s = js.concat(_s) : Rs = -1, _s.length && $s());
        }
        function $s() {
          if (!Ms) {
            var e2 = Ls(Vs);
            Ms = true;
            for (var t2 = _s.length; t2; ) {
              for (js = _s, _s = []; ++Rs < t2; )
                js && js[Rs].run();
              Rs = -1, t2 = _s.length;
            }
            js = null, Ms = false, function(e3) {
              if (Is === clearTimeout)
                return clearTimeout(e3);
              if ((Is === Ps || !Is) && clearTimeout)
                return Is = clearTimeout, clearTimeout(e3);
              try {
                Is(e3);
              } catch (t3) {
                try {
                  return Is.call(null, e3);
                } catch (t4) {
                  return Is.call(this, e3);
                }
              }
            }(e2);
          }
        }
        function Ws(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        Ws.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        function qs() {
        }
        var Us = qs, zs = qs, Gs = qs, Hs = qs, Js = qs, Xs = qs, Ys = qs;
        var Ks = Ns.performance || {}, Qs = Ks.now || Ks.mozNow || Ks.msNow || Ks.oNow || Ks.webkitNow || function() {
          return new Date().getTime();
        };
        var Zs = new Date();
        var ea = { nextTick: function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var n2 = 1; n2 < arguments.length; n2++)
              t2[n2 - 1] = arguments[n2];
          _s.push(new Ws(e2, t2)), _s.length !== 1 || Ms || Ls($s);
        }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Us, addListener: zs, once: Gs, off: Hs, removeListener: Js, removeAllListeners: Xs, emit: Ys, binding: function(e2) {
          throw new Error("process.binding is not supported");
        }, cwd: function() {
          return "/";
        }, chdir: function(e2) {
          throw new Error("process.chdir is not supported");
        }, umask: function() {
          return 0;
        }, hrtime: function(e2) {
          var t2 = 1e-3 * Qs.call(Ks), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
          return e2 && (n2 -= e2[0], (r2 -= e2[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
        }, platform: "browser", release: {}, config: {}, uptime: function() {
          return (new Date() - Zs) / 1e3;
        } }, ta = ea;
        const na = typeof ta == "object" && ta.env && ta.env.NODE_DEBUG && /\bsemver\b/i.test(ta.env.NODE_DEBUG) ? function() {
          for (var e2 = arguments.length, t2 = new Array(e2), n2 = 0; n2 < e2; n2++)
            t2[n2] = arguments[n2];
          return console.error("SEMVER", ...t2);
        } : () => {
        };
        var ra = na;
        var oa = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, ia = { exports: {} };
        !function(e2, t2) {
          const { MAX_SAFE_COMPONENT_LENGTH: n2 } = oa, r2 = ra, o2 = (t2 = e2.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
          let s2 = 0;
          const a2 = (e3, t3, n3) => {
            const a3 = s2++;
            r2(a3, t3), u2[e3] = a3, i2[a3] = t3, o2[a3] = new RegExp(t3, n3 ? "g" : void 0);
          };
          a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", "(".concat(i2[u2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIER], ")")), a2("MAINVERSIONLOOSE", "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[u2.NUMERICIDENTIFIERLOOSE], ")")), a2("PRERELEASEIDENTIFIER", "(?:".concat(i2[u2.NUMERICIDENTIFIER], "|").concat(i2[u2.NONNUMERICIDENTIFIER], ")")), a2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i2[u2.NUMERICIDENTIFIERLOOSE], "|").concat(i2[u2.NONNUMERICIDENTIFIER], ")")), a2("PRERELEASE", "(?:-(".concat(i2[u2.PRERELEASEIDENTIFIER], "(?:\\.").concat(i2[u2.PRERELEASEIDENTIFIER], ")*))")), a2("PRERELEASELOOSE", "(?:-?(".concat(i2[u2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i2[u2.PRERELEASEIDENTIFIERLOOSE], ")*))")), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", "(?:\\+(".concat(i2[u2.BUILDIDENTIFIER], "(?:\\.").concat(i2[u2.BUILDIDENTIFIER], ")*))")), a2("FULLPLAIN", "v?".concat(i2[u2.MAINVERSION]).concat(i2[u2.PRERELEASE], "?").concat(i2[u2.BUILD], "?")), a2("FULL", "^".concat(i2[u2.FULLPLAIN], "$")), a2("LOOSEPLAIN", "[v=\\s]*".concat(i2[u2.MAINVERSIONLOOSE]).concat(i2[u2.PRERELEASELOOSE], "?").concat(i2[u2.BUILD], "?")), a2("LOOSE", "^".concat(i2[u2.LOOSEPLAIN], "$")), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", "".concat(i2[u2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a2("XRANGEIDENTIFIER", "".concat(i2[u2.NUMERICIDENTIFIER], "|x|X|\\*")), a2("XRANGEPLAIN", "[v=\\s]*(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIER], ")") + "(?:".concat(i2[u2.PRERELEASE], ")?").concat(i2[u2.BUILD], "?") + ")?)?"), a2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[u2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i2[u2.PRERELEASELOOSE], ")?").concat(i2[u2.BUILD], "?") + ")?)?"), a2("XRANGE", "^".concat(i2[u2.GTLT], "\\s*").concat(i2[u2.XRANGEPLAIN], "$")), a2("XRANGELOOSE", "^".concat(i2[u2.GTLT], "\\s*").concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n2, "})") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:\\.(\\d{1,".concat(n2, "}))?") + "(?:$|[^\\d])"), a2("COERCERTL", i2[u2.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", "(\\s*)".concat(i2[u2.LONETILDE], "\\s+"), true), t2.tildeTrimReplace = "$1~", a2("TILDE", "^".concat(i2[u2.LONETILDE]).concat(i2[u2.XRANGEPLAIN], "$")), a2("TILDELOOSE", "^".concat(i2[u2.LONETILDE]).concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", "(\\s*)".concat(i2[u2.LONECARET], "\\s+"), true), t2.caretTrimReplace = "$1^", a2("CARET", "^".concat(i2[u2.LONECARET]).concat(i2[u2.XRANGEPLAIN], "$")), a2("CARETLOOSE", "^".concat(i2[u2.LONECARET]).concat(i2[u2.XRANGEPLAINLOOSE], "$")), a2("COMPARATORLOOSE", "^".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.LOOSEPLAIN], ")$|^$")), a2("COMPARATOR", "^".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.FULLPLAIN], ")$|^$")), a2("COMPARATORTRIM", "(\\s*)".concat(i2[u2.GTLT], "\\s*(").concat(i2[u2.LOOSEPLAIN], "|").concat(i2[u2.XRANGEPLAIN], ")"), true), t2.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", "^\\s*(".concat(i2[u2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i2[u2.XRANGEPLAIN], ")") + "\\s*$"), a2("HYPHENRANGELOOSE", "^\\s*(".concat(i2[u2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i2[u2.XRANGEPLAINLOOSE], ")") + "\\s*$"), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        }(ia, ia.exports);
        const ua = ["includePrerelease", "loose", "rtl"];
        var sa = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : ua.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
        const aa = /^[0-9]+$/, ca = (e2, t2) => {
          const n2 = aa.test(e2), r2 = aa.test(t2);
          return n2 && r2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e2 < t2 ? -1 : 1;
        };
        var la = { compareIdentifiers: ca, rcompareIdentifiers: (e2, t2) => ca(t2, e2) };
        const pa = ra, { MAX_LENGTH: fa, MAX_SAFE_INTEGER: da } = oa, { re: ha, t: ga } = ia.exports, ma = sa, { compareIdentifiers: ya } = la;
        class Da {
          constructor(e2, t2) {
            if (t2 = ma(t2), e2 instanceof Da) {
              if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
                return e2;
              e2 = e2.version;
            } else if (typeof e2 != "string")
              throw new TypeError("Invalid Version: ".concat(e2));
            if (e2.length > fa)
              throw new TypeError("version is longer than ".concat(fa, " characters"));
            pa("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
            const n2 = e2.trim().match(t2.loose ? ha[ga.LOOSE] : ha[ga.FULL]);
            if (!n2)
              throw new TypeError("Invalid Version: ".concat(e2));
            if (this.raw = e2, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > da || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > da || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > da || this.patch < 0)
              throw new TypeError("Invalid patch version");
            n2[4] ? this.prerelease = n2[4].split(".").map((e3) => {
              if (/^[0-9]+$/.test(e3)) {
                const t3 = +e3;
                if (t3 >= 0 && t3 < da)
                  return t3;
              }
              return e3;
            }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
          }
          format() {
            return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
          }
          toString() {
            return this.version;
          }
          compare(e2) {
            if (pa("SemVer.compare", this.version, this.options, e2), !(e2 instanceof Da)) {
              if (typeof e2 == "string" && e2 === this.version)
                return 0;
              e2 = new Da(e2, this.options);
            }
            return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
          }
          compareMain(e2) {
            return e2 instanceof Da || (e2 = new Da(e2, this.options)), ya(this.major, e2.major) || ya(this.minor, e2.minor) || ya(this.patch, e2.patch);
          }
          comparePre(e2) {
            if (e2 instanceof Da || (e2 = new Da(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
              return -1;
            if (!this.prerelease.length && e2.prerelease.length)
              return 1;
            if (!this.prerelease.length && !e2.prerelease.length)
              return 0;
            let t2 = 0;
            do {
              const n2 = this.prerelease[t2], r2 = e2.prerelease[t2];
              if (pa("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
                return 0;
              if (r2 === void 0)
                return 1;
              if (n2 === void 0)
                return -1;
              if (n2 !== r2)
                return ya(n2, r2);
            } while (++t2);
          }
          compareBuild(e2) {
            e2 instanceof Da || (e2 = new Da(e2, this.options));
            let t2 = 0;
            do {
              const n2 = this.build[t2], r2 = e2.build[t2];
              if (pa("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
                return 0;
              if (r2 === void 0)
                return 1;
              if (n2 === void 0)
                return -1;
              if (n2 !== r2)
                return ya(n2, r2);
            } while (++t2);
          }
          inc(e2, t2) {
            switch (e2) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let e3 = this.prerelease.length;
                  for (; --e3 >= 0; )
                    typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
                  e3 === -1 && this.prerelease.push(0);
                }
                t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
                break;
              default:
                throw new Error("invalid increment argument: ".concat(e2));
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        const Ea = Da;
        var Ca = (e2, t2, n2) => new Ea(e2, n2).compare(new Ea(t2, n2));
        const ba = Ca;
        var va = (e2, t2, n2) => ba(e2, t2, n2) < 0;
        const Aa = Ca;
        var Fa, xa, Sa, wa, Ta, Ba, Na = (e2, t2, n2) => Aa(e2, t2, n2) >= 0, ka = { exports: {} };
        !function(e2, t2) {
          function n2() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
          }
          function r2() {
            return typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : { add: n2, delete: n2, get: n2, set: n2, has: function(e3) {
              return false;
            } };
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
          var o2 = Object.prototype.hasOwnProperty, i2 = function(e3, t3) {
            return o2.call(e3, t3);
          };
          function u2(e3, t3) {
            for (var n3 in t3)
              i2(t3, n3) && (e3[n3] = t3[n3]);
            return e3;
          }
          var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function f2(e3, t3, n3) {
            var r3 = 0, o3 = e3[0].match(l2);
            o3 && (r3 = o3[1].length);
            var i3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
            t3 && (e3 = e3.slice(1));
            var u3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof u3 == "string", d3 = e3.length;
            return e3.map(function(e4, t4) {
              return e4 = e4.replace(i3, "$1"), t4 === 0 && c3 && (e4 = e4.replace(s2, "")), t4 === d3 - 1 && p3 && (e4 = e4.replace(a2, "")), f3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
                return u3;
              })), e4;
            });
          }
          function d2(e3, t3) {
            for (var n3 = "", r3 = 0, o3 = e3.length; r3 < o3; r3++)
              n3 += e3[r3], r3 < o3 - 1 && (n3 += t3[r3]);
            return n3;
          }
          function h2(e3) {
            return i2(e3, "raw") && i2(e3, "length");
          }
          var g2 = function e3(t3) {
            var n3 = r2(), o3 = r2(), i3 = u2(function r3(i4) {
              for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
                s3[a3 - 1] = arguments[a3];
              if (h2(i4)) {
                var l3 = i4, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? o3 : n3, D2 = y2.get(l3);
                if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
                  return D2[0];
                var E2 = d2(D2, m2 ? s3.slice(1) : s3);
                return E2;
              }
              return e3(u2(u2({}, t3), i4 || {}));
            }, { string: function(e4) {
              return f2([e4], false, t3)[0];
            } });
            return i3;
          }({ trimLeadingNewline: true, trimTrailingNewline: true });
          t2.outdent = g2, t2.default = g2;
          try {
            e2.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
          } catch (e3) {
          }
        }(ka, ka.exports);
        const { outdent: Pa } = ka.exports, Oa = "Config", Ia = "Editor", La = "Other", ja = "Global", _a = "Special", Ma = { cursorOffset: { since: "1.4.0", category: _a, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(Fa || (Fa = lu(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))), cliCategory: Ia }, endOfLine: { since: "1.15.0", category: ja, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Pa(xa || (xa = lu(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]))) }] }, filepath: { since: "1.4.0", category: _a, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: La, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: _a, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: La }, parser: { since: "0.0.10", category: ja, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: ja, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: Oa }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: ja, description: Pa(Sa || (Sa = lu(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))), exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: Oa }, printWidth: { since: "0.0.0", category: ja, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: _a, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(wa || (wa = lu(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ia }, rangeStart: { since: "1.4.0", category: _a, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Pa(Ta || (Ta = lu(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ia }, requirePragma: { since: "1.7.0", category: _a, type: "boolean", default: false, description: Pa(Ba || (Ba = lu(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))), cliCategory: La }, tabWidth: { type: "int", category: ja, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: ja, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: ja, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
        const Ra = ["cliName", "cliCategory", "cliDescription"], Va = { compare: Ca, lt: va, gte: Na }, $a = (e2, t2) => Object.entries(e2).map((e3) => {
          let [n2, r2] = e3;
          return Object.assign({ [t2]: n2 }, r2);
        }), Wa = n.version, qa = { CATEGORY_CONFIG: Oa, CATEGORY_EDITOR: Ia, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: La, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: ja, CATEGORY_SPECIAL: _a, options: Ma }.options;
        function Ua(e2, t2, n2) {
          const r2 = new Set(e2.choices.map((e3) => e3.value));
          for (const o2 of t2)
            if (o2.parsers) {
              for (const t3 of o2.parsers)
                if (!r2.has(t3)) {
                  r2.add(t3);
                  const i2 = n2.find((e3) => e3.parsers && e3.parsers[t3]);
                  let u2 = o2.name;
                  i2 && i2.name && (u2 += " (plugin: ".concat(i2.name, ")")), e2.choices.push({ value: t3, description: u2 });
                }
            }
        }
        var za = { getSupportInfo: function() {
          let { plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: n2 = false, showInternal: r2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const o2 = Wa.split("-", 1)[0], i2 = e2.flatMap((e3) => e3.languages || []).filter(s2), u2 = $a(Object.assign({}, ...e2.map((e3) => {
            let { options: t3 } = e3;
            return t3;
          }), qa), "name").filter((e3) => s2(e3) && a2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(c2).map((t3) => {
            t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e3, t4) => Va.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => s2(e3) && a2(e3)), t3.name === "parser" && Ua(t3, i2, e2));
            const n3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
            return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: n3 });
          });
          return { languages: i2, options: u2 };
          function s2(e3) {
            return t2 || !("since" in e3) || e3.since && Va.gte(o2, e3.since);
          }
          function a2(e3) {
            return n2 || !("deprecated" in e3) || e3.deprecated && Va.lt(o2, e3.deprecated);
          }
          function c2(e3) {
            if (r2)
              return e3;
            return cu(e3, Ra);
          }
        } };
        const Ga = eu.exports, Ha = (e2) => {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }, Ja = au, { getSupportInfo: Xa } = za, Ya = /[^\x20-\x7F]/;
        function Ka(e2) {
          return (t2, n2, r2) => {
            const o2 = r2 && r2.backwards;
            if (n2 === false)
              return false;
            const { length: i2 } = t2;
            let u2 = n2;
            for (; u2 >= 0 && u2 < i2; ) {
              const n3 = t2.charAt(u2);
              if (e2 instanceof RegExp) {
                if (!e2.test(n3))
                  return u2;
              } else if (!e2.includes(n3))
                return u2;
              o2 ? u2-- : u2++;
            }
            return (u2 === -1 || u2 === i2) && u2;
          };
        }
        const Qa = Ka(/\s/), Za = Ka(" 	"), ec = Ka(",; 	"), tc = Ka(/[^\n\r]/);
        function nc(e2, t2) {
          if (t2 === false)
            return false;
          if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
            for (let n2 = t2 + 2; n2 < e2.length; ++n2)
              if (e2.charAt(n2) === "*" && e2.charAt(n2 + 1) === "/")
                return n2 + 2;
          }
          return t2;
        }
        function rc(e2, t2) {
          return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? tc(e2, t2) : t2);
        }
        function oc(e2, t2, n2) {
          const r2 = n2 && n2.backwards;
          if (t2 === false)
            return false;
          const o2 = e2.charAt(t2);
          if (r2) {
            if (e2.charAt(t2 - 1) === "\r" && o2 === "\n")
              return t2 - 2;
            if (o2 === "\n" || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
              return t2 - 1;
          } else {
            if (o2 === "\r" && e2.charAt(t2 + 1) === "\n")
              return t2 + 2;
            if (o2 === "\n" || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
              return t2 + 1;
          }
          return t2;
        }
        function ic(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const r2 = Za(e2, n2.backwards ? t2 - 1 : t2, n2), o2 = oc(e2, r2, n2);
          return r2 !== o2;
        }
        function uc(e2, t2) {
          let n2 = null, r2 = t2;
          for (; r2 !== n2; )
            n2 = r2, r2 = ec(e2, r2), r2 = nc(e2, r2), r2 = Za(e2, r2);
          return r2 = rc(e2, r2), r2 = oc(e2, r2), r2 !== false && ic(e2, r2);
        }
        function sc(e2, t2) {
          let n2 = null, r2 = t2;
          for (; r2 !== n2; )
            n2 = r2, r2 = Za(e2, r2), r2 = nc(e2, r2), r2 = rc(e2, r2), r2 = oc(e2, r2);
          return r2;
        }
        function ac(e2, t2, n2) {
          return sc(e2, n2(t2));
        }
        function cc(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r2 = 0;
          for (let o2 = n2; o2 < e2.length; ++o2)
            e2[o2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
          return r2;
        }
        function lc(e2, t2) {
          const n2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, r2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, o2 = t2 === "'" ? r2 : n2, i2 = o2 === r2 ? n2 : r2;
          let u2 = o2;
          if (e2.includes(o2.quote) || e2.includes(i2.quote)) {
            u2 = (e2.match(o2.regex) || []).length > (e2.match(i2.regex) || []).length ? i2 : o2;
          }
          return u2;
        }
        function pc(e2, t2, n2) {
          const r2 = t2 === '"' ? "'" : '"', o2 = e2.replace(/\\(.)|(["'])/gs, (e3, o3, i2) => o3 === r2 ? o3 : i2 === t2 ? "\\" + i2 : i2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o3) ? o3 : "\\" + o3));
          return t2 + o2 + t2;
        }
        function fc(e2, t2) {
          (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
            const t3 = e3.type || e3.kind || "(unknown type)";
            let n2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
            n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
            return t3 + (n2 ? " " + n2 : "");
          }(e2);
        }
        var dc = { inferParserByLanguage: function(e2, t2) {
          const { languages: n2 } = Xa({ plugins: t2.plugins }), r2 = n2.find((t3) => {
            let { name: n3 } = t3;
            return n3.toLowerCase() === e2;
          }) || n2.find((t3) => {
            let { aliases: n3 } = t3;
            return Array.isArray(n3) && n3.includes(e2);
          }) || n2.find((t3) => {
            let { extensions: n3 } = t3;
            return Array.isArray(n3) && n3.includes(".".concat(e2));
          });
          return r2 && r2.parsers[0];
        }, getStringWidth: function(e2) {
          return e2 ? Ya.test(e2) ? Ga(e2) : e2.length : 0;
        }, getMaxContinuousCount: function(e2, t2) {
          const n2 = e2.match(new RegExp("(".concat(Ha(t2), ")+"), "g"));
          return n2 === null ? 0 : n2.reduce((e3, n3) => Math.max(e3, n3.length / t2.length), 0);
        }, getMinNotPresentContinuousCount: function(e2, t2) {
          const n2 = e2.match(new RegExp("(".concat(Ha(t2), ")+"), "g"));
          if (n2 === null)
            return 0;
          const r2 = /* @__PURE__ */ new Map();
          let o2 = 0;
          for (const e3 of n2) {
            const n3 = e3.length / t2.length;
            r2.set(n3, true), n3 > o2 && (o2 = n3);
          }
          for (let e3 = 1; e3 < o2; e3++)
            if (!r2.get(e3))
              return e3;
          return o2 + 1;
        }, getPenultimate: (e2) => e2[e2.length - 2], getLast: Ja, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: sc, getNextNonSpaceNonCommentCharacterIndex: ac, getNextNonSpaceNonCommentCharacter: function(e2, t2, n2) {
          return e2.charAt(ac(e2, t2, n2));
        }, skip: Ka, skipWhitespace: Qa, skipSpaces: Za, skipToLineEnd: ec, skipEverythingButNewLine: tc, skipInlineComment: nc, skipTrailingComment: rc, skipNewline: oc, isNextLineEmptyAfterIndex: uc, isNextLineEmpty: function(e2, t2, n2) {
          return uc(e2, n2(t2));
        }, isPreviousLineEmpty: function(e2, t2, n2) {
          let r2 = n2(t2) - 1;
          return r2 = Za(e2, r2, { backwards: true }), r2 = oc(e2, r2, { backwards: true }), r2 = Za(e2, r2, { backwards: true }), r2 !== oc(e2, r2, { backwards: true });
        }, hasNewline: ic, hasNewlineInRange: function(e2, t2, n2) {
          for (let r2 = t2; r2 < n2; ++r2)
            if (e2.charAt(r2) === "\n")
              return true;
          return false;
        }, hasSpaces: function(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const r2 = Za(e2, n2.backwards ? t2 - 1 : t2, n2);
          return r2 !== t2;
        }, getAlignmentSize: cc, getIndentSize: function(e2, t2) {
          const n2 = e2.lastIndexOf("\n");
          return n2 === -1 ? 0 : cc(e2.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
        }, getPreferredQuote: lc, printString: function(e2, t2) {
          const n2 = e2.slice(1, -1);
          return pc(n2, t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : lc(n2, t2.singleQuote ? "'" : '"').quote, !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
        }, printNumber: function(e2) {
          return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        }, makeString: pc, addLeadingComment: function(e2, t2) {
          t2.leading = true, t2.trailing = false, fc(e2, t2);
        }, addDanglingComment: function(e2, t2, n2) {
          t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), fc(e2, t2);
        }, addTrailingComment: function(e2, t2) {
          t2.leading = false, t2.trailing = true, fc(e2, t2);
        }, isFrontMatterNode: function(e2) {
          return e2 && e2.type === "front-matter";
        }, getShebang: function(e2) {
          if (!e2.startsWith("#!"))
            return "";
          const t2 = e2.indexOf("\n");
          return t2 === -1 ? e2 : e2.slice(0, t2);
        }, isNonEmptyArray: function(e2) {
          return Array.isArray(e2) && e2.length > 0;
        }, createGroupIdMapper: function(e2) {
          const t2 = /* @__PURE__ */ new WeakMap();
          return function(n2) {
            return t2.has(n2) || t2.set(n2, Symbol(e2)), t2.get(n2);
          };
        } };
        var hc = { guessEndOfLine: function(e2) {
          const t2 = e2.indexOf("\r");
          return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
        }, convertEndOfLineToChars: function(e2) {
          switch (e2) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        }, countEndOfLineChars: function(e2, t2) {
          let n2;
          if (t2 === "\n")
            n2 = /\n/g;
          else if (t2 === "\r")
            n2 = /\r/g;
          else {
            if (t2 !== "\r\n")
              throw new Error('Unexpected "eol" '.concat(JSON.stringify(t2), "."));
            n2 = /\r\n/g;
          }
          const r2 = e2.match(n2);
          return r2 ? r2.length : 0;
        }, normalizeEndOfLine: function(e2) {
          return e2.replace(/\r\n?/g, "\n");
        } };
        const gc = au, { literalline: mc, join: yc } = Zi, Dc = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", Ec = (e2) => {
          if (Array.isArray(e2))
            return e2;
          if (e2.type !== "concat" && e2.type !== "fill")
            throw new Error("Expect doc type to be `concat` or `fill`.");
          return e2.parts;
        }, Cc = {};
        function bc(e2, t2, n2, r2) {
          const o2 = [e2];
          for (; o2.length > 0; ) {
            const e3 = o2.pop();
            if (e3 !== Cc) {
              if (n2 && o2.push(e3, Cc), !t2 || t2(e3) !== false)
                if (Dc(e3) || e3.type === "fill") {
                  const t3 = Ec(e3);
                  for (let e4 = t3.length - 1; e4 >= 0; --e4)
                    o2.push(t3[e4]);
                } else if (e3.type === "if-break")
                  e3.flatContents && o2.push(e3.flatContents), e3.breakContents && o2.push(e3.breakContents);
                else if (e3.type === "group" && e3.expandedStates)
                  if (r2)
                    for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                      o2.push(e3.expandedStates[t3]);
                  else
                    o2.push(e3.contents);
                else
                  e3.contents && o2.push(e3.contents);
            } else
              n2(o2.pop());
          }
        }
        function vc(e2, t2) {
          const n2 = /* @__PURE__ */ new Map();
          return r2(e2);
          function r2(e3) {
            if (n2.has(e3))
              return n2.get(e3);
            const o2 = function(e4) {
              if (Array.isArray(e4))
                return t2(e4.map(r2));
              if (e4.type === "concat" || e4.type === "fill") {
                const n3 = e4.parts.map(r2);
                return t2(Object.assign(Object.assign({}, e4), {}, { parts: n3 }));
              }
              if (e4.type === "if-break") {
                const n3 = e4.breakContents && r2(e4.breakContents), o3 = e4.flatContents && r2(e4.flatContents);
                return t2(Object.assign(Object.assign({}, e4), {}, { breakContents: n3, flatContents: o3 }));
              }
              if (e4.type === "group" && e4.expandedStates) {
                const n3 = e4.expandedStates.map(r2), o3 = n3[0];
                return t2(Object.assign(Object.assign({}, e4), {}, { contents: o3, expandedStates: n3 }));
              }
              if (e4.contents) {
                const n3 = r2(e4.contents);
                return t2(Object.assign(Object.assign({}, e4), {}, { contents: n3 }));
              }
              return t2(e4);
            }(e3);
            return n2.set(e3, o2), o2;
          }
        }
        function Ac(e2, t2, n2) {
          let r2 = n2, o2 = false;
          return bc(e2, function(e3) {
            const n3 = t2(e3);
            if (n3 !== void 0 && (o2 = true, r2 = n3), o2)
              return false;
          }), r2;
        }
        function Fc(e2) {
          return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
        }
        function xc(e2) {
          if (e2.length > 0) {
            const t2 = gc(e2);
            t2.expandedStates || t2.break || (t2.break = "propagated");
          }
          return null;
        }
        function Sc(e2) {
          return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
        }
        const wc = (e2, t2) => e2 && e2.type === "line" && e2.hard && t2 && t2.type === "break-parent";
        function Tc(e2) {
          if (!e2)
            return e2;
          if (Dc(e2) || e2.type === "fill") {
            const t2 = Ec(e2);
            for (; t2.length > 1 && wc(...t2.slice(-2)); )
              t2.length -= 2;
            if (t2.length > 0) {
              const e3 = Tc(gc(t2));
              t2[t2.length - 1] = e3;
            }
            return Array.isArray(e2) ? t2 : Object.assign(Object.assign({}, e2), {}, { parts: t2 });
          }
          switch (e2.type) {
            case "align":
            case "indent":
            case "indent-if-break":
            case "group":
            case "line-suffix":
            case "label": {
              const t2 = Tc(e2.contents);
              return Object.assign(Object.assign({}, e2), {}, { contents: t2 });
            }
            case "if-break": {
              const t2 = Tc(e2.breakContents), n2 = Tc(e2.flatContents);
              return Object.assign(Object.assign({}, e2), {}, { breakContents: t2, flatContents: n2 });
            }
          }
          return e2;
        }
        function Bc(e2) {
          return vc(e2, (e3) => function(e4) {
            switch (e4.type) {
              case "fill":
                if (e4.parts.every((e5) => e5 === ""))
                  return "";
                break;
              case "group":
                if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
                  return "";
                if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
                  return e4.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!e4.contents)
                  return "";
                break;
              case "if-break":
                if (!e4.flatContents && !e4.breakContents)
                  return "";
            }
            if (!Dc(e4))
              return e4;
            const t2 = [];
            for (const n2 of Ec(e4)) {
              if (!n2)
                continue;
              const [e5, ...r2] = Dc(n2) ? Ec(n2) : [n2];
              typeof e5 == "string" && typeof gc(t2) == "string" ? t2[t2.length - 1] += e5 : t2.push(e5), t2.push(...r2);
            }
            return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e4) ? t2 : Object.assign(Object.assign({}, e4), {}, { parts: t2 });
          }(e3));
        }
        function Nc(e2) {
          const t2 = [], n2 = e2.filter(Boolean);
          for (; n2.length > 0; ) {
            const e3 = n2.shift();
            e3 && (Dc(e3) ? n2.unshift(...Ec(e3)) : t2.length > 0 && typeof gc(t2) == "string" && typeof e3 == "string" ? t2[t2.length - 1] += e3 : t2.push(e3));
          }
          return t2;
        }
        function kc(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mc;
          return yc(t2, e2.split("\n")).parts;
        }
        function Pc(e2) {
          if (e2.type === "line")
            return true;
        }
        var Oc = { isConcat: Dc, getDocParts: Ec, willBreak: function(e2) {
          return Ac(e2, Fc, false);
        }, traverseDoc: bc, findInDoc: Ac, mapDoc: vc, propagateBreaks: function(e2) {
          const t2 = /* @__PURE__ */ new Set(), n2 = [];
          bc(e2, function(e3) {
            if (e3.type === "break-parent" && xc(n2), e3.type === "group") {
              if (n2.push(e3), t2.has(e3))
                return false;
              t2.add(e3);
            }
          }, function(e3) {
            if (e3.type === "group") {
              n2.pop().break && xc(n2);
            }
          }, true);
        }, removeLines: function(e2) {
          return vc(e2, Sc);
        }, stripTrailingHardline: function(e2) {
          return Tc(Bc(e2));
        }, normalizeParts: Nc, normalizeDoc: function(e2) {
          return vc(e2, (e3) => Array.isArray(e3) ? Nc(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: Nc(e3.parts) }) : e3);
        }, cleanDoc: Bc, replaceTextEndOfLine: kc, replaceEndOfLine: function(e2) {
          return vc(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? kc(e3) : e3);
        }, canBreak: function(e2) {
          return Ac(e2, Pc, false);
        } };
        const { getStringWidth: Ic, getLast: Lc } = dc, { convertEndOfLineToChars: jc } = hc, { fill: _c, cursor: Mc, indent: Rc } = Zi, { isConcat: Vc, getDocParts: $c } = Oc;
        let Wc;
        function qc(e2, t2) {
          return zc(e2, { type: "indent" }, t2);
        }
        function Uc(e2, t2, n2) {
          if (t2 === Number.NEGATIVE_INFINITY)
            return e2.root || { value: "", length: 0, queue: [] };
          if (t2 < 0)
            return zc(e2, { type: "dedent" }, n2);
          if (!t2)
            return e2;
          if (t2.type === "root")
            return Object.assign(Object.assign({}, e2), {}, { root: e2 });
          return zc(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, n2);
        }
        function zc(e2, t2, n2) {
          const r2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2];
          let o2 = "", i2 = 0, u2 = 0, s2 = 0;
          for (const e3 of r2)
            switch (e3.type) {
              case "indent":
                l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
                break;
              case "stringAlign":
                l2(), o2 += e3.n, i2 += e3.n.length;
                break;
              case "numberAlign":
                u2 += 1, s2 += e3.n;
                break;
              default:
                throw new Error("Unexpected type '".concat(e3.type, "'"));
            }
          return p2(), Object.assign(Object.assign({}, e2), {}, { value: o2, length: i2, queue: r2 });
          function a2(e3) {
            o2 += "	".repeat(e3), i2 += n2.tabWidth * e3;
          }
          function c2(e3) {
            o2 += " ".repeat(e3), i2 += e3;
          }
          function l2() {
            n2.useTabs ? function() {
              u2 > 0 && a2(u2);
              f2();
            }() : p2();
          }
          function p2() {
            s2 > 0 && c2(s2), f2();
          }
          function f2() {
            u2 = 0, s2 = 0;
          }
        }
        function Gc(e2) {
          if (e2.length === 0)
            return 0;
          let t2 = 0;
          for (; e2.length > 0 && typeof Lc(e2) == "string" && /^[\t ]*$/.test(Lc(e2)); )
            t2 += e2.pop().length;
          if (e2.length > 0 && typeof Lc(e2) == "string") {
            const n2 = Lc(e2).replace(/[\t ]*$/, "");
            t2 += Lc(e2).length - n2.length, e2[e2.length - 1] = n2;
          }
          return t2;
        }
        function Hc(e2, t2, n2, r2, o2, i2) {
          let u2 = t2.length;
          const s2 = [e2], a2 = [];
          for (; n2 >= 0; ) {
            if (s2.length === 0) {
              if (u2 === 0)
                return true;
              s2.push(t2[u2 - 1]), u2--;
              continue;
            }
            const [e3, c2, l2] = s2.pop();
            if (typeof l2 == "string")
              a2.push(l2), n2 -= Ic(l2);
            else if (Vc(l2)) {
              const t3 = $c(l2);
              for (let n3 = t3.length - 1; n3 >= 0; n3--)
                s2.push([e3, c2, t3[n3]]);
            } else
              switch (l2.type) {
                case "indent":
                  s2.push([qc(e3, r2), c2, l2.contents]);
                  break;
                case "align":
                  s2.push([Uc(e3, l2.n, r2), c2, l2.contents]);
                  break;
                case "trim":
                  n2 += Gc(a2);
                  break;
                case "group": {
                  if (i2 && l2.break)
                    return false;
                  const t3 = l2.break ? 1 : c2;
                  s2.push([e3, t3, l2.expandedStates && t3 === 1 ? Lc(l2.expandedStates) : l2.contents]), l2.id && (Wc[l2.id] = t3);
                  break;
                }
                case "fill":
                  for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
                    s2.push([e3, c2, l2.parts[t3]]);
                  break;
                case "if-break":
                case "indent-if-break": {
                  const t3 = l2.groupId ? Wc[l2.groupId] : c2;
                  if (t3 === 1) {
                    const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Rc(l2.contents);
                    t4 && s2.push([e3, c2, t4]);
                  }
                  if (t3 === 2) {
                    const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Rc(l2.contents) : l2.contents;
                    t4 && s2.push([e3, c2, t4]);
                  }
                  break;
                }
                case "line":
                  switch (c2) {
                    case 2:
                      if (!l2.hard) {
                        l2.soft || (a2.push(" "), n2 -= 1);
                        break;
                      }
                      return true;
                    case 1:
                      return true;
                  }
                  break;
                case "line-suffix":
                  o2 = true;
                  break;
                case "line-suffix-boundary":
                  if (o2)
                    return false;
                  break;
                case "label":
                  s2.push([e3, c2, l2.contents]);
              }
          }
          return false;
        }
        var Jc = { printDocToString: function(e2, t2) {
          Wc = {};
          const n2 = t2.printWidth, r2 = jc(t2.endOfLine);
          let o2 = 0;
          const i2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], u2 = [];
          let s2 = false, a2 = [];
          for (; i2.length > 0; ) {
            const [e3, c3, l2] = i2.pop();
            if (typeof l2 == "string") {
              const e4 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
              u2.push(e4), o2 += Ic(e4);
            } else if (Vc(l2)) {
              const t3 = $c(l2);
              for (let n3 = t3.length - 1; n3 >= 0; n3--)
                i2.push([e3, c3, t3[n3]]);
            } else
              switch (l2.type) {
                case "cursor":
                  u2.push(Mc.placeholder);
                  break;
                case "indent":
                  i2.push([qc(e3, t2), c3, l2.contents]);
                  break;
                case "align":
                  i2.push([Uc(e3, l2.n, t2), c3, l2.contents]);
                  break;
                case "trim":
                  o2 -= Gc(u2);
                  break;
                case "group":
                  switch (c3) {
                    case 2:
                      if (!s2) {
                        i2.push([e3, l2.break ? 1 : 2, l2.contents]);
                        break;
                      }
                    case 1: {
                      s2 = false;
                      const r3 = [e3, 2, l2.contents], u3 = n2 - o2, c4 = a2.length > 0;
                      if (!l2.break && Hc(r3, i2, u3, t2, c4))
                        i2.push(r3);
                      else if (l2.expandedStates) {
                        const n3 = Lc(l2.expandedStates);
                        if (l2.break) {
                          i2.push([e3, 1, n3]);
                          break;
                        }
                        for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                          if (r4 >= l2.expandedStates.length) {
                            i2.push([e3, 1, n3]);
                            break;
                          }
                          {
                            const n4 = [e3, 2, l2.expandedStates[r4]];
                            if (Hc(n4, i2, u3, t2, c4)) {
                              i2.push(n4);
                              break;
                            }
                          }
                        }
                      } else
                        i2.push([e3, 1, l2.contents]);
                      break;
                    }
                  }
                  l2.id && (Wc[l2.id] = Lc(i2)[1]);
                  break;
                case "fill": {
                  const r3 = n2 - o2, { parts: u3 } = l2;
                  if (u3.length === 0)
                    break;
                  const [s3, p2] = u3, f2 = [e3, 2, s3], d2 = [e3, 1, s3], h2 = Hc(f2, [], r3, t2, a2.length > 0, true);
                  if (u3.length === 1) {
                    h2 ? i2.push(f2) : i2.push(d2);
                    break;
                  }
                  const g2 = [e3, 2, p2], m2 = [e3, 1, p2];
                  if (u3.length === 2) {
                    h2 ? i2.push(g2, f2) : i2.push(m2, d2);
                    break;
                  }
                  u3.splice(0, 2);
                  const y2 = [e3, c3, _c(u3)];
                  Hc([e3, 2, [s3, p2, u3[0]]], [], r3, t2, a2.length > 0, true) ? i2.push(y2, g2, f2) : h2 ? i2.push(y2, m2, f2) : i2.push(y2, m2, d2);
                  break;
                }
                case "if-break":
                case "indent-if-break": {
                  const t3 = l2.groupId ? Wc[l2.groupId] : c3;
                  if (t3 === 1) {
                    const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Rc(l2.contents);
                    t4 && i2.push([e3, c3, t4]);
                  }
                  if (t3 === 2) {
                    const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Rc(l2.contents) : l2.contents;
                    t4 && i2.push([e3, c3, t4]);
                  }
                  break;
                }
                case "line-suffix":
                  a2.push([e3, c3, l2.contents]);
                  break;
                case "line-suffix-boundary":
                  a2.length > 0 && i2.push([e3, c3, { type: "line", hard: true }]);
                  break;
                case "line":
                  switch (c3) {
                    case 2:
                      if (!l2.hard) {
                        l2.soft || (u2.push(" "), o2 += 1);
                        break;
                      }
                      s2 = true;
                    case 1:
                      if (a2.length > 0) {
                        i2.push([e3, c3, l2], ...a2.reverse()), a2 = [];
                        break;
                      }
                      l2.literal ? e3.root ? (u2.push(r2, e3.root.value), o2 = e3.root.length) : (u2.push(r2), o2 = 0) : (o2 -= Gc(u2), u2.push(r2 + e3.value), o2 = e3.length);
                  }
                  break;
                case "label":
                  i2.push([e3, c3, l2.contents]);
              }
            i2.length === 0 && a2.length > 0 && (i2.push(...a2.reverse()), a2 = []);
          }
          const c2 = u2.indexOf(Mc.placeholder);
          if (c2 !== -1) {
            const e3 = u2.indexOf(Mc.placeholder, c2 + 1), t3 = u2.slice(0, c2).join(""), n3 = u2.slice(c2 + 1, e3).join("");
            return { formatted: t3 + n3 + u2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3 };
          }
          return { formatted: u2.join("") };
        } };
        const { isConcat: Xc, getDocParts: Yc } = Oc;
        function Kc(e2) {
          if (!e2)
            return "";
          if (Xc(e2)) {
            const t2 = [];
            for (const n2 of Yc(e2))
              if (Xc(n2))
                t2.push(...Kc(n2).parts);
              else {
                const e3 = Kc(n2);
                e3 !== "" && t2.push(e3);
              }
            return { type: "concat", parts: t2 };
          }
          return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: Kc(e2.breakContents), flatContents: Kc(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: Kc(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(Kc) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(Kc) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: Kc(e2.contents) }) : e2;
        }
        var Qc = { printDocToDebug: function(e2) {
          const t2 = /* @__PURE__ */ Object.create(null), n2 = /* @__PURE__ */ new Set();
          return function e3(t3, n3, o2) {
            if (typeof t3 == "string")
              return JSON.stringify(t3);
            if (Xc(t3)) {
              const n4 = Yc(t3).map(e3).filter(Boolean);
              return n4.length === 1 ? n4[0] : "[".concat(n4.join(", "), "]");
            }
            if (t3.type === "line") {
              const e4 = Array.isArray(o2) && o2[n3 + 1] && o2[n3 + 1].type === "break-parent";
              return t3.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
            }
            if (t3.type === "break-parent") {
              return Array.isArray(o2) && o2[n3 - 1] && o2[n3 - 1].type === "line" && o2[n3 - 1].hard ? void 0 : "breakParent";
            }
            if (t3.type === "trim")
              return "trim";
            if (t3.type === "indent")
              return "indent(" + e3(t3.contents) + ")";
            if (t3.type === "align")
              return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e3(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e3(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e3(t3.contents) + ")";
            if (t3.type === "if-break")
              return "ifBreak(" + e3(t3.breakContents) + (t3.flatContents ? ", " + e3(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + ", { groupId: ".concat(r2(t3.groupId), " }") : "") + ")";
            if (t3.type === "indent-if-break") {
              const n4 = [];
              t3.negate && n4.push("negate: true"), t3.groupId && n4.push("groupId: ".concat(r2(t3.groupId)));
              const o3 = n4.length > 0 ? ", { ".concat(n4.join(", "), " }") : "";
              return "indentIfBreak(".concat(e3(t3.contents)).concat(o3, ")");
            }
            if (t3.type === "group") {
              const n4 = [];
              t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push("id: ".concat(r2(t3.id)));
              const o3 = n4.length > 0 ? ", { ".concat(n4.join(", "), " }") : "";
              return t3.expandedStates ? "conditionalGroup([".concat(t3.expandedStates.map((t4) => e3(t4)).join(","), "]").concat(o3, ")") : "group(".concat(e3(t3.contents)).concat(o3, ")");
            }
            if (t3.type === "fill")
              return "fill([".concat(t3.parts.map((t4) => e3(t4)).join(", "), "])");
            if (t3.type === "line-suffix")
              return "lineSuffix(" + e3(t3.contents) + ")";
            if (t3.type === "line-suffix-boundary")
              return "lineSuffixBoundary";
            if (t3.type === "label")
              return "label(".concat(JSON.stringify(t3.label), ", ").concat(e3(t3.contents), ")");
            throw new Error("Unknown doc type " + t3.type);
          }(Kc(e2));
          function r2(e3) {
            if (typeof e3 != "symbol")
              return JSON.stringify(String(e3));
            if (e3 in t2)
              return t2[e3];
            const r3 = String(e3).slice(7, -1) || "symbol";
            for (let o2 = 0; ; o2++) {
              const i2 = r3 + (o2 > 0 ? " #".concat(o2) : "");
              if (!n2.has(i2))
                return n2.add(i2), t2[e3] = "Symbol.for(".concat(JSON.stringify(i2), ")");
            }
          }
        } }, Zc = { builders: Zi, printer: Jc, utils: Oc, debug: Qc }, el = t(Object.freeze({ __proto__: null, default: {} }));
        function tl(e2, t2) {
          for (var n2 = 0, r2 = e2.length - 1; r2 >= 0; r2--) {
            var o2 = e2[r2];
            o2 === "." ? e2.splice(r2, 1) : o2 === ".." ? (e2.splice(r2, 1), n2++) : n2 && (e2.splice(r2, 1), n2--);
          }
          if (t2)
            for (; n2--; n2)
              e2.unshift("..");
          return e2;
        }
        var nl = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, rl = function(e2) {
          return nl.exec(e2).slice(1);
        };
        function ol() {
          for (var e2 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
            var r2 = n2 >= 0 ? arguments[n2] : "/";
            if (typeof r2 != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            r2 && (e2 = r2 + "/" + e2, t2 = r2.charAt(0) === "/");
          }
          return e2 = tl(dl(e2.split("/"), function(e3) {
            return !!e3;
          }), !t2).join("/"), (t2 ? "/" : "") + e2 || ".";
        }
        function il(e2) {
          var t2 = ul(e2), n2 = hl(e2, -1) === "/";
          return e2 = tl(dl(e2.split("/"), function(e3) {
            return !!e3;
          }), !t2).join("/"), e2 || t2 || (e2 = "."), e2 && n2 && (e2 += "/"), (t2 ? "/" : "") + e2;
        }
        function ul(e2) {
          return e2.charAt(0) === "/";
        }
        function sl() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return il(dl(e2, function(e3, t2) {
            if (typeof e3 != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return e3;
          }).join("/"));
        }
        function al(e2, t2) {
          function n2(e3) {
            for (var t3 = 0; t3 < e3.length && e3[t3] === ""; t3++)
              ;
            for (var n3 = e3.length - 1; n3 >= 0 && e3[n3] === ""; n3--)
              ;
            return t3 > n3 ? [] : e3.slice(t3, n3 - t3 + 1);
          }
          e2 = ol(e2).substr(1), t2 = ol(t2).substr(1);
          for (var r2 = n2(e2.split("/")), o2 = n2(t2.split("/")), i2 = Math.min(r2.length, o2.length), u2 = i2, s2 = 0; s2 < i2; s2++)
            if (r2[s2] !== o2[s2]) {
              u2 = s2;
              break;
            }
          var a2 = [];
          for (s2 = u2; s2 < r2.length; s2++)
            a2.push("..");
          return (a2 = a2.concat(o2.slice(u2))).join("/");
        }
        function cl(e2) {
          var t2 = rl(e2), n2 = t2[0], r2 = t2[1];
          return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
        }
        function ll(e2, t2) {
          var n2 = rl(e2)[2];
          return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
        }
        function pl(e2) {
          return rl(e2)[3];
        }
        var fl = { extname: pl, basename: ll, dirname: cl, sep: "/", delimiter: ":", relative: al, join: sl, isAbsolute: ul, normalize: il, resolve: ol };
        function dl(e2, t2) {
          if (e2.filter)
            return e2.filter(t2);
          for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
            t2(e2[r2], r2, e2) && n2.push(e2[r2]);
          return n2;
        }
        var hl = "ab".substr(-1) === "b" ? function(e2, t2, n2) {
          return e2.substr(t2, n2);
        } : function(e2, t2, n2) {
          return t2 < 0 && (t2 = e2.length + t2), e2.substr(t2, n2);
        }, gl = t(Object.freeze({ __proto__: null, resolve: ol, normalize: il, isAbsolute: ul, join: sl, relative: al, sep: "/", delimiter: ":", dirname: cl, basename: ll, extname: pl, default: fl })), ml = [], yl = [], Dl = typeof Uint8Array != "undefined" ? Uint8Array : Array, El = false;
        function Cl() {
          El = true;
          for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e2.length; t2 < n2; ++t2)
            ml[t2] = e2[t2], yl[e2.charCodeAt(t2)] = t2;
          yl["-".charCodeAt(0)] = 62, yl["_".charCodeAt(0)] = 63;
        }
        function bl(e2, t2, n2) {
          for (var r2, o2, i2 = [], u2 = t2; u2 < n2; u2 += 3)
            r2 = (e2[u2] << 16) + (e2[u2 + 1] << 8) + e2[u2 + 2], i2.push(ml[(o2 = r2) >> 18 & 63] + ml[o2 >> 12 & 63] + ml[o2 >> 6 & 63] + ml[63 & o2]);
          return i2.join("");
        }
        function vl(e2) {
          var t2;
          El || Cl();
          for (var n2 = e2.length, r2 = n2 % 3, o2 = "", i2 = [], u2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += u2)
            i2.push(bl(e2, s2, s2 + u2 > a2 ? a2 : s2 + u2));
          return r2 === 1 ? (t2 = e2[n2 - 1], o2 += ml[t2 >> 2], o2 += ml[t2 << 4 & 63], o2 += "==") : r2 === 2 && (t2 = (e2[n2 - 2] << 8) + e2[n2 - 1], o2 += ml[t2 >> 10], o2 += ml[t2 >> 4 & 63], o2 += ml[t2 << 2 & 63], o2 += "="), i2.push(o2), i2.join("");
        }
        function Al(e2, t2, n2, r2, o2) {
          var i2, u2, s2 = 8 * o2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? o2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e2[t2 + p2];
          for (p2 += f2, i2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; i2 = 256 * i2 + e2[t2 + p2], p2 += f2, l2 -= 8)
            ;
          for (u2 = i2 & (1 << -l2) - 1, i2 >>= -l2, l2 += r2; l2 > 0; u2 = 256 * u2 + e2[t2 + p2], p2 += f2, l2 -= 8)
            ;
          if (i2 === 0)
            i2 = 1 - c2;
          else {
            if (i2 === a2)
              return u2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
            u2 += Math.pow(2, r2), i2 -= c2;
          }
          return (d2 ? -1 : 1) * u2 * Math.pow(2, i2 - r2);
        }
        function Fl(e2, t2, n2, r2, o2, i2) {
          var u2, s2, a2, c2 = 8 * i2 - o2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = o2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : i2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, u2 = l2) : (u2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -u2)) < 1 && (u2--, a2 *= 2), (t2 += u2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (u2++, a2 /= 2), u2 + p2 >= l2 ? (s2 = 0, u2 = l2) : u2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, o2), u2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, o2), u2 = 0)); o2 >= 8; e2[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, o2 -= 8)
            ;
          for (u2 = u2 << o2 | s2, c2 += o2; c2 > 0; e2[n2 + d2] = 255 & u2, d2 += h2, u2 /= 256, c2 -= 8)
            ;
          e2[n2 + d2 - h2] |= 128 * g2;
        }
        var xl = {}.toString, Sl = Array.isArray || function(e2) {
          return xl.call(e2) == "[object Array]";
        };
        function wl() {
          return Bl.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function Tl(e2, t2) {
          if (wl() < t2)
            throw new RangeError("Invalid typed array length");
          return Bl.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t2)).__proto__ = Bl.prototype : (e2 === null && (e2 = new Bl(t2)), e2.length = t2), e2;
        }
        function Bl(e2, t2, n2) {
          if (!(Bl.TYPED_ARRAY_SUPPORT || this instanceof Bl))
            return new Bl(e2, t2, n2);
          if (typeof e2 == "number") {
            if (typeof t2 == "string")
              throw new Error("If encoding is specified then the first argument must be a string");
            return Pl(this, e2);
          }
          return Nl(this, e2, t2, n2);
        }
        function Nl(e2, t2, n2, r2) {
          if (typeof t2 == "number")
            throw new TypeError('"value" argument must not be a number');
          return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e3, t3, n3, r3) {
            if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
              throw new RangeError("'offset' is out of bounds");
            if (t3.byteLength < n3 + (r3 || 0))
              throw new RangeError("'length' is out of bounds");
            t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
            Bl.TYPED_ARRAY_SUPPORT ? (e3 = t3).__proto__ = Bl.prototype : e3 = Ol(e3, t3);
            return e3;
          }(e2, t2, n2, r2) : typeof t2 == "string" ? function(e3, t3, n3) {
            typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
            if (!Bl.isEncoding(n3))
              throw new TypeError('"encoding" must be a valid string encoding');
            var r3 = 0 | jl(t3, n3), o2 = (e3 = Tl(e3, r3)).write(t3, n3);
            o2 !== r3 && (e3 = e3.slice(0, o2));
            return e3;
          }(e2, t2, n2) : function(e3, t3) {
            if (Ll(t3)) {
              var n3 = 0 | Il(t3.length);
              return (e3 = Tl(e3, n3)).length === 0 || t3.copy(e3, 0, 0, n3), e3;
            }
            if (t3) {
              if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
                return typeof t3.length != "number" || (r3 = t3.length) != r3 ? Tl(e3, 0) : Ol(e3, t3);
              if (t3.type === "Buffer" && Sl(t3.data))
                return Ol(e3, t3.data);
            }
            var r3;
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }(e2, t2);
        }
        function kl(e2) {
          if (typeof e2 != "number")
            throw new TypeError('"size" argument must be a number');
          if (e2 < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function Pl(e2, t2) {
          if (kl(t2), e2 = Tl(e2, t2 < 0 ? 0 : 0 | Il(t2)), !Bl.TYPED_ARRAY_SUPPORT)
            for (var n2 = 0; n2 < t2; ++n2)
              e2[n2] = 0;
          return e2;
        }
        function Ol(e2, t2) {
          var n2 = t2.length < 0 ? 0 : 0 | Il(t2.length);
          e2 = Tl(e2, n2);
          for (var r2 = 0; r2 < n2; r2 += 1)
            e2[r2] = 255 & t2[r2];
          return e2;
        }
        function Il(e2) {
          if (e2 >= wl())
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + wl().toString(16) + " bytes");
          return 0 | e2;
        }
        function Ll(e2) {
          return !(e2 == null || !e2._isBuffer);
        }
        function jl(e2, t2) {
          if (Ll(e2))
            return e2.length;
          if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
            return e2.byteLength;
          typeof e2 != "string" && (e2 = "" + e2);
          var n2 = e2.length;
          if (n2 === 0)
            return 0;
          for (var r2 = false; ; )
            switch (t2) {
              case "ascii":
              case "latin1":
              case "binary":
                return n2;
              case "utf8":
              case "utf-8":
              case void 0:
                return cp(e2).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * n2;
              case "hex":
                return n2 >>> 1;
              case "base64":
                return lp(e2).length;
              default:
                if (r2)
                  return cp(e2).length;
                t2 = ("" + t2).toLowerCase(), r2 = true;
            }
        }
        function _l(e2, t2, n2) {
          var r2 = false;
          if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
            return "";
          if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
            return "";
          if ((n2 >>>= 0) <= (t2 >>>= 0))
            return "";
          for (e2 || (e2 = "utf8"); ; )
            switch (e2) {
              case "hex":
                return Ql(this, t2, n2);
              case "utf8":
              case "utf-8":
                return Jl(this, t2, n2);
              case "ascii":
                return Yl(this, t2, n2);
              case "latin1":
              case "binary":
                return Kl(this, t2, n2);
              case "base64":
                return Hl(this, t2, n2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return Zl(this, t2, n2);
              default:
                if (r2)
                  throw new TypeError("Unknown encoding: " + e2);
                e2 = (e2 + "").toLowerCase(), r2 = true;
            }
        }
        function Ml(e2, t2, n2) {
          var r2 = e2[t2];
          e2[t2] = e2[n2], e2[n2] = r2;
        }
        function Rl(e2, t2, n2, r2, o2) {
          if (e2.length === 0)
            return -1;
          if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = o2 ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
            if (o2)
              return -1;
            n2 = e2.length - 1;
          } else if (n2 < 0) {
            if (!o2)
              return -1;
            n2 = 0;
          }
          if (typeof t2 == "string" && (t2 = Bl.from(t2, r2)), Ll(t2))
            return t2.length === 0 ? -1 : Vl(e2, t2, n2, r2, o2);
          if (typeof t2 == "number")
            return t2 &= 255, Bl.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? o2 ? Uint8Array.prototype.indexOf.call(e2, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, n2) : Vl(e2, [t2], n2, r2, o2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function Vl(e2, t2, n2, r2, o2) {
          var i2, u2 = 1, s2 = e2.length, a2 = t2.length;
          if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
            if (e2.length < 2 || t2.length < 2)
              return -1;
            u2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
          }
          function c2(e3, t3) {
            return u2 === 1 ? e3[t3] : e3.readUInt16BE(t3 * u2);
          }
          if (o2) {
            var l2 = -1;
            for (i2 = n2; i2 < s2; i2++)
              if (c2(e2, i2) === c2(t2, l2 === -1 ? 0 : i2 - l2)) {
                if (l2 === -1 && (l2 = i2), i2 - l2 + 1 === a2)
                  return l2 * u2;
              } else
                l2 !== -1 && (i2 -= i2 - l2), l2 = -1;
          } else
            for (n2 + a2 > s2 && (n2 = s2 - a2), i2 = n2; i2 >= 0; i2--) {
              for (var p2 = true, f2 = 0; f2 < a2; f2++)
                if (c2(e2, i2 + f2) !== c2(t2, f2)) {
                  p2 = false;
                  break;
                }
              if (p2)
                return i2;
            }
          return -1;
        }
        function $l(e2, t2, n2, r2) {
          n2 = Number(n2) || 0;
          var o2 = e2.length - n2;
          r2 ? (r2 = Number(r2)) > o2 && (r2 = o2) : r2 = o2;
          var i2 = t2.length;
          if (i2 % 2 != 0)
            throw new TypeError("Invalid hex string");
          r2 > i2 / 2 && (r2 = i2 / 2);
          for (var u2 = 0; u2 < r2; ++u2) {
            var s2 = parseInt(t2.substr(2 * u2, 2), 16);
            if (isNaN(s2))
              return u2;
            e2[n2 + u2] = s2;
          }
          return u2;
        }
        function Wl(e2, t2, n2, r2) {
          return pp(cp(t2, e2.length - n2), e2, n2, r2);
        }
        function ql(e2, t2, n2, r2) {
          return pp(function(e3) {
            for (var t3 = [], n3 = 0; n3 < e3.length; ++n3)
              t3.push(255 & e3.charCodeAt(n3));
            return t3;
          }(t2), e2, n2, r2);
        }
        function Ul(e2, t2, n2, r2) {
          return ql(e2, t2, n2, r2);
        }
        function zl(e2, t2, n2, r2) {
          return pp(lp(t2), e2, n2, r2);
        }
        function Gl(e2, t2, n2, r2) {
          return pp(function(e3, t3) {
            for (var n3, r3, o2, i2 = [], u2 = 0; u2 < e3.length && !((t3 -= 2) < 0); ++u2)
              r3 = (n3 = e3.charCodeAt(u2)) >> 8, o2 = n3 % 256, i2.push(o2), i2.push(r3);
            return i2;
          }(t2, e2.length - n2), e2, n2, r2);
        }
        function Hl(e2, t2, n2) {
          return t2 === 0 && n2 === e2.length ? vl(e2) : vl(e2.slice(t2, n2));
        }
        function Jl(e2, t2, n2) {
          n2 = Math.min(e2.length, n2);
          for (var r2 = [], o2 = t2; o2 < n2; ) {
            var i2, u2, s2, a2, c2 = e2[o2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
            if (o2 + p2 <= n2)
              switch (p2) {
                case 1:
                  c2 < 128 && (l2 = c2);
                  break;
                case 2:
                  (192 & (i2 = e2[o2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & i2) > 127 && (l2 = a2);
                  break;
                case 3:
                  i2 = e2[o2 + 1], u2 = e2[o2 + 2], (192 & i2) == 128 && (192 & u2) == 128 && (a2 = (15 & c2) << 12 | (63 & i2) << 6 | 63 & u2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
                  break;
                case 4:
                  i2 = e2[o2 + 1], u2 = e2[o2 + 2], s2 = e2[o2 + 3], (192 & i2) == 128 && (192 & u2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & i2) << 12 | (63 & u2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
              }
            l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), o2 += p2;
          }
          return function(e3) {
            var t3 = e3.length;
            if (t3 <= Xl)
              return String.fromCharCode.apply(String, e3);
            var n3 = "", r3 = 0;
            for (; r3 < t3; )
              n3 += String.fromCharCode.apply(String, e3.slice(r3, r3 += Xl));
            return n3;
          }(r2);
        }
        Bl.TYPED_ARRAY_SUPPORT = Ns.TYPED_ARRAY_SUPPORT === void 0 || Ns.TYPED_ARRAY_SUPPORT, Bl.poolSize = 8192, Bl._augment = function(e2) {
          return e2.__proto__ = Bl.prototype, e2;
        }, Bl.from = function(e2, t2, n2) {
          return Nl(null, e2, t2, n2);
        }, Bl.TYPED_ARRAY_SUPPORT && (Bl.prototype.__proto__ = Uint8Array.prototype, Bl.__proto__ = Uint8Array), Bl.alloc = function(e2, t2, n2) {
          return function(e3, t3, n3, r2) {
            return kl(t3), t3 <= 0 ? Tl(e3, t3) : n3 !== void 0 ? typeof r2 == "string" ? Tl(e3, t3).fill(n3, r2) : Tl(e3, t3).fill(n3) : Tl(e3, t3);
          }(null, e2, t2, n2);
        }, Bl.allocUnsafe = function(e2) {
          return Pl(null, e2);
        }, Bl.allocUnsafeSlow = function(e2) {
          return Pl(null, e2);
        }, Bl.isBuffer = fp, Bl.compare = function(e2, t2) {
          if (!Ll(e2) || !Ll(t2))
            throw new TypeError("Arguments must be Buffers");
          if (e2 === t2)
            return 0;
          for (var n2 = e2.length, r2 = t2.length, o2 = 0, i2 = Math.min(n2, r2); o2 < i2; ++o2)
            if (e2[o2] !== t2[o2]) {
              n2 = e2[o2], r2 = t2[o2];
              break;
            }
          return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
        }, Bl.isEncoding = function(e2) {
          switch (String(e2).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, Bl.concat = function(e2, t2) {
          if (!Sl(e2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (e2.length === 0)
            return Bl.alloc(0);
          var n2;
          if (t2 === void 0)
            for (t2 = 0, n2 = 0; n2 < e2.length; ++n2)
              t2 += e2[n2].length;
          var r2 = Bl.allocUnsafe(t2), o2 = 0;
          for (n2 = 0; n2 < e2.length; ++n2) {
            var i2 = e2[n2];
            if (!Ll(i2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            i2.copy(r2, o2), o2 += i2.length;
          }
          return r2;
        }, Bl.byteLength = jl, Bl.prototype._isBuffer = true, Bl.prototype.swap16 = function() {
          var e2 = this.length;
          if (e2 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var t2 = 0; t2 < e2; t2 += 2)
            Ml(this, t2, t2 + 1);
          return this;
        }, Bl.prototype.swap32 = function() {
          var e2 = this.length;
          if (e2 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var t2 = 0; t2 < e2; t2 += 4)
            Ml(this, t2, t2 + 3), Ml(this, t2 + 1, t2 + 2);
          return this;
        }, Bl.prototype.swap64 = function() {
          var e2 = this.length;
          if (e2 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var t2 = 0; t2 < e2; t2 += 8)
            Ml(this, t2, t2 + 7), Ml(this, t2 + 1, t2 + 6), Ml(this, t2 + 2, t2 + 5), Ml(this, t2 + 3, t2 + 4);
          return this;
        }, Bl.prototype.toString = function() {
          var e2 = 0 | this.length;
          return e2 === 0 ? "" : arguments.length === 0 ? Jl(this, 0, e2) : _l.apply(this, arguments);
        }, Bl.prototype.equals = function(e2) {
          if (!Ll(e2))
            throw new TypeError("Argument must be a Buffer");
          return this === e2 || Bl.compare(this, e2) === 0;
        }, Bl.prototype.inspect = function() {
          var e2 = "";
          return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
        }, Bl.prototype.compare = function(e2, t2, n2, r2, o2) {
          if (!Ll(e2))
            throw new TypeError("Argument must be a Buffer");
          if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e2 ? e2.length : 0), r2 === void 0 && (r2 = 0), o2 === void 0 && (o2 = this.length), t2 < 0 || n2 > e2.length || r2 < 0 || o2 > this.length)
            throw new RangeError("out of range index");
          if (r2 >= o2 && t2 >= n2)
            return 0;
          if (r2 >= o2)
            return -1;
          if (t2 >= n2)
            return 1;
          if (this === e2)
            return 0;
          for (var i2 = (o2 >>>= 0) - (r2 >>>= 0), u2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(i2, u2), a2 = this.slice(r2, o2), c2 = e2.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
            if (a2[l2] !== c2[l2]) {
              i2 = a2[l2], u2 = c2[l2];
              break;
            }
          return i2 < u2 ? -1 : u2 < i2 ? 1 : 0;
        }, Bl.prototype.includes = function(e2, t2, n2) {
          return this.indexOf(e2, t2, n2) !== -1;
        }, Bl.prototype.indexOf = function(e2, t2, n2) {
          return Rl(this, e2, t2, n2, true);
        }, Bl.prototype.lastIndexOf = function(e2, t2, n2) {
          return Rl(this, e2, t2, n2, false);
        }, Bl.prototype.write = function(e2, t2, n2, r2) {
          if (t2 === void 0)
            r2 = "utf8", n2 = this.length, t2 = 0;
          else if (n2 === void 0 && typeof t2 == "string")
            r2 = t2, n2 = this.length, t2 = 0;
          else {
            if (!isFinite(t2))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
          }
          var o2 = this.length - t2;
          if ((n2 === void 0 || n2 > o2) && (n2 = o2), e2.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          r2 || (r2 = "utf8");
          for (var i2 = false; ; )
            switch (r2) {
              case "hex":
                return $l(this, e2, t2, n2);
              case "utf8":
              case "utf-8":
                return Wl(this, e2, t2, n2);
              case "ascii":
                return ql(this, e2, t2, n2);
              case "latin1":
              case "binary":
                return Ul(this, e2, t2, n2);
              case "base64":
                return zl(this, e2, t2, n2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return Gl(this, e2, t2, n2);
              default:
                if (i2)
                  throw new TypeError("Unknown encoding: " + r2);
                r2 = ("" + r2).toLowerCase(), i2 = true;
            }
        }, Bl.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var Xl = 4096;
        function Yl(e2, t2, n2) {
          var r2 = "";
          n2 = Math.min(e2.length, n2);
          for (var o2 = t2; o2 < n2; ++o2)
            r2 += String.fromCharCode(127 & e2[o2]);
          return r2;
        }
        function Kl(e2, t2, n2) {
          var r2 = "";
          n2 = Math.min(e2.length, n2);
          for (var o2 = t2; o2 < n2; ++o2)
            r2 += String.fromCharCode(e2[o2]);
          return r2;
        }
        function Ql(e2, t2, n2) {
          var r2 = e2.length;
          (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
          for (var o2 = "", i2 = t2; i2 < n2; ++i2)
            o2 += ap(e2[i2]);
          return o2;
        }
        function Zl(e2, t2, n2) {
          for (var r2 = e2.slice(t2, n2), o2 = "", i2 = 0; i2 < r2.length; i2 += 2)
            o2 += String.fromCharCode(r2[i2] + 256 * r2[i2 + 1]);
          return o2;
        }
        function ep(e2, t2, n2) {
          if (e2 % 1 != 0 || e2 < 0)
            throw new RangeError("offset is not uint");
          if (e2 + t2 > n2)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function tp(e2, t2, n2, r2, o2, i2) {
          if (!Ll(e2))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t2 > o2 || t2 < i2)
            throw new RangeError('"value" argument is out of bounds');
          if (n2 + r2 > e2.length)
            throw new RangeError("Index out of range");
        }
        function np(e2, t2, n2, r2) {
          t2 < 0 && (t2 = 65535 + t2 + 1);
          for (var o2 = 0, i2 = Math.min(e2.length - n2, 2); o2 < i2; ++o2)
            e2[n2 + o2] = (t2 & 255 << 8 * (r2 ? o2 : 1 - o2)) >>> 8 * (r2 ? o2 : 1 - o2);
        }
        function rp(e2, t2, n2, r2) {
          t2 < 0 && (t2 = 4294967295 + t2 + 1);
          for (var o2 = 0, i2 = Math.min(e2.length - n2, 4); o2 < i2; ++o2)
            e2[n2 + o2] = t2 >>> 8 * (r2 ? o2 : 3 - o2) & 255;
        }
        function op(e2, t2, n2, r2, o2, i2) {
          if (n2 + r2 > e2.length)
            throw new RangeError("Index out of range");
          if (n2 < 0)
            throw new RangeError("Index out of range");
        }
        function ip(e2, t2, n2, r2, o2) {
          return o2 || op(e2, 0, n2, 4), Fl(e2, t2, n2, r2, 23, 4), n2 + 4;
        }
        function up(e2, t2, n2, r2, o2) {
          return o2 || op(e2, 0, n2, 8), Fl(e2, t2, n2, r2, 52, 8), n2 + 8;
        }
        Bl.prototype.slice = function(e2, t2) {
          var n2, r2 = this.length;
          if ((e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e2 && (t2 = e2), Bl.TYPED_ARRAY_SUPPORT)
            (n2 = this.subarray(e2, t2)).__proto__ = Bl.prototype;
          else {
            var o2 = t2 - e2;
            n2 = new Bl(o2, void 0);
            for (var i2 = 0; i2 < o2; ++i2)
              n2[i2] = this[i2 + e2];
          }
          return n2;
        }, Bl.prototype.readUIntLE = function(e2, t2, n2) {
          e2 |= 0, t2 |= 0, n2 || ep(e2, t2, this.length);
          for (var r2 = this[e2], o2 = 1, i2 = 0; ++i2 < t2 && (o2 *= 256); )
            r2 += this[e2 + i2] * o2;
          return r2;
        }, Bl.prototype.readUIntBE = function(e2, t2, n2) {
          e2 |= 0, t2 |= 0, n2 || ep(e2, t2, this.length);
          for (var r2 = this[e2 + --t2], o2 = 1; t2 > 0 && (o2 *= 256); )
            r2 += this[e2 + --t2] * o2;
          return r2;
        }, Bl.prototype.readUInt8 = function(e2, t2) {
          return t2 || ep(e2, 1, this.length), this[e2];
        }, Bl.prototype.readUInt16LE = function(e2, t2) {
          return t2 || ep(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
        }, Bl.prototype.readUInt16BE = function(e2, t2) {
          return t2 || ep(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
        }, Bl.prototype.readUInt32LE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
        }, Bl.prototype.readUInt32BE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
        }, Bl.prototype.readIntLE = function(e2, t2, n2) {
          e2 |= 0, t2 |= 0, n2 || ep(e2, t2, this.length);
          for (var r2 = this[e2], o2 = 1, i2 = 0; ++i2 < t2 && (o2 *= 256); )
            r2 += this[e2 + i2] * o2;
          return r2 >= (o2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
        }, Bl.prototype.readIntBE = function(e2, t2, n2) {
          e2 |= 0, t2 |= 0, n2 || ep(e2, t2, this.length);
          for (var r2 = t2, o2 = 1, i2 = this[e2 + --r2]; r2 > 0 && (o2 *= 256); )
            i2 += this[e2 + --r2] * o2;
          return i2 >= (o2 *= 128) && (i2 -= Math.pow(2, 8 * t2)), i2;
        }, Bl.prototype.readInt8 = function(e2, t2) {
          return t2 || ep(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
        }, Bl.prototype.readInt16LE = function(e2, t2) {
          t2 || ep(e2, 2, this.length);
          var n2 = this[e2] | this[e2 + 1] << 8;
          return 32768 & n2 ? 4294901760 | n2 : n2;
        }, Bl.prototype.readInt16BE = function(e2, t2) {
          t2 || ep(e2, 2, this.length);
          var n2 = this[e2 + 1] | this[e2] << 8;
          return 32768 & n2 ? 4294901760 | n2 : n2;
        }, Bl.prototype.readInt32LE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
        }, Bl.prototype.readInt32BE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
        }, Bl.prototype.readFloatLE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), Al(this, e2, true, 23, 4);
        }, Bl.prototype.readFloatBE = function(e2, t2) {
          return t2 || ep(e2, 4, this.length), Al(this, e2, false, 23, 4);
        }, Bl.prototype.readDoubleLE = function(e2, t2) {
          return t2 || ep(e2, 8, this.length), Al(this, e2, true, 52, 8);
        }, Bl.prototype.readDoubleBE = function(e2, t2) {
          return t2 || ep(e2, 8, this.length), Al(this, e2, false, 52, 8);
        }, Bl.prototype.writeUIntLE = function(e2, t2, n2, r2) {
          (e2 = +e2, t2 |= 0, n2 |= 0, r2) || tp(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
          var o2 = 1, i2 = 0;
          for (this[t2] = 255 & e2; ++i2 < n2 && (o2 *= 256); )
            this[t2 + i2] = e2 / o2 & 255;
          return t2 + n2;
        }, Bl.prototype.writeUIntBE = function(e2, t2, n2, r2) {
          (e2 = +e2, t2 |= 0, n2 |= 0, r2) || tp(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
          var o2 = n2 - 1, i2 = 1;
          for (this[t2 + o2] = 255 & e2; --o2 >= 0 && (i2 *= 256); )
            this[t2 + o2] = e2 / i2 & 255;
          return t2 + n2;
        }, Bl.prototype.writeUInt8 = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 1, 255, 0), Bl.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t2] = 255 & e2, t2 + 1;
        }, Bl.prototype.writeUInt16LE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : np(this, e2, t2, true), t2 + 2;
        }, Bl.prototype.writeUInt16BE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 2, 65535, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : np(this, e2, t2, false), t2 + 2;
        }, Bl.prototype.writeUInt32LE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = 255 & e2) : rp(this, e2, t2, true), t2 + 4;
        }, Bl.prototype.writeUInt32BE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 4, 4294967295, 0), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : rp(this, e2, t2, false), t2 + 4;
        }, Bl.prototype.writeIntLE = function(e2, t2, n2, r2) {
          if (e2 = +e2, t2 |= 0, !r2) {
            var o2 = Math.pow(2, 8 * n2 - 1);
            tp(this, e2, t2, n2, o2 - 1, -o2);
          }
          var i2 = 0, u2 = 1, s2 = 0;
          for (this[t2] = 255 & e2; ++i2 < n2 && (u2 *= 256); )
            e2 < 0 && s2 === 0 && this[t2 + i2 - 1] !== 0 && (s2 = 1), this[t2 + i2] = (e2 / u2 >> 0) - s2 & 255;
          return t2 + n2;
        }, Bl.prototype.writeIntBE = function(e2, t2, n2, r2) {
          if (e2 = +e2, t2 |= 0, !r2) {
            var o2 = Math.pow(2, 8 * n2 - 1);
            tp(this, e2, t2, n2, o2 - 1, -o2);
          }
          var i2 = n2 - 1, u2 = 1, s2 = 0;
          for (this[t2 + i2] = 255 & e2; --i2 >= 0 && (u2 *= 256); )
            e2 < 0 && s2 === 0 && this[t2 + i2 + 1] !== 0 && (s2 = 1), this[t2 + i2] = (e2 / u2 >> 0) - s2 & 255;
          return t2 + n2;
        }, Bl.prototype.writeInt8 = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 1, 127, -128), Bl.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = 255 & e2, t2 + 1;
        }, Bl.prototype.writeInt16LE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : np(this, e2, t2, true), t2 + 2;
        }, Bl.prototype.writeInt16BE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 2, 32767, -32768), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : np(this, e2, t2, false), t2 + 2;
        }, Bl.prototype.writeInt32LE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 4, 2147483647, -2147483648), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24) : rp(this, e2, t2, true), t2 + 4;
        }, Bl.prototype.writeInt32BE = function(e2, t2, n2) {
          return e2 = +e2, t2 |= 0, n2 || tp(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), Bl.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : rp(this, e2, t2, false), t2 + 4;
        }, Bl.prototype.writeFloatLE = function(e2, t2, n2) {
          return ip(this, e2, t2, true, n2);
        }, Bl.prototype.writeFloatBE = function(e2, t2, n2) {
          return ip(this, e2, t2, false, n2);
        }, Bl.prototype.writeDoubleLE = function(e2, t2, n2) {
          return up(this, e2, t2, true, n2);
        }, Bl.prototype.writeDoubleBE = function(e2, t2, n2) {
          return up(this, e2, t2, false, n2);
        }, Bl.prototype.copy = function(e2, t2, n2, r2) {
          if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
            return 0;
          if (e2.length === 0 || this.length === 0)
            return 0;
          if (t2 < 0)
            throw new RangeError("targetStart out of bounds");
          if (n2 < 0 || n2 >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (r2 < 0)
            throw new RangeError("sourceEnd out of bounds");
          r2 > this.length && (r2 = this.length), e2.length - t2 < r2 - n2 && (r2 = e2.length - t2 + n2);
          var o2, i2 = r2 - n2;
          if (this === e2 && n2 < t2 && t2 < r2)
            for (o2 = i2 - 1; o2 >= 0; --o2)
              e2[o2 + t2] = this[o2 + n2];
          else if (i2 < 1e3 || !Bl.TYPED_ARRAY_SUPPORT)
            for (o2 = 0; o2 < i2; ++o2)
              e2[o2 + t2] = this[o2 + n2];
          else
            Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + i2), t2);
          return i2;
        }, Bl.prototype.fill = function(e2, t2, n2, r2) {
          if (typeof e2 == "string") {
            if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e2.length === 1) {
              var o2 = e2.charCodeAt(0);
              o2 < 256 && (e2 = o2);
            }
            if (r2 !== void 0 && typeof r2 != "string")
              throw new TypeError("encoding must be a string");
            if (typeof r2 == "string" && !Bl.isEncoding(r2))
              throw new TypeError("Unknown encoding: " + r2);
          } else
            typeof e2 == "number" && (e2 &= 255);
          if (t2 < 0 || this.length < t2 || this.length < n2)
            throw new RangeError("Out of range index");
          if (n2 <= t2)
            return this;
          var i2;
          if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
            for (i2 = t2; i2 < n2; ++i2)
              this[i2] = e2;
          else {
            var u2 = Ll(e2) ? e2 : cp(new Bl(e2, r2).toString()), s2 = u2.length;
            for (i2 = 0; i2 < n2 - t2; ++i2)
              this[i2 + t2] = u2[i2 % s2];
          }
          return this;
        };
        var sp = /[^+\/0-9A-Za-z-_]/g;
        function ap(e2) {
          return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
        }
        function cp(e2, t2) {
          var n2;
          t2 = t2 || 1 / 0;
          for (var r2 = e2.length, o2 = null, i2 = [], u2 = 0; u2 < r2; ++u2) {
            if ((n2 = e2.charCodeAt(u2)) > 55295 && n2 < 57344) {
              if (!o2) {
                if (n2 > 56319) {
                  (t2 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                }
                if (u2 + 1 === r2) {
                  (t2 -= 3) > -1 && i2.push(239, 191, 189);
                  continue;
                }
                o2 = n2;
                continue;
              }
              if (n2 < 56320) {
                (t2 -= 3) > -1 && i2.push(239, 191, 189), o2 = n2;
                continue;
              }
              n2 = 65536 + (o2 - 55296 << 10 | n2 - 56320);
            } else
              o2 && (t2 -= 3) > -1 && i2.push(239, 191, 189);
            if (o2 = null, n2 < 128) {
              if ((t2 -= 1) < 0)
                break;
              i2.push(n2);
            } else if (n2 < 2048) {
              if ((t2 -= 2) < 0)
                break;
              i2.push(n2 >> 6 | 192, 63 & n2 | 128);
            } else if (n2 < 65536) {
              if ((t2 -= 3) < 0)
                break;
              i2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
            } else {
              if (!(n2 < 1114112))
                throw new Error("Invalid code point");
              if ((t2 -= 4) < 0)
                break;
              i2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
            }
          }
          return i2;
        }
        function lp(e2) {
          return function(e3) {
            var t2, n2, r2, o2, i2, u2;
            El || Cl();
            var s2 = e3.length;
            if (s2 % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            i2 = e3[s2 - 2] === "=" ? 2 : e3[s2 - 1] === "=" ? 1 : 0, u2 = new Dl(3 * s2 / 4 - i2), r2 = i2 > 0 ? s2 - 4 : s2;
            var a2 = 0;
            for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
              o2 = yl[e3.charCodeAt(t2)] << 18 | yl[e3.charCodeAt(t2 + 1)] << 12 | yl[e3.charCodeAt(t2 + 2)] << 6 | yl[e3.charCodeAt(t2 + 3)], u2[a2++] = o2 >> 16 & 255, u2[a2++] = o2 >> 8 & 255, u2[a2++] = 255 & o2;
            return i2 === 2 ? (o2 = yl[e3.charCodeAt(t2)] << 2 | yl[e3.charCodeAt(t2 + 1)] >> 4, u2[a2++] = 255 & o2) : i2 === 1 && (o2 = yl[e3.charCodeAt(t2)] << 10 | yl[e3.charCodeAt(t2 + 1)] << 4 | yl[e3.charCodeAt(t2 + 2)] >> 2, u2[a2++] = o2 >> 8 & 255, u2[a2++] = 255 & o2), u2;
          }(function(e3) {
            if ((e3 = function(e4) {
              return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
            }(e3).replace(sp, "")).length < 2)
              return "";
            for (; e3.length % 4 != 0; )
              e3 += "=";
            return e3;
          }(e2));
        }
        function pp(e2, t2, n2, r2) {
          for (var o2 = 0; o2 < r2 && !(o2 + n2 >= t2.length || o2 >= e2.length); ++o2)
            t2[o2 + n2] = e2[o2];
          return o2;
        }
        function fp(e2) {
          return e2 != null && (!!e2._isBuffer || dp(e2) || function(e3) {
            return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && dp(e3.slice(0, 0));
          }(e2));
        }
        function dp(e2) {
          return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
        }
        const hp = el;
        var gp = class {
          constructor(e2, t2) {
            (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e2 == "number" ? e2 : hp.openSync(e2, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
          }
          _searchInBuffer(e2, t2) {
            let n2 = -1;
            for (let r2 = 0; r2 <= e2.length; r2++) {
              if (e2[r2] === t2) {
                n2 = r2;
                break;
              }
            }
            return n2;
          }
          reset() {
            this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
          }
          close() {
            hp.closeSync(this.fd), this.fd = null;
          }
          _extractLines(e2) {
            let t2;
            const n2 = [];
            let r2 = 0, o2 = 0;
            for (; ; ) {
              let i3 = e2[r2++];
              if (i3 === this.newLineCharacter)
                t2 = e2.slice(o2, r2), n2.push(t2), o2 = r2;
              else if (i3 === void 0)
                break;
            }
            let i2 = e2.slice(o2, r2);
            return i2.length && n2.push(i2), n2;
          }
          _readChunk(e2) {
            let t2, n2 = 0;
            const r2 = [];
            do {
              const e3 = new Bl(this.options.readChunk);
              t2 = hp.readSync(this.fd, e3, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e3);
            } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
            let o2 = Bl.concat(r2);
            return t2 < this.options.readChunk && (this.eofReached = true, o2 = o2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(o2), e2 && (this.linesCache[0] = Bl.concat([e2, this.linesCache[0]]))), n2;
          }
          next() {
            if (!this.fd)
              return false;
            let e2, t2 = false;
            if (this.eofReached && this.linesCache.length === 0)
              return t2;
            if (this.linesCache.length || (e2 = this._readChunk()), this.linesCache.length) {
              t2 = this.linesCache.shift();
              t2[t2.length - 1] !== this.newLineCharacter && (e2 = this._readChunk(t2), e2 && (t2 = this.linesCache.shift()));
            }
            return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
          }
        };
        class mp extends Error {
        }
        class yp extends Error {
        }
        class Dp extends Error {
        }
        class Ep extends Error {
        }
        var Cp = { ConfigError: mp, DebugError: yp, UndefinedParserError: Dp, ArgExpansionBailout: Ep }, bp = {}, vp = function(e2, t2) {
          return vp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var n2 in t3)
              t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
          }, vp(e2, t2);
        };
        var Ap = function() {
          return Ap = Object.assign || function(e2) {
            for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
              for (var o2 in t2 = arguments[n2])
                Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
            return e2;
          }, Ap.apply(this, arguments);
        };
        function Fp(e2) {
          var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e2[t2], r2 = 0;
          if (n2)
            return n2.call(e2);
          if (e2 && typeof e2.length == "number")
            return { next: function() {
              return e2 && r2 >= e2.length && (e2 = void 0), { value: e2 && e2[r2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function xp(e2, t2) {
          var n2 = typeof Symbol == "function" && e2[Symbol.iterator];
          if (!n2)
            return e2;
          var r2, o2, i2 = n2.call(e2), u2 = [];
          try {
            for (; (t2 === void 0 || t2-- > 0) && !(r2 = i2.next()).done; )
              u2.push(r2.value);
          } catch (e3) {
            o2 = { error: e3 };
          } finally {
            try {
              r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
            } finally {
              if (o2)
                throw o2.error;
            }
          }
          return u2;
        }
        function Sp(e2) {
          return this instanceof Sp ? (this.v = e2, this) : new Sp(e2);
        }
        var wp = Object.freeze({ __proto__: null, __extends: function(e2, t2) {
          function n2() {
            this.constructor = e2;
          }
          vp(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
        }, get __assign() {
          return Ap;
        }, __rest: function(e2, t2) {
          var n2 = {};
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
          if (e2 != null && typeof Object.getOwnPropertySymbols == "function") {
            var o2 = 0;
            for (r2 = Object.getOwnPropertySymbols(e2); o2 < r2.length; o2++)
              t2.indexOf(r2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[o2]) && (n2[r2[o2]] = e2[r2[o2]]);
          }
          return n2;
        }, __decorate: function(e2, t2, n2, r2) {
          var o2, i2 = arguments.length, u2 = i2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            u2 = Reflect.decorate(e2, t2, n2, r2);
          else
            for (var s2 = e2.length - 1; s2 >= 0; s2--)
              (o2 = e2[s2]) && (u2 = (i2 < 3 ? o2(u2) : i2 > 3 ? o2(t2, n2, u2) : o2(t2, n2)) || u2);
          return i2 > 3 && u2 && Object.defineProperty(t2, n2, u2), u2;
        }, __param: function(e2, t2) {
          return function(n2, r2) {
            t2(n2, r2, e2);
          };
        }, __metadata: function(e2, t2) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e2, t2);
        }, __awaiter: function(e2, t2, n2, r2) {
          return new (n2 || (n2 = Promise))(function(o2, i2) {
            function u2(e3) {
              try {
                a2(r2.next(e3));
              } catch (e4) {
                i2(e4);
              }
            }
            function s2(e3) {
              try {
                a2(r2.throw(e3));
              } catch (e4) {
                i2(e4);
              }
            }
            function a2(e3) {
              var t3;
              e3.done ? o2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
                e4(t3);
              })).then(u2, s2);
            }
            a2((r2 = r2.apply(e2, t2 || [])).next());
          });
        }, __generator: function(e2, t2) {
          var n2, r2, o2, i2, u2 = { label: 0, sent: function() {
            if (1 & o2[0])
              throw o2[1];
            return o2[1];
          }, trys: [], ops: [] };
          return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, typeof Symbol == "function" && (i2[Symbol.iterator] = function() {
            return this;
          }), i2;
          function s2(i3) {
            return function(s3) {
              return function(i4) {
                if (n2)
                  throw new TypeError("Generator is already executing.");
                for (; u2; )
                  try {
                    if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                      return o2;
                    switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                      case 0:
                      case 1:
                        o2 = i4;
                        break;
                      case 4:
                        return u2.label++, { value: i4[1], done: false };
                      case 5:
                        u2.label++, r2 = i4[1], i4 = [0];
                        continue;
                      case 7:
                        i4 = u2.ops.pop(), u2.trys.pop();
                        continue;
                      default:
                        if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || i4[0] !== 6 && i4[0] !== 2)) {
                          u2 = 0;
                          continue;
                        }
                        if (i4[0] === 3 && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                          u2.label = i4[1];
                          break;
                        }
                        if (i4[0] === 6 && u2.label < o2[1]) {
                          u2.label = o2[1], o2 = i4;
                          break;
                        }
                        if (o2 && u2.label < o2[2]) {
                          u2.label = o2[2], u2.ops.push(i4);
                          break;
                        }
                        o2[2] && u2.ops.pop(), u2.trys.pop();
                        continue;
                    }
                    i4 = t2.call(e2, u2);
                  } catch (e3) {
                    i4 = [6, e3], r2 = 0;
                  } finally {
                    n2 = o2 = 0;
                  }
                if (5 & i4[0])
                  throw i4[1];
                return { value: i4[0] ? i4[1] : void 0, done: true };
              }([i3, s3]);
            };
          }
        }, __createBinding: function(e2, t2, n2, r2) {
          r2 === void 0 && (r2 = n2), e2[r2] = t2[n2];
        }, __exportStar: function(e2, t2) {
          for (var n2 in e2)
            n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e2[n2]);
        }, __values: Fp, __read: xp, __spread: function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(xp(arguments[t2]));
          return e2;
        }, __spreadArrays: function() {
          for (var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
            e2 += arguments[t2].length;
          var r2 = Array(e2), o2 = 0;
          for (t2 = 0; t2 < n2; t2++)
            for (var i2 = arguments[t2], u2 = 0, s2 = i2.length; u2 < s2; u2++, o2++)
              r2[o2] = i2[u2];
          return r2;
        }, __await: Sp, __asyncGenerator: function(e2, t2, n2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r2, o2 = n2.apply(e2, t2 || []), i2 = [];
          return r2 = {}, u2("next"), u2("throw"), u2("return"), r2[Symbol.asyncIterator] = function() {
            return this;
          }, r2;
          function u2(e3) {
            o2[e3] && (r2[e3] = function(t3) {
              return new Promise(function(n3, r3) {
                i2.push([e3, t3, n3, r3]) > 1 || s2(e3, t3);
              });
            });
          }
          function s2(e3, t3) {
            try {
              (n3 = o2[e3](t3)).value instanceof Sp ? Promise.resolve(n3.value.v).then(a2, c2) : l2(i2[0][2], n3);
            } catch (e4) {
              l2(i2[0][3], e4);
            }
            var n3;
          }
          function a2(e3) {
            s2("next", e3);
          }
          function c2(e3) {
            s2("throw", e3);
          }
          function l2(e3, t3) {
            e3(t3), i2.shift(), i2.length && s2(i2[0][0], i2[0][1]);
          }
        }, __asyncDelegator: function(e2) {
          var t2, n2;
          return t2 = {}, r2("next"), r2("throw", function(e3) {
            throw e3;
          }), r2("return"), t2[Symbol.iterator] = function() {
            return this;
          }, t2;
          function r2(r3, o2) {
            t2[r3] = e2[r3] ? function(t3) {
              return (n2 = !n2) ? { value: Sp(e2[r3](t3)), done: r3 === "return" } : o2 ? o2(t3) : t3;
            } : o2;
          }
        }, __asyncValues: function(e2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var t2, n2 = e2[Symbol.asyncIterator];
          return n2 ? n2.call(e2) : (e2 = Fp(e2), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
            return this;
          }, t2);
          function r2(n3) {
            t2[n3] = e2[n3] && function(t3) {
              return new Promise(function(r3, o2) {
                (function(e3, t4, n4, r4) {
                  Promise.resolve(r4).then(function(t5) {
                    e3({ value: t5, done: n4 });
                  }, t4);
                })(r3, o2, (t3 = e2[n3](t3)).done, t3.value);
              });
            };
          }
        }, __makeTemplateObject: function(e2, t2) {
          return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: t2 }) : e2.raw = t2, e2;
        }, __importStar: function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (e2 != null)
            for (var n2 in e2)
              Object.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
          return t2.default = e2, t2;
        }, __importDefault: function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }, __classPrivateFieldGet: function(e2, t2) {
          if (!t2.has(e2))
            throw new TypeError("attempted to get private field on non-instance");
          return t2.get(e2);
        }, __classPrivateFieldSet: function(e2, t2, n2) {
          if (!t2.has(e2))
            throw new TypeError("attempted to set private field on non-instance");
          return t2.set(e2, n2), n2;
        } }), Tp = {}, Bp = {};
        !function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true }), e2.apiDescriptor = { key: (e3) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3), value(t2) {
            if (t2 === null || typeof t2 != "object")
              return JSON.stringify(t2);
            if (Array.isArray(t2))
              return "[".concat(t2.map((t3) => e2.apiDescriptor.value(t3)).join(", "), "]");
            const n2 = Object.keys(t2);
            return n2.length === 0 ? "{}" : "{ ".concat(n2.map((n3) => "".concat(e2.apiDescriptor.key(n3), ": ").concat(e2.apiDescriptor.value(t2[n3]))).join(", "), " }");
          }, pair: (t2) => {
            let { key: n2, value: r2 } = t2;
            return e2.apiDescriptor.value({ [n2]: r2 });
          } };
        }(Bp), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          wp.__exportStar(Bp, e2);
        }(Tp);
        var Np = {}, kp = {}, Pp = {}, Op = { exports: {} }, Ip = /[|\\{}()[\]^$+*?.]/g, Lp = function(e2) {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          return e2.replace(Ip, "\\$&");
        }, jp = { exports: {} }, _p = { exports: {} }, Mp = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Rp = {};
        for (var Vp in Mp)
          Mp.hasOwnProperty(Vp) && (Rp[Mp[Vp]] = Vp);
        var $p = _p.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        for (var Wp in $p)
          if ($p.hasOwnProperty(Wp)) {
            if (!("channels" in $p[Wp]))
              throw new Error("missing channels property: " + Wp);
            if (!("labels" in $p[Wp]))
              throw new Error("missing channel labels property: " + Wp);
            if ($p[Wp].labels.length !== $p[Wp].channels)
              throw new Error("channel and label counts mismatch: " + Wp);
            var qp = $p[Wp].channels, Up = $p[Wp].labels;
            delete $p[Wp].channels, delete $p[Wp].labels, Object.defineProperty($p[Wp], "channels", { value: qp }), Object.defineProperty($p[Wp], "labels", { value: Up });
          }
        $p.rgb.hsl = function(e2) {
          var t2, n2, r2 = e2[0] / 255, o2 = e2[1] / 255, i2 = e2[2] / 255, u2 = Math.min(r2, o2, i2), s2 = Math.max(r2, o2, i2), a2 = s2 - u2;
          return s2 === u2 ? t2 = 0 : r2 === s2 ? t2 = (o2 - i2) / a2 : o2 === s2 ? t2 = 2 + (i2 - r2) / a2 : i2 === s2 && (t2 = 4 + (r2 - o2) / a2), (t2 = Math.min(60 * t2, 360)) < 0 && (t2 += 360), n2 = (u2 + s2) / 2, [t2, 100 * (s2 === u2 ? 0 : n2 <= 0.5 ? a2 / (s2 + u2) : a2 / (2 - s2 - u2)), 100 * n2];
        }, $p.rgb.hsv = function(e2) {
          var t2, n2, r2, o2, i2, u2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(u2, s2, a2), l2 = c2 - Math.min(u2, s2, a2), p2 = function(e3) {
            return (c2 - e3) / 6 / l2 + 0.5;
          };
          return l2 === 0 ? o2 = i2 = 0 : (i2 = l2 / c2, t2 = p2(u2), n2 = p2(s2), r2 = p2(a2), u2 === c2 ? o2 = r2 - n2 : s2 === c2 ? o2 = 1 / 3 + t2 - r2 : a2 === c2 && (o2 = 2 / 3 + n2 - t2), o2 < 0 ? o2 += 1 : o2 > 1 && (o2 -= 1)), [360 * o2, 100 * i2, 100 * c2];
        }, $p.rgb.hwb = function(e2) {
          var t2 = e2[0], n2 = e2[1], r2 = e2[2];
          return [$p.rgb.hsl(e2)[0], 100 * (1 / 255 * Math.min(t2, Math.min(n2, r2))), 100 * (r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)))];
        }, $p.rgb.cmyk = function(e2) {
          var t2, n2 = e2[0] / 255, r2 = e2[1] / 255, o2 = e2[2] / 255;
          return [100 * ((1 - n2 - (t2 = Math.min(1 - n2, 1 - r2, 1 - o2))) / (1 - t2) || 0), 100 * ((1 - r2 - t2) / (1 - t2) || 0), 100 * ((1 - o2 - t2) / (1 - t2) || 0), 100 * t2];
        }, $p.rgb.keyword = function(e2) {
          var t2 = Rp[e2];
          if (t2)
            return t2;
          var n2, r2, o2, i2 = 1 / 0;
          for (var u2 in Mp)
            if (Mp.hasOwnProperty(u2)) {
              var s2 = Mp[u2], a2 = (r2 = e2, o2 = s2, Math.pow(r2[0] - o2[0], 2) + Math.pow(r2[1] - o2[1], 2) + Math.pow(r2[2] - o2[2], 2));
              a2 < i2 && (i2 = a2, n2 = u2);
            }
          return n2;
        }, $p.keyword.rgb = function(e2) {
          return Mp[e2];
        }, $p.rgb.xyz = function(e2) {
          var t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
          return [100 * (0.4124 * (t2 = t2 > 0.04045 ? Math.pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92) + 0.3576 * (n2 = n2 > 0.04045 ? Math.pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92) + 0.1805 * (r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92)), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
        }, $p.rgb.lab = function(e2) {
          var t2 = $p.rgb.xyz(e2), n2 = t2[0], r2 = t2[1], o2 = t2[2];
          return r2 /= 100, o2 /= 108.883, n2 = (n2 /= 95.047) > 8856e-6 ? Math.pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116, [116 * (r2 = r2 > 8856e-6 ? Math.pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116) - 16, 500 * (n2 - r2), 200 * (r2 - (o2 = o2 > 8856e-6 ? Math.pow(o2, 1 / 3) : 7.787 * o2 + 16 / 116))];
        }, $p.hsl.rgb = function(e2) {
          var t2, n2, r2, o2, i2, u2 = e2[0] / 360, s2 = e2[1] / 100, a2 = e2[2] / 100;
          if (s2 === 0)
            return [i2 = 255 * a2, i2, i2];
          t2 = 2 * a2 - (n2 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), o2 = [0, 0, 0];
          for (var c2 = 0; c2 < 3; c2++)
            (r2 = u2 + 1 / 3 * -(c2 - 1)) < 0 && r2++, r2 > 1 && r2--, i2 = 6 * r2 < 1 ? t2 + 6 * (n2 - t2) * r2 : 2 * r2 < 1 ? n2 : 3 * r2 < 2 ? t2 + (n2 - t2) * (2 / 3 - r2) * 6 : t2, o2[c2] = 255 * i2;
          return o2;
        }, $p.hsl.hsv = function(e2) {
          var t2 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = n2, i2 = Math.max(r2, 0.01);
          return n2 *= (r2 *= 2) <= 1 ? r2 : 2 - r2, o2 *= i2 <= 1 ? i2 : 2 - i2, [t2, 100 * (r2 === 0 ? 2 * o2 / (i2 + o2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
        }, $p.hsv.rgb = function(e2) {
          var t2 = e2[0] / 60, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = Math.floor(t2) % 6, i2 = t2 - Math.floor(t2), u2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * i2), a2 = 255 * r2 * (1 - n2 * (1 - i2));
          switch (r2 *= 255, o2) {
            case 0:
              return [r2, a2, u2];
            case 1:
              return [s2, r2, u2];
            case 2:
              return [u2, r2, a2];
            case 3:
              return [u2, s2, r2];
            case 4:
              return [a2, u2, r2];
            case 5:
              return [r2, u2, s2];
          }
        }, $p.hsv.hsl = function(e2) {
          var t2, n2, r2, o2 = e2[0], i2 = e2[1] / 100, u2 = e2[2] / 100, s2 = Math.max(u2, 0.01);
          return r2 = (2 - i2) * u2, n2 = i2 * s2, [o2, 100 * (n2 = (n2 /= (t2 = (2 - i2) * s2) <= 1 ? t2 : 2 - t2) || 0), 100 * (r2 /= 2)];
        }, $p.hwb.rgb = function(e2) {
          var t2, n2, r2, o2, i2, u2, s2, a2 = e2[0] / 360, c2 = e2[1] / 100, l2 = e2[2] / 100, p2 = c2 + l2;
          switch (p2 > 1 && (c2 /= p2, l2 /= p2), r2 = 6 * a2 - (t2 = Math.floor(6 * a2)), (1 & t2) != 0 && (r2 = 1 - r2), o2 = c2 + r2 * ((n2 = 1 - l2) - c2), t2) {
            default:
            case 6:
            case 0:
              i2 = n2, u2 = o2, s2 = c2;
              break;
            case 1:
              i2 = o2, u2 = n2, s2 = c2;
              break;
            case 2:
              i2 = c2, u2 = n2, s2 = o2;
              break;
            case 3:
              i2 = c2, u2 = o2, s2 = n2;
              break;
            case 4:
              i2 = o2, u2 = c2, s2 = n2;
              break;
            case 5:
              i2 = n2, u2 = c2, s2 = o2;
          }
          return [255 * i2, 255 * u2, 255 * s2];
        }, $p.cmyk.rgb = function(e2) {
          var t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = e2[3] / 100;
          return [255 * (1 - Math.min(1, t2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, n2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, r2 * (1 - o2) + o2))];
        }, $p.xyz.rgb = function(e2) {
          var t2, n2, r2, o2 = e2[0] / 100, i2 = e2[1] / 100, u2 = e2[2] / 100;
          return n2 = -0.9689 * o2 + 1.8758 * i2 + 0.0415 * u2, r2 = 0.0557 * o2 + -0.204 * i2 + 1.057 * u2, t2 = (t2 = 3.2406 * o2 + -1.5372 * i2 + -0.4986 * u2) > 31308e-7 ? 1.055 * Math.pow(t2, 1 / 2.4) - 0.055 : 12.92 * t2, n2 = n2 > 31308e-7 ? 1.055 * Math.pow(n2, 1 / 2.4) - 0.055 : 12.92 * n2, r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : 12.92 * r2, [255 * (t2 = Math.min(Math.max(0, t2), 1)), 255 * (n2 = Math.min(Math.max(0, n2), 1)), 255 * (r2 = Math.min(Math.max(0, r2), 1))];
        }, $p.xyz.lab = function(e2) {
          var t2 = e2[0], n2 = e2[1], r2 = e2[2];
          return n2 /= 100, r2 /= 108.883, t2 = (t2 /= 95.047) > 8856e-6 ? Math.pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, [116 * (n2 = n2 > 8856e-6 ? Math.pow(n2, 1 / 3) : 7.787 * n2 + 16 / 116) - 16, 500 * (t2 - n2), 200 * (n2 - (r2 = r2 > 8856e-6 ? Math.pow(r2, 1 / 3) : 7.787 * r2 + 16 / 116))];
        }, $p.lab.xyz = function(e2) {
          var t2, n2, r2, o2 = e2[0];
          t2 = e2[1] / 500 + (n2 = (o2 + 16) / 116), r2 = n2 - e2[2] / 200;
          var i2 = Math.pow(n2, 3), u2 = Math.pow(t2, 3), s2 = Math.pow(r2, 3);
          return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = s2 > 8856e-6 ? s2 : (r2 - 16 / 116) / 7.787, [t2 *= 95.047, n2 *= 100, r2 *= 108.883];
        }, $p.lab.lch = function(e2) {
          var t2, n2 = e2[0], r2 = e2[1], o2 = e2[2];
          return (t2 = 360 * Math.atan2(o2, r2) / 2 / Math.PI) < 0 && (t2 += 360), [n2, Math.sqrt(r2 * r2 + o2 * o2), t2];
        }, $p.lch.lab = function(e2) {
          var t2, n2 = e2[0], r2 = e2[1];
          return t2 = e2[2] / 360 * 2 * Math.PI, [n2, r2 * Math.cos(t2), r2 * Math.sin(t2)];
        }, $p.rgb.ansi16 = function(e2) {
          var t2 = e2[0], n2 = e2[1], r2 = e2[2], o2 = 1 in arguments ? arguments[1] : $p.rgb.hsv(e2)[2];
          if ((o2 = Math.round(o2 / 50)) === 0)
            return 30;
          var i2 = 30 + (Math.round(r2 / 255) << 2 | Math.round(n2 / 255) << 1 | Math.round(t2 / 255));
          return o2 === 2 && (i2 += 60), i2;
        }, $p.hsv.ansi16 = function(e2) {
          return $p.rgb.ansi16($p.hsv.rgb(e2), e2[2]);
        }, $p.rgb.ansi256 = function(e2) {
          var t2 = e2[0], n2 = e2[1], r2 = e2[2];
          return t2 === n2 && n2 === r2 ? t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
        }, $p.ansi16.rgb = function(e2) {
          var t2 = e2 % 10;
          if (t2 === 0 || t2 === 7)
            return e2 > 50 && (t2 += 3.5), [t2 = t2 / 10.5 * 255, t2, t2];
          var n2 = 0.5 * (1 + ~~(e2 > 50));
          return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
        }, $p.ansi256.rgb = function(e2) {
          if (e2 >= 232) {
            var t2 = 10 * (e2 - 232) + 8;
            return [t2, t2, t2];
          }
          var n2;
          return e2 -= 16, [Math.floor(e2 / 36) / 5 * 255, Math.floor((n2 = e2 % 36) / 6) / 5 * 255, n2 % 6 / 5 * 255];
        }, $p.rgb.hex = function(e2) {
          var t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
          return "000000".substring(t2.length) + t2;
        }, $p.hex.rgb = function(e2) {
          var t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t2)
            return [0, 0, 0];
          var n2 = t2[0];
          t2[0].length === 3 && (n2 = n2.split("").map(function(e3) {
            return e3 + e3;
          }).join(""));
          var r2 = parseInt(n2, 16);
          return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
        }, $p.rgb.hcg = function(e2) {
          var t2, n2 = e2[0] / 255, r2 = e2[1] / 255, o2 = e2[2] / 255, i2 = Math.max(Math.max(n2, r2), o2), u2 = Math.min(Math.min(n2, r2), o2), s2 = i2 - u2;
          return t2 = s2 <= 0 ? 0 : i2 === n2 ? (r2 - o2) / s2 % 6 : i2 === r2 ? 2 + (o2 - n2) / s2 : 4 + (n2 - r2) / s2 + 4, t2 /= 6, [360 * (t2 %= 1), 100 * s2, 100 * (s2 < 1 ? u2 / (1 - s2) : 0)];
        }, $p.hsl.hcg = function(e2) {
          var t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = 1, o2 = 0;
          return (r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2)) < 1 && (o2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, $p.hsv.hcg = function(e2) {
          var t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = t2 * n2, o2 = 0;
          return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, $p.hcg.rgb = function(e2) {
          var t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
          if (n2 === 0)
            return [255 * r2, 255 * r2, 255 * r2];
          var o2, i2 = [0, 0, 0], u2 = t2 % 1 * 6, s2 = u2 % 1, a2 = 1 - s2;
          switch (Math.floor(u2)) {
            case 0:
              i2[0] = 1, i2[1] = s2, i2[2] = 0;
              break;
            case 1:
              i2[0] = a2, i2[1] = 1, i2[2] = 0;
              break;
            case 2:
              i2[0] = 0, i2[1] = 1, i2[2] = s2;
              break;
            case 3:
              i2[0] = 0, i2[1] = a2, i2[2] = 1;
              break;
            case 4:
              i2[0] = s2, i2[1] = 0, i2[2] = 1;
              break;
            default:
              i2[0] = 1, i2[1] = 0, i2[2] = a2;
          }
          return o2 = (1 - n2) * r2, [255 * (n2 * i2[0] + o2), 255 * (n2 * i2[1] + o2), 255 * (n2 * i2[2] + o2)];
        }, $p.hcg.hsv = function(e2) {
          var t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2), r2 = 0;
          return n2 > 0 && (r2 = t2 / n2), [e2[0], 100 * r2, 100 * n2];
        }, $p.hcg.hsl = function(e2) {
          var t2 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t2) + 0.5 * t2, r2 = 0;
          return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
        }, $p.hcg.hwb = function(e2) {
          var t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
          return [e2[0], 100 * (n2 - t2), 100 * (1 - n2)];
        }, $p.hwb.hcg = function(e2) {
          var t2 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t2, o2 = 0;
          return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, $p.apple.rgb = function(e2) {
          return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
        }, $p.rgb.apple = function(e2) {
          return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
        }, $p.gray.rgb = function(e2) {
          return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
        }, $p.gray.hsl = $p.gray.hsv = function(e2) {
          return [0, 0, e2[0]];
        }, $p.gray.hwb = function(e2) {
          return [0, 100, e2[0]];
        }, $p.gray.cmyk = function(e2) {
          return [0, 0, 0, e2[0]];
        }, $p.gray.lab = function(e2) {
          return [e2[0], 0, 0];
        }, $p.gray.hex = function(e2) {
          var t2 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
          return "000000".substring(n2.length) + n2;
        }, $p.rgb.gray = function(e2) {
          return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
        };
        var zp = _p.exports;
        function Gp(e2) {
          var t2 = function() {
            for (var e3 = {}, t3 = Object.keys(zp), n3 = t3.length, r3 = 0; r3 < n3; r3++)
              e3[t3[r3]] = { distance: -1, parent: null };
            return e3;
          }(), n2 = [e2];
          for (t2[e2].distance = 0; n2.length; )
            for (var r2 = n2.pop(), o2 = Object.keys(zp[r2]), i2 = o2.length, u2 = 0; u2 < i2; u2++) {
              var s2 = o2[u2], a2 = t2[s2];
              a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
            }
          return t2;
        }
        function Hp(e2, t2) {
          return function(n2) {
            return t2(e2(n2));
          };
        }
        function Jp(e2, t2) {
          for (var n2 = [t2[e2].parent, e2], r2 = zp[t2[e2].parent][e2], o2 = t2[e2].parent; t2[o2].parent; )
            n2.unshift(t2[o2].parent), r2 = Hp(zp[t2[o2].parent][o2], r2), o2 = t2[o2].parent;
          return r2.conversion = n2, r2;
        }
        var Xp = _p.exports, Yp = function(e2) {
          for (var t2 = Gp(e2), n2 = {}, r2 = Object.keys(t2), o2 = r2.length, i2 = 0; i2 < o2; i2++) {
            var u2 = r2[i2];
            t2[u2].parent !== null && (n2[u2] = Jp(u2, t2));
          }
          return n2;
        }, Kp = {};
        Object.keys(Xp).forEach(function(e2) {
          Kp[e2] = {}, Object.defineProperty(Kp[e2], "channels", { value: Xp[e2].channels }), Object.defineProperty(Kp[e2], "labels", { value: Xp[e2].labels });
          var t2 = Yp(e2);
          Object.keys(t2).forEach(function(n2) {
            var r2 = t2[n2];
            Kp[e2][n2] = function(e3) {
              var t3 = function(t4) {
                if (t4 == null)
                  return t4;
                arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
                var n3 = e3(t4);
                if (typeof n3 == "object")
                  for (var r3 = n3.length, o2 = 0; o2 < r3; o2++)
                    n3[o2] = Math.round(n3[o2]);
                return n3;
              };
              return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
            }(r2), Kp[e2][n2].raw = function(e3) {
              var t3 = function(t4) {
                return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e3(t4));
              };
              return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
            }(r2);
          });
        });
        var Qp, Zp = Kp;
        function ef() {
          if (Qp === void 0) {
            var e2 = new ArrayBuffer(2), t2 = new Uint8Array(e2), n2 = new Uint16Array(e2);
            if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
              Qp = "BE";
            else {
              if (n2[0] !== 513)
                throw new Error("unable to figure out endianess");
              Qp = "LE";
            }
          }
          return Qp;
        }
        function tf() {
          return Ns.location !== void 0 ? Ns.location.hostname : "";
        }
        function nf() {
          return [];
        }
        function rf() {
          return 0;
        }
        function of() {
          return Number.MAX_VALUE;
        }
        function uf() {
          return Number.MAX_VALUE;
        }
        function sf() {
          return [];
        }
        function af() {
          return "Browser";
        }
        function cf() {
          return Ns.navigator !== void 0 ? Ns.navigator.appVersion : "";
        }
        function lf() {
        }
        function pf() {
        }
        function ff() {
          return "javascript";
        }
        function df() {
          return "browser";
        }
        function hf() {
          return "/tmp";
        }
        !function(e2) {
          const t2 = Zp, n2 = (e3, n3) => function() {
            const r3 = e3.apply(t2, arguments);
            return "\x1B[".concat(r3 + n3, "m");
          }, r2 = (e3, n3) => function() {
            const r3 = e3.apply(t2, arguments);
            return "\x1B[".concat(38 + n3, ";5;").concat(r3, "m");
          }, o2 = (e3, n3) => function() {
            const r3 = e3.apply(t2, arguments);
            return "\x1B[".concat(38 + n3, ";2;").concat(r3[0], ";").concat(r3[1], ";").concat(r3[2], "m");
          };
          Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
            const e3 = /* @__PURE__ */ new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
            i2.color.grey = i2.color.gray;
            for (const t3 of Object.keys(i2)) {
              const n3 = i2[t3];
              for (const t4 of Object.keys(n3)) {
                const r3 = n3[t4];
                i2[t4] = { open: "\x1B[".concat(r3[0], "m"), close: "\x1B[".concat(r3[1], "m") }, n3[t4] = i2[t4], e3.set(r3[0], r3[1]);
              }
              Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
            }
            const u2 = (e4) => e4, s2 = (e4, t3, n3) => [e4, t3, n3];
            i2.color.close = "\x1B[39m", i2.bgColor.close = "\x1B[49m", i2.color.ansi = { ansi: n2(u2, 0) }, i2.color.ansi256 = { ansi256: r2(u2, 0) }, i2.color.ansi16m = { rgb: o2(s2, 0) }, i2.bgColor.ansi = { ansi: n2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: r2(u2, 10) }, i2.bgColor.ansi16m = { rgb: o2(s2, 10) };
            for (let e4 of Object.keys(t2)) {
              if (typeof t2[e4] != "object")
                continue;
              const u3 = t2[e4];
              e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = n2(u3.ansi16, 0), i2.bgColor.ansi[e4] = n2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = r2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = r2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = o2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = o2(u3.rgb, 10));
            }
            return i2;
          } });
        }(jp);
        var gf = hf, mf = { EOL: "\n", arch: ff, platform: df, tmpdir: gf, tmpDir: hf, networkInterfaces: lf, getNetworkInterfaces: pf, release: cf, type: af, cpus: sf, totalmem: uf, freemem: of, uptime: rf, loadavg: nf, hostname: tf, endianness: ef }, yf = t(Object.freeze({ __proto__: null, endianness: ef, hostname: tf, loadavg: nf, uptime: rf, freemem: of, totalmem: uf, cpus: sf, type: af, release: cf, networkInterfaces: lf, getNetworkInterfaces: pf, arch: ff, platform: df, tmpDir: hf, tmpdir: gf, EOL: "\n", default: mf }));
        const Df = yf, Ef = (e2, t2) => {
          t2 = t2 || ta.argv;
          const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), o2 = t2.indexOf("--");
          return r2 !== -1 && (o2 === -1 || r2 < o2);
        }, Cf = ta.env;
        let bf;
        function vf(e2) {
          const t2 = function(e3) {
            if (bf === false)
              return 0;
            if (Ef("color=16m") || Ef("color=full") || Ef("color=truecolor"))
              return 3;
            if (Ef("color=256"))
              return 2;
            if (e3 && !e3.isTTY && bf !== true)
              return 0;
            const t3 = bf ? 1 : 0;
            if (ta.platform === "win32") {
              const e4 = Df.release().split(".");
              return Number(ta.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
            }
            if ("CI" in Cf)
              return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Cf) || Cf.CI_NAME === "codeship" ? 1 : t3;
            if ("TEAMCITY_VERSION" in Cf)
              return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Cf.TEAMCITY_VERSION) ? 1 : 0;
            if (Cf.COLORTERM === "truecolor")
              return 3;
            if ("TERM_PROGRAM" in Cf) {
              const e4 = parseInt((Cf.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
              switch (Cf.TERM_PROGRAM) {
                case "iTerm.app":
                  return e4 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                  return 2;
              }
            }
            return /-256(color)?$/i.test(Cf.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Cf.TERM) || "COLORTERM" in Cf ? 1 : (Cf.TERM, t3);
          }(e2);
          return function(e3) {
            return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
          }(t2);
        }
        Ef("no-color") || Ef("no-colors") || Ef("color=false") ? bf = false : (Ef("color") || Ef("colors") || Ef("color=true") || Ef("color=always")) && (bf = true), "FORCE_COLOR" in Cf && (bf = Cf.FORCE_COLOR.length === 0 || parseInt(Cf.FORCE_COLOR, 10) !== 0);
        var Af = { supportsColor: vf, stdout: vf(ta.stdout), stderr: vf(ta.stderr) };
        const Ff = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, xf = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Sf = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, wf = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Tf = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
        function Bf(e2) {
          return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Tf.get(e2) || e2;
        }
        function Nf(e2, t2) {
          const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
          let o2;
          for (const t3 of r2)
            if (isNaN(t3)) {
              if (!(o2 = t3.match(Sf)))
                throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
              n2.push(o2[2].replace(wf, (e3, t4, n3) => t4 ? Bf(t4) : n3));
            } else
              n2.push(Number(t3));
          return n2;
        }
        function kf(e2) {
          xf.lastIndex = 0;
          const t2 = [];
          let n2;
          for (; (n2 = xf.exec(e2)) !== null; ) {
            const e3 = n2[1];
            if (n2[2]) {
              const r2 = Nf(e3, n2[2]);
              t2.push([e3].concat(r2));
            } else
              t2.push([e3]);
          }
          return t2;
        }
        function Pf(e2, t2) {
          const n2 = {};
          for (const e3 of t2)
            for (const t3 of e3.styles)
              n2[t3[0]] = e3.inverse ? null : t3.slice(1);
          let r2 = e2;
          for (const e3 of Object.keys(n2))
            if (Array.isArray(n2[e3])) {
              if (!(e3 in r2))
                throw new Error("Unknown Chalk style: ".concat(e3));
              r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
            }
          return r2;
        }
        var Of = (e2, t2) => {
          const n2 = [], r2 = [];
          let o2 = [];
          if (t2.replace(Ff, (t3, i2, u2, s2, a2, c2) => {
            if (i2)
              o2.push(Bf(i2));
            else if (s2) {
              const t4 = o2.join("");
              o2 = [], r2.push(n2.length === 0 ? t4 : Pf(e2, n2)(t4)), n2.push({ inverse: u2, styles: kf(s2) });
            } else if (a2) {
              if (n2.length === 0)
                throw new Error("Found extraneous } in Chalk template literal");
              r2.push(Pf(e2, n2)(o2.join(""))), o2 = [], n2.pop();
            } else
              o2.push(c2);
          }), r2.push(o2.join("")), n2.length > 0) {
            const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
            throw new Error(e3);
          }
          return r2.join("");
        };
        !function(e2) {
          const t2 = Lp, n2 = jp.exports, r2 = Af.stdout, o2 = Of, i2 = ta.platform === "win32" && !(ta.env.TERM || "").toLowerCase().startsWith("xterm"), u2 = ["ansi", "ansi", "ansi256", "ansi16m"], s2 = /* @__PURE__ */ new Set(["gray"]), a2 = /* @__PURE__ */ Object.create(null);
          function c2(e3, t3) {
            t3 = t3 || {};
            const n3 = r2 ? r2.level : 0;
            e3.level = t3.level === void 0 ? n3 : t3.level, e3.enabled = "enabled" in t3 ? t3.enabled : e3.level > 0;
          }
          function l2(e3) {
            if (!this || !(this instanceof l2) || this.template) {
              const t3 = {};
              return c2(t3, e3), t3.template = function() {
                const e4 = [].slice.call(arguments);
                return h2.apply(null, [t3.template].concat(e4));
              }, Object.setPrototypeOf(t3, l2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = l2, t3.template;
            }
            c2(this, e3);
          }
          i2 && (n2.blue.open = "\x1B[94m");
          for (const e3 of Object.keys(n2))
            n2[e3].closeRe = new RegExp(t2(n2[e3].close), "g"), a2[e3] = { get() {
              const t3 = n2[e3];
              return f2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
            } };
          a2.visible = { get() {
            return f2.call(this, this._styles || [], true, "visible");
          } }, n2.color.closeRe = new RegExp(t2(n2.color.close), "g");
          for (const e3 of Object.keys(n2.color.ansi))
            s2.has(e3) || (a2[e3] = { get() {
              const t3 = this.level;
              return function() {
                const r3 = n2.color[u2[t3]][e3].apply(null, arguments), o3 = { open: r3, close: n2.color.close, closeRe: n2.color.closeRe };
                return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
              };
            } });
          n2.bgColor.closeRe = new RegExp(t2(n2.bgColor.close), "g");
          for (const e3 of Object.keys(n2.bgColor.ansi)) {
            if (s2.has(e3))
              continue;
            a2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
              const t3 = this.level;
              return function() {
                const r3 = n2.bgColor[u2[t3]][e3].apply(null, arguments), o3 = { open: r3, close: n2.bgColor.close, closeRe: n2.bgColor.closeRe };
                return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
              };
            } };
          }
          const p2 = Object.defineProperties(() => {
          }, a2);
          function f2(e3, t3, n3) {
            const r3 = function() {
              return d2.apply(r3, arguments);
            };
            r3._styles = e3, r3._empty = t3;
            const o3 = this;
            return Object.defineProperty(r3, "level", { enumerable: true, get: () => o3.level, set(e4) {
              o3.level = e4;
            } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => o3.enabled, set(e4) {
              o3.enabled = e4;
            } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = p2, r3;
          }
          function d2() {
            const e3 = arguments, t3 = e3.length;
            let r3 = String(arguments[0]);
            if (t3 === 0)
              return "";
            if (t3 > 1)
              for (let n3 = 1; n3 < t3; n3++)
                r3 += " " + e3[n3];
            if (!this.enabled || this.level <= 0 || !r3)
              return this._empty ? "" : r3;
            const o3 = n2.dim.open;
            i2 && this.hasGrey && (n2.dim.open = "");
            for (const e4 of this._styles.slice().reverse())
              r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
            return n2.dim.open = o3, r3;
          }
          function h2(e3, t3) {
            if (!Array.isArray(t3))
              return [].slice.call(arguments, 1).join(" ");
            const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
            for (let e4 = 1; e4 < t3.length; e4++)
              r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
            return o2(e3, r3.join(""));
          }
          Object.defineProperties(l2.prototype, a2), e2.exports = l2(), e2.exports.supportsColor = r2, e2.exports.default = e2.exports;
        }(Op), Object.defineProperty(Pp, "__esModule", { value: true });
        const If = Op.exports;
        Pp.commonDeprecatedHandler = (e2, t2, n2) => {
          let { descriptor: r2 } = n2;
          const o2 = ["".concat(If.default.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2)), " is deprecated")];
          return t2 && o2.push("we now treat it as ".concat(If.default.blue(typeof t2 == "string" ? r2.key(t2) : r2.pair(t2)))), o2.join("; ") + ".";
        }, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          wp.__exportStar(Pp, e2);
        }(kp);
        var Lf = {}, jf = {};
        Object.defineProperty(jf, "__esModule", { value: true });
        const _f = Op.exports;
        jf.commonInvalidHandler = (e2, t2, n2) => ["Invalid ".concat(_f.default.red(n2.descriptor.key(e2)), " value."), "Expected ".concat(_f.default.blue(n2.schemas[e2].expected(n2)), ","), "but received ".concat(_f.default.red(n2.descriptor.value(t2)), ".")].join(" "), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          wp.__exportStar(jf, e2);
        }(Lf);
        var Mf = {}, Rf = {}, Vf = [], $f = [];
        Object.defineProperty(Rf, "__esModule", { value: true });
        const Wf = Op.exports, qf = function(e2, t2) {
          if (e2 === t2)
            return 0;
          var n2 = e2;
          e2.length > t2.length && (e2 = t2, t2 = n2);
          var r2 = e2.length, o2 = t2.length;
          if (r2 === 0)
            return o2;
          if (o2 === 0)
            return r2;
          for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-o2); )
            r2--, o2--;
          if (r2 === 0)
            return o2;
          for (var i2, u2, s2, a2, c2 = 0; c2 < r2 && e2.charCodeAt(c2) === t2.charCodeAt(c2); )
            c2++;
          if (o2 -= c2, (r2 -= c2) === 0)
            return o2;
          for (var l2 = 0, p2 = 0; l2 < r2; )
            $f[c2 + l2] = e2.charCodeAt(c2 + l2), Vf[l2] = ++l2;
          for (; p2 < o2; )
            for (i2 = t2.charCodeAt(c2 + p2), s2 = p2++, u2 = p2, l2 = 0; l2 < r2; l2++)
              a2 = i2 === $f[c2 + l2] ? s2 : s2 + 1, s2 = Vf[l2], u2 = Vf[l2] = s2 > u2 ? a2 > u2 ? u2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
          return u2;
        };
        Rf.levenUnknownHandler = (e2, t2, n2) => {
          let { descriptor: r2, logger: o2, schemas: i2 } = n2;
          const u2 = ["Ignored unknown option ".concat(Wf.default.yellow(r2.pair({ key: e2, value: t2 })), ".")], s2 = Object.keys(i2).sort().find((t3) => qf(e2, t3) < 3);
          s2 && u2.push("Did you mean ".concat(Wf.default.blue(r2.key(s2)), "?")), o2.warn(u2.join(" "));
        }, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          wp.__exportStar(Rf, e2);
        }(Mf), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = wp;
          t2.__exportStar(kp, e2), t2.__exportStar(Lf, e2), t2.__exportStar(Mf, e2);
        }(Np);
        var Uf = {}, zf = {}, Gf = {};
        Object.defineProperty(Gf, "__esModule", { value: true });
        const Hf = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
        function Jf(e2, t2) {
          const n2 = new e2(t2), r2 = Object.create(n2);
          for (const e3 of Hf)
            e3 in t2 && (r2[e3] = Yf(t2[e3], n2, Xf.prototype[e3].length));
          return r2;
        }
        Gf.createSchema = Jf;
        class Xf {
          constructor(e2) {
            this.name = e2.name;
          }
          static create(e2) {
            return Jf(this, e2);
          }
          default(e2) {
          }
          expected(e2) {
            return "nothing";
          }
          validate(e2, t2) {
            return false;
          }
          deprecated(e2, t2) {
            return false;
          }
          forward(e2, t2) {
          }
          redirect(e2, t2) {
          }
          overlap(e2, t2, n2) {
            return e2;
          }
          preprocess(e2, t2) {
            return e2;
          }
          postprocess(e2, t2) {
            return e2;
          }
        }
        function Yf(e2, t2, n2) {
          return typeof e2 == "function" ? function() {
            for (var r2 = arguments.length, o2 = new Array(r2), i2 = 0; i2 < r2; i2++)
              o2[i2] = arguments[i2];
            return e2(...o2.slice(0, n2 - 1), t2, ...o2.slice(n2 - 1));
          } : () => e2;
        }
        Gf.Schema = Xf, Object.defineProperty(zf, "__esModule", { value: true });
        const Kf = Gf;
        class Qf extends Kf.Schema {
          constructor(e2) {
            super(e2), this._sourceName = e2.sourceName;
          }
          expected(e2) {
            return e2.schemas[this._sourceName].expected(e2);
          }
          validate(e2, t2) {
            return t2.schemas[this._sourceName].validate(e2, t2);
          }
          redirect(e2, t2) {
            return this._sourceName;
          }
        }
        zf.AliasSchema = Qf;
        var Zf = {};
        Object.defineProperty(Zf, "__esModule", { value: true });
        const ed = Gf;
        class td extends ed.Schema {
          expected() {
            return "anything";
          }
          validate() {
            return true;
          }
        }
        Zf.AnySchema = td;
        var nd = {};
        Object.defineProperty(nd, "__esModule", { value: true });
        const rd = wp, od = Gf;
        class id extends od.Schema {
          constructor(e2) {
            var { valueSchema: t2, name: n2 = t2.name } = e2, r2 = rd.__rest(e2, ["valueSchema", "name"]);
            super(Object.assign({}, r2, { name: n2 })), this._valueSchema = t2;
          }
          expected(e2) {
            return "an array of ".concat(this._valueSchema.expected(e2));
          }
          validate(e2, t2) {
            if (!Array.isArray(e2))
              return false;
            const n2 = [];
            for (const r2 of e2) {
              const e3 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
              e3 !== true && n2.push(e3.value);
            }
            return n2.length === 0 || { value: n2 };
          }
          deprecated(e2, t2) {
            const n2 = [];
            for (const r2 of e2) {
              const e3 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
              e3 !== false && n2.push(...e3.map((e4) => {
                let { value: t3 } = e4;
                return { value: [t3] };
              }));
            }
            return n2;
          }
          forward(e2, t2) {
            const n2 = [];
            for (const r2 of e2) {
              const e3 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
              n2.push(...e3.map(ud));
            }
            return n2;
          }
          redirect(e2, t2) {
            const n2 = [], r2 = [];
            for (const o2 of e2) {
              const e3 = t2.normalizeRedirectResult(this._valueSchema.redirect(o2, t2), o2);
              "remain" in e3 && n2.push(e3.remain), r2.push(...e3.redirect.map(ud));
            }
            return n2.length === 0 ? { redirect: r2 } : { redirect: r2, remain: n2 };
          }
          overlap(e2, t2) {
            return e2.concat(t2);
          }
        }
        function ud(e2) {
          let { from: t2, to: n2 } = e2;
          return { from: [t2], to: n2 };
        }
        nd.ArraySchema = id;
        var sd = {};
        Object.defineProperty(sd, "__esModule", { value: true });
        const ad = Gf;
        class cd extends ad.Schema {
          expected() {
            return "true or false";
          }
          validate(e2) {
            return typeof e2 == "boolean";
          }
        }
        sd.BooleanSchema = cd;
        var ld = {}, pd = {};
        function fd(e2, t2) {
          return typeof e2 == "string" || "key" in e2 ? { from: t2, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t2, to: e2.to };
        }
        function dd(e2, t2) {
          return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((e3) => fd(e3, t2)) : [fd(e2, t2)];
        }
        Object.defineProperty(pd, "__esModule", { value: true }), pd.recordFromArray = function(e2, t2) {
          const n2 = /* @__PURE__ */ Object.create(null);
          for (const r2 of e2) {
            const e3 = r2[t2];
            if (n2[e3])
              throw new Error("Duplicate ".concat(t2, " ").concat(JSON.stringify(e3)));
            n2[e3] = r2;
          }
          return n2;
        }, pd.mapFromArray = function(e2, t2) {
          const n2 = /* @__PURE__ */ new Map();
          for (const r2 of e2) {
            const e3 = r2[t2];
            if (n2.has(e3))
              throw new Error("Duplicate ".concat(t2, " ").concat(JSON.stringify(e3)));
            n2.set(e3, r2);
          }
          return n2;
        }, pd.createAutoChecklist = function() {
          const e2 = /* @__PURE__ */ Object.create(null);
          return (t2) => {
            const n2 = JSON.stringify(t2);
            return !!e2[n2] || (e2[n2] = true, false);
          };
        }, pd.partition = function(e2, t2) {
          const n2 = [], r2 = [];
          for (const o2 of e2)
            t2(o2) ? n2.push(o2) : r2.push(o2);
          return [n2, r2];
        }, pd.isInt = function(e2) {
          return e2 === Math.floor(e2);
        }, pd.comparePrimitive = function(e2, t2) {
          if (e2 === t2)
            return 0;
          const n2 = typeof e2, r2 = typeof t2, o2 = ["undefined", "object", "boolean", "number", "string"];
          return n2 !== r2 ? o2.indexOf(n2) - o2.indexOf(r2) : n2 !== "string" ? Number(e2) - Number(t2) : e2.localeCompare(t2);
        }, pd.normalizeDefaultResult = function(e2) {
          return e2 === void 0 ? {} : e2;
        }, pd.normalizeValidateResult = function(e2, t2) {
          return e2 === true || (e2 === false ? { value: t2 } : e2);
        }, pd.normalizeDeprecatedResult = function(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          return e2 !== false && (e2 === true ? !!n2 || [{ value: t2 }] : "value" in e2 ? [e2] : e2.length !== 0 && e2);
        }, pd.normalizeTransferResult = fd, pd.normalizeForwardResult = dd, pd.normalizeRedirectResult = function(e2, t2) {
          const n2 = dd(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t2);
          return n2.length === 0 ? { remain: t2, redirect: n2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: n2 } : { redirect: n2 };
        }, Object.defineProperty(ld, "__esModule", { value: true });
        const hd = Gf, gd = pd;
        class md extends hd.Schema {
          constructor(e2) {
            super(e2), this._choices = gd.mapFromArray(e2.choices.map((e3) => e3 && typeof e3 == "object" ? e3 : { value: e3 }), "value");
          }
          expected(e2) {
            let { descriptor: t2 } = e2;
            const n2 = Array.from(this._choices.keys()).map((e3) => this._choices.get(e3)).filter((e3) => !e3.deprecated).map((e3) => e3.value).sort(gd.comparePrimitive).map(t2.value), r2 = n2.slice(0, -2), o2 = n2.slice(-2);
            return r2.concat(o2.join(" or ")).join(", ");
          }
          validate(e2) {
            return this._choices.has(e2);
          }
          deprecated(e2) {
            const t2 = this._choices.get(e2);
            return !(!t2 || !t2.deprecated) && { value: e2 };
          }
          forward(e2) {
            const t2 = this._choices.get(e2);
            return t2 ? t2.forward : void 0;
          }
          redirect(e2) {
            const t2 = this._choices.get(e2);
            return t2 ? t2.redirect : void 0;
          }
        }
        ld.ChoiceSchema = md;
        var yd = {}, Dd = {};
        Object.defineProperty(Dd, "__esModule", { value: true });
        const Ed = Gf;
        class Cd extends Ed.Schema {
          expected() {
            return "a number";
          }
          validate(e2, t2) {
            return typeof e2 == "number";
          }
        }
        Dd.NumberSchema = Cd, Object.defineProperty(yd, "__esModule", { value: true });
        const bd = pd, vd = Dd;
        class Ad extends vd.NumberSchema {
          expected() {
            return "an integer";
          }
          validate(e2, t2) {
            return t2.normalizeValidateResult(super.validate(e2, t2), e2) === true && bd.isInt(e2);
          }
        }
        yd.IntegerSchema = Ad;
        var Fd = {};
        Object.defineProperty(Fd, "__esModule", { value: true });
        const xd = Gf;
        class Sd extends xd.Schema {
          expected() {
            return "a string";
          }
          validate(e2) {
            return typeof e2 == "string";
          }
        }
        Fd.StringSchema = Sd, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = wp;
          t2.__exportStar(zf, e2), t2.__exportStar(Zf, e2), t2.__exportStar(nd, e2), t2.__exportStar(sd, e2), t2.__exportStar(ld, e2), t2.__exportStar(yd, e2), t2.__exportStar(Dd, e2), t2.__exportStar(Fd, e2);
        }(Uf);
        var wd = {}, Td = {};
        Object.defineProperty(Td, "__esModule", { value: true });
        const Bd = Bp, Nd = Pp, kd = Lf, Pd = Rf;
        Td.defaultDescriptor = Bd.apiDescriptor, Td.defaultUnknownHandler = Pd.levenUnknownHandler, Td.defaultInvalidHandler = kd.commonInvalidHandler, Td.defaultDeprecatedHandler = Nd.commonDeprecatedHandler, Object.defineProperty(wd, "__esModule", { value: true });
        const Od = Td, Id = pd;
        wd.normalize = (e2, t2, n2) => new Ld(t2, n2).normalize(e2);
        class Ld {
          constructor(e2, t2) {
            const { logger: n2 = console, descriptor: r2 = Od.defaultDescriptor, unknown: o2 = Od.defaultUnknownHandler, invalid: i2 = Od.defaultInvalidHandler, deprecated: u2 = Od.defaultDeprecatedHandler } = t2 || {};
            this._utils = { descriptor: r2, logger: n2 || { warn: () => {
            } }, schemas: Id.recordFromArray(e2, "name"), normalizeDefaultResult: Id.normalizeDefaultResult, normalizeDeprecatedResult: Id.normalizeDeprecatedResult, normalizeForwardResult: Id.normalizeForwardResult, normalizeRedirectResult: Id.normalizeRedirectResult, normalizeValidateResult: Id.normalizeValidateResult }, this._unknownHandler = o2, this._invalidHandler = i2, this._deprecatedHandler = u2, this.cleanHistory();
          }
          cleanHistory() {
            this._hasDeprecationWarned = Id.createAutoChecklist();
          }
          normalize(e2) {
            const t2 = {}, n2 = [e2], r2 = () => {
              for (; n2.length !== 0; ) {
                const e3 = n2.shift(), r3 = this._applyNormalization(e3, t2);
                n2.push(...r3);
              }
            };
            r2();
            for (const e3 of Object.keys(this._utils.schemas)) {
              const r3 = this._utils.schemas[e3];
              if (!(e3 in t2)) {
                const t3 = Id.normalizeDefaultResult(r3.default(this._utils));
                "value" in t3 && n2.push({ [e3]: t3.value });
              }
            }
            r2();
            for (const e3 of Object.keys(this._utils.schemas)) {
              const n3 = this._utils.schemas[e3];
              e3 in t2 && (t2[e3] = n3.postprocess(t2[e3], this._utils));
            }
            return t2;
          }
          _applyNormalization(e2, t2) {
            const n2 = [], [r2, o2] = Id.partition(Object.keys(e2), (e3) => e3 in this._utils.schemas);
            for (const o3 of r2) {
              const r3 = this._utils.schemas[o3], i2 = r3.preprocess(e2[o3], this._utils), u2 = Id.normalizeValidateResult(r3.validate(i2, this._utils), i2);
              if (u2 !== true) {
                const { value: e3 } = u2, t3 = this._invalidHandler(o3, e3, this._utils);
                throw typeof t3 == "string" ? new Error(t3) : t3;
              }
              const s2 = (e3) => {
                let { from: t3, to: r4 } = e3;
                n2.push(typeof r4 == "string" ? { [r4]: t3 } : { [r4.key]: r4.value });
              }, a2 = (e3) => {
                let { value: t3, redirectTo: n3 } = e3;
                const u3 = Id.normalizeDeprecatedResult(r3.deprecated(t3, this._utils), i2, true);
                if (u3 !== false)
                  if (u3 === true)
                    this._hasDeprecationWarned(o3) || this._utils.logger.warn(this._deprecatedHandler(o3, n3, this._utils));
                  else
                    for (const { value: e4 } of u3) {
                      const t4 = { key: o3, value: e4 };
                      if (!this._hasDeprecationWarned(t4)) {
                        const r4 = typeof n3 == "string" ? { key: n3, value: e4 } : n3;
                        this._utils.logger.warn(this._deprecatedHandler(t4, r4, this._utils));
                      }
                    }
              };
              Id.normalizeForwardResult(r3.forward(i2, this._utils), i2).forEach(s2);
              const c2 = Id.normalizeRedirectResult(r3.redirect(i2, this._utils), i2);
              if (c2.redirect.forEach(s2), "remain" in c2) {
                const e3 = c2.remain;
                t2[o3] = o3 in t2 ? r3.overlap(t2[o3], e3, this._utils) : e3, a2({ value: e3 });
              }
              for (const { from: e3, to: t3 } of c2.redirect)
                a2({ value: e3, redirectTo: t3 });
            }
            for (const r3 of o2) {
              const o3 = e2[r3], i2 = this._unknownHandler(r3, o3, this._utils);
              if (i2)
                for (const e3 of Object.keys(i2)) {
                  const r4 = { [e3]: i2[e3] };
                  e3 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
                }
            }
            return n2;
          }
        }
        wd.Normalizer = Ld, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = wp;
          t2.__exportStar(Tp, e2), t2.__exportStar(Np, e2), t2.__exportStar(Uf, e2), t2.__exportStar(wd, e2), t2.__exportStar(Gf, e2);
        }(bp);
        var jd = { exports: {} };
        const _d = [], Md = [], Rd = (e2, t2) => {
          if (e2 === t2)
            return 0;
          const n2 = e2;
          e2.length > t2.length && (e2 = t2, t2 = n2);
          let r2 = e2.length, o2 = t2.length;
          for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-o2); )
            r2--, o2--;
          let i2, u2, s2, a2, c2 = 0;
          for (; c2 < r2 && e2.charCodeAt(c2) === t2.charCodeAt(c2); )
            c2++;
          if (r2 -= c2, o2 -= c2, r2 === 0)
            return o2;
          let l2 = 0, p2 = 0;
          for (; l2 < r2; )
            Md[l2] = e2.charCodeAt(c2 + l2), _d[l2] = ++l2;
          for (; p2 < o2; )
            for (i2 = t2.charCodeAt(c2 + p2), s2 = p2++, u2 = p2, l2 = 0; l2 < r2; l2++)
              a2 = i2 === Md[l2] ? s2 : s2 + 1, s2 = _d[l2], u2 = _d[l2] = s2 > u2 ? a2 > u2 ? u2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
          return u2;
        };
        jd.exports = Rd, jd.exports.default = Rd;
        var Vd = { exports: {} };
        const $d = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Wd = {};
        for (const e2 of Object.keys($d))
          Wd[$d[e2]] = e2;
        const qd = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        var Ud = qd;
        for (const e2 of Object.keys(qd)) {
          if (!("channels" in qd[e2]))
            throw new Error("missing channels property: " + e2);
          if (!("labels" in qd[e2]))
            throw new Error("missing channel labels property: " + e2);
          if (qd[e2].labels.length !== qd[e2].channels)
            throw new Error("channel and label counts mismatch: " + e2);
          const { channels: t2, labels: n2 } = qd[e2];
          delete qd[e2].channels, delete qd[e2].labels, Object.defineProperty(qd[e2], "channels", { value: t2 }), Object.defineProperty(qd[e2], "labels", { value: n2 });
        }
        qd.rgb.hsl = function(e2) {
          const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.min(t2, n2, r2), i2 = Math.max(t2, n2, r2), u2 = i2 - o2;
          let s2, a2;
          i2 === o2 ? s2 = 0 : t2 === i2 ? s2 = (n2 - r2) / u2 : n2 === i2 ? s2 = 2 + (r2 - t2) / u2 : r2 === i2 && (s2 = 4 + (t2 - n2) / u2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
          const c2 = (o2 + i2) / 2;
          return a2 = i2 === o2 ? 0 : c2 <= 0.5 ? u2 / (i2 + o2) : u2 / (2 - i2 - o2), [s2, 100 * a2, 100 * c2];
        }, qd.rgb.hsv = function(e2) {
          let t2, n2, r2, o2, i2;
          const u2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(u2, s2, a2), l2 = c2 - Math.min(u2, s2, a2), p2 = function(e3) {
            return (c2 - e3) / 6 / l2 + 0.5;
          };
          return l2 === 0 ? (o2 = 0, i2 = 0) : (i2 = l2 / c2, t2 = p2(u2), n2 = p2(s2), r2 = p2(a2), u2 === c2 ? o2 = r2 - n2 : s2 === c2 ? o2 = 1 / 3 + t2 - r2 : a2 === c2 && (o2 = 2 / 3 + n2 - t2), o2 < 0 ? o2 += 1 : o2 > 1 && (o2 -= 1)), [360 * o2, 100 * i2, 100 * c2];
        }, qd.rgb.hwb = function(e2) {
          const t2 = e2[0], n2 = e2[1];
          let r2 = e2[2];
          const o2 = qd.rgb.hsl(e2)[0], i2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
          return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [o2, 100 * i2, 100 * r2];
        }, qd.rgb.cmyk = function(e2) {
          const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.min(1 - t2, 1 - n2, 1 - r2);
          return [100 * ((1 - t2 - o2) / (1 - o2) || 0), 100 * ((1 - n2 - o2) / (1 - o2) || 0), 100 * ((1 - r2 - o2) / (1 - o2) || 0), 100 * o2];
        }, qd.rgb.keyword = function(e2) {
          const t2 = Wd[e2];
          if (t2)
            return t2;
          let n2, r2 = 1 / 0;
          for (const t3 of Object.keys($d)) {
            const u2 = (i2 = $d[t3], ((o2 = e2)[0] - i2[0]) ** 2 + (o2[1] - i2[1]) ** 2 + (o2[2] - i2[2]) ** 2);
            u2 < r2 && (r2 = u2, n2 = t3);
          }
          var o2, i2;
          return n2;
        }, qd.keyword.rgb = function(e2) {
          return $d[e2];
        }, qd.rgb.xyz = function(e2) {
          let t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
          t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
          return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
        }, qd.rgb.lab = function(e2) {
          const t2 = qd.rgb.xyz(e2);
          let n2 = t2[0], r2 = t2[1], o2 = t2[2];
          n2 /= 95.047, r2 /= 100, o2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, o2 = o2 > 8856e-6 ? o2 ** (1 / 3) : 7.787 * o2 + 16 / 116;
          return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - o2)];
        }, qd.hsl.rgb = function(e2) {
          const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
          let o2, i2, u2;
          if (n2 === 0)
            return u2 = 255 * r2, [u2, u2, u2];
          o2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
          const s2 = 2 * r2 - o2, a2 = [0, 0, 0];
          for (let e3 = 0; e3 < 3; e3++)
            i2 = t2 + 1 / 3 * -(e3 - 1), i2 < 0 && i2++, i2 > 1 && i2--, u2 = 6 * i2 < 1 ? s2 + 6 * (o2 - s2) * i2 : 2 * i2 < 1 ? o2 : 3 * i2 < 2 ? s2 + (o2 - s2) * (2 / 3 - i2) * 6 : s2, a2[e3] = 255 * u2;
          return a2;
        }, qd.hsl.hsv = function(e2) {
          const t2 = e2[0];
          let n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = n2;
          const i2 = Math.max(r2, 0.01);
          r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, o2 *= i2 <= 1 ? i2 : 2 - i2;
          return [t2, 100 * (r2 === 0 ? 2 * o2 / (i2 + o2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
        }, qd.hsv.rgb = function(e2) {
          const t2 = e2[0] / 60, n2 = e2[1] / 100;
          let r2 = e2[2] / 100;
          const o2 = Math.floor(t2) % 6, i2 = t2 - Math.floor(t2), u2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * i2), a2 = 255 * r2 * (1 - n2 * (1 - i2));
          switch (r2 *= 255, o2) {
            case 0:
              return [r2, a2, u2];
            case 1:
              return [s2, r2, u2];
            case 2:
              return [u2, r2, a2];
            case 3:
              return [u2, s2, r2];
            case 4:
              return [a2, u2, r2];
            case 5:
              return [r2, u2, s2];
          }
        }, qd.hsv.hsl = function(e2) {
          const t2 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = Math.max(r2, 0.01);
          let i2, u2;
          u2 = (2 - n2) * r2;
          const s2 = (2 - n2) * o2;
          return i2 = n2 * o2, i2 /= s2 <= 1 ? s2 : 2 - s2, i2 = i2 || 0, u2 /= 2, [t2, 100 * i2, 100 * u2];
        }, qd.hwb.rgb = function(e2) {
          const t2 = e2[0] / 360;
          let n2 = e2[1] / 100, r2 = e2[2] / 100;
          const o2 = n2 + r2;
          let i2;
          o2 > 1 && (n2 /= o2, r2 /= o2);
          const u2 = Math.floor(6 * t2), s2 = 1 - r2;
          i2 = 6 * t2 - u2, (1 & u2) != 0 && (i2 = 1 - i2);
          const a2 = n2 + i2 * (s2 - n2);
          let c2, l2, p2;
          switch (u2) {
            default:
            case 6:
            case 0:
              c2 = s2, l2 = a2, p2 = n2;
              break;
            case 1:
              c2 = a2, l2 = s2, p2 = n2;
              break;
            case 2:
              c2 = n2, l2 = s2, p2 = a2;
              break;
            case 3:
              c2 = n2, l2 = a2, p2 = s2;
              break;
            case 4:
              c2 = a2, l2 = n2, p2 = s2;
              break;
            case 5:
              c2 = s2, l2 = n2, p2 = a2;
          }
          return [255 * c2, 255 * l2, 255 * p2];
        }, qd.cmyk.rgb = function(e2) {
          const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, o2 = e2[3] / 100;
          return [255 * (1 - Math.min(1, t2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, n2 * (1 - o2) + o2)), 255 * (1 - Math.min(1, r2 * (1 - o2) + o2))];
        }, qd.xyz.rgb = function(e2) {
          const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100;
          let o2, i2, u2;
          return o2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, i2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, u2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, i2 = i2 > 31308e-7 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = Math.min(Math.max(0, o2), 1), i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), [255 * o2, 255 * i2, 255 * u2];
        }, qd.xyz.lab = function(e2) {
          let t2 = e2[0], n2 = e2[1], r2 = e2[2];
          t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
          return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
        }, qd.lab.xyz = function(e2) {
          let t2, n2, r2;
          n2 = (e2[0] + 16) / 116, t2 = e2[1] / 500 + n2, r2 = n2 - e2[2] / 200;
          const o2 = n2 ** 3, i2 = t2 ** 3, u2 = r2 ** 3;
          return n2 = o2 > 8856e-6 ? o2 : (n2 - 16 / 116) / 7.787, t2 = i2 > 8856e-6 ? i2 : (t2 - 16 / 116) / 7.787, r2 = u2 > 8856e-6 ? u2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
        }, qd.lab.lch = function(e2) {
          const t2 = e2[0], n2 = e2[1], r2 = e2[2];
          let o2;
          o2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, o2 < 0 && (o2 += 360);
          return [t2, Math.sqrt(n2 * n2 + r2 * r2), o2];
        }, qd.lch.lab = function(e2) {
          const t2 = e2[0], n2 = e2[1], r2 = e2[2] / 360 * 2 * Math.PI;
          return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
        }, qd.rgb.ansi16 = function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          const [n2, r2, o2] = e2;
          let i2 = t2 === null ? qd.rgb.hsv(e2)[2] : t2;
          if (i2 = Math.round(i2 / 50), i2 === 0)
            return 30;
          let u2 = 30 + (Math.round(o2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
          return i2 === 2 && (u2 += 60), u2;
        }, qd.hsv.ansi16 = function(e2) {
          return qd.rgb.ansi16(qd.hsv.rgb(e2), e2[2]);
        }, qd.rgb.ansi256 = function(e2) {
          const t2 = e2[0], n2 = e2[1], r2 = e2[2];
          if (t2 === n2 && n2 === r2)
            return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
          return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
        }, qd.ansi16.rgb = function(e2) {
          let t2 = e2 % 10;
          if (t2 === 0 || t2 === 7)
            return e2 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
          const n2 = 0.5 * (1 + ~~(e2 > 50));
          return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
        }, qd.ansi256.rgb = function(e2) {
          if (e2 >= 232) {
            const t3 = 10 * (e2 - 232) + 8;
            return [t3, t3, t3];
          }
          let t2;
          e2 -= 16;
          return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t2 = e2 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
        }, qd.rgb.hex = function(e2) {
          const t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
          return "000000".substring(t2.length) + t2;
        }, qd.hex.rgb = function(e2) {
          const t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t2)
            return [0, 0, 0];
          let n2 = t2[0];
          t2[0].length === 3 && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
          const r2 = parseInt(n2, 16);
          return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
        }, qd.rgb.hcg = function(e2) {
          const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, o2 = Math.max(Math.max(t2, n2), r2), i2 = Math.min(Math.min(t2, n2), r2), u2 = o2 - i2;
          let s2, a2;
          return s2 = u2 < 1 ? i2 / (1 - u2) : 0, a2 = u2 <= 0 ? 0 : o2 === t2 ? (n2 - r2) / u2 % 6 : o2 === n2 ? 2 + (r2 - t2) / u2 : 4 + (t2 - n2) / u2, a2 /= 6, a2 %= 1, [360 * a2, 100 * u2, 100 * s2];
        }, qd.hsl.hcg = function(e2) {
          const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
          let o2 = 0;
          return r2 < 1 && (o2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, qd.hsv.hcg = function(e2) {
          const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = t2 * n2;
          let o2 = 0;
          return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, qd.hcg.rgb = function(e2) {
          const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
          if (n2 === 0)
            return [255 * r2, 255 * r2, 255 * r2];
          const o2 = [0, 0, 0], i2 = t2 % 1 * 6, u2 = i2 % 1, s2 = 1 - u2;
          let a2 = 0;
          switch (Math.floor(i2)) {
            case 0:
              o2[0] = 1, o2[1] = u2, o2[2] = 0;
              break;
            case 1:
              o2[0] = s2, o2[1] = 1, o2[2] = 0;
              break;
            case 2:
              o2[0] = 0, o2[1] = 1, o2[2] = u2;
              break;
            case 3:
              o2[0] = 0, o2[1] = s2, o2[2] = 1;
              break;
            case 4:
              o2[0] = u2, o2[1] = 0, o2[2] = 1;
              break;
            default:
              o2[0] = 1, o2[1] = 0, o2[2] = s2;
          }
          return a2 = (1 - n2) * r2, [255 * (n2 * o2[0] + a2), 255 * (n2 * o2[1] + a2), 255 * (n2 * o2[2] + a2)];
        }, qd.hcg.hsv = function(e2) {
          const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
          let r2 = 0;
          return n2 > 0 && (r2 = t2 / n2), [e2[0], 100 * r2, 100 * n2];
        }, qd.hcg.hsl = function(e2) {
          const t2 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
          let r2 = 0;
          return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
        }, qd.hcg.hwb = function(e2) {
          const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
          return [e2[0], 100 * (n2 - t2), 100 * (1 - n2)];
        }, qd.hwb.hcg = function(e2) {
          const t2 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t2;
          let o2 = 0;
          return r2 < 1 && (o2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * o2];
        }, qd.apple.rgb = function(e2) {
          return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
        }, qd.rgb.apple = function(e2) {
          return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
        }, qd.gray.rgb = function(e2) {
          return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
        }, qd.gray.hsl = function(e2) {
          return [0, 0, e2[0]];
        }, qd.gray.hsv = qd.gray.hsl, qd.gray.hwb = function(e2) {
          return [0, 100, e2[0]];
        }, qd.gray.cmyk = function(e2) {
          return [0, 0, 0, e2[0]];
        }, qd.gray.lab = function(e2) {
          return [e2[0], 0, 0];
        }, qd.gray.hex = function(e2) {
          const t2 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
          return "000000".substring(n2.length) + n2;
        }, qd.rgb.gray = function(e2) {
          return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
        };
        const zd = Ud;
        function Gd(e2) {
          const t2 = function() {
            const e3 = {}, t3 = Object.keys(zd);
            for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
              e3[t3[r2]] = { distance: -1, parent: null };
            return e3;
          }(), n2 = [e2];
          for (t2[e2].distance = 0; n2.length; ) {
            const e3 = n2.pop(), r2 = Object.keys(zd[e3]);
            for (let o2 = r2.length, i2 = 0; i2 < o2; i2++) {
              const o3 = r2[i2], u2 = t2[o3];
              u2.distance === -1 && (u2.distance = t2[e3].distance + 1, u2.parent = e3, n2.unshift(o3));
            }
          }
          return t2;
        }
        function Hd(e2, t2) {
          return function(n2) {
            return t2(e2(n2));
          };
        }
        function Jd(e2, t2) {
          const n2 = [t2[e2].parent, e2];
          let r2 = zd[t2[e2].parent][e2], o2 = t2[e2].parent;
          for (; t2[o2].parent; )
            n2.unshift(t2[o2].parent), r2 = Hd(zd[t2[o2].parent][o2], r2), o2 = t2[o2].parent;
          return r2.conversion = n2, r2;
        }
        const Xd = Ud, Yd = function(e2) {
          const t2 = Gd(e2), n2 = {}, r2 = Object.keys(t2);
          for (let e3 = r2.length, o2 = 0; o2 < e3; o2++) {
            const e4 = r2[o2];
            t2[e4].parent !== null && (n2[e4] = Jd(e4, t2));
          }
          return n2;
        }, Kd = {};
        Object.keys(Xd).forEach((e2) => {
          Kd[e2] = {}, Object.defineProperty(Kd[e2], "channels", { value: Xd[e2].channels }), Object.defineProperty(Kd[e2], "labels", { value: Xd[e2].labels });
          const t2 = Yd(e2);
          Object.keys(t2).forEach((n2) => {
            const r2 = t2[n2];
            Kd[e2][n2] = function(e3) {
              const t3 = function() {
                for (var t4 = arguments.length, n3 = new Array(t4), r3 = 0; r3 < t4; r3++)
                  n3[r3] = arguments[r3];
                const o2 = n3[0];
                if (o2 == null)
                  return o2;
                o2.length > 1 && (n3 = o2);
                const i2 = e3(n3);
                if (typeof i2 == "object")
                  for (let e4 = i2.length, t5 = 0; t5 < e4; t5++)
                    i2[t5] = Math.round(i2[t5]);
                return i2;
              };
              return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
            }(r2), Kd[e2][n2].raw = function(e3) {
              const t3 = function() {
                for (var t4 = arguments.length, n3 = new Array(t4), r3 = 0; r3 < t4; r3++)
                  n3[r3] = arguments[r3];
                const o2 = n3[0];
                return o2 == null ? o2 : (o2.length > 1 && (n3 = o2), e3(n3));
              };
              return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
            }(r2);
          });
        });
        var Qd = Kd;
        function Zd() {
          return false;
        }
        function eh() {
          throw new Error("tty.ReadStream is not implemented");
        }
        function th() {
          throw new Error("tty.ReadStream is not implemented");
        }
        !function(e2) {
          const t2 = (e3, t3) => function() {
            const n3 = e3(...arguments);
            return "\x1B[".concat(n3 + t3, "m");
          }, n2 = (e3, t3) => function() {
            const n3 = e3(...arguments);
            return "\x1B[".concat(38 + t3, ";5;").concat(n3, "m");
          }, r2 = (e3, t3) => function() {
            const n3 = e3(...arguments);
            return "\x1B[".concat(38 + t3, ";2;").concat(n3[0], ";").concat(n3[1], ";").concat(n3[2], "m");
          }, o2 = (e3) => e3, i2 = (e3, t3, n3) => [e3, t3, n3], u2 = (e3, t3, n3) => {
            Object.defineProperty(e3, t3, { get: () => {
              const r3 = n3();
              return Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true }), r3;
            }, enumerable: true, configurable: true });
          };
          let s2;
          const a2 = (e3, t3, n3, r3) => {
            s2 === void 0 && (s2 = Qd);
            const o3 = r3 ? 10 : 0, i3 = {};
            for (const [r4, u3] of Object.entries(s2)) {
              const s3 = r4 === "ansi16" ? "ansi" : r4;
              r4 === t3 ? i3[s3] = e3(n3, o3) : typeof u3 == "object" && (i3[s3] = e3(u3[t3], o3));
            }
            return i3;
          };
          Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
            const e3 = /* @__PURE__ */ new Map(), s3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
            s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
            for (const [t3, n3] of Object.entries(s3)) {
              for (const [t4, r3] of Object.entries(n3))
                s3[t4] = { open: "\x1B[".concat(r3[0], "m"), close: "\x1B[".concat(r3[1], "m") }, n3[t4] = s3[t4], e3.set(r3[0], r3[1]);
              Object.defineProperty(s3, t3, { value: n3, enumerable: false });
            }
            return Object.defineProperty(s3, "codes", { value: e3, enumerable: false }), s3.color.close = "\x1B[39m", s3.bgColor.close = "\x1B[49m", u2(s3.color, "ansi", () => a2(t2, "ansi16", o2, false)), u2(s3.color, "ansi256", () => a2(n2, "ansi256", o2, false)), u2(s3.color, "ansi16m", () => a2(r2, "rgb", i2, false)), u2(s3.bgColor, "ansi", () => a2(t2, "ansi16", o2, true)), u2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", o2, true)), u2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", i2, true)), s3;
          } });
        }(Vd);
        var nh = { isatty: Zd, ReadStream: eh, WriteStream: th };
        const rh = yf, oh = t(Object.freeze({ __proto__: null, isatty: Zd, ReadStream: eh, WriteStream: th, default: nh })), ih = function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ta.argv;
          const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), o2 = t2.indexOf("--");
          return r2 !== -1 && (o2 === -1 || r2 < o2);
        }, { env: uh } = ta;
        let sh;
        function ah(e2) {
          return e2 !== 0 && { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
        }
        function ch(e2, t2) {
          if (sh === 0)
            return 0;
          if (ih("color=16m") || ih("color=full") || ih("color=truecolor"))
            return 3;
          if (ih("color=256"))
            return 2;
          if (e2 && !t2 && sh === void 0)
            return 0;
          const n2 = sh || 0;
          if (uh.TERM === "dumb")
            return n2;
          if (ta.platform === "win32") {
            const e3 = rh.release().split(".");
            return Number(e3[0]) >= 10 && Number(e3[2]) >= 10586 ? Number(e3[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in uh)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e3) => e3 in uh) || uh.CI_NAME === "codeship" ? 1 : n2;
          if ("TEAMCITY_VERSION" in uh)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(uh.TEAMCITY_VERSION) ? 1 : 0;
          if (uh.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in uh) {
            const e3 = parseInt((uh.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (uh.TERM_PROGRAM) {
              case "iTerm.app":
                return e3 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(uh.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(uh.TERM) || "COLORTERM" in uh ? 1 : n2;
        }
        ih("no-color") || ih("no-colors") || ih("color=false") || ih("color=never") ? sh = 0 : (ih("color") || ih("colors") || ih("color=true") || ih("color=always")) && (sh = 1), "FORCE_COLOR" in uh && (sh = uh.FORCE_COLOR === "true" ? 1 : uh.FORCE_COLOR === "false" ? 0 : uh.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(uh.FORCE_COLOR, 10), 3));
        var lh = { supportsColor: function(e2) {
          return ah(ch(e2, e2 && e2.isTTY));
        }, stdout: ah(ch(true, oh.isatty(1))), stderr: ah(ch(true, oh.isatty(2))) };
        var ph = { stringReplaceAll: (e2, t2, n2) => {
          let r2 = e2.indexOf(t2);
          if (r2 === -1)
            return e2;
          const o2 = t2.length;
          let i2 = 0, u2 = "";
          do {
            u2 += e2.substr(i2, r2 - i2) + t2 + n2, i2 = r2 + o2, r2 = e2.indexOf(t2, i2);
          } while (r2 !== -1);
          return u2 += e2.substr(i2), u2;
        }, stringEncaseCRLFWithFirstIndex: (e2, t2, n2, r2) => {
          let o2 = 0, i2 = "";
          do {
            const u2 = e2[r2 - 1] === "\r";
            i2 += e2.substr(o2, (u2 ? r2 - 1 : r2) - o2) + t2 + (u2 ? "\r\n" : "\n") + n2, o2 = r2 + 1, r2 = e2.indexOf("\n", o2);
          } while (r2 !== -1);
          return i2 += e2.substr(o2), i2;
        } };
        const fh = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, dh = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, hh = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, gh = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, mh = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
        function yh(e2) {
          const t2 = e2[0] === "u", n2 = e2[1] === "{";
          return t2 && !n2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : mh.get(e2) || e2;
        }
        function Dh(e2, t2) {
          const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
          let o2;
          for (const t3 of r2) {
            const r3 = Number(t3);
            if (Number.isNaN(r3)) {
              if (!(o2 = t3.match(hh)))
                throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
              n2.push(o2[2].replace(gh, (e3, t4, n3) => t4 ? yh(t4) : n3));
            } else
              n2.push(r3);
          }
          return n2;
        }
        function Eh(e2) {
          dh.lastIndex = 0;
          const t2 = [];
          let n2;
          for (; (n2 = dh.exec(e2)) !== null; ) {
            const e3 = n2[1];
            if (n2[2]) {
              const r2 = Dh(e3, n2[2]);
              t2.push([e3].concat(r2));
            } else
              t2.push([e3]);
          }
          return t2;
        }
        function Ch(e2, t2) {
          const n2 = {};
          for (const e3 of t2)
            for (const t3 of e3.styles)
              n2[t3[0]] = e3.inverse ? null : t3.slice(1);
          let r2 = e2;
          for (const [e3, t3] of Object.entries(n2))
            if (Array.isArray(t3)) {
              if (!(e3 in r2))
                throw new Error("Unknown Chalk style: ".concat(e3));
              r2 = t3.length > 0 ? r2[e3](...t3) : r2[e3];
            }
          return r2;
        }
        var bh = (e2, t2) => {
          const n2 = [], r2 = [];
          let o2 = [];
          if (t2.replace(fh, (t3, i2, u2, s2, a2, c2) => {
            if (i2)
              o2.push(yh(i2));
            else if (s2) {
              const t4 = o2.join("");
              o2 = [], r2.push(n2.length === 0 ? t4 : Ch(e2, n2)(t4)), n2.push({ inverse: u2, styles: Eh(s2) });
            } else if (a2) {
              if (n2.length === 0)
                throw new Error("Found extraneous } in Chalk template literal");
              r2.push(Ch(e2, n2)(o2.join(""))), o2 = [], n2.pop();
            } else
              o2.push(c2);
          }), r2.push(o2.join("")), n2.length > 0) {
            const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
            throw new Error(e3);
          }
          return r2.join("");
        };
        const vh = Vd.exports, { stdout: Ah, stderr: Fh } = lh, { stringReplaceAll: xh, stringEncaseCRLFWithFirstIndex: Sh } = ph, { isArray: wh } = Array, Th = ["ansi", "ansi", "ansi256", "ansi16m"], Bh = /* @__PURE__ */ Object.create(null);
        class Nh {
          constructor(e2) {
            return kh(e2);
          }
        }
        const kh = (e2) => {
          const t2 = {};
          return function(e3) {
            let t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
              throw new Error("The `level` option should be an integer from 0 to 3");
            const n2 = Ah ? Ah.level : 0;
            e3.level = t3.level === void 0 ? n2 : t3.level;
          }(t2, e2), t2.template = function() {
            for (var e3 = arguments.length, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
              n2[r2] = arguments[r2];
            return Rh(t2.template, ...n2);
          }, Object.setPrototypeOf(t2, Ph.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
            throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
          }, t2.template.Instance = Nh, t2.template;
        };
        function Ph(e2) {
          return kh(e2);
        }
        for (const [e2, t2] of Object.entries(vh))
          Bh[e2] = { get() {
            const n2 = jh(this, Lh(t2.open, t2.close, this._styler), this._isEmpty);
            return Object.defineProperty(this, e2, { value: n2 }), n2;
          } };
        Bh.visible = { get() {
          const e2 = jh(this, this._styler, true);
          return Object.defineProperty(this, "visible", { value: e2 }), e2;
        } };
        const Oh = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
        for (const e2 of Oh)
          Bh[e2] = { get() {
            const { level: t2 } = this;
            return function() {
              const n2 = Lh(vh.color[Th[t2]][e2](...arguments), vh.color.close, this._styler);
              return jh(this, n2, this._isEmpty);
            };
          } };
        for (const e2 of Oh) {
          Bh["bg" + e2[0].toUpperCase() + e2.slice(1)] = { get() {
            const { level: t2 } = this;
            return function() {
              const n2 = Lh(vh.bgColor[Th[t2]][e2](...arguments), vh.bgColor.close, this._styler);
              return jh(this, n2, this._isEmpty);
            };
          } };
        }
        const Ih = Object.defineProperties(() => {
        }, Object.assign(Object.assign({}, Bh), {}, { level: { enumerable: true, get() {
          return this._generator.level;
        }, set(e2) {
          this._generator.level = e2;
        } } })), Lh = (e2, t2, n2) => {
          let r2, o2;
          return n2 === void 0 ? (r2 = e2, o2 = t2) : (r2 = n2.openAll + e2, o2 = t2 + n2.closeAll), { open: e2, close: t2, openAll: r2, closeAll: o2, parent: n2 };
        }, jh = (e2, t2, n2) => {
          const r2 = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), n3 = 0; n3 < e3; n3++)
              t3[n3] = arguments[n3];
            return wh(t3[0]) && wh(t3[0].raw) ? _h(r2, Rh(r2, ...t3)) : _h(r2, t3.length === 1 ? "" + t3[0] : t3.join(" "));
          };
          return Object.setPrototypeOf(r2, Ih), r2._generator = e2, r2._styler = t2, r2._isEmpty = n2, r2;
        }, _h = (e2, t2) => {
          if (e2.level <= 0 || !t2)
            return e2._isEmpty ? "" : t2;
          let n2 = e2._styler;
          if (n2 === void 0)
            return t2;
          const { openAll: r2, closeAll: o2 } = n2;
          if (t2.indexOf("\x1B") !== -1)
            for (; n2 !== void 0; )
              t2 = xh(t2, n2.close, n2.open), n2 = n2.parent;
          const i2 = t2.indexOf("\n");
          return i2 !== -1 && (t2 = Sh(t2, o2, r2, i2)), r2 + t2 + o2;
        };
        let Mh;
        const Rh = function(e2) {
          for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            n2[r2 - 1] = arguments[r2];
          const [o2] = n2;
          if (!wh(o2) || !wh(o2.raw))
            return n2.join(" ");
          const i2 = n2.slice(1), u2 = [o2.raw[0]];
          for (let e3 = 1; e3 < o2.length; e3++)
            u2.push(String(i2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(o2.raw[e3]));
          return Mh === void 0 && (Mh = bh), Mh(e2, u2.join(""));
        };
        Object.defineProperties(Ph.prototype, Bh);
        const Vh = Ph();
        Vh.supportsColor = Ah, Vh.stderr = Ph({ level: Fh ? Fh.level : 0 }), Vh.stderr.supportsColor = Fh;
        var $h = Vh;
        const Wh = ["_"], qh = bp, Uh = jd.exports, zh = $h, Gh = au, Hh = { key: (e2) => e2.length === 1 ? "-".concat(e2) : "--".concat(e2), value: (e2) => qh.apiDescriptor.value(e2), pair: (e2) => {
          let { key: t2, value: n2 } = e2;
          return n2 === false ? "--no-".concat(t2) : n2 === true ? Hh.key(t2) : n2 === "" ? "".concat(Hh.key(t2), " without an argument") : "".concat(Hh.key(t2), "=").concat(n2);
        } };
        class Jh extends qh.ChoiceSchema {
          constructor(e2) {
            let { name: t2, flags: n2 } = e2;
            super({ name: t2, choices: n2 }), this._flags = [...n2].sort();
          }
          preprocess(e2, t2) {
            if (typeof e2 == "string" && e2.length > 0 && !this._flags.includes(e2)) {
              const n2 = this._flags.find((t3) => Uh(t3, e2) < 3);
              if (n2)
                return t2.logger.warn(["Unknown flag ".concat(zh.yellow(t2.descriptor.value(e2)), ","), "did you mean ".concat(zh.blue(t2.descriptor.value(n2)), "?")].join(" ")), n2;
            }
            return e2;
          }
          expected() {
            return "a flag";
          }
        }
        let Xh;
        function Yh(e2, t2) {
          let { logger: n2, isCLI: r2 = false, passThrough: o2 = false } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const i2 = o2 ? Array.isArray(o2) ? (e3, t3) => o2.includes(e3) ? { [e3]: t3 } : void 0 : (e3, t3) => ({ [e3]: t3 }) : (e3, t3, n3) => {
            const r3 = cu(n3.schemas, Wh);
            return qh.levenUnknownHandler(e3, t3, Object.assign(Object.assign({}, n3), {}, { schemas: r3 }));
          }, u2 = r2 ? Hh : qh.apiDescriptor, s2 = Kh(t2, { isCLI: r2 }), a2 = new qh.Normalizer(s2, { logger: n2, unknown: i2, descriptor: u2 }), c2 = n2 !== false;
          c2 && Xh && (a2._hasDeprecationWarned = Xh);
          const l2 = a2.normalize(e2);
          return c2 && (Xh = a2._hasDeprecationWarned), l2;
        }
        function Kh(e2, t2) {
          let { isCLI: n2 } = t2;
          const r2 = [];
          n2 && r2.push(qh.AnySchema.create({ name: "_" }));
          for (const t3 of e2)
            r2.push(Qh(t3, { isCLI: n2, optionInfos: e2 })), t3.alias && n2 && r2.push(qh.AliasSchema.create({ name: t3.alias, sourceName: t3.name }));
          return r2;
        }
        function Qh(e2, t2) {
          let n2, { isCLI: r2, optionInfos: o2 } = t2;
          const i2 = { name: e2.name }, u2 = {};
          switch (e2.type) {
            case "int":
              n2 = qh.IntegerSchema, r2 && (i2.preprocess = (e3) => Number(e3));
              break;
            case "string":
            case "path":
              n2 = qh.StringSchema;
              break;
            case "choice":
              n2 = qh.ChoiceSchema, i2.choices = e2.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, { redirect: { to: { key: e2.name, value: t3.redirect } } }) : t3);
              break;
            case "boolean":
              n2 = qh.BooleanSchema;
              break;
            case "flag":
              n2 = Jh, i2.flags = o2.flatMap((e3) => [e3.alias, e3.description && e3.name, e3.oppositeDescription && "no-".concat(e3.name)].filter(Boolean));
              break;
            default:
              throw new Error("Unexpected type ".concat(e2.type));
          }
          if (e2.exception ? i2.validate = (t3, n3, r3) => e2.exception(t3) || n3.validate(t3, r3) : i2.validate = (e3, t3, n3) => e3 === void 0 || t3.validate(e3, n3), e2.redirect && (u2.redirect = (t3) => t3 ? { to: { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (u2.deprecated = true), r2 && !e2.array) {
            const e3 = i2.preprocess || ((e4) => e4);
            i2.preprocess = (t3, n3, r3) => n3.preprocess(e3(Array.isArray(t3) ? Gh(t3) : t3), r3);
          }
          return e2.array ? qh.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, r2 ? { preprocess: (e3) => Array.isArray(e3) ? e3 : [e3] } : {}), u2), {}, { valueSchema: n2.create(i2) })) : n2.create(Object.assign(Object.assign({}, i2), u2));
        }
        var Zh = { normalizeApiOptions: function(e2, t2, n2) {
          return Yh(e2, t2, n2);
        }, normalizeCliOptions: function(e2, t2, n2) {
          return Yh(e2, t2, Object.assign({ isCLI: true }, n2));
        } };
        const { isNonEmptyArray: eg } = dc;
        function tg(e2, t2) {
          const { ignoreDecorators: n2 } = t2 || {};
          if (!n2) {
            const t3 = e2.declaration && e2.declaration.decorators || e2.decorators;
            if (eg(t3))
              return tg(t3[0]);
          }
          return e2.range ? e2.range[0] : e2.start;
        }
        function ng(e2) {
          return e2.range ? e2.range[1] : e2.end;
        }
        function rg(e2, t2) {
          return tg(e2) === tg(t2);
        }
        var og = { locStart: tg, locEnd: ng, hasSameLocStart: rg, hasSameLoc: function(e2, t2) {
          return rg(e2, t2) && function(e3, t3) {
            return ng(e3) === ng(t3);
          }(e2, t2);
        } }, ig = {}, ug = {}, sg = {};
        Object.defineProperty(sg, "__esModule", { value: true }), sg.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, sg.matchToToken = function(e2) {
          var t2 = { type: "invalid", value: e2[0], closed: void 0 };
          return e2[1] ? (t2.type = "string", t2.closed = !(!e2[3] && !e2[4])) : e2[5] ? t2.type = "comment" : e2[6] ? (t2.type = "comment", t2.closed = !!e2[7]) : e2[8] ? t2.type = "regex" : e2[9] ? t2.type = "number" : e2[10] ? t2.type = "name" : e2[11] ? t2.type = "punctuator" : e2[12] && (t2.type = "whitespace"), t2;
        };
        var ag = {}, cg = {};
        Object.defineProperty(cg, "__esModule", { value: true }), cg.isIdentifierStart = yg, cg.isIdentifierChar = Dg, cg.isIdentifierName = function(e2) {
          let t2 = true;
          for (let n2 = 0; n2 < e2.length; n2++) {
            let r2 = e2.charCodeAt(n2);
            if ((64512 & r2) == 55296 && n2 + 1 < e2.length) {
              const t3 = e2.charCodeAt(++n2);
              (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
            }
            if (t2) {
              if (t2 = false, !yg(r2))
                return false;
            } else if (!Dg(r2))
              return false;
          }
          return !t2;
        };
        let lg = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", pg = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const fg = new RegExp("[" + lg + "]"), dg = new RegExp("[" + lg + pg + "]");
        lg = pg = null;
        const hg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], gg = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function mg(e2, t2) {
          let n2 = 65536;
          for (let r2 = 0, o2 = t2.length; r2 < o2; r2 += 2) {
            if (n2 += t2[r2], n2 > e2)
              return false;
            if (n2 += t2[r2 + 1], n2 >= e2)
              return true;
          }
          return false;
        }
        function yg(e2) {
          return e2 < 65 ? e2 === 36 : e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && fg.test(String.fromCharCode(e2)) : mg(e2, hg)));
        }
        function Dg(e2) {
          return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && dg.test(String.fromCharCode(e2)) : mg(e2, hg) || mg(e2, gg))));
        }
        var Eg = {};
        Object.defineProperty(Eg, "__esModule", { value: true }), Eg.isReservedWord = xg, Eg.isStrictReservedWord = Sg, Eg.isStrictBindOnlyReservedWord = wg, Eg.isStrictBindReservedWord = function(e2, t2) {
          return Sg(e2, t2) || wg(e2);
        }, Eg.isKeyword = function(e2) {
          return vg.has(e2);
        };
        const Cg = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], bg = ["eval", "arguments"], vg = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Ag = new Set(Cg), Fg = new Set(bg);
        function xg(e2, t2) {
          return t2 && e2 === "await" || e2 === "enum";
        }
        function Sg(e2, t2) {
          return xg(e2, t2) || Ag.has(e2);
        }
        function wg(e2) {
          return Fg.has(e2);
        }
        !function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true }), Object.defineProperty(e2, "isIdentifierName", { enumerable: true, get: function() {
            return t2.isIdentifierName;
          } }), Object.defineProperty(e2, "isIdentifierChar", { enumerable: true, get: function() {
            return t2.isIdentifierChar;
          } }), Object.defineProperty(e2, "isIdentifierStart", { enumerable: true, get: function() {
            return t2.isIdentifierStart;
          } }), Object.defineProperty(e2, "isReservedWord", { enumerable: true, get: function() {
            return n2.isReservedWord;
          } }), Object.defineProperty(e2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
            return n2.isStrictBindOnlyReservedWord;
          } }), Object.defineProperty(e2, "isStrictBindReservedWord", { enumerable: true, get: function() {
            return n2.isStrictBindReservedWord;
          } }), Object.defineProperty(e2, "isStrictReservedWord", { enumerable: true, get: function() {
            return n2.isStrictReservedWord;
          } }), Object.defineProperty(e2, "isKeyword", { enumerable: true, get: function() {
            return n2.isKeyword;
          } });
          var t2 = cg, n2 = Eg;
        }(ag);
        var Tg = { exports: {} }, Bg = /[|\\{}()[\]^$+*?.]/g, Ng = function(e2) {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          return e2.replace(Bg, "\\$&");
        };
        const kg = yf, Pg = (e2, t2) => {
          t2 = t2 || ta.argv;
          const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), o2 = t2.indexOf("--");
          return r2 !== -1 && (o2 === -1 || r2 < o2);
        }, Og = ta.env;
        let Ig;
        function Lg(e2) {
          const t2 = function(e3) {
            if (Ig === false)
              return 0;
            if (Pg("color=16m") || Pg("color=full") || Pg("color=truecolor"))
              return 3;
            if (Pg("color=256"))
              return 2;
            if (e3 && !e3.isTTY && Ig !== true)
              return 0;
            const t3 = Ig ? 1 : 0;
            if (ta.platform === "win32") {
              const e4 = kg.release().split(".");
              return Number(ta.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
            }
            if ("CI" in Og)
              return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Og) || Og.CI_NAME === "codeship" ? 1 : t3;
            if ("TEAMCITY_VERSION" in Og)
              return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Og.TEAMCITY_VERSION) ? 1 : 0;
            if (Og.COLORTERM === "truecolor")
              return 3;
            if ("TERM_PROGRAM" in Og) {
              const e4 = parseInt((Og.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
              switch (Og.TERM_PROGRAM) {
                case "iTerm.app":
                  return e4 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                  return 2;
              }
            }
            return /-256(color)?$/i.test(Og.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Og.TERM) || "COLORTERM" in Og ? 1 : (Og.TERM, t3);
          }(e2);
          return function(e3) {
            return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
          }(t2);
        }
        Pg("no-color") || Pg("no-colors") || Pg("color=false") ? Ig = false : (Pg("color") || Pg("colors") || Pg("color=true") || Pg("color=always")) && (Ig = true), "FORCE_COLOR" in Og && (Ig = Og.FORCE_COLOR.length === 0 || parseInt(Og.FORCE_COLOR, 10) !== 0);
        var jg = { supportsColor: Lg, stdout: Lg(ta.stdout), stderr: Lg(ta.stderr) };
        const _g = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Mg = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Rg = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Vg = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, $g = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
        function Wg(e2) {
          return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : $g.get(e2) || e2;
        }
        function qg(e2, t2) {
          const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
          let o2;
          for (const t3 of r2)
            if (isNaN(t3)) {
              if (!(o2 = t3.match(Rg)))
                throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
              n2.push(o2[2].replace(Vg, (e3, t4, n3) => t4 ? Wg(t4) : n3));
            } else
              n2.push(Number(t3));
          return n2;
        }
        function Ug(e2) {
          Mg.lastIndex = 0;
          const t2 = [];
          let n2;
          for (; (n2 = Mg.exec(e2)) !== null; ) {
            const e3 = n2[1];
            if (n2[2]) {
              const r2 = qg(e3, n2[2]);
              t2.push([e3].concat(r2));
            } else
              t2.push([e3]);
          }
          return t2;
        }
        function zg(e2, t2) {
          const n2 = {};
          for (const e3 of t2)
            for (const t3 of e3.styles)
              n2[t3[0]] = e3.inverse ? null : t3.slice(1);
          let r2 = e2;
          for (const e3 of Object.keys(n2))
            if (Array.isArray(n2[e3])) {
              if (!(e3 in r2))
                throw new Error("Unknown Chalk style: ".concat(e3));
              r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
            }
          return r2;
        }
        var Gg = (e2, t2) => {
          const n2 = [], r2 = [];
          let o2 = [];
          if (t2.replace(_g, (t3, i2, u2, s2, a2, c2) => {
            if (i2)
              o2.push(Wg(i2));
            else if (s2) {
              const t4 = o2.join("");
              o2 = [], r2.push(n2.length === 0 ? t4 : zg(e2, n2)(t4)), n2.push({ inverse: u2, styles: Ug(s2) });
            } else if (a2) {
              if (n2.length === 0)
                throw new Error("Found extraneous } in Chalk template literal");
              r2.push(zg(e2, n2)(o2.join(""))), o2 = [], n2.pop();
            } else
              o2.push(c2);
          }), r2.push(o2.join("")), n2.length > 0) {
            const e3 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(n2.length === 1 ? "" : "s", " (`}`)");
            throw new Error(e3);
          }
          return r2.join("");
        };
        !function(e2) {
          const t2 = Ng, n2 = jp.exports, r2 = jg.stdout, o2 = Gg, i2 = ta.platform === "win32" && !(ta.env.TERM || "").toLowerCase().startsWith("xterm"), u2 = ["ansi", "ansi", "ansi256", "ansi16m"], s2 = /* @__PURE__ */ new Set(["gray"]), a2 = /* @__PURE__ */ Object.create(null);
          function c2(e3, t3) {
            t3 = t3 || {};
            const n3 = r2 ? r2.level : 0;
            e3.level = t3.level === void 0 ? n3 : t3.level, e3.enabled = "enabled" in t3 ? t3.enabled : e3.level > 0;
          }
          function l2(e3) {
            if (!this || !(this instanceof l2) || this.template) {
              const t3 = {};
              return c2(t3, e3), t3.template = function() {
                const e4 = [].slice.call(arguments);
                return h2.apply(null, [t3.template].concat(e4));
              }, Object.setPrototypeOf(t3, l2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = l2, t3.template;
            }
            c2(this, e3);
          }
          i2 && (n2.blue.open = "\x1B[94m");
          for (const e3 of Object.keys(n2))
            n2[e3].closeRe = new RegExp(t2(n2[e3].close), "g"), a2[e3] = { get() {
              const t3 = n2[e3];
              return f2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
            } };
          a2.visible = { get() {
            return f2.call(this, this._styles || [], true, "visible");
          } }, n2.color.closeRe = new RegExp(t2(n2.color.close), "g");
          for (const e3 of Object.keys(n2.color.ansi))
            s2.has(e3) || (a2[e3] = { get() {
              const t3 = this.level;
              return function() {
                const r3 = n2.color[u2[t3]][e3].apply(null, arguments), o3 = { open: r3, close: n2.color.close, closeRe: n2.color.closeRe };
                return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
              };
            } });
          n2.bgColor.closeRe = new RegExp(t2(n2.bgColor.close), "g");
          for (const e3 of Object.keys(n2.bgColor.ansi)) {
            if (s2.has(e3))
              continue;
            a2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
              const t3 = this.level;
              return function() {
                const r3 = n2.bgColor[u2[t3]][e3].apply(null, arguments), o3 = { open: r3, close: n2.bgColor.close, closeRe: n2.bgColor.closeRe };
                return f2.call(this, this._styles ? this._styles.concat(o3) : [o3], this._empty, e3);
              };
            } };
          }
          const p2 = Object.defineProperties(() => {
          }, a2);
          function f2(e3, t3, n3) {
            const r3 = function() {
              return d2.apply(r3, arguments);
            };
            r3._styles = e3, r3._empty = t3;
            const o3 = this;
            return Object.defineProperty(r3, "level", { enumerable: true, get: () => o3.level, set(e4) {
              o3.level = e4;
            } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => o3.enabled, set(e4) {
              o3.enabled = e4;
            } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = p2, r3;
          }
          function d2() {
            const e3 = arguments, t3 = e3.length;
            let r3 = String(arguments[0]);
            if (t3 === 0)
              return "";
            if (t3 > 1)
              for (let n3 = 1; n3 < t3; n3++)
                r3 += " " + e3[n3];
            if (!this.enabled || this.level <= 0 || !r3)
              return this._empty ? "" : r3;
            const o3 = n2.dim.open;
            i2 && this.hasGrey && (n2.dim.open = "");
            for (const e4 of this._styles.slice().reverse())
              r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, "".concat(e4.close, "$&").concat(e4.open));
            return n2.dim.open = o3, r3;
          }
          function h2(e3, t3) {
            if (!Array.isArray(t3))
              return [].slice.call(arguments, 1).join(" ");
            const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
            for (let e4 = 1; e4 < t3.length; e4++)
              r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
            return o2(e3, r3.join(""));
          }
          Object.defineProperties(l2.prototype, a2), e2.exports = l2(), e2.exports.supportsColor = r2, e2.exports.default = e2.exports;
        }(Tg), Object.defineProperty(ug, "__esModule", { value: true }), ug.default = function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (nm(t2)) {
            const n2 = rm(t2);
            return tm(Kg(n2), e2);
          }
          return e2;
        }, ug.getChalk = rm, ug.shouldHighlight = nm;
        var Hg = sg, Jg = ag, Xg = Tg.exports;
        const Yg = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
        function Kg(e2) {
          return { keyword: e2.cyan, capitalized: e2.yellow, jsxIdentifier: e2.yellow, punctuator: e2.yellow, number: e2.magenta, string: e2.green, regex: e2.magenta, comment: e2.grey, invalid: e2.white.bgRed.bold };
        }
        const Qg = /\r\n|[\n\r\u2028\u2029]/, Zg = /^[()[\]{}]$/;
        let em;
        {
          const e2 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
            if (t3.type === "name") {
              if ((0, Jg.isKeyword)(t3.value) || (0, Jg.isStrictReservedWord)(t3.value, true) || Yg.has(t3.value))
                return "keyword";
              if (e2.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
                return "jsxIdentifier";
              if (t3.value[0] !== t3.value[0].toLowerCase())
                return "capitalized";
            }
            return t3.type === "punctuator" && Zg.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
          };
          em = function* (e3) {
            let n2;
            for (; n2 = Hg.default.exec(e3); ) {
              const r2 = Hg.matchToToken(n2);
              yield { type: t2(r2, n2.index, e3), value: r2.value };
            }
          };
        }
        function tm(e2, t2) {
          let n2 = "";
          for (const { type: r2, value: o2 } of em(t2)) {
            const t3 = e2[r2];
            n2 += t3 ? o2.split(Qg).map((e3) => t3(e3)).join("\n") : o2;
          }
          return n2;
        }
        function nm(e2) {
          return !!Xg.supportsColor || e2.forceColor;
        }
        function rm(e2) {
          return e2.forceColor ? new Xg.constructor({ enabled: true, level: 1 }) : Xg;
        }
        Object.defineProperty(ig, "__esModule", { value: true }), ig.codeFrameColumns = cm, ig.default = function(e2, t2, n2) {
          let r2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          if (!im) {
            im = true;
            const e3 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (ta.emitWarning)
              ta.emitWarning(e3, "DeprecationWarning");
            else {
              new Error(e3).name = "DeprecationWarning", console.warn(new Error(e3));
            }
          }
          const o2 = { start: { column: n2 = Math.max(n2, 0), line: t2 } };
          return cm(e2, o2, r2);
        };
        var om = ug;
        let im = false;
        function um(e2) {
          return { gutter: e2.grey, marker: e2.red.bold, message: e2.red.bold };
        }
        const sm = /\r\n|[\n\r\u2028\u2029]/;
        function am(e2, t2, n2) {
          const r2 = Object.assign({ column: 0, line: -1 }, e2.start), o2 = Object.assign({}, r2, e2.end), { linesAbove: i2 = 2, linesBelow: u2 = 3 } = n2 || {}, s2 = r2.line, a2 = r2.column, c2 = o2.line, l2 = o2.column;
          let p2 = Math.max(s2 - (i2 + 1), 0), f2 = Math.min(t2.length, c2 + u2);
          s2 === -1 && (p2 = 0), c2 === -1 && (f2 = t2.length);
          const d2 = c2 - s2, h2 = {};
          if (d2)
            for (let e3 = 0; e3 <= d2; e3++) {
              const n3 = e3 + s2;
              if (a2)
                if (e3 === 0) {
                  const e4 = t2[n3 - 1].length;
                  h2[n3] = [a2, e4 - a2 + 1];
                } else if (e3 === d2)
                  h2[n3] = [0, l2];
                else {
                  const r3 = t2[n3 - e3].length;
                  h2[n3] = [0, r3];
                }
              else
                h2[n3] = true;
            }
          else
            h2[s2] = a2 === l2 ? !a2 || [a2, 0] : [a2, l2 - a2];
          return { start: p2, end: f2, markerLines: h2 };
        }
        function cm(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const r2 = (n2.highlightCode || n2.forceColor) && (0, om.shouldHighlight)(n2), o2 = (0, om.getChalk)(n2), i2 = um(o2), u2 = (e3, t3) => r2 ? e3(t3) : t3, s2 = e2.split(sm), { start: a2, end: c2, markerLines: l2 } = am(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length, d2 = r2 ? (0, om.default)(e2, n2) : e2;
          let h2 = d2.split(sm, c2).slice(a2, c2).map((e3, t3) => {
            const r3 = a2 + 1 + t3, o3 = " ".concat(r3).slice(-f2), s3 = " ".concat(o3, " |"), c3 = l2[r3], p3 = !l2[r3 + 1];
            if (c3) {
              let t4 = "";
              if (Array.isArray(c3)) {
                const r4 = e3.slice(0, Math.max(c3[0] - 1, 0)).replace(/[^\t]/g, " "), o4 = c3[1] || 1;
                t4 = ["\n ", u2(i2.gutter, s3.replace(/\d/g, " ")), " ", r4, u2(i2.marker, "^").repeat(o4)].join(""), p3 && n2.message && (t4 += " " + u2(i2.message, n2.message));
              }
              return [u2(i2.marker, ">"), u2(i2.gutter, s3), e3.length > 0 ? " ".concat(e3) : "", t4].join("");
            }
            return " ".concat(u2(i2.gutter, s3)).concat(e3.length > 0 ? " ".concat(e3) : "");
          }).join("\n");
          return n2.message && !p2 && (h2 = "".concat(" ".repeat(f2 + 1)).concat(n2.message, "\n").concat(h2)), r2 ? o2.reset(h2) : h2;
        }
        const { ConfigError: lm } = Cp, pm = og, { locStart: fm, locEnd: dm } = pm, hm = Object.getOwnPropertyNames, gm = Object.getOwnPropertyDescriptor;
        function mm(e2) {
          const t2 = {};
          for (const n2 of e2.plugins)
            if (n2.parsers)
              for (const e3 of hm(n2.parsers))
                Object.defineProperty(t2, e3, gm(n2.parsers, e3));
          return t2;
        }
        function ym(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mm(e2);
          if (typeof e2.parser == "function")
            return { parse: e2.parser, astFormat: "estree", locStart: fm, locEnd: dm };
          if (typeof e2.parser == "string") {
            if (Object.prototype.hasOwnProperty.call(t2, e2.parser))
              return t2[e2.parser];
            throw new lm(`Couldn't resolve parser "`.concat(e2.parser, '". Parsers must be explicitly added to the standalone bundle.'));
          }
        }
        var Dm = { parse: function(e2, t2) {
          const n2 = mm(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e3) => [e3, { enumerable: true, get: () => n2[e3].parse }]))), o2 = ym(t2, n2);
          try {
            return o2.preprocess && (e2 = o2.preprocess(e2, t2)), { text: e2, ast: o2.parse(e2, r2, t2) };
          } catch (t3) {
            const { loc: n3 } = t3;
            if (n3) {
              const { codeFrameColumns: r3 } = ig;
              throw t3.codeFrame = r3(e2, n3, { highlightCode: true }), t3.message += "\n" + t3.codeFrame, t3;
            }
            throw t3.stack;
          }
        }, resolveParser: ym };
        const Em = el, Cm = gl, bm = gp, { UndefinedParserError: vm } = Cp, { getSupportInfo: Am } = za, Fm = Zh, { resolveParser: xm } = Dm, Sm = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
        function wm(e2) {
          const { astFormat: t2 } = e2;
          if (!t2)
            throw new Error("getPlugin() requires astFormat to be set");
          const n2 = e2.plugins.find((e3) => e3.printers && e3.printers[t2]);
          if (!n2)
            throw new Error(`Couldn't find plugin for AST format "`.concat(t2, '"'));
          return n2;
        }
        function Tm(e2, t2) {
          const n2 = Cm.basename(e2).toLowerCase(), r2 = Am({ plugins: t2 }).languages.filter((e3) => e3.since !== null);
          let o2 = r2.find((e3) => e3.extensions && e3.extensions.some((e4) => n2.endsWith(e4)) || e3.filenames && e3.filenames.some((e4) => e4.toLowerCase() === n2));
          if (!o2 && !n2.includes(".")) {
            const t3 = function(e3) {
              if (typeof e3 != "string")
                return "";
              let t4;
              try {
                t4 = Em.openSync(e3, "r");
              } catch (e4) {
                return "";
              }
              try {
                const e4 = new bm(t4).next().toString("utf8"), n3 = e4.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
                if (n3)
                  return n3[1];
                const r3 = e4.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
                return r3 ? r3[1] : "";
              } catch (e4) {
                return "";
              } finally {
                try {
                  Em.closeSync(t4);
                } catch (e4) {
                }
              }
            }(e2);
            o2 = r2.find((e3) => e3.interpreters && e3.interpreters.includes(t3));
          }
          return o2 && o2.parsers[0];
        }
        var Bm = { normalize: function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const n2 = Object.assign({}, e2), r2 = Am({ plugins: e2.plugins, showUnreleased: true, showDeprecated: true }).options, o2 = Object.assign(Object.assign({}, Sm), Object.fromEntries(r2.filter((e3) => e3.default !== void 0).map((e3) => [e3.name, e3.default])));
          if (!n2.parser)
            if (n2.filepath) {
              if (n2.parser = Tm(n2.filepath, n2.plugins), !n2.parser)
                throw new vm("No parser could be inferred for file: ".concat(n2.filepath));
            } else {
              (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
            }
          const i2 = xm(Fm.normalizeApiOptions(n2, [r2.find((e3) => e3.name === "parser")], { passThrough: true, logger: false }));
          n2.astFormat = i2.astFormat, n2.locEnd = i2.locEnd, n2.locStart = i2.locStart;
          const u2 = wm(n2);
          n2.printer = u2.printers[n2.astFormat];
          const s2 = Object.fromEntries(r2.filter((e3) => e3.pluginDefaults && e3.pluginDefaults[u2.name] !== void 0).map((e3) => [e3.name, e3.pluginDefaults[u2.name]])), a2 = Object.assign(Object.assign({}, o2), s2);
          for (const [e3, t3] of Object.entries(a2))
            n2[e3] !== null && n2[e3] !== void 0 || (n2[e3] = t3);
          return n2.parser === "json" && (n2.trailingComma = "none"), Fm.normalizeApiOptions(n2, r2, Object.assign({ passThrough: Object.keys(Sm) }, t2));
        }, hiddenDefaults: Sm, inferParser: Tm };
        var Nm = function e2(t2, n2, r2) {
          if (Array.isArray(t2))
            return t2.map((t3) => e2(t3, n2, r2)).filter(Boolean);
          if (!t2 || typeof t2 != "object")
            return t2;
          const o2 = n2.printer.massageAstNode;
          let i2;
          i2 = o2 && o2.ignoredProperties ? o2.ignoredProperties : /* @__PURE__ */ new Set();
          const u2 = {};
          for (const [r3, o3] of Object.entries(t2))
            i2.has(r3) || typeof o3 == "function" || (u2[r3] = e2(o3, n2, t2));
          if (o2) {
            const e3 = o2(t2, u2, r2);
            if (e3 === null)
              return;
            if (e3)
              return e3;
          }
          return u2;
        }, km = typeof Object.create == "function" ? function(e2, t2) {
          e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
        } : function(e2, t2) {
          e2.super_ = t2;
          var n2 = function() {
          };
          n2.prototype = t2.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
        };
        function Pm(e2, t2) {
          var n2 = { seen: [], stylize: Im };
          return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Mm(t2) ? n2.showHidden = t2 : t2 && Xm(n2, t2), $m(n2.showHidden) && (n2.showHidden = false), $m(n2.depth) && (n2.depth = 2), $m(n2.colors) && (n2.colors = false), $m(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Om), Lm(n2, e2, n2.depth);
        }
        function Om(e2, t2) {
          var n2 = Pm.styles[t2];
          return n2 ? "\x1B[" + Pm.colors[n2][0] + "m" + e2 + "\x1B[" + Pm.colors[n2][1] + "m" : e2;
        }
        function Im(e2, t2) {
          return e2;
        }
        function Lm(e2, t2, n2) {
          if (e2.customInspect && t2 && Gm(t2.inspect) && t2.inspect !== Pm && (!t2.constructor || t2.constructor.prototype !== t2)) {
            var r2 = t2.inspect(n2, e2);
            return Vm(r2) || (r2 = Lm(e2, r2, n2)), r2;
          }
          var o2 = function(e3, t3) {
            if ($m(t3))
              return e3.stylize("undefined", "undefined");
            if (Vm(t3)) {
              var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return e3.stylize(n3, "string");
            }
            if (r3 = t3, typeof r3 == "number")
              return e3.stylize("" + t3, "number");
            var r3;
            if (Mm(t3))
              return e3.stylize("" + t3, "boolean");
            if (Rm(t3))
              return e3.stylize("null", "null");
          }(e2, t2);
          if (o2)
            return o2;
          var i2 = Object.keys(t2), u2 = function(e3) {
            var t3 = {};
            return e3.forEach(function(e4, n3) {
              t3[e4] = true;
            }), t3;
          }(i2);
          if (e2.showHidden && (i2 = Object.getOwnPropertyNames(t2)), zm(t2) && (i2.indexOf("message") >= 0 || i2.indexOf("description") >= 0))
            return jm(t2);
          if (i2.length === 0) {
            if (Gm(t2)) {
              var s2 = t2.name ? ": " + t2.name : "";
              return e2.stylize("[Function" + s2 + "]", "special");
            }
            if (Wm(t2))
              return e2.stylize(RegExp.prototype.toString.call(t2), "regexp");
            if (Um(t2))
              return e2.stylize(Date.prototype.toString.call(t2), "date");
            if (zm(t2))
              return jm(t2);
          }
          var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
          (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Gm(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
          return Wm(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), Um(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), zm(t2) && (l2 = " " + jm(t2)), i2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? Wm(t2) ? e2.stylize(RegExp.prototype.toString.call(t2), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t2), c2 = p2 ? function(e3, t3, n3, r3, o3) {
            for (var i3 = [], u3 = 0, s3 = t3.length; u3 < s3; ++u3)
              Ym(t3, String(u3)) ? i3.push(_m(e3, t3, n3, r3, String(u3), true)) : i3.push("");
            return o3.forEach(function(o4) {
              o4.match(/^\d+$/) || i3.push(_m(e3, t3, n3, r3, o4, true));
            }), i3;
          }(e2, t2, n2, u2, i2) : i2.map(function(r3) {
            return _m(e2, t2, n2, u2, r3, p2);
          }), e2.seen.pop(), function(e3, t3, n3) {
            if (e3.reduce(function(e4, t4) {
              return t4.indexOf("\n"), e4 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60)
              return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e3.join(",\n  ") + " " + n3[1];
            return n3[0] + t3 + " " + e3.join(", ") + " " + n3[1];
          }(c2, l2, f2)) : f2[0] + l2 + f2[1];
        }
        function jm(e2) {
          return "[" + Error.prototype.toString.call(e2) + "]";
        }
        function _m(e2, t2, n2, r2, o2, i2) {
          var u2, s2, a2;
          if ((a2 = Object.getOwnPropertyDescriptor(t2, o2) || { value: t2[o2] }).get ? s2 = a2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : a2.set && (s2 = e2.stylize("[Setter]", "special")), Ym(r2, o2) || (u2 = "[" + o2 + "]"), s2 || (e2.seen.indexOf(a2.value) < 0 ? (s2 = Rm(n2) ? Lm(e2, a2.value, null) : Lm(e2, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = i2 ? s2.split("\n").map(function(e3) {
            return "  " + e3;
          }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e3) {
            return "   " + e3;
          }).join("\n")) : s2 = e2.stylize("[Circular]", "special")), $m(u2)) {
            if (i2 && o2.match(/^\d+$/))
              return s2;
            (u2 = JSON.stringify("" + o2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u2 = u2.substr(1, u2.length - 2), u2 = e2.stylize(u2, "name")) : (u2 = u2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u2 = e2.stylize(u2, "string"));
          }
          return u2 + ": " + s2;
        }
        function Mm(e2) {
          return typeof e2 == "boolean";
        }
        function Rm(e2) {
          return e2 === null;
        }
        function Vm(e2) {
          return typeof e2 == "string";
        }
        function $m(e2) {
          return e2 === void 0;
        }
        function Wm(e2) {
          return qm(e2) && Jm(e2) === "[object RegExp]";
        }
        function qm(e2) {
          return typeof e2 == "object" && e2 !== null;
        }
        function Um(e2) {
          return qm(e2) && Jm(e2) === "[object Date]";
        }
        function zm(e2) {
          return qm(e2) && (Jm(e2) === "[object Error]" || e2 instanceof Error);
        }
        function Gm(e2) {
          return typeof e2 == "function";
        }
        function Hm(e2) {
          return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || e2 === void 0;
        }
        function Jm(e2) {
          return Object.prototype.toString.call(e2);
        }
        function Xm(e2, t2) {
          if (!t2 || !qm(t2))
            return e2;
          for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
            e2[n2[r2]] = t2[n2[r2]];
          return e2;
        }
        function Ym(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }
        function Km(e2, t2) {
          if (e2 === t2)
            return 0;
          for (var n2 = e2.length, r2 = t2.length, o2 = 0, i2 = Math.min(n2, r2); o2 < i2; ++o2)
            if (e2[o2] !== t2[o2]) {
              n2 = e2[o2], r2 = t2[o2];
              break;
            }
          return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
        }
        Pm.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, Pm.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
        var Qm, Zm = Object.prototype.hasOwnProperty, ey = Object.keys || function(e2) {
          var t2 = [];
          for (var n2 in e2)
            Zm.call(e2, n2) && t2.push(n2);
          return t2;
        }, ty = Array.prototype.slice;
        function ny() {
          return Qm !== void 0 ? Qm : Qm = function() {
          }.name === "foo";
        }
        function ry(e2) {
          return Object.prototype.toString.call(e2);
        }
        function oy(e2) {
          return !fp(e2) && (typeof Ns.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e2) : !!e2 && (e2 instanceof DataView || !!(e2.buffer && e2.buffer instanceof ArrayBuffer))));
        }
        function iy(e2, t2) {
          e2 || py(e2, true, t2, "==", fy);
        }
        var uy = /\s*function\s+([^\(\s]*)\s*/;
        function sy(e2) {
          if (Gm(e2)) {
            if (ny())
              return e2.name;
            var t2 = e2.toString().match(uy);
            return t2 && t2[1];
          }
        }
        function ay(e2) {
          this.name = "AssertionError", this.actual = e2.actual, this.expected = e2.expected, this.operator = e2.operator, e2.message ? (this.message = e2.message, this.generatedMessage = false) : (this.message = function(e3) {
            return cy(ly(e3.actual), 128) + " " + e3.operator + " " + cy(ly(e3.expected), 128);
          }(this), this.generatedMessage = true);
          var t2 = e2.stackStartFunction || py;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, t2);
          else {
            var n2 = new Error();
            if (n2.stack) {
              var r2 = n2.stack, o2 = sy(t2), i2 = r2.indexOf("\n" + o2);
              if (i2 >= 0) {
                var u2 = r2.indexOf("\n", i2 + 1);
                r2 = r2.substring(u2 + 1);
              }
              this.stack = r2;
            }
          }
        }
        function cy(e2, t2) {
          return typeof e2 == "string" ? e2.length < t2 ? e2 : e2.slice(0, t2) : e2;
        }
        function ly(e2) {
          if (ny() || !Gm(e2))
            return Pm(e2);
          var t2 = sy(e2);
          return "[Function" + (t2 ? ": " + t2 : "") + "]";
        }
        function py(e2, t2, n2, r2, o2) {
          throw new ay({ message: n2, actual: e2, expected: t2, operator: r2, stackStartFunction: o2 });
        }
        function fy(e2, t2) {
          e2 || py(e2, true, t2, "==", fy);
        }
        function dy(e2, t2, n2) {
          e2 != t2 && py(e2, t2, n2, "==", dy);
        }
        function hy(e2, t2, n2) {
          e2 == t2 && py(e2, t2, n2, "!=", hy);
        }
        function gy(e2, t2, n2) {
          yy(e2, t2, false) || py(e2, t2, n2, "deepEqual", gy);
        }
        function my(e2, t2, n2) {
          yy(e2, t2, true) || py(e2, t2, n2, "deepStrictEqual", my);
        }
        function yy(e2, t2, n2, r2) {
          if (e2 === t2)
            return true;
          if (fp(e2) && fp(t2))
            return Km(e2, t2) === 0;
          if (Um(e2) && Um(t2))
            return e2.getTime() === t2.getTime();
          if (Wm(e2) && Wm(t2))
            return e2.source === t2.source && e2.global === t2.global && e2.multiline === t2.multiline && e2.lastIndex === t2.lastIndex && e2.ignoreCase === t2.ignoreCase;
          if (e2 !== null && typeof e2 == "object" || t2 !== null && typeof t2 == "object") {
            if (oy(e2) && oy(t2) && ry(e2) === ry(t2) && !(e2 instanceof Float32Array || e2 instanceof Float64Array))
              return Km(new Uint8Array(e2.buffer), new Uint8Array(t2.buffer)) === 0;
            if (fp(e2) !== fp(t2))
              return false;
            var o2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e2);
            return o2 !== -1 && o2 === r2.expected.indexOf(t2) || (r2.actual.push(e2), r2.expected.push(t2), function(e3, t3, n3, r3) {
              if (e3 == null || t3 == null)
                return false;
              if (Hm(e3) || Hm(t3))
                return e3 === t3;
              if (n3 && Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3))
                return false;
              var o3 = Dy(e3), i2 = Dy(t3);
              if (o3 && !i2 || !o3 && i2)
                return false;
              if (o3)
                return yy(e3 = ty.call(e3), t3 = ty.call(t3), n3);
              var u2, s2, a2 = ey(e3), c2 = ey(t3);
              if (a2.length !== c2.length)
                return false;
              for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
                if (a2[s2] !== c2[s2])
                  return false;
              for (s2 = a2.length - 1; s2 >= 0; s2--)
                if (!yy(e3[u2 = a2[s2]], t3[u2], n3, r3))
                  return false;
              return true;
            }(e2, t2, n2, r2));
          }
          return n2 ? e2 === t2 : e2 == t2;
        }
        function Dy(e2) {
          return Object.prototype.toString.call(e2) == "[object Arguments]";
        }
        function Ey(e2, t2, n2) {
          yy(e2, t2, false) && py(e2, t2, n2, "notDeepEqual", Ey);
        }
        function Cy(e2, t2, n2) {
          yy(e2, t2, true) && py(e2, t2, n2, "notDeepStrictEqual", Cy);
        }
        function by(e2, t2, n2) {
          e2 !== t2 && py(e2, t2, n2, "===", by);
        }
        function vy(e2, t2, n2) {
          e2 === t2 && py(e2, t2, n2, "!==", vy);
        }
        function Ay(e2, t2) {
          if (!e2 || !t2)
            return false;
          if (Object.prototype.toString.call(t2) == "[object RegExp]")
            return t2.test(e2);
          try {
            if (e2 instanceof t2)
              return true;
          } catch (e3) {
          }
          return !Error.isPrototypeOf(t2) && t2.call({}, e2) === true;
        }
        function Fy(e2, t2, n2, r2) {
          var o2;
          if (typeof t2 != "function")
            throw new TypeError('"block" argument must be a function');
          typeof n2 == "string" && (r2 = n2, n2 = null), o2 = function(e3) {
            var t3;
            try {
              e3();
            } catch (e4) {
              t3 = e4;
            }
            return t3;
          }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e2 && !o2 && py(o2, n2, "Missing expected exception" + r2);
          var i2 = typeof r2 == "string", u2 = !e2 && o2 && !n2;
          if ((!e2 && zm(o2) && i2 && Ay(o2, n2) || u2) && py(o2, n2, "Got unwanted exception" + r2), e2 && o2 && n2 && !Ay(o2, n2) || !e2 && o2)
            throw o2;
        }
        function xy(e2, t2, n2) {
          Fy(true, e2, t2, n2);
        }
        function Sy(e2, t2, n2) {
          Fy(false, e2, t2, n2);
        }
        function wy(e2) {
          if (e2)
            throw e2;
        }
        iy.AssertionError = ay, km(ay, Error), iy.fail = py, iy.ok = fy, iy.equal = dy, iy.notEqual = hy, iy.deepEqual = gy, iy.deepStrictEqual = my, iy.notDeepEqual = Ey, iy.notDeepStrictEqual = Cy, iy.strictEqual = by, iy.notStrictEqual = vy, iy.throws = xy, iy.doesNotThrow = Sy, iy.ifError = wy;
        var Ty = t(Object.freeze({ __proto__: null, default: iy, AssertionError: ay, fail: py, ok: fy, assert: fy, equal: dy, notEqual: hy, deepEqual: gy, deepStrictEqual: my, notDeepEqual: Ey, notDeepStrictEqual: Cy, strictEqual: by, notStrictEqual: vy, throws: xy, doesNotThrow: Sy, ifError: wy }));
        const By = Ty, { builders: { line: Ny, hardline: ky, breakParent: Py, indent: Oy, lineSuffix: Iy, join: Ly, cursor: jy } } = Zc, { hasNewline: _y, skipNewline: My, skipSpaces: Ry, isPreviousLineEmpty: Vy, addLeadingComment: $y, addDanglingComment: Wy, addTrailingComment: qy } = dc, Uy = /* @__PURE__ */ new WeakMap();
        function zy(e2, t2, n2) {
          if (!e2)
            return;
          const { printer: r2, locStart: o2, locEnd: i2 } = t2;
          if (n2) {
            if (r2.canAttachComment && r2.canAttachComment(e2)) {
              let t3;
              for (t3 = n2.length - 1; t3 >= 0 && !(o2(n2[t3]) <= o2(e2) && i2(n2[t3]) <= i2(e2)); --t3)
                ;
              return void n2.splice(t3 + 1, 0, e2);
            }
          } else if (Uy.has(e2))
            return Uy.get(e2);
          const u2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e2, t2) || typeof e2 == "object" && Object.entries(e2).filter((e3) => {
            let [t3] = e3;
            return t3 !== "enclosingNode" && t3 !== "precedingNode" && t3 !== "followingNode" && t3 !== "tokens" && t3 !== "comments";
          }).map((e3) => {
            let [, t3] = e3;
            return t3;
          });
          if (u2) {
            n2 || (n2 = [], Uy.set(e2, n2));
            for (const e3 of u2)
              zy(e3, t2, n2);
            return n2;
          }
        }
        function Gy(e2, t2, n2, r2) {
          const { locStart: o2, locEnd: i2 } = n2, u2 = o2(t2), s2 = i2(t2), a2 = zy(e2, n2);
          let c2, l2, p2 = 0, f2 = a2.length;
          for (; p2 < f2; ) {
            const e3 = p2 + f2 >> 1, r3 = a2[e3], d2 = o2(r3), h2 = i2(r3);
            if (d2 <= u2 && s2 <= h2)
              return Gy(r3, t2, n2, r3);
            if (h2 <= u2)
              c2 = r3, p2 = e3 + 1;
            else {
              if (!(s2 <= d2))
                throw new Error("Comment location overlaps with node location");
              l2 = r3, f2 = e3;
            }
          }
          if (r2 && r2.type === "TemplateLiteral") {
            const { quasis: e3 } = r2, o3 = Zy(e3, t2, n2);
            c2 && Zy(e3, c2, n2) !== o3 && (c2 = null), l2 && Zy(e3, l2, n2) !== o3 && (l2 = null);
          }
          return { enclosingNode: r2, precedingNode: c2, followingNode: l2 };
        }
        const Hy = () => false;
        const Jy = (e2) => !/[\S\n\u2028\u2029]/.test(e2);
        function Xy(e2, t2, n2, r2) {
          const { comment: o2, precedingNode: i2 } = n2[r2], { locStart: u2, locEnd: s2 } = t2;
          let a2 = u2(o2);
          if (i2)
            for (let t3 = r2 - 1; t3 >= 0; t3--) {
              const { comment: r3, precedingNode: o3 } = n2[t3];
              if (o3 !== i2 || !Jy(e2.slice(s2(r3), a2)))
                break;
              a2 = u2(r3);
            }
          return _y(e2, a2, { backwards: true });
        }
        function Yy(e2, t2, n2, r2) {
          const { comment: o2, followingNode: i2 } = n2[r2], { locStart: u2, locEnd: s2 } = t2;
          let a2 = s2(o2);
          if (i2)
            for (let t3 = r2 + 1; t3 < n2.length; t3++) {
              const { comment: r3, followingNode: o3 } = n2[t3];
              if (o3 !== i2 || !Jy(e2.slice(a2, u2(r3))))
                break;
              a2 = s2(r3);
            }
          return _y(e2, a2);
        }
        function Ky(e2, t2, n2) {
          const r2 = e2.length;
          if (r2 === 0)
            return;
          const { precedingNode: o2, followingNode: i2, enclosingNode: u2 } = e2[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(u2) || /^[\s(]*$/;
          let a2, c2 = n2.locStart(i2);
          for (a2 = r2; a2 > 0; --a2) {
            const { comment: r3, precedingNode: u3, followingNode: l2 } = e2[a2 - 1];
            By.strictEqual(u3, o2), By.strictEqual(l2, i2);
            const p2 = t2.slice(n2.locEnd(r3), c2);
            if (!s2.test(p2))
              break;
            c2 = n2.locStart(r3);
          }
          for (const [t3, { comment: n3 }] of e2.entries())
            t3 < a2 ? qy(o2, n3) : $y(i2, n3);
          for (const e3 of [o2, i2])
            e3.comments && e3.comments.length > 1 && e3.comments.sort((e4, t3) => n2.locStart(e4) - n2.locStart(t3));
          e2.length = 0;
        }
        function Qy(e2, t2) {
          return e2.getValue().printed = true, t2.printer.printComment(e2, t2);
        }
        function Zy(e2, t2, n2) {
          const r2 = n2.locStart(t2) - 1;
          for (let t3 = 1; t3 < e2.length; ++t3)
            if (r2 < n2.locStart(e2[t3]))
              return t3 - 1;
          return 0;
        }
        function eD(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2)
            return {};
          let o2 = r2.comments || [];
          n2 && (o2 = o2.filter((e3) => !n2.has(e3)));
          const i2 = r2 === t2.cursorNode;
          if (o2.length === 0) {
            const e3 = i2 ? jy : "";
            return { leading: e3, trailing: e3 };
          }
          const u2 = [], s2 = [];
          return e2.each(() => {
            const r3 = e2.getValue();
            if (n2 && n2.has(r3))
              return;
            const { leading: o3, trailing: i3 } = r3;
            o3 ? u2.push(function(e3, t3) {
              const n3 = e3.getValue(), r4 = [Qy(e3, t3)], { printer: o4, originalText: i4, locStart: u3, locEnd: s3 } = t3;
              if (o4.isBlockComment && o4.isBlockComment(n3)) {
                const e4 = _y(i4, s3(n3)) ? _y(i4, u3(n3), { backwards: true }) ? ky : Ny : " ";
                r4.push(e4);
              } else
                r4.push(ky);
              const a2 = My(i4, Ry(i4, s3(n3)));
              return a2 !== false && _y(i4, a2) && r4.push(ky), r4;
            }(e2, t2)) : i3 && s2.push(function(e3, t3) {
              const n3 = e3.getValue(), r4 = Qy(e3, t3), { printer: o4, originalText: i4, locStart: u3 } = t3, s3 = o4.isBlockComment && o4.isBlockComment(n3);
              if (_y(i4, u3(n3), { backwards: true })) {
                const e4 = Vy(i4, n3, u3);
                return Iy([ky, e4 ? ky : "", r4]);
              }
              let a2 = [" ", r4];
              return s3 || (a2 = [Iy(a2), Py]), a2;
            }(e2, t2));
          }, "comments"), i2 && (u2.unshift(jy), s2.push(jy)), { leading: u2, trailing: s2 };
        }
        var tD = { attach: function(e2, t2, n2, r2) {
          if (!Array.isArray(e2))
            return;
          const o2 = [], { locStart: i2, locEnd: u2, printer: { handleComments: s2 = {} } } = r2, { avoidAstMutation: a2, ownLine: c2 = Hy, endOfLine: l2 = Hy, remaining: p2 = Hy } = s2, f2 = e2.map((o3, i3) => Object.assign(Object.assign({}, Gy(t2, o3, r2)), {}, { comment: o3, text: n2, options: r2, ast: t2, isLastComment: e2.length - 1 === i3 }));
          for (const [e3, t3] of f2.entries()) {
            const { comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2 } = t3;
            if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
              if (i2(n3) - i2(m2) <= 0) {
                $y(m2, n3);
                continue;
              }
              if (u2(n3) - u2(m2) >= 0) {
                qy(m2, n3);
                continue;
              }
            }
            let D2;
            if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), Xy(h2, g2, f2, e3))
              n3.placement = "ownLine", c2(...D2) || (d2 ? $y(d2, n3) : r3 ? qy(r3, n3) : Wy(s3 || m2, n3));
            else if (Yy(h2, g2, f2, e3))
              n3.placement = "endOfLine", l2(...D2) || (r3 ? qy(r3, n3) : d2 ? $y(d2, n3) : Wy(s3 || m2, n3));
            else if (n3.placement = "remaining", p2(...D2))
              ;
            else if (r3 && d2) {
              const e4 = o2.length;
              if (e4 > 0) {
                o2[e4 - 1].followingNode !== d2 && Ky(o2, h2, g2);
              }
              o2.push(t3);
            } else
              r3 ? qy(r3, n3) : d2 ? $y(d2, n3) : Wy(s3 || m2, n3);
          }
          if (Ky(o2, n2, r2), !a2)
            for (const t3 of e2)
              delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
        }, printComments: function(e2, t2, n2, r2) {
          const { leading: o2, trailing: i2 } = eD(e2, n2, r2);
          return o2 || i2 ? [o2, t2, i2] : t2;
        }, printCommentsSeparately: eD, printDanglingComments: function(e2, t2, n2, r2) {
          const o2 = [], i2 = e2.getValue();
          return i2 && i2.comments ? (e2.each(() => {
            const n3 = e2.getValue();
            n3.leading || n3.trailing || r2 && !r2(n3) || o2.push(Qy(e2, t2));
          }, "comments"), o2.length === 0 ? "" : n2 ? Ly(ky, o2) : Oy([ky, Ly(ky, o2)])) : "";
        }, getSortedChildNodes: zy, ensureAllCommentsPrinted: function(e2) {
          if (e2)
            for (const t2 of e2) {
              if (!t2.printed)
                throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
              delete t2.printed;
            }
        } };
        const nD = au;
        function rD(e2, t2) {
          const n2 = oD(e2.stack, t2);
          return n2 === -1 ? null : e2.stack[n2];
        }
        function oD(e2, t2) {
          for (let n2 = e2.length - 1; n2 >= 0; n2 -= 2) {
            const r2 = e2[n2];
            if (r2 && !Array.isArray(r2) && --t2 < 0)
              return n2;
          }
          return -1;
        }
        var iD = class {
          constructor(e2) {
            this.stack = [e2];
          }
          getName() {
            const { stack: e2 } = this, { length: t2 } = e2;
            return t2 > 1 ? e2[t2 - 2] : null;
          }
          getValue() {
            return nD(this.stack);
          }
          getNode() {
            return rD(this, arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0);
          }
          getParentNode() {
            return rD(this, (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0) + 1);
          }
          call(e2) {
            const { stack: t2 } = this, { length: n2 } = t2;
            let r2 = nD(t2);
            for (var o2 = arguments.length, i2 = new Array(o2 > 1 ? o2 - 1 : 0), u2 = 1; u2 < o2; u2++)
              i2[u2 - 1] = arguments[u2];
            for (const e3 of i2)
              r2 = r2[e3], t2.push(e3, r2);
            const s2 = e2(this);
            return t2.length = n2, s2;
          }
          callParent(e2) {
            let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const n2 = oD(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), o2 = e2(this);
            return this.stack.push(...r2), o2;
          }
          each(e2) {
            const { stack: t2 } = this, { length: n2 } = t2;
            let r2 = nD(t2);
            for (var o2 = arguments.length, i2 = new Array(o2 > 1 ? o2 - 1 : 0), u2 = 1; u2 < o2; u2++)
              i2[u2 - 1] = arguments[u2];
            for (const e3 of i2)
              r2 = r2[e3], t2.push(e3, r2);
            for (let n3 = 0; n3 < r2.length; ++n3)
              t2.push(n3, r2[n3]), e2(this, n3, r2), t2.length -= 2;
            t2.length = n2;
          }
          map(e2) {
            const t2 = [];
            for (var n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++)
              r2[o2 - 1] = arguments[o2];
            return this.each((n3, r3, o3) => {
              t2[r3] = e2(n3, r3, o3);
            }, ...r2), t2;
          }
          try(e2) {
            const { stack: t2 } = this, n2 = [...t2];
            try {
              return e2();
            } finally {
              t2.length = 0, t2.push(...n2);
            }
          }
          match() {
            let e2 = this.stack.length - 1, t2 = null, n2 = this.stack[e2--];
            for (var r2 = arguments.length, o2 = new Array(r2), i2 = 0; i2 < r2; i2++)
              o2[i2] = arguments[i2];
            for (const r3 of o2) {
              if (n2 === void 0)
                return false;
              let o3 = null;
              if (typeof t2 == "number" && (o3 = t2, t2 = this.stack[e2--], n2 = this.stack[e2--]), r3 && !r3(n2, t2, o3))
                return false;
              t2 = this.stack[e2--], n2 = this.stack[e2--];
            }
            return true;
          }
          findAncestor(e2) {
            let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
            for (; r2; ) {
              let o2 = null;
              if (typeof n2 == "number" && (o2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e2(r2, n2, o2))
                return r2;
              n2 = this.stack[t2--], r2 = this.stack[t2--];
            }
          }
        };
        const { utils: { stripTrailingHardline: uD } } = Zc, { normalize: sD } = Bm, aD = tD;
        var cD = { printSubtree: function(e2, t2, n2, r2) {
          if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
            return n2.printer.embed(e2, t2, (e3, t3, o2) => function(e4, t4, n3, r3) {
              let { stripTrailingHardline: o3 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
              const i2 = sD(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, { parentParser: n3.parser, originalText: e4 }), { passThrough: true }), u2 = Dm.parse(e4, i2), { ast: s2 } = u2;
              e4 = u2.text;
              const a2 = s2.comments;
              delete s2.comments, aD.attach(a2, s2, e4, i2), i2[Symbol.for("comments")] = a2 || [], i2[Symbol.for("tokens")] = s2.tokens || [];
              const c2 = r3(s2, i2);
              if (aD.ensureAllCommentsPrinted(a2), o3)
                return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : uD(c2);
              return c2;
            }(e3, t3, n2, r2, o2), n2);
        } };
        const lD = iD, { builders: { hardline: pD, addAlignmentToDoc: fD }, utils: { propagateBreaks: dD } } = Zc, { printComments: hD } = tD, gD = cD;
        function mD(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          const { printer: r2 } = t2;
          r2.preprocess && (e2 = r2.preprocess(e2, t2));
          const o2 = /* @__PURE__ */ new Map(), i2 = new lD(e2);
          let u2 = s2();
          return n2 > 0 && (u2 = fD([pD, u2], n2, t2.tabWidth)), dD(u2), u2;
          function s2(e3, t3) {
            return e3 === void 0 || e3 === i2 ? a2(t3) : Array.isArray(e3) ? i2.call(() => a2(t3), ...e3) : i2.call(() => a2(t3), e3);
          }
          function a2(e3) {
            const n3 = i2.getValue(), r3 = n3 && typeof n3 == "object" && e3 === void 0;
            if (r3 && o2.has(n3))
              return o2.get(n3);
            const u3 = yD(i2, t2, s2, e3);
            return r3 && o2.set(n3, u3), u3;
          }
        }
        function yD(t2, n2, r2, o2) {
          const i2 = t2.getValue(), { printer: u2 } = n2;
          let s2, a2;
          if (u2.hasPrettierIgnore && u2.hasPrettierIgnore(t2))
            ({ doc: s2, printedComments: a2 } = function(e2, t3) {
              const { originalText: n3, [Symbol.for("comments")]: r3, locStart: o3, locEnd: i3 } = t3, u3 = o3(e2), s3 = i3(e2), a3 = /* @__PURE__ */ new Set();
              for (const e3 of r3)
                o3(e3) >= u3 && i3(e3) <= s3 && (e3.printed = true, a3.add(e3));
              return { doc: n3.slice(u3, s3), printedComments: a3 };
            }(i2, n2));
          else {
            if (i2)
              try {
                s2 = gD.printSubtree(t2, r2, n2, mD);
              } catch (t3) {
                if (e.PRETTIER_DEBUG)
                  throw t3;
              }
            s2 || (s2 = u2.print(t2, n2, r2, o2));
          }
          return u2.willPrintOwnComments && u2.willPrintOwnComments(t2, n2) || (s2 = hD(t2, s2, n2, a2)), s2;
        }
        var DD = mD;
        const ED = Ty, CD = tD;
        function bD(e2) {
          let t2 = e2.length - 1;
          for (; ; ) {
            const n2 = e2[t2];
            if (!n2 || n2.type !== "Program" && n2.type !== "File")
              break;
            t2--;
          }
          return e2.slice(0, t2 + 1);
        }
        function vD(e2, t2, n2, r2) {
          let o2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], i2 = arguments.length > 5 ? arguments[5] : void 0;
          const { locStart: u2, locEnd: s2 } = n2, a2 = u2(e2), c2 = s2(e2);
          if (!(t2 > c2 || t2 < a2 || i2 === "rangeEnd" && t2 === a2 || i2 === "rangeStart" && t2 === c2)) {
            for (const u3 of CD.getSortedChildNodes(e2, n2)) {
              const s3 = vD(u3, t2, n2, r2, [e2, ...o2], i2);
              if (s3)
                return s3;
            }
            return !r2 || r2(e2, o2[0]) ? { node: e2, parentNodes: o2 } : void 0;
          }
        }
        const AD = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), FD = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
        function xD(e2, t2, n2) {
          if (!t2)
            return false;
          switch (e2.parser) {
            case "flow":
            case "babel":
            case "babel-flow":
            case "babel-ts":
            case "typescript":
            case "espree":
            case "meriyah":
            case "__babel_estree":
              return function(e3, t3) {
                return t3 !== "DeclareExportDeclaration" && e3 !== "TypeParameterDeclaration" && (e3 === "Directive" || e3 === "TypeAlias" || e3 === "TSExportAssignment" || e3.startsWith("Declare") || e3.startsWith("TSDeclare") || e3.endsWith("Statement") || e3.endsWith("Declaration"));
              }(t2.type, n2 && n2.type);
            case "json":
            case "json5":
            case "json-stringify":
              return AD.has(t2.type);
            case "graphql":
              return FD.has(t2.kind);
            case "vue":
              return t2.tag !== "root";
          }
          return false;
        }
        var SD = { calculateRange: function(e2, t2, n2) {
          let { rangeStart: r2, rangeEnd: o2, locStart: i2, locEnd: u2 } = t2;
          ED.ok(o2 > r2);
          const s2 = e2.slice(r2, o2).search(/\S/), a2 = s2 === -1;
          if (!a2)
            for (r2 += s2; o2 > r2 && !/\S/.test(e2[o2 - 1]); --o2)
              ;
          const c2 = vD(n2, r2, t2, (e3, n3) => xD(t2, e3, n3), [], "rangeStart"), l2 = a2 ? c2 : vD(n2, o2, t2, (e3) => xD(t2, e3), [], "rangeEnd");
          if (!c2 || !l2)
            return { rangeStart: 0, rangeEnd: 0 };
          let p2, f2;
          if (((e3) => {
            let { parser: t3 } = e3;
            return t3 === "json" || t3 === "json5" || t3 === "json-stringify";
          })(t2)) {
            const e3 = function(e4, t3) {
              const n3 = [e4.node, ...e4.parentNodes], r3 = /* @__PURE__ */ new Set([t3.node, ...t3.parentNodes]);
              return n3.find((e5) => AD.has(e5.type) && r3.has(e5));
            }(c2, l2);
            p2 = e3, f2 = e3;
          } else
            ({ startNode: p2, endNode: f2 } = function(e3, t3, n3) {
              let { locStart: r3, locEnd: o3 } = n3, i3 = e3.node, u3 = t3.node;
              if (i3 === u3)
                return { startNode: i3, endNode: u3 };
              const s3 = r3(e3.node);
              for (const e4 of bD(t3.parentNodes)) {
                if (!(r3(e4) >= s3))
                  break;
                u3 = e4;
              }
              const a3 = o3(t3.node);
              for (const t4 of bD(e3.parentNodes)) {
                if (!(o3(t4) <= a3))
                  break;
                i3 = t4;
              }
              return { startNode: i3, endNode: u3 };
            }(c2, l2, t2));
          return { rangeStart: Math.min(i2(p2), i2(f2)), rangeEnd: Math.max(u2(p2), u2(f2)) };
        }, findNodeAtOffset: vD };
        const wD = r, { printer: { printDocToString: TD }, debug: { printDocToDebug: BD } } = Zc, { getAlignmentSize: ND } = dc, { guessEndOfLine: kD, convertEndOfLineToChars: PD, countEndOfLineChars: OD, normalizeEndOfLine: ID } = hc, LD = Bm.normalize, jD = Nm, _D = tD, MD = Dm, RD = DD, VD = SD, $D = Symbol("cursor");
        function WD(e2, t2, n2) {
          const r2 = t2.comments;
          return r2 && (delete t2.comments, _D.attach(r2, t2, e2, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e2, r2;
        }
        function qD(e2, t2) {
          let n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (!e2 || e2.trim().length === 0)
            return { formatted: "", cursorOffset: -1, comments: [] };
          const { ast: r2, text: o2 } = MD.parse(e2, t2);
          if (t2.cursorOffset >= 0) {
            const e3 = VD.findNodeAtOffset(r2, t2.cursorOffset, t2);
            e3 && e3.node && (t2.cursorNode = e3.node);
          }
          const i2 = WD(o2, r2, t2), u2 = RD(r2, t2, n2), s2 = TD(u2, t2);
          if (_D.ensureAllCommentsPrinted(i2), n2 > 0) {
            const e3 = s2.formatted.trim();
            s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e3)), s2.formatted = e3 + PD(t2.endOfLine);
          }
          if (t2.cursorOffset >= 0) {
            let e3, n3, r3, u3, a2;
            if (t2.cursorNode && s2.cursorNodeText ? (e3 = t2.locStart(t2.cursorNode), n3 = o2.slice(e3, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e3, u3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e3 = 0, n3 = o2, r3 = t2.cursorOffset, u3 = 0, a2 = s2.formatted), n3 === a2)
              return { formatted: s2.formatted, cursorOffset: u3 + r3, comments: i2 };
            const c2 = [...n3];
            c2.splice(r3, 0, $D);
            const l2 = [...a2], p2 = wD.diffArrays(c2, l2);
            let f2 = u3;
            for (const e4 of p2)
              if (e4.removed) {
                if (e4.value.includes($D))
                  break;
              } else
                f2 += e4.count;
            return { formatted: s2.formatted, cursorOffset: f2, comments: i2 };
          }
          return { formatted: s2.formatted, cursorOffset: -1, comments: i2 };
        }
        function UD(e2, t2, n2) {
          return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e2.length ? n2 : t2;
        }
        function zD(e2, t2) {
          let { cursorOffset: n2, rangeStart: r2, rangeEnd: o2 } = t2;
          return n2 = UD(e2, n2, -1), r2 = UD(e2, r2, 0), o2 = UD(e2, o2, e2.length), Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: o2 });
        }
        function GD(e2, t2) {
          let { cursorOffset: n2, rangeStart: r2, rangeEnd: o2, endOfLine: i2 } = zD(e2, t2);
          const u2 = e2.charAt(0) === "\uFEFF";
          if (u2 && (e2 = e2.slice(1), n2--, r2--, o2--), i2 === "auto" && (i2 = kD(e2)), e2.includes("\r")) {
            const t3 = (t4) => OD(e2.slice(0, Math.max(t4, 0)), "\r\n");
            n2 -= t3(n2), r2 -= t3(r2), o2 -= t3(o2), e2 = ID(e2);
          }
          return { hasBOM: u2, text: e2, options: zD(e2, Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: o2, endOfLine: i2 })) };
        }
        function HD(e2, t2) {
          const n2 = MD.resolveParser(t2);
          return !n2.hasPragma || n2.hasPragma(e2);
        }
        function JD(e2, t2) {
          let n2, { hasBOM: r2, text: o2, options: i2 } = GD(e2, LD(t2));
          return i2.rangeStart >= i2.rangeEnd && o2 !== "" || i2.requirePragma && !HD(o2, i2) ? { formatted: e2, cursorOffset: t2.cursorOffset, comments: [] } : (i2.rangeStart > 0 || i2.rangeEnd < o2.length ? n2 = function(e3, t3) {
            const { ast: n3, text: r3 } = MD.parse(e3, t3), { rangeStart: o3, rangeEnd: i3 } = VD.calculateRange(r3, t3, n3), u2 = r3.slice(o3, i3), s2 = Math.min(o3, r3.lastIndexOf("\n", o3) + 1), a2 = r3.slice(s2, o3).match(/^\s*/)[0], c2 = ND(a2, t3.tabWidth), l2 = qD(u2, Object.assign(Object.assign({}, t3), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t3.cursorOffset > o3 && t3.cursorOffset <= i3 ? t3.cursorOffset - o3 : -1, endOfLine: "lf" }), c2), p2 = l2.formatted.trimEnd();
            let { cursorOffset: f2 } = t3;
            f2 > i3 ? f2 += p2.length - u2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + o3);
            let d2 = r3.slice(0, o3) + p2 + r3.slice(i3);
            if (t3.endOfLine !== "lf") {
              const e4 = PD(t3.endOfLine);
              f2 >= 0 && e4 === "\r\n" && (f2 += OD(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e4);
            }
            return { formatted: d2, cursorOffset: f2, comments: l2.comments };
          }(o2, i2) : (!i2.requirePragma && i2.insertPragma && i2.printer.insertPragma && !HD(o2, i2) && (o2 = i2.printer.insertPragma(o2)), n2 = qD(o2, i2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
        }
        var XD = { formatWithCursor: JD, parse(e2, t2, n2) {
          const { text: r2, options: o2 } = GD(e2, LD(t2)), i2 = MD.parse(r2, o2);
          return n2 && (i2.ast = jD(i2.ast, o2)), i2;
        }, formatAST(e2, t2) {
          t2 = LD(t2);
          const n2 = RD(e2, t2);
          return TD(n2, t2);
        }, formatDoc: (e2, t2) => JD(BD(e2), Object.assign(Object.assign({}, t2), {}, { parser: "__js_expression" })).formatted, printToDoc(e2, t2) {
          t2 = LD(t2);
          const { ast: n2, text: r2 } = MD.parse(e2, t2);
          return WD(r2, n2, t2), RD(n2, t2);
        }, printDocToString: (e2, t2) => TD(e2, LD(t2)) };
        const { getMaxContinuousCount: YD, getStringWidth: KD, getAlignmentSize: QD, getIndentSize: ZD, skip: eE, skipWhitespace: tE, skipSpaces: nE, skipNewline: rE, skipToLineEnd: oE, skipEverythingButNewLine: iE, skipInlineComment: uE, skipTrailingComment: sE, hasNewline: aE, hasNewlineInRange: cE, hasSpaces: lE, isNextLineEmpty: pE, isNextLineEmptyAfterIndex: fE, isPreviousLineEmpty: dE, getNextNonSpaceNonCommentCharacterIndex: hE, makeString: gE, addLeadingComment: mE, addDanglingComment: yE, addTrailingComment: DE } = dc;
        var EE = { getMaxContinuousCount: YD, getStringWidth: KD, getAlignmentSize: QD, getIndentSize: ZD, skip: eE, skipWhitespace: tE, skipSpaces: nE, skipNewline: rE, skipToLineEnd: oE, skipEverythingButNewLine: iE, skipInlineComment: uE, skipTrailingComment: sE, hasNewline: aE, hasNewlineInRange: cE, hasSpaces: lE, isNextLineEmpty: pE, isNextLineEmptyAfterIndex: fE, isPreviousLineEmpty: dE, getNextNonSpaceNonCommentCharacterIndex: hE, makeString: gE, addLeadingComment: mE, addDanglingComment: yE, addTrailingComment: DE };
        const CE = ["languageId"];
        var bE = function(e2, t2) {
          const { languageId: n2 } = e2, r2 = cu(e2, CE);
          return Object.assign(Object.assign({ linguistLanguageId: n2 }, r2), t2(e2));
        }, vE = {}, AE = { exports: {} };
        !function() {
          function e2(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function t2(e3) {
            switch (e3.type) {
              case "IfStatement":
                return e3.alternate != null ? e3.alternate : e3.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return e3.body;
            }
            return null;
          }
          AE.exports = { isExpression: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "ArrayExpression":
              case "AssignmentExpression":
              case "BinaryExpression":
              case "CallExpression":
              case "ConditionalExpression":
              case "FunctionExpression":
              case "Identifier":
              case "Literal":
              case "LogicalExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ObjectExpression":
              case "SequenceExpression":
              case "ThisExpression":
              case "UnaryExpression":
              case "UpdateExpression":
                return true;
            }
            return false;
          }, isStatement: e2, isIterationStatement: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "DoWhileStatement":
              case "ForInStatement":
              case "ForStatement":
              case "WhileStatement":
                return true;
            }
            return false;
          }, isSourceElement: function(t3) {
            return e2(t3) || t3 != null && t3.type === "FunctionDeclaration";
          }, isProblematicIfStatement: function(e3) {
            var n2;
            if (e3.type !== "IfStatement")
              return false;
            if (e3.alternate == null)
              return false;
            n2 = e3.consequent;
            do {
              if (n2.type === "IfStatement" && n2.alternate == null)
                return true;
              n2 = t2(n2);
            } while (n2);
            return false;
          }, trailingStatement: t2 };
        }();
        var FE = { exports: {} };
        !function() {
          var e2, t2, n2, r2, o2, i2;
          function u2(e3) {
            return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
          }
          for (t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, e2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, n2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], r2 = new Array(128), i2 = 0; i2 < 128; ++i2)
            r2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
          for (o2 = new Array(128), i2 = 0; i2 < 128; ++i2)
            o2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
          FE.exports = { isDecimalDigit: function(e3) {
            return 48 <= e3 && e3 <= 57;
          }, isHexDigit: function(e3) {
            return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
          }, isOctalDigit: function(e3) {
            return e3 >= 48 && e3 <= 55;
          }, isWhiteSpace: function(e3) {
            return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && n2.indexOf(e3) >= 0;
          }, isLineTerminator: function(e3) {
            return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
          }, isIdentifierStartES5: function(e3) {
            return e3 < 128 ? r2[e3] : t2.NonAsciiIdentifierStart.test(u2(e3));
          }, isIdentifierPartES5: function(e3) {
            return e3 < 128 ? o2[e3] : t2.NonAsciiIdentifierPart.test(u2(e3));
          }, isIdentifierStartES6: function(t3) {
            return t3 < 128 ? r2[t3] : e2.NonAsciiIdentifierStart.test(u2(t3));
          }, isIdentifierPartES6: function(t3) {
            return t3 < 128 ? o2[t3] : e2.NonAsciiIdentifierPart.test(u2(t3));
          } };
        }();
        var xE = { exports: {} };
        !function() {
          var e2 = FE.exports;
          function t2(e3, t3) {
            return !(!t3 && e3 === "yield") && n2(e3, t3);
          }
          function n2(e3, t3) {
            if (t3 && function(e4) {
              switch (e4) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(e3))
              return true;
            switch (e3.length) {
              case 2:
                return e3 === "if" || e3 === "in" || e3 === "do";
              case 3:
                return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
              case 4:
                return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
              case 5:
                return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
              case 6:
                return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
              case 7:
                return e3 === "default" || e3 === "finally" || e3 === "extends";
              case 8:
                return e3 === "function" || e3 === "continue" || e3 === "debugger";
              case 10:
                return e3 === "instanceof";
              default:
                return false;
            }
          }
          function r2(e3, n3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || t2(e3, n3);
          }
          function o2(e3, t3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || n2(e3, t3);
          }
          function i2(t3) {
            var n3, r3, o3;
            if (t3.length === 0)
              return false;
            if (o3 = t3.charCodeAt(0), !e2.isIdentifierStartES5(o3))
              return false;
            for (n3 = 1, r3 = t3.length; n3 < r3; ++n3)
              if (o3 = t3.charCodeAt(n3), !e2.isIdentifierPartES5(o3))
                return false;
            return true;
          }
          function u2(t3) {
            var n3, r3, o3, i3, u3;
            if (t3.length === 0)
              return false;
            for (u3 = e2.isIdentifierStartES6, n3 = 0, r3 = t3.length; n3 < r3; ++n3) {
              if (55296 <= (o3 = t3.charCodeAt(n3)) && o3 <= 56319) {
                if (++n3 >= r3)
                  return false;
                if (!(56320 <= (i3 = t3.charCodeAt(n3)) && i3 <= 57343))
                  return false;
                o3 = 1024 * (o3 - 55296) + (i3 - 56320) + 65536;
              }
              if (!u3(o3))
                return false;
              u3 = e2.isIdentifierPartES6;
            }
            return true;
          }
          xE.exports = { isKeywordES5: t2, isKeywordES6: n2, isReservedWordES5: r2, isReservedWordES6: o2, isRestrictedWord: function(e3) {
            return e3 === "eval" || e3 === "arguments";
          }, isIdentifierNameES5: i2, isIdentifierNameES6: u2, isIdentifierES5: function(e3, t3) {
            return i2(e3) && !r2(e3, t3);
          }, isIdentifierES6: function(e3, t3) {
            return u2(e3) && !o2(e3, t3);
          } };
        }(), vE.ast = AE.exports, vE.code = FE.exports, vE.keyword = xE.exports;
        const SE = vE.keyword.isIdentifierNameES5, { getLast: wE, hasNewline: TE, skipWhitespace: BE, isNonEmptyArray: NE, isNextLineEmptyAfterIndex: kE, getStringWidth: PE } = dc, { locStart: OE, locEnd: IE, hasSameLocStart: LE } = og, jE = "(?:(?=.)\\s)", _E = new RegExp("^".concat(jE, "*:")), ME = new RegExp("^".concat(jE, "*::"));
        function RE(e2) {
          return e2.type === "Block" || e2.type === "CommentBlock" || e2.type === "MultiLine";
        }
        function VE(e2) {
          return e2.type === "Line" || e2.type === "CommentLine" || e2.type === "SingleLine" || e2.type === "HashbangComment" || e2.type === "HTMLOpen" || e2.type === "HTMLClose";
        }
        const $E = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
        function WE(e2) {
          return e2 && $E.has(e2.type);
        }
        function qE(e2) {
          return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
        }
        function UE(e2) {
          return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
        }
        function zE(e2) {
          return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
        }
        function GE(e2) {
          return ZE(e2) && e2.callee.type === "Identifier" && (e2.callee.name === "async" || e2.callee.name === "inject" || e2.callee.name === "fakeAsync");
        }
        function HE(e2) {
          return e2.type === "JSXElement" || e2.type === "JSXFragment";
        }
        function JE(e2) {
          return e2.kind === "get" || e2.kind === "set";
        }
        function XE(e2) {
          return JE(e2) || LE(e2, e2.value);
        }
        const YE = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
        const KE = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
        const QE = /^(?:skip|[fx]?(?:it|describe|test))$/;
        function ZE(e2) {
          return e2 && (e2.type === "CallExpression" || e2.type === "OptionalCallExpression");
        }
        function eC(e2) {
          return e2 && (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression");
        }
        function tC(e2) {
          return /^(?:\d+|\d+\.\d+)$/.test(e2);
        }
        function nC(e2) {
          return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
        }
        function rC(e2) {
          return e2.extra ? e2.extra.raw : e2.raw;
        }
        const oC = { "==": true, "!=": true, "===": true, "!==": true }, iC = { "*": true, "/": true, "%": true }, uC = { ">>": true, ">>>": true, "<<": true };
        const sC = {};
        for (const [e2, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
          for (const n2 of t2)
            sC[n2] = e2;
        function aC(e2) {
          return sC[e2];
        }
        const cC = /* @__PURE__ */ new WeakMap();
        function lC(e2) {
          if (cC.has(e2))
            return cC.get(e2);
          const t2 = [];
          return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), cC.set(e2, t2), t2;
        }
        const pC = /* @__PURE__ */ new WeakMap();
        function fC(e2) {
          if (pC.has(e2))
            return pC.get(e2);
          let t2 = e2.arguments;
          return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes)), pC.set(e2, t2), t2;
        }
        function dC(e2) {
          return e2.value.trim() === "prettier-ignore" && !e2.unignore;
        }
        function hC(e2) {
          return e2 && (e2.prettierIgnore || yC(e2, gC.PrettierIgnore));
        }
        const gC = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, mC = (e2, t2) => {
          if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
            return (n2, r2, o2) => !(e2 & gC.Leading && !n2.leading || e2 & gC.Trailing && !n2.trailing || e2 & gC.Dangling && (n2.leading || n2.trailing) || e2 & gC.Block && !RE(n2) || e2 & gC.Line && !VE(n2) || e2 & gC.First && r2 !== 0 || e2 & gC.Last && r2 !== o2.length - 1 || e2 & gC.PrettierIgnore && !dC(n2) || t2 && !t2(n2));
        };
        function yC(e2, t2, n2) {
          if (!e2 || !NE(e2.comments))
            return false;
          const r2 = mC(t2, n2);
          return !r2 || e2.comments.some(r2);
        }
        function DC(e2, t2, n2) {
          if (!e2 || !Array.isArray(e2.comments))
            return [];
          const r2 = mC(t2, n2);
          return r2 ? e2.comments.filter(r2) : e2.comments;
        }
        function EC(e2) {
          return ZE(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
        }
        var CC = { getFunctionParameters: lC, iterateFunctionParametersPath: function(e2, t2) {
          const n2 = e2.getValue();
          let r2 = 0;
          const o2 = (e3) => t2(e3, r2++);
          n2.this && e2.call(o2, "this"), Array.isArray(n2.parameters) ? e2.each(o2, "parameters") : Array.isArray(n2.params) && e2.each(o2, "params"), n2.rest && e2.call(o2, "rest");
        }, getCallArguments: fC, iterateCallArgumentsPath: function(e2, t2) {
          const n2 = e2.getValue();
          n2.type === "ImportExpression" ? (e2.call((e3) => t2(e3, 0), "source"), n2.attributes && e2.call((e3) => t2(e3, 1), "attributes")) : e2.each(t2, "arguments");
        }, hasRestParameter: function(e2) {
          if (e2.rest)
            return true;
          const t2 = lC(e2);
          return t2.length > 0 && wE(t2).type === "RestElement";
        }, getLeftSide: function(e2) {
          return e2.expressions ? e2.expressions[0] : e2.left || e2.test || e2.callee || e2.object || e2.tag || e2.argument || e2.expression;
        }, getLeftSidePathName: function(e2, t2) {
          if (t2.expressions)
            return ["expressions", 0];
          if (t2.left)
            return ["left"];
          if (t2.test)
            return ["test"];
          if (t2.object)
            return ["object"];
          if (t2.callee)
            return ["callee"];
          if (t2.tag)
            return ["tag"];
          if (t2.argument)
            return ["argument"];
          if (t2.expression)
            return ["expression"];
          throw new Error("Unexpected node has no left side.");
        }, getParentExportDeclaration: function(e2) {
          const t2 = e2.getParentNode();
          return e2.getName() === "declaration" && WE(t2) ? t2 : null;
        }, getTypeScriptMappedTypeModifier: function(e2, t2) {
          return e2 === "+" ? "+" + t2 : e2 === "-" ? "-" + t2 : t2;
        }, hasFlowAnnotationComment: function(e2) {
          return NE(e2) && RE(e2[0]) && ME.test(e2[0].value);
        }, hasFlowShorthandAnnotationComment: function(e2) {
          return e2.extra && e2.extra.parenthesized && NE(e2.trailingComments) && RE(e2.trailingComments[0]) && _E.test(e2.trailingComments[0].value);
        }, hasLeadingOwnLineComment: function(e2, t2) {
          return HE(t2) ? hC(t2) : yC(t2, gC.Leading, (t3) => TE(e2, IE(t3)));
        }, hasNakedLeftSide: function(e2) {
          return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || ZE(e2) || eC(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
        }, hasNode: function e2(t2, n2) {
          if (!t2 || typeof t2 != "object")
            return false;
          if (Array.isArray(t2))
            return t2.some((t3) => e2(t3, n2));
          const r2 = n2(t2);
          return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, n2));
        }, hasIgnoreComment: function(e2) {
          return hC(e2.getValue());
        }, hasNodeIgnoreComment: hC, identity: function(e2) {
          return e2;
        }, isBinaryish: function(e2) {
          return YE.has(e2.type);
        }, isBlockComment: RE, isCallLikeExpression: EC, isEnabledHackPipeline: function(e2) {
          return Boolean(e2.__isUsingHackPipeline);
        }, isLineComment: VE, isPrettierIgnoreComment: dC, isCallExpression: ZE, isMemberExpression: eC, isExportDeclaration: WE, isFlowAnnotationComment: function(e2, t2) {
          const n2 = OE(t2), r2 = BE(e2, IE(t2));
          return r2 !== false && e2.slice(n2, n2 + 2) === "/*" && e2.slice(r2, r2 + 2) === "*/";
        }, isFunctionCompositionArgs: function(e2) {
          if (e2.length <= 1)
            return false;
          let t2 = 0;
          for (const n2 of e2)
            if (zE(n2)) {
              if (t2 += 1, t2 > 1)
                return true;
            } else if (ZE(n2)) {
              for (const e3 of n2.arguments)
                if (zE(e3))
                  return true;
            }
          return false;
        }, isFunctionNotation: XE, isFunctionOrArrowExpression: zE, isGetterOrSetter: JE, isJestEachTemplateLiteral: function(e2, t2) {
          const n2 = /^[fx]?(?:describe|it|test)$/;
          return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
        }, isJsxNode: HE, isLiteral: function(e2) {
          return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
        }, isLongCurriedCallExpression: function(e2) {
          const t2 = e2.getValue(), n2 = e2.getParentNode();
          return ZE(t2) && ZE(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
        }, isSimpleCallArgument: function e2(t2, n2) {
          if (n2 >= 2)
            return false;
          const r2 = (t3) => e2(t3, n2 + 1), o2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
          return !(o2 && PE(o2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e3) => !e3.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e3) => e3 === null || r2(e3)) : EC(t2) ? (t2.type === "ImportExpression" || e2(t2.callee, n2)) && fC(t2).every(r2) : eC(t2) ? e2(t2.object, n2) && e2(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e2(t2.expression, n2) : e2(t2.argument, n2)));
        }, isMemberish: function(e2) {
          return eC(e2) || e2.type === "BindExpression" && Boolean(e2.object);
        }, isNumericLiteral: qE, isSignedNumericLiteral: function(e2) {
          return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && qE(e2.argument);
        }, isObjectProperty: function(e2) {
          return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !e2.method && e2.kind === "init");
        }, isObjectType: function(e2) {
          return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral" || e2.type === "TSMappedType";
        }, isObjectTypePropertyAFunction: function(e2) {
          return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || XE(e2));
        }, isSimpleType: function(e2) {
          return !!e2 && (!(e2.type !== "GenericTypeAnnotation" && e2.type !== "TSTypeReference" || e2.typeParameters) || !!KE.has(e2.type));
        }, isSimpleNumber: tC, isSimpleTemplateLiteral: function(e2) {
          let t2 = "expressions";
          e2.type === "TSTemplateLiteralType" && (t2 = "types");
          const n2 = e2[t2];
          return n2.length !== 0 && n2.every((e3) => {
            if (yC(e3))
              return false;
            if (e3.type === "Identifier" || e3.type === "ThisExpression")
              return true;
            if (eC(e3)) {
              let t3 = e3;
              for (; eC(t3); ) {
                if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
                  return false;
                if (t3 = t3.object, yC(t3))
                  return false;
              }
              return t3.type === "Identifier" || t3.type === "ThisExpression";
            }
            return false;
          });
        }, isStringLiteral: UE, isStringPropSafeToUnquote: function(e2, t2) {
          return t2.parser !== "json" && UE(e2.key) && rC(e2.key).slice(1, -1) === e2.key.value && (SE(e2.key.value) && !(t2.parser === "babel-ts" && e2.type === "ClassProperty" || t2.parser === "typescript" && e2.type === "PropertyDefinition") || tC(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
        }, isTemplateOnItsOwnLine: function(e2, t2) {
          return (e2.type === "TemplateLiteral" && nC(e2) || e2.type === "TaggedTemplateExpression" && nC(e2.quasi)) && !TE(t2, OE(e2), { backwards: true });
        }, isTestCall: function e2(t2, n2) {
          if (t2.type !== "CallExpression")
            return false;
          if (t2.arguments.length === 1) {
            if (GE(t2) && n2 && e2(n2))
              return zE(t2.arguments[0]);
            if (function(e3) {
              return e3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e3.callee.name) && e3.arguments.length === 1;
            }(t2))
              return GE(t2.arguments[0]);
          } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && QE.test(t2.callee.name) || function(e3) {
            return eC(e3.callee) && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && QE.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
          }(t2)) && (function(e3) {
            return e3.type === "TemplateLiteral";
          }(t2.arguments[0]) || UE(t2.arguments[0])))
            return !(t2.arguments[2] && !qE(t2.arguments[2])) && ((t2.arguments.length === 2 ? zE(t2.arguments[1]) : function(e3) {
              return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
            }(t2.arguments[1]) && lC(t2.arguments[1]).length <= 1) || GE(t2.arguments[1]));
          return false;
        }, isTheOnlyJsxElementInMarkdown: function(e2, t2) {
          if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
            return false;
          const n2 = t2.getNode();
          if (!n2.expression || !HE(n2.expression))
            return false;
          const r2 = t2.getParentNode();
          return r2.type === "Program" && r2.body.length === 1;
        }, isTSXFile: function(e2) {
          return e2.filepath && /\.tsx$/i.test(e2.filepath);
        }, isTypeAnnotationAFunction: function(e2) {
          return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || LE(e2, e2.typeAnnotation));
        }, isNextLineEmpty: (e2, t2) => {
          let { originalText: n2 } = t2;
          return kE(n2, IE(e2));
        }, needsHardlineAfterDanglingComment: function(e2) {
          if (!yC(e2))
            return false;
          const t2 = wE(DC(e2, gC.Dangling));
          return t2 && !RE(t2);
        }, rawText: rC, shouldPrintComma: function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
          return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
        }, isBitwiseOperator: function(e2) {
          return Boolean(uC[e2]) || e2 === "|" || e2 === "^" || e2 === "&";
        }, shouldFlatten: function(e2, t2) {
          return aC(t2) === aC(e2) && (e2 !== "**" && ((!oC[e2] || !oC[t2]) && (!(t2 === "%" && iC[e2] || e2 === "%" && iC[t2]) && ((t2 === e2 || !iC[t2] || !iC[e2]) && (!uC[e2] || !uC[t2])))));
        }, startsWithNoLookaheadToken: function e2(t2, n2) {
          switch ((t2 = function(e3) {
            for (; e3.left; )
              e3 = e3.left;
            return e3;
          }(t2)).type) {
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
              return n2;
            case "ObjectExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return e2(t2.object, n2);
            case "TaggedTemplateExpression":
              return t2.tag.type !== "FunctionExpression" && e2(t2.tag, n2);
            case "CallExpression":
            case "OptionalCallExpression":
              return t2.callee.type !== "FunctionExpression" && e2(t2.callee, n2);
            case "ConditionalExpression":
              return e2(t2.test, n2);
            case "UpdateExpression":
              return !t2.prefix && e2(t2.argument, n2);
            case "BindExpression":
              return t2.object && e2(t2.object, n2);
            case "SequenceExpression":
              return e2(t2.expressions[0], n2);
            case "TSAsExpression":
            case "TSNonNullExpression":
              return e2(t2.expression, n2);
            default:
              return false;
          }
        }, getPrecedence: aC, hasComment: yC, getComments: DC, CommentCheckFlags: gC };
        const bC = au, { getStringWidth: vC, getIndentSize: AC } = dc, { builders: { join: FC, hardline: xC, softline: SC, group: wC, indent: TC, align: BC, lineSuffixBoundary: NC, addAlignmentToDoc: kC }, printer: { printDocToString: PC }, utils: { mapDoc: OC } } = Zc, { isBinaryish: IC, isJestEachTemplateLiteral: LC, isSimpleTemplateLiteral: jC, hasComment: _C, isMemberExpression: MC } = CC;
        function RC(e2) {
          return e2.replace(/([\\`]|\${)/g, "\\$1");
        }
        var VC = { printTemplateLiteral: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (r2.type === "TemplateLiteral" && LC(r2, e2.getParentNode())) {
            const r3 = function(e3, t3, n3) {
              const r4 = e3.getNode(), o3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (o3.length > 1 || o3.some((e4) => e4.length > 0)) {
                t3.__inJestEach = true;
                const i3 = e3.map(n3, "expressions");
                t3.__inJestEach = false;
                const u3 = [], s3 = i3.map((e4) => "${" + PC(e4, Object.assign(Object.assign({}, t3), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), a2 = [{ hasLineBreak: false, cells: [] }];
                for (let e4 = 1; e4 < r4.quasis.length; e4++) {
                  const t4 = bC(a2), n4 = s3[e4 - 1];
                  t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e4].value.raw.includes("\n") && a2.push({ hasLineBreak: false, cells: [] });
                }
                const c2 = Math.max(o3.length, ...a2.map((e4) => e4.cells.length)), l2 = Array.from({ length: c2 }).fill(0), p2 = [{ cells: o3 }, ...a2.filter((e4) => e4.cells.length > 0)];
                for (const { cells: e4 } of p2.filter((e5) => !e5.hasLineBreak))
                  for (const [t4, n4] of e4.entries())
                    l2[t4] = Math.max(l2[t4], vC(n4));
                return u3.push(NC, "`", TC([xC, FC(xC, p2.map((e4) => FC(" | ", e4.cells.map((t4, n4) => e4.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - vC(t4))))))]), xC, "`"), u3;
              }
            }(e2, n2, t2);
            if (r3)
              return r3;
          }
          let o2 = "expressions";
          r2.type === "TSTemplateLiteralType" && (o2 = "types");
          const i2 = [];
          let u2 = e2.map(t2, o2);
          const s2 = jC(r2);
          return s2 && (u2 = u2.map((e3) => PC(e3, Object.assign(Object.assign({}, n2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), i2.push(NC, "`"), e2.each((e3) => {
            const a2 = e3.getName();
            if (i2.push(t2()), a2 < u2.length) {
              const { tabWidth: t3 } = n2, c2 = e3.getValue(), l2 = AC(c2.value.raw, t3);
              let p2 = u2[a2];
              if (!s2) {
                const e4 = r2[o2][a2];
                (_C(e4) || MC(e4) || e4.type === "ConditionalExpression" || e4.type === "SequenceExpression" || e4.type === "TSAsExpression" || IC(e4)) && (p2 = [TC([SC, p2]), SC]);
              }
              const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? BC(Number.NEGATIVE_INFINITY, p2) : kC(p2, l2, t3);
              i2.push(wC(["${", f2, NC, "}"]));
            }
          }, "quasis"), i2.push("`"), i2;
        }, printTemplateExpressions: function(e2, t2) {
          return e2.map((e3) => function(e4, t3) {
            const n2 = e4.getValue();
            let r2 = t3();
            return _C(n2) && (r2 = wC([TC([SC, r2]), SC])), ["${", r2, NC, "}"];
          }(e3, t2), "expressions");
        }, escapeTemplateCharacters: function(e2, t2) {
          return OC(e2, (e3) => typeof e3 == "string" ? t2 ? e3.replace(/(\\*)`/g, "$1$1\\`") : RC(e3) : e3);
        }, uncookTemplateElementValue: RC };
        const { builders: { indent: $C, softline: WC, literalline: qC, dedentToRoot: UC } } = Zc, { escapeTemplateCharacters: zC } = VC;
        var GC = function(e2, t2, n2) {
          let r2 = e2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e3, t3) => "\\".repeat(t3.length / 2) + "`");
          const o2 = function(e3) {
            const t3 = e3.match(/^([^\S\n]*)\S/m);
            return t3 === null ? "" : t3[1];
          }(r2), i2 = o2 !== "";
          i2 && (r2 = r2.replace(new RegExp("^".concat(o2), "gm"), ""));
          const u2 = zC(n2(r2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
          return ["`", i2 ? $C([WC, u2]) : [qC, UC(u2)], WC, "`"];
        };
        const { isNonEmptyArray: HC } = dc, { builders: { indent: JC, hardline: XC, softline: YC }, utils: { mapDoc: KC, replaceEndOfLine: QC, cleanDoc: ZC } } = Zc, { printTemplateExpressions: eb } = VC;
        var tb = function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.quasis.map((e3) => e3.value.raw);
          let i2 = 0;
          return function(e3, t3, n3) {
            if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
              return "``";
            const r3 = function(e4, t4) {
              if (!HC(t4))
                return e4;
              let n4 = 0;
              const r4 = KC(ZC(e4), (e5) => typeof e5 == "string" && e5.includes("@prettier-placeholder") ? e5.split(/@prettier-placeholder-(\d+)-id/).map((e6, r5) => r5 % 2 == 0 ? QC(e6) : (n4++, t4[e6])) : e5);
              return t4.length === n4 ? r4 : null;
            }(e3, n3);
            if (!r3)
              throw new Error("Couldn't insert all the expressions");
            return ["`", JC([XC, r3]), YC, "`"];
          }(n2(o2.reduce((e3, t3, n3) => n3 === 0 ? t3 : e3 + "@prettier-placeholder-" + i2++ + "-id" + t3, ""), { parser: "scss" }, { stripTrailingHardline: true }), r2, eb(e2, t2));
        };
        const { builders: { indent: nb, join: rb, hardline: ob } } = Zc, { escapeTemplateCharacters: ib, printTemplateExpressions: ub } = VC;
        function sb(e2) {
          const t2 = [];
          let n2 = false;
          const r2 = e2.map((e3) => e3.trim());
          for (const [e3, o2] of r2.entries())
            o2 !== "" && (r2[e3 - 1] === "" && n2 ? t2.push([ob, o2]) : t2.push(o2), n2 = true);
          return t2.length === 0 ? null : rb(ob, t2);
        }
        var ab = function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.quasis.length;
          if (o2 === 1 && r2.quasis[0].value.raw.trim() === "")
            return "``";
          const i2 = ub(e2, t2), u2 = [];
          for (let e3 = 0; e3 < o2; e3++) {
            const t3 = e3 === 0, s2 = e3 === o2 - 1, a2 = r2.quasis[e3].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = i2[e3], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e4) => /^\s*(?:#[^\n\r]*)?$/.test(e4));
            if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
              return null;
            let g2 = null;
            g2 = h2 ? sb(c2) : n2(a2, { parser: "graphql" }, { stripTrailingHardline: true }), g2 ? (g2 = ib(g2, false), !t3 && f2 && u2.push(""), u2.push(g2), !s2 && d2 && u2.push("")) : t3 || s2 || !f2 || u2.push(""), p2 && u2.push(p2);
          }
          return ["`", nb([ob, rb(ob, u2)]), ob, "`"];
        };
        const { builders: { indent: cb, line: lb, hardline: pb, group: fb }, utils: { mapDoc: db } } = Zc, { printTemplateExpressions: hb, uncookTemplateElementValue: gb } = VC;
        let mb = 0;
        var yb = function(e2, t2, n2, r2, o2) {
          let { parser: i2 } = o2;
          const u2 = e2.getValue(), s2 = mb;
          mb = mb + 1 >>> 0;
          const a2 = (e3) => "PRETTIER_HTML_PLACEHOLDER_".concat(e3, "_").concat(s2, "_IN_JS"), c2 = u2.quasis.map((e3, t3, n3) => t3 === n3.length - 1 ? e3.value.cooked : e3.value.cooked + a2(t3)).join(""), l2 = hb(e2, t2);
          if (l2.length === 0 && c2.trim().length === 0)
            return "``";
          const p2 = new RegExp(a2("(\\d+)"), "g");
          let f2 = 0;
          const d2 = n2(c2, { parser: i2, __onHtmlRoot(e3) {
            f2 = e3.children.length;
          } }, { stripTrailingHardline: true }), h2 = db(d2, (e3) => {
            if (typeof e3 != "string")
              return e3;
            const t3 = [], n3 = e3.split(p2);
            for (let e4 = 0; e4 < n3.length; e4++) {
              let o3 = n3[e4];
              if (e4 % 2 == 0) {
                o3 && (o3 = gb(o3), r2.__embeddedInHtml && (o3 = o3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(o3));
                continue;
              }
              const i3 = Number(o3);
              t3.push(l2[i3]);
            }
            return t3;
          }), g2 = /^\s/.test(c2) ? " " : "", m2 = /\s$/.test(c2) ? " " : "", y2 = r2.htmlWhitespaceSensitivity === "ignore" ? pb : g2 && m2 ? lb : null;
          return fb(y2 ? ["`", cb([y2, fb(h2)]), y2, "`"] : ["`", g2, f2 > 1 ? cb(fb(h2)) : fb(h2), m2, "`"]);
        };
        const { hasComment: Db, CommentCheckFlags: Eb, isObjectProperty: Cb } = CC, bb = GC, vb = tb, Ab = ab, Fb = yb;
        function xb(e2) {
          return function(e3) {
            const t2 = e3.getValue(), n2 = e3.getParentNode(), r2 = e3.getParentNode(1);
            return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e4) => e4.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
          }(e2) || function(e3) {
            const t2 = e3.getParentNode();
            if (!t2 || t2.type !== "TaggedTemplateExpression")
              return false;
            const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
            switch (n2.type) {
              case "MemberExpression":
                return wb(n2.object) || Tb(n2);
              case "CallExpression":
                return wb(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (wb(n2.callee.object.object) || Tb(n2.callee.object)) || n2.callee.object.type === "CallExpression" && wb(n2.callee.object.callee));
              case "Identifier":
                return n2.name === "css";
              default:
                return false;
            }
          }(e2) || function(e3) {
            const t2 = e3.getParentNode(), n2 = e3.getParentNode(1);
            return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
          }(e2) || function(e3) {
            return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "ArrayExpression" && t2 === "elements", (e4, t2) => Cb(e4) && e4.key.type === "Identifier" && e4.key.name === "styles" && t2 === "value", ...Sb);
          }(e2) ? "css" : function(e3) {
            const t2 = e3.getValue(), n2 = e3.getParentNode();
            return Bb(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
          }(e2) ? "graphql" : function(e3) {
            return Bb(e3.getValue(), "HTML") || e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "TaggedTemplateExpression" && e4.tag.type === "Identifier" && e4.tag.name === "html" && t2 === "quasi");
          }(e2) ? "html" : function(e3) {
            return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => Cb(e4) && e4.key.type === "Identifier" && e4.key.name === "template" && t2 === "value", ...Sb);
          }(e2) ? "angular" : function(e3) {
            const t2 = e3.getValue(), n2 = e3.getParentNode();
            return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
          }(e2) ? "markdown" : void 0;
        }
        const Sb = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
        function wb(e2) {
          return e2.type === "Identifier" && e2.name === "styled";
        }
        function Tb(e2) {
          return /^[A-Z]/.test(e2.object.name) && e2.property.name === "extend";
        }
        function Bb(e2, t2) {
          return Db(e2, Eb.Block | Eb.Leading, (e3) => {
            let { value: n2 } = e3;
            return n2 === " ".concat(t2, " ");
          });
        }
        var Nb = function(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          if (o2.type !== "TemplateLiteral" || function(e3) {
            let { quasis: t3 } = e3;
            return t3.some((e4) => {
              let { value: { cooked: t4 } } = e4;
              return t4 === null;
            });
          }(o2))
            return;
          const i2 = xb(e2);
          return i2 ? i2 === "markdown" ? bb(e2, t2, n2) : i2 === "css" ? vb(e2, t2, n2) : i2 === "graphql" ? Ab(e2, t2, n2) : i2 === "html" || i2 === "angular" ? Fb(e2, t2, n2, r2, { parser: i2 }) : void 0 : void 0;
        };
        const { isBlockComment: kb } = CC, Pb = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Ob = (e2) => {
          for (const t2 of e2.quasis)
            delete t2.value;
        };
        function Ib(e2, t2, n2) {
          if (e2.type === "Program" && delete t2.sourceType, e2.type !== "BigIntLiteral" && e2.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e2.type !== "BigIntLiteral" && e2.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e2.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e2.type === "EmptyStatement")
            return null;
          if (e2.type === "JSXText")
            return null;
          if (e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
            return null;
          if (e2.type !== "Property" && e2.type !== "ObjectProperty" && e2.type !== "MethodDefinition" && e2.type !== "ClassProperty" && e2.type !== "ClassMethod" && e2.type !== "PropertyDefinition" && e2.type !== "TSDeclareMethod" && e2.type !== "TSPropertySignature" && e2.type !== "ObjectTypeProperty" || typeof e2.key != "object" || !e2.key || e2.key.type !== "Literal" && e2.key.type !== "NumericLiteral" && e2.key.type !== "StringLiteral" && e2.key.type !== "Identifier" || delete t2.key, e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((e3) => e3.name.name === "jsx"))
            for (const { type: e3, expression: n3 } of t2.children)
              e3 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && Ob(n3);
          e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && Ob(t2.value.expression), e2.type === "JSXAttribute" && e2.value && e2.value.type === "Literal" && /["']|&quot;|&apos;/.test(e2.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
          const r2 = e2.expression || e2.callee;
          if (e2.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
            const n3 = e2.expression.arguments[0].properties;
            for (const [e3, r3] of t2.expression.arguments[0].properties.entries())
              switch (n3[e3].key.name) {
                case "styles":
                  r3.value.type === "ArrayExpression" && Ob(r3.value.elements[0]);
                  break;
                case "template":
                  r3.value.type === "TemplateLiteral" && Ob(r3.value);
              }
          }
          if (e2.type !== "TaggedTemplateExpression" || e2.tag.type !== "MemberExpression" && (e2.tag.type !== "Identifier" || e2.tag.name !== "gql" && e2.tag.name !== "graphql" && e2.tag.name !== "css" && e2.tag.name !== "md" && e2.tag.name !== "markdown" && e2.tag.name !== "html") && e2.tag.type !== "CallExpression" || Ob(t2.quasi), e2.type === "TemplateLiteral") {
            const r3 = e2.leadingComments && e2.leadingComments.some((e3) => kb(e3) && ["GraphQL", "HTML"].some((t3) => e3.value === " ".concat(t3, " ")));
            (r3 || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e2.leadingComments) && Ob(t2);
          }
          return e2.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e2.type !== "TSIntersectionType" && e2.type !== "TSUnionType" || e2.types.length !== 1 ? void 0 : t2.types[0];
        }
        Ib.ignoredProperties = Pb;
        var Lb = Ib, jb = {}, _b = { exports: {} };
        const Mb = (e2) => {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          const t2 = e2.match(/(?:\r?\n)/g) || [];
          if (t2.length === 0)
            return;
          const n2 = t2.filter((e3) => e3 === "\r\n").length;
          return n2 > t2.length - n2 ? "\r\n" : "\n";
        };
        function Rb() {
          const e2 = yf;
          return Rb = function() {
            return e2;
          }, e2;
        }
        function Vb() {
          const e2 = function(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }(_b.exports);
          return Vb = function() {
            return e2;
          }, e2;
        }
        _b.exports = Mb, _b.exports.graceful = (e2) => typeof e2 == "string" && Mb(e2) || "\n", Object.defineProperty(jb, "__esModule", { value: true }), jb.extract = function(e2) {
          const t2 = e2.match(qb);
          return t2 ? t2[0].trimLeft() : "";
        }, jb.strip = function(e2) {
          const t2 = e2.match(qb);
          return t2 && t2[0] ? e2.substring(t2[0].length) : e2;
        }, jb.parse = function(e2) {
          return Yb(e2).pragmas;
        }, jb.parseWithComments = Yb, jb.print = function(e2) {
          let { comments: t2 = "", pragmas: n2 = {} } = e2;
          const r2 = (0, Vb().default)(t2) || Rb().EOL, o2 = " *", i2 = Object.keys(n2), u2 = i2.map((e3) => Kb(e3, n2[e3])).reduce((e3, t3) => e3.concat(t3), []).map((e3) => " * " + e3 + r2).join("");
          if (!t2) {
            if (i2.length === 0)
              return "";
            if (i2.length === 1 && !Array.isArray(n2[i2[0]])) {
              const e3 = n2[i2[0]];
              return "".concat("/**", " ").concat(Kb(i2[0], e3)[0]).concat(" */");
            }
          }
          const s2 = t2.split(r2).map((e3) => "".concat(o2, " ").concat(e3)).join(r2) + r2;
          return "/**" + r2 + (t2 ? s2 : "") + (t2 && i2.length ? o2 + r2 : "") + u2 + " */";
        };
        const $b = /\*\/$/, Wb = /^\/\*\*/, qb = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Ub = /(^|\s+)\/\/([^\r\n]*)/g, zb = /^(\r?\n)+/, Gb = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Hb = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, Jb = /(\r?\n|^) *\* ?/g, Xb = [];
        function Yb(e2) {
          const t2 = (0, Vb().default)(e2) || Rb().EOL;
          e2 = e2.replace(Wb, "").replace($b, "").replace(Jb, "$1");
          let n2 = "";
          for (; n2 !== e2; )
            n2 = e2, e2 = e2.replace(Gb, "".concat(t2, "$1 $2").concat(t2));
          e2 = e2.replace(zb, "").trimRight();
          const r2 = /* @__PURE__ */ Object.create(null), o2 = e2.replace(Hb, "").replace(zb, "").trimRight();
          let i2;
          for (; i2 = Hb.exec(e2); ) {
            const e3 = i2[2].replace(Ub, "");
            typeof r2[i2[1]] == "string" || Array.isArray(r2[i2[1]]) ? r2[i2[1]] = Xb.concat(r2[i2[1]], e3) : r2[i2[1]] = e3;
          }
          return { comments: o2, pragmas: r2 };
        }
        function Kb(e2, t2) {
          return Xb.concat(t2).map((t3) => "@".concat(e2, " ").concat(t3).trim());
        }
        const { parseWithComments: Qb, strip: Zb, extract: ev, print: tv } = jb, { getShebang: nv } = dc, { normalizeEndOfLine: rv } = hc;
        function ov(e2) {
          const t2 = nv(e2);
          t2 && (e2 = e2.slice(t2.length + 1));
          const n2 = ev(e2), { pragmas: r2, comments: o2 } = Qb(n2);
          return { shebang: t2, text: e2, pragmas: r2, comments: o2 };
        }
        var iv = { hasPragma: function(e2) {
          const t2 = Object.keys(ov(e2).pragmas);
          return t2.includes("prettier") || t2.includes("format");
        }, insertPragma: function(e2) {
          const { shebang: t2, text: n2, pragmas: r2, comments: o2 } = ov(e2), i2 = Zb(n2), u2 = tv({ pragmas: Object.assign({ format: "" }, r2), comments: o2.trimStart() });
          return (t2 ? "".concat(t2, "\n") : "") + rv(u2) + (i2.startsWith("\n") ? "\n" : "\n\n") + i2;
        } };
        const { getLast: uv, hasNewline: sv, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: av, getNextNonSpaceNonCommentCharacter: cv, hasNewlineInRange: lv, addLeadingComment: pv, addTrailingComment: fv, addDanglingComment: dv, getNextNonSpaceNonCommentCharacterIndex: hv, isNonEmptyArray: gv } = dc, { isBlockComment: mv, getFunctionParameters: yv, isPrettierIgnoreComment: Dv, isJsxNode: Ev, hasFlowShorthandAnnotationComment: Cv, hasFlowAnnotationComment: bv, hasIgnoreComment: vv, isCallLikeExpression: Av, getCallArguments: Fv, isCallExpression: xv, isMemberExpression: Sv, isObjectProperty: wv, getComments: Tv, CommentCheckFlags: Bv } = CC, { locStart: Nv, locEnd: kv } = og;
        function Pv(e2, t2) {
          const n2 = (e2.body || e2.properties).find((e3) => {
            let { type: t3 } = e3;
            return t3 !== "EmptyStatement";
          });
          n2 ? pv(n2, t2) : dv(e2, t2);
        }
        function Ov(e2, t2) {
          e2.type === "BlockStatement" ? Pv(e2, t2) : pv(e2, t2);
        }
        function Iv(e2) {
          let { comment: t2, followingNode: n2 } = e2;
          return !(!n2 || !cA(t2)) && (pv(n2, t2), true);
        }
        function Lv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
          if (!r2 || r2.type !== "IfStatement" || !o2)
            return false;
          return cv(i2, t2, kv) === ")" ? (fv(n2, t2), true) : n2 === r2.consequent && o2 === r2.alternate ? (n2.type === "BlockStatement" ? fv(n2, t2) : dv(r2, t2), true) : o2.type === "BlockStatement" ? (Pv(o2, t2), true) : o2.type === "IfStatement" ? (Ov(o2.consequent, t2), true) : r2.consequent === o2 && (pv(o2, t2), true);
        }
        function jv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
          if (!r2 || r2.type !== "WhileStatement" || !o2)
            return false;
          return cv(i2, t2, kv) === ")" ? (fv(n2, t2), true) : o2.type === "BlockStatement" ? (Pv(o2, t2), true) : r2.body === o2 && (pv(o2, t2), true);
        }
        function _v(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
          return !(!r2 || r2.type !== "TryStatement" && r2.type !== "CatchClause" || !o2) && (r2.type === "CatchClause" && n2 ? (fv(n2, t2), true) : o2.type === "BlockStatement" ? (Pv(o2, t2), true) : o2.type === "TryStatement" ? (Ov(o2.finalizer, t2), true) : o2.type === "CatchClause" && (Ov(o2.body, t2), true));
        }
        function Mv(e2) {
          let { comment: t2, enclosingNode: n2, followingNode: r2 } = e2;
          return !(!Sv(n2) || !r2 || r2.type !== "Identifier") && (pv(n2, t2), true);
        }
        function Rv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
          const u2 = n2 && !lv(i2, kv(n2), Nv(t2));
          return !(n2 && u2 || !r2 || r2.type !== "ConditionalExpression" && r2.type !== "TSConditionalType" || !o2) && (pv(o2, t2), true);
        }
        function Vv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2 } = e2;
          return !(!wv(r2) || !r2.shorthand || r2.key !== n2 || r2.value.type !== "AssignmentPattern") && (fv(r2.value.left, t2), true);
        }
        function $v(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
          if (r2 && (r2.type === "ClassDeclaration" || r2.type === "ClassExpression" || r2.type === "DeclareClass" || r2.type === "DeclareInterface" || r2.type === "InterfaceDeclaration" || r2.type === "TSInterfaceDeclaration")) {
            if (gv(r2.decorators) && (!o2 || o2.type !== "Decorator"))
              return fv(uv(r2.decorators), t2), true;
            if (r2.body && o2 === r2.body)
              return Pv(r2.body, t2), true;
            if (o2) {
              for (const e3 of ["implements", "extends", "mixins"])
                if (r2[e3] && o2 === r2[e3][0])
                  return !n2 || n2 !== r2.id && n2 !== r2.typeParameters && n2 !== r2.superClass ? dv(r2, t2, e3) : fv(n2, t2), true;
            }
          }
          return false;
        }
        function Wv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
          return (r2 && n2 && (r2.type === "Property" || r2.type === "TSDeclareMethod" || r2.type === "TSAbstractMethodDefinition") && n2.type === "Identifier" && r2.key === n2 && cv(o2, n2, kv) !== ":" || !(!n2 || !r2 || n2.type !== "Decorator" || r2.type !== "ClassMethod" && r2.type !== "ClassProperty" && r2.type !== "PropertyDefinition" && r2.type !== "TSAbstractPropertyDefinition" && r2.type !== "TSAbstractMethodDefinition" && r2.type !== "TSDeclareMethod" && r2.type !== "MethodDefinition")) && (fv(n2, t2), true);
        }
        function qv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
          return cv(o2, t2, kv) === "(" && (!(!n2 || !r2 || r2.type !== "FunctionDeclaration" && r2.type !== "FunctionExpression" && r2.type !== "ClassMethod" && r2.type !== "MethodDefinition" && r2.type !== "ObjectMethod") && (fv(n2, t2), true));
        }
        function Uv(e2) {
          let { comment: t2, enclosingNode: n2, text: r2 } = e2;
          if (!n2 || n2.type !== "ArrowFunctionExpression")
            return false;
          const o2 = hv(r2, t2, kv);
          return o2 !== false && r2.slice(o2, o2 + 2) === "=>" && (dv(n2, t2), true);
        }
        function zv(e2) {
          let { comment: t2, enclosingNode: n2, text: r2 } = e2;
          return cv(r2, t2, kv) === ")" && (n2 && (aA(n2) && yv(n2).length === 0 || Av(n2) && Fv(n2).length === 0) ? (dv(n2, t2), true) : !(!n2 || n2.type !== "MethodDefinition" && n2.type !== "TSAbstractMethodDefinition" || yv(n2.value).length !== 0) && (dv(n2.value, t2), true));
        }
        function Gv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2, text: i2 } = e2;
          if (n2 && n2.type === "FunctionTypeParam" && r2 && r2.type === "FunctionTypeAnnotation" && o2 && o2.type !== "FunctionTypeParam")
            return fv(n2, t2), true;
          if (n2 && (n2.type === "Identifier" || n2.type === "AssignmentPattern") && r2 && aA(r2) && cv(i2, t2, kv) === ")")
            return fv(n2, t2), true;
          if (r2 && r2.type === "FunctionDeclaration" && o2 && o2.type === "BlockStatement") {
            const e3 = (() => {
              const e4 = yv(r2);
              if (e4.length > 0)
                return av(i2, kv(uv(e4)));
              const t3 = av(i2, kv(r2.id));
              return t3 !== false && av(i2, t3 + 1);
            })();
            if (Nv(t2) > e3)
              return Pv(o2, t2), true;
          }
          return false;
        }
        function Hv(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "ImportSpecifier") && (pv(n2, t2), true);
        }
        function Jv(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "LabeledStatement") && (pv(n2, t2), true);
        }
        function Xv(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "ContinueStatement" && n2.type !== "BreakStatement" || n2.label) && (fv(n2, t2), true);
        }
        function Yv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2 } = e2;
          return !!(xv(r2) && n2 && r2.callee === n2 && r2.arguments.length > 0) && (pv(r2.arguments[0], t2), true);
        }
        function Kv(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
          return !r2 || r2.type !== "UnionTypeAnnotation" && r2.type !== "TSUnionType" ? (o2 && (o2.type === "UnionTypeAnnotation" || o2.type === "TSUnionType") && Dv(t2) && (o2.types[0].prettierIgnore = true, t2.unignore = true), false) : (Dv(t2) && (o2.prettierIgnore = true, t2.unignore = true), !!n2 && (fv(n2, t2), true));
        }
        function Qv(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !!wv(n2) && (pv(n2, t2), true);
        }
        function Zv(e2) {
          let { comment: t2, enclosingNode: n2, followingNode: r2, ast: o2, isLastComment: i2 } = e2;
          return o2 && o2.body && o2.body.length === 0 ? (i2 ? dv(o2, t2) : pv(o2, t2), true) : n2 && n2.type === "Program" && n2.body.length === 0 && !gv(n2.directives) ? (i2 ? dv(n2, t2) : pv(n2, t2), true) : !(!r2 || r2.type !== "Program" || r2.body.length !== 0 || !n2 || n2.type !== "ModuleExpression") && (dv(r2, t2), true);
        }
        function eA(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "ForInStatement" && n2.type !== "ForOfStatement") && (pv(n2, t2), true);
        }
        function tA(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, text: o2 } = e2;
          return !!(n2 && n2.type === "ImportSpecifier" && r2 && r2.type === "ImportDeclaration" && sv(o2, kv(t2))) && (fv(n2, t2), true);
        }
        function nA(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "AssignmentPattern") && (pv(n2, t2), true);
        }
        function rA(e2) {
          let { comment: t2, enclosingNode: n2 } = e2;
          return !(!n2 || n2.type !== "TypeAlias") && (pv(n2, t2), true);
        }
        function oA(e2) {
          let { comment: t2, enclosingNode: n2, followingNode: r2 } = e2;
          return !(!n2 || n2.type !== "VariableDeclarator" && n2.type !== "AssignmentExpression" || !r2 || r2.type !== "ObjectExpression" && r2.type !== "ArrayExpression" && r2.type !== "TemplateLiteral" && r2.type !== "TaggedTemplateExpression" && !mv(t2)) && (pv(r2, t2), true);
        }
        function iA(e2) {
          let { comment: t2, enclosingNode: n2, followingNode: r2, text: o2 } = e2;
          return !(r2 || !n2 || n2.type !== "TSMethodSignature" && n2.type !== "TSDeclareFunction" && n2.type !== "TSAbstractMethodDefinition" || cv(o2, t2, kv) !== ";") && (fv(n2, t2), true);
        }
        function uA(e2) {
          let { comment: t2, enclosingNode: n2, followingNode: r2 } = e2;
          if (Dv(t2) && n2 && n2.type === "TSMappedType" && r2 && r2.type === "TSTypeParameter" && r2.constraint)
            return n2.prettierIgnore = true, t2.unignore = true, true;
        }
        function sA(e2) {
          let { comment: t2, precedingNode: n2, enclosingNode: r2, followingNode: o2 } = e2;
          return !(!r2 || r2.type !== "TSMappedType") && (o2 && o2.type === "TSTypeParameter" && o2.name ? (pv(o2.name, t2), true) : !(!n2 || n2.type !== "TSTypeParameter" || !n2.constraint) && (fv(n2.constraint, t2), true));
        }
        function aA(e2) {
          return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
        }
        function cA(e2) {
          return mv(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
        }
        var lA = { handleOwnLineComment: function(e2) {
          return [uA, Gv, Mv, Lv, jv, _v, $v, Hv, eA, Kv, Zv, tA, nA, Wv, Jv].some((t2) => t2(e2));
        }, handleEndOfLineComment: function(e2) {
          return [Iv, Gv, Rv, Hv, Lv, jv, _v, $v, Jv, Yv, Qv, Zv, rA, oA].some((t2) => t2(e2));
        }, handleRemainingComment: function(e2) {
          return [uA, Lv, jv, Vv, zv, Wv, Zv, Uv, qv, sA, Xv, iA].some((t2) => t2(e2));
        }, isTypeCastComment: cA, getCommentChildNodes: function(e2, t2) {
          if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && yv(e2.value).length === 0 && !e2.value.returnType && !gv(e2.value.typeParameters) && e2.value.body)
            return [...e2.decorators || [], e2.key, e2.value.body];
        }, willPrintOwnComments: function(e2) {
          const t2 = e2.getValue(), n2 = e2.getParentNode();
          return (t2 && (Ev(t2) || Cv(t2) || xv(n2) && ((e3) => bv(Tv(e3, Bv.Leading)) || bv(Tv(e3, Bv.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!vv(e2) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
        } };
        const pA = au, { getFunctionParameters: fA, getLeftSidePathName: dA, hasFlowShorthandAnnotationComment: hA, hasNakedLeftSide: gA, hasNode: mA, isBitwiseOperator: yA, startsWithNoLookaheadToken: DA, shouldFlatten: EA, getPrecedence: CA, isCallExpression: bA, isMemberExpression: vA, isObjectProperty: AA } = CC;
        function FA(e2, t2) {
          const n2 = e2.getParentNode();
          if (!n2)
            return false;
          const r2 = e2.getName(), o2 = e2.getNode();
          if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e3) {
            if (e3.type === "ObjectExpression")
              return true;
            return false;
          }(o2) && xA(e2))
            return true;
          if (function(e3) {
            return e3.type === "BlockStatement" || e3.type === "BreakStatement" || e3.type === "ClassBody" || e3.type === "ClassDeclaration" || e3.type === "ClassMethod" || e3.type === "ClassProperty" || e3.type === "PropertyDefinition" || e3.type === "ClassPrivateProperty" || e3.type === "ContinueStatement" || e3.type === "DebuggerStatement" || e3.type === "DeclareClass" || e3.type === "DeclareExportAllDeclaration" || e3.type === "DeclareExportDeclaration" || e3.type === "DeclareFunction" || e3.type === "DeclareInterface" || e3.type === "DeclareModule" || e3.type === "DeclareModuleExports" || e3.type === "DeclareVariable" || e3.type === "DoWhileStatement" || e3.type === "EnumDeclaration" || e3.type === "ExportAllDeclaration" || e3.type === "ExportDefaultDeclaration" || e3.type === "ExportNamedDeclaration" || e3.type === "ExpressionStatement" || e3.type === "ForInStatement" || e3.type === "ForOfStatement" || e3.type === "ForStatement" || e3.type === "FunctionDeclaration" || e3.type === "IfStatement" || e3.type === "ImportDeclaration" || e3.type === "InterfaceDeclaration" || e3.type === "LabeledStatement" || e3.type === "MethodDefinition" || e3.type === "ReturnStatement" || e3.type === "SwitchStatement" || e3.type === "ThrowStatement" || e3.type === "TryStatement" || e3.type === "TSDeclareFunction" || e3.type === "TSEnumDeclaration" || e3.type === "TSImportEqualsDeclaration" || e3.type === "TSInterfaceDeclaration" || e3.type === "TSModuleDeclaration" || e3.type === "TSNamespaceExportDeclaration" || e3.type === "TypeAlias" || e3.type === "VariableDeclaration" || e3.type === "WhileStatement" || e3.type === "WithStatement";
          }(o2))
            return false;
          if (t2.parser !== "flow" && hA(e2.getValue()))
            return true;
          if (o2.type === "Identifier")
            return !!(o2.extra && o2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o2.name)) || r2 === "left" && o2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
          switch (n2.type) {
            case "ParenthesizedExpression":
              return false;
            case "ClassDeclaration":
            case "ClassExpression":
              if (r2 === "superClass" && (o2.type === "ArrowFunctionExpression" || o2.type === "AssignmentExpression" || o2.type === "AwaitExpression" || o2.type === "BinaryExpression" || o2.type === "ConditionalExpression" || o2.type === "LogicalExpression" || o2.type === "NewExpression" || o2.type === "ObjectExpression" || o2.type === "ParenthesizedExpression" || o2.type === "SequenceExpression" || o2.type === "TaggedTemplateExpression" || o2.type === "UnaryExpression" || o2.type === "UpdateExpression" || o2.type === "YieldExpression" || o2.type === "TSNonNullExpression"))
                return true;
              break;
            case "ExportDefaultDeclaration":
              return SA(e2, t2) || o2.type === "SequenceExpression";
            case "Decorator":
              if (r2 === "expression") {
                let e3 = false, n3 = false, r3 = o2;
                for (; r3; )
                  switch (r3.type) {
                    case "MemberExpression":
                      n3 = true, r3 = r3.object;
                      break;
                    case "CallExpression":
                      if (n3 || e3)
                        return t2.parser !== "typescript";
                      e3 = true, r3 = r3.callee;
                      break;
                    case "Identifier":
                      return false;
                    case "TaggedTemplateExpression":
                      return t2.parser !== "typescript";
                    default:
                      return true;
                  }
                return true;
              }
              break;
            case "ExpressionStatement":
              if (DA(o2, true))
                return true;
              break;
            case "ArrowFunctionExpression":
              if (r2 === "body" && o2.type !== "SequenceExpression" && DA(o2, false))
                return true;
          }
          switch (o2.type) {
            case "UpdateExpression":
              if (n2.type === "UnaryExpression")
                return o2.prefix && (o2.operator === "++" && n2.operator === "+" || o2.operator === "--" && n2.operator === "-");
            case "UnaryExpression":
              switch (n2.type) {
                case "UnaryExpression":
                  return o2.operator === n2.operator && (o2.operator === "+" || o2.operator === "-");
                case "BindExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return r2 === "object";
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "BinaryExpression":
                  return r2 === "left" && n2.operator === "**";
                default:
                  return false;
              }
            case "BinaryExpression":
              if (n2.type === "UpdateExpression")
                return true;
              if (o2.operator === "in" && function(e3) {
                let t3 = 0, n3 = e3.getValue();
                for (; n3; ) {
                  const r3 = e3.getParentNode(t3++);
                  if (r3 && r3.type === "ForStatement" && r3.init === n3)
                    return true;
                  n3 = r3;
                }
                return false;
              }(e2))
                return true;
              if (o2.operator === "|>" && o2.extra && o2.extra.parenthesized) {
                const t3 = e2.getParentNode(1);
                if (t3.type === "BinaryExpression" && t3.operator === "|>")
                  return true;
              }
            case "TSTypeAssertion":
            case "TSAsExpression":
            case "LogicalExpression":
              switch (n2.type) {
                case "TSAsExpression":
                  return o2.type !== "TSAsExpression";
                case "ConditionalExpression":
                  return o2.type === "TSAsExpression";
                case "CallExpression":
                case "NewExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "ClassExpression":
                case "ClassDeclaration":
                  return r2 === "superClass";
                case "TSTypeAssertion":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "JSXSpreadAttribute":
                case "SpreadElement":
                case "SpreadProperty":
                case "BindExpression":
                case "AwaitExpression":
                case "TSNonNullExpression":
                case "UpdateExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return r2 === "object";
                case "AssignmentExpression":
                case "AssignmentPattern":
                  return r2 === "left" && (o2.type === "TSTypeAssertion" || o2.type === "TSAsExpression");
                case "LogicalExpression":
                  if (o2.type === "LogicalExpression")
                    return n2.operator !== o2.operator;
                case "BinaryExpression": {
                  const { operator: e3, type: t3 } = o2;
                  if (!e3 && t3 !== "TSTypeAssertion")
                    return true;
                  const i2 = CA(e3), u2 = n2.operator, s2 = CA(u2);
                  return s2 > i2 || (r2 === "right" && s2 === i2 || (s2 === i2 && !EA(u2, e3) || (s2 < i2 && e3 === "%" ? u2 === "+" || u2 === "-" : !!yA(u2))));
                }
                default:
                  return false;
              }
            case "SequenceExpression":
              switch (n2.type) {
                case "ReturnStatement":
                case "ForStatement":
                  return false;
                case "ExpressionStatement":
                  return r2 !== "expression";
                case "ArrowFunctionExpression":
                  return r2 !== "body";
                default:
                  return true;
              }
            case "YieldExpression":
              if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
                return true;
            case "AwaitExpression":
              switch (n2.type) {
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "BindExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return r2 === "object";
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "ConditionalExpression":
                  return r2 === "test";
                case "BinaryExpression":
                  return !(!o2.argument && n2.operator === "|>");
                default:
                  return false;
              }
            case "TSConditionalType":
              if (r2 === "extendsType" && n2.type === "TSConditionalType")
                return true;
            case "TSFunctionType":
            case "TSConstructorType":
              if (r2 === "checkType" && n2.type === "TSConditionalType")
                return true;
            case "TSUnionType":
            case "TSIntersectionType":
              if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!o2.types || o2.types.length > 1))
                return true;
            case "TSInferType":
              if (o2.type === "TSInferType" && n2.type === "TSRestType")
                return false;
            case "TSTypeOperator":
              return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && e2.getParentNode(1).type.startsWith("TSJSDoc");
            case "ArrayTypeAnnotation":
              return n2.type === "NullableTypeAnnotation";
            case "IntersectionTypeAnnotation":
            case "UnionTypeAnnotation":
              return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
            case "NullableTypeAnnotation":
              return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
            case "FunctionTypeAnnotation": {
              const t3 = n2.type === "NullableTypeAnnotation" ? e2.getParentNode(1) : n2;
              return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && fA(o2).some((e3) => e3.typeAnnotation && e3.typeAnnotation.type === "NullableTypeAnnotation");
            }
            case "OptionalIndexedAccessType":
              return r2 === "objectType" && n2.type === "IndexedAccessType";
            case "TypeofTypeAnnotation":
              return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
            case "StringLiteral":
            case "NumericLiteral":
            case "Literal":
              if (typeof o2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
                const t3 = e2.getParentNode(1);
                return t3.type === "Program" || t3.type === "BlockStatement";
              }
              return r2 === "object" && n2.type === "MemberExpression" && typeof o2.value == "number";
            case "AssignmentExpression": {
              const t3 = e2.getParentNode(1);
              return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? o2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
            }
            case "ConditionalExpression":
              switch (n2.type) {
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                case "NGPipeExpression":
                case "ExportDefaultDeclaration":
                case "AwaitExpression":
                case "JSXSpreadAttribute":
                case "TSTypeAssertion":
                case "TypeCastExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return true;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "ConditionalExpression":
                  return r2 === "test";
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return r2 === "object";
                default:
                  return false;
              }
            case "FunctionExpression":
              switch (n2.type) {
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "TaggedTemplateExpression":
                  return true;
                default:
                  return false;
              }
            case "ArrowFunctionExpression":
              switch (n2.type) {
                case "BinaryExpression":
                  return n2.operator !== "|>" || o2.extra && o2.extra.parenthesized;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                  return r2 === "callee";
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return r2 === "object";
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "BindExpression":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "AwaitExpression":
                case "TSTypeAssertion":
                  return true;
                case "ConditionalExpression":
                  return r2 === "test";
                default:
                  return false;
              }
            case "ClassExpression":
              return n2.type === "NewExpression" && r2 === "callee";
            case "OptionalMemberExpression":
            case "OptionalCallExpression": {
              const t3 = e2.getParentNode(1);
              if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
                return true;
            }
            case "CallExpression":
            case "MemberExpression":
            case "TaggedTemplateExpression":
            case "TSNonNullExpression":
              if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
                let e3 = o2;
                for (; e3; )
                  switch (e3.type) {
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "BindExpression":
                      e3 = e3.object;
                      break;
                    case "TaggedTemplateExpression":
                      e3 = e3.tag;
                      break;
                    case "TSNonNullExpression":
                      e3 = e3.expression;
                      break;
                    default:
                      return false;
                  }
              }
              return false;
            case "BindExpression":
              return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && vA(n2);
            case "NGPipeExpression":
              return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!o2.extra || !o2.extra.parenthesized) || n2.type === "ArrayExpression" || bA(n2) && n2.arguments[r2] === o2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
            case "JSXFragment":
            case "JSXElement":
              return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !bA(n2) && !AA(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
            case "TypeAnnotation":
              return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e3) {
                return mA(e3, (e4) => e4.type === "ObjectTypeAnnotation" && mA(e4, (e5) => e5.type === "FunctionTypeAnnotation" || void 0) || void 0);
              }(o2);
          }
          return false;
        }
        function xA(e2) {
          const t2 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getName();
          switch (n2.type) {
            case "NGPipeExpression":
              if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
                return e2.callParent(xA);
              break;
            case "ObjectProperty":
              if (r2 === "value") {
                const t3 = e2.getParentNode(1);
                return pA(t3.properties) === n2;
              }
              break;
            case "BinaryExpression":
            case "LogicalExpression":
              if (r2 === "right")
                return e2.callParent(xA);
              break;
            case "ConditionalExpression":
              if (r2 === "alternate")
                return e2.callParent(xA);
              break;
            case "UnaryExpression":
              if (n2.prefix)
                return e2.callParent(xA);
          }
          return false;
        }
        function SA(e2, t2) {
          const n2 = e2.getValue(), r2 = e2.getParentNode();
          return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !FA(e2, t2) : !(!gA(n2) || r2.type !== "ExportDefaultDeclaration" && FA(e2, t2)) && e2.call((e3) => SA(e3, t2), ...dA(e2, n2));
        }
        var wA = FA;
        var TA = function(e2, t2) {
          switch (t2.parser) {
            case "json":
            case "json5":
            case "json-stringify":
            case "__js_expression":
            case "__vue_expression":
              return Object.assign(Object.assign({}, e2), {}, { type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e2, comments: [], rootMarker: t2.rootMarker });
            default:
              return e2;
          }
        };
        const { builders: { join: BA, line: NA, group: kA, softline: PA, indent: OA } } = Zc;
        var IA = { isVueEventBindingExpression: function e2(t2) {
          switch (t2.type) {
            case "MemberExpression":
              switch (t2.property.type) {
                case "Identifier":
                case "NumericLiteral":
                case "StringLiteral":
                  return e2(t2.object);
              }
              return false;
            case "Identifier":
              return true;
            default:
              return false;
          }
        }, printHtmlBinding: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (t2.__onHtmlBindingRoot && e2.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
            return t2.__isVueForBindingLeft ? e2.call((e3) => {
              const t3 = BA([",", NA], e3.map(n2, "params")), { params: r3 } = e3.getValue();
              return r3.length === 1 ? t3 : ["(", OA([PA, kA(t3)]), PA, ")"];
            }, "program", "body", 0) : t2.__isVueBindings ? e2.call((e3) => BA([",", NA], e3.map(n2, "params")), "program", "body", 0) : void 0;
        } };
        const { printComments: LA } = tD, { getLast: jA } = dc, { builders: { join: _A, line: MA, softline: RA, group: VA, indent: $A, align: WA, ifBreak: qA, indentIfBreak: UA }, utils: { cleanDoc: zA, getDocParts: GA, isConcat: HA } } = Zc, { hasLeadingOwnLineComment: JA, isBinaryish: XA, isJsxNode: YA, shouldFlatten: KA, hasComment: QA, CommentCheckFlags: ZA, isCallExpression: eF, isMemberExpression: tF, isObjectProperty: nF, isEnabledHackPipeline: rF } = CC;
        let oF = 0;
        function iF(e2, t2, n2, r2, o2) {
          const i2 = e2.getValue();
          if (!XA(i2))
            return [VA(t2())];
          let u2 = [];
          KA(i2.operator, i2.left.operator) ? u2 = e2.call((e3) => iF(e3, t2, n2, true, o2), "left") : u2.push(VA(t2("left")));
          const s2 = uF(i2), a2 = (i2.operator === "|>" || i2.type === "NGPipeExpression" || i2.operator === "|" && n2.parser === "__vue_expression") && !JA(n2.originalText, i2.right), c2 = i2.type === "NGPipeExpression" ? "|" : i2.operator, l2 = i2.type === "NGPipeExpression" && i2.arguments.length > 0 ? VA($A([RA, ": ", _A([RA, ":", qA(" ")], e2.map(t2, "arguments").map((e3) => WA(2, VA(e3))))])) : "";
          let p2;
          if (s2)
            p2 = [c2, " ", t2("right"), l2];
          else {
            const r3 = rF(n2) && c2 === "|>" ? e2.call((e3) => iF(e3, t2, n2, true, o2), "right") : t2("right");
            p2 = [a2 ? MA : "", c2, a2 ? " " : MA, r3, l2];
          }
          const f2 = e2.getParentNode(), d2 = QA(i2.left, ZA.Trailing | ZA.Line), h2 = d2 || !(o2 && i2.type === "LogicalExpression") && f2.type !== i2.type && i2.left.type !== i2.type && i2.right.type !== i2.type;
          if (u2.push(a2 ? "" : " ", h2 ? VA(p2, { shouldBreak: d2 }) : p2), r2 && QA(i2)) {
            const t3 = zA(LA(e2, u2, n2));
            return HA(t3) || t3.type === "fill" ? GA(t3) : [t3];
          }
          return u2;
        }
        function uF(e2) {
          return e2.type === "LogicalExpression" && (e2.right.type === "ObjectExpression" && e2.right.properties.length > 0 || (e2.right.type === "ArrayExpression" && e2.right.elements.length > 0 || !!YA(e2.right)));
        }
        var sF = { printBinaryishExpression: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = e2.getParentNode(1), u2 = r2 !== o2.body && (o2.type === "IfStatement" || o2.type === "WhileStatement" || o2.type === "SwitchStatement" || o2.type === "DoWhileStatement"), s2 = rF(t2) && r2.operator === "|>", a2 = iF(e2, n2, t2, false, u2);
          if (u2)
            return a2;
          if (s2)
            return VA(a2);
          if (eF(o2) && o2.callee === r2 || o2.type === "UnaryExpression" || tF(o2) && !o2.computed)
            return VA([$A([RA, ...a2]), RA]);
          const c2 = o2.type === "ReturnStatement" || o2.type === "ThrowStatement" || o2.type === "JSXExpressionContainer" && i2.type === "JSXAttribute" || r2.operator !== "|" && o2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (o2.type === "NGRoot" && t2.parser === "__ng_binding" || o2.type === "NGMicrosyntaxExpression" && i2.type === "NGMicrosyntax" && i2.body.length === 1) || r2 === o2.body && o2.type === "ArrowFunctionExpression" || r2 !== o2.body && o2.type === "ForStatement" || o2.type === "ConditionalExpression" && i2.type !== "ReturnStatement" && i2.type !== "ThrowStatement" && !eF(i2) || o2.type === "TemplateLiteral", l2 = o2.type === "AssignmentExpression" || o2.type === "VariableDeclarator" || o2.type === "ClassProperty" || o2.type === "PropertyDefinition" || o2.type === "TSAbstractPropertyDefinition" || o2.type === "ClassPrivateProperty" || nF(o2), p2 = XA(r2.left) && KA(r2.operator, r2.left.operator);
          if (c2 || uF(r2) && !p2 || !uF(r2) && l2)
            return VA(a2);
          if (a2.length === 0)
            return "";
          const f2 = YA(r2.right), d2 = a2.findIndex((e3) => typeof e3 != "string" && !Array.isArray(e3) && e3.type === "group"), h2 = a2.slice(0, d2 === -1 ? 1 : d2 + 1), g2 = a2.slice(h2.length, f2 ? -1 : void 0), m2 = Symbol("logicalChain-" + ++oF), y2 = VA([...h2, $A(g2)], { id: m2 });
          if (!f2)
            return y2;
          const D2 = jA(a2);
          return VA([y2, UA(D2, { groupId: m2 })]);
        }, shouldInlineLogicalExpression: uF };
        const { builders: { join: aF, line: cF, group: lF } } = Zc, { hasNode: pF, hasComment: fF, getComments: dF } = CC, { printBinaryishExpression: hF } = sF;
        function gF(e2, t2, n2) {
          return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
        }
        var mF = { printAngular: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (r2.type.startsWith("NG"))
            switch (r2.type) {
              case "NGRoot":
                return [n2("node"), fF(r2.node) ? " //" + dF(r2.node)[0].value.trimEnd() : ""];
              case "NGPipeExpression":
                return hF(e2, t2, n2);
              case "NGChainedExpression":
                return lF(aF([";", cF], e2.map((e3) => function(e4) {
                  return pF(e4.getValue(), (e5) => {
                    switch (e5.type) {
                      case void 0:
                        return false;
                      case "CallExpression":
                      case "OptionalCallExpression":
                      case "AssignmentExpression":
                        return true;
                    }
                  });
                }(e3) ? n2() : ["(", n2(), ")"], "expressions")));
              case "NGEmptyExpression":
                return "";
              case "NGQuotedExpression":
                return [r2.prefix, ": ", r2.value.trim()];
              case "NGMicrosyntax":
                return e2.map((e3, t3) => [t3 === 0 ? "" : gF(e3.getValue(), t3, r2) ? " " : [";", cF], n2()], "body");
              case "NGMicrosyntaxKey":
                return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
              case "NGMicrosyntaxExpression":
                return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
              case "NGMicrosyntaxKeyedExpression": {
                const t3 = e2.getName(), o2 = e2.getParentNode(), i2 = gF(r2, t3, o2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && o2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && o2.body[t3 - 1].key.name === "then") && o2.body[0].type === "NGMicrosyntaxExpression";
                return [n2("key"), i2 ? " " : ": ", n2("expression")];
              }
              case "NGMicrosyntaxLet":
                return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
              case "NGMicrosyntaxAs":
                return [n2("key"), " as ", n2("alias")];
              default:
                throw new Error("Unknown Angular node type: ".concat(JSON.stringify(r2.type), "."));
            }
        } };
        const { printComments: yF, printDanglingComments: DF } = tD, { builders: { line: EF, hardline: CF, softline: bF, group: vF, indent: AF, conditionalGroup: FF, fill: xF, ifBreak: SF, lineSuffixBoundary: wF, join: TF }, utils: { willBreak: BF } } = Zc, { getLast: NF, getPreferredQuote: kF } = dc, { isJsxNode: PF, rawText: OF, isLiteral: IF, isCallExpression: LF, isStringLiteral: jF, isBinaryish: _F, hasComment: MF, CommentCheckFlags: RF, hasNodeIgnoreComment: VF } = CC, $F = wA, { willPrintOwnComments: WF } = lA, qF = (e2) => e2 === "" || e2 === EF || e2 === CF || e2 === bF;
        function UF(e2, t2, n2) {
          const r2 = e2.getValue();
          if (r2.type === "JSXElement" && function(e3) {
            if (e3.children.length === 0)
              return true;
            if (e3.children.length > 1)
              return false;
            const t3 = e3.children[0];
            return IF(t3) && !QF(t3);
          }(r2))
            return [n2("openingElement"), n2("closingElement")];
          const o2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), i2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
          if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
            return [o2, ...e2.map(n2, "children"), i2];
          r2.children = r2.children.map((e3) => function(e4) {
            return e4.type === "JSXExpressionContainer" && IF(e4.expression) && e4.expression.value === " " && !MF(e4.expression);
          }(e3) ? { type: "JSXText", value: " ", raw: " " } : e3);
          const u2 = r2.children.some(PF), s2 = r2.children.filter((e3) => e3.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
          let c2 = BF(o2) || u2 || a2 || s2;
          const l2 = e2.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : SF([p2, bF], " "), d2 = function(e3, t3, n3, r3, o3) {
            const i3 = [];
            return e3.each((e4, t4, u3) => {
              const s3 = e4.getValue();
              if (IF(s3)) {
                const e5 = OF(s3);
                if (QF(s3)) {
                  const n4 = e5.split(XF);
                  if (n4[0] === "") {
                    if (i3.push(""), n4.shift(), /\n/.test(n4[0])) {
                      const e6 = u3[t4 + 1];
                      i3.push(GF(o3, n4[1], s3, e6));
                    } else
                      i3.push(r3);
                    n4.shift();
                  }
                  let a3;
                  if (NF(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
                    return;
                  for (const [e6, t5] of n4.entries())
                    e6 % 2 == 1 ? i3.push(EF) : i3.push(t5);
                  if (a3 !== void 0)
                    if (/\n/.test(a3)) {
                      const e6 = u3[t4 + 1];
                      i3.push(GF(o3, NF(i3), s3, e6));
                    } else
                      i3.push(r3);
                  else {
                    const e6 = u3[t4 + 1];
                    i3.push(zF(o3, NF(i3), s3, e6));
                  }
                } else
                  /\n/.test(e5) ? e5.match(/\n/g).length > 1 && i3.push("", CF) : i3.push("", r3);
              } else {
                const e5 = n3();
                i3.push(e5);
                const r4 = u3[t4 + 1];
                if (r4 && QF(r4)) {
                  const e6 = KF(OF(r4)).split(XF)[0];
                  i3.push(zF(o3, e6, s3, r4));
                } else
                  i3.push(CF);
              }
            }, "children"), i3;
          }(e2, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e3) => QF(e3));
          for (let e3 = d2.length - 2; e3 >= 0; e3--) {
            const t3 = d2[e3] === "" && d2[e3 + 1] === "", n3 = d2[e3] === CF && d2[e3 + 1] === "" && d2[e3 + 2] === CF, r3 = (d2[e3] === bF || d2[e3] === CF) && d2[e3 + 1] === "" && d2[e3 + 2] === f2, o3 = d2[e3] === f2 && d2[e3 + 1] === "" && (d2[e3 + 2] === bF || d2[e3 + 2] === CF), i3 = d2[e3] === f2 && d2[e3 + 1] === "" && d2[e3 + 2] === f2, u3 = d2[e3] === bF && d2[e3 + 1] === "" && d2[e3 + 2] === CF || d2[e3] === CF && d2[e3 + 1] === "" && d2[e3 + 2] === bF;
            n3 && h2 || t3 || r3 || i3 || u3 ? d2.splice(e3, 2) : o3 && d2.splice(e3 + 1, 2);
          }
          for (; d2.length > 0 && qF(NF(d2)); )
            d2.pop();
          for (; d2.length > 1 && qF(d2[0]) && qF(d2[1]); )
            d2.shift(), d2.shift();
          const g2 = [];
          for (const [e3, t3] of d2.entries()) {
            if (t3 === f2) {
              if (e3 === 1 && d2[e3 - 1] === "") {
                if (d2.length === 2) {
                  g2.push(p2);
                  continue;
                }
                g2.push([p2, CF]);
                continue;
              }
              if (e3 === d2.length - 1) {
                g2.push(p2);
                continue;
              }
              if (d2[e3 - 1] === "" && d2[e3 - 2] === CF) {
                g2.push(p2);
                continue;
              }
            }
            g2.push(t3), BF(t3) && (c2 = true);
          }
          const m2 = h2 ? xF(g2) : vF(g2, { shouldBreak: true });
          if (l2)
            return m2;
          const y2 = vF([o2, AF([CF, m2]), CF, i2]);
          return c2 ? y2 : FF([vF([o2, ...d2, i2]), y2]);
        }
        function zF(e2, t2, n2, r2) {
          return e2 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? bF : CF : bF;
        }
        function GF(e2, t2, n2, r2) {
          return e2 ? CF : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? CF : bF : CF;
        }
        function HF(e2, t2, n2) {
          return function(e3, t3, n3) {
            const r2 = e3.getParentNode();
            if (!r2)
              return t3;
            if ({ ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[r2.type])
              return t3;
            const o2 = e3.match(void 0, (e4) => e4.type === "ArrowFunctionExpression", LF, (e4) => e4.type === "JSXExpressionContainer"), i2 = $F(e3, n3);
            return vF([i2 ? "" : SF("("), AF([bF, t3]), bF, i2 ? "" : SF(")")], { shouldBreak: o2 });
          }(e2, yF(e2, UF(e2, t2, n2), t2), t2);
        }
        function JF(e2, t2, n2) {
          const r2 = e2.getValue();
          return ["{", e2.call((e3) => {
            const r3 = ["...", n2()], o2 = e3.getValue();
            return MF(o2) && WF(e3) ? [AF([bF, yF(e3, r3, t2)]), bF] : r3;
          }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
        }
        const XF = new RegExp("([ \n\r	]+)"), YF = new RegExp("[^ \n\r	]"), KF = (e2) => e2.replace(new RegExp("(?:^" + XF.source + "|" + XF.source + "$)"), "");
        function QF(e2) {
          return IF(e2) && (YF.test(OF(e2)) || !/\n/.test(OF(e2)));
        }
        var ZF = { hasJsxIgnoreComment: function(e2) {
          const t2 = e2.getValue(), n2 = e2.getParentNode();
          if (!(n2 && t2 && PF(t2) && PF(n2)))
            return false;
          let r2 = null;
          for (let e3 = n2.children.indexOf(t2); e3 > 0; e3--) {
            const t3 = n2.children[e3 - 1];
            if (t3.type !== "JSXText" || QF(t3)) {
              r2 = t3;
              break;
            }
          }
          return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && VF(r2.expression);
        }, printJsx: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (r2.type.startsWith("JSX"))
            switch (r2.type) {
              case "JSXAttribute":
                return function(e3, t3, n3) {
                  const r3 = e3.getValue(), o2 = [];
                  if (o2.push(n3("name")), r3.value) {
                    let e4;
                    if (jF(r3.value)) {
                      let n4 = OF(r3.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                      const { escaped: o3, quote: i2, regex: u2 } = kF(n4, t3.jsxSingleQuote ? "'" : '"');
                      n4 = n4.replace(u2, o3), e4 = [i2, n4, i2];
                    } else
                      e4 = n3("value");
                    o2.push("=", e4);
                  }
                  return o2;
                }(e2, t2, n2);
              case "JSXIdentifier":
                return String(r2.name);
              case "JSXNamespacedName":
                return TF(":", [n2("namespace"), n2("name")]);
              case "JSXMemberExpression":
                return TF(".", [n2("object"), n2("property")]);
              case "JSXSpreadAttribute":
                return JF(e2, t2, n2);
              case "JSXSpreadChild":
                return JF(e2, t2, n2);
              case "JSXExpressionContainer":
                return function(e3, t3, n3) {
                  const r3 = e3.getValue(), o2 = e3.getParentNode(0), i2 = r3.expression.type === "JSXEmptyExpression" || !MF(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || LF(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || PF(o2) && (r3.expression.type === "ConditionalExpression" || _F(r3.expression)));
                  return vF(i2 ? ["{", n3("expression"), wF, "}"] : ["{", AF([bF, n3("expression")]), bF, wF, "}"]);
                }(e2, 0, n2);
              case "JSXFragment":
              case "JSXElement":
                return HF(e2, t2, n2);
              case "JSXOpeningElement":
                return function(e3, t3, n3) {
                  const r3 = e3.getValue(), o2 = r3.name && MF(r3.name) || r3.typeParameters && MF(r3.typeParameters);
                  if (r3.selfClosing && r3.attributes.length === 0 && !o2)
                    return ["<", n3("name"), n3("typeParameters"), " />"];
                  if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && jF(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !o2 && !MF(r3.attributes[0]))
                    return vF(["<", n3("name"), n3("typeParameters"), " ", ...e3.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
                  const i2 = r3.attributes.length > 0 && MF(NF(r3.attributes), RF.Trailing), u2 = r3.attributes.length === 0 && !o2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!o2 || r3.attributes.length > 0) && !i2, s2 = r3.attributes && r3.attributes.some((e4) => e4.value && jF(e4.value) && e4.value.value.includes("\n"));
                  return vF(["<", n3("name"), n3("typeParameters"), AF(e3.map(() => [EF, n3()], "attributes")), r3.selfClosing ? EF : u2 ? ">" : bF, r3.selfClosing ? "/>" : u2 ? "" : ">"], { shouldBreak: s2 });
                }(e2, t2, n2);
              case "JSXClosingElement":
                return function(e3, t3, n3) {
                  const r3 = e3.getValue(), o2 = [];
                  o2.push("</");
                  const i2 = n3("name");
                  return MF(r3.name, RF.Leading | RF.Line) ? o2.push(AF([CF, i2]), CF) : MF(r3.name, RF.Leading | RF.Block) ? o2.push(" ", i2) : o2.push(i2), o2.push(">"), o2;
                }(e2, 0, n2);
              case "JSXOpeningFragment":
              case "JSXClosingFragment":
                return function(e3, t3) {
                  const n3 = e3.getValue(), r3 = MF(n3), o2 = MF(n3, RF.Line), i2 = n3.type === "JSXOpeningFragment";
                  return [i2 ? "<" : "</", AF([o2 ? CF : r3 && !i2 ? " " : "", DF(e3, t3, true)]), o2 ? CF : "", ">"];
                }(e2, t2);
              case "JSXEmptyExpression":
                return function(e3, t3) {
                  const n3 = e3.getValue(), r3 = MF(n3, RF.Line);
                  return [DF(e3, t3, !r3), r3 ? CF : ""];
                }(e2, t2);
              case "JSXText":
                throw new Error("JSXTest should be handled by JSXElement");
              default:
                throw new Error("Unknown JSX node type: ".concat(JSON.stringify(r2.type), "."));
            }
        } }, ex = bu, tx = Ze, nx = gr, rx = ar, ox = Wu;
        ro({ target: "Array", proto: true }, { flat: function() {
          var e2 = arguments.length ? arguments[0] : void 0, t2 = tx(this), n2 = nx(t2), r2 = ox(t2, 0);
          return r2.length = ex(r2, t2, t2, n2, 0, e2 === void 0 ? 1 : rx(e2)), r2;
        } });
        var ix, ux = Sr, sx = wr, ax = Object.keys || function(e2) {
          return ux(e2, sx);
        }, cx = zt, lx = Yt, px = oe, fx = ax, dx = B ? Object.defineProperties : function(e2, t2) {
          lx(e2);
          for (var n2, r2 = px(t2), o2 = fx(t2), i2 = o2.length, u2 = 0; i2 > u2; )
            cx.f(e2, n2 = o2[u2++], r2[n2]);
          return e2;
        }, hx = pe("document", "documentElement"), gx = Yt, mx = dx, yx = wr, Dx = An, Ex = hx, Cx = Ot, bx = vn("IE_PROTO"), vx = function() {
        }, Ax = function(e2) {
          return "<script>" + e2 + "<\/script>";
        }, Fx = function(e2) {
          e2.write(Ax("")), e2.close();
          var t2 = e2.parentWindow.Object;
          return e2 = null, t2;
        }, xx = function() {
          try {
            ix = new ActiveXObject("htmlfile");
          } catch (e3) {
          }
          xx = typeof document != "undefined" ? document.domain && ix ? Fx(ix) : function() {
            var e3, t2 = Cx("iframe");
            return t2.style.display = "none", Ex.appendChild(t2), t2.src = String("javascript:"), (e3 = t2.contentWindow.document).open(), e3.write(Ax("document.F=Object")), e3.close(), e3.F;
          }() : Fx(ix);
          for (var e2 = yx.length; e2--; )
            delete xx.prototype[yx[e2]];
          return xx();
        };
        Dx[bx] = true;
        var Sx = Object.create || function(e2, t2) {
          var n2;
          return e2 !== null ? (vx.prototype = gx(e2), n2 = new vx(), vx.prototype = null, n2[bx] = e2) : n2 = xx(), t2 === void 0 ? n2 : mx(n2, t2);
        }, wx = zt, Tx = Dt("unscopables"), Bx = Array.prototype;
        Bx[Tx] == null && wx.f(Bx, Tx, { configurable: true, value: Sx(null) });
        var Nx = function(e2) {
          Bx[Tx][e2] = true;
        };
        Nx("flat");
        const { isNonEmptyArray: kx } = dc, { builders: { indent: Px, join: Ox, line: Ix } } = Zc, { isFlowAnnotationComment: Lx } = CC;
        function jx(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2.typeAnnotation)
            return "";
          const o2 = e2.getParentNode(), i2 = r2.definite || o2 && o2.type === "VariableDeclarator" && o2.definite, u2 = o2.type === "DeclareFunction" && o2.id === r2;
          return Lx(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [u2 ? "" : i2 ? "!: " : ": ", n2("typeAnnotation")];
        }
        var _x = { printOptionalToken: function(e2) {
          const t2 = e2.getValue();
          return !t2.optional || t2.type === "Identifier" && t2 === e2.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
        }, printFunctionTypeParameters: function(e2, t2, n2) {
          const r2 = e2.getValue();
          return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
        }, printBindExpressionCallee: function(e2, t2, n2) {
          return ["::", n2("callee")];
        }, printTypeScriptModifiers: function(e2, t2, n2) {
          const r2 = e2.getValue();
          return kx(r2.modifiers) ? [Ox(" ", e2.map(n2, "modifiers")), " "] : "";
        }, printTypeAnnotation: jx, printRestSpread: function(e2, t2, n2) {
          return ["...", n2("argument"), jx(e2, t2, n2)];
        }, adjustClause: function(e2, t2, n2) {
          return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || n2 ? [" ", t2] : Px([Ix, t2]);
        } };
        const { printDanglingComments: Mx } = tD, { builders: { line: Rx, softline: Vx, hardline: $x, group: Wx, indent: qx, ifBreak: Ux, fill: zx } } = Zc, { getLast: Gx, hasNewline: Hx } = dc, { shouldPrintComma: Jx, hasComment: Xx, CommentCheckFlags: Yx, isNextLineEmpty: Kx, isNumericLiteral: Qx, isSignedNumericLiteral: Zx } = CC, { locStart: eS } = og, { printOptionalToken: tS, printTypeAnnotation: nS } = _x;
        function rS(e2, t2) {
          return e2.elements.length > 1 && e2.elements.every((e3) => e3 && (Qx(e3) || Zx(e3) && !Xx(e3.argument)) && !Xx(e3, Yx.Trailing | Yx.Line, (e4) => !Hx(t2.originalText, eS(e4), { backwards: true })));
        }
        function oS(e2, t2, n2, r2) {
          const o2 = [];
          let i2 = [];
          return e2.each((e3) => {
            o2.push(i2, Wx(r2())), i2 = [",", Rx], e3.getValue() && Kx(e3.getValue(), t2) && i2.push(Vx);
          }, n2), o2;
        }
        function iS(e2, t2, n2, r2) {
          const o2 = [];
          return e2.each((e3, i2, u2) => {
            const s2 = i2 === u2.length - 1;
            o2.push([n2(), s2 ? r2 : ","]), s2 || o2.push(Kx(e3.getValue(), t2) ? [$x, $x] : Xx(u2[i2 + 1], Yx.Leading | Yx.Line) ? $x : Rx);
          }, "elements"), zx(o2);
        }
        var uS = { printArray: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [], i2 = r2.type === "TupleExpression" ? "#[" : "[";
          if (r2.elements.length === 0)
            Xx(r2, Yx.Dangling) ? o2.push(Wx([i2, Mx(e2, t2), Vx, "]"])) : o2.push(i2, "]");
          else {
            const u2 = Gx(r2.elements), s2 = !(u2 && u2.type === "RestElement"), a2 = u2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e3, t3, n3) => {
              const r3 = e3 && e3.type;
              if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
                return false;
              const o3 = n3[t3 + 1];
              if (o3 && r3 !== o3.type)
                return false;
              const i3 = r3 === "ArrayExpression" ? "elements" : "properties";
              return e3[i3] && e3[i3].length > 1;
            }), p2 = rS(r2, t2), f2 = s2 ? a2 ? "," : Jx(t2) ? p2 ? Ux(",", "", { groupId: c2 }) : Ux(",") : "" : "";
            o2.push(Wx([i2, qx([Vx, p2 ? iS(e2, t2, n2, f2) : [oS(e2, t2, "elements", n2), f2], Mx(e2, t2, true)]), Vx, "]"], { shouldBreak: l2, id: c2 }));
          }
          return o2.push(tS(e2), nS(e2, t2, n2)), o2;
        }, printArrayItems: oS, isConciselyPrintedArray: rS };
        const { printDanglingComments: sS } = tD, { getLast: aS, getPenultimate: cS } = dc, { getFunctionParameters: lS, hasComment: pS, CommentCheckFlags: fS, isFunctionCompositionArgs: dS, isJsxNode: hS, isLongCurriedCallExpression: gS, shouldPrintComma: mS, getCallArguments: yS, iterateCallArgumentsPath: DS, isNextLineEmpty: ES, isCallExpression: CS, isStringLiteral: bS, isObjectProperty: vS } = CC, { builders: { line: AS, hardline: FS, softline: xS, group: SS, indent: wS, conditionalGroup: TS, ifBreak: BS, breakParent: NS }, utils: { willBreak: kS } } = Zc, { ArgExpansionBailout: PS } = Cp, { isConciselyPrintedArray: OS } = uS;
        function IS(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          return e2.type === "ObjectExpression" && (e2.properties.length > 0 || pS(e2)) || e2.type === "ArrayExpression" && (e2.elements.length > 0 || pS(e2)) || e2.type === "TSTypeAssertion" && IS(e2.expression) || e2.type === "TSAsExpression" && IS(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || LS(e2.body)) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && IS(e2.body, true) || e2.body.type === "ObjectExpression" || e2.body.type === "ArrayExpression" || !t2 && (CS(e2.body) || e2.body.type === "ConditionalExpression") || hS(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
        }
        function LS(e2) {
          return e2.type === "BlockStatement" && (e2.body.some((e3) => e3.type !== "EmptyStatement") || pS(e2, fS.Dangling));
        }
        var jS = function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "ImportExpression", i2 = yS(r2);
          if (i2.length === 0)
            return ["(", sS(e2, t2, true), ")"];
          if (function(e3) {
            return e3.length === 2 && e3[0].type === "ArrowFunctionExpression" && lS(e3[0]).length === 0 && e3[0].body.type === "BlockStatement" && e3[1].type === "ArrayExpression" && !e3.some((e4) => pS(e4));
          }(i2))
            return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
          let u2 = false, s2 = false;
          const a2 = i2.length - 1, c2 = [];
          DS(e2, (e3, r3) => {
            const o3 = e3.getNode(), i3 = [n2()];
            r3 === a2 || (ES(o3, t2) ? (r3 === 0 && (s2 = true), u2 = true, i3.push(",", FS, FS)) : i3.push(",", AS)), c2.push(i3);
          });
          const l2 = o2 || r2.callee && r2.callee.type === "Import" || !mS(t2, "all") ? "" : ",";
          function p2() {
            return SS(["(", wS([AS, ...c2]), l2, AS, ")"], { shouldBreak: true });
          }
          if (u2 || e2.getParentNode().type !== "Decorator" && dS(i2))
            return p2();
          const f2 = function(e3) {
            if (e3.length !== 2)
              return false;
            const [t3, n3] = e3;
            if (t3.type === "ModuleExpression" && function(e4) {
              return e4.type === "ObjectExpression" && e4.properties.length === 1 && vS(e4.properties[0]) && e4.properties[0].key.type === "Identifier" && e4.properties[0].key.name === "type" && bS(e4.properties[0].value) && e4.properties[0].value.value === "module";
            }(n3))
              return true;
            return !pS(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !IS(n3);
          }(i2), d2 = function(e3, t3) {
            const n3 = aS(e3), r3 = cS(e3);
            return !pS(n3, fS.Leading) && !pS(n3, fS.Trailing) && IS(n3) && (!r3 || r3.type !== n3.type) && (e3.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e3.length > 1 && n3.type === "ArrayExpression" && OS(n3, t3));
          }(i2, t2);
          if (f2 || d2) {
            if (f2 ? c2.slice(1).some(kS) : c2.slice(0, -1).some(kS))
              return p2();
            let t3 = [];
            try {
              e2.try(() => {
                DS(e2, (e3, r3) => {
                  f2 && r3 === 0 && (t3 = [[n2([], { expandFirstArg: true }), c2.length > 1 ? "," : "", s2 ? FS : AS, s2 ? FS : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t3 = [...c2.slice(0, -1), n2([], { expandLastArg: true })]);
                });
              });
            } catch (e3) {
              if (e3 instanceof PS)
                return p2();
              throw e3;
            }
            return [c2.some(kS) ? NS : "", TS([["(", ...t3, ")"], f2 ? ["(", SS(t3[0], { shouldBreak: true }), ...t3.slice(1), ")"] : ["(", ...c2.slice(0, -1), SS(aS(t3), { shouldBreak: true }), ")"], p2()])];
          }
          const h2 = ["(", wS([xS, ...c2]), BS(l2), xS, ")"];
          return gS(e2) ? h2 : SS(h2, { shouldBreak: c2.some(kS) || u2 });
        };
        const { builders: { softline: _S, group: MS, indent: RS, label: VS } } = Zc, { isNumericLiteral: $S, isMemberExpression: WS, isCallExpression: qS } = CC, { printOptionalToken: US } = _x;
        function zS(e2, t2, n2) {
          const r2 = n2("property"), o2 = e2.getValue(), i2 = US(e2);
          return o2.computed ? !o2.property || $S(o2.property) ? [i2, "[", r2, "]"] : MS([i2, "[", RS([_S, r2]), _S, "]"]) : [i2, ".", r2];
        }
        var GS = { printMemberExpression: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = e2.getParentNode();
          let i2, u2 = 0;
          do {
            i2 = e2.getParentNode(u2), u2++;
          } while (i2 && (WS(i2) || i2.type === "TSNonNullExpression"));
          const s2 = n2("object"), a2 = zS(e2, t2, n2), c2 = i2 && (i2.type === "NewExpression" || i2.type === "BindExpression" || i2.type === "AssignmentExpression" && i2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !WS(o2) || (o2.type === "AssignmentExpression" || o2.type === "VariableDeclarator") && (qS(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && qS(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
          return VS(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : MS(RS([_S, a2]))]);
        }, printMemberLookup: zS };
        const { printComments: HS } = tD, { getLast: JS, isNextLineEmptyAfterIndex: XS, getNextNonSpaceNonCommentCharacterIndex: YS } = dc, KS = wA, { isCallExpression: QS, isMemberExpression: ZS, isFunctionOrArrowExpression: ew, isLongCurriedCallExpression: tw, isMemberish: nw, isNumericLiteral: rw, isSimpleCallArgument: ow, hasComment: iw, CommentCheckFlags: uw, isNextLineEmpty: sw } = CC, { locEnd: aw } = og, { builders: { join: cw, hardline: lw, group: pw, indent: fw, conditionalGroup: dw, breakParent: hw, label: gw }, utils: { willBreak: mw } } = Zc, yw = jS, { printMemberLookup: Dw } = GS, { printOptionalToken: Ew, printFunctionTypeParameters: Cw, printBindExpressionCallee: bw } = _x;
        var vw = function(e2, t2, n2) {
          const r2 = e2.getParentNode(), o2 = !r2 || r2.type === "ExpressionStatement", i2 = [];
          function u2(e3) {
            const { originalText: n3 } = t2, r3 = YS(n3, e3, aw);
            return n3.charAt(r3) === ")" ? r3 !== false && XS(n3, r3 + 1) : sw(e3, t2);
          }
          function s2(e3) {
            const r3 = e3.getValue();
            QS(r3) && (nw(r3.callee) || QS(r3.callee)) ? (i2.unshift({ node: r3, printed: [HS(e3, [Ew(e3), Cw(e3, t2, n2), yw(e3, t2, n2)], t2), u2(r3) ? lw : ""] }), e3.call((e4) => s2(e4), "callee")) : nw(r3) ? (i2.unshift({ node: r3, needsParens: KS(e3, t2), printed: HS(e3, ZS(r3) ? Dw(e3, t2, n2) : bw(e3, t2, n2), t2) }), e3.call((e4) => s2(e4), "object")) : r3.type === "TSNonNullExpression" ? (i2.unshift({ node: r3, printed: HS(e3, "!", t2) }), e3.call((e4) => s2(e4), "expression")) : i2.unshift({ node: r3, printed: n2() });
          }
          const a2 = e2.getValue();
          i2.unshift({ node: a2, printed: [Ew(e2), Cw(e2, t2, n2), yw(e2, t2, n2)] }), a2.callee && e2.call((e3) => s2(e3), "callee");
          const c2 = [];
          let l2 = [i2[0]], p2 = 1;
          for (; p2 < i2.length && (i2[p2].node.type === "TSNonNullExpression" || QS(i2[p2].node) || ZS(i2[p2].node) && i2[p2].node.computed && rw(i2[p2].node.property)); ++p2)
            l2.push(i2[p2]);
          if (!QS(i2[0].node))
            for (; p2 + 1 < i2.length && (nw(i2[p2].node) && nw(i2[p2 + 1].node)); ++p2)
              l2.push(i2[p2]);
          c2.push(l2), l2 = [];
          let f2 = false;
          for (; p2 < i2.length; ++p2) {
            if (f2 && nw(i2[p2].node)) {
              if (i2[p2].node.computed && rw(i2[p2].node.property)) {
                l2.push(i2[p2]);
                continue;
              }
              c2.push(l2), l2 = [], f2 = false;
            }
            (QS(i2[p2].node) || i2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(i2[p2]), iw(i2[p2].node, uw.Trailing) && (c2.push(l2), l2 = [], f2 = false);
          }
          function d2(e3) {
            return /^[A-Z]|^[$_]+$/.test(e3);
          }
          l2.length > 0 && c2.push(l2);
          const h2 = c2.length >= 2 && !iw(c2[1][0].node) && function(e3) {
            const n3 = e3[1].length > 0 && e3[1][0].node.computed;
            if (e3[0].length === 1) {
              const r4 = e3[0][0].node;
              return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || o2 && function(e4) {
                return e4.length <= t2.tabWidth;
              }(r4.name) || n3);
            }
            const r3 = JS(e3[0]).node;
            return ZS(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
          }(c2);
          function g2(e3) {
            const t3 = e3.map((e4) => e4.printed);
            return e3.length > 0 && JS(e3).needsParens ? ["(", ...t3, ")"] : t3;
          }
          const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e3) => iw(e3.node, uw.Leading)) || E2.slice(0, -1).some((e3) => iw(e3.node, uw.Trailing)) || c2[D2] && iw(c2[D2][0].node, uw.Leading);
          if (c2.length <= D2 && !C2)
            return tw(e2) ? y2 : pw(y2);
          const b2 = JS(c2[h2 ? 1 : 0]).node, v2 = !QS(b2) && u2(b2), A2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", v2 ? lw : "", function(e3) {
            return e3.length === 0 ? "" : fw(pw([lw, cw(lw, e3.map(g2))]));
          }(c2.slice(h2 ? 2 : 1))], F2 = i2.map((e3) => {
            let { node: t3 } = e3;
            return t3;
          }).filter(QS);
          let x2;
          return x2 = C2 || F2.length > 2 && F2.some((e3) => !e3.arguments.every((e4) => ow(e4, 0))) || m2.slice(0, -1).some(mw) || function() {
            const e3 = JS(JS(c2)).node, t3 = JS(m2);
            return QS(e3) && mw(t3) && F2.slice(0, -1).some((e4) => e4.arguments.some(ew));
          }() ? pw(A2) : [mw(y2) || v2 ? hw : "", dw([y2, A2])], gw("member-chain", x2);
        };
        const { builders: { join: Aw, group: Fw } } = Zc, xw = wA, { getCallArguments: Sw, hasFlowAnnotationComment: ww, isCallExpression: Tw, isMemberish: Bw, isStringLiteral: Nw, isTemplateOnItsOwnLine: kw, isTestCall: Pw, iterateCallArgumentsPath: Ow } = CC, Iw = vw, Lw = jS, { printOptionalToken: jw, printFunctionTypeParameters: _w } = _x;
        var Mw = { printCallExpression: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = r2.type === "NewExpression", u2 = r2.type === "ImportExpression", s2 = jw(e2), a2 = Sw(r2);
          if (a2.length > 0 && (!u2 && !i2 && function(e3, t3) {
            if (e3.callee.type !== "Identifier")
              return false;
            if (e3.callee.name === "require")
              return true;
            if (e3.callee.name === "define") {
              const n3 = Sw(e3);
              return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Nw(n3[0]) && n3[1].type === "ArrayExpression");
            }
            return false;
          }(r2, o2) || a2.length === 1 && kw(a2[0], t2.originalText) || !i2 && Pw(r2, o2))) {
            const r3 = [];
            return Ow(e2, () => {
              r3.push(n2());
            }), [i2 ? "new " : "", n2("callee"), s2, _w(e2, t2, n2), "(", Aw(", ", r3), ")"];
          }
          const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && ww(r2.callee.trailingComments);
          if (c2 && (r2.callee.trailingComments[0].printed = true), !u2 && !i2 && Bw(r2.callee) && !e2.call((e3) => xw(e3, t2), "callee"))
            return Iw(e2, t2, n2);
          const l2 = [i2 ? "new " : "", u2 ? "import" : n2("callee"), s2, c2 ? "/*:: ".concat(r2.callee.trailingComments[0].value.slice(2).trim(), " */") : "", _w(e2, t2, n2), Lw(e2, t2, n2)];
          return u2 || Tw(r2.callee) ? Fw(l2) : l2;
        } };
        const { isNonEmptyArray: Rw, getStringWidth: Vw } = dc, { builders: { line: $w, group: Ww, indent: qw, indentIfBreak: Uw }, utils: { cleanDoc: zw, willBreak: Gw, canBreak: Hw } } = Zc, { hasLeadingOwnLineComment: Jw, isBinaryish: Xw, isStringLiteral: Yw, isLiteral: Kw, isNumericLiteral: Qw, isCallExpression: Zw, isMemberExpression: eT, getCallArguments: tT, rawText: nT, hasComment: rT, isSignedNumericLiteral: oT, isObjectProperty: iT } = CC, { shouldInlineLogicalExpression: uT } = sF, { printCallExpression: sT } = Mw;
        function aT(e2, t2, n2, r2, o2, i2) {
          const u2 = function(e3, t3, n3, r3, o3) {
            const i3 = e3.getValue(), u3 = i3[o3];
            if (!u3)
              return "only-left";
            const s3 = !cT(u3), a2 = e3.match(cT, lT, (e4) => !s3 || e4.type !== "ExpressionStatement" && e4.type !== "VariableDeclaration");
            if (a2)
              return s3 ? u3.type === "ArrowFunctionExpression" && u3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!s3 && cT(u3.right) || Jw(t3.originalText, u3))
              return "break-after-operator";
            if (u3.type === "CallExpression" && u3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
              return "never-break-after-operator";
            if (function(e4) {
              if (lT(e4)) {
                const t4 = e4.left || e4.id;
                return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e5) => iT(e5) && (!e5.shorthand || e5.value && e5.value.type === "AssignmentPattern"));
              }
              return false;
            }(i3) || function(e4) {
              const t4 = function(e5) {
                if (function(e6) {
                  return e6.type === "TSTypeAliasDeclaration" || e6.type === "TypeAlias";
                }(e5) && e5.typeParameters && e5.typeParameters.params)
                  return e5.typeParameters.params;
                return null;
              }(e4);
              if (Rw(t4)) {
                const n4 = e4.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (t4.length > 1 && t4.some((e5) => e5[n4] || e5.default))
                  return true;
              }
              return false;
            }(i3) || function(e4) {
              if (e4.type !== "VariableDeclarator")
                return false;
              const { typeAnnotation: t4 } = e4.id;
              if (!t4 || !t4.typeAnnotation)
                return false;
              const n4 = fT(t4.typeAnnotation);
              return Rw(n4) && n4.length > 1 && n4.some((e5) => Rw(fT(e5)) || e5.type === "TSConditionalType");
            }(i3) || pT(i3) && Hw(r3))
              return "break-lhs";
            const c2 = function(e4, t4, n4) {
              if (!iT(e4))
                return false;
              t4 = zw(t4);
              const r4 = 3;
              return typeof t4 == "string" && Vw(t4) < n4.tabWidth + r4;
            }(i3, r3, t3);
            if (e3.call(() => function(e4, t4, n4, r4) {
              const o4 = e4.getValue();
              if (Xw(o4) && !uT(o4))
                return true;
              switch (o4.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  const { test: e5 } = o4;
                  return Xw(e5) && !uT(e5);
                }
                case "ClassExpression":
                  return Rw(o4.decorators);
              }
              if (r4)
                return false;
              let i4 = o4;
              const u4 = [];
              for (; ; )
                if (i4.type === "UnaryExpression")
                  i4 = i4.argument, u4.push("argument");
                else {
                  if (i4.type !== "TSNonNullExpression")
                    break;
                  i4 = i4.expression, u4.push("expression");
                }
              if (Yw(i4) || e4.call(() => dT(e4, t4, n4), ...u4))
                return true;
              return false;
            }(e3, t3, n3, c2), o3))
              return "break-after-operator";
            if (c2 || u3.type === "TemplateLiteral" || u3.type === "TaggedTemplateExpression" || u3.type === "BooleanLiteral" || Qw(u3) || u3.type === "ClassExpression")
              return "never-break-after-operator";
            return "fluid";
          }(e2, t2, n2, r2, i2), s2 = n2(i2, { assignmentLayout: u2 });
          switch (u2) {
            case "break-after-operator":
              return Ww([Ww(r2), o2, Ww(qw([$w, s2]))]);
            case "never-break-after-operator":
              return Ww([Ww(r2), o2, " ", s2]);
            case "fluid": {
              const e3 = Symbol("assignment");
              return Ww([Ww(r2), o2, Ww(qw($w), { id: e3 }), Uw(s2, { groupId: e3 })]);
            }
            case "break-lhs":
              return Ww([r2, o2, " ", Ww(s2)]);
            case "chain":
              return [Ww(r2), o2, $w, s2];
            case "chain-tail":
              return [Ww(r2), o2, qw([$w, s2])];
            case "chain-tail-arrow-chain":
              return [Ww(r2), o2, s2];
            case "only-left":
              return r2;
          }
        }
        function cT(e2) {
          return e2.type === "AssignmentExpression";
        }
        function lT(e2) {
          return cT(e2) || e2.type === "VariableDeclarator";
        }
        function pT(e2) {
          return e2.type === "VariableDeclarator" && e2.init && e2.init.type === "ArrowFunctionExpression";
        }
        function fT(e2) {
          return function(e3) {
            return e3.type === "TSTypeReference" || e3.type === "GenericTypeAnnotation";
          }(e2) && e2.typeParameters && e2.typeParameters.params ? e2.typeParameters.params : null;
        }
        function dT(e2, t2, n2) {
          let r2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
          const o2 = e2.getValue(), i2 = () => dT(e2, t2, n2, true);
          if (o2.type === "TSNonNullExpression")
            return e2.call(i2, "expression");
          if (Zw(o2)) {
            if (sT(e2, t2, n2).label === "member-chain")
              return false;
            const r3 = tT(o2);
            return !!(r3.length === 0 || r3.length === 1 && hT(r3[0], t2)) && (!gT(o2, n2) && e2.call(i2, "callee"));
          }
          return eT(o2) ? e2.call(i2, "object") : r2 && (o2.type === "Identifier" || o2.type === "ThisExpression");
        }
        function hT(e2, t2) {
          let { printWidth: n2 } = t2;
          if (rT(e2))
            return false;
          const r2 = 0.25 * n2;
          if (e2.type === "ThisExpression" || e2.type === "Identifier" && e2.name.length <= r2 || oT(e2) && !rT(e2.argument))
            return true;
          const o2 = e2.type === "Literal" && "regex" in e2 && e2.regex.pattern || e2.type === "RegExpLiteral" && e2.pattern;
          return o2 ? o2.length <= r2 : Yw(e2) ? nT(e2).length <= r2 : e2.type === "TemplateLiteral" ? e2.expressions.length === 0 && e2.quasis[0].value.raw.length <= r2 && !e2.quasis[0].value.raw.includes("\n") : Kw(e2);
        }
        function gT(e2, t2) {
          const n2 = function(e3) {
            return e3.typeParameters && e3.typeParameters.params || e3.typeArguments && e3.typeArguments.params;
          }(e2);
          if (Rw(n2)) {
            if (n2.length > 1)
              return true;
            if (n2.length === 1) {
              const e3 = n2[0];
              if (e3.type === "TSUnionType" || e3.type === "UnionTypeAnnotation" || e3.type === "TSIntersectionType" || e3.type === "IntersectionTypeAnnotation")
                return true;
            }
            const r2 = e2.typeParameters ? "typeParameters" : "typeArguments";
            if (Gw(t2(r2)))
              return true;
          }
          return false;
        }
        var mT = { printVariableDeclarator: function(e2, t2, n2) {
          return aT(e2, t2, n2, n2("id"), " =", "init");
        }, printAssignmentExpression: function(e2, t2, n2) {
          const r2 = e2.getValue();
          return aT(e2, t2, n2, n2("left"), [" ", r2.operator], "right");
        }, printAssignment: aT, isArrowFunctionVariableDeclarator: pT };
        const { getNextNonSpaceNonCommentCharacter: yT } = dc, { printDanglingComments: DT } = tD, { builders: { line: ET, hardline: CT, softline: bT, group: vT, indent: AT, ifBreak: FT }, utils: { removeLines: xT, willBreak: ST } } = Zc, { getFunctionParameters: wT, iterateFunctionParametersPath: TT, isSimpleType: BT, isTestCall: NT, isTypeAnnotationAFunction: kT, isObjectType: PT, isObjectTypePropertyAFunction: OT, hasRestParameter: IT, shouldPrintComma: LT, hasComment: jT, isNextLineEmpty: _T } = CC, { locEnd: MT } = og, { ArgExpansionBailout: RT } = Cp, { printFunctionTypeParameters: VT } = _x;
        function $T(e2) {
          if (!e2)
            return false;
          const t2 = wT(e2);
          if (t2.length !== 1)
            return false;
          const [n2] = t2;
          return !jT(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && PT(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && PT(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
        }
        var WT = { printFunctionParameters: function(e2, t2, n2, r2, o2) {
          const i2 = e2.getValue(), u2 = wT(i2), s2 = o2 ? VT(e2, n2, t2) : "";
          if (u2.length === 0)
            return [s2, "(", DT(e2, n2, true, (e3) => yT(n2.originalText, e3, MT) === ")"), ")"];
          const a2 = e2.getParentNode(), c2 = NT(a2), l2 = $T(i2), p2 = [];
          if (TT(e2, (e3, r3) => {
            const o3 = r3 === u2.length - 1;
            o3 && i2.rest && p2.push("..."), p2.push(t2()), o3 || (p2.push(","), c2 || l2 ? p2.push(" ") : _T(u2[r3], n2) ? p2.push(CT, CT) : p2.push(ET));
          }), r2) {
            if (ST(s2) || ST(p2))
              throw new RT();
            return vT([xT(s2), "(", xT(p2), ")"]);
          }
          const f2 = u2.every((e3) => !e3.decorators);
          return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (OT(a2) || kT(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === i2) && u2.length === 1 && u2[0].name === null && i2.this !== u2[0] && u2[0].typeAnnotation && i2.typeParameters === null && BT(u2[0].typeAnnotation) && !i2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", AT([bT, ...p2]), FT(!IT(i2) && LT(n2, "all") ? "," : ""), bT, ")"];
        }, shouldHugFunctionParameters: $T, shouldGroupFunctionParameters: function(e2, t2) {
          const n2 = function(e3) {
            let t3;
            return e3.returnType ? (t3 = e3.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e3.typeAnnotation && (t3 = e3.typeAnnotation), t3;
          }(e2);
          if (!n2)
            return false;
          const r2 = e2.typeParameters && e2.typeParameters.params;
          if (r2) {
            if (r2.length > 1)
              return false;
            if (r2.length === 1) {
              const e3 = r2[0];
              if (e3.constraint || e3.default)
                return false;
            }
          }
          return wT(e2).length === 1 && (PT(n2) || ST(t2));
        } };
        const { printComments: qT, printDanglingComments: UT } = tD, { getLast: zT, isNonEmptyArray: GT } = dc, { builders: { group: HT, join: JT, line: XT, softline: YT, indent: KT, align: QT, ifBreak: ZT } } = Zc, eB = wA, { locStart: tB } = og, { isSimpleType: nB, isObjectType: rB, hasLeadingOwnLineComment: oB, isObjectTypePropertyAFunction: iB, shouldPrintComma: uB } = CC, { printAssignment: sB } = mT, { printFunctionParameters: aB, shouldGroupFunctionParameters: cB } = WT, { printArrayItems: lB } = uS;
        function pB(e2) {
          if (nB(e2) || rB(e2))
            return true;
          if (e2.type === "UnionTypeAnnotation" || e2.type === "TSUnionType") {
            const t2 = e2.types.filter((e3) => e3.type === "VoidTypeAnnotation" || e3.type === "TSVoidKeyword" || e3.type === "NullLiteralTypeAnnotation" || e3.type === "TSNullKeyword").length, n2 = e2.types.some((e3) => e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "GenericTypeAnnotation" || e3.type === "TSTypeReference");
            if (e2.types.length - 1 === t2 && n2)
              return true;
          }
          return false;
        }
        var fB = { printOpaqueType: function(e2, t2, n2) {
          const r2 = t2.semi ? ";" : "", o2 = e2.getValue(), i2 = [];
          return i2.push("opaque type ", n2("id"), n2("typeParameters")), o2.supertype && i2.push(": ", n2("supertype")), o2.impltype && i2.push(" = ", n2("impltype")), i2.push(r2), i2;
        }, printTypeAlias: function(e2, t2, n2) {
          const r2 = t2.semi ? ";" : "", o2 = e2.getValue(), i2 = [];
          o2.declare && i2.push("declare "), i2.push("type ", n2("id"), n2("typeParameters"));
          const u2 = o2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
          return [sB(e2, t2, n2, i2, " =", u2), r2];
        }, printIntersectionType: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = e2.map(n2, "types"), i2 = [];
          let u2 = false;
          for (let e3 = 0; e3 < o2.length; ++e3)
            e3 === 0 ? i2.push(o2[e3]) : rB(r2.types[e3 - 1]) && rB(r2.types[e3]) ? i2.push([" & ", u2 ? KT(o2[e3]) : o2[e3]]) : rB(r2.types[e3 - 1]) || rB(r2.types[e3]) ? (e3 > 1 && (u2 = true), i2.push(" & ", e3 > 1 ? KT(o2[e3]) : o2[e3])) : i2.push(KT([" &", XT, o2[e3]]));
          return HT(i2);
        }, printUnionType: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = e2.getParentNode(), i2 = !(o2.type === "TypeParameterInstantiation" || o2.type === "TSTypeParameterInstantiation" || o2.type === "GenericTypeAnnotation" || o2.type === "TSTypeReference" || o2.type === "TSTypeAssertion" || o2.type === "TupleTypeAnnotation" || o2.type === "TSTupleType" || o2.type === "FunctionTypeParam" && !o2.name && e2.getParentNode(1).this !== o2 || (o2.type === "TypeAlias" || o2.type === "VariableDeclarator" || o2.type === "TSTypeAliasDeclaration") && oB(t2.originalText, r2)), u2 = pB(r2), s2 = e2.map((e3) => {
            let r3 = n2();
            return u2 || (r3 = QT(2, r3)), qT(e3, r3, t2);
          }, "types");
          if (u2)
            return JT(" | ", s2);
          const a2 = i2 && !oB(t2.originalText, r2), c2 = [ZT([a2 ? XT : "", "| "]), JT([XT, "| "], s2)];
          return eB(e2, t2) ? HT([KT(c2), YT]) : o2.type === "TupleTypeAnnotation" && o2.types.length > 1 || o2.type === "TSTupleType" && o2.elementTypes.length > 1 ? HT([KT([ZT(["(", YT]), c2]), YT, ZT(")")]) : HT(i2 ? KT(c2) : c2);
        }, printFunctionType: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [], i2 = e2.getParentNode(0), u2 = e2.getParentNode(1), s2 = e2.getParentNode(2);
          let a2 = r2.type === "TSFunctionType" || !((i2.type === "ObjectTypeProperty" || i2.type === "ObjectTypeInternalSlot") && !i2.variance && !i2.optional && tB(i2) === tB(r2) || i2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (i2.type === "TypeAnnotation" || i2.type === "TSTypeAnnotation");
          const l2 = c2 && a2 && (i2.type === "TypeAnnotation" || i2.type === "TSTypeAnnotation") && u2.type === "ArrowFunctionExpression";
          iB(i2) && (a2 = true, c2 = true), l2 && o2.push("(");
          const p2 = aB(e2, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = cB(r2, f2);
          return o2.push(d2 ? HT(p2) : p2), f2 && o2.push(f2), l2 && o2.push(")"), HT(o2);
        }, printTupleType: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "TSTupleType" ? "elementTypes" : "types", i2 = r2[o2], u2 = GT(i2), s2 = u2 && zT(i2).type === "TSRestType", a2 = u2 ? YT : "";
          return HT(["[", KT([a2, lB(e2, t2, o2, n2)]), ZT(u2 && uB(t2, "all") && !s2 ? "," : ""), UT(e2, t2, true), a2, "]"]);
        }, printIndexedAccessType: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
          return [n2("objectType"), o2, n2("indexType"), "]"];
        }, shouldHugType: pB };
        const { printDanglingComments: dB } = tD, { builders: { join: hB, line: gB, hardline: mB, softline: yB, group: DB, indent: EB, ifBreak: CB } } = Zc, { isTestCall: bB, hasComment: vB, CommentCheckFlags: AB, isTSXFile: FB, shouldPrintComma: xB, getFunctionParameters: SB, isObjectType: wB } = CC, { createGroupIdMapper: TB } = dc, { shouldHugType: BB } = fB, { isArrowFunctionVariableDeclarator: NB } = mT, kB = TB("typeParameters");
        function PB(e2, t2) {
          const n2 = e2.getValue();
          if (!vB(n2, AB.Dangling))
            return "";
          const r2 = !vB(n2, AB.Line), o2 = dB(e2, t2, r2);
          return r2 ? o2 : [o2, mB];
        }
        var OB = { printTypeParameter: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [], i2 = e2.getParentNode();
          return i2.type === "TSMappedType" ? (o2.push("[", n2("name")), r2.constraint && o2.push(" in ", n2("constraint")), i2.nameType && o2.push(" as ", e2.callParent(() => n2("nameType"))), o2.push("]"), o2) : (r2.variance && o2.push(n2("variance")), o2.push(n2("name")), r2.bound && o2.push(": ", n2("bound")), r2.constraint && o2.push(" extends ", n2("constraint")), r2.default && o2.push(" = ", n2("default")), o2);
        }, printTypeParameters: function(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          if (!o2[r2])
            return "";
          if (!Array.isArray(o2[r2]))
            return n2(r2);
          const i2 = e2.getNode(2), u2 = i2 && bB(i2), s2 = e2.match((e3) => !(e3[r2].length === 1 && wB(e3[r2][0])), void 0, (e3, t3) => t3 === "typeAnnotation", (e3) => e3.type === "Identifier", NB);
          if (!s2 && (u2 || o2[r2].length === 0 || o2[r2].length === 1 && (o2[r2][0].type === "NullableTypeAnnotation" || BB(o2[r2][0]))))
            return ["<", hB(", ", e2.map(n2, r2)), PB(e2, t2), ">"];
          const a2 = o2.type === "TSTypeParameterInstantiation" ? "" : SB(o2).length === 1 && FB(t2) && !o2[r2][0].constraint && e2.getParentNode().type === "ArrowFunctionExpression" ? "," : xB(t2, "all") ? CB(",") : "";
          return DB(["<", EB([yB, hB([",", gB], e2.map(n2, r2))]), a2, yB, ">"], { id: kB(o2) });
        }, getTypeParametersGroupId: kB };
        const { printComments: IB } = tD, { printString: LB, printNumber: jB } = dc, { isNumericLiteral: _B, isSimpleNumber: MB, isStringLiteral: RB, isStringPropSafeToUnquote: VB, rawText: $B } = CC, { printAssignment: WB } = mT, qB = /* @__PURE__ */ new WeakMap();
        function UB(e2, t2, n2) {
          const r2 = e2.getNode();
          if (r2.computed)
            return ["[", n2("key"), "]"];
          const o2 = e2.getParentNode(), { key: i2 } = r2;
          if (r2.type === "ClassPrivateProperty" && i2.type === "Identifier")
            return ["#", n2("key")];
          if (t2.quoteProps === "consistent" && !qB.has(o2)) {
            const e3 = (o2.properties || o2.body || o2.members).some((e4) => !e4.computed && e4.key && RB(e4.key) && !VB(e4, t2));
            qB.set(o2, e3);
          }
          if ((i2.type === "Identifier" || _B(i2) && MB(jB($B(i2))) && String(i2.value) === jB($B(i2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && qB.get(o2))) {
            const n3 = LB(JSON.stringify(i2.type === "Identifier" ? i2.name : i2.value.toString()), t2);
            return e2.call((e3) => IB(e3, n3, t2), "key");
          }
          return VB(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !qB.get(o2)) ? e2.call((e3) => IB(e3, /^\d/.test(i2.value) ? jB(i2.value) : i2.value, t2), "key") : n2("key");
        }
        var zB = { printProperty: function(e2, t2, n2) {
          return e2.getValue().shorthand ? n2("value") : WB(e2, t2, n2, UB(e2, t2, n2), ":", "value");
        }, printPropertyKey: UB };
        const GB = Ty, { printDanglingComments: HB, printCommentsSeparately: JB } = tD, XB = au, { getNextNonSpaceNonCommentCharacterIndex: YB } = dc, { builders: { line: KB, softline: QB, group: ZB, indent: eN, ifBreak: tN, hardline: nN, join: rN, indentIfBreak: oN }, utils: { removeLines: iN, willBreak: uN } } = Zc, { ArgExpansionBailout: sN } = Cp, { getFunctionParameters: aN, hasLeadingOwnLineComment: cN, isFlowAnnotationComment: lN, isJsxNode: pN, isTemplateOnItsOwnLine: fN, shouldPrintComma: dN, startsWithNoLookaheadToken: hN, isBinaryish: gN, isLineComment: mN, hasComment: yN, getComments: DN, CommentCheckFlags: EN, isCallLikeExpression: CN, isCallExpression: bN, getCallArguments: vN, hasNakedLeftSide: AN, getLeftSide: FN } = CC, { locEnd: xN } = og, { printFunctionParameters: SN, shouldGroupFunctionParameters: wN } = WT, { printPropertyKey: TN } = zB, { printFunctionTypeParameters: BN } = _x;
        function NN(e2, t2, n2) {
          const r2 = e2.getNode(), o2 = SN(e2, n2, t2), i2 = PN(e2, n2, t2), u2 = wN(r2, i2), s2 = [BN(e2, t2, n2), ZB([u2 ? ZB(o2) : o2, i2])];
          return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
        }
        function kN(e2, t2) {
          if (t2.arrowParens === "always")
            return false;
          if (t2.arrowParens === "avoid") {
            return function(e3) {
              const t3 = aN(e3);
              return !(t3.length !== 1 || e3.typeParameters || yN(e3, EN.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || yN(t3[0]) || t3[0].optional || e3.predicate || e3.returnType);
            }(e2.getValue());
          }
          return false;
        }
        function PN(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2("returnType");
          if (r2.returnType && lN(n2.originalText, r2.returnType))
            return [" /*: ", o2, " */"];
          const i2 = [o2];
          return r2.returnType && r2.returnType.typeAnnotation && i2.unshift(": "), r2.predicate && i2.push(r2.returnType ? " " : ": ", t2("predicate")), i2;
        }
        function ON(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2.semi ? ";" : "", i2 = [];
          r2.argument && (!function(e3, t3) {
            if (cN(e3.originalText, t3))
              return true;
            if (AN(t3)) {
              let n3, r3 = t3;
              for (; n3 = FN(r3); )
                if (r3 = n3, cN(e3.originalText, r3))
                  return true;
            }
            return false;
          }(t2, r2.argument) ? gN(r2.argument) || r2.argument.type === "SequenceExpression" ? i2.push(ZB([tN(" (", " "), eN([QB, n2("argument")]), QB, tN(")")])) : i2.push(" ", n2("argument")) : i2.push([" (", eN([nN, n2("argument")]), nN, ")"]));
          const u2 = DN(r2), s2 = XB(u2), a2 = s2 && mN(s2);
          return a2 && i2.push(o2), yN(r2, EN.Dangling) && i2.push(" ", HB(e2, t2, true)), a2 || i2.push(o2), i2;
        }
        var IN = { printFunction: function(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          let i2 = false;
          if ((o2.type === "FunctionDeclaration" || o2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
            const t3 = e2.getParentNode();
            bN(t3) && vN(t3).length > 1 && (i2 = true);
          }
          const u2 = [];
          o2.type === "TSDeclareFunction" && o2.declare && u2.push("declare "), o2.async && u2.push("async "), o2.generator ? u2.push("function* ") : u2.push("function "), o2.id && u2.push(t2("id"));
          const s2 = SN(e2, t2, n2, i2), a2 = PN(e2, t2, n2), c2 = wN(o2, a2);
          return u2.push(BN(e2, n2, t2), ZB([c2 ? ZB(s2) : s2, a2]), o2.body ? " " : "", t2("body")), !n2.semi || !o2.declare && o2.body || u2.push(";"), u2;
        }, printArrowFunction: function(e2, t2, n2, r2) {
          let o2 = e2.getValue();
          const i2 = [], u2 = [];
          let s2 = false;
          if (function a3() {
            const c3 = function(e3, t3, n3, r3) {
              const o3 = [];
              if (e3.getValue().async && o3.push("async "), kN(e3, t3))
                o3.push(n3(["params", 0]));
              else {
                const i4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
                let u3 = PN(e3, n3, t3);
                if (i4) {
                  if (uN(u3))
                    throw new sN();
                  u3 = ZB(iN(u3));
                }
                o3.push(ZB([SN(e3, n3, t3, i4, true), u3]));
              }
              const i3 = HB(e3, t3, true, (e4) => {
                const n4 = YB(t3.originalText, e4, xN);
                return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
              });
              return i3 && o3.push(" ", i3), o3;
            }(e2, t2, n2, r2);
            if (i2.length === 0)
              i2.push(c3);
            else {
              const { leading: n3, trailing: r3 } = JB(e2, t2);
              i2.push([n3, c3]), u2.unshift(r3);
            }
            s2 = s2 || o2.returnType && aN(o2).length > 0 || o2.typeParameters || aN(o2).some((e3) => e3.type !== "Identifier"), o2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? u2.unshift(n2("body", r2)) : (o2 = o2.body, e2.call(a3, "body"));
          }(), i2.length > 1)
            return function(e3, t3, n3, r3, o3, i3) {
              const u3 = e3.getName(), s3 = e3.getParentNode(), a3 = CN(s3) && u3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = i3.body.type !== "BlockStatement" && i3.body.type !== "ObjectExpression" && i3.body.type !== "SequenceExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
              return i3.body.type === "SequenceExpression" && (o3 = ZB(["(", eN([QB, o3]), QB, ")"])), ZB([ZB(eN([a3 || c3 ? QB : "", ZB(rN([" =>", KB], n3), { shouldBreak: r3 })]), { id: f2, shouldBreak: p3 }), " =>", oN(l3 ? eN([KB, o3]) : [" ", o3], { groupId: f2 }), a3 ? tN(QB, "", { groupId: f2 }) : ""]);
            }(e2, r2, i2, s2, u2, o2);
          const a2 = i2;
          if (a2.push(" =>"), !cN(t2.originalText, o2.body) && (o2.body.type === "ArrayExpression" || o2.body.type === "ObjectExpression" || o2.body.type === "BlockStatement" || pN(o2.body) || fN(o2.body, t2.originalText) || o2.body.type === "ArrowFunctionExpression" || o2.body.type === "DoExpression"))
            return ZB([...a2, " ", u2]);
          if (o2.body.type === "SequenceExpression")
            return ZB([...a2, ZB([" (", eN([QB, u2]), QB, ")"])]);
          const c2 = (r2 && r2.expandLastArg || e2.getParentNode().type === "JSXExpressionContainer") && !yN(o2), l2 = r2 && r2.expandLastArg && dN(t2, "all"), p2 = o2.body.type === "ConditionalExpression" && !hN(o2.body, false);
          return ZB([...a2, ZB([eN([KB, p2 ? tN("", "(") : "", u2, p2 ? tN("", ")") : ""]), c2 ? [tN(l2 ? "," : ""), QB] : ""])]);
        }, printMethod: function(e2, t2, n2) {
          const r2 = e2.getNode(), { kind: o2 } = r2, i2 = r2.value || r2, u2 = [];
          return o2 && o2 !== "init" && o2 !== "method" && o2 !== "constructor" ? (GB.ok(o2 === "get" || o2 === "set"), u2.push(o2, " ")) : i2.async && u2.push("async "), i2.generator && u2.push("*"), u2.push(TN(e2, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === i2 ? u2.push(NN(e2, t2, n2)) : i2.type === "FunctionExpression" ? u2.push(e2.call((e3) => NN(e3, t2, n2), "value")) : u2.push(n2("value")), u2;
        }, printReturnStatement: function(e2, t2, n2) {
          return ["return", ON(e2, t2, n2)];
        }, printThrowStatement: function(e2, t2, n2) {
          return ["throw", ON(e2, t2, n2)];
        }, printMethodInternal: NN, shouldPrintParamsWithoutParens: kN };
        const { isNonEmptyArray: LN, hasNewline: jN } = dc, { builders: { line: _N, hardline: MN, join: RN, breakParent: VN, group: $N } } = Zc, { locStart: WN, locEnd: qN } = og, { getParentExportDeclaration: UN } = CC;
        function zN(e2, t2) {
          return e2.decorators.some((e3) => jN(t2.originalText, qN(e3)));
        }
        function GN(e2) {
          if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
            return false;
          const t2 = e2.declaration && e2.declaration.decorators;
          return LN(t2) && WN(e2, { ignoreDecorators: true }) > WN(t2[0]);
        }
        var HN = { printDecorators: function(e2, t2, n2) {
          const r2 = e2.getValue(), { decorators: o2 } = r2;
          if (!LN(o2) || GN(e2.getParentNode()))
            return;
          const i2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || zN(r2, t2);
          return [UN(e2) ? MN : i2 ? VN : "", RN(_N, e2.map(n2, "decorators")), _N];
        }, printClassMemberDecorators: function(e2, t2, n2) {
          const r2 = e2.getValue();
          return $N([RN(_N, e2.map(n2, "decorators")), zN(r2, t2) ? MN : _N]);
        }, printDecoratorsBeforeExport: function(e2, t2, n2) {
          return [RN(MN, e2.map(n2, "declaration", "decorators")), MN];
        }, hasDecoratorsBeforeExport: GN };
        const { isNonEmptyArray: JN, createGroupIdMapper: XN } = dc, { printComments: YN, printDanglingComments: KN } = tD, { builders: { join: QN, line: ZN, hardline: ek, softline: tk, group: nk, indent: rk, ifBreak: ok } } = Zc, { hasComment: ik, CommentCheckFlags: uk } = CC, { getTypeParametersGroupId: sk } = OB, { printMethod: ak } = IN, { printOptionalToken: ck, printTypeAnnotation: lk } = _x, { printPropertyKey: pk } = zB, { printAssignment: fk } = mT, { printClassMemberDecorators: dk } = HN;
        const hk = XN("heritageGroup");
        function gk(e2) {
          return e2.typeParameters && !ik(e2.typeParameters, uk.Trailing | uk.Line) && !function(e3) {
            return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e3[t2])).length > 1;
          }(e2);
        }
        function mk(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          if (!JN(o2[r2]))
            return "";
          const i2 = KN(e2, t2, true, (e3) => {
            let { marker: t3 } = e3;
            return t3 === r2;
          });
          return [gk(o2) ? ok(" ", ZN, { groupId: sk(o2.typeParameters) }) : ZN, i2, i2 && ek, r2, nk(rk([ZN, QN([",", ZN], e2.map(n2, r2))]))];
        }
        function yk(e2, t2, n2) {
          const r2 = n2("superClass");
          return e2.getParentNode().type === "AssignmentExpression" ? nk(ok(["(", rk([tk, r2]), tk, ")"], r2)) : r2;
        }
        var Dk = { printClass: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          r2.declare && o2.push("declare "), r2.abstract && o2.push("abstract "), o2.push("class");
          const i2 = r2.id && ik(r2.id, uk.Trailing) || r2.superClass && ik(r2.superClass) || JN(r2.extends) || JN(r2.mixins) || JN(r2.implements), u2 = [], s2 = [];
          if (r2.id && u2.push(" ", n2("id")), u2.push(n2("typeParameters")), r2.superClass) {
            const r3 = ["extends ", yk(e2, t2, n2), n2("superTypeParameters")], o3 = e2.call((e3) => YN(e3, r3, t2), "superClass");
            i2 ? s2.push(ZN, nk(o3)) : s2.push(" ", o3);
          } else
            s2.push(mk(e2, t2, n2, "extends"));
          if (s2.push(mk(e2, t2, n2, "mixins"), mk(e2, t2, n2, "implements")), i2) {
            let e3;
            e3 = gk(r2) ? [...u2, rk(s2)] : rk([...u2, s2]), o2.push(nk(e3, { id: hk(r2) }));
          } else
            o2.push(...u2, ...s2);
          return o2.push(" ", n2("body")), o2;
        }, printClassMethod: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          return JN(r2.decorators) && o2.push(dk(e2, t2, n2)), r2.accessibility && o2.push(r2.accessibility + " "), r2.readonly && o2.push("readonly "), r2.declare && o2.push("declare "), r2.static && o2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && o2.push("abstract "), r2.override && o2.push("override "), o2.push(ak(e2, t2, n2)), o2;
        }, printClassProperty: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [], i2 = t2.semi ? ";" : "";
          return JN(r2.decorators) && o2.push(dk(e2, t2, n2)), r2.accessibility && o2.push(r2.accessibility + " "), r2.declare && o2.push("declare "), r2.static && o2.push("static "), (r2.type === "TSAbstractPropertyDefinition" || r2.abstract) && o2.push("abstract "), r2.override && o2.push("override "), r2.readonly && o2.push("readonly "), r2.variance && o2.push(n2("variance")), o2.push(pk(e2, t2, n2), ck(e2), lk(e2, t2, n2)), [fk(e2, t2, n2, o2, " =", "value"), i2];
        }, printHardlineAfterHeritage: function(e2) {
          return ok(ek, "", { groupId: hk(e2) });
        } };
        const { isNonEmptyArray: Ek } = dc, { builders: { join: Ck, line: bk, group: vk, indent: Ak, ifBreak: Fk } } = Zc, { hasComment: xk, identity: Sk, CommentCheckFlags: wk } = CC, { getTypeParametersGroupId: Tk } = OB, { printTypeScriptModifiers: Bk } = _x;
        var Nk = { printInterface: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          r2.declare && o2.push("declare "), r2.type === "TSInterfaceDeclaration" && o2.push(r2.abstract ? "abstract " : "", Bk(e2, t2, n2)), o2.push("interface");
          const i2 = [], u2 = [];
          r2.type !== "InterfaceTypeAnnotation" && i2.push(" ", n2("id"), n2("typeParameters"));
          const s2 = r2.typeParameters && !xk(r2.typeParameters, wk.Trailing | wk.Line);
          return Ek(r2.extends) && u2.push(s2 ? Fk(" ", bk, { groupId: Tk(r2.typeParameters) }) : bk, "extends ", (r2.extends.length === 1 ? Sk : Ak)(Ck([",", bk], e2.map(n2, "extends")))), r2.id && xk(r2.id, wk.Trailing) || Ek(r2.extends) ? s2 ? o2.push(vk([...i2, Ak(u2)])) : o2.push(vk(Ak([...i2, ...u2]))) : o2.push(...i2, ...u2), o2.push(" ", n2("body")), vk(o2);
        } };
        const { isNonEmptyArray: kk } = dc, { builders: { softline: Pk, group: Ok, indent: Ik, join: Lk, line: jk, ifBreak: _k, hardline: Mk } } = Zc, { printDanglingComments: Rk } = tD, { hasComment: Vk, CommentCheckFlags: $k, shouldPrintComma: Wk, needsHardlineAfterDanglingComment: qk } = CC, { locStart: Uk, hasSameLoc: zk } = og, { hasDecoratorsBeforeExport: Gk, printDecoratorsBeforeExport: Hk } = HN;
        function Jk(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2.source)
            return "";
          const o2 = [];
          return Yk(r2, t2) || o2.push(" from"), o2.push(" ", n2("source")), o2;
        }
        function Xk(e2, t2, n2) {
          const r2 = e2.getValue();
          if (Yk(r2, t2))
            return "";
          const o2 = [" "];
          if (kk(r2.specifiers)) {
            const i2 = [], u2 = [];
            if (e2.each(() => {
              const t3 = e2.getValue().type;
              if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
                i2.push(n2());
              else {
                if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
                  throw new Error("Unknown specifier type ".concat(JSON.stringify(t3)));
                u2.push(n2());
              }
            }, "specifiers"), o2.push(Lk(", ", i2)), u2.length > 0) {
              i2.length > 0 && o2.push(", ");
              u2.length > 1 || i2.length > 0 || r2.specifiers.some((e3) => Vk(e3)) ? o2.push(Ok(["{", Ik([t2.bracketSpacing ? jk : Pk, Lk([",", jk], u2)]), _k(Wk(t2) ? "," : ""), t2.bracketSpacing ? jk : Pk, "}"])) : o2.push(["{", t2.bracketSpacing ? " " : "", ...u2, t2.bracketSpacing ? " " : "", "}"]);
            }
          } else
            o2.push("{}");
          return o2;
        }
        function Yk(e2, t2) {
          const { type: n2, importKind: r2, source: o2, specifiers: i2 } = e2;
          return n2 === "ImportDeclaration" && !kk(i2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(Uk(e2), Uk(o2)));
        }
        function Kk(e2, t2, n2) {
          const r2 = e2.getNode();
          return kk(r2.assertions) ? [" assert {", t2.bracketSpacing ? " " : "", Lk(", ", e2.map(n2, "assertions")), t2.bracketSpacing ? " " : "", "}"] : "";
        }
        var Qk = { printImportDeclaration: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2.semi ? ";" : "", i2 = [], { importKind: u2 } = r2;
          return i2.push("import"), u2 && u2 !== "value" && i2.push(" ", u2), i2.push(Xk(e2, t2, n2), Jk(e2, t2, n2), Kk(e2, t2, n2), o2), i2;
        }, printExportDeclaration: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          Gk(r2) && o2.push(Hk(e2, t2, n2));
          const { type: i2, exportKind: u2, declaration: s2 } = r2;
          return o2.push("export"), (r2.default || i2 === "ExportDefaultDeclaration") && o2.push(" default"), Vk(r2, $k.Dangling) && (o2.push(" ", Rk(e2, t2, true)), qk(r2) && o2.push(Mk)), s2 ? o2.push(" ", n2("declaration")) : o2.push(u2 === "type" ? " type" : "", Xk(e2, t2, n2), Jk(e2, t2, n2), Kk(e2, t2, n2)), function(e3, t3) {
            if (!t3.semi)
              return false;
            const { type: n3, declaration: r3 } = e3, o3 = e3.default || n3 === "ExportDefaultDeclaration";
            if (!r3)
              return true;
            const { type: i3 } = r3;
            if (o3 && i3 !== "ClassDeclaration" && i3 !== "FunctionDeclaration" && i3 !== "TSInterfaceDeclaration" && i3 !== "DeclareClass" && i3 !== "DeclareFunction" && i3 !== "TSDeclareFunction" && i3 !== "EnumDeclaration")
              return true;
            return false;
          }(r2, t2) && o2.push(";"), o2;
        }, printExportAllDeclaration: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2.semi ? ";" : "", i2 = [], { exportKind: u2, exported: s2 } = r2;
          return i2.push("export"), u2 === "type" && i2.push(" type"), i2.push(" *"), s2 && i2.push(" as ", n2("exported")), i2.push(Jk(e2, t2, n2), Kk(e2, t2, n2), o2), i2;
        }, printModuleSpecifier: function(e2, t2, n2) {
          const r2 = e2.getNode(), { type: o2 } = r2, i2 = [], u2 = o2 === "ImportSpecifier" ? r2.importKind : r2.exportKind;
          u2 && u2 !== "value" && i2.push(u2, " ");
          const s2 = o2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
          let l2 = "", p2 = "";
          return o2 === "ExportNamespaceSpecifier" || o2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && zk(r2[a2], r2[c2]) || (p2 = n2(c2)), i2.push(l2, l2 && p2 ? " as " : "", p2), i2;
        } };
        const { printDanglingComments: Zk } = tD, { builders: { line: eP, softline: tP, group: nP, indent: rP, ifBreak: oP, hardline: iP } } = Zc, { getLast: uP, hasNewlineInRange: sP, hasNewline: aP, isNonEmptyArray: cP } = dc, { shouldPrintComma: lP, hasComment: pP, getComments: fP, CommentCheckFlags: dP, isNextLineEmpty: hP } = CC, { locStart: gP, locEnd: mP } = og, { printOptionalToken: yP, printTypeAnnotation: DP } = _x, { shouldHugFunctionParameters: EP } = WT, { shouldHugType: CP } = fB, { printHardlineAfterHeritage: bP } = Dk;
        var vP = { printObject: function(e2, t2, n2) {
          const r2 = t2.semi ? ";" : "", o2 = e2.getValue();
          let i2;
          i2 = o2.type === "TSTypeLiteral" ? "members" : o2.type === "TSInterfaceBody" ? "body" : "properties";
          const u2 = o2.type === "ObjectTypeAnnotation", s2 = [i2];
          u2 && s2.push("indexers", "callProperties", "internalSlots");
          const a2 = s2.map((e3) => o2[e3][0]).sort((e3, t3) => gP(e3) - gP(t3))[0], c2 = e2.getParentNode(0), l2 = u2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e2.getName() === "body", p2 = o2.type === "TSInterfaceBody" || l2 || o2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && o2.properties.some((e3) => e3.value && (e3.value.type === "ObjectPattern" || e3.value.type === "ArrayPattern")) || o2.type !== "ObjectPattern" && a2 && sP(t2.originalText, gP(o2), gP(a2)), f2 = l2 ? ";" : o2.type === "TSInterfaceBody" || o2.type === "TSTypeLiteral" ? oP(r2, ";") : ",", d2 = o2.type === "RecordExpression" ? "#{" : o2.exact ? "{|" : "{", h2 = o2.exact ? "|}" : "}", g2 = [];
          for (const t3 of s2)
            e2.each((e3) => {
              const t4 = e3.getValue();
              g2.push({ node: t4, printed: n2(), loc: gP(t4) });
            }, t3);
          s2.length > 1 && g2.sort((e3, t3) => e3.loc - t3.loc);
          let m2 = [];
          const y2 = g2.map((e3) => {
            const n3 = [...m2, nP(e3.printed)];
            return m2 = [f2, eP], e3.node.type !== "TSPropertySignature" && e3.node.type !== "TSMethodSignature" && e3.node.type !== "TSConstructSignatureDeclaration" || !pP(e3.node, dP.PrettierIgnore) || m2.shift(), hP(e3.node, t2) && m2.push(iP), n3;
          });
          if (o2.inexact) {
            let n3;
            if (pP(o2, dP.Dangling)) {
              const r3 = pP(o2, dP.Line);
              n3 = [Zk(e2, t2, true), r3 || aP(t2.originalText, mP(uP(fP(o2)))) ? iP : eP, "..."];
            } else
              n3 = ["..."];
            y2.push([...m2, ...n3]);
          }
          const D2 = uP(o2[i2]), E2 = !(o2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && pP(D2, dP.PrettierIgnore));
          let C2;
          if (y2.length === 0) {
            if (!pP(o2, dP.Dangling))
              return [d2, h2, DP(e2, t2, n2)];
            C2 = nP([d2, Zk(e2, t2), tP, h2, yP(e2), DP(e2, t2, n2)]);
          } else
            C2 = [l2 && cP(o2.properties) ? bP(c2) : "", d2, rP([t2.bracketSpacing ? eP : tP, ...y2]), oP(E2 && (f2 !== "," || lP(t2)) ? f2 : ""), t2.bracketSpacing ? eP : tP, h2, yP(e2), DP(e2, t2, n2)];
          return e2.match((e3) => e3.type === "ObjectPattern" && !e3.decorators, (e3, t3, n3) => EP(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e2.match(CP, (e3, t3) => t3 === "typeAnnotation", (e3, t3) => t3 === "typeAnnotation", (e3, t3, n3) => EP(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e2.match((e3) => e3.type === "ObjectPattern", (e3) => e3.type === "AssignmentExpression" || e3.type === "VariableDeclarator") ? C2 : nP(C2, { shouldBreak: p2 });
        } };
        const AP = Ty, { printDanglingComments: FP } = tD, { printString: xP, printNumber: SP } = dc, { builders: { hardline: wP, softline: TP, group: BP, indent: NP } } = Zc, { getParentExportDeclaration: kP, isFunctionNotation: PP, isGetterOrSetter: OP, rawText: IP, shouldPrintComma: LP } = CC, { locStart: jP, locEnd: _P } = og, { printClass: MP } = Dk, { printOpaqueType: RP, printTypeAlias: VP, printIntersectionType: $P, printUnionType: WP, printFunctionType: qP, printTupleType: UP, printIndexedAccessType: zP } = fB, { printInterface: GP } = Nk, { printTypeParameter: HP, printTypeParameters: JP } = OB, { printExportDeclaration: XP, printExportAllDeclaration: YP } = Qk, { printArrayItems: KP } = uS, { printObject: QP } = vP, { printPropertyKey: ZP } = zB, { printOptionalToken: eO, printTypeAnnotation: tO, printRestSpread: nO } = _x;
        function rO(e2, t2) {
          const n2 = kP(e2);
          return n2 ? (AP.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
        }
        var oO = { printFlow: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2.semi ? ";" : "", i2 = [];
          switch (r2.type) {
            case "DeclareClass":
              return rO(e2, MP(e2, t2, n2));
            case "DeclareFunction":
              return rO(e2, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), o2]);
            case "DeclareModule":
              return rO(e2, ["module ", n2("id"), " ", n2("body")]);
            case "DeclareModuleExports":
              return rO(e2, ["module.exports", ": ", n2("typeAnnotation"), o2]);
            case "DeclareVariable":
              return rO(e2, ["var ", n2("id"), o2]);
            case "DeclareOpaqueType":
              return rO(e2, RP(e2, t2, n2));
            case "DeclareInterface":
              return rO(e2, GP(e2, t2, n2));
            case "DeclareTypeAlias":
              return rO(e2, VP(e2, t2, n2));
            case "DeclareExportDeclaration":
              return rO(e2, XP(e2, t2, n2));
            case "DeclareExportAllDeclaration":
              return rO(e2, YP(e2, t2, n2));
            case "OpaqueType":
              return RP(e2, t2, n2);
            case "TypeAlias":
              return VP(e2, t2, n2);
            case "IntersectionTypeAnnotation":
              return $P(e2, t2, n2);
            case "UnionTypeAnnotation":
              return WP(e2, t2, n2);
            case "FunctionTypeAnnotation":
              return qP(e2, t2, n2);
            case "TupleTypeAnnotation":
              return UP(e2, t2, n2);
            case "GenericTypeAnnotation":
              return [n2("id"), JP(e2, t2, n2, "typeParameters")];
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              return zP(e2, t2, n2);
            case "TypeAnnotation":
              return n2("typeAnnotation");
            case "TypeParameter":
              return HP(e2, t2, n2);
            case "TypeofTypeAnnotation":
              return ["typeof ", n2("argument")];
            case "ExistsTypeAnnotation":
              return "*";
            case "EmptyTypeAnnotation":
              return "empty";
            case "MixedTypeAnnotation":
              return "mixed";
            case "ArrayTypeAnnotation":
              return [n2("elementType"), "[]"];
            case "BooleanLiteralTypeAnnotation":
              return String(r2.value);
            case "EnumDeclaration":
              return ["enum ", n2("id"), " ", n2("body")];
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              if (r2.type === "EnumSymbolBody" || r2.explicitType) {
                let e3 = null;
                switch (r2.type) {
                  case "EnumBooleanBody":
                    e3 = "boolean";
                    break;
                  case "EnumNumberBody":
                    e3 = "number";
                    break;
                  case "EnumStringBody":
                    e3 = "string";
                    break;
                  case "EnumSymbolBody":
                    e3 = "symbol";
                }
                i2.push("of ", e3, " ");
              }
              if (r2.members.length !== 0 || r2.hasUnknownMembers) {
                const o3 = r2.members.length > 0 ? [wP, KP(e2, t2, "members", n2), r2.hasUnknownMembers || LP(t2) ? "," : ""] : [];
                i2.push(BP(["{", NP([...o3, ...r2.hasUnknownMembers ? [wP, "..."] : []]), FP(e2, t2, true), wP, "}"]));
              } else
                i2.push(BP(["{", FP(e2, t2), TP, "}"]));
              return i2;
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
              return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
            case "EnumDefaultedMember":
              return n2("id");
            case "FunctionTypeParam": {
              const t3 = r2.name ? n2("name") : e2.getParentNode().this === r2 ? "this" : "";
              return [t3, eO(e2), t3 ? ": " : "", n2("typeAnnotation")];
            }
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
              return GP(e2, t2, n2);
            case "ClassImplements":
            case "InterfaceExtends":
              return [n2("id"), n2("typeParameters")];
            case "NullableTypeAnnotation":
              return ["?", n2("typeAnnotation")];
            case "Variance": {
              const { kind: e3 } = r2;
              return AP.ok(e3 === "plus" || e3 === "minus"), e3 === "plus" ? "+" : "-";
            }
            case "ObjectTypeCallProperty":
              return r2.static && i2.push("static "), i2.push(n2("value")), i2;
            case "ObjectTypeIndexer":
              return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
            case "ObjectTypeProperty": {
              let o3 = "";
              return r2.proto ? o3 = "proto " : r2.static && (o3 = "static "), [o3, OP(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", ZP(e2, t2, n2), eO(e2), PP(r2) ? "" : ": ", n2("value")];
            }
            case "ObjectTypeAnnotation":
              return QP(e2, t2, n2);
            case "ObjectTypeInternalSlot":
              return [r2.static ? "static " : "", "[[", n2("id"), "]]", eO(e2), r2.method ? "" : ": ", n2("value")];
            case "ObjectTypeSpreadProperty":
              return nO(e2, t2, n2);
            case "QualifiedTypeIdentifier":
              return [n2("qualification"), ".", n2("id")];
            case "StringLiteralTypeAnnotation":
              return xP(IP(r2), t2);
            case "NumberLiteralTypeAnnotation":
              AP.strictEqual(typeof r2.value, "number");
            case "BigIntLiteralTypeAnnotation":
              return r2.extra ? SP(r2.extra.raw) : SP(r2.raw);
            case "TypeCastExpression":
              return ["(", n2("expression"), tO(e2, t2, n2), ")"];
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation": {
              const o3 = JP(e2, t2, n2, "params");
              if (t2.parser === "flow") {
                const e3 = jP(r2), n3 = _P(r2), i3 = t2.originalText.lastIndexOf("/*", e3), u2 = t2.originalText.indexOf("*/", n3);
                if (i3 !== -1 && u2 !== -1) {
                  const e4 = t2.originalText.slice(i3 + 2, u2).trim();
                  if (e4.startsWith("::") && !e4.includes("/*") && !e4.includes("*/"))
                    return ["/*:: ", o3, " */"];
                }
              }
              return o3;
            }
            case "InferredPredicate":
              return "%checks";
            case "DeclaredPredicate":
              return ["%checks(", n2("value"), ")"];
            case "AnyTypeAnnotation":
              return "any";
            case "BooleanTypeAnnotation":
              return "boolean";
            case "BigIntTypeAnnotation":
              return "bigint";
            case "NullLiteralTypeAnnotation":
              return "null";
            case "NumberTypeAnnotation":
              return "number";
            case "SymbolTypeAnnotation":
              return "symbol";
            case "StringTypeAnnotation":
              return "string";
            case "VoidTypeAnnotation":
              return "void";
            case "ThisTypeAnnotation":
              return "this";
            case "Node":
            case "Printable":
            case "SourceLocation":
            case "Position":
            case "Statement":
            case "Function":
            case "Pattern":
            case "Expression":
            case "Declaration":
            case "Specifier":
            case "NamedSpecifier":
            case "Comment":
            case "MemberTypeAnnotation":
            case "Type":
              throw new Error("unprintable type: " + JSON.stringify(r2.type));
          }
        } };
        const { hasNewlineInRange: iO } = dc, { isJsxNode: uO, isBlockComment: sO, getComments: aO, isCallExpression: cO, isMemberExpression: lO } = CC, { locStart: pO, locEnd: fO } = og, { builders: { line: dO, softline: hO, group: gO, indent: mO, align: yO, ifBreak: DO, dedent: EO, breakParent: CO } } = Zc;
        function bO(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "ConditionalExpression", i2 = o2 ? "alternate" : "falseType", u2 = e2.getParentNode(), s2 = o2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
          return u2.type === r2.type && u2[i2] === r2 ? yO(2, s2) : s2;
        }
        const vO = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
        var AO = { printTernary: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "ConditionalExpression", i2 = o2 ? "consequent" : "trueType", u2 = o2 ? "alternate" : "falseType", s2 = o2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[i2], c2 = r2[u2], l2 = [];
          let p2 = false;
          const f2 = e2.getParentNode(), d2 = f2.type === r2.type && s2.some((e3) => f2[e3] === r2);
          let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
          do {
            g2 = h2 || r2, h2 = e2.getParentNode(y2), y2++;
          } while (h2 && h2.type === r2.type && s2.every((e3) => h2[e3] !== g2));
          const D2 = h2 || f2, E2 = g2;
          if (o2 && (uO(r2[s2[0]]) || uO(a2) || uO(c2) || function(e3) {
            const t3 = [e3];
            for (let e4 = 0; e4 < t3.length; e4++) {
              const n3 = t3[e4];
              for (const e5 of ["test", "consequent", "alternate"]) {
                const r3 = n3[e5];
                if (uO(r3))
                  return true;
                r3.type === "ConditionalExpression" && t3.push(r3);
              }
            }
            return false;
          }(E2))) {
            p2 = true, m2 = true;
            const e3 = (e4) => [DO("("), mO([hO, e4]), hO, DO(")")], t3 = (e4) => e4.type === "NullLiteral" || e4.type === "Literal" && e4.value === null || e4.type === "Identifier" && e4.name === "undefined";
            l2.push(" ? ", t3(a2) ? n2(i2) : e3(n2(i2)), " : ", c2.type === r2.type || t3(c2) ? n2(u2) : e3(n2(u2)));
          } else {
            const e3 = [dO, "? ", a2.type === r2.type ? DO("", "(") : "", yO(2, n2(i2)), a2.type === r2.type ? DO("", ")") : "", dO, ": ", c2.type === r2.type ? n2(u2) : yO(2, n2(u2))];
            l2.push(f2.type !== r2.type || f2[u2] === r2 || d2 ? e3 : t2.useTabs ? EO(mO(e3)) : yO(Math.max(0, t2.tabWidth - 2), e3));
          }
          const C2 = [...s2.map((e3) => aO(r2[e3])), aO(a2), aO(c2)].flat().some((e3) => sO(e3) && iO(t2.originalText, pO(e3), fO(e3))), b2 = !p2 && (lO(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, v2 = function(e3) {
            const t3 = e3.getValue();
            if (t3.type !== "ConditionalExpression")
              return false;
            let n3, r3 = t3;
            for (let t4 = 0; !n3; t4++) {
              const o3 = e3.getParentNode(t4);
              cO(o3) && o3.callee === r3 || lO(o3) && o3.object === r3 || o3.type === "TSNonNullExpression" && o3.expression === r3 ? r3 = o3 : o3.type === "NewExpression" && o3.callee === r3 || o3.type === "TSAsExpression" && o3.expression === r3 ? (n3 = e3.getParentNode(t4 + 1), r3 = o3) : n3 = o3;
            }
            return r3 !== t3 && n3[vO.get(n3.type)] === r3;
          }(e2), A2 = ((e3) => f2 === D2 ? gO(e3, { shouldBreak: C2 }) : C2 ? [e3, CO] : e3)([bO(e2, 0, n2), m2 ? l2 : mO(l2), o2 && b2 && !v2 ? hO : ""]);
          return d2 || v2 ? gO([mO([hO, A2]), hO]) : A2;
        } };
        const { builders: { hardline: FO } } = Zc, xO = wA, { getLeftSidePathName: SO, hasNakedLeftSide: wO, isJsxNode: TO, isTheOnlyJsxElementInMarkdown: BO, hasComment: NO, CommentCheckFlags: kO, isNextLineEmpty: PO } = CC, { shouldPrintParamsWithoutParens: OO } = IN;
        function IO(e2, t2, n2, r2) {
          const o2 = e2.getValue(), i2 = [], u2 = o2.type === "ClassBody", s2 = function(e3) {
            for (let t3 = e3.length - 1; t3 >= 0; t3--) {
              const n3 = e3[t3];
              if (n3.type !== "EmptyStatement")
                return n3;
            }
          }(o2[r2]);
          return e2.each((e3, r3, o3) => {
            const a2 = e3.getValue();
            if (a2.type === "EmptyStatement")
              return;
            const c2 = n2();
            t2.semi || u2 || BO(t2, e3) || !function(e4, t3) {
              if (e4.getNode().type !== "ExpressionStatement")
                return false;
              return e4.call((e5) => LO(e5, t3), "expression");
            }(e3, t2) ? i2.push(c2) : NO(a2, kO.Leading) ? i2.push(n2([], { needsSemi: true })) : i2.push(";", c2), !t2.semi && u2 && jO(a2) && function(e4, t3) {
              const n3 = e4.key && e4.key.name;
              if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e4.value || e4.typeAnnotation))
                return true;
              if (!t3)
                return false;
              if (t3.static || t3.accessibility)
                return false;
              if (!t3.computed) {
                const e5 = t3.key && t3.key.name;
                if (e5 === "in" || e5 === "instanceof")
                  return true;
              }
              if (jO(t3) && t3.variance && !t3.static && !t3.declare)
                return true;
              switch (t3.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return t3.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
                    return false;
                  const e5 = t3.value ? t3.value.generator : t3.generator;
                  return !(!t3.computed && !e5);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }(a2, o3[r3 + 1]) && i2.push(";"), a2 !== s2 && (i2.push(FO), PO(a2, t2) && i2.push(FO));
          }, r2), i2;
        }
        function LO(e2, t2) {
          const n2 = e2.getValue();
          switch (n2.type) {
            case "ParenthesizedExpression":
            case "TypeCastExpression":
            case "ArrayExpression":
            case "ArrayPattern":
            case "TemplateLiteral":
            case "TemplateElement":
            case "RegExpLiteral":
              return true;
            case "ArrowFunctionExpression":
              if (!OO(e2, t2))
                return true;
              break;
            case "UnaryExpression": {
              const { prefix: e3, operator: t3 } = n2;
              if (e3 && (t3 === "+" || t3 === "-"))
                return true;
              break;
            }
            case "BindExpression":
              if (!n2.object)
                return true;
              break;
            case "Literal":
              if (n2.regex)
                return true;
              break;
            default:
              if (TO(n2))
                return true;
          }
          return !!xO(e2, t2) || !!wO(n2) && e2.call((e3) => LO(e3, t2), ...SO(e2, n2));
        }
        const jO = (e2) => {
          let { type: t2 } = e2;
          return t2 === "ClassProperty" || t2 === "PropertyDefinition" || t2 === "ClassPrivateProperty";
        };
        var _O = { printBody: function(e2, t2, n2) {
          return IO(e2, t2, n2, "body");
        }, printSwitchCaseConsequent: function(e2, t2, n2) {
          return IO(e2, t2, n2, "consequent");
        } };
        const { printDanglingComments: MO } = tD, { isNonEmptyArray: RO } = dc, { builders: { hardline: VO, indent: $O } } = Zc, { hasComment: WO, CommentCheckFlags: qO, isNextLineEmpty: UO } = CC, { printHardlineAfterHeritage: zO } = Dk, { printBody: GO } = _O;
        function HO(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = RO(r2.directives), i2 = r2.body.some((e3) => e3.type !== "EmptyStatement"), u2 = WO(r2, qO.Dangling);
          if (!o2 && !i2 && !u2)
            return "";
          const s2 = [];
          if (o2 && e2.each((e3, r3, o3) => {
            s2.push(n2()), (r3 < o3.length - 1 || i2 || u2) && (s2.push(VO), UO(e3.getValue(), t2) && s2.push(VO));
          }, "directives"), i2 && s2.push(GO(e2, t2, n2)), u2 && s2.push(MO(e2, t2, true)), r2.type === "Program") {
            const t3 = e2.getParentNode();
            t3 && t3.type === "ModuleExpression" || s2.push(VO);
          }
          return s2;
        }
        var JO = { printBlock: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          if (r2.type === "StaticBlock" && o2.push("static "), r2.type === "ClassBody" && RO(r2.body)) {
            const t3 = e2.getParentNode();
            o2.push(zO(t3));
          }
          o2.push("{");
          const i2 = HO(e2, t2, n2);
          if (i2)
            o2.push($O([VO, i2]), VO);
          else {
            const t3 = e2.getParentNode(), n3 = e2.getParentNode(1);
            t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || o2.push(VO);
          }
          return o2.push("}"), o2;
        }, printBlockBody: HO };
        const { printDanglingComments: XO } = tD, { hasNewlineInRange: YO } = dc, { builders: { join: KO, line: QO, hardline: ZO, softline: eI, group: tI, indent: nI, conditionalGroup: rI, ifBreak: oI } } = Zc, { isLiteral: iI, getTypeScriptMappedTypeModifier: uI, shouldPrintComma: sI, isCallExpression: aI, isMemberExpression: cI } = CC, { locStart: lI, locEnd: pI } = og, { printOptionalToken: fI, printTypeScriptModifiers: dI } = _x, { printTernary: hI } = AO, { printFunctionParameters: gI, shouldGroupFunctionParameters: mI } = WT, { printTemplateLiteral: yI } = VC, { printArrayItems: DI } = uS, { printObject: EI } = vP, { printClassProperty: CI, printClassMethod: bI } = Dk, { printTypeParameter: vI, printTypeParameters: AI } = OB, { printPropertyKey: FI } = zB, { printFunction: xI, printMethodInternal: SI } = IN, { printInterface: wI } = Nk, { printBlock: TI } = JO, { printTypeAlias: BI, printIntersectionType: NI, printUnionType: kI, printFunctionType: PI, printTupleType: OI, printIndexedAccessType: II } = fB;
        var LI = { printTypescript: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2.type.startsWith("TS"))
            return;
          if (r2.type.endsWith("Keyword"))
            return r2.type.slice(2, -7).toLowerCase();
          const o2 = t2.semi ? ";" : "", i2 = [];
          switch (r2.type) {
            case "TSThisType":
              return "this";
            case "TSTypeAssertion": {
              const e3 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = tI(["<", nI([eI, n2("typeAnnotation")]), eI, ">"]), o3 = [oI("("), nI([eI, n2("expression")]), eI, oI(")")];
              return e3 ? rI([[t3, n2("expression")], [t3, tI(o3, { shouldBreak: true })], [t3, n2("expression")]]) : tI([t3, n2("expression")]);
            }
            case "TSDeclareFunction":
              return xI(e2, n2, t2);
            case "TSExportAssignment":
              return ["export = ", n2("expression"), o2];
            case "TSModuleBlock":
              return TI(e2, t2, n2);
            case "TSInterfaceBody":
            case "TSTypeLiteral":
              return EI(e2, t2, n2);
            case "TSTypeAliasDeclaration":
              return BI(e2, t2, n2);
            case "TSQualifiedName":
              return KO(".", [n2("left"), n2("right")]);
            case "TSAbstractMethodDefinition":
            case "TSDeclareMethod":
              return bI(e2, t2, n2);
            case "TSAbstractPropertyDefinition":
              return CI(e2, t2, n2);
            case "TSInterfaceHeritage":
            case "TSExpressionWithTypeArguments":
              return i2.push(n2("expression")), r2.typeParameters && i2.push(n2("typeParameters")), i2;
            case "TSTemplateLiteralType":
              return yI(e2, n2, t2);
            case "TSNamedTupleMember":
              return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
            case "TSRestType":
              return ["...", n2("typeAnnotation")];
            case "TSOptionalType":
              return [n2("typeAnnotation"), "?"];
            case "TSInterfaceDeclaration":
              return wI(e2, t2, n2);
            case "TSClassImplements":
              return [n2("expression"), n2("typeParameters")];
            case "TSTypeParameterDeclaration":
            case "TSTypeParameterInstantiation":
              return AI(e2, t2, n2, "params");
            case "TSTypeParameter":
              return vI(e2, t2, n2);
            case "TSAsExpression": {
              i2.push(n2("expression"), " as ", n2("typeAnnotation"));
              const t3 = e2.getParentNode();
              return aI(t3) && t3.callee === r2 || cI(t3) && t3.object === r2 ? tI([nI([eI, ...i2]), eI]) : i2;
            }
            case "TSArrayType":
              return [n2("elementType"), "[]"];
            case "TSPropertySignature":
              return r2.readonly && i2.push("readonly "), i2.push(FI(e2, t2, n2), fI(e2)), r2.typeAnnotation && i2.push(": ", n2("typeAnnotation")), r2.initializer && i2.push(" = ", n2("initializer")), i2;
            case "TSParameterProperty":
              return r2.accessibility && i2.push(r2.accessibility + " "), r2.export && i2.push("export "), r2.static && i2.push("static "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), i2.push(n2("parameter")), i2;
            case "TSTypeQuery":
              return ["typeof ", n2("exprName")];
            case "TSIndexSignature": {
              const i3 = e2.getParentNode(), u2 = r2.parameters.length > 1 ? oI(sI(t2) ? "," : "") : "", s2 = tI([nI([eI, KO([", ", eI], e2.map(n2, "parameters"))]), u2, eI]);
              return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", i3.type === "ClassBody" ? o2 : ""];
            }
            case "TSTypePredicate":
              return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
            case "TSNonNullExpression":
              return [n2("expression"), "!"];
            case "TSImportType":
              return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", AI(e2, t2, n2, "typeParameters")];
            case "TSLiteralType":
              return n2("literal");
            case "TSIndexedAccessType":
              return II(e2, t2, n2);
            case "TSConstructSignatureDeclaration":
            case "TSCallSignatureDeclaration":
            case "TSConstructorType":
              if (r2.type === "TSConstructorType" && r2.abstract && i2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && i2.push("new "), i2.push(tI(gI(e2, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
                const e3 = r2.type === "TSConstructorType";
                i2.push(e3 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
              }
              return i2;
            case "TSTypeOperator":
              return [r2.operator, " ", n2("typeAnnotation")];
            case "TSMappedType": {
              const i3 = YO(t2.originalText, lI(r2), pI(r2));
              return tI(["{", nI([t2.bracketSpacing ? QO : eI, r2.readonly ? [uI(r2.readonly, "readonly"), " "] : "", dI(e2, t2, n2), n2("typeParameter"), r2.optional ? uI(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), oI(o2)]), XO(e2, t2, true), t2.bracketSpacing ? QO : eI, "}"], { shouldBreak: i3 });
            }
            case "TSMethodSignature": {
              const o3 = r2.kind && r2.kind !== "method" ? "".concat(r2.kind, " ") : "";
              i2.push(r2.accessibility ? [r2.accessibility, " "] : "", o3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", fI(e2));
              const u2 = gI(e2, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = mI(r2, c2);
              return i2.push(l2 ? tI(u2) : u2), a2 && i2.push(": ", tI(c2)), tI(i2);
            }
            case "TSNamespaceExportDeclaration":
              return i2.push("export as namespace ", n2("id")), t2.semi && i2.push(";"), tI(i2);
            case "TSEnumDeclaration":
              return r2.declare && i2.push("declare "), r2.modifiers && i2.push(dI(e2, t2, n2)), r2.const && i2.push("const "), i2.push("enum ", n2("id"), " "), r2.members.length === 0 ? i2.push(tI(["{", XO(e2, t2), eI, "}"])) : i2.push(tI(["{", nI([ZO, DI(e2, t2, "members", n2), sI(t2, "es5") ? "," : ""]), XO(e2, t2, true), ZO, "}"])), i2;
            case "TSEnumMember":
              return i2.push(n2("id")), r2.initializer && i2.push(" = ", n2("initializer")), i2;
            case "TSImportEqualsDeclaration":
              return r2.isExport && i2.push("export "), i2.push("import "), r2.importKind && r2.importKind !== "value" && i2.push(r2.importKind, " "), i2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && i2.push(";"), tI(i2);
            case "TSExternalModuleReference":
              return ["require(", n2("expression"), ")"];
            case "TSModuleDeclaration": {
              const u2 = e2.getParentNode(), s2 = iI(r2.id), a2 = u2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
              if (a2)
                i2.push(".");
              else {
                r2.declare && i2.push("declare "), i2.push(dI(e2, t2, n2));
                const o3 = t2.originalText.slice(lI(r2), lI(r2.id));
                r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(o3) || i2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(o3) ? "module " : "namespace ");
              }
              return i2.push(n2("id")), c2 ? i2.push(n2("body")) : r2.body ? i2.push(" ", tI(n2("body"))) : i2.push(o2), i2;
            }
            case "TSConditionalType":
              return hI(e2, t2, n2);
            case "TSInferType":
              return ["infer", " ", n2("typeParameter")];
            case "TSIntersectionType":
              return NI(e2, t2, n2);
            case "TSUnionType":
              return kI(e2, t2, n2);
            case "TSFunctionType":
              return PI(e2, t2, n2);
            case "TSTupleType":
              return OI(e2, t2, n2);
            case "TSTypeReference":
              return [n2("typeName"), AI(e2, t2, n2, "typeParameters")];
            case "TSTypeAnnotation":
              return n2("typeAnnotation");
            case "TSEmptyBodyFunctionExpression":
              return SI(e2, t2, n2);
            case "TSJSDocAllType":
              return "*";
            case "TSJSDocUnknownType":
              return "?";
            case "TSJSDocNullableType":
              return ["?", n2("typeAnnotation")];
            case "TSJSDocNonNullableType":
              return ["!", n2("typeAnnotation")];
            default:
              throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(r2.type), "."));
          }
        } };
        const { hasNewline: jI } = dc, { builders: { join: _I, hardline: MI }, utils: { replaceTextEndOfLine: RI } } = Zc, { isLineComment: VI, isBlockComment: $I } = CC, { locStart: WI, locEnd: qI } = og;
        var UI = { printComment: function(e2, t2) {
          const n2 = e2.getValue();
          if (VI(n2))
            return t2.originalText.slice(WI(n2), qI(n2)).trimEnd();
          if ($I(n2)) {
            if (function(e4) {
              const t3 = "*".concat(e4.value, "*").split("\n");
              return t3.length > 1 && t3.every((e5) => e5.trim()[0] === "*");
            }(n2)) {
              const e4 = function(e5) {
                const t3 = e5.value.split("\n");
                return ["/*", _I(MI, t3.map((e6, n3) => n3 === 0 ? e6.trimEnd() : " " + (n3 < t3.length - 1 ? e6.trim() : e6.trimStart()))), "*/"];
              }(n2);
              return n2.trailing && !jI(t2.originalText, WI(n2), { backwards: true }) ? [MI, e4] : e4;
            }
            const e3 = qI(n2), r2 = t2.originalText.slice(e3 - 3, e3) === "*-/";
            return ["/*", RI(n2.value), r2 ? "*-/" : "*/"];
          }
          throw new Error("Not a comment: " + JSON.stringify(n2));
        } };
        const { printString: zI, printNumber: GI } = dc;
        function HI(e2) {
          return e2.toLowerCase();
        }
        function JI(e2) {
          let { pattern: t2, flags: n2 } = e2;
          return n2 = [...n2].sort().join(""), "/".concat(t2, "/").concat(n2);
        }
        var XI = { printLiteral: function(e2, t2) {
          const n2 = e2.getNode();
          switch (n2.type) {
            case "RegExpLiteral":
              return JI(n2);
            case "BigIntLiteral":
              return HI(n2.bigint || n2.extra.raw);
            case "NumericLiteral":
              return GI(n2.extra.raw);
            case "StringLiteral":
              return zI(n2.extra.raw, t2);
            case "NullLiteral":
              return "null";
            case "BooleanLiteral":
              return String(n2.value);
            case "DecimalLiteral":
              return GI(n2.value) + "m";
            case "Literal": {
              if (n2.regex)
                return JI(n2.regex);
              if (n2.bigint)
                return HI(n2.raw);
              if (n2.decimal)
                return GI(n2.decimal) + "m";
              const { value: e3 } = n2;
              return typeof e3 == "number" ? GI(n2.raw) : typeof e3 == "string" ? zI(n2.raw, t2) : String(e3);
            }
          }
        } };
        const { printDanglingComments: YI } = tD, { hasNewline: KI } = dc, { builders: { join: QI, line: ZI, hardline: eL, softline: tL, group: nL, indent: rL }, utils: { replaceTextEndOfLine: oL } } = Zc, iL = Nb, uL = Lb, { insertPragma: sL } = iv, aL = lA, cL = wA, lL = TA, { hasFlowShorthandAnnotationComment: pL, hasComment: fL, CommentCheckFlags: dL, isTheOnlyJsxElementInMarkdown: hL, isBlockComment: gL, isLineComment: mL, isNextLineEmpty: yL, needsHardlineAfterDanglingComment: DL, rawText: EL, hasIgnoreComment: CL, isCallExpression: bL, isMemberExpression: vL } = CC, { locStart: AL, locEnd: FL } = og, { printHtmlBinding: xL, isVueEventBindingExpression: SL } = IA, { printAngular: wL } = mF, { printJsx: TL, hasJsxIgnoreComment: BL } = ZF, { printFlow: NL } = oO, { printTypescript: kL } = LI, { printOptionalToken: PL, printBindExpressionCallee: OL, printTypeAnnotation: IL, adjustClause: LL, printRestSpread: jL } = _x, { printImportDeclaration: _L, printExportDeclaration: ML, printExportAllDeclaration: RL, printModuleSpecifier: VL } = Qk, { printTernary: $L } = AO, { printTemplateLiteral: WL } = VC, { printArray: qL } = uS, { printObject: UL } = vP, { printClass: zL, printClassMethod: GL, printClassProperty: HL } = Dk, { printProperty: JL } = zB, { printFunction: XL, printArrowFunction: YL, printMethod: KL, printReturnStatement: QL, printThrowStatement: ZL } = IN, { printCallExpression: ej } = Mw, { printVariableDeclarator: tj, printAssignmentExpression: nj } = mT, { printBinaryishExpression: rj } = sF, { printSwitchCaseConsequent: oj } = _O, { printMemberExpression: ij } = GS, { printBlock: uj, printBlockBody: sj } = JO, { printComment: aj } = UI, { printLiteral: cj } = XI, { printDecorators: lj } = HN;
        function pj(e2, t2) {
          const n2 = EL(e2), r2 = n2.slice(1, -1);
          if (r2.includes('"') || r2.includes("'"))
            return n2;
          const o2 = t2.singleQuote ? "'" : '"';
          return o2 + r2 + o2;
        }
        var fj = { preprocess: lL, print: function(e2, t2, n2, r2) {
          const o2 = function(e3, t3, n3, r3) {
            const o3 = e3.getValue(), i3 = t3.semi ? ";" : "";
            if (!o3)
              return "";
            if (typeof o3 == "string")
              return o3;
            for (const r4 of [cj, xL, wL, TL, NL, kL]) {
              const o4 = r4(e3, t3, n3);
              if (o4 !== void 0)
                return o4;
            }
            let u3 = [];
            switch (o3.type) {
              case "JsExpressionRoot":
                return n3("node");
              case "JsonRoot":
                return [n3("node"), eL];
              case "File":
                return o3.program && o3.program.interpreter && u3.push(n3(["program", "interpreter"])), u3.push(n3("program")), u3;
              case "Program":
                return sj(e3, t3, n3);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement":
                if (o3.directive)
                  return [pj(o3.expression, t3), i3];
                if (t3.parser === "__vue_event_binding") {
                  const t4 = e3.getParentNode();
                  if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === o3)
                    return [n3("expression"), SL(o3.expression) ? ";" : ""];
                }
                return [n3("expression"), hL(t3, e3) ? "" : i3];
              case "ParenthesizedExpression":
                return !fL(o3.expression) && (o3.expression.type === "ObjectExpression" || o3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : nL(["(", rL([tL, n3("expression")]), tL, ")"]);
              case "AssignmentExpression":
                return nj(e3, t3, n3);
              case "VariableDeclarator":
                return tj(e3, t3, n3);
              case "BinaryExpression":
              case "LogicalExpression":
                return rj(e3, t3, n3);
              case "AssignmentPattern":
                return [n3("left"), " = ", n3("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return ij(e3, t3, n3);
              case "MetaProperty":
                return [n3("meta"), ".", n3("property")];
              case "BindExpression":
                return o3.object && u3.push(n3("object")), u3.push(nL(rL([tL, OL(e3, t3, n3)]))), u3;
              case "Identifier":
                return [o3.name, PL(e3), IL(e3, t3, n3)];
              case "V8IntrinsicIdentifier":
                return ["%", o3.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return jL(e3, t3, n3);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return XL(e3, n3, t3, r3);
              case "ArrowFunctionExpression":
                return YL(e3, t3, n3, r3);
              case "YieldExpression":
                return u3.push("yield"), o3.delegate && u3.push("*"), o3.argument && u3.push(" ", n3("argument")), u3;
              case "AwaitExpression":
                if (u3.push("await"), o3.argument) {
                  u3.push(" ", n3("argument"));
                  const t4 = e3.getParentNode();
                  if (bL(t4) && t4.callee === o3 || vL(t4) && t4.object === o3) {
                    u3 = [rL([tL, ...u3]), tL];
                    const t5 = e3.findAncestor((e4) => e4.type === "AwaitExpression" || e4.type === "BlockStatement");
                    if (!t5 || t5.type !== "AwaitExpression")
                      return nL(u3);
                  }
                }
                return u3;
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ML(e3, t3, n3);
              case "ExportAllDeclaration":
                return RL(e3, t3, n3);
              case "ImportDeclaration":
                return _L(e3, t3, n3);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return VL(e3, t3, n3);
              case "ImportAttribute":
                return [n3("key"), ": ", n3("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return uj(e3, t3, n3);
              case "ThrowStatement":
                return ZL(e3, t3, n3);
              case "ReturnStatement":
                return QL(e3, t3, n3);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return ej(e3, t3, n3);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return UL(e3, t3, n3);
              case "ObjectProperty":
              case "Property":
                return o3.method || o3.kind === "get" || o3.kind === "set" ? KL(e3, t3, n3) : JL(e3, t3, n3);
              case "ObjectMethod":
                return KL(e3, t3, n3);
              case "Decorator":
                return ["@", n3("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return qL(e3, t3, n3);
              case "SequenceExpression": {
                const t4 = e3.getParentNode(0);
                if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
                  const t5 = [];
                  return e3.each((e4, r4) => {
                    r4 === 0 ? t5.push(n3()) : t5.push(",", rL([ZI, n3()]));
                  }, "expressions"), nL(t5);
                }
                return nL(QI([",", ZI], e3.map(n3, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [n3("value"), i3];
              case "DirectiveLiteral":
                return pj(o3, t3);
              case "UnaryExpression":
                return u3.push(o3.operator), /[a-z]$/.test(o3.operator) && u3.push(" "), fL(o3.argument) ? u3.push(nL(["(", rL([tL, n3("argument")]), tL, ")"])) : u3.push(n3("argument")), u3;
              case "UpdateExpression":
                return u3.push(n3("argument"), o3.operator), o3.prefix && u3.reverse(), u3;
              case "ConditionalExpression":
                return $L(e3, t3, n3);
              case "VariableDeclaration": {
                const t4 = e3.map(n3, "declarations"), r4 = e3.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = o3.declarations.some((e4) => e4.init);
                let c2;
                return t4.length !== 1 || fL(o3.declarations[0]) ? t4.length > 0 && (c2 = rL(t4[0])) : c2 = t4[0], u3 = [o3.declare ? "declare " : "", o3.kind, c2 ? [" ", c2] : "", rL(t4.slice(1).map((e4) => [",", a3 && !s3 ? eL : ZI, e4]))], s3 && r4.body !== o3 || u3.push(i3), nL(u3);
              }
              case "WithStatement":
                return nL(["with (", n3("object"), ")", LL(o3.body, n3("body"))]);
              case "IfStatement": {
                const r4 = LL(o3.consequent, n3("consequent")), i4 = nL(["if (", nL([rL([tL, n3("test")]), tL]), ")", r4]);
                if (u3.push(i4), o3.alternate) {
                  const r5 = fL(o3.consequent, dL.Trailing | dL.Line) || DL(o3), i5 = o3.consequent.type === "BlockStatement" && !r5;
                  u3.push(i5 ? " " : eL), fL(o3, dL.Dangling) && u3.push(YI(e3, t3, true), r5 ? eL : " "), u3.push("else", nL(LL(o3.alternate, n3("alternate"), o3.alternate.type === "IfStatement")));
                }
                return u3;
              }
              case "ForStatement": {
                const r4 = LL(o3.body, n3("body")), i4 = YI(e3, t3, true), u4 = i4 ? [i4, tL] : "";
                return o3.init || o3.test || o3.update ? [u4, nL(["for (", nL([rL([tL, n3("init"), ";", ZI, n3("test"), ";", ZI, n3("update")]), tL]), ")", r4])] : [u4, nL(["for (;;)", r4])];
              }
              case "WhileStatement":
                return nL(["while (", nL([rL([tL, n3("test")]), tL]), ")", LL(o3.body, n3("body"))]);
              case "ForInStatement":
                return nL(["for (", n3("left"), " in ", n3("right"), ")", LL(o3.body, n3("body"))]);
              case "ForOfStatement":
                return nL(["for", o3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", LL(o3.body, n3("body"))]);
              case "DoWhileStatement": {
                const e4 = LL(o3.body, n3("body"));
                return u3 = [nL(["do", e4])], o3.body.type === "BlockStatement" ? u3.push(" ") : u3.push(eL), u3.push("while (", nL([rL([tL, n3("test")]), tL]), ")", i3), u3;
              }
              case "DoExpression":
                return [o3.async ? "async " : "", "do ", n3("body")];
              case "BreakStatement":
                return u3.push("break"), o3.label && u3.push(" ", n3("label")), u3.push(i3), u3;
              case "ContinueStatement":
                return u3.push("continue"), o3.label && u3.push(" ", n3("label")), u3.push(i3), u3;
              case "LabeledStatement":
                return o3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
              case "TryStatement":
                return ["try ", n3("block"), o3.handler ? [" ", n3("handler")] : "", o3.finalizer ? [" finally ", n3("finalizer")] : ""];
              case "CatchClause":
                if (o3.param) {
                  const e4 = fL(o3.param, (e5) => !gL(e5) || e5.leading && KI(t3.originalText, FL(e5)) || e5.trailing && KI(t3.originalText, AL(e5), { backwards: true })), r4 = n3("param");
                  return ["catch ", e4 ? ["(", rL([tL, r4]), tL, ") "] : ["(", r4, ") "], n3("body")];
                }
                return ["catch ", n3("body")];
              case "SwitchStatement":
                return [nL(["switch (", rL([tL, n3("discriminant")]), tL, ")"]), " {", o3.cases.length > 0 ? rL([eL, QI(eL, e3.map((e4, r4, o4) => {
                  const i4 = e4.getValue();
                  return [n3(), r4 !== o4.length - 1 && yL(i4, t3) ? eL : ""];
                }, "cases"))]) : "", eL, "}"];
              case "SwitchCase": {
                o3.test ? u3.push("case ", n3("test"), ":") : u3.push("default:");
                const r4 = o3.consequent.filter((e4) => e4.type !== "EmptyStatement");
                if (r4.length > 0) {
                  const o4 = oj(e3, t3, n3);
                  u3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", o4] : rL([eL, o4]));
                }
                return u3;
              }
              case "DebuggerStatement":
                return ["debugger", i3];
              case "ClassDeclaration":
              case "ClassExpression":
                return zL(e3, t3, n3);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return GL(e3, t3, n3);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
                return HL(e3, t3, n3);
              case "TemplateElement":
                return oL(o3.value.raw);
              case "TemplateLiteral":
                return WL(e3, n3, t3);
              case "TaggedTemplateExpression":
                return [n3("tag"), n3("typeParameters"), n3("quasi")];
              case "PrivateIdentifier":
                return ["#", n3("name")];
              case "PrivateName":
                return ["#", n3("id")];
              case "InterpreterDirective":
                return u3.push("#!", o3.value, eL), yL(o3, t3) && u3.push(eL), u3;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                u3.push("module {");
                const e4 = n3("body");
                return e4 && u3.push(rL([eL, e4]), eL), u3.push("}"), u3;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(o3.type));
            }
          }(e2, t2, n2, r2);
          if (!o2)
            return "";
          const i2 = e2.getValue(), { type: u2 } = i2;
          if (u2 === "ClassMethod" || u2 === "ClassPrivateMethod" || u2 === "ClassProperty" || u2 === "PropertyDefinition" || u2 === "TSAbstractPropertyDefinition" || u2 === "ClassPrivateProperty" || u2 === "MethodDefinition" || u2 === "TSAbstractMethodDefinition" || u2 === "TSDeclareMethod")
            return o2;
          const s2 = lj(e2, t2, n2);
          if (s2)
            return nL([...s2, o2]);
          if (!cL(e2, t2))
            return r2 && r2.needsSemi ? [";", o2] : o2;
          const a2 = [r2 && r2.needsSemi ? ";(" : "(", o2];
          if (pL(i2)) {
            const [e3] = i2.trailingComments;
            a2.push(" /*", e3.value.trimStart(), "*/"), e3.printed = true;
          }
          return a2.push(")"), a2;
        }, embed: iL, insertPragma: sL, massageAstNode: uL, hasPrettierIgnore: (e2) => CL(e2) || BL(e2), willPrintOwnComments: aL.willPrintOwnComments, canAttachComment: function(e2) {
          return e2.type && !gL(e2) && !mL(e2) && e2.type !== "EmptyStatement" && e2.type !== "TemplateElement" && e2.type !== "Import" && e2.type !== "TSEmptyBodyFunctionExpression";
        }, printComment: aj, isBlockComment: gL, handleComments: { avoidAstMutation: true, ownLine: aL.handleOwnLineComment, endOfLine: aL.handleEndOfLineComment, remaining: aL.handleRemainingComment }, getCommentChildNodes: aL.getCommentChildNodes };
        const { builders: { hardline: dj, indent: hj, join: gj } } = Zc, mj = TA;
        const yj = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
        function Dj(e2, t2) {
          const { type: n2 } = e2;
          if (n2 !== "ObjectProperty" || e2.key.type !== "Identifier") {
            if (n2 === "UnaryExpression" && e2.operator === "+")
              return t2.argument;
            if (n2 !== "ArrayExpression")
              return n2 === "TemplateLiteral" ? { type: "StringLiteral", value: e2.quasis[0].value.cooked } : void 0;
            for (const [n3, r2] of e2.elements.entries())
              r2 === null && t2.elements.splice(n3, 0, { type: "NullLiteral" });
          } else
            t2.key = { type: "StringLiteral", value: e2.key.name };
        }
        Dj.ignoredProperties = yj;
        var Ej = { preprocess: mj, print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          switch (r2.type) {
            case "JsonRoot":
              return [n2("node"), dj];
            case "ArrayExpression": {
              if (r2.elements.length === 0)
                return "[]";
              const t3 = e2.map(() => e2.getValue() === null ? "null" : n2(), "elements");
              return ["[", hj([dj, gj([",", dj], t3)]), dj, "]"];
            }
            case "ObjectExpression":
              return r2.properties.length === 0 ? "{}" : ["{", hj([dj, gj([",", dj], e2.map(n2, "properties"))]), dj, "}"];
            case "ObjectProperty":
              return [n2("key"), ": ", n2("value")];
            case "UnaryExpression":
              return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
            case "NullLiteral":
              return "null";
            case "BooleanLiteral":
              return r2.value ? "true" : "false";
            case "StringLiteral":
            case "NumericLiteral":
              return JSON.stringify(r2.value);
            case "Identifier": {
              const t3 = e2.getParentNode();
              return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
            }
            case "TemplateLiteral":
              return n2(["quasis", 0]);
            case "TemplateElement":
              return JSON.stringify(r2.value.cooked);
            default:
              throw new Error("unknown type: " + JSON.stringify(r2.type));
          }
        }, massageAstNode: Dj };
        const Cj = "Common";
        var bj = { bracketSpacing: { since: "0.0.0", category: Cj, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: Cj, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: Cj, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: Cj, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." } };
        const vj = "JavaScript";
        var Aj = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 }, Fj = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 }, xj = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 }, Sj = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 }, wj = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 }, Tj = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        const Bj = bE, Nj = fj, kj = Ej, Pj = { arrowParens: { since: "1.9.0", category: vj, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: bj.bracketSameLine, bracketSpacing: bj.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: vj, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: vj, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: bj.singleQuote, jsxSingleQuote: { since: "1.15.0", category: vj, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: vj, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: vj, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, Oj = [Bj(Aj, (e2) => ({ since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e2.interpreters, "zx"], extensions: [...e2.extensions.filter((e3) => e3 !== ".jsx"), ".wxs"] })), Bj(Aj, () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), Bj(Aj, () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), Bj(Fj, (e2) => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], extensions: [...e2.extensions, ".mts", ".cts"] })), Bj(xj, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), Bj(Sj, () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), Bj(Sj, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e2.extensions.filter((e3) => e3 !== ".jsonl") })), Bj(wj, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e2.filenames, ".eslintrc"] })), Bj(Tj, () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))];
        var Ij = { languages: Oj, options: Pj, printers: { estree: Nj, "estree-json": kj }, parsers: void 0 };
        const { isFrontMatterNode: Lj } = dc, jj = au, _j = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
        function Mj(e2, t2, n2) {
          if (Lj(e2) && e2.lang === "yaml" && delete t2.value, e2.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
            if ((n2.nodes[0] === e2 || Lj(n2.nodes[0]) && n2.nodes[1] === e2) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e2.text)))
              return null;
            if (n2.type === "css-root" && jj(n2.nodes) === e2)
              return null;
          }
          if (e2.type === "value-root" && delete t2.text, e2.type !== "media-query" && e2.type !== "media-query-list" && e2.type !== "media-feature-expression" || delete t2.value, e2.type === "css-rule" && delete t2.params, e2.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e2.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e2.type === "value-word" && (e2.isColor && e2.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e2.type === "media-feature" || e2.type === "selector-root-invalid" || e2.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e2.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e2.type !== "css-atrule" && e2.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e2.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e2.type !== "media-feature" && e2.type !== "media-keyword" && e2.type !== "media-type" && e2.type !== "media-unknown" && e2.type !== "media-url" && e2.type !== "media-value" && e2.type !== "selector-attribute" && e2.type !== "selector-string" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e2.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e2.type !== "media-value" && e2.type !== "media-type" && e2.type !== "value-number" && e2.type !== "selector-root-invalid" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e3, t3, n3) => {
            const r2 = Number(t3);
            return Number.isNaN(r2) ? e3 : r2 + n3.toLowerCase();
          })), e2.type === "selector-tag") {
            const n3 = e2.value.toLowerCase();
            ["from", "to"].includes(n3) && (t2.value = n3);
          }
          e2.type === "css-atrule" && e2.name.toLowerCase() === "supports" && delete t2.value, e2.type === "selector-unknown" && delete t2.value;
        }
        Mj.ignoredProperties = _j;
        var Rj = Mj;
        const { builders: { hardline: Vj, markAsRoot: $j } } = Zc;
        var Wj = function(e2, t2) {
          if (e2.lang === "yaml") {
            const n2 = e2.value.trim(), r2 = n2 ? t2(n2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
            return $j([e2.startDelimiter, Vj, r2, r2 ? Vj : "", e2.endDelimiter]);
          }
        };
        const { builders: { hardline: qj } } = Zc, Uj = Wj;
        var zj = function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (r2.type === "front-matter") {
            const e3 = Uj(r2, n2);
            return e3 ? [e3, qj] : "";
          }
        };
        const Gj = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
        var Hj = function(e2) {
          const t2 = e2.match(Gj);
          if (!t2)
            return { content: e2 };
          const { startDelimiter: n2, language: r2, value: o2 = "", endDelimiter: i2 } = t2.groups;
          let u2 = r2.trim() || "yaml";
          if (n2 === "+++" && (u2 = "toml"), u2 !== "yaml" && n2 !== i2)
            return { content: e2 };
          const [s2] = t2;
          return { frontMatter: { type: "front-matter", lang: u2, value: o2, startDelimiter: n2, endDelimiter: i2, raw: s2.replace(/\n$/, "") }, content: s2.replace(/[^\n]/g, " ") + e2.slice(s2.length) };
        };
        const Jj = iv, Xj = Hj;
        var Yj = { hasPragma: function(e2) {
          return Jj.hasPragma(Xj(e2).content);
        }, insertPragma: function(e2) {
          const { frontMatter: t2, content: n2 } = Xj(e2);
          return (t2 ? t2.raw + "\n\n" : "") + Jj.insertPragma(n2);
        } };
        const { isNonEmptyArray: Kj } = dc, Qj = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), Zj = /* @__PURE__ */ new Set(["import", "use", "forward"]);
        function e_(e2, t2) {
          const n2 = Array.isArray(t2) ? t2 : [t2];
          let r2, o2 = -1;
          for (; r2 = e2.getParentNode(++o2); )
            if (n2.includes(r2.type))
              return o2;
          return -1;
        }
        function t_(e2, t2) {
          const n2 = e_(e2, t2);
          return n2 === -1 ? null : e2.getParentNode(n2);
        }
        function n_(e2) {
          return e2.type === "value-operator" && e2.value === "*";
        }
        function r_(e2) {
          return e2.type === "value-operator" && e2.value === "/";
        }
        function o_(e2) {
          return e2.type === "value-operator" && e2.value === "+";
        }
        function i_(e2) {
          return e2.type === "value-operator" && e2.value === "-";
        }
        function u_(e2) {
          return e2.type === "value-operator" && e2.value === "%";
        }
        function s_(e2) {
          return e2.type === "value-comma_group" && e2.groups && e2.groups[1] && e2.groups[1].type === "value-colon";
        }
        function a_(e2) {
          return e2.type === "value-paren_group" && e2.groups && e2.groups[0] && s_(e2.groups[0]);
        }
        function c_(e2) {
          return e2 && e2.type === "value-colon";
        }
        var l_ = { getAncestorCounter: e_, getAncestorNode: t_, getPropOfDeclNode: function(e2) {
          const t2 = t_(e2, "css-decl");
          return t2 && t2.prop && t2.prop.toLowerCase();
        }, hasSCSSInterpolation: function(e2) {
          if (Kj(e2)) {
            for (let t2 = e2.length - 1; t2 > 0; t2--)
              if (e2[t2].type === "word" && e2[t2].value === "{" && e2[t2 - 1].type === "word" && e2[t2 - 1].value.endsWith("#"))
                return true;
          }
          return false;
        }, hasStringOrFunction: function(e2) {
          if (Kj(e2)) {
            for (let t2 = 0; t2 < e2.length; t2++)
              if (e2[t2].type === "string" || e2[t2].type === "func")
                return true;
          }
          return false;
        }, maybeToLowerCase: function(e2) {
          return e2.includes("$") || e2.includes("@") || e2.includes("#") || e2.startsWith("%") || e2.startsWith("--") || e2.startsWith(":--") || e2.includes("(") && e2.includes(")") ? e2 : e2.toLowerCase();
        }, insideValueFunctionNode: function(e2, t2) {
          const n2 = t_(e2, "value-func");
          return n2 && n2.value && n2.value.toLowerCase() === t2;
        }, insideICSSRuleNode: function(e2) {
          const t2 = t_(e2, "css-rule");
          return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
        }, insideAtRuleNode: function(e2, t2) {
          const n2 = Array.isArray(t2) ? t2 : [t2], r2 = t_(e2, "css-atrule");
          return r2 && n2.includes(r2.name.toLowerCase());
        }, insideURLFunctionInImportAtRuleNode: function(e2) {
          const t2 = e2.getValue(), n2 = t_(e2, "css-atrule");
          return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
        }, isKeyframeAtRuleKeywords: function(e2, t2) {
          const n2 = t_(e2, "css-atrule");
          return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
        }, isWideKeywords: function(e2) {
          return ["initial", "inherit", "unset", "revert"].includes(e2.toLowerCase());
        }, isSCSS: function(e2, t2) {
          return e2 === "less" || e2 === "scss" ? e2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
        }, isSCSSVariable: function(e2) {
          return Boolean(e2 && e2.type === "word" && e2.value.startsWith("$"));
        }, isLastNode: function(e2, t2) {
          const n2 = e2.getParentNode();
          if (!n2)
            return false;
          const { nodes: r2 } = n2;
          return r2 && r2.indexOf(t2) === r2.length - 1;
        }, isLessParser: function(e2) {
          return e2.parser === "css" || e2.parser === "less";
        }, isSCSSControlDirectiveNode: function(e2) {
          return e2.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e2.name);
        }, isDetachedRulesetDeclarationNode: function(e2) {
          return !!e2.selector && (typeof e2.selector == "string" && /^@.+:.*$/.test(e2.selector) || e2.selector.value && /^@.+:.*$/.test(e2.selector.value));
        }, isRelationalOperatorNode: function(e2) {
          return e2.type === "value-word" && ["<", ">", "<=", ">="].includes(e2.value);
        }, isEqualityOperatorNode: function(e2) {
          return e2.type === "value-word" && ["==", "!="].includes(e2.value);
        }, isMultiplicationNode: n_, isDivisionNode: r_, isAdditionNode: o_, isSubtractionNode: i_, isModuloNode: u_, isMathOperatorNode: function(e2) {
          return n_(e2) || r_(e2) || o_(e2) || i_(e2) || u_(e2);
        }, isEachKeywordNode: function(e2) {
          return e2.type === "value-word" && e2.value === "in";
        }, isForKeywordNode: function(e2) {
          return e2.type === "value-word" && ["from", "through", "end"].includes(e2.value);
        }, isURLFunctionNode: function(e2) {
          return e2.type === "value-func" && e2.value.toLowerCase() === "url";
        }, isIfElseKeywordNode: function(e2) {
          return e2.type === "value-word" && ["and", "or", "not"].includes(e2.value);
        }, hasComposesNode: function(e2) {
          return e2.value && e2.value.type === "value-root" && e2.value.group && e2.value.group.type === "value-value" && e2.prop.toLowerCase() === "composes";
        }, hasParensAroundNode: function(e2) {
          return e2.value && e2.value.group && e2.value.group.group && e2.value.group.group.type === "value-paren_group" && e2.value.group.group.open !== null && e2.value.group.group.close !== null;
        }, hasEmptyRawBefore: function(e2) {
          return e2.raws && e2.raws.before === "";
        }, isSCSSNestedPropertyNode: function(e2) {
          return !!e2.selector && e2.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
        }, isDetachedRulesetCallNode: function(e2) {
          return e2.raws && e2.raws.params && /^\(\s*\)$/.test(e2.raws.params);
        }, isTemplatePlaceholderNode: function(e2) {
          return e2.name.startsWith("prettier-placeholder");
        }, isTemplatePropNode: function(e2) {
          return e2.prop.startsWith("@prettier-placeholder");
        }, isPostcssSimpleVarNode: function(e2, t2) {
          return e2.value === "$$" && e2.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
        }, isKeyValuePairNode: s_, isKeyValuePairInParenGroupNode: a_, isKeyInValuePairNode: function(e2, t2) {
          if (!s_(t2))
            return false;
          const { groups: n2 } = t2, r2 = n2.indexOf(e2);
          return r2 !== -1 && c_(n2[r2 + 1]);
        }, isSCSSMapItemNode: function(e2) {
          const t2 = e2.getValue();
          if (t2.groups.length === 0)
            return false;
          const n2 = e2.getParentNode(1);
          if (!(a_(t2) || n2 && a_(n2)))
            return false;
          const r2 = t_(e2, "css-decl");
          return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!a_(n2) || n2.type === "value-func");
        }, isInlineValueCommentNode: function(e2) {
          return e2.type === "value-comment" && e2.inline;
        }, isHashNode: function(e2) {
          return e2.type === "value-word" && e2.value === "#";
        }, isLeftCurlyBraceNode: function(e2) {
          return e2.type === "value-word" && e2.value === "{";
        }, isRightCurlyBraceNode: function(e2) {
          return e2.type === "value-word" && e2.value === "}";
        }, isWordNode: function(e2) {
          return ["value-word", "value-atword"].includes(e2.type);
        }, isColonNode: c_, isMediaAndSupportsKeywords: function(e2) {
          return e2.value && ["not", "and", "or"].includes(e2.value.toLowerCase());
        }, isColorAdjusterFuncNode: function(e2) {
          return e2.type === "value-func" && Qj.has(e2.value.toLowerCase());
        }, lastLineHasInlineComment: function(e2) {
          return /\/\//.test(e2.split(/[\n\r]/).pop());
        }, stringifyNode: function e2(t2) {
          if (t2.groups) {
            return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, o2) => n3 + e2(r3) + (t2.groups[0].type === "comma_group" && o2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
          }
          const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
          return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e2(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
        }, isAtWordPlaceholderNode: function(e2) {
          return e2 && e2.type === "value-atword" && e2.value.startsWith("prettier-placeholder-");
        }, isModuleRuleName: function(e2) {
          return Zj.has(e2);
        }, isConfigurationNode: function(e2, t2) {
          if (!e2.open || e2.open.value !== "(" || !e2.close || e2.close.value !== ")" || e2.groups.some((e3) => e3.type !== "value-comma_group"))
            return false;
          if (t2.type === "value-comma_group") {
            const n2 = t2.groups.indexOf(e2) - 1, r2 = t2.groups[n2];
            if (r2 && r2.type === "value-word" && r2.value === "with")
              return true;
          }
          return false;
        }, isParenGroupNode: function(e2) {
          return e2.type === "value-paren_group" && e2.open && e2.open.value === "(" && e2.close && e2.close.value === ")";
        } };
        const p_ = function(e2, t2) {
          let n2 = 0;
          for (let r2 = 0; r2 < e2.line - 1; ++r2)
            n2 = t2.indexOf("\n", n2) + 1;
          return n2 + e2.column;
        }, { getLast: f_, skipEverythingButNewLine: d_ } = dc;
        function h_(e2, t2) {
          return typeof e2.sourceIndex == "number" ? e2.sourceIndex : e2.source ? p_(e2.source.start, t2) - 1 : null;
        }
        function g_(e2, t2) {
          if (e2.type === "css-comment" && e2.inline)
            return d_(t2, e2.source.startOffset);
          const n2 = e2.nodes && f_(e2.nodes);
          return n2 && e2.source && !e2.source.end && (e2 = n2), e2.source && e2.source.end ? p_(e2.source.end, t2) : null;
        }
        function m_(e2, t2, n2) {
          e2.source && (e2.source.startOffset = h_(e2, n2) + t2, e2.source.endOffset = g_(e2, n2) + t2);
          for (const r2 in e2) {
            const o2 = e2[r2];
            r2 !== "source" && o2 && typeof o2 == "object" && m_(o2, t2, n2);
          }
        }
        function y_(e2) {
          let t2 = e2.source.startOffset;
          return typeof e2.prop == "string" && (t2 += e2.prop.length), e2.type === "css-atrule" && typeof e2.name == "string" && (t2 += 1 + e2.name.length + e2.raws.afterName.match(/^\s*:?\s*/)[0].length), e2.type !== "css-atrule" && e2.raws && typeof e2.raws.between == "string" && (t2 += e2.raws.between.length), t2;
        }
        var D_ = { locStart: function(e2) {
          return e2.source.startOffset;
        }, locEnd: function(e2) {
          return e2.source.endOffset;
        }, calculateLoc: function e2(t2, n2) {
          t2.source && (t2.source.startOffset = h_(t2, n2), t2.source.endOffset = g_(t2, n2));
          for (const r2 in t2) {
            const o2 = t2[r2];
            r2 !== "source" && o2 && typeof o2 == "object" && (o2.type === "value-root" || o2.type === "value-unknown" ? m_(o2, y_(t2), o2.text || o2.value) : e2(o2, n2));
          }
        }, replaceQuotesInInlineComments: function(e2) {
          let t2, n2 = "initial", r2 = "initial", o2 = false;
          const i2 = [];
          for (let u2 = 0; u2 < e2.length; u2++) {
            const s2 = e2[u2];
            switch (n2) {
              case "initial":
                if (s2 === "'") {
                  n2 = "single-quotes";
                  continue;
                }
                if (s2 === '"') {
                  n2 = "double-quotes";
                  continue;
                }
                if ((s2 === "u" || s2 === "U") && e2.slice(u2, u2 + 4).toLowerCase() === "url(") {
                  n2 = "url", u2 += 3;
                  continue;
                }
                if (s2 === "*" && e2[u2 - 1] === "/") {
                  n2 = "comment-block";
                  continue;
                }
                if (s2 === "/" && e2[u2 - 1] === "/") {
                  n2 = "comment-inline", t2 = u2 - 1;
                  continue;
                }
                continue;
              case "single-quotes":
                if (s2 === "'" && e2[u2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
                  return e2;
                continue;
              case "double-quotes":
                if (s2 === '"' && e2[u2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
                  return e2;
                continue;
              case "url":
                if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
                  return e2;
                if (s2 === "'") {
                  n2 = "single-quotes", r2 = "url";
                  continue;
                }
                if (s2 === '"') {
                  n2 = "double-quotes", r2 = "url";
                  continue;
                }
                continue;
              case "comment-block":
                s2 === "/" && e2[u2 - 1] === "*" && (n2 = "initial");
                continue;
              case "comment-inline":
                s2 !== '"' && s2 !== "'" && s2 !== "*" || (o2 = true), s2 !== "\n" && s2 !== "\r" || (o2 && i2.push([t2, u2]), n2 = "initial", o2 = false);
                continue;
            }
          }
          for (const [t3, n3] of i2)
            e2 = e2.slice(0, t3) + e2.slice(t3, n3).replace(/["'*]/g, " ") + e2.slice(n3);
          return e2;
        } };
        const E_ = au, { printNumber: C_, printString: b_, hasNewline: v_, isFrontMatterNode: A_, isNextLineEmpty: F_, isNonEmptyArray: x_ } = dc, { builders: { join: S_, line: w_, hardline: T_, softline: B_, group: N_, fill: k_, indent: P_, dedent: O_, ifBreak: I_, breakParent: L_ }, utils: { removeLines: j_, getDocParts: __ } } = Zc, M_ = Rj, R_ = zj, { insertPragma: V_ } = Yj, { getAncestorNode: $_, getPropOfDeclNode: W_, maybeToLowerCase: q_, insideValueFunctionNode: U_, insideICSSRuleNode: z_, insideAtRuleNode: G_, insideURLFunctionInImportAtRuleNode: H_, isKeyframeAtRuleKeywords: J_, isWideKeywords: X_, isSCSS: Y_, isLastNode: K_, isLessParser: Q_, isSCSSControlDirectiveNode: Z_, isDetachedRulesetDeclarationNode: eM, isRelationalOperatorNode: tM, isEqualityOperatorNode: nM, isMultiplicationNode: rM, isDivisionNode: oM, isAdditionNode: iM, isSubtractionNode: uM, isMathOperatorNode: sM, isEachKeywordNode: aM, isForKeywordNode: cM, isURLFunctionNode: lM, isIfElseKeywordNode: pM, hasComposesNode: fM, hasParensAroundNode: dM, hasEmptyRawBefore: hM, isKeyValuePairNode: gM, isKeyInValuePairNode: mM, isDetachedRulesetCallNode: yM, isTemplatePlaceholderNode: DM, isTemplatePropNode: EM, isPostcssSimpleVarNode: CM, isSCSSMapItemNode: bM, isInlineValueCommentNode: vM, isHashNode: AM, isLeftCurlyBraceNode: FM, isRightCurlyBraceNode: xM, isWordNode: SM, isColonNode: wM, isMediaAndSupportsKeywords: TM, isColorAdjusterFuncNode: BM, lastLineHasInlineComment: NM, isAtWordPlaceholderNode: kM, isConfigurationNode: PM, isParenGroupNode: OM } = l_, { locStart: IM, locEnd: LM } = D_;
        function jM(e2) {
          return e2.trailingComma === "es5" || e2.trailingComma === "all";
        }
        function _M(e2, t2, n2) {
          const r2 = [];
          return e2.each((e3, o2, i2) => {
            const u2 = i2[o2 - 1];
            if (u2 && u2.type === "css-comment" && u2.text.trim() === "prettier-ignore") {
              const n3 = e3.getValue();
              r2.push(t2.originalText.slice(IM(n3), LM(n3)));
            } else
              r2.push(n2());
            o2 !== i2.length - 1 && (i2[o2 + 1].type === "css-comment" && !v_(t2.originalText, IM(i2[o2 + 1]), { backwards: true }) && !A_(i2[o2]) || i2[o2 + 1].type === "css-atrule" && i2[o2 + 1].name === "else" && i2[o2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? w_ : T_), F_(t2.originalText, e3.getValue(), LM) && !A_(i2[o2]) && r2.push(T_)));
          }, "nodes"), r2;
        }
        const MM = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, RM = new RegExp(MM.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
        function VM(e2, t2) {
          return e2.replace(MM, (e3) => b_(e3, t2));
        }
        function $M(e2, t2) {
          const n2 = t2.singleQuote ? "'" : '"';
          return e2.includes('"') || e2.includes("'") ? e2 : n2 + e2 + n2;
        }
        function WM(e2) {
          return e2.replace(RM, (e3, t2, n2, r2, o2) => !n2 && r2 ? qM(r2) + q_(o2 || "") : e3);
        }
        function qM(e2) {
          return C_(e2).replace(/\.0(?=$|e)/, "");
        }
        var UM = { print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2)
            return "";
          if (typeof r2 == "string")
            return r2;
          switch (r2.type) {
            case "front-matter":
              return [r2.raw, T_];
            case "css-root": {
              const o2 = _M(e2, t2, n2), i2 = r2.raws.after.trim();
              return [o2, i2 ? " ".concat(i2) : "", __(o2).length > 0 ? T_ : ""];
            }
            case "css-comment": {
              const e3 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(IM(r2), LM(r2));
              return e3 ? n3.trimEnd() : n3;
            }
            case "css-rule":
              return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && NM(r2.selector.value) ? w_ : " ", "{", r2.nodes.length > 0 ? P_([T_, _M(e2, t2, n2)]) : "", T_, "}", eM(r2) ? ";" : ""] : ";"];
            case "css-decl": {
              const o2 = e2.getParentNode(), { between: i2 } = r2.raws, u2 = i2.trim(), s2 = u2 === ":";
              let a2 = fM(r2) ? j_(n2("value")) : n2("value");
              return !s2 && NM(u2) && (a2 = P_([T_, O_(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), z_(e2) ? r2.prop : q_(r2.prop), u2.startsWith("//") ? " " : "", u2, r2.extend ? "" : " ", Q_(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", P_([B_, _M(e2, t2, n2)]), B_, "}"] : EM(r2) && !o2.raws.semicolon && t2.originalText[LM(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && K_(e2, r2) ? I_(";") : ";"];
            }
            case "css-atrule": {
              const o2 = e2.getParentNode(), i2 = DM(r2) && !o2.raws.semicolon && t2.originalText[LM(r2) - 1] !== ";";
              if (Q_(t2)) {
                if (r2.mixin)
                  return [n2("selector"), r2.important ? " !important" : "", i2 ? "" : ";"];
                if (r2.function)
                  return [r2.name, n2("params"), i2 ? "" : ";"];
                if (r2.variable)
                  return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", P_([r2.nodes.length > 0 ? B_ : "", _M(e2, t2, n2)]), B_, "}"] : "", i2 ? "" : ";"];
              }
              return ["@", yM(r2) || r2.name.endsWith(":") ? r2.name : q_(r2.name), r2.params ? [yM(r2) ? "" : DM(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [T_, T_] : /^\s*\n/.test(r2.raws.afterName) ? T_ : " " : " ", n2("params")] : "", r2.selector ? P_([" ", n2("selector")]) : "", r2.value ? N_([" ", n2("value"), Z_(r2) ? dM(r2) ? " " : w_ : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [Z_(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && NM(r2.selector.value) || !r2.selector && typeof r2.params == "string" && NM(r2.params) ? w_ : " ", "{", P_([r2.nodes.length > 0 ? B_ : "", _M(e2, t2, n2)]), B_, "}"] : i2 ? "" : ";"];
            }
            case "media-query-list": {
              const t3 = [];
              return e2.each((e3) => {
                const r3 = e3.getValue();
                r3.type === "media-query" && r3.value === "" || t3.push(n2());
              }, "nodes"), N_(P_(S_(w_, t3)));
            }
            case "media-query":
              return [S_(" ", e2.map(n2, "nodes")), K_(e2, r2) ? "" : ","];
            case "media-type":
            case "media-value":
              return WM(VM(r2.value, t2));
            case "media-feature-expression":
              return r2.nodes ? ["(", ...e2.map(n2, "nodes"), ")"] : r2.value;
            case "media-feature":
              return q_(VM(r2.value.replace(/ +/g, " "), t2));
            case "media-colon":
            case "value-comma":
              return [r2.value, " "];
            case "media-keyword":
            case "selector-string":
              return VM(r2.value, t2);
            case "media-url":
              return VM(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
            case "media-unknown":
            case "selector-comment":
            case "selector-nesting":
            case "value-paren":
            case "value-operator":
            case "value-unicode-range":
            case "value-unknown":
              return r2.value;
            case "selector-root":
              return N_([G_(e2, "custom-selector") ? [$_(e2, "css-atrule").customSelector, w_] : "", S_([",", G_(e2, ["extend", "custom-selector", "nest"]) ? w_ : T_], e2.map(n2, "nodes"))]);
            case "selector-selector":
              return N_(P_(e2.map(n2, "nodes")));
            case "selector-tag": {
              const t3 = e2.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), o2 = n3 && t3.nodes[n3 - 1];
              return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", o2.type === "selector-nesting" ? r2.value : WM(J_(e2, r2.value) ? r2.value.toLowerCase() : r2.value)];
            }
            case "selector-id":
              return ["#", r2.value];
            case "selector-class":
              return [".", WM(VM(r2.value, t2))];
            case "selector-attribute":
              return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? $M(VM(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"];
            case "selector-combinator":
              if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
                const t3 = e2.getParentNode();
                return [t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : w_, r2.value, K_(e2, r2) ? "" : " "];
              }
              return [r2.value.trim().startsWith("(") ? w_ : "", WM(VM(r2.value.trim(), t2)) || w_];
            case "selector-universal":
              return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
            case "selector-pseudo":
              return [q_(r2.value), x_(r2.nodes) ? ["(", S_(", ", e2.map(n2, "nodes")), ")"] : ""];
            case "selector-unknown": {
              const n3 = $_(e2, "css-rule");
              if (n3 && n3.isSCSSNesterProperty)
                return WM(VM(q_(r2.value), t2));
              const o2 = e2.getParentNode();
              if (o2.raws && o2.raws.selector) {
                const e3 = IM(o2), n4 = e3 + o2.raws.selector.length;
                return t2.originalText.slice(e3, n4).trim();
              }
              const i2 = e2.getParentNode(1);
              if (o2.type === "value-paren_group" && i2 && i2.type === "value-func" && i2.value === "selector") {
                const e3 = IM(o2.open) + 1, n4 = LM(o2.close) - 1, r3 = t2.originalText.slice(e3, n4).trim();
                return NM(r3) ? [L_, r3] : r3;
              }
              return r2.value;
            }
            case "value-value":
            case "value-root":
              return n2("group");
            case "value-comment":
              return t2.originalText.slice(IM(r2), LM(r2));
            case "value-comma_group": {
              const t3 = e2.getParentNode(), o2 = e2.getParentNode(1), i2 = W_(e2), u2 = i2 && t3.type === "value-value" && (i2 === "grid" || i2.startsWith("grid-template")), s2 = $_(e2, "css-atrule"), a2 = s2 && Z_(s2), c2 = r2.groups.some((e3) => vM(e3)), l2 = e2.map(n2, "groups"), p2 = [], f2 = U_(e2, "url");
              let d2 = false, h2 = false;
              for (let n3 = 0; n3 < r2.groups.length; ++n3) {
                p2.push(l2[n3]);
                const i3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
                if (f2) {
                  (g2 && iM(g2) || iM(c3)) && p2.push(" ");
                  continue;
                }
                if (G_(e2, "forward") && c3.type === "value-word" && c3.value && i3 !== void 0 && i3.type === "value-word" && i3.value === "as" && g2.type === "value-operator" && g2.value === "*")
                  continue;
                if (!g2)
                  continue;
                if (c3.type === "value-word" && c3.value.endsWith("-") && kM(g2))
                  continue;
                const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
                if (y2 || D2) {
                  d2 = !d2;
                  continue;
                }
                if (d2)
                  continue;
                if (wM(c3) || wM(g2))
                  continue;
                if (c3.type === "value-atword" && c3.value === "")
                  continue;
                if (c3.value === "~")
                  continue;
                if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
                  continue;
                if (i3 && i3.value && i3.value.indexOf("\\") === i3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
                  continue;
                if (c3.value === "\\")
                  continue;
                if (CM(c3, g2))
                  continue;
                if (AM(c3) || FM(c3) || xM(g2) || FM(g2) && hM(g2) || xM(c3) && hM(g2))
                  continue;
                if (c3.value === "--" && AM(g2))
                  continue;
                const E2 = sM(c3), C2 = sM(g2);
                if ((E2 && AM(g2) || C2 && xM(c3)) && hM(g2))
                  continue;
                if (!i3 && oM(c3))
                  continue;
                if (U_(e2, "calc") && (iM(c3) || iM(g2) || uM(c3) || uM(g2)) && hM(g2))
                  continue;
                const b2 = (iM(c3) || uM(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && o2 && BM(o2) && !hM(g2), v2 = m2 && m2.type === "value-func" || m2 && SM(m2) || c3.type === "value-func" || SM(c3), A2 = g2.type === "value-func" || SM(g2) || i3 && i3.type === "value-func" || i3 && SM(i3);
                if (rM(g2) || rM(c3) || U_(e2, "calc") || b2 || !(oM(g2) && !v2 || oM(c3) && !A2 || iM(g2) && !v2 || iM(c3) && !A2 || uM(g2) || uM(c3)) || !(hM(g2) || E2 && (!i3 || i3 && sM(i3))))
                  if (vM(c3)) {
                    if (t3.type === "value-paren_group") {
                      p2.push(O_(T_));
                      continue;
                    }
                    p2.push(T_);
                  } else
                    a2 && (nM(g2) || tM(g2) || pM(g2) || aM(c3) || cM(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : u2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(T_), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || kM(c3) && kM(g2) && LM(c3) === IM(g2) || (kM(c3) && OM(g2) && LM(c3) === IM(g2.open) ? p2.push(B_) : c3.value === "with" && OM(g2) ? p2.push(" ") : p2.push(w_));
              }
              return c2 && p2.push(L_), h2 && p2.unshift(T_), a2 ? N_(P_(p2)) : H_(e2) ? N_(k_(p2)) : N_(P_(k_(p2)));
            }
            case "value-paren_group": {
              const o2 = e2.getParentNode();
              if (o2 && lM(o2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
                return [r2.open ? n2("open") : "", S_(",", e2.map(n2, "groups")), r2.close ? n2("close") : ""];
              if (!r2.open) {
                const t3 = e2.map(n2, "groups"), r3 = [];
                for (let e3 = 0; e3 < t3.length; e3++)
                  e3 !== 0 && r3.push([",", w_]), r3.push(t3[e3]);
                return N_(P_(k_(r3)));
              }
              const i2 = bM(e2), u2 = E_(r2.groups), s2 = u2 && u2.type === "value-comment", a2 = mM(r2, o2), c2 = PM(r2, o2), l2 = c2 || i2 && !a2, p2 = c2 || a2, f2 = N_([r2.open ? n2("open") : "", P_([B_, S_([",", w_], e2.map((e3) => {
                const t3 = e3.getValue(), r3 = n2();
                if (gM(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
                  const e4 = __(r3.contents.contents);
                  return e4[1] = N_(e4[1]), N_(O_(r3));
                }
                return r3;
              }, "groups"))]), I_(!s2 && Y_(t2.parser, t2.originalText) && i2 && jM(t2) ? "," : ""), B_, r2.close ? n2("close") : ""], { shouldBreak: l2 });
              return p2 ? O_(f2) : f2;
            }
            case "value-func":
              return [r2.value, G_(e2, "supports") && TM(r2) ? " " : "", n2("group")];
            case "value-number":
              return [qM(r2.value), q_(r2.unit)];
            case "value-word":
              return r2.isColor && r2.isHex || X_(r2.value) ? r2.value.toLowerCase() : r2.value;
            case "value-colon": {
              const t3 = e2.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), o2 = n3 && t3.groups[n3 - 1];
              return [r2.value, o2 && typeof o2.value == "string" && E_(o2.value) === "\\" || U_(e2, "url") ? "" : w_];
            }
            case "value-string":
              return b_(r2.raws.quote + r2.value + r2.raws.quote, t2);
            case "value-atword":
              return ["@", r2.value];
            default:
              throw new Error("Unknown postcss type ".concat(JSON.stringify(r2.type)));
          }
        }, embed: R_, insertPragma: V_, massageAstNode: M_ };
        var zM = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 }, GM = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 }, HM = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        const JM = bE, XM = UM, YM = { singleQuote: bj.singleQuote }, KM = [JM({ name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 }, (e2) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e2.extensions, ".wxss"] })), JM(zM, () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), JM(GM, () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), JM(HM, () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))];
        var QM = { languages: KM, options: YM, printers: { postcss: XM }, parsers: void 0 };
        var ZM = { locStart: function(e2) {
          return e2.loc.start.offset;
        }, locEnd: function(e2) {
          return e2.loc.end.offset;
        } };
        function eR(e2, t2) {
          if (e2.type === "TextNode") {
            const n2 = e2.chars.trim();
            if (!n2)
              return null;
            t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
          }
          e2.type === "AttrNode" && e2.name.toLowerCase() === "class" && delete t2.value;
        }
        eR.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]);
        var tR = eR;
        const nR = au;
        const rR = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
        function oR(e2) {
          return iR(e2, ["TextNode"]) && !/\S/.test(e2.chars);
        }
        function iR(e2, t2) {
          return e2 && t2.includes(e2.type);
        }
        function uR(e2, t2) {
          return iR(e2.getParentNode(0), t2);
        }
        function sR(e2, t2) {
          const n2 = e2.getValue(), r2 = e2.getParentNode(0) || {}, o2 = r2.children || r2.body || r2.parts || [], i2 = o2.indexOf(n2);
          return i2 !== -1 && o2[i2 + t2];
        }
        function aR(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return sR(e2, -t2);
        }
        function cR(e2) {
          return sR(e2, 1);
        }
        function lR(e2) {
          return iR(e2, ["MustacheCommentStatement"]) && typeof e2.value == "string" && e2.value.trim() === "prettier-ignore";
        }
        var pR = { getNextNode: cR, getPreviousNode: aR, hasPrettierIgnore: function(e2) {
          const t2 = e2.getValue(), n2 = aR(e2, 2);
          return lR(t2) || lR(n2);
        }, isLastNodeOfSiblings: function(e2) {
          const t2 = e2.getValue(), n2 = e2.getParentNode(0);
          return !(!uR(e2, ["ElementNode"]) || nR(n2.children) !== t2) || !(!uR(e2, ["Block"]) || nR(n2.body) !== t2);
        }, isNextNodeOfSomeType: function(e2, t2) {
          return iR(cR(e2), t2);
        }, isNodeOfSomeType: iR, isParentOfSomeType: uR, isPreviousNodeOfSomeType: function(e2, t2) {
          return iR(aR(e2), t2);
        }, isVoid: function(e2) {
          return function(e3) {
            return iR(e3, ["ElementNode"]) && typeof e3.tag == "string" && e3.tag[0] !== ":" && (function(e4) {
              return e4.toUpperCase() === e4;
            }(e3.tag[0]) || e3.tag.includes("."));
          }(e2) && e2.children.every((e3) => oR(e3)) || rR.has(e2.tag);
        }, isWhitespaceNode: oR };
        const { builders: { dedent: fR, fill: dR, group: hR, hardline: gR, ifBreak: mR, indent: yR, join: DR, line: ER, softline: CR }, utils: { getDocParts: bR, replaceTextEndOfLine: vR } } = Zc, { getPreferredQuote: AR, isNonEmptyArray: FR } = dc, { locStart: xR, locEnd: SR } = ZM, wR = tR, { getNextNode: TR, getPreviousNode: BR, hasPrettierIgnore: NR, isLastNodeOfSiblings: kR, isNextNodeOfSomeType: PR, isNodeOfSomeType: OR, isParentOfSomeType: IR, isPreviousNodeOfSomeType: LR, isVoid: jR, isWhitespaceNode: _R } = pR;
        function MR(e2, t2) {
          return xR(e2) - xR(t2);
        }
        function RR(e2, t2, n2) {
          const r2 = e2.getValue().children.every((e3) => _R(e3));
          return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e2.map((e3, r3) => {
            const o2 = n2();
            return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [CR, o2] : o2;
          }, "children");
        }
        function VR(e2) {
          return jR(e2) ? mR([CR, "/>"], [" />", CR]) : mR([CR, ">"], ">");
        }
        function $R(e2) {
          return [e2.escaped === false ? "{{{" : "{{", e2.strip && e2.strip.open ? "~" : ""];
        }
        function WR(e2) {
          const t2 = e2.escaped === false ? "}}}" : "}}";
          return [e2.strip && e2.strip.close ? "~" : "", t2];
        }
        function qR(e2) {
          return [$R(e2), e2.closeStrip.open ? "~" : "", "/"];
        }
        function UR(e2) {
          const t2 = WR(e2);
          return [e2.closeStrip.close ? "~" : "", t2];
        }
        function zR(e2) {
          return [$R(e2), e2.inverseStrip.open ? "~" : ""];
        }
        function GR(e2) {
          const t2 = WR(e2);
          return [e2.inverseStrip.close ? "~" : "", t2];
        }
        function HR(e2, t2) {
          const n2 = e2.getValue(), r2 = function(e3) {
            return [$R(e3), e3.openStrip.open ? "~" : "", "#"];
          }(n2), o2 = function(e3) {
            const t3 = WR(e3);
            return [e3.openStrip.close ? "~" : "", t3];
          }(n2), i2 = [sV(e2, t2)], u2 = aV(e2, t2);
          if (u2 && i2.push(ER, u2), FR(n2.program.blockParams)) {
            const e3 = cV(n2.program);
            i2.push(ER, e3);
          }
          return hR([r2, yR(i2), CR, o2]);
        }
        function JR(e2, t2) {
          return [t2.htmlWhitespaceSensitivity === "ignore" ? gR : "", zR(e2), "else", GR(e2)];
        }
        function XR(e2, t2) {
          const n2 = e2.getParentNode(1);
          return [zR(n2), "else if ", aV(e2, t2), GR(n2)];
        }
        function YR(e2, t2, n2) {
          const r2 = e2.getValue();
          if (n2.htmlWhitespaceSensitivity === "ignore") {
            return [KR(r2) ? CR : gR, qR(r2), t2("path"), UR(r2)];
          }
          return [qR(r2), t2("path"), UR(r2)];
        }
        function KR(e2) {
          return OR(e2, ["BlockStatement"]) && e2.program.body.every((e3) => _R(e3));
        }
        function QR(e2) {
          return OR(e2, ["BlockStatement"]) && e2.inverse;
        }
        function ZR(e2, t2, n2) {
          if (KR(e2.getValue()))
            return "";
          const r2 = t2("program");
          return n2.htmlWhitespaceSensitivity === "ignore" ? yR([gR, r2]) : yR(r2);
        }
        function eV(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = t2("inverse"), i2 = n2.htmlWhitespaceSensitivity === "ignore" ? [gR, o2] : o2;
          return function(e3) {
            return QR(e3) && e3.inverse.body.length === 1 && OR(e3.inverse.body[0], ["BlockStatement"]) && e3.inverse.body[0].path.parts[0] === "if";
          }(r2) ? i2 : QR(r2) ? [JR(r2, n2), yR(i2)] : "";
        }
        function tV(e2) {
          return bR(DR(ER, function(e3) {
            return e3.split(/[\t\n\f\r ]+/);
          }(e2)));
        }
        function nV(e2) {
          return (e2 = typeof e2 == "string" ? e2 : "").split("\n").length - 1;
        }
        function rV() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return Array.from({ length: Math.min(e2, 2) }).fill(gR);
        }
        function oV(e2, t2) {
          const { quote: n2, regex: r2 } = AR(e2, t2);
          return [n2, e2.replace(r2, "\\".concat(n2)), n2];
        }
        function iV(e2, t2) {
          const n2 = sV(e2, t2), r2 = aV(e2, t2);
          return r2 ? yR([n2, ER, hR(r2)]) : n2;
        }
        function uV(e2, t2) {
          const n2 = sV(e2, t2), r2 = aV(e2, t2);
          return r2 ? [yR([n2, ER, r2]), CR] : n2;
        }
        function sV(e2, t2) {
          return t2("path");
        }
        function aV(e2, t2) {
          const n2 = e2.getValue(), r2 = [];
          if (n2.params.length > 0) {
            const n3 = e2.map(t2, "params");
            r2.push(...n3);
          }
          if (n2.hash && n2.hash.pairs.length > 0) {
            const e3 = t2("hash");
            r2.push(e3);
          }
          return r2.length === 0 ? "" : DR(ER, r2);
        }
        function cV(e2) {
          return ["as |", e2.blockParams.join(" "), "|"];
        }
        var lV = { print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2)
            return "";
          if (NR(e2))
            return t2.originalText.slice(xR(r2), SR(r2));
          const o2 = t2.singleQuote ? "'" : '"';
          switch (r2.type) {
            case "Block":
            case "Program":
            case "Template":
              return hR(e2.map(n2, "body"));
            case "ElementNode": {
              const o3 = hR(function(e3, t3) {
                const n3 = e3.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e4) => FR(n3[e4])), o4 = r3.flatMap((e4) => n3[e4]).sort(MR);
                for (const n4 of r3)
                  e3.each((e4) => {
                    const n5 = o4.indexOf(e4.getValue());
                    o4.splice(n5, 1, [ER, t3()]);
                  }, n4);
                FR(n3.blockParams) && o4.push(ER, cV(n3));
                return ["<", n3.tag, yR(o4), VR(n3)];
              }(e2, n2)), i2 = t2.htmlWhitespaceSensitivity === "ignore" && PR(e2, ["ElementNode"]) ? CR : "";
              if (jR(r2))
                return [o3, i2];
              const u2 = ["</", r2.tag, ">"];
              return r2.children.length === 0 ? [o3, yR(u2), i2] : t2.htmlWhitespaceSensitivity === "ignore" ? [o3, yR(RR(e2, t2, n2)), gR, yR(u2), i2] : [o3, yR(hR(RR(e2, t2, n2))), yR(u2), i2];
            }
            case "BlockStatement": {
              const o3 = e2.getParentNode(1);
              return o3 && o3.inverse && o3.inverse.body.length === 1 && o3.inverse.body[0] === r2 && o3.inverse.body[0].path.parts[0] === "if" ? [XR(e2, n2), ZR(e2, n2, t2), eV(e2, n2, t2)] : [HR(e2, n2), hR([ZR(e2, n2, t2), eV(e2, n2, t2), YR(e2, n2, t2)])];
            }
            case "ElementModifierStatement":
              return hR(["{{", uV(e2, n2), "}}"]);
            case "MustacheStatement":
              return hR([$R(r2), uV(e2, n2), WR(r2)]);
            case "SubExpression":
              return hR(["(", iV(e2, n2), CR, ")"]);
            case "AttrNode": {
              const e3 = r2.value.type === "TextNode";
              if (e3 && r2.value.chars === "" && xR(r2.value) === SR(r2.value))
                return r2.name;
              const t3 = e3 ? AR(r2.value.chars, o2).quote : r2.value.type === "ConcatStatement" ? AR(r2.value.parts.filter((e4) => e4.type === "TextNode").map((e4) => e4.chars).join(""), o2).quote : "", i2 = n2("value");
              return [r2.name, "=", t3, r2.name === "class" && t3 ? hR(yR(i2)) : i2, t3];
            }
            case "ConcatStatement":
              return e2.map(n2, "parts");
            case "Hash":
              return DR(ER, e2.map(n2, "pairs"));
            case "HashPair":
              return [r2.key, "=", n2("value")];
            case "TextNode": {
              let n3 = r2.chars.replace(/{{/g, "\\{{");
              const o3 = function(e3) {
                for (let t3 = 0; t3 < 2; t3++) {
                  const n4 = e3.getParentNode(t3);
                  if (n4 && n4.type === "AttrNode")
                    return n4.name.toLowerCase();
                }
              }(e2);
              if (o3) {
                if (o3 === "class") {
                  const t3 = n3.trim().split(/\s+/).join(" ");
                  let r3 = false, o4 = false;
                  return IR(e2, ["ConcatStatement"]) && (LR(e2, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), PR(e2, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (o4 = true)), [r3 ? ER : "", t3, o4 ? ER : ""];
                }
                return vR(n3);
              }
              const i2 = /^[\t\n\f\r ]*$/.test(n3), u2 = !BR(e2), s2 = !TR(e2);
              if (t2.htmlWhitespaceSensitivity !== "ignore") {
                const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, o4 = s2 && IR(e2, ["Template"]), a3 = u2 && IR(e2, ["Template"]);
                if (i2) {
                  if (a3 || o4)
                    return "";
                  let t4 = [ER];
                  const r4 = nV(n3);
                  return r4 && (t4 = rV(r4)), kR(e2) && (t4 = t4.map((e3) => fR(e3))), t4;
                }
                const [c3] = n3.match(t3), [l3] = n3.match(r3);
                let p3 = [];
                if (c3) {
                  p3 = [ER];
                  const e3 = nV(c3);
                  e3 && (p3 = rV(e3)), n3 = n3.replace(t3, "");
                }
                let f3 = [];
                if (l3) {
                  if (!o4) {
                    f3 = [ER];
                    const t4 = nV(l3);
                    t4 && (f3 = rV(t4)), kR(e2) && (f3 = f3.map((e3) => fR(e3)));
                  }
                  n3 = n3.replace(r3, "");
                }
                return [...p3, dR(tV(n3)), ...f3];
              }
              const a2 = nV(n3);
              let c2 = function(e3) {
                return nV(((e3 = typeof e3 == "string" ? e3 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
              }(n3), l2 = function(e3) {
                return nV(((e3 = typeof e3 == "string" ? e3 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
              }(n3);
              if ((u2 || s2) && i2 && IR(e2, ["Block", "ElementNode", "Template"]))
                return "";
              i2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (PR(e2, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), LR(e2, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
              let p2 = "", f2 = "";
              return l2 === 0 && PR(e2, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && LR(e2, ["MustacheStatement"]) && (p2 = " "), u2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...rV(c2), dR(tV(n3)), ...rV(l2)];
            }
            case "MustacheCommentStatement": {
              const e3 = xR(r2), n3 = SR(r2), o3 = t2.originalText.charAt(e3 + 2) === "~", i2 = t2.originalText.charAt(n3 - 3) === "~", u2 = r2.value.includes("}}") ? "--" : "";
              return ["{{", o3 ? "~" : "", "!", u2, r2.value, u2, i2 ? "~" : "", "}}"];
            }
            case "PathExpression":
              return r2.original;
            case "BooleanLiteral":
            case "NumberLiteral":
              return String(r2.value);
            case "CommentStatement":
              return ["<!--", r2.value, "-->"];
            case "StringLiteral":
              if (function(e3) {
                let t3 = 0, n3 = e3.getParentNode(t3);
                for (; n3 && OR(n3, ["SubExpression"]); )
                  t3++, n3 = e3.getParentNode(t3);
                if (n3 && OR(e3.getParentNode(t3 + 1), ["ConcatStatement"]) && OR(e3.getParentNode(t3 + 2), ["AttrNode"]))
                  return true;
                return false;
              }(e2)) {
                const e3 = t2.singleQuote ? '"' : "'";
                return oV(r2.value, e3);
              }
              return oV(r2.value, o2);
            case "UndefinedLiteral":
              return "undefined";
            case "NullLiteral":
              return "null";
            default:
              throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
          }
        }, massageAstNode: wR };
        const pV = lV;
        var fV = { languages: [bE({ name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 }, () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], printers: { glimmer: pV }, parsers: void 0 };
        var dV = { hasPragma: function(e2) {
          return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e2);
        }, insertPragma: function(e2) {
          return "# @format\n\n" + e2;
        } };
        var hV = { locStart: function(e2) {
          return typeof e2.start == "number" ? e2.start : e2.loc && e2.loc.start;
        }, locEnd: function(e2) {
          return typeof e2.end == "number" ? e2.end : e2.loc && e2.loc.end;
        } };
        const { builders: { join: gV, hardline: mV, line: yV, softline: DV, group: EV, indent: CV, ifBreak: bV } } = Zc, { isNextLineEmpty: vV, isNonEmptyArray: AV } = dc, { insertPragma: FV } = dV, { locStart: xV, locEnd: SV } = hV;
        function wV(e2, t2, n2) {
          if (n2.directives.length === 0)
            return "";
          const r2 = gV(yV, e2.map(t2, "directives"));
          return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? EV([yV, r2]) : [" ", EV(CV([DV, r2]))];
        }
        function TV(e2, t2, n2) {
          const r2 = e2.getValue().length;
          return e2.map((e3, o2) => {
            const i2 = n2();
            return vV(t2.originalText, e3.getValue(), SV) && o2 < r2 - 1 ? [i2, mV] : i2;
          });
        }
        function BV(e2, t2, n2) {
          const r2 = e2.getNode(), o2 = [], { interfaces: i2 } = r2, u2 = e2.map((e3) => n2(e3), "interfaces");
          for (let e3 = 0; e3 < i2.length; e3++) {
            const n3 = i2[e3];
            o2.push(u2[e3]);
            const r3 = i2[e3 + 1];
            if (r3) {
              const e4 = t2.originalText.slice(n3.loc.end, r3.loc.start), i3 = e4.includes("#"), u3 = e4.replace(/#.*/g, "").trim();
              o2.push(u3 === "," ? "," : " &", i3 ? yV : " ");
            }
          }
          return o2;
        }
        function NV() {
        }
        NV.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
        var kV = { print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!r2)
            return "";
          if (typeof r2 == "string")
            return r2;
          switch (r2.kind) {
            case "Document": {
              const r3 = [];
              return e2.each((e3, o2, i2) => {
                r3.push(n2()), o2 !== i2.length - 1 && (r3.push(mV), vV(t2.originalText, e3.getValue(), SV) && r3.push(mV));
              }, "definitions"), [...r3, mV];
            }
            case "OperationDefinition": {
              const o2 = t2.originalText[xV(r2)] !== "{", i2 = Boolean(r2.name);
              return [o2 ? r2.operation : "", o2 && i2 ? [" ", n2("name")] : "", o2 && !i2 && AV(r2.variableDefinitions) ? " " : "", AV(r2.variableDefinitions) ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "variableDefinitions"))]), DV, ")"]) : "", wV(e2, n2, r2), r2.selectionSet && (o2 || i2) ? " " : "", n2("selectionSet")];
            }
            case "FragmentDefinition":
              return ["fragment ", n2("name"), AV(r2.variableDefinitions) ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "variableDefinitions"))]), DV, ")"]) : "", " on ", n2("typeCondition"), wV(e2, n2, r2), " ", n2("selectionSet")];
            case "SelectionSet":
              return ["{", CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "selections"))]), mV, "}"];
            case "Field":
              return EV([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t2, n2), "arguments"))]), DV, ")"]) : "", wV(e2, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
            case "Name":
            case "IntValue":
            case "FloatValue":
            case "EnumValue":
              return r2.value;
            case "StringValue":
              return r2.block ? ['"""', mV, gV(mV, r2.value.replace(/"""/g, "\\$&").split("\n")), mV, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
            case "BooleanValue":
              return r2.value ? "true" : "false";
            case "NullValue":
              return "null";
            case "Variable":
              return ["$", n2("name")];
            case "ListValue":
              return EV(["[", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "values"))]), DV, "]"]);
            case "ObjectValue":
              return EV(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", CV([DV, gV([bV("", ", "), DV], e2.map(n2, "fields"))]), DV, bV("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
            case "ObjectField":
            case "Argument":
              return [n2("name"), ": ", n2("value")];
            case "Directive":
              return ["@", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t2, n2), "arguments"))]), DV, ")"]) : ""];
            case "NamedType":
              return n2("name");
            case "VariableDefinition":
              return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wV(e2, n2, r2)];
            case "ObjectTypeExtension":
            case "ObjectTypeDefinition":
              return [n2("description"), r2.description ? mV : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BV(e2, t2, n2)] : "", wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "fields"))]), mV, "}"] : ""];
            case "FieldDefinition":
              return [n2("description"), r2.description ? mV : "", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t2, n2), "arguments"))]), DV, ")"]) : "", ": ", n2("type"), wV(e2, n2, r2)];
            case "DirectiveDefinition":
              return [n2("description"), r2.description ? mV : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? EV(["(", CV([DV, gV([bV("", ", "), DV], e2.call((e3) => TV(e3, t2, n2), "arguments"))]), DV, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", gV(" | ", e2.map(n2, "locations"))];
            case "EnumTypeExtension":
            case "EnumTypeDefinition":
              return [n2("description"), r2.description ? mV : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), wV(e2, n2, r2), r2.values.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "values"))]), mV, "}"] : ""];
            case "EnumValueDefinition":
              return [n2("description"), r2.description ? mV : "", n2("name"), wV(e2, n2, r2)];
            case "InputValueDefinition":
              return [n2("description"), r2.description ? r2.description.block ? mV : yV : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", wV(e2, n2, r2)];
            case "InputObjectTypeExtension":
            case "InputObjectTypeDefinition":
              return [n2("description"), r2.description ? mV : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "fields"))]), mV, "}"] : ""];
            case "SchemaDefinition":
              return ["schema", wV(e2, n2, r2), " {", r2.operationTypes.length > 0 ? CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "operationTypes"))]) : "", mV, "}"];
            case "OperationTypeDefinition":
              return [n2("operation"), ": ", n2("type")];
            case "InterfaceTypeExtension":
            case "InterfaceTypeDefinition":
              return [n2("description"), r2.description ? mV : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...BV(e2, t2, n2)] : "", wV(e2, n2, r2), r2.fields.length > 0 ? [" {", CV([mV, gV(mV, e2.call((e3) => TV(e3, t2, n2), "fields"))]), mV, "}"] : ""];
            case "FragmentSpread":
              return ["...", n2("name"), wV(e2, n2, r2)];
            case "InlineFragment":
              return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", wV(e2, n2, r2), " ", n2("selectionSet")];
            case "UnionTypeExtension":
            case "UnionTypeDefinition":
              return EV([n2("description"), r2.description ? mV : "", EV([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), wV(e2, n2, r2), r2.types.length > 0 ? [" =", bV("", " "), CV([bV([yV, "  "]), gV([yV, "| "], e2.map(n2, "types"))])] : ""])]);
            case "ScalarTypeExtension":
            case "ScalarTypeDefinition":
              return [n2("description"), r2.description ? mV : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), wV(e2, n2, r2)];
            case "NonNullType":
              return [n2("type"), "!"];
            case "ListType":
              return ["[", n2("type"), "]"];
            default:
              throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
          }
        }, massageAstNode: NV, hasPrettierIgnore: function(e2) {
          const t2 = e2.getValue();
          return t2 && Array.isArray(t2.comments) && t2.comments.some((e3) => e3.value.trim() === "prettier-ignore");
        }, insertPragma: FV, printComment: function(e2) {
          const t2 = e2.getValue();
          if (t2.kind === "Comment")
            return "#" + t2.value.trimEnd();
          throw new Error("Not a comment: " + JSON.stringify(t2));
        }, canAttachComment: function(e2) {
          return e2.kind && e2.kind !== "Comment";
        } };
        const PV = kV, OV = { bracketSpacing: bj.bracketSpacing };
        var IV = { languages: [bE({ name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 }, () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], options: OV, printers: { graphql: PV }, parsers: void 0 };
        var LV = { locStart: function(e2) {
          return e2.position.start.offset;
        }, locEnd: function(e2) {
          return e2.position.end.offset;
        } };
        const { getLast: jV } = dc, { locStart: _V, locEnd: MV } = LV, { cjkPattern: RV, kPattern: VV, punctuationPattern: $V } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, WV = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], qV = [...WV, "tableCell", "paragraph", "heading"], UV = new RegExp(VV), zV = new RegExp($V);
        function GV(e2, t2) {
          const [, n2, r2, o2] = t2.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
          return { numberText: n2, marker: r2, leadingSpaces: o2 };
        }
        var HV = { mapAst: function(e2, t2) {
          return function e3(n2, r2, o2) {
            const i2 = Object.assign({}, t2(n2, r2, o2));
            return i2.children && (i2.children = i2.children.map((t3, n3) => e3(t3, n3, [i2, ...o2]))), i2;
          }(e2, null, []);
        }, splitText: function(e2, t2) {
          const n2 = "non-cjk", r2 = "cj-letter", o2 = "cjk-punctuation", i2 = [], u2 = (t2.proseWrap === "preserve" ? e2 : e2.replace(new RegExp("(".concat(RV, ")\n(").concat(RV, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
          for (const [e3, t3] of u2.entries()) {
            if (e3 % 2 == 1) {
              i2.push({ type: "whitespace", value: /\n/.test(t3) ? "\n" : " " });
              continue;
            }
            if ((e3 === 0 || e3 === u2.length - 1) && t3 === "")
              continue;
            const a2 = t3.split(new RegExp("(".concat(RV, ")")));
            for (const [e4, t4] of a2.entries())
              (e4 !== 0 && e4 !== a2.length - 1 || t4 !== "") && (e4 % 2 != 0 ? s2(zV.test(t4) ? { type: "word", value: t4, kind: o2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t4, kind: UV.test(t4) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t4 !== "" && s2({ type: "word", value: t4, kind: n2, hasLeadingPunctuation: zV.test(t4[0]), hasTrailingPunctuation: zV.test(jV(t4)) }));
          }
          return i2;
          function s2(e3) {
            const t3 = jV(i2);
            var u3, s3;
            t3 && t3.type === "word" && (t3.kind === n2 && e3.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e3.kind === n2 && !e3.hasLeadingPunctuation ? i2.push({ type: "whitespace", value: " " }) : (u3 = n2, s3 = o2, t3.kind === u3 && e3.kind === s3 || t3.kind === s3 && e3.kind === u3 || [t3.value, e3.value].some((e4) => /\u3000/.test(e4)) || i2.push({ type: "whitespace", value: "" }))), i2.push(e3);
          }
        }, punctuationPattern: $V, getFencedCodeBlockValue: function(e2, t2) {
          const { value: n2 } = e2;
          return e2.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
        }, getOrderedListItemInfo: GV, hasGitDiffFriendlyOrderedList: function(e2, t2) {
          if (!e2.ordered)
            return false;
          if (e2.children.length < 2)
            return false;
          const n2 = Number(GV(e2.children[0], t2.originalText).numberText), r2 = Number(GV(e2.children[1], t2.originalText).numberText);
          if (n2 === 0 && e2.children.length > 2) {
            const n3 = Number(GV(e2.children[2], t2.originalText).numberText);
            return r2 === 1 && n3 === 1;
          }
          return r2 === 1;
        }, INLINE_NODE_TYPES: WV, INLINE_NODE_WRAPPER_TYPES: qV, isAutolink: function(e2) {
          if (!e2 || e2.type !== "link" || e2.children.length !== 1)
            return false;
          const t2 = e2.children[0];
          return t2 && _V(e2) === _V(t2) && MV(e2) === MV(t2);
        } };
        const { inferParserByLanguage: JV, getMaxContinuousCount: XV } = dc, { builders: { hardline: YV, markAsRoot: KV }, utils: { replaceEndOfLine: QV } } = Zc, ZV = Wj, { getFencedCodeBlockValue: e$ } = HV;
        var t$ = function(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          if (o2.type === "code" && o2.lang !== null) {
            const e3 = JV(o2.lang, r2);
            if (e3) {
              const t3 = r2.__inJsTemplate ? "~" : "`", i2 = t3.repeat(Math.max(3, XV(o2.value, t3) + 1)), u2 = { parser: e3 };
              o2.lang === "tsx" && (u2.filepath = "dummy.tsx");
              const s2 = n2(e$(o2, r2.originalText), u2, { stripTrailingHardline: true });
              return KV([i2, o2.lang, o2.meta ? " " + o2.meta : "", YV, QV(s2), YV, i2]);
            }
          }
          switch (o2.type) {
            case "front-matter":
              return ZV(o2, n2);
            case "importExport":
              return [n2(o2.value, { parser: "babel" }, { stripTrailingHardline: true }), YV];
            case "jsx":
              return n2("<$>".concat(o2.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
          }
          return null;
        };
        const n$ = Hj, r$ = ["format", "prettier"];
        function o$(e2) {
          const t2 = "@(".concat(r$.join("|"), ")"), n2 = new RegExp(["<!--\\s*".concat(t2, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(t2, "\\s*\\*\\/\\s*}"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t2, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m"), r2 = e2.match(n2);
          return r2 && r2.index === 0;
        }
        var i$ = { startWithPragma: o$, hasPragma: (e2) => o$(n$(e2).content.trimStart()), insertPragma: (e2) => {
          const t2 = n$(e2), n2 = "<!-- @".concat(r$[0], " -->");
          return t2.frontMatter ? "".concat(t2.frontMatter.raw, "\n\n").concat(n2, "\n\n").concat(t2.content) : "".concat(n2, "\n\n").concat(t2.content);
        } };
        const u$ = au, { getOrderedListItemInfo: s$, mapAst: a$, splitText: c$ } = HV, l$ = /^.$/us;
        function p$(e2, t2, n2) {
          return a$(e2, (e3) => {
            if (!e3.children)
              return e3;
            const r2 = e3.children.reduce((e4, r3) => {
              const o2 = u$(e4);
              return o2 && t2(o2, r3) ? e4.splice(-1, 1, n2(o2, r3)) : e4.push(r3), e4;
            }, []);
            return Object.assign(Object.assign({}, e3), {}, { children: r2 });
          });
        }
        var f$ = function(e2, t2) {
          return e2 = function(e3, t3) {
            return a$(e3, (e4) => e4.type === "text" && e4.value !== "*" && e4.value !== "_" && l$.test(e4.value) && e4.position.end.offset - e4.position.start.offset !== e4.value.length ? Object.assign(Object.assign({}, e4), {}, { value: t3.originalText.slice(e4.position.start.offset, e4.position.end.offset) }) : e4);
          }(e2, t2), e2 = function(e3, t3) {
            return a$(e3, (e4, n2, r2) => {
              if (e4.type === "code") {
                const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e4.position.start.offset, e4.position.end.offset));
                if (e4.isIndented = n3, n3)
                  for (let e5 = 0; e5 < r2.length; e5++) {
                    const t4 = r2[e5];
                    if (t4.hasIndentedCodeblock)
                      break;
                    t4.type === "list" && (t4.hasIndentedCodeblock = true);
                  }
              }
              return e4;
            });
          }(e2 = function(e3) {
            return a$(e3, (e4) => e4.type !== "inlineCode" ? e4 : Object.assign(Object.assign({}, e4), {}, { value: e4.value.replace(/\s+/g, " ") }));
          }(e2 = function(e3) {
            return p$(e3, (e4, t3) => e4.type === "text" && t3.type === "text", (e4, t3) => ({ type: "text", value: e4.value + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
          }(e2)), t2), e2 = function(e3, t3) {
            return a$(e3, (e4, t4, n3) => {
              if (e4.type === "list" && e4.children.length > 0) {
                for (let t5 = 0; t5 < n3.length; t5++) {
                  const r3 = n3[t5];
                  if (r3.type === "list" && !r3.isAligned)
                    return e4.isAligned = false, e4;
                }
                e4.isAligned = r2(e4);
              }
              return e4;
            });
            function n2(e4) {
              return e4.children.length === 0 ? -1 : e4.children[0].position.start.column - 1;
            }
            function r2(e4) {
              if (!e4.ordered)
                return true;
              const [r3, o2] = e4.children;
              if (s$(r3, t3.originalText).leadingSpaces.length > 1)
                return true;
              const i2 = n2(r3);
              if (i2 === -1)
                return false;
              if (e4.children.length === 1)
                return i2 % t3.tabWidth == 0;
              if (i2 !== n2(o2))
                return false;
              if (i2 % t3.tabWidth == 0)
                return true;
              return s$(o2, t3.originalText).leadingSpaces.length > 1;
            }
          }(e2, t2), e2 = function(e3, t3) {
            return a$(e3, (e4, n2, r2) => {
              let [o2] = r2;
              if (e4.type !== "text")
                return e4;
              let { value: i2 } = e4;
              return o2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === o2.children.length - 1 && (i2 = i2.trimEnd())), { type: "sentence", position: e4.position, children: c$(i2, t3) };
            });
          }(e2, t2), e2 = function(e3) {
            return p$(e3, (e4, t3) => e4.type === "importExport" && t3.type === "importExport", (e4, t3) => ({ type: "importExport", value: e4.value + "\n\n" + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
          }(e2 = function(e3) {
            return a$(e3, (e4) => e4.type !== "import" && e4.type !== "export" ? e4 : Object.assign(Object.assign({}, e4), {}, { type: "importExport" }));
          }(e2));
        };
        const { isFrontMatterNode: d$ } = dc, { startWithPragma: h$ } = i$, g$ = /* @__PURE__ */ new Set(["position", "raw"]);
        function m$(e2, t2, n2) {
          return e2.type !== "front-matter" && e2.type !== "code" && e2.type !== "yaml" && e2.type !== "import" && e2.type !== "export" && e2.type !== "jsx" || delete t2.value, e2.type === "list" && delete t2.isAligned, e2.type !== "list" && e2.type !== "listItem" || (delete t2.spread, delete t2.loose), e2.type === "text" ? null : (e2.type === "inlineCode" && (t2.value = e2.value.replace(/[\t\n ]+/g, " ")), e2.type === "wikiLink" && (t2.value = e2.value.trim().replace(/[\t\n]+/g, " ")), e2.type !== "definition" && e2.type !== "linkReference" || (t2.label = e2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e2.type !== "definition" && e2.type !== "link" && e2.type !== "image" || !e2.title || (t2.title = e2.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e2 || d$(n2.children[0]) && n2.children[1] === e2) && e2.type === "html" && h$(e2.value) ? null : void 0);
        }
        m$.ignoredProperties = g$;
        var y$ = m$;
        const { getLast: D$, getMinNotPresentContinuousCount: E$, getMaxContinuousCount: C$, getStringWidth: b$, isNonEmptyArray: v$ } = dc, { builders: { breakParent: A$, join: F$, line: x$, literalline: S$, markAsRoot: w$, hardline: T$, softline: B$, ifBreak: N$, fill: k$, align: P$, indent: O$, group: I$, hardlineWithoutBreakParent: L$ }, utils: { normalizeDoc: j$, replaceTextEndOfLine: _$ }, printer: { printDocToString: M$ } } = Zc, R$ = t$, { insertPragma: V$ } = i$, { locStart: $$, locEnd: W$ } = LV, q$ = f$, U$ = y$, { getFencedCodeBlockValue: z$, hasGitDiffFriendlyOrderedList: G$, splitText: H$, punctuationPattern: J$, INLINE_NODE_TYPES: X$, INLINE_NODE_WRAPPER_TYPES: Y$, isAutolink: K$ } = HV, Q$ = /* @__PURE__ */ new Set(["importExport"]), Z$ = ["heading", "tableCell", "link", "wikiLink"], eW = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
        function tW(e2, t2, n2, r2) {
          const o2 = e2.getValue(), i2 = o2.checked === null ? "" : o2.checked ? "[x] " : "[ ] ";
          return [i2, sW(e2, t2, n2, { processor: (e3, o3) => {
            if (o3 === 0 && e3.getValue().type !== "list")
              return P$(" ".repeat(i2.length), n2());
            const u2 = " ".repeat(function(e4, t3, n3) {
              return e4 < t3 ? t3 : e4 > n3 ? n3 : e4;
            }(t2.tabWidth - r2.length, 0, 3));
            return [u2, P$(u2, n2())];
          } })];
        }
        function nW(e2, t2) {
          return function(e3, t3, n2) {
            let r2 = -1;
            for (const o2 of t3.children)
              if (o2.type === e3.type && n2(o2) ? r2++ : r2 = -1, o2 === e3)
                return r2;
          }(e2, t2, (t3) => t3.ordered === e2.ordered);
        }
        function rW(e2, t2) {
          const n2 = Array.isArray(t2) ? t2 : [t2];
          let r2, o2 = -1;
          for (; r2 = e2.getParentNode(++o2); )
            if (n2.includes(r2.type))
              return o2;
          return -1;
        }
        function oW(e2, t2) {
          const n2 = rW(e2, t2);
          return n2 === -1 ? null : e2.getParentNode(n2);
        }
        function iW(e2, t2, n2) {
          if (n2.proseWrap === "preserve" && t2 === "\n")
            return T$;
          const r2 = n2.proseWrap === "always" && !oW(e2, Z$);
          return t2 !== "" ? r2 ? x$ : " " : r2 ? B$ : "";
        }
        function uW(e2, t2, n2) {
          const r2 = [];
          let o2 = null;
          const { children: i2 } = e2.getValue();
          for (const [e3, t3] of i2.entries())
            switch (cW(t3)) {
              case "start":
                o2 === null && (o2 = { index: e3, offset: t3.position.end.offset });
                break;
              case "end":
                o2 !== null && (r2.push({ start: o2, end: { index: e3, offset: t3.position.start.offset } }), o2 = null);
            }
          return sW(e2, t2, n2, { processor: (e3, o3) => {
            if (r2.length > 0) {
              const e4 = r2[0];
              if (o3 === e4.start.index)
                return [i2[e4.start.index].value, t2.originalText.slice(e4.start.offset, e4.end.offset), i2[e4.end.index].value];
              if (e4.start.index < o3 && o3 < e4.end.index)
                return false;
              if (o3 === e4.end.index)
                return r2.shift(), false;
            }
            return n2();
          } });
        }
        function sW(e2, t2, n2) {
          let r2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          const { postprocessor: o2 } = r2, i2 = r2.processor || (() => n2()), u2 = e2.getValue(), s2 = [];
          let a2;
          return e2.each((e3, n3) => {
            const r3 = e3.getValue(), o3 = i2(e3, n3);
            if (o3 !== false) {
              const e4 = { parts: s2, prevNode: a2, parentNode: u2, options: t2 };
              lW(r3, e4) && (s2.push(T$), a2 && Q$.has(a2.type) || (pW(r3, e4) || fW(r3, e4)) && s2.push(T$), fW(r3, e4) && s2.push(T$)), s2.push(o3), a2 = r3;
            }
          }, "children"), o2 ? o2(s2) : s2;
        }
        function aW(e2) {
          let t2 = e2;
          for (; v$(t2.children); )
            t2 = D$(t2.children);
          return t2;
        }
        function cW(e2) {
          let t2;
          if (e2.type === "html")
            t2 = e2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
          else {
            let n2;
            e2.type === "esComment" ? n2 = e2 : e2.type === "paragraph" && e2.children.length === 1 && e2.children[0].type === "esComment" && (n2 = e2.children[0]), n2 && (t2 = n2.value.match(/^prettier-ignore(?:-(start|end))?$/));
          }
          return !!t2 && (t2[1] ? t2[1] : "next");
        }
        function lW(e2, t2) {
          const n2 = t2.parts.length === 0, r2 = X$.includes(e2.type), o2 = e2.type === "html" && Y$.includes(t2.parentNode.type);
          return !n2 && !r2 && !o2;
        }
        function pW(e2, t2) {
          const n2 = (t2.prevNode && t2.prevNode.type) === e2.type && eW.has(e2.type), r2 = t2.parentNode.type === "listItem" && !t2.parentNode.loose, o2 = t2.prevNode && t2.prevNode.type === "listItem" && t2.prevNode.loose, i2 = cW(t2.prevNode) === "next", u2 = e2.type === "html" && t2.prevNode && t2.prevNode.type === "html" && t2.prevNode.position.end.line + 1 === e2.position.start.line, s2 = e2.type === "html" && t2.parentNode.type === "listItem" && t2.prevNode && t2.prevNode.type === "paragraph" && t2.prevNode.position.end.line + 1 === e2.position.start.line;
          return o2 || !(n2 || r2 || i2 || u2 || s2);
        }
        function fW(e2, t2) {
          const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e2.type === "code" && e2.isIndented;
          return n2 && r2;
        }
        function dW(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
          return new RegExp(n2.map((e3) => "\\".concat(e3)).join("|")).test(e2) ? "<".concat(e2, ">") : e2;
        }
        function hW(e2, t2) {
          let n2 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
          if (!e2)
            return "";
          if (n2)
            return " " + hW(e2, t2, false);
          if ((e2 = e2.replace(/\\(["')])/g, "$1")).includes('"') && e2.includes("'") && !e2.includes(")"))
            return "(".concat(e2, ")");
          const r2 = e2.split("'").length - 1, o2 = e2.split('"').length - 1, i2 = r2 > o2 ? '"' : o2 > r2 || t2.singleQuote ? "'" : '"';
          return e2 = (e2 = e2.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(i2, ")"), "g"), "\\$1"), "".concat(i2).concat(e2).concat(i2);
        }
        var gW = { preprocess: q$, print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (function(e3) {
            const t3 = oW(e3, ["linkReference", "imageReference"]);
            return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
          }(e2))
            return H$(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : iW(e2, n3.value, t2));
          switch (r2.type) {
            case "front-matter":
              return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
            case "root":
              return r2.children.length === 0 ? "" : [j$(uW(e2, t2, n2)), Q$.has(aW(r2).type) ? "" : T$];
            case "paragraph":
              return sW(e2, t2, n2, { postprocessor: k$ });
            case "sentence":
              return sW(e2, t2, n2);
            case "word": {
              let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(J$, ")(_+)"), "(_+)(".concat(J$, "|$)")].join("|"), "g"), (e3, t4, n4, r3, o3) => (n4 ? "".concat(t4).concat(n4) : "".concat(r3).concat(o3)).replace(/_/g, "\\_"));
              const n3 = (e3, t4, n4) => e3.type === "sentence" && n4 === 0, o2 = (e3, t4, n4) => K$(e3.children[n4 - 1]);
              return t3 !== r2.value && (e2.match(void 0, n3, o2) || e2.match(void 0, n3, (e3, t4, n4) => e3.type === "emphasis" && n4 === 0, o2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e3) => e3.replace(/\\/g, ""))), t3;
            }
            case "whitespace": {
              const n3 = e2.getParentNode(), o2 = n3.children.indexOf(r2), i2 = n3.children[o2 + 1], u2 = i2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(i2.value) ? "never" : t2.proseWrap;
              return iW(e2, r2.value, { proseWrap: u2 });
            }
            case "emphasis": {
              let o2;
              if (K$(r2.children[0]))
                o2 = t2.originalText[r2.position.start.offset];
              else {
                const t3 = e2.getParentNode(), n3 = t3.children.indexOf(r2), i2 = t3.children[n3 - 1], u2 = t3.children[n3 + 1];
                o2 = i2 && i2.type === "sentence" && i2.children.length > 0 && D$(i2.children).type === "word" && !D$(i2.children).hasTrailingPunctuation || u2 && u2.type === "sentence" && u2.children.length > 0 && u2.children[0].type === "word" && !u2.children[0].hasLeadingPunctuation || oW(e2, "emphasis") ? "*" : "_";
              }
              return [o2, sW(e2, t2, n2), o2];
            }
            case "strong":
              return ["**", sW(e2, t2, n2), "**"];
            case "delete":
              return ["~~", sW(e2, t2, n2), "~~"];
            case "inlineCode": {
              const e3 = E$(r2.value, "`"), t3 = "`".repeat(e3 || 1), n3 = e3 && !/^\s/.test(r2.value) ? " " : "";
              return [t3, n3, r2.value, n3, t3];
            }
            case "wikiLink": {
              let e3 = "";
              return e3 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e3, "]]"];
            }
            case "link":
              switch (t2.originalText[r2.position.start.offset]) {
                case "<": {
                  const e3 = "mailto:";
                  return ["<", r2.url.startsWith(e3) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e3.length) !== e3 ? r2.url.slice(e3.length) : r2.url, ">"];
                }
                case "[":
                  return ["[", sW(e2, t2, n2), "](", dW(r2.url, ")"), hW(r2.title, t2), ")"];
                default:
                  return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
              }
            case "image":
              return ["![", r2.alt || "", "](", dW(r2.url, ")"), hW(r2.title, t2), ")"];
            case "blockquote":
              return ["> ", P$("> ", sW(e2, t2, n2))];
            case "heading":
              return ["#".repeat(r2.depth) + " ", sW(e2, t2, n2)];
            case "code": {
              if (r2.isIndented) {
                const e4 = " ".repeat(4);
                return P$(e4, [e4, ..._$(r2.value, T$)]);
              }
              const e3 = t2.__inJsTemplate ? "~" : "`", n3 = e3.repeat(Math.max(3, C$(r2.value, e3) + 1));
              return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", T$, ..._$(z$(r2, t2.originalText), T$), T$, n3];
            }
            case "html": {
              const t3 = e2.getParentNode(), n3 = t3.type === "root" && D$(t3.children) === r2 ? r2.value.trimEnd() : r2.value, o2 = /^<!--.*-->$/s.test(n3);
              return _$(n3, o2 ? T$ : w$(S$));
            }
            case "list": {
              const o2 = nW(r2, e2.getParentNode()), i2 = G$(r2, t2);
              return sW(e2, t2, n2, { processor: (e3, u2) => {
                const s2 = function() {
                  const e4 = r2.ordered ? (u2 === 0 ? r2.start : i2 ? 1 : r2.start + u2) + (o2 % 2 == 0 ? ". " : ") ") : o2 % 2 == 0 ? "- " : "* ";
                  return r2.isAligned || r2.hasIndentedCodeblock ? function(e5, t3) {
                    const n3 = r3();
                    return e5 + " ".repeat(n3 >= 4 ? 0 : n3);
                    function r3() {
                      const n4 = e5.length % t3.tabWidth;
                      return n4 === 0 ? 0 : t3.tabWidth - n4;
                    }
                  }(e4, t2) : e4;
                }(), a2 = e3.getValue();
                return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, tW(e3, t2, n2, s2)] : [s2, P$(" ".repeat(s2.length), tW(e3, t2, n2, s2))];
              } });
            }
            case "thematicBreak": {
              const t3 = rW(e2, "list");
              if (t3 === -1)
                return "---";
              return nW(e2.getParentNode(t3), e2.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
            }
            case "linkReference":
              return ["[", sW(e2, t2, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
            case "imageReference":
              return r2.referenceType === "full" ? ["![", r2.alt || "", "][", r2.identifier, "]"] : ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
            case "definition": {
              const e3 = t2.proseWrap === "always" ? x$ : " ";
              return I$(["[", r2.identifier, "]:", O$([e3, dW(r2.url), r2.title === null ? "" : [e3, hW(r2.title, t2, false)]])]);
            }
            case "footnote":
              return ["[^", sW(e2, t2, n2), "]"];
            case "footnoteReference":
              return ["[^", r2.identifier, "]"];
            case "footnoteDefinition": {
              const o2 = e2.getParentNode().children[e2.getName() + 1], i2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
              return ["[^", r2.identifier, "]: ", i2 ? sW(e2, t2, n2) : I$([P$(" ".repeat(4), sW(e2, t2, n2, { processor: (e3, t3) => t3 === 0 ? I$([B$, n2()]) : n2() })), o2 && o2.type === "footnoteDefinition" ? B$ : ""])];
            }
            case "table":
              return function(e3, t3, n3) {
                const r3 = e3.getValue(), o2 = [], i2 = e3.map((e4) => e4.map((e5, r4) => {
                  const i3 = M$(n3(), t3).formatted, u3 = b$(i3);
                  return o2[r4] = Math.max(o2[r4] || 3, u3), { text: i3, width: u3 };
                }, "children"), "children"), u2 = a2(false);
                if (t3.proseWrap !== "never")
                  return [A$, u2];
                const s2 = a2(true);
                return [A$, I$(N$(s2, u2))];
                function a2(e4) {
                  const t4 = [l2(i2[0], e4), c2(e4)];
                  return i2.length > 1 && t4.push(F$(L$, i2.slice(1).map((t5) => l2(t5, e4)))), F$(L$, t4);
                }
                function c2(e4) {
                  const t4 = o2.map((t5, n4) => {
                    const o3 = r3.align[n4], i3 = o3 === "center" || o3 === "left" ? ":" : "-", u3 = o3 === "center" || o3 === "right" ? ":" : "-", s3 = e4 ? "-" : "-".repeat(t5 - 2);
                    return "".concat(i3).concat(s3).concat(u3);
                  });
                  return "| ".concat(t4.join(" | "), " |");
                }
                function l2(e4, t4) {
                  const n4 = e4.map((e5, n5) => {
                    let { text: i3, width: u3 } = e5;
                    if (t4)
                      return i3;
                    const s3 = o2[n5] - u3, a3 = r3.align[n5];
                    let c3 = 0;
                    a3 === "right" ? c3 = s3 : a3 === "center" && (c3 = Math.floor(s3 / 2));
                    const l3 = s3 - c3;
                    return "".concat(" ".repeat(c3)).concat(i3).concat(" ".repeat(l3));
                  });
                  return "| ".concat(n4.join(" | "), " |");
                }
              }(e2, t2, n2);
            case "tableCell":
              return sW(e2, t2, n2);
            case "break":
              return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", w$(S$)] : ["\\", T$];
            case "liquidNode":
              return _$(r2.value, T$);
            case "importExport":
              return [r2.value, T$];
            case "esComment":
              return ["{/* ", r2.value, " */}"];
            case "jsx":
              return r2.value;
            case "math":
              return ["$$", T$, r2.value ? [..._$(r2.value, T$), T$] : "", "$$"];
            case "inlineMath":
              return t2.originalText.slice($$(r2), W$(r2));
            default:
              throw new Error("Unknown markdown type ".concat(JSON.stringify(r2.type)));
          }
        }, embed: R$, massageAstNode: U$, hasPrettierIgnore: function(e2) {
          const t2 = Number(e2.getName());
          return t2 !== 0 && cW(e2.getParentNode().children[t2 - 1]) === "next";
        }, insertPragma: V$ };
        var mW = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        const yW = bE, DW = gW, EW = { proseWrap: bj.proseWrap, singleQuote: bj.singleQuote }, CW = [yW(mW, (e2) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e2.filenames, "README"], extensions: e2.extensions.filter((e3) => e3 !== ".mdx") })), yW(mW, () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))];
        var bW = { languages: CW, options: EW, printers: { mdast: DW }, parsers: void 0 };
        const { isFrontMatterNode: vW } = dc, AW = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
        function FW(e2, t2) {
          return e2.type === "text" || e2.type === "comment" || vW(e2) || e2.type === "yaml" || e2.type === "toml" ? null : (e2.type === "attribute" && delete t2.value, void (e2.type === "docType" && delete t2.value));
        }
        FW.ignoredProperties = AW;
        var xW = FW;
        const SW = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"], wW = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] }, { inferParserByLanguage: TW, isFrontMatterNode: BW } = dc, { builders: { line: NW, hardline: kW, join: PW }, utils: { getDocParts: OW, replaceTextEndOfLine: IW } } = Zc, { CSS_DISPLAY_TAGS: LW, CSS_DISPLAY_DEFAULT: jW, CSS_WHITE_SPACE_TAGS: _W, CSS_WHITE_SPACE_DEFAULT: MW } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, RW = GW(SW), VW = function(e2, t2) {
          const n2 = /* @__PURE__ */ Object.create(null);
          for (const [r2, o2] of Object.entries(e2))
            n2[r2] = t2(o2, r2);
          return n2;
        }(wW, GW), $W = /* @__PURE__ */ new Set(["	", "\n", "\f", "\r", " "]), WW = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), qW = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(WW(e2)), UW = (e2) => e2.split(/[\t\n\f\r ]+/), zW = (e2) => e2.match(/^[\t\n\f\r ]*/)[0];
        function GW(e2) {
          const t2 = /* @__PURE__ */ Object.create(null);
          for (const n2 of e2)
            t2[n2] = true;
          return t2;
        }
        function HW(e2) {
          return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || oq(e2) && (e2.name === "script" || e2.name === "style"));
        }
        function JW(e2) {
          return iq(e2).startsWith("pre");
        }
        function XW(e2) {
          return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
        }
        function YW(e2) {
          return eq(e2) || e2.type === "element" && e2.fullName === "br" || KW(e2);
        }
        function KW(e2) {
          return QW(e2) && ZW(e2);
        }
        function QW(e2) {
          return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
        }
        function ZW(e2) {
          return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
        }
        function eq(e2) {
          switch (e2.type) {
            case "ieConditionalComment":
            case "comment":
            case "directive":
              return true;
            case "element":
              return ["script", "select"].includes(e2.name);
          }
          return false;
        }
        function tq(e2) {
          const { type: t2, lang: n2 } = e2.attrMap;
          return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
        }
        function nq(e2) {
          return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
        }
        function rq(e2) {
          return iq(e2).startsWith("pre");
        }
        function oq(e2) {
          return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
        }
        function iq(e2) {
          return e2.type === "element" && (!e2.namespace || oq(e2)) && _W[e2.name] || MW;
        }
        function uq(e2) {
          let t2 = Number.POSITIVE_INFINITY;
          for (const n2 of e2.split("\n")) {
            if (n2.length === 0)
              continue;
            if (!$W.has(n2[0]))
              return 0;
            const e3 = zW(n2).length;
            n2.length !== e3 && (e3 < t2 && (t2 = e3));
          }
          return t2 === Number.POSITIVE_INFINITY ? 0 : t2;
        }
        function sq(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : uq(e2);
          return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
        }
        const aq = /* @__PURE__ */ new Set(["template", "style", "script"]);
        function cq(e2, t2) {
          return lq(e2, t2) && !aq.has(e2.fullName);
        }
        function lq(e2, t2) {
          return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
        }
        function pq(e2, t2) {
          return lq(e2, t2) && (cq(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
        }
        var fq = { HTML_ELEMENT_ATTRIBUTES: VW, HTML_TAGS: RW, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(WW(e2)), htmlTrimPreserveIndentation: qW, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
          const [, t2, n2, r2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
          return { leadingWhitespace: t2, trailingWhitespace: r2, text: n2 };
        }, canHaveInterpolation: function(e2) {
          return e2.children && !HW(e2);
        }, countChars: function(e2, t2) {
          let n2 = 0;
          for (let r2 = 0; r2 < e2.length; r2++)
            e2[r2] === t2 && n2++;
          return n2;
        }, countParents: function(e2, t2) {
          let n2 = 0;
          for (let r2 = e2.stack.length - 1; r2 >= 0; r2--) {
            const o2 = e2.stack[r2];
            o2 && typeof o2 == "object" && !Array.isArray(o2) && t2(o2) && n2++;
          }
          return n2;
        }, dedentString: sq, forceBreakChildren: XW, forceBreakContent: function(e2) {
          return XW(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
            return e4.children && e4.children.some((e5) => e5.type !== "text");
          }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && QW(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || ZW(e2.lastChild));
        }, forceNextEmptyLine: function(e2) {
          return BW(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
        }, getLastDescendant: function e2(t2) {
          return t2.lastChild ? e2(t2.lastChild) : t2;
        }, getNodeCssStyleDisplay: function(e2, t2) {
          if (e2.prev && e2.prev.type === "comment") {
            const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t3)
              return t3[1];
          }
          let n2 = false;
          if (e2.type === "element" && e2.namespace === "svg") {
            if (!function(e3, t3) {
              let n3 = e3;
              for (; n3; ) {
                if (t3(n3))
                  return true;
                n3 = n3.parent;
              }
              return false;
            }(e2, (e3) => e3.fullName === "svg:foreignObject"))
              return e2.name === "svg" ? "inline-block" : "block";
            n2 = true;
          }
          switch (t2.htmlWhitespaceSensitivity) {
            case "strict":
              return "inline";
            case "ignore":
              return "block";
            default:
              return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || n2 || oq(e2)) && LW[e2.name] || jW;
          }
        }, getNodeCssStyleWhiteSpace: iq, hasPrettierIgnore: function(e2) {
          return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
            return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
          }(e2.parent.children[e2.index - 1])));
        }, inferScriptParser: function(e2, t2) {
          return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
            const { lang: t3 } = e3.attrMap;
            return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
          }(e2) : t2 && pq(e2, t2) ? tq(e2) || !("src" in e2.attrMap) && TW(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? tq(e2) : "babel";
        }, isVueCustomBlock: cq, isVueNonHtmlBlock: pq, isVueSlotAttribute: function(e2) {
          const t2 = e2.fullName;
          return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
        }, isVueSfcBindingsAttribute: function(e2, t2) {
          const n2 = e2.parent;
          if (!lq(n2, t2))
            return false;
          const r2 = n2.fullName, o2 = e2.fullName;
          return r2 === "script" && o2 === "setup" || r2 === "style" && o2 === "vars";
        }, isDanglingSpaceSensitiveNode: function(e2) {
          return !(t2 = e2.cssDisplay, nq(t2) || t2 === "inline-block" || HW(e2));
          var t2;
        }, isIndentationSensitiveNode: JW, isLeadingSpaceSensitiveNode: function(e2, t2) {
          const n2 = function() {
            if (BW(e2))
              return false;
            if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
              return true;
            if (!e2.parent || e2.parent.cssDisplay === "none")
              return false;
            if (rq(e2.parent))
              return true;
            if (!e2.prev && (e2.parent.type === "root" || rq(e2) && e2.parent || HW(e2.parent) || cq(e2.parent, t2) || (n3 = e2.parent.cssDisplay, nq(n3) || n3 === "inline-block")))
              return false;
            var n3;
            if (e2.prev && !function(e3) {
              return !nq(e3);
            }(e2.prev.cssDisplay))
              return false;
            return true;
          }();
          return n2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : n2;
        }, isPreLikeNode: rq, isScriptLikeTag: HW, isTextLikeNode: function(e2) {
          return e2.type === "text" || e2.type === "comment";
        }, isTrailingSpaceSensitiveNode: function(e2, t2) {
          return !BW(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!rq(e2.parent) || !(!e2.next && (e2.parent.type === "root" || rq(e2) && e2.parent || HW(e2.parent) || cq(e2.parent, t2) || (n2 = e2.parent.cssDisplay, nq(n2) || n2 === "inline-block"))) && !(e2.next && !function(e3) {
            return !nq(e3);
          }(e2.next.cssDisplay))));
          var n2;
        }, isWhitespaceSensitiveNode: function(e2) {
          return HW(e2) || e2.type === "interpolation" || JW(e2);
        }, isUnknownNamespace: oq, preferHardlineAsLeadingSpaces: function(e2) {
          return eq(e2) || e2.prev && YW(e2.prev) || KW(e2);
        }, preferHardlineAsTrailingSpaces: YW, shouldPreserveContent: function(e2, t2) {
          return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!rq(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!pq(e2, t2) || HW(e2) || e2.type === "interpolation")));
        }, unescapeQuoteEntities: function(e2) {
          return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
        }, getTextValueParts: function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e2.value;
          return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? IW(t2) : IW(sq(qW(t2)), kW) : OW(PW(NW, UW(t2)));
        } }, dq = {}, hq = {};
        !function(e2) {
          function t2(t3) {
            return e2.$0 <= t3 && t3 <= e2.$9;
          }
          Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96, e2.isWhitespace = function(t3) {
            return t3 >= e2.$TAB && t3 <= e2.$SPACE || t3 == e2.$NBSP;
          }, e2.isDigit = t2, e2.isAsciiLetter = function(t3) {
            return t3 >= e2.$a && t3 <= e2.$z || t3 >= e2.$A && t3 <= e2.$Z;
          }, e2.isAsciiHexDigit = function(n2) {
            return n2 >= e2.$a && n2 <= e2.$f || n2 >= e2.$A && n2 <= e2.$F || t2(n2);
          }, e2.isNewLine = function(t3) {
            return t3 === e2.$LF || t3 === e2.$CR;
          }, e2.isOctalDigit = function(t3) {
            return e2.$0 <= t3 && t3 <= e2.$7;
          };
        }(hq);
        var gq = {}, mq = {};
        Object.defineProperty(mq, "__esModule", { value: true });
        class yq {
          constructor(e2, t2, n2) {
            this.filePath = e2, this.name = t2, this.members = n2;
          }
          assertNoMembers() {
            if (this.members.length)
              throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
          }
        }
        mq.StaticSymbol = yq;
        mq.StaticSymbolCache = class {
          constructor() {
            this.cache = /* @__PURE__ */ new Map();
          }
          get(e2, t2, n2) {
            const r2 = (n2 = n2 || []).length ? ".".concat(n2.join(".")) : "", o2 = '"'.concat(e2, '".').concat(t2).concat(r2);
            let i2 = this.cache.get(o2);
            return i2 || (i2 = new yq(e2, t2, n2), this.cache.set(o2, i2)), i2;
          }
        };
        var Dq = {};
        Object.defineProperty(Dq, "__esModule", { value: true });
        const Eq = /-+([a-z0-9])/g;
        function Cq(e2, t2, n2) {
          const r2 = e2.indexOf(t2);
          return r2 == -1 ? n2 : [e2.slice(0, r2).trim(), e2.slice(r2 + 1).trim()];
        }
        function bq(e2, t2, n2) {
          return Array.isArray(e2) ? t2.visitArray(e2, n2) : function(e3) {
            return typeof e3 == "object" && e3 !== null && Object.getPrototypeOf(e3) === Fq;
          }(e2) ? t2.visitStringMap(e2, n2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t2.visitPrimitive(e2, n2) : t2.visitOther(e2, n2);
        }
        Dq.dashCaseToCamelCase = function(e2) {
          return e2.replace(Eq, function() {
            for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++)
              t2[n2] = arguments[n2];
            return t2[1].toUpperCase();
          });
        }, Dq.splitAtColon = function(e2, t2) {
          return Cq(e2, ":", t2);
        }, Dq.splitAtPeriod = function(e2, t2) {
          return Cq(e2, ".", t2);
        }, Dq.visitValue = bq, Dq.isDefined = function(e2) {
          return e2 != null;
        }, Dq.noUndefined = function(e2) {
          return e2 === void 0 ? null : e2;
        };
        Dq.ValueTransformer = class {
          visitArray(e2, t2) {
            return e2.map((e3) => bq(e3, this, t2));
          }
          visitStringMap(e2, t2) {
            const n2 = {};
            return Object.keys(e2).forEach((r2) => {
              n2[r2] = bq(e2[r2], this, t2);
            }), n2;
          }
          visitPrimitive(e2, t2) {
            return e2;
          }
          visitOther(e2, t2) {
            return e2;
          }
        }, Dq.SyncAsync = { assertSync: (e2) => {
          if (xq(e2))
            throw new Error("Illegal state: value cannot be a promise");
          return e2;
        }, then: (e2, t2) => xq(e2) ? e2.then(t2) : t2(e2), all: (e2) => e2.some(xq) ? Promise.all(e2) : e2 }, Dq.error = function(e2) {
          throw new Error("Internal Error: ".concat(e2));
        }, Dq.syntaxError = function(e2, t2) {
          const n2 = Error(e2);
          return n2[vq] = true, t2 && (n2[Aq] = t2), n2;
        };
        const vq = "ngSyntaxError", Aq = "ngParseErrors";
        Dq.isSyntaxError = function(e2) {
          return e2[vq];
        }, Dq.getParseErrors = function(e2) {
          return e2[Aq] || [];
        }, Dq.escapeRegExp = function(e2) {
          return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        };
        const Fq = Object.getPrototypeOf({});
        function xq(e2) {
          return !!e2 && typeof e2.then == "function";
        }
        Dq.utf8Encode = function(e2) {
          let t2 = "";
          for (let n2 = 0; n2 < e2.length; n2++) {
            let r2 = e2.charCodeAt(n2);
            if (r2 >= 55296 && r2 <= 56319 && e2.length > n2 + 1) {
              const t3 = e2.charCodeAt(n2 + 1);
              t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
            }
            r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
          }
          return t2;
        }, Dq.stringify = function e2(t2) {
          if (typeof t2 == "string")
            return t2;
          if (t2 instanceof Array)
            return "[" + t2.map(e2).join(", ") + "]";
          if (t2 == null)
            return "" + t2;
          if (t2.overriddenName)
            return "".concat(t2.overriddenName);
          if (t2.name)
            return "".concat(t2.name);
          if (!t2.toString)
            return "object";
          const n2 = t2.toString();
          if (n2 == null)
            return "" + n2;
          const r2 = n2.indexOf("\n");
          return r2 === -1 ? n2 : n2.substring(0, r2);
        }, Dq.resolveForwardRef = function(e2) {
          return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
        }, Dq.isPromise = xq;
        Dq.Version = class {
          constructor(e2) {
            this.full = e2;
            const t2 = e2.split(".");
            this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
          }
        };
        const Sq = typeof window != "undefined" && window, wq = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self, Tq = e !== void 0 && e || Sq || wq;
        Dq.global = Tq, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = mq, n2 = Dq, r2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function o2(e3) {
            return e3.replace(/\W/g, "_");
          }
          e2.sanitizeIdentifier = o2;
          let i2 = 0;
          function u2(e3) {
            if (!e3 || !e3.reference)
              return null;
            const r3 = e3.reference;
            if (r3 instanceof t2.StaticSymbol)
              return r3.name;
            if (r3.__anonymousType)
              return r3.__anonymousType;
            let u3 = n2.stringify(r3);
            return u3.indexOf("(") >= 0 ? (u3 = "anonymous_".concat(i2++), r3.__anonymousType = u3) : u3 = o2(u3), u3;
          }
          var s2;
          e2.identifierName = u2, e2.identifierModuleUrl = function(e3) {
            const r3 = e3.reference;
            return r3 instanceof t2.StaticSymbol ? r3.filePath : "./".concat(n2.stringify(r3));
          }, e2.viewClassName = function(e3, t3) {
            return "View_".concat(u2({ reference: e3 }), "_").concat(t3);
          }, e2.rendererTypeName = function(e3) {
            return "RenderType_".concat(u2({ reference: e3 }));
          }, e2.hostViewClassName = function(e3) {
            return "HostView_".concat(u2({ reference: e3 }));
          }, e2.componentFactoryName = function(e3) {
            return "".concat(u2({ reference: e3 }), "NgFactory");
          }, function(e3) {
            e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
          }(s2 = e2.CompileSummaryKind || (e2.CompileSummaryKind = {})), e2.tokenName = function(e3) {
            return e3.value != null ? o2(e3.value) : u2(e3.identifier);
          }, e2.tokenReference = function(e3) {
            return e3.identifier != null ? e3.identifier.reference : e3.value;
          };
          e2.CompileStylesheetMetadata = class {
            constructor() {
              let { moduleUrl: e3, styles: t3, styleUrls: n3 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = e3 || null, this.styles = c2(t3), this.styleUrls = c2(n3);
            }
          };
          e2.CompileTemplateMetadata = class {
            constructor(e3) {
              let { encapsulation: t3, template: n3, templateUrl: r3, htmlAst: o3, styles: i3, styleUrls: u3, externalStylesheets: s3, animations: a3, ngContentSelectors: p3, interpolation: f2, isInline: d2, preserveWhitespaces: h2 } = e3;
              if (this.encapsulation = t3, this.template = n3, this.templateUrl = r3, this.htmlAst = o3, this.styles = c2(i3), this.styleUrls = c2(u3), this.externalStylesheets = c2(s3), this.animations = a3 ? l2(a3) : [], this.ngContentSelectors = p3 || [], f2 && f2.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = f2, this.isInline = d2, this.preserveWhitespaces = h2;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          class a2 {
            static create(e3) {
              let { isHost: t3, type: o3, isComponent: i3, selector: u3, exportAs: s3, changeDetection: c3, inputs: l3, outputs: p3, host: f2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C2, rendererType: b2, componentFactory: v2 } = e3;
              const A2 = {}, F2 = {}, x2 = {};
              f2 != null && Object.keys(f2).forEach((e4) => {
                const t4 = f2[e4], n3 = e4.match(r2);
                n3 === null ? x2[e4] = t4 : n3[1] != null ? F2[n3[1]] = t4 : n3[2] != null && (A2[n3[2]] = t4);
              });
              const S2 = {};
              l3 != null && l3.forEach((e4) => {
                const t4 = n2.splitAtColon(e4, [e4, e4]);
                S2[t4[0]] = t4[1];
              });
              const w2 = {};
              return p3 != null && p3.forEach((e4) => {
                const t4 = n2.splitAtColon(e4, [e4, e4]);
                w2[t4[0]] = t4[1];
              }), new a2({ isHost: t3, type: o3, isComponent: !!i3, selector: u3, exportAs: s3, changeDetection: c3, inputs: S2, outputs: w2, hostListeners: A2, hostProperties: F2, hostAttributes: x2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C2, rendererType: b2, componentFactory: v2 });
            }
            constructor(e3) {
              let { isHost: t3, type: n3, isComponent: r3, selector: o3, exportAs: i3, changeDetection: u3, inputs: s3, outputs: a3, hostListeners: l3, hostProperties: p3, hostAttributes: f2, providers: d2, viewProviders: h2, queries: g2, guards: m2, viewQueries: y2, entryComponents: D2, template: E2, componentViewType: C2, rendererType: b2, componentFactory: v2 } = e3;
              this.isHost = !!t3, this.type = n3, this.isComponent = r3, this.selector = o3, this.exportAs = i3, this.changeDetection = u3, this.inputs = s3, this.outputs = a3, this.hostListeners = l3, this.hostProperties = p3, this.hostAttributes = f2, this.providers = c2(d2), this.viewProviders = c2(h2), this.queries = c2(g2), this.guards = m2, this.viewQueries = c2(y2), this.entryComponents = c2(D2), this.template = E2, this.componentViewType = C2, this.rendererType = b2, this.componentFactory = v2;
            }
            toSummary() {
              return { summaryKind: s2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          }
          e2.CompileDirectiveMetadata = a2;
          e2.CompilePipeMetadata = class {
            constructor(e3) {
              let { type: t3, name: n3, pure: r3 } = e3;
              this.type = t3, this.name = n3, this.pure = !!r3;
            }
            toSummary() {
              return { summaryKind: s2.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e2.CompileShallowModuleMetadata = class {
          };
          e2.CompileNgModuleMetadata = class {
            constructor(e3) {
              let { type: t3, providers: n3, declaredDirectives: r3, exportedDirectives: o3, declaredPipes: i3, exportedPipes: u3, entryComponents: s3, bootstrapComponents: a3, importedModules: l3, exportedModules: p3, schemas: f2, transitiveModule: d2, id: h2 } = e3;
              this.type = t3 || null, this.declaredDirectives = c2(r3), this.exportedDirectives = c2(o3), this.declaredPipes = c2(i3), this.exportedPipes = c2(u3), this.providers = c2(n3), this.entryComponents = c2(s3), this.bootstrapComponents = c2(a3), this.importedModules = c2(l3), this.exportedModules = c2(p3), this.schemas = c2(f2), this.id = h2 || null, this.transitiveModule = d2 || null;
            }
            toSummary() {
              const e3 = this.transitiveModule;
              return { summaryKind: s2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
            }
          };
          function c2(e3) {
            return e3 || [];
          }
          e2.TransitiveCompileNgModuleMetadata = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(e3, t3) {
              this.providers.push({ provider: e3, module: t3 });
            }
            addDirective(e3) {
              this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
            }
            addExportedDirective(e3) {
              this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
            }
            addPipe(e3) {
              this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
            }
            addExportedPipe(e3) {
              this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
            }
            addModule(e3) {
              this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
            }
            addEntryComponent(e3) {
              this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
            }
          };
          function l2(e3) {
            return e3.reduce((e4, t3) => {
              const n3 = Array.isArray(t3) ? l2(t3) : t3;
              return e4.concat(n3);
            }, []);
          }
          function p2(e3) {
            return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          e2.ProviderMeta = class {
            constructor(e3, t3) {
              let { useClass: n3, useValue: r3, useExisting: o3, useFactory: i3, deps: u3, multi: s3 } = t3;
              this.token = e3, this.useClass = n3 || null, this.useValue = r3, this.useExisting = o3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!s3;
            }
          }, e2.flatten = l2, e2.templateSourceUrl = function(e3, n3, r3) {
            let o3;
            return o3 = r3.isInline ? n3.type.reference instanceof t2.StaticSymbol ? "".concat(n3.type.reference.filePath, ".").concat(n3.type.reference.name, ".html") : "".concat(u2(e3), "/").concat(u2(n3.type), ".html") : r3.templateUrl, n3.type.reference instanceof t2.StaticSymbol ? o3 : p2(o3);
          }, e2.sharedStylesheetJitUrl = function(e3, t3) {
            const n3 = e3.moduleUrl.split(/\/\\/g), r3 = n3[n3.length - 1];
            return p2("css/".concat(t3).concat(r3, ".ngstyle.js"));
          }, e2.ngModuleJitUrl = function(e3) {
            return p2("".concat(u2(e3.type), "/module.ngfactory.js"));
          }, e2.templateJitUrl = function(e3, t3) {
            return p2("".concat(u2(e3), "/").concat(u2(t3.type), ".ngfactory.js"));
          };
        }(gq), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = hq, n2 = gq;
          class r2 {
            constructor(e3, t3, n3, r3) {
              this.file = e3, this.offset = t3, this.line = n3, this.col = r3;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(e3) {
              const n3 = this.file.content, o3 = n3.length;
              let i3 = this.offset, u3 = this.line, s2 = this.col;
              for (; i3 > 0 && e3 < 0; ) {
                i3--, e3++;
                if (n3.charCodeAt(i3) == t2.$LF) {
                  u3--;
                  const e4 = n3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(t2.$LF));
                  s2 = e4 > 0 ? i3 - e4 : i3;
                } else
                  s2--;
              }
              for (; i3 < o3 && e3 > 0; ) {
                const r3 = n3.charCodeAt(i3);
                i3++, e3--, r3 == t2.$LF ? (u3++, s2 = 0) : s2++;
              }
              return new r2(this.file, i3, u3, s2);
            }
            getContext(e3, t3) {
              const n3 = this.file.content;
              let r3 = this.offset;
              if (r3 != null) {
                r3 > n3.length - 1 && (r3 = n3.length - 1);
                let o3 = r3, i3 = 0, u3 = 0;
                for (; i3 < e3 && r3 > 0 && (r3--, i3++, n3[r3] != "\n" || ++u3 != t3); )
                  ;
                for (i3 = 0, u3 = 0; i3 < e3 && o3 < n3.length - 1 && (o3++, i3++, n3[o3] != "\n" || ++u3 != t3); )
                  ;
                return { before: n3.substring(r3, this.offset), after: n3.substring(this.offset, o3 + 1) };
              }
              return null;
            }
          }
          e2.ParseLocation = r2;
          class o2 {
            constructor(e3, t3) {
              this.content = e3, this.url = t3;
            }
          }
          e2.ParseSourceFile = o2;
          class i2 {
            constructor(e3, t3) {
              let n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = e3, this.end = t3, this.details = n3;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          }
          var u2;
          e2.ParseSourceSpan = i2, e2.EMPTY_PARSE_LOCATION = new r2(new o2("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new i2(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION), function(e3) {
            e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
          }(u2 = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
          e2.ParseError = class {
            constructor(e3, t3) {
              let n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u2.ERROR;
              this.span = e3, this.msg = t3, this.level = n3;
            }
            contextualMessage() {
              const e3 = this.span.start.getContext(100, 3);
              return e3 ? "".concat(this.msg, ' ("').concat(e3.before, "[").concat(u2[this.level], " ->]").concat(e3.after, '")') : this.msg;
            }
            toString() {
              const e3 = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e3);
            }
          }, e2.typeSourceSpan = function(e3, t3) {
            const u3 = n2.identifierModuleUrl(t3), s2 = u3 != null ? "in ".concat(e3, " ").concat(n2.identifierName(t3), " in ").concat(u3) : "in ".concat(e3, " ").concat(n2.identifierName(t3)), a2 = new o2("", s2);
            return new i2(new r2(a2, -1, -1, -1), new r2(a2, -1, -1, -1));
          }, e2.r3JitTypeSourceSpan = function(e3, t3, n3) {
            const u3 = "in ".concat(e3, " ").concat(t3, " in ").concat(n3), s2 = new o2("", u3);
            return new i2(new r2(s2, -1, -1, -1), new r2(s2, -1, -1, -1));
          };
        }(dq);
        const { ParseSourceSpan: Bq } = dq, Nq = au, { htmlTrim: kq, getLeadingAndTrailingHtmlWhitespace: Pq, hasHtmlWhitespace: Oq, canHaveInterpolation: Iq, getNodeCssStyleDisplay: Lq, isDanglingSpaceSensitiveNode: jq, isIndentationSensitiveNode: _q, isLeadingSpaceSensitiveNode: Mq, isTrailingSpaceSensitiveNode: Rq, isWhitespaceSensitiveNode: Vq } = fq, $q = [function(e2) {
          e2.walk((e3) => {
            if (e3.type === "element" && e3.tagDefinition.ignoreFirstLf && e3.children.length > 0 && e3.children[0].type === "text" && e3.children[0].value[0] === "\n") {
              const [t2, ...n2] = e3.children;
              e3.setChildren(t2.value.length === 1 ? n2 : [t2.clone({ value: t2.value.slice(1) }), ...n2]);
            }
          });
        }, function(e2) {
          const t2 = (e3) => e3.type === "element" && e3.prev && e3.prev.type === "ieConditionalStartComment" && e3.prev.sourceSpan.end.offset === e3.startSourceSpan.start.offset && e3.firstChild && e3.firstChild.type === "ieConditionalEndComment" && e3.firstChild.sourceSpan.start.offset === e3.startSourceSpan.end.offset;
          e2.walk((e3) => {
            if (e3.children) {
              const n2 = e3.children.map(t2);
              if (n2.some(Boolean)) {
                const t3 = [];
                for (let r2 = 0; r2 < e3.children.length; r2++) {
                  const o2 = e3.children[r2];
                  if (!n2[r2 + 1])
                    if (n2[r2]) {
                      const e4 = o2.prev, n3 = o2.firstChild, r3 = new Bq(e4.sourceSpan.start, n3.sourceSpan.end), i2 = new Bq(r3.start, o2.sourceSpan.end);
                      t3.push(o2.clone({ condition: e4.condition, sourceSpan: i2, startSourceSpan: r3, children: o2.children.slice(1) }));
                    } else
                      t3.push(o2);
                }
                e3.setChildren(t3);
              }
            }
          });
        }, function(e2) {
          return function(e3, t2, n2) {
            e3.walk((e4) => {
              if (e4.children) {
                const r2 = e4.children.map(t2);
                if (r2.some(Boolean)) {
                  const t3 = [];
                  for (let o2 = 0; o2 < e4.children.length; o2++) {
                    const i2 = e4.children[o2];
                    if (i2.type !== "text" && !r2[o2]) {
                      t3.push(i2);
                      continue;
                    }
                    const u2 = i2.type === "text" ? i2 : i2.clone({ type: "text", value: n2(i2) });
                    if (t3.length === 0 || Nq(t3).type !== "text") {
                      t3.push(u2);
                      continue;
                    }
                    const s2 = t3.pop();
                    t3.push(s2.clone({ value: s2.value + u2.value, sourceSpan: new Bq(s2.sourceSpan.start, u2.sourceSpan.end) }));
                  }
                  e4.setChildren(t3);
                }
              }
            });
          }(e2, (e3) => e3.type === "cdata", (e3) => "<![CDATA[".concat(e3.value, "]]>"));
        }, function(e2, t2) {
          if (t2.parser === "html")
            return;
          const n2 = /{{(.+?)}}/s;
          e2.walk((e3) => {
            if (!Iq(e3))
              return;
            const t3 = [];
            for (const r2 of e3.children) {
              if (r2.type !== "text") {
                t3.push(r2);
                continue;
              }
              let e4 = r2.sourceSpan.start, o2 = null;
              const i2 = r2.value.split(n2);
              for (let n3 = 0; n3 < i2.length; n3++, e4 = o2) {
                const r3 = i2[n3];
                n3 % 2 != 0 ? (o2 = e4.moveBy(r3.length + 4), t3.push({ type: "interpolation", sourceSpan: new Bq(e4, o2), children: r3.length === 0 ? [] : [{ type: "text", value: r3, sourceSpan: new Bq(e4.moveBy(2), o2.moveBy(-2)) }] })) : (o2 = e4.moveBy(r3.length), r3.length > 0 && t3.push({ type: "text", value: r3, sourceSpan: new Bq(e4, o2) }));
              }
            }
            e3.setChildren(t3);
          });
        }, function(e2) {
          e2.walk((e3) => {
            if (!e3.children)
              return;
            if (e3.children.length === 0 || e3.children.length === 1 && e3.children[0].type === "text" && kq(e3.children[0].value).length === 0)
              return e3.hasDanglingSpaces = e3.children.length > 0, void (e3.children = []);
            const t2 = Vq(e3), n2 = _q(e3);
            e3.setChildren(e3.children.flatMap((e4) => {
              if (e4.type !== "text" || t2)
                return e4;
              const n3 = [], { leadingWhitespace: r2, text: o2, trailingWhitespace: i2 } = Pq(e4.value);
              return r2 && n3.push(Wq), o2 && n3.push({ type: "text", value: o2, sourceSpan: new Bq(e4.sourceSpan.start.moveBy(r2.length), e4.sourceSpan.end.moveBy(-i2.length)) }), i2 && n3.push(Wq), n3;
            }).map((e4, t3, n3) => {
              if (e4 !== Wq)
                return Object.assign(Object.assign({}, e4), {}, { hasLeadingSpaces: n3[t3 - 1] === Wq, hasTrailingSpaces: n3[t3 + 1] === Wq });
            }).filter(Boolean)), e3.isWhitespaceSensitive = t2, e3.isIndentationSensitive = n2;
          });
        }, function(e2, t2) {
          e2.walk((e3) => Object.assign(e3, { cssDisplay: Lq(e3, t2) }));
        }, function(e2) {
          e2.walk((e3) => Object.assign(e3, { isSelfClosing: !e3.children || e3.type === "element" && (e3.tagDefinition.isVoid || e3.startSourceSpan === e3.endSourceSpan) }));
        }, function(e2, t2) {
          e2.walk((e3) => e3.type !== "element" ? e3 : Object.assign(e3, { hasHtmComponentClosingTag: e3.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e3.endSourceSpan.start.offset, e3.endSourceSpan.end.offset)) }));
        }, function(e2, t2) {
          e2.walk((e3) => {
            e3.children && (e3.children.length !== 0 ? e3.setChildren(e3.children.map((e4) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: Mq(e4, t2), isTrailingSpaceSensitive: Rq(e4, t2) })).map((e4, t3, n2) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e4.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e4.isTrailingSpaceSensitive }))) : e3.isDanglingSpaceSensitive = jq(e3));
          });
        }, function(e2) {
          const t2 = (e3) => e3.type === "element" && e3.attrs.length === 0 && e3.children.length === 1 && e3.firstChild.type === "text" && !Oq(e3.children[0].value) && !e3.firstChild.hasLeadingSpaces && !e3.firstChild.hasTrailingSpaces && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces && e3.prev && e3.prev.type === "text" && e3.next && e3.next.type === "text";
          e2.walk((e3) => {
            if (e3.children) {
              const n2 = e3.children.map(t2);
              if (n2.some(Boolean)) {
                const t3 = [];
                for (let r2 = 0; r2 < e3.children.length; r2++) {
                  const o2 = e3.children[r2];
                  if (n2[r2]) {
                    const n3 = t3.pop(), i2 = e3.children[++r2], { isTrailingSpaceSensitive: u2, hasTrailingSpaces: s2 } = i2;
                    t3.push(n3.clone({ value: n3.value + "<".concat(o2.rawName, ">") + o2.firstChild.value + "</".concat(o2.rawName, ">") + i2.value, sourceSpan: new Bq(n3.sourceSpan.start, i2.sourceSpan.end), isTrailingSpaceSensitive: u2, hasTrailingSpaces: s2 }));
                  } else
                    t3.push(o2);
                }
                e3.setChildren(t3);
              }
            }
          });
        }];
        const Wq = { type: "whitespace" };
        var qq = function(e2, t2) {
          const n2 = e2.map((e3) => e3);
          for (const e3 of $q)
            e3(n2, t2);
          return n2;
        };
        var Uq = { hasPragma: function(e2) {
          return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
        }, insertPragma: function(e2) {
          return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
        } };
        var zq = { locStart: function(e2) {
          return e2.sourceSpan.start.offset;
        }, locEnd: function(e2) {
          return e2.sourceSpan.end.offset;
        } };
        const Gq = Ty, { isNonEmptyArray: Hq } = dc, { builders: { indent: Jq, join: Xq, line: Yq, softline: Kq }, utils: { replaceTextEndOfLine: Qq } } = Zc, { locStart: Zq, locEnd: eU } = zq, { isTextLikeNode: tU, getLastDescendant: nU, isPreLikeNode: rU, hasPrettierIgnore: oU, shouldPreserveContent: iU } = fq;
        function uU(e2, t2) {
          return e2.lastChild && gU(e2.lastChild) ? "" : [aU(e2, t2), lU(e2, t2)];
        }
        function sU(e2, t2) {
          return (e2.next ? dU(e2.next) : hU(e2.parent)) ? "" : [pU(e2, t2), cU(e2, t2)];
        }
        function aU(e2, t2) {
          return hU(e2) ? pU(e2.lastChild, t2) : "";
        }
        function cU(e2, t2) {
          return gU(e2) ? lU(e2.parent, t2) : mU(e2) ? vU(e2.next) : "";
        }
        function lU(e2, t2) {
          if (Gq(!e2.isSelfClosing), fU(e2, t2))
            return "";
          switch (e2.type) {
            case "ieConditionalComment":
              return "<!";
            case "element":
              if (e2.hasHtmComponentClosingTag)
                return "<//";
            default:
              return "</".concat(e2.rawName);
          }
        }
        function pU(e2, t2) {
          if (fU(e2, t2))
            return "";
          switch (e2.type) {
            case "ieConditionalComment":
            case "ieConditionalEndComment":
              return "[endif]-->";
            case "ieConditionalStartComment":
              return "]><!-->";
            case "interpolation":
              return "}}";
            case "element":
              if (e2.isSelfClosing)
                return "/>";
            default:
              return ">";
          }
        }
        function fU(e2, t2) {
          return !e2.isSelfClosing && !e2.endSourceSpan && (oU(e2) || iU(e2.parent, t2));
        }
        function dU(e2) {
          return e2.prev && e2.prev.type !== "docType" && !tU(e2.prev) && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
        }
        function hU(e2) {
          return e2.lastChild && e2.lastChild.isTrailingSpaceSensitive && !e2.lastChild.hasTrailingSpaces && !tU(nU(e2.lastChild)) && !rU(e2);
        }
        function gU(e2) {
          return !e2.next && !e2.hasTrailingSpaces && e2.isTrailingSpaceSensitive && tU(nU(e2));
        }
        function mU(e2) {
          return e2.next && !tU(e2.next) && tU(e2) && e2.isTrailingSpaceSensitive && !e2.hasTrailingSpaces;
        }
        function yU(e2) {
          return !e2.prev && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
        }
        function DU(e2, t2, n2) {
          const r2 = e2.getValue();
          if (!Hq(r2.attrs))
            return r2.isSelfClosing ? " " : "";
          const o2 = r2.prev && r2.prev.type === "comment" && function(e3) {
            const t3 = e3.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return !!t3 && (!t3[1] || t3[1].split(/\s+/));
          }(r2.prev.value), i2 = typeof o2 == "boolean" ? () => o2 : Array.isArray(o2) ? (e3) => o2.includes(e3.rawName) : () => false, u2 = e2.map((e3) => {
            const r3 = e3.getValue();
            return i2(r3) ? Qq(t2.originalText.slice(Zq(r3), eU(r3))) : n2();
          }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [Jq([s2 ? " " : Yq, Xq(Yq, u2)])];
          return r2.firstChild && yU(r2.firstChild) || r2.isSelfClosing && hU(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? Yq : Kq), a2;
        }
        function EU(e2) {
          return e2.firstChild && yU(e2.firstChild) ? "" : AU(e2);
        }
        function CU(e2, t2) {
          return e2.prev && mU(e2.prev) ? "" : [bU(e2, t2), vU(e2)];
        }
        function bU(e2, t2) {
          return yU(e2) ? AU(e2.parent) : dU(e2) ? pU(e2.prev, t2) : "";
        }
        function vU(e2) {
          switch (e2.type) {
            case "ieConditionalComment":
            case "ieConditionalStartComment":
              return "<!--[if ".concat(e2.condition);
            case "ieConditionalEndComment":
              return "<!--<!";
            case "interpolation":
              return "{{";
            case "docType":
              return "<!DOCTYPE";
            case "element":
              if (e2.condition)
                return "<!--[if ".concat(e2.condition, "]><!--><").concat(e2.rawName);
            default:
              return "<".concat(e2.rawName);
          }
        }
        function AU(e2) {
          switch (Gq(!e2.isSelfClosing), e2.type) {
            case "ieConditionalComment":
              return "]>";
            case "element":
              if (e2.condition)
                return "><!--<![endif]-->";
            default:
              return ">";
          }
        }
        var FU = { printClosingTag: function(e2, t2) {
          return [e2.isSelfClosing ? "" : uU(e2, t2), sU(e2, t2)];
        }, printClosingTagStart: uU, printClosingTagStartMarker: lU, printClosingTagEndMarker: pU, printClosingTagSuffix: cU, printClosingTagEnd: sU, needsToBorrowLastChildClosingTagEndMarker: hU, needsToBorrowParentClosingTagStartMarker: gU, needsToBorrowPrevClosingTagEndMarker: dU, printOpeningTag: function(e2, t2, n2) {
          const r2 = e2.getValue();
          return [CU(r2, t2), DU(e2, t2, n2), r2.isSelfClosing ? "" : EU(r2)];
        }, printOpeningTagStart: CU, printOpeningTagPrefix: bU, printOpeningTagStartMarker: vU, printOpeningTagEndMarker: AU, needsToBorrowNextOpeningTagStartMarker: mU, needsToBorrowParentOpeningTagEndMarker: yU }, xU = { exports: {} };
        !function(t2) {
          var n2, r2;
          n2 = e, r2 = function() {
            return function(e2, t3) {
              var n3 = t3 && t3.logger || console;
              function r3(e3) {
                return e3 === " " || e3 === "	" || e3 === "\n" || e3 === "\f" || e3 === "\r";
              }
              function o2(t4) {
                var n4, r4 = t4.exec(e2.substring(y2));
                if (r4)
                  return n4 = r4[0], y2 += n4.length, n4;
              }
              for (var i2, u2, s2, a2, c2, l2 = e2.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
                if (o2(f2), y2 >= l2)
                  return D2;
                i2 = o2(d2), u2 = [], i2.slice(-1) === "," ? (i2 = i2.replace(h2, ""), C2()) : E2();
              }
              function E2() {
                for (o2(p2), s2 = "", a2 = "in descriptor"; ; ) {
                  if (c2 = e2.charAt(y2), a2 === "in descriptor")
                    if (r3(c2))
                      s2 && (u2.push(s2), s2 = "", a2 = "after descriptor");
                    else {
                      if (c2 === ",")
                        return y2 += 1, s2 && u2.push(s2), void C2();
                      if (c2 === "(")
                        s2 += c2, a2 = "in parens";
                      else {
                        if (c2 === "")
                          return s2 && u2.push(s2), void C2();
                        s2 += c2;
                      }
                    }
                  else if (a2 === "in parens")
                    if (c2 === ")")
                      s2 += c2, a2 = "in descriptor";
                    else {
                      if (c2 === "")
                        return u2.push(s2), void C2();
                      s2 += c2;
                    }
                  else if (a2 === "after descriptor")
                    if (r3(c2))
                      ;
                    else {
                      if (c2 === "")
                        return void C2();
                      a2 = "in descriptor", y2 -= 1;
                    }
                  y2 += 1;
                }
              }
              function C2() {
                var t4, r4, o3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
                for (s3 = 0; s3 < u2.length; s3++)
                  c3 = (a3 = u2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t4 || r4) && (d3 = true), p3 === 0 ? d3 = true : t4 = p3) : m2.test(l3) && c3 === "x" ? ((t4 || r4 || o3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((o3 || r4) && (d3 = true), p3 === 0 ? d3 = true : o3 = p3) : d3 = true;
                d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e2 + "' at '" + a3 + "'.") : (h3.url = i2, t4 && (h3.w = t4), r4 && (h3.d = r4), o3 && (h3.h = o3), D2.push(h3));
              }
            };
          }, t2.exports ? t2.exports = r2() : n2.parseSrcset = r2();
        }(xU);
        const SU = xU.exports, { builders: { ifBreak: wU, join: TU, line: BU } } = Zc;
        var NU = { printImgSrcset: function(e2) {
          const t2 = SU(e2, { logger: { error(e3) {
            throw new Error(e3);
          } } }), n2 = t2.some((e3) => {
            let { w: t3 } = e3;
            return t3;
          }), r2 = t2.some((e3) => {
            let { h: t3 } = e3;
            return t3;
          });
          if (n2 + r2 + t2.some((e3) => {
            let { d: t3 } = e3;
            return t3;
          }) > 1)
            throw new Error("Mixed descriptor in srcset is not supported");
          const o2 = n2 ? "w" : r2 ? "h" : "d", i2 = n2 ? "w" : r2 ? "h" : "x", u2 = (e3) => Math.max(...e3), s2 = t2.map((e3) => e3.url), a2 = u2(s2.map((e3) => e3.length)), c2 = t2.map((e3) => e3[o2]).map((e3) => e3 ? e3.toString() : ""), l2 = c2.map((e3) => {
            const t3 = e3.indexOf(".");
            return t3 === -1 ? e3.length : t3;
          }), p2 = u2(l2);
          return TU([",", BU], s2.map((e3, t3) => {
            const n3 = [e3], r3 = c2[t3];
            if (r3) {
              const o3 = a2 - e3.length + 1, u3 = p2 - l2[t3], s3 = " ".repeat(o3 + u3);
              n3.push(wU(s3, " "), r3 + i2);
            }
            return n3;
          }));
        }, printClassNames: function(e2) {
          return e2.trim().split(/\s+/).join(" ");
        } };
        const { builders: { group: kU } } = Zc;
        var PU = { isVueEventBindingExpression: function(e2) {
          const t2 = e2.trim();
          return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
        }, printVueFor: function(e2, t2) {
          const { left: n2, operator: r2, right: o2 } = function(e3) {
            const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, o3 = e3.match(t3);
            if (!o3)
              return;
            const i2 = {};
            i2.for = o3[3].trim();
            const u2 = o3[1].trim().replace(r3, ""), s2 = u2.match(n3);
            s2 ? (i2.alias = u2.replace(n3, ""), i2.iterator1 = s2[1].trim(), s2[2] && (i2.iterator2 = s2[2].trim())) : i2.alias = u2;
            return { left: "".concat([i2.alias, i2.iterator1, i2.iterator2].filter(Boolean).join(",")), operator: o3[2], right: i2.for };
          }(e2);
          return [kU(t2("function _(".concat(n2, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", r2, " ", t2(o2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
        }, printVueBindings: function(e2, t2) {
          return t2("function _(".concat(e2, ") {}"), { parser: "babel", __isVueBindings: true });
        } };
        const { needsToBorrowParentClosingTagStartMarker: OU, printClosingTagStartMarker: IU, needsToBorrowLastChildClosingTagEndMarker: LU, printClosingTagEndMarker: jU, needsToBorrowParentOpeningTagEndMarker: _U, printOpeningTagEndMarker: MU } = FU;
        var RU = function(e2, t2) {
          let n2 = e2.startSourceSpan.end.offset;
          e2.firstChild && _U(e2.firstChild) && (n2 -= MU(e2).length);
          let r2 = e2.endSourceSpan.start.offset;
          return e2.lastChild && OU(e2.lastChild) ? r2 += IU(e2, t2).length : LU(e2) && (r2 -= jU(e2.lastChild, t2).length), t2.originalText.slice(n2, r2);
        };
        const { builders: { breakParent: VU, group: $U, hardline: WU, indent: qU, line: UU, fill: zU, softline: GU }, utils: { mapDoc: HU, replaceTextEndOfLine: JU } } = Zc, XU = Wj, { printClosingTag: YU, printClosingTagSuffix: KU, needsToBorrowPrevClosingTagEndMarker: QU, printOpeningTagPrefix: ZU, printOpeningTag: ez } = FU, { printImgSrcset: tz, printClassNames: nz } = NU, { printVueFor: rz, printVueBindings: oz, isVueEventBindingExpression: iz } = PU, { isScriptLikeTag: uz, isVueNonHtmlBlock: sz, inferScriptParser: az, htmlTrimPreserveIndentation: cz, dedentString: lz, unescapeQuoteEntities: pz, isVueSlotAttribute: fz, isVueSfcBindingsAttribute: dz, getTextValueParts: hz } = fq, gz = RU;
        function mz(e2, t2, n2) {
          const r2 = (t3) => new RegExp(t3.join("|")).test(e2.fullName), o2 = () => pz(e2.value);
          let i2 = false;
          const u2 = (e3, t3) => {
            const n3 = e3.type === "NGRoot" ? e3.node.type === "NGMicrosyntax" && e3.node.body.length === 1 && e3.node.body[0].type === "NGMicrosyntaxExpression" ? e3.node.body[0].expression : e3.node : e3.type === "JsExpressionRoot" ? e3.node : e3;
            !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (i2 = true);
          }, s2 = function(e3) {
            let t3 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            return $U([qU([GU, e3]), t3 ? GU : ""]);
          }, a2 = (e3) => i2 ? ((e4) => $U(e4))(e3) : s2(e3), c2 = (e3, n3) => t2(e3, Object.assign({ __onHtmlBindingRoot: u2, __embeddedInHtml: true }, n3), { stripTrailingHardline: true });
          if (e2.fullName === "srcset" && (e2.parent.fullName === "img" || e2.parent.fullName === "source"))
            return s2(tz(o2()));
          if (e2.fullName === "class" && !n2.parentParser) {
            const e3 = o2();
            if (!e3.includes("{{"))
              return nz(e3);
          }
          if (e2.fullName === "style" && !n2.parentParser) {
            const e3 = o2();
            if (!e3.includes("{{"))
              return s2(c2(e3, { parser: "css", __isHTMLStyleAttribute: true }));
          }
          if (n2.parser === "vue") {
            if (e2.fullName === "v-for")
              return rz(o2(), c2);
            if (fz(e2) || dz(e2, n2))
              return oz(o2(), c2);
            const t3 = ["^:", "^v-bind:"], i3 = ["^v-"];
            if (r2(["^@", "^v-on:"])) {
              const e3 = o2();
              return a2(c2(e3, { parser: iz(e3) ? "__js_expression" : "__vue_event_binding" }));
            }
            if (r2(t3))
              return a2(c2(o2(), { parser: "__vue_expression" }));
            if (r2(i3))
              return a2(c2(o2(), { parser: "__js_expression" }));
          }
          if (n2.parser === "angular") {
            const t3 = (e3, t4) => c2(e3, Object.assign(Object.assign({}, t4), {}, { trailingComma: "none" })), n3 = ["^\\*"], i3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], u3 = ["^i18n(-.+)?$"];
            if (r2(["^\\(.+\\)$", "^on-"]))
              return a2(t3(o2(), { parser: "__ng_action" }));
            if (r2(i3))
              return a2(t3(o2(), { parser: "__ng_binding" }));
            if (r2(u3)) {
              const t4 = o2().trim();
              return s2(zU(hz(e2, t4)), !t4.includes("@@"));
            }
            if (r2(n3))
              return a2(t3(o2(), { parser: "__ng_directive" }));
            const l2 = /{{(.+?)}}/s, p2 = o2();
            if (l2.test(p2)) {
              const e3 = [];
              for (const [n4, r3] of p2.split(l2).entries())
                if (n4 % 2 == 0)
                  e3.push(JU(r3));
                else
                  try {
                    e3.push($U(["{{", qU([UU, t3(r3, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), UU, "}}"]));
                  } catch (e4) {
                    e3.push("{{", JU(r3), "}}");
                  }
              return $U(e3);
            }
          }
          return null;
        }
        var yz = function(e2, t2, n2, r2) {
          const o2 = e2.getValue();
          switch (o2.type) {
            case "element":
              if (uz(o2) || o2.type === "interpolation")
                return;
              if (!o2.isSelfClosing && sz(o2, r2)) {
                const i2 = az(o2, r2);
                if (!i2)
                  return;
                const u2 = gz(o2, r2);
                let s2 = /^\s*$/.test(u2), a2 = "";
                return s2 || (a2 = n2(cz(u2), { parser: i2, __embeddedInHtml: true }, { stripTrailingHardline: true }), s2 = a2 === ""), [ZU(o2, r2), $U(ez(e2, r2, t2)), s2 ? "" : WU, a2, s2 ? "" : WU, YU(o2, r2), KU(o2, r2)];
              }
              break;
            case "text":
              if (uz(o2.parent)) {
                const e3 = az(o2.parent);
                if (e3) {
                  const t3 = e3 === "markdown" ? lz(o2.value.replace(/^[^\S\n]*?\n/, "")) : o2.value, i2 = { parser: e3, __embeddedInHtml: true };
                  if (r2.parser === "html" && e3 === "babel") {
                    let e4 = "script";
                    const { attrMap: t4 } = o2.parent;
                    t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e4 = "module"), i2.__babelSourceType = e4;
                  }
                  return [VU, ZU(o2, r2), n2(t3, i2, { stripTrailingHardline: true }), KU(o2, r2)];
                }
              } else if (o2.parent.type === "interpolation") {
                const e3 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                return r2.parser === "angular" ? (e3.parser = "__ng_interpolation", e3.trailingComma = "none") : r2.parser === "vue" ? e3.parser = "__vue_expression" : e3.parser = "__js_expression", [qU([UU, n2(o2.value, e3, { stripTrailingHardline: true })]), o2.parent.next && QU(o2.parent.next) ? " " : UU];
              }
              break;
            case "attribute": {
              if (!o2.value)
                break;
              if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(o2.valueSpan.start.offset, o2.valueSpan.end.offset)))
                return [o2.rawName, "=", o2.value];
              if (r2.parser === "lwc") {
                if (/^{.*}$/s.test(r2.originalText.slice(o2.valueSpan.start.offset, o2.valueSpan.end.offset)))
                  return [o2.rawName, "=", o2.value];
              }
              const e3 = mz(o2, (e4, t3) => n2(e4, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t3), { stripTrailingHardline: true }), r2);
              if (e3)
                return [o2.rawName, '="', $U(HU(e3, (e4) => typeof e4 == "string" ? e4.replace(/"/g, "&quot;") : e4)), '"'];
              break;
            }
            case "front-matter":
              return XU(o2, n2);
          }
        };
        const { builders: { breakParent: Dz, group: Ez, ifBreak: Cz, line: bz, softline: vz, hardline: Az }, utils: { replaceTextEndOfLine: Fz } } = Zc, { locStart: xz, locEnd: Sz } = zq, { forceBreakChildren: wz, forceNextEmptyLine: Tz, isTextLikeNode: Bz, hasPrettierIgnore: Nz, preferHardlineAsLeadingSpaces: kz } = fq, { printOpeningTagPrefix: Pz, needsToBorrowNextOpeningTagStartMarker: Oz, printOpeningTagStartMarker: Iz, needsToBorrowPrevClosingTagEndMarker: Lz, printClosingTagEndMarker: jz, printClosingTagSuffix: _z, needsToBorrowParentClosingTagStartMarker: Mz } = FU;
        function Rz(e2, t2, n2) {
          const r2 = e2.getValue();
          return Nz(r2) ? [Pz(r2, t2), ...Fz(t2.originalText.slice(xz(r2) + (r2.prev && Oz(r2.prev) ? Iz(r2).length : 0), Sz(r2) - (r2.next && Lz(r2.next) ? jz(r2, t2).length : 0))), _z(r2, t2)] : n2();
        }
        function Vz(e2, t2) {
          return Bz(e2) && Bz(t2) ? e2.isTrailingSpaceSensitive ? e2.hasTrailingSpaces ? kz(t2) ? Az : bz : "" : kz(t2) ? Az : vz : Oz(e2) && (Nz(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e2.type === "element" && e2.isSelfClosing && Lz(t2) ? "" : !t2.isLeadingSpaceSensitive || kz(t2) || Lz(t2) && e2.lastChild && Mz(e2.lastChild) && e2.lastChild.lastChild && Mz(e2.lastChild.lastChild) ? Az : t2.hasLeadingSpaces ? bz : vz;
        }
        var $z = { printChildren: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (wz(r2))
            return [Dz, ...e2.map((e3) => {
              const r3 = e3.getValue(), o3 = r3.prev ? Vz(r3.prev, r3) : "";
              return [o3 ? [o3, Tz(r3.prev) ? Az : ""] : "", Rz(e3, t2, n2)];
            }, "children")];
          const o2 = r2.children.map(() => Symbol(""));
          return e2.map((e3, r3) => {
            const i2 = e3.getValue();
            if (Bz(i2)) {
              if (i2.prev && Bz(i2.prev)) {
                const r4 = Vz(i2.prev, i2);
                if (r4)
                  return Tz(i2.prev) ? [Az, Az, Rz(e3, t2, n2)] : [r4, Rz(e3, t2, n2)];
              }
              return Rz(e3, t2, n2);
            }
            const u2 = [], s2 = [], a2 = [], c2 = [], l2 = i2.prev ? Vz(i2.prev, i2) : "", p2 = i2.next ? Vz(i2, i2.next) : "";
            return l2 && (Tz(i2.prev) ? u2.push(Az, Az) : l2 === Az ? u2.push(Az) : Bz(i2.prev) ? s2.push(l2) : s2.push(Cz("", vz, { groupId: o2[r3 - 1] }))), p2 && (Tz(i2) ? Bz(i2.next) && c2.push(Az, Az) : p2 === Az ? Bz(i2.next) && c2.push(Az) : a2.push(p2)), [...u2, Ez([...s2, Ez([Rz(e3, t2, n2), ...a2], { id: o2[r3] })]), ...c2];
          }, "children");
        } };
        const { builders: { breakParent: Wz, dedentToRoot: qz, group: Uz, ifBreak: zz, indentIfBreak: Gz, indent: Hz, line: Jz, softline: Xz }, utils: { replaceTextEndOfLine: Yz } } = Zc, Kz = RU, { shouldPreserveContent: Qz, isScriptLikeTag: Zz, isVueCustomBlock: eG, countParents: tG, forceBreakContent: nG } = fq, { printOpeningTagPrefix: rG, printOpeningTag: oG, printClosingTagSuffix: iG, printClosingTag: uG, needsToBorrowPrevClosingTagEndMarker: sG, needsToBorrowLastChildClosingTagEndMarker: aG } = FU, { printChildren: cG } = $z;
        var lG = { printElement: function(e2, t2, n2) {
          const r2 = e2.getValue();
          if (Qz(r2, t2))
            return [rG(r2, t2), Uz(oG(e2, t2, n2)), ...Yz(Kz(r2, t2)), ...uG(r2, t2), iG(r2, t2)];
          const o2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, i2 = Symbol("element-attr-group-id"), u2 = (o3) => Uz([Uz(oG(e2, t2, n2), { id: i2 }), o3, uG(r2, t2)]);
          return r2.children.length === 0 ? u2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? Jz : "") : u2([nG(r2) ? Wz : "", (s2 = [o2 ? zz(Xz, "", { groupId: i2 }) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? Jz : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? qz(Xz) : Xz, cG(e2, t2, n2)], o2 ? Gz(s2, { groupId: i2 }) : !Zz(r2) && !eG(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? Hz(s2) : s2), (r2.next ? sG(r2.next) : aG(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : o2 ? zz(Xz, "", { groupId: i2 }) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? Jz : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t2.tabWidth * tG(e2, (e3) => e3.parent && e3.parent.type !== "root"), "}$")).test(r2.lastChild.value) ? "" : Xz]);
          var s2;
        } };
        const { builders: { fill: pG, group: fG, hardline: dG, literalline: hG }, utils: { cleanDoc: gG, getDocParts: mG, isConcat: yG, replaceTextEndOfLine: DG } } = Zc, EG = xW, { countChars: CG, unescapeQuoteEntities: bG, getTextValueParts: vG } = fq, AG = qq, { insertPragma: FG } = Uq, { locStart: xG, locEnd: SG } = zq, wG = yz, { printClosingTagSuffix: TG, printClosingTagEnd: BG, printOpeningTagPrefix: NG, printOpeningTagStart: kG } = FU, { printElement: PG } = lG, { printChildren: OG } = $z;
        var IG = { preprocess: AG, print: function(e2, t2, n2) {
          const r2 = e2.getValue();
          switch (r2.type) {
            case "front-matter":
              return DG(r2.raw);
            case "root":
              return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [fG(OG(e2, t2, n2)), dG];
            case "element":
            case "ieConditionalComment":
              return PG(e2, t2, n2);
            case "ieConditionalStartComment":
            case "ieConditionalEndComment":
              return [kG(r2), BG(r2)];
            case "interpolation":
              return [kG(r2, t2), ...e2.map(n2, "children"), BG(r2, t2)];
            case "text": {
              if (r2.parent.type === "interpolation") {
                const e4 = /\n[^\S\n]*?$/, t3 = e4.test(r2.value), n3 = t3 ? r2.value.replace(e4, "") : r2.value;
                return [...DG(n3), t3 ? dG : ""];
              }
              const e3 = gG([NG(r2, t2), ...vG(r2), TG(r2, t2)]);
              return yG(e3) || e3.type === "fill" ? pG(mG(e3)) : e3;
            }
            case "docType":
              return [fG([kG(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), BG(r2, t2)];
            case "comment":
              return [NG(r2, t2), ...DG(t2.originalText.slice(xG(r2), SG(r2)), hG), TG(r2, t2)];
            case "attribute": {
              if (r2.value === null)
                return r2.rawName;
              const e3 = bG(r2.value), t3 = CG(e3, "'") < CG(e3, '"') ? "'" : '"';
              return [r2.rawName, "=", t3, ...DG(t3 === '"' ? e3.replace(/"/g, "&quot;") : e3.replace(/'/g, "&apos;")), t3];
            }
            default:
              throw new Error("Unexpected node type ".concat(r2.type));
          }
        }, insertPragma: FG, massageAstNode: EG, embed: wG };
        const LG = "HTML";
        var jG = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 }, _G = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        const MG = bE, RG = IG, VG = { bracketSameLine: bj.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: LG, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: LG, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, $G = [MG(jG, () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), MG(jG, (e2) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e2.extensions, ".mjml"] })), MG(jG, () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), MG(_G, () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))];
        var WG = { languages: $G, printers: { html: RG }, options: VG, parsers: void 0 };
        var qG = { isPragma: function(e2) {
          return /^\s*@(?:prettier|format)\s*$/.test(e2);
        }, hasPragma: function(e2) {
          return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e2);
        }, insertPragma: function(e2) {
          return "# @format\n\n".concat(e2);
        } };
        var UG = { locStart: function(e2) {
          return e2.position.start.offset;
        }, locEnd: function(e2) {
          return e2.position.end.offset;
        } };
        var zG = function(e2, t2, n2, r2) {
          if (e2.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
            return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, { parser: "json" }));
        };
        const { getLast: GG, isNonEmptyArray: HG } = dc;
        function JG(e2, t2) {
          return e2 && typeof e2.type == "string" && (!t2 || t2.includes(e2.type));
        }
        function XG(e2) {
          return e2.value.trim() === "prettier-ignore";
        }
        function YG(e2) {
          return e2 && HG(e2.leadingComments);
        }
        function KG(e2) {
          return e2 && HG(e2.middleComments);
        }
        function QG(e2) {
          return e2 && e2.indicatorComment;
        }
        function ZG(e2) {
          return e2 && e2.trailingComment;
        }
        function eH(e2) {
          return e2 && HG(e2.endComments);
        }
        function tH(e2) {
          const t2 = [];
          let n2;
          for (const r2 of e2.split(/( +)/))
            r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
          return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
        }
        var nH = { getLast: GG, getAncestorCount: function(e2, t2) {
          let n2 = 0;
          const r2 = e2.stack.length - 1;
          for (let o2 = 0; o2 < r2; o2++) {
            const r3 = e2.stack[o2];
            JG(r3) && t2(r3) && n2++;
          }
          return n2;
        }, isNode: JG, isEmptyNode: function(e2) {
          return !HG(e2.children) && !function(e3) {
            return YG(e3) || KG(e3) || QG(e3) || ZG(e3) || eH(e3);
          }(e2);
        }, isInlineNode: function(e2) {
          if (!e2)
            return true;
          switch (e2.type) {
            case "plain":
            case "quoteDouble":
            case "quoteSingle":
            case "alias":
            case "flowMapping":
            case "flowSequence":
              return true;
            default:
              return false;
          }
        }, mapNode: function e2(t2, n2, r2) {
          return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, { children: t2.children.map((r3) => e2(r3, n2, t2)) }) : t2, r2);
        }, defineShortcut: function(e2, t2, n2) {
          Object.defineProperty(e2, t2, { get: n2, enumerable: false });
        }, isNextLineEmpty: function(e2, t2) {
          let n2 = 0;
          const r2 = t2.length;
          for (let o2 = e2.position.end.offset - 1; o2 < r2; o2++) {
            const e3 = t2[o2];
            if (e3 === "\n" && n2++, n2 === 1 && /\S/.test(e3))
              return false;
            if (n2 === 2)
              return true;
          }
          return false;
        }, isLastDescendantNode: function(e2) {
          switch (e2.getValue().type) {
            case "tag":
            case "anchor":
            case "comment":
              return false;
          }
          const t2 = e2.stack.length;
          for (let n2 = 1; n2 < t2; n2++) {
            const t3 = e2.stack[n2], r2 = e2.stack[n2 - 1];
            if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
              return false;
          }
          return true;
        }, getBlockValueLineContents: function(e2, t2) {
          let { parentIndent: n2, isLastDescendant: r2, options: o2 } = t2;
          const i2 = e2.position.start.line === e2.position.end.line ? "" : o2.originalText.slice(e2.position.start.offset, e2.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e2.indent === null ? ((e3) => e3 ? e3[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e2.indent - 1 + n2, s2 = i2.split("\n").map((e3) => e3.slice(u2));
          return o2.proseWrap === "preserve" || e2.type === "blockLiteral" ? a2(s2.map((e3) => e3.length === 0 ? [] : [e3])) : a2(s2.map((e3) => e3.length === 0 ? [] : tH(e3)).reduce((e3, t3, n3) => n3 !== 0 && s2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(GG(e3)) ? [...e3.slice(0, -1), [...GG(e3), ...t3]] : [...e3, t3], []).map((e3) => e3.reduce((e4, t3) => e4.length > 0 && /\s$/.test(GG(e4)) ? [...e4.slice(0, -1), GG(e4) + " " + t3] : [...e4, t3], [])).map((e3) => o2.proseWrap === "never" ? [e3.join(" ")] : e3));
          function a2(t3) {
            if (e2.chomping === "keep")
              return GG(t3).length === 0 ? t3.slice(0, -1) : t3;
            let n3 = 0;
            for (let e3 = t3.length - 1; e3 >= 0 && t3[e3].length === 0; e3--)
              n3++;
            return n3 === 0 ? t3 : n3 >= 2 && !r2 ? t3.slice(0, -(n3 - 1)) : t3.slice(0, -n3);
          }
        }, getFlowScalarLineContents: function(e2, t2, n2) {
          const r2 = t2.split("\n").map((e3, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e3 : t3 !== 0 && t3 !== n3.length - 1 ? e3.trim() : t3 === 0 ? e3.trimEnd() : e3.trimStart());
          return n2.proseWrap === "preserve" ? r2.map((e3) => e3.length === 0 ? [] : [e3]) : r2.map((e3) => e3.length === 0 ? [] : tH(e3)).reduce((t3, n3, o2) => o2 !== 0 && r2[o2 - 1].length > 0 && n3.length > 0 && (e2 !== "quoteDouble" || !GG(GG(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...GG(t3), ...n3]] : [...t3, n3], []).map((e3) => n2.proseWrap === "never" ? [e3.join(" ")] : e3);
        }, getLastDescendantNode: function e2(t2) {
          return HG(t2.children) ? e2(GG(t2.children)) : t2;
        }, hasPrettierIgnore: function(e2) {
          const t2 = e2.getValue();
          if (t2.type === "documentBody") {
            const t3 = e2.getParentNode();
            return eH(t3.head) && XG(GG(t3.head.endComments));
          }
          return YG(t2) && XG(GG(t2.leadingComments));
        }, hasLeadingComments: YG, hasMiddleComments: KG, hasIndicatorComment: QG, hasTrailingComment: ZG, hasEndComments: eH };
        const { defineShortcut: rH, mapNode: oH } = nH;
        function iH(e2) {
          switch (e2.type) {
            case "document":
              rH(e2, "head", () => e2.children[0]), rH(e2, "body", () => e2.children[1]);
              break;
            case "documentBody":
            case "sequenceItem":
            case "flowSequenceItem":
            case "mappingKey":
            case "mappingValue":
              rH(e2, "content", () => e2.children[0]);
              break;
            case "mappingItem":
            case "flowMappingItem":
              rH(e2, "key", () => e2.children[0]), rH(e2, "value", () => e2.children[1]);
          }
          return e2;
        }
        var uH = function(e2) {
          return oH(e2, iH);
        };
        const { builders: { softline: sH, align: aH } } = Zc, { hasEndComments: cH, isNextLineEmpty: lH, isNode: pH } = nH, fH = /* @__PURE__ */ new WeakMap();
        function dH(e2) {
          return cH(e2) && !pH(e2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
        }
        var hH = { alignWithSpaces: function(e2, t2) {
          return aH(" ".repeat(e2), t2);
        }, shouldPrintEndComments: dH, printNextEmptyLine: function(e2, t2) {
          const n2 = e2.getValue(), r2 = e2.stack[0];
          let o2;
          return fH.has(r2) ? o2 = fH.get(r2) : (o2 = /* @__PURE__ */ new Set(), fH.set(r2, o2)), o2.has(n2.position.end.line) || (o2.add(n2.position.end.line), !lH(n2, t2) || dH(e2.getParentNode())) ? "" : sH;
        } };
        const { builders: { ifBreak: gH, line: mH, softline: yH, hardline: DH, join: EH } } = Zc, { isEmptyNode: CH, getLast: bH, hasEndComments: vH } = nH, { printNextEmptyLine: AH, alignWithSpaces: FH } = hH;
        function xH(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = r2.type === "flowMapping", i2 = o2 ? "{" : "[", u2 = o2 ? "}" : "]";
          let s2 = yH;
          o2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = mH);
          const a2 = bH(r2.children), c2 = a2 && a2.type === "flowMappingItem" && CH(a2.key) && CH(a2.value);
          return [i2, FH(n2.tabWidth, [s2, SH(e2, t2, n2), n2.trailingComma === "none" ? "" : gH(","), vH(r2) ? [DH, EH(DH, e2.map(t2, "endComments"))] : ""]), c2 ? "" : s2, u2];
        }
        function SH(e2, t2, n2) {
          const r2 = e2.getValue();
          return e2.map((e3, o2) => [t2(), o2 === r2.children.length - 1 ? "" : [",", mH, r2.children[o2].position.start.line !== r2.children[o2 + 1].position.start.line ? AH(e3, n2.originalText) : ""]], "children");
        }
        var wH = { printFlowMapping: xH, printFlowSequence: xH };
        const { builders: { conditionalGroup: TH, group: BH, hardline: NH, ifBreak: kH, join: PH, line: OH } } = Zc, { hasLeadingComments: IH, hasMiddleComments: LH, hasTrailingComment: jH, hasEndComments: _H, isNode: MH, isEmptyNode: RH, isInlineNode: VH } = nH, { alignWithSpaces: $H } = hH;
        function WH(e2, t2) {
          if (!e2)
            return true;
          switch (e2.type) {
            case "plain":
            case "quoteSingle":
            case "quoteDouble":
              break;
            case "alias":
              return true;
            default:
              return false;
          }
          if (t2.proseWrap === "preserve")
            return e2.position.start.line === e2.position.end.line;
          if (/\\$/m.test(t2.originalText.slice(e2.position.start.offset, e2.position.end.offset)))
            return false;
          switch (t2.proseWrap) {
            case "never":
              return !e2.value.includes("\n");
            case "always":
              return !/[\n ]/.test(e2.value);
            default:
              return false;
          }
        }
        var qH = function(e2, t2, n2, r2, o2) {
          const { key: i2, value: u2 } = e2, s2 = RH(i2), a2 = RH(u2);
          if (s2 && a2)
            return ": ";
          const c2 = r2("key"), l2 = function(e3) {
            return e3.key.content && e3.key.content.type === "alias";
          }(e2) ? " " : "";
          if (a2)
            return e2.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e2.type !== "mappingItem" || !WH(i2.content, o2) || jH(i2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", $H(2, c2)] : [c2, l2, ":"];
          const p2 = r2("value");
          if (s2)
            return [": ", $H(2, p2)];
          if (IH(u2) || !VH(i2.content))
            return ["? ", $H(2, c2), NH, PH("", n2.map(r2, "value", "leadingComments").map((e3) => [e3, NH])), ": ", $H(2, p2)];
          if (function(e3) {
            if (!e3)
              return true;
            switch (e3.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return e3.position.start.line === e3.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }(i2.content) && !IH(i2.content) && !LH(i2.content) && !jH(i2.content) && !_H(i2) && !IH(u2.content) && !LH(u2.content) && !_H(u2) && WH(u2.content, o2))
            return [c2, l2, ": ", p2];
          const f2 = Symbol("mappingKey"), d2 = BH([kH("? "), BH($H(2, c2), { id: f2 })]), h2 = [NH, ": ", $H(2, p2)], g2 = [l2, ":"];
          IH(u2.content) || _H(u2) && u2.content && !MH(u2.content, ["mapping", "sequence"]) || t2.type === "mapping" && jH(i2.content) && VH(u2.content) || MH(u2.content, ["mapping", "sequence"]) && u2.content.tag === null && u2.content.anchor === null ? g2.push(NH) : u2.content && g2.push(OH), g2.push(p2);
          const m2 = $H(o2.tabWidth, g2);
          return !WH(i2.content, o2) || IH(i2.content) || LH(i2.content) || _H(i2) ? TH([[d2, kH(h2, m2, { groupId: f2 })]]) : TH([[c2, m2]]);
        };
        const { builders: { dedent: UH, dedentToRoot: zH, fill: GH, hardline: HH, join: JH, line: XH, literalline: YH, markAsRoot: KH }, utils: { getDocParts: QH } } = Zc, { getAncestorCount: ZH, getBlockValueLineContents: eJ, hasIndicatorComment: tJ, isLastDescendantNode: nJ, isNode: rJ } = nH, { alignWithSpaces: oJ } = hH;
        var iJ = function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = ZH(e2, (e3) => rJ(e3, ["sequence", "mapping"])), i2 = nJ(e2), u2 = [r2.type === "blockFolded" ? ">" : "|"];
          r2.indent !== null && u2.push(r2.indent.toString()), r2.chomping !== "clip" && u2.push(r2.chomping === "keep" ? "+" : "-"), tJ(r2) && u2.push(" ", t2("indicatorComment"));
          const s2 = eJ(r2, { parentIndent: o2, isLastDescendant: i2, options: n2 }), a2 = [];
          for (const [e3, t3] of s2.entries())
            e3 === 0 && a2.push(HH), a2.push(GH(QH(JH(XH, t3)))), e3 !== s2.length - 1 ? a2.push(t3.length === 0 ? HH : KH(YH)) : r2.chomping === "keep" && i2 && a2.push(zH(t3.length === 0 ? HH : YH));
          return r2.indent === null ? u2.push(UH(oJ(n2.tabWidth, a2))) : u2.push(zH(oJ(r2.indent - 1 + o2, a2))), u2;
        };
        const { builders: { breakParent: uJ, fill: sJ, group: aJ, hardline: cJ, join: lJ, line: pJ, lineSuffix: fJ, literalline: dJ }, utils: { getDocParts: hJ, replaceTextEndOfLine: gJ } } = Zc, { isPreviousLineEmpty: mJ } = dc, { insertPragma: yJ, isPragma: DJ } = qG, { locStart: EJ } = UG, CJ = zG, { getFlowScalarLineContents: bJ, getLastDescendantNode: vJ, hasLeadingComments: AJ, hasMiddleComments: FJ, hasTrailingComment: xJ, hasEndComments: SJ, hasPrettierIgnore: wJ, isLastDescendantNode: TJ, isNode: BJ, isInlineNode: NJ } = nH, kJ = uH, { alignWithSpaces: PJ, printNextEmptyLine: OJ, shouldPrintEndComments: IJ } = hH, { printFlowMapping: LJ, printFlowSequence: jJ } = wH, _J = qH, MJ = iJ;
        function RJ(e2, t2) {
          return xJ(e2) || t2 && (t2.head.children.length > 0 || SJ(t2.head));
        }
        function VJ(e2, t2, n2) {
          const r2 = bJ(e2, t2, n2);
          return lJ(cJ, r2.map((e3) => sJ(hJ(lJ(pJ, e3)))));
        }
        var $J = { preprocess: kJ, embed: CJ, print: function(e2, t2, n2) {
          const r2 = e2.getValue(), o2 = [];
          r2.type !== "mappingValue" && AJ(r2) && o2.push([lJ(cJ, e2.map(n2, "leadingComments")), cJ]);
          const { tag: i2, anchor: u2 } = r2;
          i2 && o2.push(n2("tag")), i2 && u2 && o2.push(" "), u2 && o2.push(n2("anchor"));
          let s2 = "";
          BJ(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !TJ(e2) && (s2 = OJ(e2, t2.originalText)), (i2 || u2) && (BJ(r2, ["sequence", "mapping"]) && !FJ(r2) ? o2.push(cJ) : o2.push(" ")), FJ(r2) && o2.push([r2.middleComments.length === 1 ? "" : cJ, lJ(cJ, e2.map(n2, "middleComments")), cJ]);
          const a2 = e2.getParentNode();
          return wJ(e2) ? o2.push(gJ(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), dJ)) : o2.push(aJ(function(e3, t3, n3, r3, o3) {
            switch (e3.type) {
              case "root": {
                const { children: t4 } = e3, r4 = [];
                n3.each((e4, n4) => {
                  const i4 = t4[n4], u3 = t4[n4 + 1];
                  n4 !== 0 && r4.push(cJ), r4.push(o3()), RJ(i4, u3) ? (r4.push(cJ, "..."), xJ(i4) && r4.push(" ", o3("trailingComment"))) : u3 && !xJ(u3.head) && r4.push(cJ, "---");
                }, "children");
                const i3 = vJ(e3);
                return BJ(i3, ["blockLiteral", "blockFolded"]) && i3.chomping === "keep" || r4.push(cJ), r4;
              }
              case "document": {
                const i3 = [];
                return function(e4, t4, n4, r4) {
                  if (n4.children[0] === e4 && /---(?:\s|$)/.test(r4.originalText.slice(EJ(e4), EJ(e4) + 4)) || e4.head.children.length > 0 || SJ(e4.head) || xJ(e4.head))
                    return "head";
                  if (RJ(e4, t4))
                    return false;
                  return !!t4 && "root";
                }(e3, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e3.head.children.length > 0 || e3.head.endComments.length > 0) && i3.push(o3("head")), xJ(e3.head) ? i3.push(["---", " ", o3(["head", "trailingComment"])]) : i3.push("---")), function(e4) {
                  return e4.body.children.length > 0 || SJ(e4.body);
                }(e3) && i3.push(o3("body")), lJ(cJ, i3);
              }
              case "documentHead":
                return lJ(cJ, [...n3.map(o3, "children"), ...n3.map(o3, "endComments")]);
              case "documentBody": {
                const { children: t4, endComments: r4 } = e3;
                let i3 = "";
                if (t4.length > 0 && r4.length > 0) {
                  const t5 = vJ(e3);
                  BJ(t5, ["blockFolded", "blockLiteral"]) ? t5.chomping !== "keep" && (i3 = [cJ, cJ]) : i3 = cJ;
                }
                return [lJ(cJ, n3.map(o3, "children")), i3, lJ(cJ, n3.map(o3, "endComments"))];
              }
              case "directive":
                return ["%", lJ(" ", [e3.name, ...e3.parameters])];
              case "comment":
                return ["#", e3.value];
              case "alias":
                return ["*", e3.value];
              case "tag":
                return r3.originalText.slice(e3.position.start.offset, e3.position.end.offset);
              case "anchor":
                return ["&", e3.value];
              case "plain":
                return VJ(e3.type, r3.originalText.slice(e3.position.start.offset, e3.position.end.offset), r3);
              case "quoteDouble":
              case "quoteSingle": {
                const t4 = "'", n4 = '"', o4 = r3.originalText.slice(e3.position.start.offset + 1, e3.position.end.offset - 1);
                if (e3.type === "quoteSingle" && o4.includes("\\") || e3.type === "quoteDouble" && /\\[^"]/.test(o4)) {
                  const i4 = e3.type === "quoteDouble" ? n4 : t4;
                  return [i4, VJ(e3.type, o4, r3), i4];
                }
                if (o4.includes(n4))
                  return [t4, VJ(e3.type, e3.type === "quoteDouble" ? o4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : o4, r3), t4];
                if (o4.includes(t4))
                  return [n4, VJ(e3.type, e3.type === "quoteSingle" ? o4.replace(/''/g, t4) : o4, r3), n4];
                const i3 = r3.singleQuote ? t4 : n4;
                return [i3, VJ(e3.type, o4, r3), i3];
              }
              case "blockFolded":
              case "blockLiteral":
                return MJ(n3, o3, r3);
              case "mapping":
              case "sequence":
                return lJ(cJ, n3.map(o3, "children"));
              case "sequenceItem":
                return ["- ", PJ(2, e3.content ? o3("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return e3.content ? o3("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return _J(e3, t3, n3, o3, r3);
              case "flowMapping":
                return LJ(n3, o3, r3);
              case "flowSequence":
                return jJ(n3, o3, r3);
              case "flowSequenceItem":
                return o3("content");
              default:
                throw new Error("Unexpected node type ".concat(e3.type));
            }
          }(r2, a2, e2, t2, n2))), xJ(r2) && !BJ(r2, ["document", "documentHead"]) && o2.push(fJ([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e2.getParentNode(2).type === "mapping" && NJ(r2) ? "" : uJ, n2("trailingComment")])), IJ(r2) && o2.push(PJ(r2.type === "sequenceItem" ? 2 : 0, [cJ, lJ(cJ, e2.map((e3) => [mJ(t2.originalText, e3.getValue(), EJ) ? cJ : "", n2()], "endComments"))])), o2.push(s2), o2;
        }, massageAstNode: function(e2, t2) {
          if (BJ(t2))
            switch (delete t2.position, t2.type) {
              case "comment":
                if (DJ(t2.value))
                  return null;
                break;
              case "quoteDouble":
              case "quoteSingle":
                t2.type = "quote";
            }
        }, insertPragma: yJ };
        const WJ = $J, qJ = { bracketSpacing: bj.bracketSpacing, singleQuote: bj.singleQuote, proseWrap: bj.proseWrap }, UJ = [bE({ name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 }, (e2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e2.filenames.filter((e3) => e3 !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
        var zJ = [Ij, QM, fV, IV, bW, WG, { languages: UJ, printers: { yaml: WJ }, options: qJ, parsers: void 0 }];
        const { version: GJ } = n, HJ = XD, { getSupportInfo: JJ } = za, XJ = EE, YJ = zJ, KJ = Zc;
        function QJ(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var n2 = arguments.length, r2 = new Array(n2), o2 = 0; o2 < n2; o2++)
              r2[o2] = arguments[o2];
            const i2 = r2[t2] || {}, u2 = i2.plugins || [];
            return r2[t2] = Object.assign(Object.assign({}, i2), {}, { plugins: [...YJ, ...Array.isArray(u2) ? u2 : Object.values(u2)] }), e2(...r2);
          };
        }
        const ZJ = QJ(HJ.formatWithCursor);
        var eX = { formatWithCursor: ZJ, format: (e2, t2) => ZJ(e2, t2).formatted, check(e2, t2) {
          const { formatted: n2 } = ZJ(e2, t2);
          return n2 === e2;
        }, doc: KJ, getSupportInfo: QJ(JJ, 0), version: GJ, util: XJ, __debug: { parse: QJ(HJ.parse), formatAST: QJ(HJ.formatAST), formatDoc: QJ(HJ.formatDoc), printToDoc: QJ(HJ.printToDoc), printDocToString: QJ(HJ.printDocToString) } };
        return eX;
      });
    }
  });

  // ../../node_modules/prettier/parser-babel.js
  var require_parser_babel = __commonJS({
    "../../node_modules/prettier/parser-babel.js"(exports, module) {
      !function(t, e) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : ((t = typeof globalThis != "undefined" ? globalThis : t || self).prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e());
      }(exports, function() {
        "use strict";
        var t = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
        function e(t2) {
          return t2 && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var s = function(t2) {
          return t2 && t2.Math == Math && t2;
        }, r = s(typeof globalThis == "object" && globalThis) || s(typeof window == "object" && window) || s(typeof self == "object" && self) || s(typeof t == "object" && t) || function() {
          return this;
        }() || Function("return this")(), i = {}, n = function(t2) {
          try {
            return !!t2();
          } catch (t3) {
            return true;
          }
        }, a = !n(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        }), o = Function.prototype.call, u = o.bind ? o.bind(o) : function() {
          return o.apply(o, arguments);
        }, h = {}, p = {}.propertyIsEnumerable, c = Object.getOwnPropertyDescriptor, l = c && !p.call({ 1: 2 }, 1);
        h.f = l ? function(t2) {
          var e2 = c(this, t2);
          return !!e2 && e2.enumerable;
        } : p;
        var d, D, m = function(t2, e2) {
          return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
        }, f = Function.prototype, y = f.bind, E = f.call, A = y && y.bind(E), C = y ? function(t2) {
          return t2 && A(E, t2);
        } : function(t2) {
          return t2 && function() {
            return E.apply(t2, arguments);
          };
        }, x = C, F = x({}.toString), g = x("".slice), P = function(t2) {
          return g(F(t2), 8, -1);
        }, T = C, b = n, S = P, w = r.Object, B = T("".split), N = b(function() {
          return !w("z").propertyIsEnumerable(0);
        }) ? function(t2) {
          return S(t2) == "String" ? B(t2, "") : w(t2);
        } : w, I = r.TypeError, v = function(t2) {
          if (t2 == null)
            throw I("Can't call method on " + t2);
          return t2;
        }, k = N, L = v, O = function(t2) {
          return k(L(t2));
        }, M = function(t2) {
          return typeof t2 == "function";
        }, R = M, j = function(t2) {
          return typeof t2 == "object" ? t2 !== null : R(t2);
        }, U = r, _ = M, z = function(t2) {
          return _(t2) ? t2 : void 0;
        }, H = function(t2, e2) {
          return arguments.length < 2 ? z(U[t2]) : U[t2] && U[t2][e2];
        }, V = C({}.isPrototypeOf), q = H("navigator", "userAgent") || "", W = r, K = q, G = W.process, X = W.Deno, J = G && G.versions || X && X.version, $ = J && J.v8;
        $ && (D = (d = $.split("."))[0] > 0 && d[0] < 4 ? 1 : +(d[0] + d[1])), !D && K && (!(d = K.match(/Edge\/(\d+)/)) || d[1] >= 74) && (d = K.match(/Chrome\/(\d+)/)) && (D = +d[1]);
        var Y = D, Q = Y, Z = n, tt = !!Object.getOwnPropertySymbols && !Z(function() {
          var t2 = Symbol();
          return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && Q && Q < 41;
        }), et = tt && !Symbol.sham && typeof Symbol.iterator == "symbol", st = H, rt = M, it = V, nt = et, at = r.Object, ot = nt ? function(t2) {
          return typeof t2 == "symbol";
        } : function(t2) {
          var e2 = st("Symbol");
          return rt(e2) && it(e2.prototype, at(t2));
        }, ut = r.String, ht = function(t2) {
          try {
            return ut(t2);
          } catch (t3) {
            return "Object";
          }
        }, pt = M, ct = ht, lt = r.TypeError, dt = function(t2) {
          if (pt(t2))
            return t2;
          throw lt(ct(t2) + " is not a function");
        }, Dt = dt, mt = function(t2, e2) {
          var s2 = t2[e2];
          return s2 == null ? void 0 : Dt(s2);
        }, ft = u, yt = M, Et = j, At = r.TypeError, Ct = { exports: {} }, xt = r, Ft = Object.defineProperty, gt = function(t2, e2) {
          try {
            Ft(xt, t2, { value: e2, configurable: true, writable: true });
          } catch (s2) {
            xt[t2] = e2;
          }
          return e2;
        }, Pt = gt, Tt = "__core-js_shared__", bt = r[Tt] || Pt(Tt, {}), St = bt;
        (Ct.exports = function(t2, e2) {
          return St[t2] || (St[t2] = e2 !== void 0 ? e2 : {});
        })("versions", []).push({ version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
        var wt = v, Bt = r.Object, Nt = function(t2) {
          return Bt(wt(t2));
        }, It = Nt, vt = C({}.hasOwnProperty), kt = Object.hasOwn || function(t2, e2) {
          return vt(It(t2), e2);
        }, Lt = C, Ot = 0, Mt = Math.random(), Rt = Lt(1 .toString), jt = function(t2) {
          return "Symbol(" + (t2 === void 0 ? "" : t2) + ")_" + Rt(++Ot + Mt, 36);
        }, Ut = r, _t = Ct.exports, zt = kt, Ht = jt, Vt = tt, qt = et, Wt = _t("wks"), Kt = Ut.Symbol, Gt = Kt && Kt.for, Xt = qt ? Kt : Kt && Kt.withoutSetter || Ht, Jt = function(t2) {
          if (!zt(Wt, t2) || !Vt && typeof Wt[t2] != "string") {
            var e2 = "Symbol." + t2;
            Vt && zt(Kt, t2) ? Wt[t2] = Kt[t2] : Wt[t2] = qt && Gt ? Gt(e2) : Xt(e2);
          }
          return Wt[t2];
        }, $t = u, Yt = j, Qt = ot, Zt = mt, te = function(t2, e2) {
          var s2, r2;
          if (e2 === "string" && yt(s2 = t2.toString) && !Et(r2 = ft(s2, t2)))
            return r2;
          if (yt(s2 = t2.valueOf) && !Et(r2 = ft(s2, t2)))
            return r2;
          if (e2 !== "string" && yt(s2 = t2.toString) && !Et(r2 = ft(s2, t2)))
            return r2;
          throw At("Can't convert object to primitive value");
        }, ee = Jt, se = r.TypeError, re = ee("toPrimitive"), ie = function(t2, e2) {
          if (!Yt(t2) || Qt(t2))
            return t2;
          var s2, r2 = Zt(t2, re);
          if (r2) {
            if (e2 === void 0 && (e2 = "default"), s2 = $t(r2, t2, e2), !Yt(s2) || Qt(s2))
              return s2;
            throw se("Can't convert object to primitive value");
          }
          return e2 === void 0 && (e2 = "number"), te(t2, e2);
        }, ne = ot, ae = function(t2) {
          var e2 = ie(t2, "string");
          return ne(e2) ? e2 : e2 + "";
        }, oe = j, ue = r.document, he = oe(ue) && oe(ue.createElement), pe = function(t2) {
          return he ? ue.createElement(t2) : {};
        }, ce = !a && !n(function() {
          return Object.defineProperty(pe("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        }), le = a, de = u, De = h, me = m, fe = O, ye = ae, Ee = kt, Ae = ce, Ce = Object.getOwnPropertyDescriptor;
        i.f = le ? Ce : function(t2, e2) {
          if (t2 = fe(t2), e2 = ye(e2), Ae)
            try {
              return Ce(t2, e2);
            } catch (t3) {
            }
          if (Ee(t2, e2))
            return me(!de(De.f, t2, e2), t2[e2]);
        };
        var xe = {}, Fe = r, ge = j, Pe = Fe.String, Te = Fe.TypeError, be = function(t2) {
          if (ge(t2))
            return t2;
          throw Te(Pe(t2) + " is not an object");
        }, Se = a, we = ce, Be = be, Ne = ae, Ie = r.TypeError, ve = Object.defineProperty;
        xe.f = Se ? ve : function(t2, e2, s2) {
          if (Be(t2), e2 = Ne(e2), Be(s2), we)
            try {
              return ve(t2, e2, s2);
            } catch (t3) {
            }
          if ("get" in s2 || "set" in s2)
            throw Ie("Accessors not supported");
          return "value" in s2 && (t2[e2] = s2.value), t2;
        };
        var ke = xe, Le = m, Oe = a ? function(t2, e2, s2) {
          return ke.f(t2, e2, Le(1, s2));
        } : function(t2, e2, s2) {
          return t2[e2] = s2, t2;
        }, Me = { exports: {} }, Re = M, je = bt, Ue = C(Function.toString);
        Re(je.inspectSource) || (je.inspectSource = function(t2) {
          return Ue(t2);
        });
        var _e, ze, He, Ve = je.inspectSource, qe = M, We = Ve, Ke = r.WeakMap, Ge = qe(Ke) && /native code/.test(We(Ke)), Xe = Ct.exports, Je = jt, $e = Xe("keys"), Ye = {}, Qe = Ge, Ze = r, ts = C, es = j, ss = Oe, rs = kt, is = bt, ns = function(t2) {
          return $e[t2] || ($e[t2] = Je(t2));
        }, as = Ye, os = "Object already initialized", us = Ze.TypeError, hs = Ze.WeakMap;
        if (Qe || is.state) {
          var ps = is.state || (is.state = new hs()), cs = ts(ps.get), ls = ts(ps.has), ds = ts(ps.set);
          _e = function(t2, e2) {
            if (ls(ps, t2))
              throw new us(os);
            return e2.facade = t2, ds(ps, t2, e2), e2;
          }, ze = function(t2) {
            return cs(ps, t2) || {};
          }, He = function(t2) {
            return ls(ps, t2);
          };
        } else {
          var Ds = ns("state");
          as[Ds] = true, _e = function(t2, e2) {
            if (rs(t2, Ds))
              throw new us(os);
            return e2.facade = t2, ss(t2, Ds, e2), e2;
          }, ze = function(t2) {
            return rs(t2, Ds) ? t2[Ds] : {};
          }, He = function(t2) {
            return rs(t2, Ds);
          };
        }
        var ms = { set: _e, get: ze, has: He, enforce: function(t2) {
          return He(t2) ? ze(t2) : _e(t2, {});
        }, getterFor: function(t2) {
          return function(e2) {
            var s2;
            if (!es(e2) || (s2 = ze(e2)).type !== t2)
              throw us("Incompatible receiver, " + t2 + " required");
            return s2;
          };
        } }, fs = a, ys = kt, Es = Function.prototype, As = fs && Object.getOwnPropertyDescriptor, Cs = ys(Es, "name"), xs = Cs && function() {
        }.name === "something", Fs = Cs && (!fs || fs && As(Es, "name").configurable), gs = r, Ps = M, Ts = kt, bs = Oe, Ss = gt, ws = Ve, Bs = { EXISTS: Cs, PROPER: xs, CONFIGURABLE: Fs }.CONFIGURABLE, Ns = ms.get, Is = ms.enforce, vs = String(String).split("String");
        (Me.exports = function(t2, e2, s2, r2) {
          var i2, n2 = !!r2 && !!r2.unsafe, a2 = !!r2 && !!r2.enumerable, o2 = !!r2 && !!r2.noTargetGet, u2 = r2 && r2.name !== void 0 ? r2.name : e2;
          Ps(s2) && (String(u2).slice(0, 7) === "Symbol(" && (u2 = "[" + String(u2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Ts(s2, "name") || Bs && s2.name !== u2) && bs(s2, "name", u2), (i2 = Is(s2)).source || (i2.source = vs.join(typeof u2 == "string" ? u2 : ""))), t2 !== gs ? (n2 ? !o2 && t2[e2] && (a2 = true) : delete t2[e2], a2 ? t2[e2] = s2 : bs(t2, e2, s2)) : a2 ? t2[e2] = s2 : Ss(e2, s2);
        })(Function.prototype, "toString", function() {
          return Ps(this) && Ns(this).source || ws(this);
        });
        var ks = {}, Ls = Math.ceil, Os = Math.floor, Ms = function(t2) {
          var e2 = +t2;
          return e2 != e2 || e2 === 0 ? 0 : (e2 > 0 ? Os : Ls)(e2);
        }, Rs = Ms, js = Math.max, Us = Math.min, _s = Ms, zs = Math.min, Hs = function(t2) {
          return t2 > 0 ? zs(_s(t2), 9007199254740991) : 0;
        }, Vs = function(t2) {
          return Hs(t2.length);
        }, qs = O, Ws = function(t2, e2) {
          var s2 = Rs(t2);
          return s2 < 0 ? js(s2 + e2, 0) : Us(s2, e2);
        }, Ks = Vs, Gs = function(t2) {
          return function(e2, s2, r2) {
            var i2, n2 = qs(e2), a2 = Ks(n2), o2 = Ws(r2, a2);
            if (t2 && s2 != s2) {
              for (; a2 > o2; )
                if ((i2 = n2[o2++]) != i2)
                  return true;
            } else
              for (; a2 > o2; o2++)
                if ((t2 || o2 in n2) && n2[o2] === s2)
                  return t2 || o2 || 0;
            return !t2 && -1;
          };
        }, Xs = { includes: Gs(true), indexOf: Gs(false) }, Js = kt, $s = O, Ys = Xs.indexOf, Qs = Ye, Zs = C([].push), tr = function(t2, e2) {
          var s2, r2 = $s(t2), i2 = 0, n2 = [];
          for (s2 in r2)
            !Js(Qs, s2) && Js(r2, s2) && Zs(n2, s2);
          for (; e2.length > i2; )
            Js(r2, s2 = e2[i2++]) && (~Ys(n2, s2) || Zs(n2, s2));
          return n2;
        }, er = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype");
        ks.f = Object.getOwnPropertyNames || function(t2) {
          return tr(t2, er);
        };
        var sr = {};
        sr.f = Object.getOwnPropertySymbols;
        var rr = H, ir = ks, nr = sr, ar = be, or = C([].concat), ur = rr("Reflect", "ownKeys") || function(t2) {
          var e2 = ir.f(ar(t2)), s2 = nr.f;
          return s2 ? or(e2, s2(t2)) : e2;
        }, hr = kt, pr = ur, cr = i, lr = xe, dr = n, Dr = M, mr = /#|\.prototype\./, fr = function(t2, e2) {
          var s2 = Er[yr(t2)];
          return s2 == Cr || s2 != Ar && (Dr(e2) ? dr(e2) : !!e2);
        }, yr = fr.normalize = function(t2) {
          return String(t2).replace(mr, ".").toLowerCase();
        }, Er = fr.data = {}, Ar = fr.NATIVE = "N", Cr = fr.POLYFILL = "P", xr = fr, Fr = r, gr = i.f, Pr = Oe, Tr = Me.exports, br = gt, Sr = function(t2, e2) {
          for (var s2 = pr(e2), r2 = lr.f, i2 = cr.f, n2 = 0; n2 < s2.length; n2++) {
            var a2 = s2[n2];
            hr(t2, a2) || r2(t2, a2, i2(e2, a2));
          }
        }, wr = xr, Br = function(t2, e2) {
          var s2, r2, i2, n2, a2, o2 = t2.target, u2 = t2.global, h2 = t2.stat;
          if (s2 = u2 ? Fr : h2 ? Fr[o2] || br(o2, {}) : (Fr[o2] || {}).prototype)
            for (r2 in e2) {
              if (n2 = e2[r2], i2 = t2.noTargetGet ? (a2 = gr(s2, r2)) && a2.value : s2[r2], !wr(u2 ? r2 : o2 + (h2 ? "." : "#") + r2, t2.forced) && i2 !== void 0) {
                if (typeof n2 == typeof i2)
                  continue;
                Sr(n2, i2);
              }
              (t2.sham || i2 && i2.sham) && Pr(n2, "sham", true), Tr(s2, r2, n2, t2);
            }
        }, Nr = P, Ir = Array.isArray || function(t2) {
          return Nr(t2) == "Array";
        }, vr = dt, kr = C(C.bind), Lr = function(t2, e2) {
          return vr(t2), e2 === void 0 ? t2 : kr ? kr(t2, e2) : function() {
            return t2.apply(e2, arguments);
          };
        }, Or = Ir, Mr = Vs, Rr = Lr, jr = r.TypeError, Ur = function(t2, e2, s2, r2, i2, n2, a2, o2) {
          for (var u2, h2, p2 = i2, c2 = 0, l2 = !!a2 && Rr(a2, o2); c2 < r2; ) {
            if (c2 in s2) {
              if (u2 = l2 ? l2(s2[c2], c2, e2) : s2[c2], n2 > 0 && Or(u2))
                h2 = Mr(u2), p2 = Ur(t2, e2, u2, h2, p2, n2 - 1) - 1;
              else {
                if (p2 >= 9007199254740991)
                  throw jr("Exceed the acceptable array length");
                t2[p2] = u2;
              }
              p2++;
            }
            c2++;
          }
          return p2;
        }, _r = Ur, zr = {};
        zr[Jt("toStringTag")] = "z";
        var Hr = r, Vr = String(zr) === "[object z]", qr = M, Wr = P, Kr = Jt("toStringTag"), Gr = Hr.Object, Xr = Wr(function() {
          return arguments;
        }()) == "Arguments", Jr = Vr ? Wr : function(t2) {
          var e2, s2, r2;
          return t2 === void 0 ? "Undefined" : t2 === null ? "Null" : typeof (s2 = function(t3, e3) {
            try {
              return t3[e3];
            } catch (t4) {
            }
          }(e2 = Gr(t2), Kr)) == "string" ? s2 : Xr ? Wr(e2) : (r2 = Wr(e2)) == "Object" && qr(e2.callee) ? "Arguments" : r2;
        }, $r = C, Yr = n, Qr = M, Zr = Jr, ti = Ve, ei = function() {
        }, si = [], ri = H("Reflect", "construct"), ii = /^\s*(?:class|function)\b/, ni = $r(ii.exec), ai = !ii.exec(ei), oi = function(t2) {
          if (!Qr(t2))
            return false;
          try {
            return ri(ei, si, t2), true;
          } catch (t3) {
            return false;
          }
        }, ui = !ri || Yr(function() {
          var t2;
          return oi(oi.call) || !oi(Object) || !oi(function() {
            t2 = true;
          }) || t2;
        }) ? function(t2) {
          if (!Qr(t2))
            return false;
          switch (Zr(t2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          return ai || !!ni(ii, ti(t2));
        } : oi, hi = r, pi = Ir, ci = ui, li = j, di = Jt("species"), Di = hi.Array, mi = function(t2) {
          var e2;
          return pi(t2) && (e2 = t2.constructor, (ci(e2) && (e2 === Di || pi(e2.prototype)) || li(e2) && (e2 = e2[di]) === null) && (e2 = void 0)), e2 === void 0 ? Di : e2;
        }, fi = _r, yi = dt, Ei = Nt, Ai = Vs, Ci = function(t2, e2) {
          return new (mi(t2))(e2 === 0 ? 0 : e2);
        };
        Br({ target: "Array", proto: true }, { flatMap: function(t2) {
          var e2, s2 = Ei(this), r2 = Ai(s2);
          return yi(t2), (e2 = Ci(s2, 0)).length = fi(e2, s2, s2, r2, 0, 1, t2, arguments.length > 1 ? arguments[1] : void 0), e2;
        } });
        var xi = function() {
          let t2;
          for (var e2 = arguments.length, s2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            s2[r2] = arguments[r2];
          for (const [e3, r3] of s2.entries())
            try {
              return { result: r3() };
            } catch (s3) {
              e3 === 0 && (t2 = s3);
            }
          return { error: t2 };
        }, Fi = { exports: {} };
        const gi = function() {
          let { onlyFirst: t2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const e2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(e2, t2 ? void 0 : "g");
        };
        var Pi = { exports: {} };
        const Ti = (t2) => !Number.isNaN(t2) && (t2 >= 4352 && (t2 <= 4447 || t2 === 9001 || t2 === 9002 || 11904 <= t2 && t2 <= 12871 && t2 !== 12351 || 12880 <= t2 && t2 <= 19903 || 19968 <= t2 && t2 <= 42182 || 43360 <= t2 && t2 <= 43388 || 44032 <= t2 && t2 <= 55203 || 63744 <= t2 && t2 <= 64255 || 65040 <= t2 && t2 <= 65049 || 65072 <= t2 && t2 <= 65131 || 65281 <= t2 && t2 <= 65376 || 65504 <= t2 && t2 <= 65510 || 110592 <= t2 && t2 <= 110593 || 127488 <= t2 && t2 <= 127569 || 131072 <= t2 && t2 <= 262141));
        Pi.exports = Ti, Pi.exports.default = Ti;
        const bi = (t2) => typeof t2 == "string" ? t2.replace(gi(), "") : t2, Si = Pi.exports, wi = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        }, Bi = (t2) => {
          if (typeof t2 != "string" || t2.length === 0)
            return 0;
          if ((t2 = bi(t2)).length === 0)
            return 0;
          t2 = t2.replace(wi(), "  ");
          let e2 = 0;
          for (let s2 = 0; s2 < t2.length; s2++) {
            const r2 = t2.codePointAt(s2);
            r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, e2 += Si(r2) ? 2 : 1));
          }
          return e2;
        };
        Fi.exports = Bi, Fi.exports.default = Bi;
        var Ni = (t2) => t2[t2.length - 1];
        function Ii(t2, e2) {
          if (t2 == null)
            return {};
          var s2, r2, i2 = function(t3, e3) {
            if (t3 == null)
              return {};
            var s3, r3, i3 = {}, n3 = Object.keys(t3);
            for (r3 = 0; r3 < n3.length; r3++)
              s3 = n3[r3], e3.indexOf(s3) >= 0 || (i3[s3] = t3[s3]);
            return i3;
          }(t2, e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(t2);
            for (r2 = 0; r2 < n2.length; r2++)
              s2 = n2[r2], e2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(t2, s2) && (i2[s2] = t2[s2]);
          }
          return i2;
        }
        function vi(t2, e2) {
          return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, { raw: { value: Object.freeze(e2) } }));
        }
        var ki = Jr, Li = r.String, Oi = C([].slice), Mi = Math.floor, Ri = function(t2, e2) {
          var s2 = t2.length, r2 = Mi(s2 / 2);
          return s2 < 8 ? ji(t2, e2) : Ui(t2, Ri(Oi(t2, 0, r2), e2), Ri(Oi(t2, r2), e2), e2);
        }, ji = function(t2, e2) {
          for (var s2, r2, i2 = t2.length, n2 = 1; n2 < i2; ) {
            for (r2 = n2, s2 = t2[n2]; r2 && e2(t2[r2 - 1], s2) > 0; )
              t2[r2] = t2[--r2];
            r2 !== n2++ && (t2[r2] = s2);
          }
          return t2;
        }, Ui = function(t2, e2, s2, r2) {
          for (var i2 = e2.length, n2 = s2.length, a2 = 0, o2 = 0; a2 < i2 || o2 < n2; )
            t2[a2 + o2] = a2 < i2 && o2 < n2 ? r2(e2[a2], s2[o2]) <= 0 ? e2[a2++] : s2[o2++] : a2 < i2 ? e2[a2++] : s2[o2++];
          return t2;
        }, _i = Ri, zi = n, Hi = q.match(/firefox\/(\d+)/i), Vi = !!Hi && +Hi[1], qi = /MSIE|Trident/.test(q), Wi = q.match(/AppleWebKit\/(\d+)\./), Ki = !!Wi && +Wi[1], Gi = Br, Xi = C, Ji = dt, $i = Nt, Yi = Vs, Qi = function(t2) {
          if (ki(t2) === "Symbol")
            throw TypeError("Cannot convert a Symbol value to a string");
          return Li(t2);
        }, Zi = n, tn = _i, en = function(t2, e2) {
          var s2 = [][t2];
          return !!s2 && zi(function() {
            s2.call(null, e2 || function() {
              throw 1;
            }, 1);
          });
        }, sn = Vi, rn = qi, nn = Y, an = Ki, on = [], un = Xi(on.sort), hn = Xi(on.push), pn = Zi(function() {
          on.sort(void 0);
        }), cn = Zi(function() {
          on.sort(null);
        }), ln = en("sort"), dn = !Zi(function() {
          if (nn)
            return nn < 70;
          if (!(sn && sn > 3)) {
            if (rn)
              return true;
            if (an)
              return an < 603;
            var t2, e2, s2, r2, i2 = "";
            for (t2 = 65; t2 < 76; t2++) {
              switch (e2 = String.fromCharCode(t2), t2) {
                case 66:
                case 69:
                case 70:
                case 72:
                  s2 = 3;
                  break;
                case 68:
                case 71:
                  s2 = 4;
                  break;
                default:
                  s2 = 2;
              }
              for (r2 = 0; r2 < 47; r2++)
                on.push({ k: e2 + r2, v: s2 });
            }
            for (on.sort(function(t3, e3) {
              return e3.v - t3.v;
            }), r2 = 0; r2 < on.length; r2++)
              e2 = on[r2].k.charAt(0), i2.charAt(i2.length - 1) !== e2 && (i2 += e2);
            return i2 !== "DGBEFHACIJK";
          }
        });
        Gi({ target: "Array", proto: true, forced: pn || !cn || !ln || !dn }, { sort: function(t2) {
          t2 !== void 0 && Ji(t2);
          var e2 = $i(this);
          if (dn)
            return t2 === void 0 ? un(e2) : un(e2, t2);
          var s2, r2, i2 = [], n2 = Yi(e2);
          for (r2 = 0; r2 < n2; r2++)
            r2 in e2 && hn(i2, e2[r2]);
          for (tn(i2, function(t3) {
            return function(e3, s3) {
              return s3 === void 0 ? -1 : e3 === void 0 ? 1 : t3 !== void 0 ? +t3(e3, s3) || 0 : Qi(e3) > Qi(s3) ? 1 : -1;
            };
          }(t2)), s2 = i2.length, r2 = 0; r2 < s2; )
            e2[r2] = i2[r2++];
          for (; r2 < n2; )
            delete e2[r2++];
          return e2;
        } });
        var Dn = {}, mn = Dn, fn = Jt("iterator"), yn = Array.prototype, En = Jr, An = mt, Cn = Dn, xn = Jt("iterator"), Fn = function(t2) {
          if (t2 != null)
            return An(t2, xn) || An(t2, "@@iterator") || Cn[En(t2)];
        }, gn = u, Pn = dt, Tn = be, bn = ht, Sn = Fn, wn = r.TypeError, Bn = u, Nn = be, In = mt, vn = Lr, kn = u, Ln = be, On = ht, Mn = function(t2) {
          return t2 !== void 0 && (mn.Array === t2 || yn[fn] === t2);
        }, Rn = Vs, jn = V, Un = function(t2, e2) {
          var s2 = arguments.length < 2 ? Sn(t2) : e2;
          if (Pn(s2))
            return Tn(gn(s2, t2));
          throw wn(bn(t2) + " is not iterable");
        }, _n = Fn, zn = function(t2, e2, s2) {
          var r2, i2;
          Nn(t2);
          try {
            if (!(r2 = In(t2, "return"))) {
              if (e2 === "throw")
                throw s2;
              return s2;
            }
            r2 = Bn(r2, t2);
          } catch (t3) {
            i2 = true, r2 = t3;
          }
          if (e2 === "throw")
            throw s2;
          if (i2)
            throw r2;
          return Nn(r2), s2;
        }, Hn = r.TypeError, Vn = function(t2, e2) {
          this.stopped = t2, this.result = e2;
        }, qn = Vn.prototype, Wn = ae, Kn = xe, Gn = m, Xn = function(t2, e2, s2) {
          var r2, i2, n2, a2, o2, u2, h2, p2 = s2 && s2.that, c2 = !(!s2 || !s2.AS_ENTRIES), l2 = !(!s2 || !s2.IS_ITERATOR), d2 = !(!s2 || !s2.INTERRUPTED), D2 = vn(e2, p2), m2 = function(t3) {
            return r2 && zn(r2, "normal", t3), new Vn(true, t3);
          }, f2 = function(t3) {
            return c2 ? (Ln(t3), d2 ? D2(t3[0], t3[1], m2) : D2(t3[0], t3[1])) : d2 ? D2(t3, m2) : D2(t3);
          };
          if (l2)
            r2 = t2;
          else {
            if (!(i2 = _n(t2)))
              throw Hn(On(t2) + " is not iterable");
            if (Mn(i2)) {
              for (n2 = 0, a2 = Rn(t2); a2 > n2; n2++)
                if ((o2 = f2(t2[n2])) && jn(qn, o2))
                  return o2;
              return new Vn(false);
            }
            r2 = Un(t2, i2);
          }
          for (u2 = r2.next; !(h2 = kn(u2, r2)).done; ) {
            try {
              o2 = f2(h2.value);
            } catch (t3) {
              zn(r2, "throw", t3);
            }
            if (typeof o2 == "object" && o2 && jn(qn, o2))
              return o2;
          }
          return new Vn(false);
        }, Jn = function(t2, e2, s2) {
          var r2 = Wn(e2);
          r2 in t2 ? Kn.f(t2, r2, Gn(0, s2)) : t2[r2] = s2;
        };
        Br({ target: "Object", stat: true }, { fromEntries: function(t2) {
          var e2 = {};
          return Xn(t2, function(t3, s2) {
            Jn(e2, t3, s2);
          }, { AS_ENTRIES: true }), e2;
        } });
        var $n = $n !== void 0 ? $n : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
        function Yn() {
          throw new Error("setTimeout has not been defined");
        }
        function Qn() {
          throw new Error("clearTimeout has not been defined");
        }
        var Zn = Yn, ta = Qn;
        function ea(t2) {
          if (Zn === setTimeout)
            return setTimeout(t2, 0);
          if ((Zn === Yn || !Zn) && setTimeout)
            return Zn = setTimeout, setTimeout(t2, 0);
          try {
            return Zn(t2, 0);
          } catch (e2) {
            try {
              return Zn.call(null, t2, 0);
            } catch (e3) {
              return Zn.call(this, t2, 0);
            }
          }
        }
        typeof $n.setTimeout == "function" && (Zn = setTimeout), typeof $n.clearTimeout == "function" && (ta = clearTimeout);
        var sa, ra = [], ia = false, na = -1;
        function aa() {
          ia && sa && (ia = false, sa.length ? ra = sa.concat(ra) : na = -1, ra.length && oa());
        }
        function oa() {
          if (!ia) {
            var t2 = ea(aa);
            ia = true;
            for (var e2 = ra.length; e2; ) {
              for (sa = ra, ra = []; ++na < e2; )
                sa && sa[na].run();
              na = -1, e2 = ra.length;
            }
            sa = null, ia = false, function(t3) {
              if (ta === clearTimeout)
                return clearTimeout(t3);
              if ((ta === Qn || !ta) && clearTimeout)
                return ta = clearTimeout, clearTimeout(t3);
              try {
                ta(t3);
              } catch (e3) {
                try {
                  return ta.call(null, t3);
                } catch (e4) {
                  return ta.call(this, t3);
                }
              }
            }(t2);
          }
        }
        function ua(t2, e2) {
          this.fun = t2, this.array = e2;
        }
        ua.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        function ha() {
        }
        var pa = ha, ca = ha, la = ha, da = ha, Da = ha, ma = ha, fa = ha;
        var ya = $n.performance || {}, Ea = ya.now || ya.mozNow || ya.msNow || ya.oNow || ya.webkitNow || function() {
          return new Date().getTime();
        };
        var Aa = new Date();
        var Ca = { nextTick: function(t2) {
          var e2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var s2 = 1; s2 < arguments.length; s2++)
              e2[s2 - 1] = arguments[s2];
          ra.push(new ua(t2, e2)), ra.length !== 1 || ia || ea(oa);
        }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: pa, addListener: ca, once: la, off: da, removeListener: Da, removeAllListeners: ma, emit: fa, binding: function(t2) {
          throw new Error("process.binding is not supported");
        }, cwd: function() {
          return "/";
        }, chdir: function(t2) {
          throw new Error("process.chdir is not supported");
        }, umask: function() {
          return 0;
        }, hrtime: function(t2) {
          var e2 = 1e-3 * Ea.call(ya), s2 = Math.floor(e2), r2 = Math.floor(e2 % 1 * 1e9);
          return t2 && (s2 -= t2[0], (r2 -= t2[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
        }, platform: "browser", release: {}, config: {}, uptime: function() {
          return (new Date() - Aa) / 1e3;
        } }, xa = Ca;
        const Fa = typeof xa == "object" && xa.env && xa.env.NODE_DEBUG && /\bsemver\b/i.test(xa.env.NODE_DEBUG) ? function() {
          for (var t2 = arguments.length, e2 = new Array(t2), s2 = 0; s2 < t2; s2++)
            e2[s2] = arguments[s2];
          return console.error("SEMVER", ...e2);
        } : () => {
        };
        var ga = Fa;
        var Pa = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, Ta = { exports: {} };
        !function(t2, e2) {
          const { MAX_SAFE_COMPONENT_LENGTH: s2 } = Pa, r2 = ga, i2 = (e2 = t2.exports = {}).re = [], n2 = e2.src = [], a2 = e2.t = {};
          let o2 = 0;
          const u2 = (t3, e3, s3) => {
            const u3 = o2++;
            r2(u3, e3), a2[t3] = u3, n2[u3] = e3, i2[u3] = new RegExp(e3, s3 ? "g" : void 0);
          };
          u2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), u2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), u2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), u2("MAINVERSION", "(".concat(n2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(n2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(n2[a2.NUMERICIDENTIFIER], ")")), u2("MAINVERSIONLOOSE", "(".concat(n2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(n2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(n2[a2.NUMERICIDENTIFIERLOOSE], ")")), u2("PRERELEASEIDENTIFIER", "(?:".concat(n2[a2.NUMERICIDENTIFIER], "|").concat(n2[a2.NONNUMERICIDENTIFIER], ")")), u2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(n2[a2.NUMERICIDENTIFIERLOOSE], "|").concat(n2[a2.NONNUMERICIDENTIFIER], ")")), u2("PRERELEASE", "(?:-(".concat(n2[a2.PRERELEASEIDENTIFIER], "(?:\\.").concat(n2[a2.PRERELEASEIDENTIFIER], ")*))")), u2("PRERELEASELOOSE", "(?:-?(".concat(n2[a2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(n2[a2.PRERELEASEIDENTIFIERLOOSE], ")*))")), u2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), u2("BUILD", "(?:\\+(".concat(n2[a2.BUILDIDENTIFIER], "(?:\\.").concat(n2[a2.BUILDIDENTIFIER], ")*))")), u2("FULLPLAIN", "v?".concat(n2[a2.MAINVERSION]).concat(n2[a2.PRERELEASE], "?").concat(n2[a2.BUILD], "?")), u2("FULL", "^".concat(n2[a2.FULLPLAIN], "$")), u2("LOOSEPLAIN", "[v=\\s]*".concat(n2[a2.MAINVERSIONLOOSE]).concat(n2[a2.PRERELEASELOOSE], "?").concat(n2[a2.BUILD], "?")), u2("LOOSE", "^".concat(n2[a2.LOOSEPLAIN], "$")), u2("GTLT", "((?:<|>)?=?)"), u2("XRANGEIDENTIFIERLOOSE", "".concat(n2[a2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), u2("XRANGEIDENTIFIER", "".concat(n2[a2.NUMERICIDENTIFIER], "|x|X|\\*")), u2("XRANGEPLAIN", "[v=\\s]*(".concat(n2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(n2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(n2[a2.XRANGEIDENTIFIER], ")") + "(?:".concat(n2[a2.PRERELEASE], ")?").concat(n2[a2.BUILD], "?") + ")?)?"), u2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(n2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(n2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(n2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(n2[a2.PRERELEASELOOSE], ")?").concat(n2[a2.BUILD], "?") + ")?)?"), u2("XRANGE", "^".concat(n2[a2.GTLT], "\\s*").concat(n2[a2.XRANGEPLAIN], "$")), u2("XRANGELOOSE", "^".concat(n2[a2.GTLT], "\\s*").concat(n2[a2.XRANGEPLAINLOOSE], "$")), u2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(s2, "})") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:$|[^\\d])"), u2("COERCERTL", n2[a2.COERCE], true), u2("LONETILDE", "(?:~>?)"), u2("TILDETRIM", "(\\s*)".concat(n2[a2.LONETILDE], "\\s+"), true), e2.tildeTrimReplace = "$1~", u2("TILDE", "^".concat(n2[a2.LONETILDE]).concat(n2[a2.XRANGEPLAIN], "$")), u2("TILDELOOSE", "^".concat(n2[a2.LONETILDE]).concat(n2[a2.XRANGEPLAINLOOSE], "$")), u2("LONECARET", "(?:\\^)"), u2("CARETTRIM", "(\\s*)".concat(n2[a2.LONECARET], "\\s+"), true), e2.caretTrimReplace = "$1^", u2("CARET", "^".concat(n2[a2.LONECARET]).concat(n2[a2.XRANGEPLAIN], "$")), u2("CARETLOOSE", "^".concat(n2[a2.LONECARET]).concat(n2[a2.XRANGEPLAINLOOSE], "$")), u2("COMPARATORLOOSE", "^".concat(n2[a2.GTLT], "\\s*(").concat(n2[a2.LOOSEPLAIN], ")$|^$")), u2("COMPARATOR", "^".concat(n2[a2.GTLT], "\\s*(").concat(n2[a2.FULLPLAIN], ")$|^$")), u2("COMPARATORTRIM", "(\\s*)".concat(n2[a2.GTLT], "\\s*(").concat(n2[a2.LOOSEPLAIN], "|").concat(n2[a2.XRANGEPLAIN], ")"), true), e2.comparatorTrimReplace = "$1$2$3", u2("HYPHENRANGE", "^\\s*(".concat(n2[a2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(n2[a2.XRANGEPLAIN], ")") + "\\s*$"), u2("HYPHENRANGELOOSE", "^\\s*(".concat(n2[a2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(n2[a2.XRANGEPLAINLOOSE], ")") + "\\s*$"), u2("STAR", "(<|>)?=?\\s*\\*"), u2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), u2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        }(Ta, Ta.exports);
        const ba = ["includePrerelease", "loose", "rtl"];
        var Sa = (t2) => t2 ? typeof t2 != "object" ? { loose: true } : ba.filter((e2) => t2[e2]).reduce((t3, e2) => (t3[e2] = true, t3), {}) : {};
        const wa = /^[0-9]+$/, Ba = (t2, e2) => {
          const s2 = wa.test(t2), r2 = wa.test(e2);
          return s2 && r2 && (t2 = +t2, e2 = +e2), t2 === e2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : t2 < e2 ? -1 : 1;
        };
        var Na = { compareIdentifiers: Ba, rcompareIdentifiers: (t2, e2) => Ba(e2, t2) };
        const Ia = ga, { MAX_LENGTH: va, MAX_SAFE_INTEGER: ka } = Pa, { re: La, t: Oa } = Ta.exports, Ma = Sa, { compareIdentifiers: Ra } = Na;
        class ja {
          constructor(t2, e2) {
            if (e2 = Ma(e2), t2 instanceof ja) {
              if (t2.loose === !!e2.loose && t2.includePrerelease === !!e2.includePrerelease)
                return t2;
              t2 = t2.version;
            } else if (typeof t2 != "string")
              throw new TypeError("Invalid Version: ".concat(t2));
            if (t2.length > va)
              throw new TypeError("version is longer than ".concat(va, " characters"));
            Ia("SemVer", t2, e2), this.options = e2, this.loose = !!e2.loose, this.includePrerelease = !!e2.includePrerelease;
            const s2 = t2.trim().match(e2.loose ? La[Oa.LOOSE] : La[Oa.FULL]);
            if (!s2)
              throw new TypeError("Invalid Version: ".concat(t2));
            if (this.raw = t2, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > ka || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > ka || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > ka || this.patch < 0)
              throw new TypeError("Invalid patch version");
            s2[4] ? this.prerelease = s2[4].split(".").map((t3) => {
              if (/^[0-9]+$/.test(t3)) {
                const e3 = +t3;
                if (e3 >= 0 && e3 < ka)
                  return e3;
              }
              return t3;
            }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
          }
          format() {
            return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
          }
          toString() {
            return this.version;
          }
          compare(t2) {
            if (Ia("SemVer.compare", this.version, this.options, t2), !(t2 instanceof ja)) {
              if (typeof t2 == "string" && t2 === this.version)
                return 0;
              t2 = new ja(t2, this.options);
            }
            return t2.version === this.version ? 0 : this.compareMain(t2) || this.comparePre(t2);
          }
          compareMain(t2) {
            return t2 instanceof ja || (t2 = new ja(t2, this.options)), Ra(this.major, t2.major) || Ra(this.minor, t2.minor) || Ra(this.patch, t2.patch);
          }
          comparePre(t2) {
            if (t2 instanceof ja || (t2 = new ja(t2, this.options)), this.prerelease.length && !t2.prerelease.length)
              return -1;
            if (!this.prerelease.length && t2.prerelease.length)
              return 1;
            if (!this.prerelease.length && !t2.prerelease.length)
              return 0;
            let e2 = 0;
            do {
              const s2 = this.prerelease[e2], r2 = t2.prerelease[e2];
              if (Ia("prerelease compare", e2, s2, r2), s2 === void 0 && r2 === void 0)
                return 0;
              if (r2 === void 0)
                return 1;
              if (s2 === void 0)
                return -1;
              if (s2 !== r2)
                return Ra(s2, r2);
            } while (++e2);
          }
          compareBuild(t2) {
            t2 instanceof ja || (t2 = new ja(t2, this.options));
            let e2 = 0;
            do {
              const s2 = this.build[e2], r2 = t2.build[e2];
              if (Ia("prerelease compare", e2, s2, r2), s2 === void 0 && r2 === void 0)
                return 0;
              if (r2 === void 0)
                return 1;
              if (s2 === void 0)
                return -1;
              if (s2 !== r2)
                return Ra(s2, r2);
            } while (++e2);
          }
          inc(t2, e2) {
            switch (t2) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e2);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e2);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", e2), this.inc("pre", e2);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", e2), this.inc("pre", e2);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let t3 = this.prerelease.length;
                  for (; --t3 >= 0; )
                    typeof this.prerelease[t3] == "number" && (this.prerelease[t3]++, t3 = -2);
                  t3 === -1 && this.prerelease.push(0);
                }
                e2 && (this.prerelease[0] === e2 ? isNaN(this.prerelease[1]) && (this.prerelease = [e2, 0]) : this.prerelease = [e2, 0]);
                break;
              default:
                throw new Error("invalid increment argument: ".concat(t2));
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        const Ua = ja;
        var _a = (t2, e2, s2) => new Ua(t2, s2).compare(new Ua(e2, s2));
        const za = _a;
        var Ha = (t2, e2, s2) => za(t2, e2, s2) < 0;
        const Va = _a;
        var qa, Wa, Ka, Ga, Xa, Ja, $a = (t2, e2, s2) => Va(t2, e2, s2) >= 0, Ya = { exports: {} };
        !function(t2, e2) {
          function s2() {
            for (var t3 = [], e3 = 0; e3 < arguments.length; e3++)
              t3[e3] = arguments[e3];
          }
          function r2() {
            return typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : { add: s2, delete: s2, get: s2, set: s2, has: function(t3) {
              return false;
            } };
          }
          Object.defineProperty(e2, "__esModule", { value: true }), e2.outdent = void 0;
          var i2 = Object.prototype.hasOwnProperty, n2 = function(t3, e3) {
            return i2.call(t3, e3);
          };
          function a2(t3, e3) {
            for (var s3 in e3)
              n2(e3, s3) && (t3[s3] = e3[s3]);
            return t3;
          }
          var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, p2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, c2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function l2(t3, e3, s3) {
            var r3 = 0, i3 = t3[0].match(p2);
            i3 && (r3 = i3[1].length);
            var n3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
            e3 && (t3 = t3.slice(1));
            var a3 = s3.newline, h3 = s3.trimLeadingNewline, c3 = s3.trimTrailingNewline, l3 = typeof a3 == "string", d3 = t3.length;
            return t3.map(function(t4, e4) {
              return t4 = t4.replace(n3, "$1"), e4 === 0 && h3 && (t4 = t4.replace(o2, "")), e4 === d3 - 1 && c3 && (t4 = t4.replace(u2, "")), l3 && (t4 = t4.replace(/\r\n|\n|\r/g, function(t5) {
                return a3;
              })), t4;
            });
          }
          function d2(t3, e3) {
            for (var s3 = "", r3 = 0, i3 = t3.length; r3 < i3; r3++)
              s3 += t3[r3], r3 < i3 - 1 && (s3 += e3[r3]);
            return s3;
          }
          function D2(t3) {
            return n2(t3, "raw") && n2(t3, "length");
          }
          var m2 = function t3(e3) {
            var s3 = r2(), i3 = r2(), n3 = a2(function r3(n4) {
              for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
                o3[u3 - 1] = arguments[u3];
              if (D2(n4)) {
                var p3 = n4, f2 = (o3[0] === r3 || o3[0] === m2) && c2.test(p3[0]) && h2.test(p3[1]), y2 = f2 ? i3 : s3, E2 = y2.get(p3);
                if (E2 || (E2 = l2(p3, f2, e3), y2.set(p3, E2)), o3.length === 0)
                  return E2[0];
                var A2 = d2(E2, f2 ? o3.slice(1) : o3);
                return A2;
              }
              return t3(a2(a2({}, e3), n4 || {}));
            }, { string: function(t4) {
              return l2([t4], false, e3)[0];
            } });
            return n3;
          }({ trimLeadingNewline: true, trimTrailingNewline: true });
          e2.outdent = m2, e2.default = m2;
          try {
            t2.exports = m2, Object.defineProperty(m2, "__esModule", { value: true }), m2.default = m2, m2.outdent = m2;
          } catch (t3) {
          }
        }(Ya, Ya.exports);
        const { outdent: Qa } = Ya.exports, Za = "Config", to = "Editor", eo = "Other", so = "Global", ro = "Special", io = { cursorOffset: { since: "1.4.0", category: ro, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Qa(qa || (qa = vi(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))), cliCategory: to }, endOfLine: { since: "1.15.0", category: so, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Qa(Wa || (Wa = vi(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]))) }] }, filepath: { since: "1.4.0", category: ro, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: eo, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: ro, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: eo }, parser: { since: "0.0.10", category: so, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (t2) => typeof t2 == "string" || typeof t2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: so, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t2) => typeof t2 == "string" || typeof t2 == "object", cliName: "plugin", cliCategory: Za }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: so, description: Qa(Ka || (Ka = vi(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))), exception: (t2) => typeof t2 == "string" || typeof t2 == "object", cliName: "plugin-search-dir", cliCategory: Za }, printWidth: { since: "0.0.0", category: so, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: ro, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Qa(Ga || (Ga = vi(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: to }, rangeStart: { since: "1.4.0", category: ro, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Qa(Xa || (Xa = vi(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: to }, requirePragma: { since: "1.7.0", category: ro, type: "boolean", default: false, description: Qa(Ja || (Ja = vi(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))), cliCategory: eo }, tabWidth: { type: "int", category: so, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: so, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: so, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
        const no = ["cliName", "cliCategory", "cliDescription"], ao = { compare: _a, lt: Ha, gte: $a }, oo = (t2, e2) => Object.entries(t2).map((t3) => {
          let [s2, r2] = t3;
          return Object.assign({ [e2]: s2 }, r2);
        }), uo = "2.5.1", ho = { CATEGORY_CONFIG: Za, CATEGORY_EDITOR: to, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: eo, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: so, CATEGORY_SPECIAL: ro, options: io }.options;
        function po(t2, e2, s2) {
          const r2 = new Set(t2.choices.map((t3) => t3.value));
          for (const i2 of e2)
            if (i2.parsers) {
              for (const e3 of i2.parsers)
                if (!r2.has(e3)) {
                  r2.add(e3);
                  const n2 = s2.find((t3) => t3.parsers && t3.parsers[e3]);
                  let a2 = i2.name;
                  n2 && n2.name && (a2 += " (plugin: ".concat(n2.name, ")")), t2.choices.push({ value: e3, description: a2 });
                }
            }
        }
        var co = { getSupportInfo: function() {
          let { plugins: t2 = [], showUnreleased: e2 = false, showDeprecated: s2 = false, showInternal: r2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const i2 = uo.split("-", 1)[0], n2 = t2.flatMap((t3) => t3.languages || []).filter(o2), a2 = oo(Object.assign({}, ...t2.map((t3) => {
            let { options: e3 } = t3;
            return e3;
          }), ho), "name").filter((t3) => o2(t3) && u2(t3)).sort((t3, e3) => t3.name === e3.name ? 0 : t3.name < e3.name ? -1 : 1).map(h2).map((e3) => {
            e3 = Object.assign({}, e3), Array.isArray(e3.default) && (e3.default = e3.default.length === 1 ? e3.default[0].value : e3.default.filter(o2).sort((t3, e4) => ao.compare(e4.since, t3.since))[0].value), Array.isArray(e3.choices) && (e3.choices = e3.choices.filter((t3) => o2(t3) && u2(t3)), e3.name === "parser" && po(e3, n2, t2));
            const s3 = Object.fromEntries(t2.filter((t3) => t3.defaultOptions && t3.defaultOptions[e3.name] !== void 0).map((t3) => [t3.name, t3.defaultOptions[e3.name]]));
            return Object.assign(Object.assign({}, e3), {}, { pluginDefaults: s3 });
          });
          return { languages: n2, options: a2 };
          function o2(t3) {
            return e2 || !("since" in t3) || t3.since && ao.gte(i2, t3.since);
          }
          function u2(t3) {
            return s2 || !("deprecated" in t3) || t3.deprecated && ao.lt(i2, t3.deprecated);
          }
          function h2(t3) {
            if (r2)
              return t3;
            return Ii(t3, no);
          }
        } };
        const lo = Fi.exports, Do = (t2) => {
          if (typeof t2 != "string")
            throw new TypeError("Expected a string");
          return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }, mo = Ni, { getSupportInfo: fo } = co, yo = /[^\x20-\x7F]/;
        function Eo(t2) {
          return (e2, s2, r2) => {
            const i2 = r2 && r2.backwards;
            if (s2 === false)
              return false;
            const { length: n2 } = e2;
            let a2 = s2;
            for (; a2 >= 0 && a2 < n2; ) {
              const s3 = e2.charAt(a2);
              if (t2 instanceof RegExp) {
                if (!t2.test(s3))
                  return a2;
              } else if (!t2.includes(s3))
                return a2;
              i2 ? a2-- : a2++;
            }
            return (a2 === -1 || a2 === n2) && a2;
          };
        }
        const Ao = Eo(/\s/), Co = Eo(" 	"), xo = Eo(",; 	"), Fo = Eo(/[^\n\r]/);
        function go(t2, e2) {
          if (e2 === false)
            return false;
          if (t2.charAt(e2) === "/" && t2.charAt(e2 + 1) === "*") {
            for (let s2 = e2 + 2; s2 < t2.length; ++s2)
              if (t2.charAt(s2) === "*" && t2.charAt(s2 + 1) === "/")
                return s2 + 2;
          }
          return e2;
        }
        function Po(t2, e2) {
          return e2 !== false && (t2.charAt(e2) === "/" && t2.charAt(e2 + 1) === "/" ? Fo(t2, e2) : e2);
        }
        function To(t2, e2, s2) {
          const r2 = s2 && s2.backwards;
          if (e2 === false)
            return false;
          const i2 = t2.charAt(e2);
          if (r2) {
            if (t2.charAt(e2 - 1) === "\r" && i2 === "\n")
              return e2 - 2;
            if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
              return e2 - 1;
          } else {
            if (i2 === "\r" && t2.charAt(e2 + 1) === "\n")
              return e2 + 2;
            if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
              return e2 + 1;
          }
          return e2;
        }
        function bo(t2, e2) {
          let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const r2 = Co(t2, s2.backwards ? e2 - 1 : e2, s2), i2 = To(t2, r2, s2);
          return r2 !== i2;
        }
        function So(t2, e2) {
          let s2 = null, r2 = e2;
          for (; r2 !== s2; )
            s2 = r2, r2 = xo(t2, r2), r2 = go(t2, r2), r2 = Co(t2, r2);
          return r2 = Po(t2, r2), r2 = To(t2, r2), r2 !== false && bo(t2, r2);
        }
        function wo(t2, e2) {
          let s2 = null, r2 = e2;
          for (; r2 !== s2; )
            s2 = r2, r2 = Co(t2, r2), r2 = go(t2, r2), r2 = Po(t2, r2), r2 = To(t2, r2);
          return r2;
        }
        function Bo(t2, e2, s2) {
          return wo(t2, s2(e2));
        }
        function No(t2, e2) {
          let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r2 = 0;
          for (let i2 = s2; i2 < t2.length; ++i2)
            t2[i2] === "	" ? r2 = r2 + e2 - r2 % e2 : r2++;
          return r2;
        }
        function Io(t2, e2) {
          const s2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, r2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, i2 = e2 === "'" ? r2 : s2, n2 = i2 === r2 ? s2 : r2;
          let a2 = i2;
          if (t2.includes(i2.quote) || t2.includes(n2.quote)) {
            a2 = (t2.match(i2.regex) || []).length > (t2.match(n2.regex) || []).length ? n2 : i2;
          }
          return a2;
        }
        function vo(t2, e2, s2) {
          const r2 = e2 === '"' ? "'" : '"', i2 = t2.replace(/\\(.)|(["'])/gs, (t3, i3, n2) => i3 === r2 ? i3 : n2 === e2 ? "\\" + n2 : n2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
          return e2 + i2 + e2;
        }
        function ko(t2, e2) {
          (t2.comments || (t2.comments = [])).push(e2), e2.printed = false, e2.nodeDescription = function(t3) {
            const e3 = t3.type || t3.kind || "(unknown type)";
            let s2 = String(t3.name || t3.id && (typeof t3.id == "object" ? t3.id.name : t3.id) || t3.key && (typeof t3.key == "object" ? t3.key.name : t3.key) || t3.value && (typeof t3.value == "object" ? "" : String(t3.value)) || t3.operator || "");
            s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
            return e3 + (s2 ? " " + s2 : "");
          }(t2);
        }
        var Lo, Oo = { inferParserByLanguage: function(t2, e2) {
          const { languages: s2 } = fo({ plugins: e2.plugins }), r2 = s2.find((e3) => {
            let { name: s3 } = e3;
            return s3.toLowerCase() === t2;
          }) || s2.find((e3) => {
            let { aliases: s3 } = e3;
            return Array.isArray(s3) && s3.includes(t2);
          }) || s2.find((e3) => {
            let { extensions: s3 } = e3;
            return Array.isArray(s3) && s3.includes(".".concat(t2));
          });
          return r2 && r2.parsers[0];
        }, getStringWidth: function(t2) {
          return t2 ? yo.test(t2) ? lo(t2) : t2.length : 0;
        }, getMaxContinuousCount: function(t2, e2) {
          const s2 = t2.match(new RegExp("(".concat(Do(e2), ")+"), "g"));
          return s2 === null ? 0 : s2.reduce((t3, s3) => Math.max(t3, s3.length / e2.length), 0);
        }, getMinNotPresentContinuousCount: function(t2, e2) {
          const s2 = t2.match(new RegExp("(".concat(Do(e2), ")+"), "g"));
          if (s2 === null)
            return 0;
          const r2 = /* @__PURE__ */ new Map();
          let i2 = 0;
          for (const t3 of s2) {
            const s3 = t3.length / e2.length;
            r2.set(s3, true), s3 > i2 && (i2 = s3);
          }
          for (let t3 = 1; t3 < i2; t3++)
            if (!r2.get(t3))
              return t3;
          return i2 + 1;
        }, getPenultimate: (t2) => t2[t2.length - 2], getLast: mo, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: wo, getNextNonSpaceNonCommentCharacterIndex: Bo, getNextNonSpaceNonCommentCharacter: function(t2, e2, s2) {
          return t2.charAt(Bo(t2, e2, s2));
        }, skip: Eo, skipWhitespace: Ao, skipSpaces: Co, skipToLineEnd: xo, skipEverythingButNewLine: Fo, skipInlineComment: go, skipTrailingComment: Po, skipNewline: To, isNextLineEmptyAfterIndex: So, isNextLineEmpty: function(t2, e2, s2) {
          return So(t2, s2(e2));
        }, isPreviousLineEmpty: function(t2, e2, s2) {
          let r2 = s2(e2) - 1;
          return r2 = Co(t2, r2, { backwards: true }), r2 = To(t2, r2, { backwards: true }), r2 = Co(t2, r2, { backwards: true }), r2 !== To(t2, r2, { backwards: true });
        }, hasNewline: bo, hasNewlineInRange: function(t2, e2, s2) {
          for (let r2 = e2; r2 < s2; ++r2)
            if (t2.charAt(r2) === "\n")
              return true;
          return false;
        }, hasSpaces: function(t2, e2) {
          let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const r2 = Co(t2, s2.backwards ? e2 - 1 : e2, s2);
          return r2 !== e2;
        }, getAlignmentSize: No, getIndentSize: function(t2, e2) {
          const s2 = t2.lastIndexOf("\n");
          return s2 === -1 ? 0 : No(t2.slice(s2 + 1).match(/^[\t ]*/)[0], e2);
        }, getPreferredQuote: Io, printString: function(t2, e2) {
          const s2 = t2.slice(1, -1);
          return vo(s2, e2.parser === "json" || e2.parser === "json5" && e2.quoteProps === "preserve" && !e2.singleQuote ? '"' : e2.__isInHtmlAttribute ? "'" : Io(s2, e2.singleQuote ? "'" : '"').quote, !(e2.parser === "css" || e2.parser === "less" || e2.parser === "scss" || e2.__embeddedInHtml));
        }, printNumber: function(t2) {
          return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        }, makeString: vo, addLeadingComment: function(t2, e2) {
          e2.leading = true, e2.trailing = false, ko(t2, e2);
        }, addDanglingComment: function(t2, e2, s2) {
          e2.leading = false, e2.trailing = false, s2 && (e2.marker = s2), ko(t2, e2);
        }, addTrailingComment: function(t2, e2) {
          e2.leading = false, e2.trailing = true, ko(t2, e2);
        }, isFrontMatterNode: function(t2) {
          return t2 && t2.type === "front-matter";
        }, getShebang: function(t2) {
          if (!t2.startsWith("#!"))
            return "";
          const e2 = t2.indexOf("\n");
          return e2 === -1 ? t2 : t2.slice(0, e2);
        }, isNonEmptyArray: function(t2) {
          return Array.isArray(t2) && t2.length > 0;
        }, createGroupIdMapper: function(t2) {
          const e2 = /* @__PURE__ */ new WeakMap();
          return function(s2) {
            return e2.has(s2) || e2.set(s2, Symbol(t2)), e2.get(s2);
          };
        } }, Mo = {};
        function Ro() {
          if (Lo === void 0) {
            var t2 = new ArrayBuffer(2), e2 = new Uint8Array(t2), s2 = new Uint16Array(t2);
            if (e2[0] = 1, e2[1] = 2, s2[0] === 258)
              Lo = "BE";
            else {
              if (s2[0] !== 513)
                throw new Error("unable to figure out endianess");
              Lo = "LE";
            }
          }
          return Lo;
        }
        function jo() {
          return $n.location !== void 0 ? $n.location.hostname : "";
        }
        function Uo() {
          return [];
        }
        function _o() {
          return 0;
        }
        function zo() {
          return Number.MAX_VALUE;
        }
        function Ho() {
          return Number.MAX_VALUE;
        }
        function Vo() {
          return [];
        }
        function qo() {
          return "Browser";
        }
        function Wo() {
          return $n.navigator !== void 0 ? $n.navigator.appVersion : "";
        }
        function Ko() {
        }
        function Go() {
        }
        function Xo() {
          return "javascript";
        }
        function Jo() {
          return "browser";
        }
        function $o() {
          return "/tmp";
        }
        var Yo = $o, Qo = { EOL: "\n", arch: Xo, platform: Jo, tmpdir: Yo, tmpDir: $o, networkInterfaces: Ko, getNetworkInterfaces: Go, release: Wo, type: qo, cpus: Vo, totalmem: Ho, freemem: zo, uptime: _o, loadavg: Uo, hostname: jo, endianness: Ro }, Zo = e(Object.freeze({ __proto__: null, endianness: Ro, hostname: jo, loadavg: Uo, uptime: _o, freemem: zo, totalmem: Ho, cpus: Vo, type: qo, release: Wo, networkInterfaces: Ko, getNetworkInterfaces: Go, arch: Xo, platform: Jo, tmpDir: $o, tmpdir: Yo, EOL: "\n", default: Qo })), tu = { exports: {} };
        const eu = (t2) => {
          if (typeof t2 != "string")
            throw new TypeError("Expected a string");
          const e2 = t2.match(/(?:\r?\n)/g) || [];
          if (e2.length === 0)
            return;
          const s2 = e2.filter((t3) => t3 === "\r\n").length;
          return s2 > e2.length - s2 ? "\r\n" : "\n";
        };
        function su() {
          const t2 = Zo;
          return su = function() {
            return t2;
          }, t2;
        }
        function ru() {
          const t2 = (e2 = tu.exports) && e2.__esModule ? e2 : { default: e2 };
          var e2;
          return ru = function() {
            return t2;
          }, t2;
        }
        tu.exports = eu, tu.exports.graceful = (t2) => typeof t2 == "string" && eu(t2) || "\n", Object.defineProperty(Mo, "__esModule", { value: true }), Mo.extract = function(t2) {
          const e2 = t2.match(au);
          return e2 ? e2[0].trimLeft() : "";
        }, Mo.strip = function(t2) {
          const e2 = t2.match(au);
          return e2 && e2[0] ? t2.substring(e2[0].length) : t2;
        }, Mo.parse = function(t2) {
          return du(t2).pragmas;
        }, Mo.parseWithComments = du, Mo.print = function(t2) {
          let { comments: e2 = "", pragmas: s2 = {} } = t2;
          const r2 = (0, ru().default)(e2) || su().EOL, i2 = " *", n2 = Object.keys(s2), a2 = n2.map((t3) => Du(t3, s2[t3])).reduce((t3, e3) => t3.concat(e3), []).map((t3) => " * " + t3 + r2).join("");
          if (!e2) {
            if (n2.length === 0)
              return "";
            if (n2.length === 1 && !Array.isArray(s2[n2[0]])) {
              const t3 = s2[n2[0]];
              return "".concat("/**", " ").concat(Du(n2[0], t3)[0]).concat(" */");
            }
          }
          const o2 = e2.split(r2).map((t3) => "".concat(i2, " ").concat(t3)).join(r2) + r2;
          return "/**" + r2 + (e2 ? o2 : "") + (e2 && n2.length ? i2 + r2 : "") + a2 + " */";
        };
        const iu = /\*\/$/, nu = /^\/\*\*/, au = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, ou = /(^|\s+)\/\/([^\r\n]*)/g, uu = /^(\r?\n)+/, hu = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, pu = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, cu = /(\r?\n|^) *\* ?/g, lu = [];
        function du(t2) {
          const e2 = (0, ru().default)(t2) || su().EOL;
          t2 = t2.replace(nu, "").replace(iu, "").replace(cu, "$1");
          let s2 = "";
          for (; s2 !== t2; )
            s2 = t2, t2 = t2.replace(hu, "".concat(e2, "$1 $2").concat(e2));
          t2 = t2.replace(uu, "").trimRight();
          const r2 = /* @__PURE__ */ Object.create(null), i2 = t2.replace(pu, "").replace(uu, "").trimRight();
          let n2;
          for (; n2 = pu.exec(t2); ) {
            const t3 = n2[2].replace(ou, "");
            typeof r2[n2[1]] == "string" || Array.isArray(r2[n2[1]]) ? r2[n2[1]] = lu.concat(r2[n2[1]], t3) : r2[n2[1]] = t3;
          }
          return { comments: i2, pragmas: r2 };
        }
        function Du(t2, e2) {
          return lu.concat(e2).map((e3) => "@".concat(t2, " ").concat(e3).trim());
        }
        var mu = { guessEndOfLine: function(t2) {
          const e2 = t2.indexOf("\r");
          return e2 >= 0 ? t2.charAt(e2 + 1) === "\n" ? "crlf" : "cr" : "lf";
        }, convertEndOfLineToChars: function(t2) {
          switch (t2) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        }, countEndOfLineChars: function(t2, e2) {
          let s2;
          if (e2 === "\n")
            s2 = /\n/g;
          else if (e2 === "\r")
            s2 = /\r/g;
          else {
            if (e2 !== "\r\n")
              throw new Error('Unexpected "eol" '.concat(JSON.stringify(e2), "."));
            s2 = /\r\n/g;
          }
          const r2 = t2.match(s2);
          return r2 ? r2.length : 0;
        }, normalizeEndOfLine: function(t2) {
          return t2.replace(/\r\n?/g, "\n");
        } };
        const { parseWithComments: fu, strip: yu, extract: Eu, print: Au } = Mo, { getShebang: Cu } = Oo, { normalizeEndOfLine: xu } = mu;
        function Fu(t2) {
          const e2 = Cu(t2);
          e2 && (t2 = t2.slice(e2.length + 1));
          const s2 = Eu(t2), { pragmas: r2, comments: i2 } = fu(s2);
          return { shebang: e2, text: t2, pragmas: r2, comments: i2 };
        }
        var gu = { hasPragma: function(t2) {
          const e2 = Object.keys(Fu(t2).pragmas);
          return e2.includes("prettier") || e2.includes("format");
        }, insertPragma: function(t2) {
          const { shebang: e2, text: s2, pragmas: r2, comments: i2 } = Fu(t2), n2 = yu(s2), a2 = Au({ pragmas: Object.assign({ format: "" }, r2), comments: i2.trimStart() });
          return (e2 ? "".concat(e2, "\n") : "") + xu(a2) + (n2.startsWith("\n") ? "\n" : "\n\n") + n2;
        } };
        const { isNonEmptyArray: Pu } = Oo;
        function Tu(t2, e2) {
          const { ignoreDecorators: s2 } = e2 || {};
          if (!s2) {
            const e3 = t2.declaration && t2.declaration.decorators || t2.decorators;
            if (Pu(e3))
              return Tu(e3[0]);
          }
          return t2.range ? t2.range[0] : t2.start;
        }
        function bu(t2) {
          return t2.range ? t2.range[1] : t2.end;
        }
        function Su(t2, e2) {
          return Tu(t2) === Tu(e2);
        }
        var wu = { locStart: Tu, locEnd: bu, hasSameLocStart: Su, hasSameLoc: function(t2, e2) {
          return Su(t2, e2) && function(t3, e3) {
            return bu(t3) === bu(e3);
          }(t2, e2);
        } };
        const { hasPragma: Bu } = gu, { locStart: Nu, locEnd: Iu } = wu;
        var vu = function(t2) {
          return t2 = typeof t2 == "function" ? { parse: t2 } : t2, Object.assign({ astFormat: "estree", hasPragma: Bu, locStart: Nu, locEnd: Iu }, t2);
        };
        var ku = function(t2, e2) {
          const s2 = new SyntaxError(t2 + " (" + e2.start.line + ":" + e2.start.column + ")");
          return s2.loc = e2, s2;
        };
        const Lu = ku;
        var Ou = function(t2) {
          const { message: e2, loc: s2 } = t2;
          return Lu(e2.replace(/ \(.*\)/, ""), { start: { line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0 } });
        }, Mu = {}, Ru = { exports: {} };
        !function() {
          function t2(t3) {
            if (t3 == null)
              return false;
            switch (t3.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function e2(t3) {
            switch (t3.type) {
              case "IfStatement":
                return t3.alternate != null ? t3.alternate : t3.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return t3.body;
            }
            return null;
          }
          Ru.exports = { isExpression: function(t3) {
            if (t3 == null)
              return false;
            switch (t3.type) {
              case "ArrayExpression":
              case "AssignmentExpression":
              case "BinaryExpression":
              case "CallExpression":
              case "ConditionalExpression":
              case "FunctionExpression":
              case "Identifier":
              case "Literal":
              case "LogicalExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ObjectExpression":
              case "SequenceExpression":
              case "ThisExpression":
              case "UnaryExpression":
              case "UpdateExpression":
                return true;
            }
            return false;
          }, isStatement: t2, isIterationStatement: function(t3) {
            if (t3 == null)
              return false;
            switch (t3.type) {
              case "DoWhileStatement":
              case "ForInStatement":
              case "ForStatement":
              case "WhileStatement":
                return true;
            }
            return false;
          }, isSourceElement: function(e3) {
            return t2(e3) || e3 != null && e3.type === "FunctionDeclaration";
          }, isProblematicIfStatement: function(t3) {
            var s2;
            if (t3.type !== "IfStatement")
              return false;
            if (t3.alternate == null)
              return false;
            s2 = t3.consequent;
            do {
              if (s2.type === "IfStatement" && s2.alternate == null)
                return true;
              s2 = e2(s2);
            } while (s2);
            return false;
          }, trailingStatement: e2 };
        }();
        var ju = { exports: {} };
        !function() {
          var t2, e2, s2, r2, i2, n2;
          function a2(t3) {
            return t3 <= 65535 ? String.fromCharCode(t3) : String.fromCharCode(Math.floor((t3 - 65536) / 1024) + 55296) + String.fromCharCode((t3 - 65536) % 1024 + 56320);
          }
          for (e2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, s2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], r2 = new Array(128), n2 = 0; n2 < 128; ++n2)
            r2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
          for (i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
            i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
          ju.exports = { isDecimalDigit: function(t3) {
            return 48 <= t3 && t3 <= 57;
          }, isHexDigit: function(t3) {
            return 48 <= t3 && t3 <= 57 || 97 <= t3 && t3 <= 102 || 65 <= t3 && t3 <= 70;
          }, isOctalDigit: function(t3) {
            return t3 >= 48 && t3 <= 55;
          }, isWhiteSpace: function(t3) {
            return t3 === 32 || t3 === 9 || t3 === 11 || t3 === 12 || t3 === 160 || t3 >= 5760 && s2.indexOf(t3) >= 0;
          }, isLineTerminator: function(t3) {
            return t3 === 10 || t3 === 13 || t3 === 8232 || t3 === 8233;
          }, isIdentifierStartES5: function(t3) {
            return t3 < 128 ? r2[t3] : e2.NonAsciiIdentifierStart.test(a2(t3));
          }, isIdentifierPartES5: function(t3) {
            return t3 < 128 ? i2[t3] : e2.NonAsciiIdentifierPart.test(a2(t3));
          }, isIdentifierStartES6: function(e3) {
            return e3 < 128 ? r2[e3] : t2.NonAsciiIdentifierStart.test(a2(e3));
          }, isIdentifierPartES6: function(e3) {
            return e3 < 128 ? i2[e3] : t2.NonAsciiIdentifierPart.test(a2(e3));
          } };
        }();
        var Uu = { exports: {} };
        !function() {
          var t2 = ju.exports;
          function e2(t3, e3) {
            return !(!e3 && t3 === "yield") && s2(t3, e3);
          }
          function s2(t3, e3) {
            if (e3 && function(t4) {
              switch (t4) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(t3))
              return true;
            switch (t3.length) {
              case 2:
                return t3 === "if" || t3 === "in" || t3 === "do";
              case 3:
                return t3 === "var" || t3 === "for" || t3 === "new" || t3 === "try";
              case 4:
                return t3 === "this" || t3 === "else" || t3 === "case" || t3 === "void" || t3 === "with" || t3 === "enum";
              case 5:
                return t3 === "while" || t3 === "break" || t3 === "catch" || t3 === "throw" || t3 === "const" || t3 === "yield" || t3 === "class" || t3 === "super";
              case 6:
                return t3 === "return" || t3 === "typeof" || t3 === "delete" || t3 === "switch" || t3 === "export" || t3 === "import";
              case 7:
                return t3 === "default" || t3 === "finally" || t3 === "extends";
              case 8:
                return t3 === "function" || t3 === "continue" || t3 === "debugger";
              case 10:
                return t3 === "instanceof";
              default:
                return false;
            }
          }
          function r2(t3, s3) {
            return t3 === "null" || t3 === "true" || t3 === "false" || e2(t3, s3);
          }
          function i2(t3, e3) {
            return t3 === "null" || t3 === "true" || t3 === "false" || s2(t3, e3);
          }
          function n2(e3) {
            var s3, r3, i3;
            if (e3.length === 0)
              return false;
            if (i3 = e3.charCodeAt(0), !t2.isIdentifierStartES5(i3))
              return false;
            for (s3 = 1, r3 = e3.length; s3 < r3; ++s3)
              if (i3 = e3.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
                return false;
            return true;
          }
          function a2(e3) {
            var s3, r3, i3, n3, a3;
            if (e3.length === 0)
              return false;
            for (a3 = t2.isIdentifierStartES6, s3 = 0, r3 = e3.length; s3 < r3; ++s3) {
              if (55296 <= (i3 = e3.charCodeAt(s3)) && i3 <= 56319) {
                if (++s3 >= r3)
                  return false;
                if (!(56320 <= (n3 = e3.charCodeAt(s3)) && n3 <= 57343))
                  return false;
                i3 = 1024 * (i3 - 55296) + (n3 - 56320) + 65536;
              }
              if (!a3(i3))
                return false;
              a3 = t2.isIdentifierPartES6;
            }
            return true;
          }
          Uu.exports = { isKeywordES5: e2, isKeywordES6: s2, isReservedWordES5: r2, isReservedWordES6: i2, isRestrictedWord: function(t3) {
            return t3 === "eval" || t3 === "arguments";
          }, isIdentifierNameES5: n2, isIdentifierNameES6: a2, isIdentifierES5: function(t3, e3) {
            return n2(t3) && !r2(t3, e3);
          }, isIdentifierES6: function(t3, e3) {
            return a2(t3) && !i2(t3, e3);
          } };
        }(), Mu.ast = Ru.exports, Mu.code = ju.exports, Mu.keyword = Uu.exports;
        const _u = Mu.keyword.isIdentifierNameES5, { getLast: zu, hasNewline: Hu, skipWhitespace: Vu, isNonEmptyArray: qu, isNextLineEmptyAfterIndex: Wu, getStringWidth: Ku } = Oo, { locStart: Gu, locEnd: Xu, hasSameLocStart: Ju } = wu, $u = "(?:(?=.)\\s)", Yu = new RegExp("^".concat($u, "*:")), Qu = new RegExp("^".concat($u, "*::"));
        function Zu(t2) {
          return t2.type === "Block" || t2.type === "CommentBlock" || t2.type === "MultiLine";
        }
        function th(t2) {
          return t2.type === "Line" || t2.type === "CommentLine" || t2.type === "SingleLine" || t2.type === "HashbangComment" || t2.type === "HTMLOpen" || t2.type === "HTMLClose";
        }
        const eh = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
        function sh(t2) {
          return t2 && eh.has(t2.type);
        }
        function rh(t2) {
          return t2.type === "NumericLiteral" || t2.type === "Literal" && typeof t2.value == "number";
        }
        function ih(t2) {
          return t2.type === "StringLiteral" || t2.type === "Literal" && typeof t2.value == "string";
        }
        function nh(t2) {
          return t2.type === "FunctionExpression" || t2.type === "ArrowFunctionExpression";
        }
        function ah(t2) {
          return dh(t2) && t2.callee.type === "Identifier" && (t2.callee.name === "async" || t2.callee.name === "inject" || t2.callee.name === "fakeAsync");
        }
        function oh(t2) {
          return t2.type === "JSXElement" || t2.type === "JSXFragment";
        }
        function uh(t2) {
          return t2.kind === "get" || t2.kind === "set";
        }
        function hh(t2) {
          return uh(t2) || Ju(t2, t2.value);
        }
        const ph = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
        const ch = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
        const lh = /^(?:skip|[fx]?(?:it|describe|test))$/;
        function dh(t2) {
          return t2 && (t2.type === "CallExpression" || t2.type === "OptionalCallExpression");
        }
        function Dh(t2) {
          return t2 && (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression");
        }
        function mh(t2) {
          return /^(?:\d+|\d+\.\d+)$/.test(t2);
        }
        function fh(t2) {
          return t2.quasis.some((t3) => t3.value.raw.includes("\n"));
        }
        function yh(t2) {
          return t2.extra ? t2.extra.raw : t2.raw;
        }
        const Eh = { "==": true, "!=": true, "===": true, "!==": true }, Ah = { "*": true, "/": true, "%": true }, Ch = { ">>": true, ">>>": true, "<<": true };
        const xh = {};
        for (const [t2, e2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
          for (const s2 of e2)
            xh[s2] = t2;
        function Fh(t2) {
          return xh[t2];
        }
        const gh = /* @__PURE__ */ new WeakMap();
        function Ph(t2) {
          if (gh.has(t2))
            return gh.get(t2);
          const e2 = [];
          return t2.this && e2.push(t2.this), Array.isArray(t2.parameters) ? e2.push(...t2.parameters) : Array.isArray(t2.params) && e2.push(...t2.params), t2.rest && e2.push(t2.rest), gh.set(t2, e2), e2;
        }
        const Th = /* @__PURE__ */ new WeakMap();
        function bh(t2) {
          if (Th.has(t2))
            return Th.get(t2);
          let e2 = t2.arguments;
          return t2.type === "ImportExpression" && (e2 = [t2.source], t2.attributes && e2.push(t2.attributes)), Th.set(t2, e2), e2;
        }
        function Sh(t2) {
          return t2.value.trim() === "prettier-ignore" && !t2.unignore;
        }
        function wh(t2) {
          return t2 && (t2.prettierIgnore || Ih(t2, Bh.PrettierIgnore));
        }
        const Bh = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Nh = (t2, e2) => {
          if (typeof t2 == "function" && (e2 = t2, t2 = 0), t2 || e2)
            return (s2, r2, i2) => !(t2 & Bh.Leading && !s2.leading || t2 & Bh.Trailing && !s2.trailing || t2 & Bh.Dangling && (s2.leading || s2.trailing) || t2 & Bh.Block && !Zu(s2) || t2 & Bh.Line && !th(s2) || t2 & Bh.First && r2 !== 0 || t2 & Bh.Last && r2 !== i2.length - 1 || t2 & Bh.PrettierIgnore && !Sh(s2) || e2 && !e2(s2));
        };
        function Ih(t2, e2, s2) {
          if (!t2 || !qu(t2.comments))
            return false;
          const r2 = Nh(e2, s2);
          return !r2 || t2.comments.some(r2);
        }
        function vh(t2, e2, s2) {
          if (!t2 || !Array.isArray(t2.comments))
            return [];
          const r2 = Nh(e2, s2);
          return r2 ? t2.comments.filter(r2) : t2.comments;
        }
        function kh(t2) {
          return dh(t2) || t2.type === "NewExpression" || t2.type === "ImportExpression";
        }
        var Lh = { getFunctionParameters: Ph, iterateFunctionParametersPath: function(t2, e2) {
          const s2 = t2.getValue();
          let r2 = 0;
          const i2 = (t3) => e2(t3, r2++);
          s2.this && t2.call(i2, "this"), Array.isArray(s2.parameters) ? t2.each(i2, "parameters") : Array.isArray(s2.params) && t2.each(i2, "params"), s2.rest && t2.call(i2, "rest");
        }, getCallArguments: bh, iterateCallArgumentsPath: function(t2, e2) {
          const s2 = t2.getValue();
          s2.type === "ImportExpression" ? (t2.call((t3) => e2(t3, 0), "source"), s2.attributes && t2.call((t3) => e2(t3, 1), "attributes")) : t2.each(e2, "arguments");
        }, hasRestParameter: function(t2) {
          if (t2.rest)
            return true;
          const e2 = Ph(t2);
          return e2.length > 0 && zu(e2).type === "RestElement";
        }, getLeftSide: function(t2) {
          return t2.expressions ? t2.expressions[0] : t2.left || t2.test || t2.callee || t2.object || t2.tag || t2.argument || t2.expression;
        }, getLeftSidePathName: function(t2, e2) {
          if (e2.expressions)
            return ["expressions", 0];
          if (e2.left)
            return ["left"];
          if (e2.test)
            return ["test"];
          if (e2.object)
            return ["object"];
          if (e2.callee)
            return ["callee"];
          if (e2.tag)
            return ["tag"];
          if (e2.argument)
            return ["argument"];
          if (e2.expression)
            return ["expression"];
          throw new Error("Unexpected node has no left side.");
        }, getParentExportDeclaration: function(t2) {
          const e2 = t2.getParentNode();
          return t2.getName() === "declaration" && sh(e2) ? e2 : null;
        }, getTypeScriptMappedTypeModifier: function(t2, e2) {
          return t2 === "+" ? "+" + e2 : t2 === "-" ? "-" + e2 : e2;
        }, hasFlowAnnotationComment: function(t2) {
          return qu(t2) && Zu(t2[0]) && Qu.test(t2[0].value);
        }, hasFlowShorthandAnnotationComment: function(t2) {
          return t2.extra && t2.extra.parenthesized && qu(t2.trailingComments) && Zu(t2.trailingComments[0]) && Yu.test(t2.trailingComments[0].value);
        }, hasLeadingOwnLineComment: function(t2, e2) {
          return oh(e2) ? wh(e2) : Ih(e2, Bh.Leading, (e3) => Hu(t2, Xu(e3)));
        }, hasNakedLeftSide: function(t2) {
          return t2.type === "AssignmentExpression" || t2.type === "BinaryExpression" || t2.type === "LogicalExpression" || t2.type === "NGPipeExpression" || t2.type === "ConditionalExpression" || dh(t2) || Dh(t2) || t2.type === "SequenceExpression" || t2.type === "TaggedTemplateExpression" || t2.type === "BindExpression" || t2.type === "UpdateExpression" && !t2.prefix || t2.type === "TSAsExpression" || t2.type === "TSNonNullExpression";
        }, hasNode: function t2(e2, s2) {
          if (!e2 || typeof e2 != "object")
            return false;
          if (Array.isArray(e2))
            return e2.some((e3) => t2(e3, s2));
          const r2 = s2(e2);
          return typeof r2 == "boolean" ? r2 : Object.values(e2).some((e3) => t2(e3, s2));
        }, hasIgnoreComment: function(t2) {
          return wh(t2.getValue());
        }, hasNodeIgnoreComment: wh, identity: function(t2) {
          return t2;
        }, isBinaryish: function(t2) {
          return ph.has(t2.type);
        }, isBlockComment: Zu, isCallLikeExpression: kh, isEnabledHackPipeline: function(t2) {
          return Boolean(t2.__isUsingHackPipeline);
        }, isLineComment: th, isPrettierIgnoreComment: Sh, isCallExpression: dh, isMemberExpression: Dh, isExportDeclaration: sh, isFlowAnnotationComment: function(t2, e2) {
          const s2 = Gu(e2), r2 = Vu(t2, Xu(e2));
          return r2 !== false && t2.slice(s2, s2 + 2) === "/*" && t2.slice(r2, r2 + 2) === "*/";
        }, isFunctionCompositionArgs: function(t2) {
          if (t2.length <= 1)
            return false;
          let e2 = 0;
          for (const s2 of t2)
            if (nh(s2)) {
              if (e2 += 1, e2 > 1)
                return true;
            } else if (dh(s2)) {
              for (const t3 of s2.arguments)
                if (nh(t3))
                  return true;
            }
          return false;
        }, isFunctionNotation: hh, isFunctionOrArrowExpression: nh, isGetterOrSetter: uh, isJestEachTemplateLiteral: function(t2, e2) {
          const s2 = /^[fx]?(?:describe|it|test)$/;
          return e2.type === "TaggedTemplateExpression" && e2.quasi === t2 && e2.tag.type === "MemberExpression" && e2.tag.property.type === "Identifier" && e2.tag.property.name === "each" && (e2.tag.object.type === "Identifier" && s2.test(e2.tag.object.name) || e2.tag.object.type === "MemberExpression" && e2.tag.object.property.type === "Identifier" && (e2.tag.object.property.name === "only" || e2.tag.object.property.name === "skip") && e2.tag.object.object.type === "Identifier" && s2.test(e2.tag.object.object.name));
        }, isJsxNode: oh, isLiteral: function(t2) {
          return t2.type === "BooleanLiteral" || t2.type === "DirectiveLiteral" || t2.type === "Literal" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "TemplateLiteral" || t2.type === "TSTypeLiteral" || t2.type === "JSXText";
        }, isLongCurriedCallExpression: function(t2) {
          const e2 = t2.getValue(), s2 = t2.getParentNode();
          return dh(e2) && dh(s2) && s2.callee === e2 && e2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
        }, isSimpleCallArgument: function t2(e2, s2) {
          if (s2 >= 2)
            return false;
          const r2 = (e3) => t2(e3, s2 + 1), i2 = e2.type === "Literal" && "regex" in e2 && e2.regex.pattern || e2.type === "RegExpLiteral" && e2.pattern;
          return !(i2 && Ku(i2) > 5) && (e2.type === "Literal" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "BooleanLiteral" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "Identifier" || e2.type === "ThisExpression" || e2.type === "Super" || e2.type === "PrivateName" || e2.type === "PrivateIdentifier" || e2.type === "ArgumentPlaceholder" || e2.type === "Import" || (e2.type === "TemplateLiteral" ? e2.quasis.every((t3) => !t3.value.raw.includes("\n")) && e2.expressions.every(r2) : e2.type === "ObjectExpression" ? e2.properties.every((t3) => !t3.computed && (t3.shorthand || t3.value && r2(t3.value))) : e2.type === "ArrayExpression" ? e2.elements.every((t3) => t3 === null || r2(t3)) : kh(e2) ? (e2.type === "ImportExpression" || t2(e2.callee, s2)) && bh(e2).every(r2) : Dh(e2) ? t2(e2.object, s2) && t2(e2.property, s2) : e2.type !== "UnaryExpression" || e2.operator !== "!" && e2.operator !== "-" ? e2.type === "TSNonNullExpression" && t2(e2.expression, s2) : t2(e2.argument, s2)));
        }, isMemberish: function(t2) {
          return Dh(t2) || t2.type === "BindExpression" && Boolean(t2.object);
        }, isNumericLiteral: rh, isSignedNumericLiteral: function(t2) {
          return t2.type === "UnaryExpression" && (t2.operator === "+" || t2.operator === "-") && rh(t2.argument);
        }, isObjectProperty: function(t2) {
          return t2 && (t2.type === "ObjectProperty" || t2.type === "Property" && !t2.method && t2.kind === "init");
        }, isObjectType: function(t2) {
          return t2.type === "ObjectTypeAnnotation" || t2.type === "TSTypeLiteral" || t2.type === "TSMappedType";
        }, isObjectTypePropertyAFunction: function(t2) {
          return !(t2.type !== "ObjectTypeProperty" && t2.type !== "ObjectTypeInternalSlot" || t2.value.type !== "FunctionTypeAnnotation" || t2.static || hh(t2));
        }, isSimpleType: function(t2) {
          return !!t2 && (!(t2.type !== "GenericTypeAnnotation" && t2.type !== "TSTypeReference" || t2.typeParameters) || !!ch.has(t2.type));
        }, isSimpleNumber: mh, isSimpleTemplateLiteral: function(t2) {
          let e2 = "expressions";
          t2.type === "TSTemplateLiteralType" && (e2 = "types");
          const s2 = t2[e2];
          return s2.length !== 0 && s2.every((t3) => {
            if (Ih(t3))
              return false;
            if (t3.type === "Identifier" || t3.type === "ThisExpression")
              return true;
            if (Dh(t3)) {
              let e3 = t3;
              for (; Dh(e3); ) {
                if (e3.property.type !== "Identifier" && e3.property.type !== "Literal" && e3.property.type !== "StringLiteral" && e3.property.type !== "NumericLiteral")
                  return false;
                if (e3 = e3.object, Ih(e3))
                  return false;
              }
              return e3.type === "Identifier" || e3.type === "ThisExpression";
            }
            return false;
          });
        }, isStringLiteral: ih, isStringPropSafeToUnquote: function(t2, e2) {
          return e2.parser !== "json" && ih(t2.key) && yh(t2.key).slice(1, -1) === t2.key.value && (_u(t2.key.value) && !(e2.parser === "babel-ts" && t2.type === "ClassProperty" || e2.parser === "typescript" && t2.type === "PropertyDefinition") || mh(t2.key.value) && String(Number(t2.key.value)) === t2.key.value && (e2.parser === "babel" || e2.parser === "espree" || e2.parser === "meriyah" || e2.parser === "__babel_estree"));
        }, isTemplateOnItsOwnLine: function(t2, e2) {
          return (t2.type === "TemplateLiteral" && fh(t2) || t2.type === "TaggedTemplateExpression" && fh(t2.quasi)) && !Hu(e2, Gu(t2), { backwards: true });
        }, isTestCall: function t2(e2, s2) {
          if (e2.type !== "CallExpression")
            return false;
          if (e2.arguments.length === 1) {
            if (ah(e2) && s2 && t2(s2))
              return nh(e2.arguments[0]);
            if (function(t3) {
              return t3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(t3.callee.name) && t3.arguments.length === 1;
            }(e2))
              return ah(e2.arguments[0]);
          } else if ((e2.arguments.length === 2 || e2.arguments.length === 3) && (e2.callee.type === "Identifier" && lh.test(e2.callee.name) || function(t3) {
            return Dh(t3.callee) && t3.callee.object.type === "Identifier" && t3.callee.property.type === "Identifier" && lh.test(t3.callee.object.name) && (t3.callee.property.name === "only" || t3.callee.property.name === "skip");
          }(e2)) && (function(t3) {
            return t3.type === "TemplateLiteral";
          }(e2.arguments[0]) || ih(e2.arguments[0])))
            return !(e2.arguments[2] && !rh(e2.arguments[2])) && ((e2.arguments.length === 2 ? nh(e2.arguments[1]) : function(t3) {
              return t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement";
            }(e2.arguments[1]) && Ph(e2.arguments[1]).length <= 1) || ah(e2.arguments[1]));
          return false;
        }, isTheOnlyJsxElementInMarkdown: function(t2, e2) {
          if (t2.parentParser !== "markdown" && t2.parentParser !== "mdx")
            return false;
          const s2 = e2.getNode();
          if (!s2.expression || !oh(s2.expression))
            return false;
          const r2 = e2.getParentNode();
          return r2.type === "Program" && r2.body.length === 1;
        }, isTSXFile: function(t2) {
          return t2.filepath && /\.tsx$/i.test(t2.filepath);
        }, isTypeAnnotationAFunction: function(t2) {
          return !(t2.type !== "TypeAnnotation" && t2.type !== "TSTypeAnnotation" || t2.typeAnnotation.type !== "FunctionTypeAnnotation" || t2.static || Ju(t2, t2.typeAnnotation));
        }, isNextLineEmpty: (t2, e2) => {
          let { originalText: s2 } = e2;
          return Wu(s2, Xu(t2));
        }, needsHardlineAfterDanglingComment: function(t2) {
          if (!Ih(t2))
            return false;
          const e2 = zu(vh(t2, Bh.Dangling));
          return e2 && !Zu(e2);
        }, rawText: yh, shouldPrintComma: function(t2) {
          let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
          return t2.trailingComma === "es5" && e2 === "es5" || t2.trailingComma === "all" && (e2 === "all" || e2 === "es5");
        }, isBitwiseOperator: function(t2) {
          return Boolean(Ch[t2]) || t2 === "|" || t2 === "^" || t2 === "&";
        }, shouldFlatten: function(t2, e2) {
          return Fh(e2) === Fh(t2) && (t2 !== "**" && ((!Eh[t2] || !Eh[e2]) && (!(e2 === "%" && Ah[t2] || t2 === "%" && Ah[e2]) && ((e2 === t2 || !Ah[e2] || !Ah[t2]) && (!Ch[t2] || !Ch[e2])))));
        }, startsWithNoLookaheadToken: function t2(e2, s2) {
          switch ((e2 = function(t3) {
            for (; t3.left; )
              t3 = t3.left;
            return t3;
          }(e2)).type) {
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
              return s2;
            case "ObjectExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return t2(e2.object, s2);
            case "TaggedTemplateExpression":
              return e2.tag.type !== "FunctionExpression" && t2(e2.tag, s2);
            case "CallExpression":
            case "OptionalCallExpression":
              return e2.callee.type !== "FunctionExpression" && t2(e2.callee, s2);
            case "ConditionalExpression":
              return t2(e2.test, s2);
            case "UpdateExpression":
              return !e2.prefix && t2(e2.argument, s2);
            case "BindExpression":
              return e2.object && t2(e2.object, s2);
            case "SequenceExpression":
              return t2(e2.expressions[0], s2);
            case "TSAsExpression":
            case "TSNonNullExpression":
              return t2(e2.expression, s2);
            default:
              return false;
          }
        }, getPrecedence: Fh, hasComment: Ih, getComments: vh, CommentCheckFlags: Bh };
        const { getLast: Oh, hasNewline: Mh, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Rh, getNextNonSpaceNonCommentCharacter: jh, hasNewlineInRange: Uh, addLeadingComment: _h, addTrailingComment: zh, addDanglingComment: Hh, getNextNonSpaceNonCommentCharacterIndex: Vh, isNonEmptyArray: qh } = Oo, { isBlockComment: Wh, getFunctionParameters: Kh, isPrettierIgnoreComment: Gh, isJsxNode: Xh, hasFlowShorthandAnnotationComment: Jh, hasFlowAnnotationComment: $h, hasIgnoreComment: Yh, isCallLikeExpression: Qh, getCallArguments: Zh, isCallExpression: tp, isMemberExpression: ep, isObjectProperty: sp, getComments: rp, CommentCheckFlags: ip } = Lh, { locStart: np, locEnd: ap } = wu;
        function op(t2, e2) {
          const s2 = (t2.body || t2.properties).find((t3) => {
            let { type: e3 } = t3;
            return e3 !== "EmptyStatement";
          });
          s2 ? _h(s2, e2) : Hh(t2, e2);
        }
        function up(t2, e2) {
          t2.type === "BlockStatement" ? op(t2, e2) : _h(t2, e2);
        }
        function hp(t2) {
          let { comment: e2, followingNode: s2 } = t2;
          return !(!s2 || !jp(e2)) && (_h(s2, e2), true);
        }
        function pp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2, text: n2 } = t2;
          if (!r2 || r2.type !== "IfStatement" || !i2)
            return false;
          return jh(n2, e2, ap) === ")" ? (zh(s2, e2), true) : s2 === r2.consequent && i2 === r2.alternate ? (s2.type === "BlockStatement" ? zh(s2, e2) : Hh(r2, e2), true) : i2.type === "BlockStatement" ? (op(i2, e2), true) : i2.type === "IfStatement" ? (up(i2.consequent, e2), true) : r2.consequent === i2 && (_h(i2, e2), true);
        }
        function cp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2, text: n2 } = t2;
          if (!r2 || r2.type !== "WhileStatement" || !i2)
            return false;
          return jh(n2, e2, ap) === ")" ? (zh(s2, e2), true) : i2.type === "BlockStatement" ? (op(i2, e2), true) : r2.body === i2 && (_h(i2, e2), true);
        }
        function lp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2 } = t2;
          return !(!r2 || r2.type !== "TryStatement" && r2.type !== "CatchClause" || !i2) && (r2.type === "CatchClause" && s2 ? (zh(s2, e2), true) : i2.type === "BlockStatement" ? (op(i2, e2), true) : i2.type === "TryStatement" ? (up(i2.finalizer, e2), true) : i2.type === "CatchClause" && (up(i2.body, e2), true));
        }
        function dp(t2) {
          let { comment: e2, enclosingNode: s2, followingNode: r2 } = t2;
          return !(!ep(s2) || !r2 || r2.type !== "Identifier") && (_h(s2, e2), true);
        }
        function Dp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2, text: n2 } = t2;
          const a2 = s2 && !Uh(n2, ap(s2), np(e2));
          return !(s2 && a2 || !r2 || r2.type !== "ConditionalExpression" && r2.type !== "TSConditionalType" || !i2) && (_h(i2, e2), true);
        }
        function mp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2 } = t2;
          return !(!sp(r2) || !r2.shorthand || r2.key !== s2 || r2.value.type !== "AssignmentPattern") && (zh(r2.value.left, e2), true);
        }
        function fp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2 } = t2;
          if (r2 && (r2.type === "ClassDeclaration" || r2.type === "ClassExpression" || r2.type === "DeclareClass" || r2.type === "DeclareInterface" || r2.type === "InterfaceDeclaration" || r2.type === "TSInterfaceDeclaration")) {
            if (qh(r2.decorators) && (!i2 || i2.type !== "Decorator"))
              return zh(Oh(r2.decorators), e2), true;
            if (r2.body && i2 === r2.body)
              return op(r2.body, e2), true;
            if (i2) {
              for (const t3 of ["implements", "extends", "mixins"])
                if (r2[t3] && i2 === r2[t3][0])
                  return !s2 || s2 !== r2.id && s2 !== r2.typeParameters && s2 !== r2.superClass ? Hh(r2, e2, t3) : zh(s2, e2), true;
            }
          }
          return false;
        }
        function yp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, text: i2 } = t2;
          return (r2 && s2 && (r2.type === "Property" || r2.type === "TSDeclareMethod" || r2.type === "TSAbstractMethodDefinition") && s2.type === "Identifier" && r2.key === s2 && jh(i2, s2, ap) !== ":" || !(!s2 || !r2 || s2.type !== "Decorator" || r2.type !== "ClassMethod" && r2.type !== "ClassProperty" && r2.type !== "PropertyDefinition" && r2.type !== "TSAbstractPropertyDefinition" && r2.type !== "TSAbstractMethodDefinition" && r2.type !== "TSDeclareMethod" && r2.type !== "MethodDefinition")) && (zh(s2, e2), true);
        }
        function Ep(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, text: i2 } = t2;
          return jh(i2, e2, ap) === "(" && (!(!s2 || !r2 || r2.type !== "FunctionDeclaration" && r2.type !== "FunctionExpression" && r2.type !== "ClassMethod" && r2.type !== "MethodDefinition" && r2.type !== "ObjectMethod") && (zh(s2, e2), true));
        }
        function Ap(t2) {
          let { comment: e2, enclosingNode: s2, text: r2 } = t2;
          if (!s2 || s2.type !== "ArrowFunctionExpression")
            return false;
          const i2 = Vh(r2, e2, ap);
          return i2 !== false && r2.slice(i2, i2 + 2) === "=>" && (Hh(s2, e2), true);
        }
        function Cp(t2) {
          let { comment: e2, enclosingNode: s2, text: r2 } = t2;
          return jh(r2, e2, ap) === ")" && (s2 && (Rp(s2) && Kh(s2).length === 0 || Qh(s2) && Zh(s2).length === 0) ? (Hh(s2, e2), true) : !(!s2 || s2.type !== "MethodDefinition" && s2.type !== "TSAbstractMethodDefinition" || Kh(s2.value).length !== 0) && (Hh(s2.value, e2), true));
        }
        function xp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2, text: n2 } = t2;
          if (s2 && s2.type === "FunctionTypeParam" && r2 && r2.type === "FunctionTypeAnnotation" && i2 && i2.type !== "FunctionTypeParam")
            return zh(s2, e2), true;
          if (s2 && (s2.type === "Identifier" || s2.type === "AssignmentPattern") && r2 && Rp(r2) && jh(n2, e2, ap) === ")")
            return zh(s2, e2), true;
          if (r2 && r2.type === "FunctionDeclaration" && i2 && i2.type === "BlockStatement") {
            const t3 = (() => {
              const t4 = Kh(r2);
              if (t4.length > 0)
                return Rh(n2, ap(Oh(t4)));
              const e3 = Rh(n2, ap(r2.id));
              return e3 !== false && Rh(n2, e3 + 1);
            })();
            if (np(e2) > t3)
              return op(i2, e2), true;
          }
          return false;
        }
        function Fp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "ImportSpecifier") && (_h(s2, e2), true);
        }
        function gp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "LabeledStatement") && (_h(s2, e2), true);
        }
        function Pp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "ContinueStatement" && s2.type !== "BreakStatement" || s2.label) && (zh(s2, e2), true);
        }
        function Tp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2 } = t2;
          return !!(tp(r2) && s2 && r2.callee === s2 && r2.arguments.length > 0) && (_h(r2.arguments[0], e2), true);
        }
        function bp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2 } = t2;
          return !r2 || r2.type !== "UnionTypeAnnotation" && r2.type !== "TSUnionType" ? (i2 && (i2.type === "UnionTypeAnnotation" || i2.type === "TSUnionType") && Gh(e2) && (i2.types[0].prettierIgnore = true, e2.unignore = true), false) : (Gh(e2) && (i2.prettierIgnore = true, e2.unignore = true), !!s2 && (zh(s2, e2), true));
        }
        function Sp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !!sp(s2) && (_h(s2, e2), true);
        }
        function wp(t2) {
          let { comment: e2, enclosingNode: s2, followingNode: r2, ast: i2, isLastComment: n2 } = t2;
          return i2 && i2.body && i2.body.length === 0 ? (n2 ? Hh(i2, e2) : _h(i2, e2), true) : s2 && s2.type === "Program" && s2.body.length === 0 && !qh(s2.directives) ? (n2 ? Hh(s2, e2) : _h(s2, e2), true) : !(!r2 || r2.type !== "Program" || r2.body.length !== 0 || !s2 || s2.type !== "ModuleExpression") && (Hh(r2, e2), true);
        }
        function Bp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "ForInStatement" && s2.type !== "ForOfStatement") && (_h(s2, e2), true);
        }
        function Np(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, text: i2 } = t2;
          return !!(s2 && s2.type === "ImportSpecifier" && r2 && r2.type === "ImportDeclaration" && Mh(i2, ap(e2))) && (zh(s2, e2), true);
        }
        function Ip(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "AssignmentPattern") && (_h(s2, e2), true);
        }
        function vp(t2) {
          let { comment: e2, enclosingNode: s2 } = t2;
          return !(!s2 || s2.type !== "TypeAlias") && (_h(s2, e2), true);
        }
        function kp(t2) {
          let { comment: e2, enclosingNode: s2, followingNode: r2 } = t2;
          return !(!s2 || s2.type !== "VariableDeclarator" && s2.type !== "AssignmentExpression" || !r2 || r2.type !== "ObjectExpression" && r2.type !== "ArrayExpression" && r2.type !== "TemplateLiteral" && r2.type !== "TaggedTemplateExpression" && !Wh(e2)) && (_h(r2, e2), true);
        }
        function Lp(t2) {
          let { comment: e2, enclosingNode: s2, followingNode: r2, text: i2 } = t2;
          return !(r2 || !s2 || s2.type !== "TSMethodSignature" && s2.type !== "TSDeclareFunction" && s2.type !== "TSAbstractMethodDefinition" || jh(i2, e2, ap) !== ";") && (zh(s2, e2), true);
        }
        function Op(t2) {
          let { comment: e2, enclosingNode: s2, followingNode: r2 } = t2;
          if (Gh(e2) && s2 && s2.type === "TSMappedType" && r2 && r2.type === "TSTypeParameter" && r2.constraint)
            return s2.prettierIgnore = true, e2.unignore = true, true;
        }
        function Mp(t2) {
          let { comment: e2, precedingNode: s2, enclosingNode: r2, followingNode: i2 } = t2;
          return !(!r2 || r2.type !== "TSMappedType") && (i2 && i2.type === "TSTypeParameter" && i2.name ? (_h(i2.name, e2), true) : !(!s2 || s2.type !== "TSTypeParameter" || !s2.constraint) && (zh(s2.constraint, e2), true));
        }
        function Rp(t2) {
          return t2.type === "ArrowFunctionExpression" || t2.type === "FunctionExpression" || t2.type === "FunctionDeclaration" || t2.type === "ObjectMethod" || t2.type === "ClassMethod" || t2.type === "TSDeclareFunction" || t2.type === "TSCallSignatureDeclaration" || t2.type === "TSConstructSignatureDeclaration" || t2.type === "TSMethodSignature" || t2.type === "TSConstructorType" || t2.type === "TSFunctionType" || t2.type === "TSDeclareMethod";
        }
        function jp(t2) {
          return Wh(t2) && t2.value[0] === "*" && /@type\b/.test(t2.value);
        }
        var Up = { handleOwnLineComment: function(t2) {
          return [Op, xp, dp, pp, cp, lp, fp, Fp, Bp, bp, wp, Np, Ip, yp, gp].some((e2) => e2(t2));
        }, handleEndOfLineComment: function(t2) {
          return [hp, xp, Dp, Fp, pp, cp, lp, fp, gp, Tp, Sp, wp, vp, kp].some((e2) => e2(t2));
        }, handleRemainingComment: function(t2) {
          return [Op, pp, cp, mp, Cp, yp, wp, Ap, Ep, Mp, Pp, Lp].some((e2) => e2(t2));
        }, isTypeCastComment: jp, getCommentChildNodes: function(t2, e2) {
          if ((e2.parser === "typescript" || e2.parser === "flow" || e2.parser === "espree" || e2.parser === "meriyah" || e2.parser === "__babel_estree") && t2.type === "MethodDefinition" && t2.value && t2.value.type === "FunctionExpression" && Kh(t2.value).length === 0 && !t2.value.returnType && !qh(t2.value.typeParameters) && t2.value.body)
            return [...t2.decorators || [], t2.key, t2.value.body];
        }, willPrintOwnComments: function(t2) {
          const e2 = t2.getValue(), s2 = t2.getParentNode();
          return (e2 && (Xh(e2) || Jh(e2) || tp(s2) && ((t3) => $h(rp(t3, ip.Leading)) || $h(rp(t3, ip.Trailing)))(e2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === e2)) && (!Yh(t2) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
        } };
        var _p = function t2(e2, s2) {
          let r2;
          if (Array.isArray(e2))
            r2 = e2.entries();
          else {
            if (!e2 || typeof e2 != "object" || typeof e2.type != "string")
              return e2;
            r2 = Object.entries(e2);
          }
          for (const [i2, n2] of r2)
            e2[i2] = t2(n2, s2);
          return Array.isArray(e2) ? e2 : s2(e2) || e2;
        };
        const zp = ku, Hp = _p;
        function Vp(t2, e2) {
          const { start: s2, end: r2 } = t2.loc;
          throw zp(e2, { start: { line: s2.line, column: s2.column + 1 }, end: { line: r2.line, column: r2.column + 1 } });
        }
        var qp = { throwErrorForInvalidNodes: function(t2, e2) {
          const { esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2 } = e2.tsParseResult;
          t2 = Hp(t2, (t3) => {
            const e3 = s2.get(t3);
            if (!e3)
              return;
            const i2 = r2.get(e3);
            i2 === t3 && (function(t4, e4, s3) {
              const r3 = t4.decorators;
              if (!Array.isArray(r3))
                return;
              const i3 = e4.decorators;
              Array.isArray(i3) && i3.length === r3.length && !r3.some((t5) => {
                const e5 = s3.get(t5);
                return !e5 || !i3.includes(e5);
              }) || Vp(e4, "Leading decorators must be attached to a class declaration");
            }(e3, i2, r2), function(t4, e4) {
              t4.kind !== 166 || t4.modifiers && !t4.modifiers.some((t5) => t5.kind === 126) || t4.initializer && e4.value === null && Vp(e4, "Abstract property cannot have an initializer");
            }(e3, i2));
          });
        } };
        const { getLast: Wp } = Oo, { locStart: Kp, locEnd: Gp } = wu, { isTypeCastComment: Xp } = Up, Jp = _p, { throwErrorForInvalidNodes: $p } = qp;
        function Yp(t2) {
          return t2.type === "CallExpression" ? (t2.type = "OptionalCallExpression", t2.callee = Yp(t2.callee)) : t2.type === "MemberExpression" ? (t2.type = "OptionalMemberExpression", t2.object = Yp(t2.object)) : t2.type === "TSNonNullExpression" && (t2.expression = Yp(t2.expression)), t2;
        }
        function Qp(t2) {
          return t2.type === "LogicalExpression" && t2.right.type === "LogicalExpression" && t2.operator === t2.right.operator;
        }
        function Zp(t2) {
          return Qp(t2) ? Zp({ type: "LogicalExpression", operator: t2.operator, left: Zp({ type: "LogicalExpression", operator: t2.operator, left: t2.left, right: t2.right.left, range: [Kp(t2.left), Gp(t2.right.left)] }), right: t2.right.right, range: [Kp(t2), Gp(t2)] }) : t2;
        }
        var tc = function(t2, e2) {
          if (e2.parser === "typescript" && /@|abstract/.test(e2.originalText) && $p(t2, e2), e2.parser !== "typescript" && e2.parser !== "flow" && e2.parser !== "espree" && e2.parser !== "meriyah") {
            const e3 = /* @__PURE__ */ new Set();
            t2 = Jp(t2, (t3) => {
              t3.leadingComments && t3.leadingComments.some(Xp) && e3.add(Kp(t3));
            }), t2 = Jp(t2, (t3) => {
              if (t3.type === "ParenthesizedExpression") {
                const { expression: s2 } = t3;
                if (s2.type === "TypeCastExpression")
                  return s2.range = t3.range, s2;
                const r2 = Kp(t3);
                if (!e3.has(r2))
                  return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, { parenthesized: true }), s2;
              }
            });
          }
          return t2 = Jp(t2, (t3) => {
            switch (t3.type) {
              case "ChainExpression":
                return Yp(t3.expression);
              case "LogicalExpression":
                if (Qp(t3))
                  return Zp(t3);
                break;
              case "VariableDeclaration": {
                const s2 = Wp(t3.declarations);
                s2 && s2.init && function(t4, s3) {
                  if (e2.originalText[Gp(s3)] === ";")
                    return;
                  t4.range = [Kp(t4), Gp(s3)];
                }(t3, s2);
                break;
              }
              case "TSParenthesizedType":
                return t3.typeAnnotation.range = [Kp(t3), Gp(t3)], t3.typeAnnotation;
              case "TSTypeParameter":
                if (typeof t3.name == "string") {
                  const e3 = Kp(t3);
                  t3.name = { type: "Identifier", name: t3.name, range: [e3, e3 + t3.name.length] };
                }
                break;
              case "SequenceExpression": {
                const e3 = Wp(t3.expressions);
                t3.range = [Kp(t3), Math.min(Gp(e3), Gp(t3))];
                break;
              }
              case "TopicReference":
                e2.__isUsingHackPipeline = true;
            }
          });
        }, ec = {};
        Object.defineProperty(ec, "__esModule", { value: true });
        const sc = /\r\n?|[\n\u2028\u2029]/, rc = new RegExp(sc.source, "g");
        function ic(t2) {
          switch (t2) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const nc = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ac = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function oc(t2) {
          switch (t2) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class uc {
          constructor(t2, e2) {
            this.line = void 0, this.column = void 0, this.line = t2, this.column = e2;
          }
        }
        class hc {
          constructor(t2, e2) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = e2;
          }
        }
        function pc(t2, e2) {
          t2.trailingComments === void 0 ? t2.trailingComments = e2 : t2.trailingComments.unshift(...e2);
        }
        function cc(t2, e2) {
          t2.innerComments === void 0 ? t2.innerComments = e2 : t2.innerComments.unshift(...e2);
        }
        function lc(t2, e2, s2) {
          let r2 = null, i2 = e2.length;
          for (; r2 === null && i2 > 0; )
            r2 = e2[--i2];
          r2 === null || r2.start > s2.start ? cc(t2, s2.comments) : pc(r2, s2.comments);
        }
        const dc = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), Dc = yc({ AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, dc.SyntaxError), mc = yc({ ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'` }, dc.SourceTypeModuleError);
        function fc(t2, e2) {
          return e2 === "flow" && t2 === "PatternIsOptional" ? "OptionalBindingPattern" : t2;
        }
        function yc(t2, e2, s2) {
          const r2 = {};
          return Object.keys(t2).forEach((i2) => {
            r2[i2] = Object.freeze({ code: e2, reasonCode: fc(i2, s2), template: t2[i2] });
          }), Object.freeze(r2);
        }
        class Ec {
          constructor(t2, e2) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t2, this.preserveSpace = !!e2;
          }
        }
        const Ac = { brace: new Ec("{"), template: new Ec("`", true) }, Cc = true, xc = true, Fc = true, gc = true, Pc = true;
        class Tc {
          constructor(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t2, this.keyword = e2.keyword, this.beforeExpr = !!e2.beforeExpr, this.startsExpr = !!e2.startsExpr, this.rightAssociative = !!e2.rightAssociative, this.isLoop = !!e2.isLoop, this.isAssign = !!e2.isAssign, this.prefix = !!e2.prefix, this.postfix = !!e2.postfix, this.binop = e2.binop != null ? e2.binop : null, this.updateContext = null;
          }
        }
        const bc = /* @__PURE__ */ new Map();
        function Sc(t2) {
          let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          e2.keyword = t2;
          const s2 = Mc(t2, e2);
          return bc.set(t2, s2), s2;
        }
        function wc(t2, e2) {
          return Mc(t2, { beforeExpr: Cc, binop: e2 });
        }
        let Bc = -1;
        const Nc = [], Ic = [], vc = [], kc = [], Lc = [], Oc = [];
        function Mc(t2) {
          let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var s2, r2, i2, n2;
          return ++Bc, Ic.push(t2), vc.push((s2 = e2.binop) != null ? s2 : -1), kc.push((r2 = e2.beforeExpr) != null && r2), Lc.push((i2 = e2.startsExpr) != null && i2), Oc.push((n2 = e2.prefix) != null && n2), Nc.push(new Tc(t2, e2)), Bc;
        }
        function Rc(t2) {
          let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var s2, r2, i2, n2;
          return ++Bc, bc.set(t2, Bc), Ic.push(t2), vc.push((s2 = e2.binop) != null ? s2 : -1), kc.push((r2 = e2.beforeExpr) != null && r2), Lc.push((i2 = e2.startsExpr) != null && i2), Oc.push((n2 = e2.prefix) != null && n2), Nc.push(new Tc("name", e2)), Bc;
        }
        const jc = { bracketL: Mc("[", { beforeExpr: Cc, startsExpr: xc }), bracketHashL: Mc("#[", { beforeExpr: Cc, startsExpr: xc }), bracketBarL: Mc("[|", { beforeExpr: Cc, startsExpr: xc }), bracketR: Mc("]"), bracketBarR: Mc("|]"), braceL: Mc("{", { beforeExpr: Cc, startsExpr: xc }), braceBarL: Mc("{|", { beforeExpr: Cc, startsExpr: xc }), braceHashL: Mc("#{", { beforeExpr: Cc, startsExpr: xc }), braceR: Mc("}", { beforeExpr: Cc }), braceBarR: Mc("|}"), parenL: Mc("(", { beforeExpr: Cc, startsExpr: xc }), parenR: Mc(")"), comma: Mc(",", { beforeExpr: Cc }), semi: Mc(";", { beforeExpr: Cc }), colon: Mc(":", { beforeExpr: Cc }), doubleColon: Mc("::", { beforeExpr: Cc }), dot: Mc("."), question: Mc("?", { beforeExpr: Cc }), questionDot: Mc("?."), arrow: Mc("=>", { beforeExpr: Cc }), template: Mc("template"), ellipsis: Mc("...", { beforeExpr: Cc }), backQuote: Mc("`", { startsExpr: xc }), dollarBraceL: Mc("${", { beforeExpr: Cc, startsExpr: xc }), at: Mc("@"), hash: Mc("#", { startsExpr: xc }), interpreterDirective: Mc("#!..."), eq: Mc("=", { beforeExpr: Cc, isAssign: gc }), assign: Mc("_=", { beforeExpr: Cc, isAssign: gc }), slashAssign: Mc("_=", { beforeExpr: Cc, isAssign: gc }), xorAssign: Mc("_=", { beforeExpr: Cc, isAssign: gc }), moduloAssign: Mc("_=", { beforeExpr: Cc, isAssign: gc }), incDec: Mc("++/--", { prefix: Pc, postfix: true, startsExpr: xc }), bang: Mc("!", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), tilde: Mc("~", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), pipeline: wc("|>", 0), nullishCoalescing: wc("??", 1), logicalOR: wc("||", 1), logicalAND: wc("&&", 2), bitwiseOR: wc("|", 3), bitwiseXOR: wc("^", 4), bitwiseAND: wc("&", 5), equality: wc("==/!=/===/!==", 6), lt: wc("</>/<=/>=", 7), gt: wc("</>/<=/>=", 7), relational: wc("</>/<=/>=", 7), bitShift: wc("<</>>/>>>", 8), plusMin: Mc("+/-", { beforeExpr: Cc, binop: 9, prefix: Pc, startsExpr: xc }), modulo: Mc("%", { binop: 10, startsExpr: xc }), star: Mc("*", { binop: 10 }), slash: wc("/", 10), exponent: Mc("**", { beforeExpr: Cc, binop: 11, rightAssociative: true }), _in: Sc("in", { beforeExpr: Cc, binop: 7 }), _instanceof: Sc("instanceof", { beforeExpr: Cc, binop: 7 }), _break: Sc("break"), _case: Sc("case", { beforeExpr: Cc }), _catch: Sc("catch"), _continue: Sc("continue"), _debugger: Sc("debugger"), _default: Sc("default", { beforeExpr: Cc }), _else: Sc("else", { beforeExpr: Cc }), _finally: Sc("finally"), _function: Sc("function", { startsExpr: xc }), _if: Sc("if"), _return: Sc("return", { beforeExpr: Cc }), _switch: Sc("switch"), _throw: Sc("throw", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), _try: Sc("try"), _var: Sc("var"), _const: Sc("const"), _with: Sc("with"), _new: Sc("new", { beforeExpr: Cc, startsExpr: xc }), _this: Sc("this", { startsExpr: xc }), _super: Sc("super", { startsExpr: xc }), _class: Sc("class", { startsExpr: xc }), _extends: Sc("extends", { beforeExpr: Cc }), _export: Sc("export"), _import: Sc("import", { startsExpr: xc }), _null: Sc("null", { startsExpr: xc }), _true: Sc("true", { startsExpr: xc }), _false: Sc("false", { startsExpr: xc }), _typeof: Sc("typeof", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), _void: Sc("void", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), _delete: Sc("delete", { beforeExpr: Cc, prefix: Pc, startsExpr: xc }), _do: Sc("do", { isLoop: Fc, beforeExpr: Cc }), _for: Sc("for", { isLoop: Fc }), _while: Sc("while", { isLoop: Fc }), _as: Rc("as", { startsExpr: xc }), _assert: Rc("assert", { startsExpr: xc }), _async: Rc("async", { startsExpr: xc }), _await: Rc("await", { startsExpr: xc }), _from: Rc("from", { startsExpr: xc }), _get: Rc("get", { startsExpr: xc }), _let: Rc("let", { startsExpr: xc }), _meta: Rc("meta", { startsExpr: xc }), _of: Rc("of", { startsExpr: xc }), _sent: Rc("sent", { startsExpr: xc }), _set: Rc("set", { startsExpr: xc }), _static: Rc("static", { startsExpr: xc }), _yield: Rc("yield", { startsExpr: xc }), _asserts: Rc("asserts", { startsExpr: xc }), _checks: Rc("checks", { startsExpr: xc }), _exports: Rc("exports", { startsExpr: xc }), _global: Rc("global", { startsExpr: xc }), _implements: Rc("implements", { startsExpr: xc }), _intrinsic: Rc("intrinsic", { startsExpr: xc }), _infer: Rc("infer", { startsExpr: xc }), _is: Rc("is", { startsExpr: xc }), _mixins: Rc("mixins", { startsExpr: xc }), _proto: Rc("proto", { startsExpr: xc }), _require: Rc("require", { startsExpr: xc }), _keyof: Rc("keyof", { startsExpr: xc }), _readonly: Rc("readonly", { startsExpr: xc }), _unique: Rc("unique", { startsExpr: xc }), _abstract: Rc("abstract", { startsExpr: xc }), _declare: Rc("declare", { startsExpr: xc }), _enum: Rc("enum", { startsExpr: xc }), _module: Rc("module", { startsExpr: xc }), _namespace: Rc("namespace", { startsExpr: xc }), _interface: Rc("interface", { startsExpr: xc }), _type: Rc("type", { startsExpr: xc }), _opaque: Rc("opaque", { startsExpr: xc }), name: Mc("name", { startsExpr: xc }), string: Mc("string", { startsExpr: xc }), num: Mc("num", { startsExpr: xc }), bigint: Mc("bigint", { startsExpr: xc }), decimal: Mc("decimal", { startsExpr: xc }), regexp: Mc("regexp", { startsExpr: xc }), privateName: Mc("#name", { startsExpr: xc }), eof: Mc("eof"), jsxName: Mc("jsxName"), jsxText: Mc("jsxText", { beforeExpr: true }), jsxTagStart: Mc("jsxTagStart", { startsExpr: true }), jsxTagEnd: Mc("jsxTagEnd"), placeholder: Mc("%%", { startsExpr: true }) };
        function Uc(t2) {
          return t2 >= 87 && t2 <= 122;
        }
        function _c(t2) {
          return t2 >= 52 && t2 <= 122;
        }
        function zc(t2) {
          return t2 >= 52 && t2 <= 126;
        }
        function Hc(t2) {
          return Lc[t2];
        }
        function Vc(t2) {
          return t2 >= 119 && t2 <= 121;
        }
        function qc(t2) {
          return t2 >= 52 && t2 <= 86;
        }
        function Wc(t2) {
          return Ic[t2];
        }
        function Kc(t2) {
          return vc[t2];
        }
        function Gc(t2) {
          return Nc[t2];
        }
        Nc[8].updateContext = (t2) => {
          t2.pop();
        }, Nc[5].updateContext = Nc[7].updateContext = Nc[23].updateContext = (t2) => {
          t2.push(Ac.brace);
        }, Nc[22].updateContext = (t2) => {
          t2[t2.length - 1] === Ac.template ? t2.pop() : t2.push(Ac.template);
        }, Nc[132].updateContext = (t2) => {
          t2.push(Ac.j_expr, Ac.j_oTag);
        };
        let Xc = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Jc = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const $c = new RegExp("[" + Xc + "]"), Yc = new RegExp("[" + Xc + Jc + "]");
        Xc = Jc = null;
        const Qc = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], Zc = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function tl(t2, e2) {
          let s2 = 65536;
          for (let r2 = 0, i2 = e2.length; r2 < i2; r2 += 2) {
            if (s2 += e2[r2], s2 > t2)
              return false;
            if (s2 += e2[r2 + 1], s2 >= t2)
              return true;
          }
          return false;
        }
        function el(t2) {
          return t2 < 65 ? t2 === 36 : t2 <= 90 || (t2 < 97 ? t2 === 95 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && $c.test(String.fromCharCode(t2)) : tl(t2, Qc)));
        }
        function sl(t2) {
          return t2 < 48 ? t2 === 36 : t2 < 58 || !(t2 < 65) && (t2 <= 90 || (t2 < 97 ? t2 === 95 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && Yc.test(String.fromCharCode(t2)) : tl(t2, Qc) || tl(t2, Zc))));
        }
        const rl = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], il = ["eval", "arguments"], nl = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), al = new Set(rl), ol = new Set(il);
        function ul(t2, e2) {
          return e2 && t2 === "await" || t2 === "enum";
        }
        function hl(t2, e2) {
          return ul(t2, e2) || al.has(t2);
        }
        function pl(t2) {
          return ol.has(t2);
        }
        function cl(t2, e2) {
          return hl(t2, e2) || pl(t2);
        }
        const ll = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        const dl = 64, Dl = 256, ml = 259, fl = 128, yl = 1024, El = 2048;
        class Al {
          constructor(t2) {
            this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t2;
          }
        }
        class Cl {
          constructor(t2, e2) {
            this.scopeStack = [], this.undefinedExports = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.raise = t2, this.inModule = e2;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (this.currentThisScopeFlags() & dl) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const t2 = this.currentThisScopeFlags();
            return (t2 & dl) > 0 && (2 & t2) == 0;
          }
          get inStaticBlock() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              const { flags: e2 } = this.scopeStack[t2];
              if (128 & e2)
                return true;
              if (323 & e2)
                return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t2) {
            return new Al(t2);
          }
          enter(t2) {
            this.scopeStack.push(this.createScope(t2));
          }
          exit() {
            this.scopeStack.pop();
          }
          treatFunctionsAsVarInScope(t2) {
            return !!(2 & t2.flags || !this.inModule && 1 & t2.flags);
          }
          declareName(t2, e2, s2) {
            let r2 = this.currentScope();
            if (8 & e2 || 16 & e2)
              this.checkRedeclarationInScope(r2, t2, e2, s2), 16 & e2 ? r2.functions.add(t2) : r2.lexical.add(t2), 8 & e2 && this.maybeExportDefined(r2, t2);
            else if (4 & e2)
              for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, t2, e2, s2), r2.var.add(t2), this.maybeExportDefined(r2, t2), !(r2.flags & ml)); --i2)
                ;
            this.inModule && 1 & r2.flags && this.undefinedExports.delete(t2);
          }
          maybeExportDefined(t2, e2) {
            this.inModule && 1 & t2.flags && this.undefinedExports.delete(e2);
          }
          checkRedeclarationInScope(t2, e2, s2, r2) {
            this.isRedeclaredInScope(t2, e2, s2) && this.raise(r2, Dc.VarRedeclaration, e2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            return !!(1 & s2) && (8 & s2 ? t2.lexical.has(e2) || t2.functions.has(e2) || t2.var.has(e2) : 16 & s2 ? t2.lexical.has(e2) || !this.treatFunctionsAsVarInScope(t2) && t2.var.has(e2) : t2.lexical.has(e2) && !(8 & t2.flags && t2.lexical.values().next().value === e2) || !this.treatFunctionsAsVarInScope(t2) && t2.functions.has(e2));
          }
          checkLocalExport(t2) {
            const { name: e2 } = t2, s2 = this.scopeStack[0];
            s2.lexical.has(e2) || s2.var.has(e2) || s2.functions.has(e2) || this.undefinedExports.set(e2, t2.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              const { flags: e2 } = this.scopeStack[t2];
              if (e2 & ml)
                return e2;
            }
          }
          currentThisScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              const { flags: e2 } = this.scopeStack[t2];
              if (323 & e2 && !(4 & e2))
                return e2;
            }
          }
        }
        class xl extends Al {
          constructor() {
            super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class Fl extends Cl {
          createScope(t2) {
            return new xl(t2);
          }
          declareName(t2, e2, s2) {
            const r2 = this.currentScope();
            if (e2 & El)
              return this.checkRedeclarationInScope(r2, t2, e2, s2), this.maybeExportDefined(r2, t2), void r2.declareFunctions.add(t2);
            super.declareName(...arguments);
          }
          isRedeclaredInScope(t2, e2, s2) {
            return !!super.isRedeclaredInScope(...arguments) || !!(s2 & El) && (!t2.declareFunctions.has(e2) && (t2.lexical.has(e2) || t2.functions.has(e2)));
          }
          checkLocalExport(t2) {
            this.scopeStack[0].declareFunctions.has(t2.name) || super.checkLocalExport(t2);
          }
        }
        class gl {
          constructor() {
            this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 129, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [Ac.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          init(t2) {
            let { strictMode: e2, sourceType: s2, startLine: r2, startColumn: i2 } = t2;
            this.strict = e2 !== false && (e2 === true || s2 === "module"), this.curLine = r2, this.lineStart = -i2, this.startLoc = this.endLoc = new uc(r2, i2);
          }
          curPosition() {
            return new uc(this.curLine, this.pos - this.lineStart);
          }
          clone(t2) {
            const e2 = new gl(), s2 = Object.keys(this);
            for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
              const i3 = s2[r2];
              let n2 = this[i3];
              !t2 && Array.isArray(n2) && (n2 = n2.slice()), e2[i3] = n2;
            }
            return e2;
          }
        }
        var Pl = function(t2) {
          return t2 >= 48 && t2 <= 57;
        };
        const Tl = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100]), bl = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] }, Sl = { bin: [48, 49] };
        Sl.oct = [...Sl.bin, 50, 51, 52, 53, 54, 55], Sl.dec = [...Sl.oct, 56, 57], Sl.hex = [...Sl.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
        class wl {
          constructor(t2) {
            this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new hc(t2.startLoc, t2.endLoc);
          }
        }
        class Bl {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class Nl {
          constructor(t2) {
            this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.raise = t2;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new Bl());
          }
          exit() {
            const t2 = this.stack.pop(), e2 = this.current();
            for (const [s2, r2] of Array.from(t2.undefinedPrivateNames))
              e2 ? e2.undefinedPrivateNames.has(s2) || e2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Dc.InvalidPrivateFieldResolution, s2);
          }
          declarePrivateName(t2, e2, s2) {
            const r2 = this.current();
            let i2 = r2.privateNames.has(t2);
            if (3 & e2) {
              const s3 = i2 && r2.loneAccessors.get(t2);
              if (s3) {
                const n2 = 4 & s3, a2 = 4 & e2;
                i2 = (3 & s3) === (3 & e2) || n2 !== a2, i2 || r2.loneAccessors.delete(t2);
              } else
                i2 || r2.loneAccessors.set(t2, e2);
            }
            i2 && this.raise(s2, Dc.PrivateNameRedeclaration, t2), r2.privateNames.add(t2), r2.undefinedPrivateNames.delete(t2);
          }
          usePrivateName(t2, e2) {
            let s2;
            for (s2 of this.stack)
              if (s2.privateNames.has(t2))
                return;
            s2 ? s2.undefinedPrivateNames.set(t2, e2) : this.raise(e2, Dc.InvalidPrivateFieldResolution, t2);
          }
        }
        class Il {
          constructor() {
            let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            this.type = void 0, this.type = t2;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
        class vl extends Il {
          constructor(t2) {
            super(t2), this.errors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(t2, e2) {
            this.errors.set(t2, e2);
          }
          clearDeclarationError(t2) {
            this.errors.delete(t2);
          }
          iterateErrors(t2) {
            this.errors.forEach(t2);
          }
        }
        class kl {
          constructor(t2) {
            this.stack = [new Il()], this.raise = t2;
          }
          enter(t2) {
            this.stack.push(t2);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(t2, e2) {
            const { stack: s2 } = this;
            let r2 = s2.length - 1, i2 = s2[r2];
            for (; !i2.isCertainlyParameterDeclaration(); ) {
              if (!i2.canBeArrowParameterDeclaration())
                return;
              i2.recordDeclarationError(t2, e2), i2 = s2[--r2];
            }
            this.raise(t2, e2);
          }
          recordParenthesizedIdentifierError(t2, e2) {
            const { stack: s2 } = this, r2 = s2[s2.length - 1];
            if (r2.isCertainlyParameterDeclaration())
              this.raise(t2, e2);
            else {
              if (!r2.canBeArrowParameterDeclaration())
                return;
              r2.recordDeclarationError(t2, e2);
            }
          }
          recordAsyncArrowParametersError(t2, e2) {
            const { stack: s2 } = this;
            let r2 = s2.length - 1, i2 = s2[r2];
            for (; i2.canBeArrowParameterDeclaration(); )
              i2.type === 2 && i2.recordDeclarationError(t2, e2), i2 = s2[--r2];
          }
          validateAsPattern() {
            const { stack: t2 } = this, e2 = t2[t2.length - 1];
            e2.canBeArrowParameterDeclaration() && e2.iterateErrors((e3, s2) => {
              this.raise(s2, e3);
              let r2 = t2.length - 2, i2 = t2[r2];
              for (; i2.canBeArrowParameterDeclaration(); )
                i2.clearDeclarationError(s2), i2 = t2[--r2];
            });
          }
        }
        function Ll() {
          return new Il();
        }
        class Ol {
          constructor() {
            this.stacks = [];
          }
          enter(t2) {
            this.stacks.push(t2);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function Ml(t2, e2) {
          return (t2 ? 2 : 0) | (e2 ? 1 : 0);
        }
        class Rl {
          constructor() {
            this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
          }
        }
        class jl {
          constructor(t2, e2, s2) {
            this.type = "", this.start = e2, this.end = 0, this.loc = new hc(s2), t2 != null && t2.options.ranges && (this.range = [e2, 0]), t2 != null && t2.filename && (this.loc.filename = t2.filename);
          }
        }
        const Ul = jl.prototype;
        function _l(t2) {
          const { type: e2, start: s2, end: r2, loc: i2, range: n2, extra: a2, name: o2 } = t2, u2 = Object.create(Ul);
          return u2.type = e2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = n2, u2.extra = a2, u2.name = o2, e2 === "Placeholder" && (u2.expectedNode = t2.expectedNode), u2;
        }
        function zl(t2) {
          const { type: e2, start: s2, end: r2, loc: i2, range: n2, extra: a2 } = t2;
          if (e2 === "Placeholder")
            return function(t3) {
              return _l(t3);
            }(t2);
          const o2 = Object.create(Ul);
          return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = n2, o2.extra = a2, o2.value = t2.value, o2;
        }
        Ul.__clone = function() {
          const t2 = new jl(), e2 = Object.keys(this);
          for (let s2 = 0, r2 = e2.length; s2 < r2; s2++) {
            const r3 = e2[s2];
            r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (t2[r3] = this[r3]);
          }
          return t2;
        };
        const Hl = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Vl = yc({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." }, dc.SyntaxError, "flow");
        function ql(t2) {
          return t2.importKind === "type" || t2.importKind === "typeof";
        }
        function Wl(t2) {
          return _c(t2) && t2 !== 91;
        }
        const Kl = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        const Gl = /\*?\s*@((?:no)?flow)\b/;
        const Xl = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Jl = /^[\da-fA-F]+$/, $l = /^\d+$/, Yl = yc({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }, dc.SyntaxError, "jsx");
        function Ql(t2) {
          return !!t2 && (t2.type === "JSXOpeningFragment" || t2.type === "JSXClosingFragment");
        }
        function Zl(t2) {
          if (t2.type === "JSXIdentifier")
            return t2.name;
          if (t2.type === "JSXNamespacedName")
            return t2.namespace.name + ":" + t2.name.name;
          if (t2.type === "JSXMemberExpression")
            return Zl(t2.object) + "." + Zl(t2.property);
          throw new Error("Node had unexpected type: " + t2.type);
        }
        Ac.j_oTag = new Ec("<tag"), Ac.j_cTag = new Ec("</tag"), Ac.j_expr = new Ec("<tag>...</tag>", true);
        class td extends Al {
          constructor() {
            super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
          }
        }
        class ed extends Cl {
          createScope(t2) {
            return new td(t2);
          }
          declareName(t2, e2, s2) {
            const r2 = this.currentScope();
            if (e2 & yl)
              return this.maybeExportDefined(r2, t2), void r2.exportOnlyBindings.add(t2);
            super.declareName(...arguments), 2 & e2 && (1 & e2 || (this.checkRedeclarationInScope(r2, t2, e2, s2), this.maybeExportDefined(r2, t2)), r2.types.add(t2)), 256 & e2 && r2.enums.add(t2), 512 & e2 && r2.constEnums.add(t2), e2 & fl && r2.classes.add(t2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            if (t2.enums.has(e2)) {
              if (256 & s2) {
                return !!(512 & s2) !== t2.constEnums.has(e2);
              }
              return true;
            }
            return s2 & fl && t2.classes.has(e2) ? !!t2.lexical.has(e2) && !!(1 & s2) : !!(2 & s2 && t2.types.has(e2)) || super.isRedeclaredInScope(...arguments);
          }
          checkLocalExport(t2) {
            const e2 = this.scopeStack[0], { name: s2 } = t2;
            e2.types.has(s2) || e2.exportOnlyBindings.has(s2) || super.checkLocalExport(t2);
          }
        }
        function sd(t2) {
          if (!t2)
            throw new Error("Assert fail");
        }
        const rd = yc({ AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0." }, dc.SyntaxError, "typescript");
        function id(t2) {
          return t2 === "private" || t2 === "public" || t2 === "protected";
        }
        const nd = yc({ ClassNameIsRequired: "A class name is required." }, dc.SyntaxError);
        function ad(t2, e2) {
          return t2.some((t3) => Array.isArray(t3) ? t3[0] === e2 : t3 === e2);
        }
        function od(t2, e2, s2) {
          const r2 = t2.find((t3) => Array.isArray(t3) ? t3[0] === e2 : t3 === e2);
          return r2 && Array.isArray(r2) ? r2[1][s2] : null;
        }
        const ud = ["minimal", "fsharp", "hack", "smart"], hd = ["^", "%", "#"], pd = ["hash", "bar"];
        const cd = { estree: (t2) => class extends t2 {
          parseRegExpLiteral(t3) {
            let { pattern: e2, flags: s2 } = t3, r2 = null;
            try {
              r2 = new RegExp(e2, s2);
            } catch (t4) {
            }
            const i2 = this.estreeParseLiteral(r2);
            return i2.regex = { pattern: e2, flags: s2 }, i2;
          }
          parseBigIntLiteral(t3) {
            let e2;
            try {
              e2 = BigInt(t3);
            } catch (t4) {
              e2 = null;
            }
            const s2 = this.estreeParseLiteral(e2);
            return s2.bigint = String(s2.value || t3), s2;
          }
          parseDecimalLiteral(t3) {
            const e2 = this.estreeParseLiteral(null);
            return e2.decimal = String(e2.value || t3), e2;
          }
          estreeParseLiteral(t3) {
            return this.parseLiteral(t3, "Literal");
          }
          parseStringLiteral(t3) {
            return this.estreeParseLiteral(t3);
          }
          parseNumericLiteral(t3) {
            return this.estreeParseLiteral(t3);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(t3) {
            return this.estreeParseLiteral(t3);
          }
          directiveToStmt(t3) {
            const e2 = t3.value, s2 = this.startNodeAt(t3.start, t3.loc.start), r2 = this.startNodeAt(e2.start, e2.loc.start);
            return r2.value = e2.extra.expressionValue, r2.raw = e2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", e2.end, e2.loc.end), s2.directive = e2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", t3.end, t3.loc.end);
          }
          initFunction(t3, e2) {
            super.initFunction(t3, e2), t3.expression = false;
          }
          checkDeclaration(t3) {
            t3 != null && this.isObjectProperty(t3) ? this.checkDeclaration(t3.value) : super.checkDeclaration(t3);
          }
          getObjectOrClassMethodParams(t3) {
            return t3.value.params;
          }
          isValidDirective(t3) {
            var e2;
            return t3.type === "ExpressionStatement" && t3.expression.type === "Literal" && typeof t3.expression.value == "string" && !((e2 = t3.expression.extra) != null && e2.parenthesized);
          }
          parseBlockBody(t3) {
            for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++)
              s2[r2 - 1] = arguments[r2];
            super.parseBlockBody(t3, ...s2);
            const i2 = t3.directives.map((t4) => this.directiveToStmt(t4));
            t3.body = i2.concat(t3.body), delete t3.directives;
          }
          pushClassMethod(t3, e2, s2, r2, i2, n2) {
            this.parseMethod(e2, s2, r2, i2, n2, "ClassMethod", true), e2.typeParameters && (e2.value.typeParameters = e2.typeParameters, delete e2.typeParameters), t3.body.push(e2);
          }
          parsePrivateName() {
            const t3 = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t3) : t3;
          }
          convertPrivateNameToPrivateIdentifier(t3) {
            const e2 = super.getPrivateNameSV(t3);
            return delete (t3 = t3).id, t3.name = e2, t3.type = "PrivateIdentifier", t3;
          }
          isPrivateName(t3) {
            return this.getPluginOption("estree", "classFeatures") ? t3.type === "PrivateIdentifier" : super.isPrivateName(t3);
          }
          getPrivateNameSV(t3) {
            return this.getPluginOption("estree", "classFeatures") ? t3.name : super.getPrivateNameSV(t3);
          }
          parseLiteral(t3, e2) {
            const s2 = super.parseLiteral(t3, e2);
            return s2.raw = s2.extra.raw, delete s2.extra, s2;
          }
          parseFunctionBody(t3, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            super.parseFunctionBody(t3, e2, s2), t3.expression = t3.body.type !== "BlockStatement";
          }
          parseMethod(t3, e2, s2, r2, i2, n2) {
            let a2 = arguments.length > 6 && arguments[6] !== void 0 && arguments[6], o2 = this.startNode();
            return o2.kind = t3.kind, o2 = super.parseMethod(o2, e2, s2, r2, i2, n2, a2), o2.type = "FunctionExpression", delete o2.kind, t3.value = o2, n2 === "ClassPrivateMethod" && (t3.computed = false), n2 = "MethodDefinition", this.finishNode(t3, n2);
          }
          parseClassProperty() {
            const t3 = super.parseClassProperty(...arguments);
            return this.getPluginOption("estree", "classFeatures") ? (t3.type = "PropertyDefinition", t3) : t3;
          }
          parseClassPrivateProperty() {
            const t3 = super.parseClassPrivateProperty(...arguments);
            return this.getPluginOption("estree", "classFeatures") ? (t3.type = "PropertyDefinition", t3.computed = false, t3) : t3;
          }
          parseObjectMethod(t3, e2, s2, r2, i2) {
            const n2 = super.parseObjectMethod(t3, e2, s2, r2, i2);
            return n2 && (n2.type = "Property", n2.kind === "method" && (n2.kind = "init"), n2.shorthand = false), n2;
          }
          parseObjectProperty(t3, e2, s2, r2, i2) {
            const n2 = super.parseObjectProperty(t3, e2, s2, r2, i2);
            return n2 && (n2.kind = "init", n2.type = "Property"), n2;
          }
          isAssignable(t3, e2) {
            return t3 != null && this.isObjectProperty(t3) ? this.isAssignable(t3.value, e2) : super.isAssignable(t3, e2);
          }
          toAssignable(t3) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            return t3 != null && this.isObjectProperty(t3) ? (this.toAssignable(t3.value, e2), t3) : super.toAssignable(t3, e2);
          }
          toAssignableObjectExpressionProp(t3) {
            if (t3.kind === "get" || t3.kind === "set")
              this.raise(t3.key.start, Dc.PatternHasAccessor);
            else if (t3.method)
              this.raise(t3.key.start, Dc.PatternHasMethod);
            else {
              for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++)
                s2[r2 - 1] = arguments[r2];
              super.toAssignableObjectExpressionProp(t3, ...s2);
            }
          }
          finishCallExpression(t3, e2) {
            if (super.finishCallExpression(t3, e2), t3.callee.type === "Import") {
              var s2;
              if (t3.type = "ImportExpression", t3.source = t3.arguments[0], this.hasPlugin("importAssertions"))
                t3.attributes = (s2 = t3.arguments[1]) != null ? s2 : null;
              delete t3.arguments, delete t3.callee;
            }
            return t3;
          }
          toReferencedArguments(t3) {
            t3.type !== "ImportExpression" && super.toReferencedArguments(t3);
          }
          parseExport(t3) {
            switch (super.parseExport(t3), t3.type) {
              case "ExportAllDeclaration":
                t3.exported = null;
                break;
              case "ExportNamedDeclaration":
                t3.specifiers.length === 1 && t3.specifiers[0].type === "ExportNamespaceSpecifier" && (t3.type = "ExportAllDeclaration", t3.exported = t3.specifiers[0].exported, delete t3.specifiers);
            }
            return t3;
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            const n2 = super.parseSubscript(t3, e2, s2, r2, i2);
            if (i2.optionalChainMember) {
              if (n2.type !== "OptionalMemberExpression" && n2.type !== "OptionalCallExpression" || (n2.type = n2.type.substring(8)), i2.stop) {
                const t4 = this.startNodeAtNode(n2);
                return t4.expression = n2, this.finishNode(t4, "ChainExpression");
              }
            } else
              n2.type !== "MemberExpression" && n2.type !== "CallExpression" || (n2.optional = false);
            return n2;
          }
          hasPropertyAsPrivateName(t3) {
            return t3.type === "ChainExpression" && (t3 = t3.expression), super.hasPropertyAsPrivateName(t3);
          }
          isOptionalChain(t3) {
            return t3.type === "ChainExpression";
          }
          isObjectProperty(t3) {
            return t3.type === "Property" && t3.kind === "init" && !t3.method;
          }
          isObjectMethod(t3) {
            return t3.method || t3.kind === "get" || t3.kind === "set";
          }
        }, jsx: (t2) => class extends t2 {
          jsxReadToken() {
            let t3 = "", e2 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, Yl.UnterminatedJsxContent);
              const s2 = this.input.charCodeAt(this.state.pos);
              switch (s2) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? s2 === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(132)) : super.getTokenFromCode(s2) : (t3 += this.input.slice(e2, this.state.pos), this.finishToken(131, t3));
                case 38:
                  t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadEntity(), e2 = this.state.pos;
                  break;
                default:
                  ic(s2) ? (t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadNewLine(true), e2 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(t3) {
            const e2 = this.input.charCodeAt(this.state.pos);
            let s2;
            return ++this.state.pos, e2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = t3 ? "\n" : "\r\n") : s2 = String.fromCharCode(e2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
          }
          jsxReadString(t3) {
            let e2 = "", s2 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, Dc.UnterminatedString);
              const r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === t3)
                break;
              r2 === 38 ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadEntity(), s2 = this.state.pos) : ic(r2) ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
            }
            return e2 += this.input.slice(s2, this.state.pos++), this.finishToken(123, e2);
          }
          jsxReadEntity() {
            let t3, e2 = "", s2 = 0, r2 = this.input[this.state.pos];
            const i2 = ++this.state.pos;
            for (; this.state.pos < this.length && s2++ < 10; ) {
              if (r2 = this.input[this.state.pos++], r2 === ";") {
                e2[0] === "#" ? e2[1] === "x" ? (e2 = e2.substr(2), Jl.test(e2) && (t3 = String.fromCodePoint(parseInt(e2, 16)))) : (e2 = e2.substr(1), $l.test(e2) && (t3 = String.fromCodePoint(parseInt(e2, 10)))) : t3 = Xl[e2];
                break;
              }
              e2 += r2;
            }
            return t3 || (this.state.pos = i2, "&");
          }
          jsxReadWord() {
            let t3;
            const e2 = this.state.pos;
            do {
              t3 = this.input.charCodeAt(++this.state.pos);
            } while (sl(t3) || t3 === 45);
            return this.finishToken(130, this.input.slice(e2, this.state.pos));
          }
          jsxParseIdentifier() {
            const t3 = this.startNode();
            return this.match(130) ? t3.name = this.state.value : qc(this.state.type) ? t3.name = Wc(this.state.type) : this.unexpected(), this.next(), this.finishNode(t3, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
            if (!this.eat(14))
              return s2;
            const r2 = this.startNodeAt(t3, e2);
            return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            let s2 = this.jsxParseNamespacedName();
            if (s2.type === "JSXNamespacedName")
              return s2;
            for (; this.eat(16); ) {
              const r2 = this.startNodeAt(t3, e2);
              r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
            }
            return s2;
          }
          jsxParseAttributeValue() {
            let t3;
            switch (this.state.type) {
              case 5:
                return t3 = this.startNode(), this.next(), t3 = this.jsxParseExpressionContainer(t3), t3.expression.type === "JSXEmptyExpression" && this.raise(t3.start, Yl.AttributeIsEmpty), t3;
              case 132:
              case 123:
                return this.parseExprAtom();
              default:
                throw this.raise(this.state.start, Yl.UnsupportedJsxValue);
            }
          }
          jsxParseEmptyExpression() {
            const t3 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
            return this.finishNodeAt(t3, "JSXEmptyExpression", this.state.start, this.state.startLoc);
          }
          jsxParseSpreadChild(t3) {
            return this.next(), t3.expression = this.parseExpression(), this.expect(8), this.finishNode(t3, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(t3) {
            if (this.match(8))
              t3.expression = this.jsxParseEmptyExpression();
            else {
              const e2 = this.parseExpression();
              t3.expression = e2;
            }
            return this.expect(8), this.finishNode(t3, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const t3 = this.startNode();
            return this.eat(5) ? (this.expect(21), t3.argument = this.parseMaybeAssignAllowIn(), this.expect(8), this.finishNode(t3, "JSXSpreadAttribute")) : (t3.name = this.jsxParseNamespacedName(), t3.value = this.eat(27) ? this.jsxParseAttributeValue() : null, this.finishNode(t3, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            return this.match(133) ? (this.expect(133), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
          }
          jsxParseOpeningElementAfterName(t3) {
            const e2 = [];
            for (; !this.match(50) && !this.match(133); )
              e2.push(this.jsxParseAttribute());
            return t3.attributes = e2, t3.selfClosing = this.eat(50), this.expect(133), this.finishNode(t3, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            return this.match(133) ? (this.expect(133), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(133), this.finishNode(s2, "JSXClosingElement"));
          }
          jsxParseElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2), r2 = [], i2 = this.jsxParseOpeningElementAt(t3, e2);
            let n2 = null;
            if (!i2.selfClosing) {
              t:
                for (; ; )
                  switch (this.state.type) {
                    case 132:
                      if (t3 = this.state.start, e2 = this.state.startLoc, this.next(), this.eat(50)) {
                        n2 = this.jsxParseClosingElementAt(t3, e2);
                        break t;
                      }
                      r2.push(this.jsxParseElementAt(t3, e2));
                      break;
                    case 131:
                      r2.push(this.parseExprAtom());
                      break;
                    case 5: {
                      const t4 = this.startNode();
                      this.next(), this.match(21) ? r2.push(this.jsxParseSpreadChild(t4)) : r2.push(this.jsxParseExpressionContainer(t4));
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
              Ql(i2) && !Ql(n2) ? this.raise(n2.start, Yl.MissingClosingTagFragment) : !Ql(i2) && Ql(n2) ? this.raise(n2.start, Yl.MissingClosingTagElement, Zl(i2.name)) : Ql(i2) || Ql(n2) || Zl(n2.name) !== Zl(i2.name) && this.raise(n2.start, Yl.MissingClosingTagElement, Zl(i2.name));
            }
            if (Ql(i2) ? (s2.openingFragment = i2, s2.closingFragment = n2) : (s2.openingElement = i2, s2.closingElement = n2), s2.children = r2, this.match(43))
              throw this.raise(this.state.start, Yl.UnwrappedAdjacentJSXElements);
            return Ql(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
          }
          jsxParseElement() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(t3, e2);
          }
          parseExprAtom(t3) {
            return this.match(131) ? this.parseLiteral(this.state.value, "JSXText") : this.match(132) ? this.jsxParseElement() : this.match(43) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(132), this.jsxParseElement()) : super.parseExprAtom(t3);
          }
          getTokenFromCode(t3) {
            const e2 = this.curContext();
            if (e2 === Ac.j_expr)
              return this.jsxReadToken();
            if (e2 === Ac.j_oTag || e2 === Ac.j_cTag) {
              if (el(t3))
                return this.jsxReadWord();
              if (t3 === 62)
                return ++this.state.pos, this.finishToken(133);
              if ((t3 === 34 || t3 === 39) && e2 === Ac.j_oTag)
                return this.jsxReadString(t3);
            }
            return t3 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(132)) : super.getTokenFromCode(t3);
          }
          updateContext(t3) {
            super.updateContext(t3);
            const { context: e2, type: s2 } = this.state;
            if (s2 === 50 && t3 === 132)
              e2.splice(-2, 2, Ac.j_cTag), this.state.canStartJSXElement = false;
            else if (s2 === 132)
              e2.push(Ac.j_expr, Ac.j_oTag);
            else if (s2 === 133) {
              const s3 = e2.pop();
              s3 === Ac.j_oTag && t3 === 50 || s3 === Ac.j_cTag ? (e2.pop(), this.state.canStartJSXElement = e2[e2.length - 1] === Ac.j_expr) : this.state.canStartJSXElement = true;
            } else
              this.state.canStartJSXElement = kc[s2];
          }
        }, flow: (t2) => class extends t2 {
          constructor() {
            super(...arguments), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Fl;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(t3, e2) {
            return t3 !== 123 && t3 !== 13 && t3 !== 26 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(t3, e2);
          }
          addComment(t3) {
            if (this.flowPragma === void 0) {
              const e2 = Gl.exec(t3.value);
              if (e2)
                if (e2[1] === "flow")
                  this.flowPragma = "flow";
                else {
                  if (e2[1] !== "noflow")
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
              else
                ;
            }
            return super.addComment(t3);
          }
          flowParseTypeInitialiser(t3) {
            const e2 = this.state.inType;
            this.state.inType = true, this.expect(t3 || 14);
            const s2 = this.flowParseType();
            return this.state.inType = e2, s2;
          }
          flowParsePredicate() {
            const t3 = this.startNode(), e2 = this.state.start;
            return this.next(), this.expectContextual(101), this.state.lastTokStart > e2 + 1 && this.raise(e2, Vl.UnexpectedSpaceBetweenModuloChecks), this.eat(10) ? (t3.value = this.parseExpression(), this.expect(11), this.finishNode(t3, "DeclaredPredicate")) : this.finishNode(t3, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const t3 = this.state.inType;
            this.state.inType = true, this.expect(14);
            let e2 = null, s2 = null;
            return this.match(48) ? (this.state.inType = t3, s2 = this.flowParsePredicate()) : (e2 = this.flowParseType(), this.state.inType = t3, this.match(48) && (s2 = this.flowParsePredicate())), [e2, s2];
          }
          flowParseDeclareClass(t3) {
            return this.next(), this.flowParseInterfaceish(t3, true), this.finishNode(t3, "DeclareClass");
          }
          flowParseDeclareFunction(t3) {
            this.next();
            const e2 = t3.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
            this.match(43) ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(10);
            const i2 = this.flowParseFunctionTypeParams();
            return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(11), [s2.returnType, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), e2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(e2), this.semicolon(), this.scope.declareName(t3.id.name, 2048, t3.id.start), this.finishNode(t3, "DeclareFunction");
          }
          flowParseDeclare(t3, e2) {
            if (this.match(74))
              return this.flowParseDeclareClass(t3);
            if (this.match(62))
              return this.flowParseDeclareFunction(t3);
            if (this.match(68))
              return this.flowParseDeclareVariable(t3);
            if (this.eatContextual(117))
              return this.match(16) ? this.flowParseDeclareModuleExports(t3) : (e2 && this.raise(this.state.lastTokStart, Vl.NestedDeclareModule), this.flowParseDeclareModule(t3));
            if (this.isContextual(120))
              return this.flowParseDeclareTypeAlias(t3);
            if (this.isContextual(121))
              return this.flowParseDeclareOpaqueType(t3);
            if (this.isContextual(119))
              return this.flowParseDeclareInterface(t3);
            if (this.match(76))
              return this.flowParseDeclareExportDeclaration(t3, e2);
            throw this.unexpected();
          }
          flowParseDeclareVariable(t3) {
            return this.next(), t3.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(t3.id.name, 5, t3.id.start), this.semicolon(), this.finishNode(t3, "DeclareVariable");
          }
          flowParseDeclareModule(t3) {
            this.scope.enter(0), this.match(123) ? t3.id = this.parseExprAtom() : t3.id = this.parseIdentifier();
            const e2 = t3.body = this.startNode(), s2 = e2.body = [];
            for (this.expect(5); !this.match(8); ) {
              let t4 = this.startNode();
              this.match(77) ? (this.next(), this.isContextual(120) || this.match(81) || this.raise(this.state.lastTokStart, Vl.InvalidNonTypeImportInDeclareModule), this.parseImport(t4)) : (this.expectContextual(115, Vl.UnsupportedStatementInDeclareModule), t4 = this.flowParseDeclare(t4, true)), s2.push(t4);
            }
            this.scope.exit(), this.expect(8), this.finishNode(e2, "BlockStatement");
            let r2 = null, i2 = false;
            return s2.forEach((t4) => {
              !function(t5) {
                return t5.type === "DeclareExportAllDeclaration" || t5.type === "DeclareExportDeclaration" && (!t5.declaration || t5.declaration.type !== "TypeAlias" && t5.declaration.type !== "InterfaceDeclaration");
              }(t4) ? t4.type === "DeclareModuleExports" && (i2 && this.raise(t4.start, Vl.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(t4.start, Vl.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(t4.start, Vl.AmbiguousDeclareModuleKind), r2 = "ES");
            }), t3.kind = r2 || "CommonJS", this.finishNode(t3, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(t3, e2) {
            if (this.expect(76), this.eat(59))
              return this.match(62) || this.match(74) ? t3.declaration = this.flowParseDeclare(this.startNode()) : (t3.declaration = this.flowParseType(), this.semicolon()), t3.default = true, this.finishNode(t3, "DeclareExportDeclaration");
            if (this.match(69) || this.isLet() || (this.isContextual(120) || this.isContextual(119)) && !e2) {
              const t4 = this.state.value, e3 = Kl[t4];
              throw this.raise(this.state.start, Vl.UnsupportedDeclareExportKind, t4, e3);
            }
            if (this.match(68) || this.match(62) || this.match(74) || this.isContextual(121))
              return t3.declaration = this.flowParseDeclare(this.startNode()), t3.default = false, this.finishNode(t3, "DeclareExportDeclaration");
            if (this.match(49) || this.match(5) || this.isContextual(119) || this.isContextual(120) || this.isContextual(121))
              return (t3 = this.parseExport(t3)).type === "ExportNamedDeclaration" && (t3.type = "ExportDeclaration", t3.default = false, delete t3.exportKind), t3.type = "Declare" + t3.type, t3;
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(t3) {
            return this.next(), this.expectContextual(102), t3.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t3, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(t3) {
            return this.next(), this.flowParseTypeAlias(t3), t3.type = "DeclareTypeAlias", t3;
          }
          flowParseDeclareOpaqueType(t3) {
            return this.next(), this.flowParseOpaqueType(t3, true), t3.type = "DeclareOpaqueType", t3;
          }
          flowParseDeclareInterface(t3) {
            return this.next(), this.flowParseInterfaceish(t3), this.finishNode(t3, "DeclareInterface");
          }
          flowParseInterfaceish(t3) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            if (t3.id = this.flowParseRestrictedIdentifier(!e2, true), this.scope.declareName(t3.id.name, e2 ? 17 : 9, t3.id.start), this.match(43) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.extends = [], t3.implements = [], t3.mixins = [], this.eat(75))
              do {
                t3.extends.push(this.flowParseInterfaceExtends());
              } while (!e2 && this.eat(12));
            if (this.isContextual(108)) {
              this.next();
              do {
                t3.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            if (this.isContextual(104)) {
              this.next();
              do {
                t3.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            t3.body = this.flowParseObjectType({ allowStatic: e2, allowExact: false, allowSpread: false, allowProto: e2, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const t3 = this.startNode();
            return t3.id = this.flowParseQualifiedTypeIdentifier(), this.match(43) ? t3.typeParameters = this.flowParseTypeParameterInstantiation() : t3.typeParameters = null, this.finishNode(t3, "InterfaceExtends");
          }
          flowParseInterface(t3) {
            return this.flowParseInterfaceish(t3), this.finishNode(t3, "InterfaceDeclaration");
          }
          checkNotUnderscore(t3) {
            t3 === "_" && this.raise(this.state.start, Vl.UnexpectedReservedUnderscore);
          }
          checkReservedType(t3, e2, s2) {
            Hl.has(t3) && this.raise(e2, s2 ? Vl.AssignReservedType : Vl.UnexpectedReservedType, t3);
          }
          flowParseRestrictedIdentifier(t3, e2) {
            return this.checkReservedType(this.state.value, this.state.start, e2), this.parseIdentifier(t3);
          }
          flowParseTypeAlias(t3) {
            return t3.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(t3.id.name, 9, t3.id.start), this.match(43) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.right = this.flowParseTypeInitialiser(27), this.semicolon(), this.finishNode(t3, "TypeAlias");
          }
          flowParseOpaqueType(t3, e2) {
            return this.expectContextual(120), t3.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(t3.id.name, 9, t3.id.start), this.match(43) ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.supertype = null, this.match(14) && (t3.supertype = this.flowParseTypeInitialiser(14)), t3.impltype = null, e2 || (t3.impltype = this.flowParseTypeInitialiser(27)), this.semicolon(), this.finishNode(t3, "OpaqueType");
          }
          flowParseTypeParameter() {
            let t3 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            const e2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
            return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(27) ? (this.eat(27), s2.default = this.flowParseType()) : t3 && this.raise(e2, Vl.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const t3 = this.state.inType, e2 = this.startNode();
            e2.params = [], this.state.inType = true, this.match(43) || this.match(132) ? this.next() : this.unexpected();
            let s2 = false;
            do {
              const t4 = this.flowParseTypeParameter(s2);
              e2.params.push(t4), t4.default && (s2 = true), this.match(44) || this.expect(12);
            } while (!this.match(44));
            return this.expect(44), this.state.inType = t3, this.finishNode(e2, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const t3 = this.startNode(), e2 = this.state.inType;
            t3.params = [], this.state.inType = true, this.expect(43);
            const s2 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(44); )
              t3.params.push(this.flowParseType()), this.match(44) || this.expect(12);
            return this.state.noAnonFunctionType = s2, this.expect(44), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const t3 = this.startNode(), e2 = this.state.inType;
            for (t3.params = [], this.state.inType = true, this.expect(43); !this.match(44); )
              t3.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(44) || this.expect(12);
            return this.expect(44), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const t3 = this.startNode();
            if (this.expectContextual(119), t3.extends = [], this.eat(75))
              do {
                t3.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            return t3.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(t3, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(124) || this.match(123) ? this.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(t3, e2, s2) {
            return t3.static = e2, this.lookahead().type === 14 ? (t3.id = this.flowParseObjectPropertyKey(), t3.key = this.flowParseTypeInitialiser()) : (t3.id = null, t3.key = this.flowParseType()), this.expect(3), t3.value = this.flowParseTypeInitialiser(), t3.variance = s2, this.finishNode(t3, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(t3, e2) {
            return t3.static = e2, t3.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(43) || this.match(10) ? (t3.method = true, t3.optional = false, t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.start, t3.loc.start))) : (t3.method = false, this.eat(17) && (t3.optional = true), t3.value = this.flowParseTypeInitialiser()), this.finishNode(t3, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(t3) {
            for (t3.params = [], t3.rest = null, t3.typeParameters = null, t3.this = null, this.match(43) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(72) && (t3.this = this.flowParseFunctionTypeParam(true), t3.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              t3.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (t3.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), t3.returnType = this.flowParseTypeInitialiser(), this.finishNode(t3, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(t3, e2) {
            const s2 = this.startNode();
            return t3.static = e2, t3.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(t3, "ObjectTypeCallProperty");
          }
          flowParseObjectType(t3) {
            let { allowStatic: e2, allowExact: s2, allowSpread: r2, allowProto: i2, allowInexact: n2 } = t3;
            const a2 = this.state.inType;
            this.state.inType = true;
            const o2 = this.startNode();
            let u2, h2;
            o2.callProperties = [], o2.properties = [], o2.indexers = [], o2.internalSlots = [];
            let p2 = false;
            for (s2 && this.match(6) ? (this.expect(6), u2 = 9, h2 = true) : (this.expect(5), u2 = 8, h2 = false), o2.exact = h2; !this.match(u2); ) {
              let t4 = false, s3 = null, a3 = null;
              const u3 = this.startNode();
              if (i2 && this.isContextual(109)) {
                const t5 = this.lookahead();
                t5.type !== 14 && t5.type !== 17 && (this.next(), s3 = this.state.start, e2 = false);
              }
              if (e2 && this.isContextual(98)) {
                const e3 = this.lookahead();
                e3.type !== 14 && e3.type !== 17 && (this.next(), t4 = true);
              }
              const c3 = this.flowParseVariance();
              if (this.eat(0))
                s3 != null && this.unexpected(s3), this.eat(0) ? (c3 && this.unexpected(c3.start), o2.internalSlots.push(this.flowParseObjectTypeInternalSlot(u3, t4))) : o2.indexers.push(this.flowParseObjectTypeIndexer(u3, t4, c3));
              else if (this.match(10) || this.match(43))
                s3 != null && this.unexpected(s3), c3 && this.unexpected(c3.start), o2.callProperties.push(this.flowParseObjectTypeCallProperty(u3, t4));
              else {
                let e3 = "init";
                if (this.isContextual(92) || this.isContextual(97)) {
                  zc(this.lookahead().type) && (e3 = this.state.value, this.next());
                }
                const i3 = this.flowParseObjectTypeProperty(u3, t4, s3, c3, e3, r2, n2 != null ? n2 : !h2);
                i3 === null ? (p2 = true, a3 = this.state.lastTokStart) : o2.properties.push(i3);
              }
              this.flowObjectTypeSemicolon(), !a3 || this.match(8) || this.match(9) || this.raise(a3, Vl.UnexpectedExplicitInexactInObject);
            }
            this.expect(u2), r2 && (o2.inexact = p2);
            const c2 = this.finishNode(o2, "ObjectTypeAnnotation");
            return this.state.inType = a2, c2;
          }
          flowParseObjectTypeProperty(t3, e2, s2, r2, i2, n2, a2) {
            if (this.eat(21)) {
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (n2 ? a2 || this.raise(this.state.lastTokStart, Vl.InexactInsideExact) : this.raise(this.state.lastTokStart, Vl.InexactInsideNonObject), r2 && this.raise(r2.start, Vl.InexactVariance), null) : (n2 || this.raise(this.state.lastTokStart, Vl.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Vl.SpreadVariance), t3.argument = this.flowParseType(), this.finishNode(t3, "ObjectTypeSpreadProperty"));
            }
            {
              t3.key = this.flowParseObjectPropertyKey(), t3.static = e2, t3.proto = s2 != null, t3.kind = i2;
              let a3 = false;
              return this.match(43) || this.match(10) ? (t3.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.start, t3.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(t3), !n2 && t3.key.name === "constructor" && t3.value.this && this.raise(t3.value.this.start, Vl.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), t3.method = false, this.eat(17) && (a3 = true), t3.value = this.flowParseTypeInitialiser(), t3.variance = r2), t3.optional = a3, this.finishNode(t3, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(t3) {
            const e2 = t3.kind === "get" ? 0 : 1, s2 = t3.start, r2 = t3.value.params.length + (t3.value.rest ? 1 : 0);
            t3.value.this && this.raise(t3.value.this.start, t3.kind === "get" ? Vl.GetterMayNotHaveThisParam : Vl.SetterMayNotHaveThisParam), r2 !== e2 && (t3.kind === "get" ? this.raise(s2, Dc.BadGetterArity) : this.raise(s2, Dc.BadSetterArity)), t3.kind === "set" && t3.value.rest && this.raise(s2, Dc.BadSetterRestParameter);
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(t3, e2, s2) {
            t3 = t3 || this.state.start, e2 = e2 || this.state.startLoc;
            let r2 = s2 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const s3 = this.startNodeAt(t3, e2);
              s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
            }
            return r2;
          }
          flowParseGenericType(t3, e2, s2) {
            const r2 = this.startNodeAt(t3, e2);
            return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(t3, e2, s2), this.match(43) && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const t3 = this.startNode();
            return this.expect(81), t3.argument = this.flowParsePrimaryType(), this.finishNode(t3, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const t3 = this.startNode();
            for (t3.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (t3.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(t3, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(t3) {
            let e2 = null, s2 = false, r2 = null;
            const i2 = this.startNode(), n2 = this.lookahead(), a2 = this.state.type === 72;
            return n2.type === 14 || n2.type === 17 ? (a2 && !t3 && this.raise(i2.start, Vl.ThisParamMustBeFirst), e2 = this.parseIdentifier(a2), this.eat(17) && (s2 = true, a2 && this.raise(i2.start, Vl.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = e2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(t3) {
            const e2 = this.startNodeAt(t3.start, t3.loc.start);
            return e2.name = null, e2.optional = false, e2.typeAnnotation = t3, this.finishNode(e2, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams() {
            let t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e2 = null, s2 = null;
            for (this.match(72) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              t3.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e2 = this.flowParseFunctionTypeParam(false)), { params: t3, rest: e2, _this: s2 };
          }
          flowIdentToTypeAnnotation(t3, e2, s2, r2) {
            switch (r2.name) {
              case "any":
                return this.finishNode(s2, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s2, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s2, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s2, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s2, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s2, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s2, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(r2.name), this.flowParseGenericType(t3, e2, r2);
            }
          }
          flowParsePrimaryType() {
            const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.startNode();
            let r2, i2, n2 = false;
            const a2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = a2, i2;
              case 43:
                return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
              case 10:
                if (this.next(), !this.match(11) && !this.match(21))
                  if (Uc(this.state.type) || this.match(72)) {
                    const t4 = this.lookahead().type;
                    n2 = t4 !== 17 && t4 !== 14;
                  } else
                    n2 = true;
                if (n2) {
                  if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = a2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                    return this.expect(11), i2;
                  this.eat(12);
                }
                return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
              case 123:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 79:
              case 80:
                return s2.value = this.match(79), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
              case 47:
                if (this.state.value === "-") {
                  if (this.next(), this.match(124))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
                  if (this.match(125))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
                  throw this.raise(this.state.start, Vl.UnexpectedSubtractionOperand);
                }
                throw this.unexpected();
              case 124:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 125:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 82:
                return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
              case 72:
                return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
              case 49:
                return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
              case 81:
                return this.flowParseTypeofType();
              default:
                if (qc(this.state.type)) {
                  const t4 = Wc(this.state.type);
                  return this.next(), super.createIdentifier(s2, t4);
                }
                if (Uc(this.state.type))
                  return this.isContextual(119) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t3, e2, s2, this.parseIdentifier());
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            let s2 = this.flowParsePrimaryType(), r2 = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const i2 = this.startNodeAt(t3, e2), n2 = this.eat(18);
              r2 = r2 || n2, this.expect(0), !n2 && this.match(3) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(3), r2 ? (i2.optional = n2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
            }
            return s2;
          }
          flowParsePrefixType() {
            const t3 = this.startNode();
            return this.eat(17) ? (t3.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t3, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const t3 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const e2 = this.startNodeAt(t3.start, t3.loc.start);
              return e2.params = [this.reinterpretTypeAsFunctionTypeParam(t3)], e2.rest = null, e2.this = null, e2.returnType = this.flowParseType(), e2.typeParameters = null, this.finishNode(e2, "FunctionTypeAnnotation");
            }
            return t3;
          }
          flowParseIntersectionType() {
            const t3 = this.startNode();
            this.eat(41);
            const e2 = this.flowParseAnonFunctionWithoutParens();
            for (t3.types = [e2]; this.eat(41); )
              t3.types.push(this.flowParseAnonFunctionWithoutParens());
            return t3.types.length === 1 ? e2 : this.finishNode(t3, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const t3 = this.startNode();
            this.eat(39);
            const e2 = this.flowParseIntersectionType();
            for (t3.types = [e2]; this.eat(39); )
              t3.types.push(this.flowParseIntersectionType());
            return t3.types.length === 1 ? e2 : this.finishNode(t3, "UnionTypeAnnotation");
          }
          flowParseType() {
            const t3 = this.state.inType;
            this.state.inType = true;
            const e2 = this.flowParseUnionType();
            return this.state.inType = t3, e2;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 122 && this.state.value === "_") {
              const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.parseIdentifier();
              return this.flowParseGenericType(t3, e2, s2);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const t3 = this.startNode();
            return t3.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t3, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(t3) {
            const e2 = t3 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2)), e2;
          }
          typeCastToParameter(t3) {
            return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.end, t3.typeAnnotation.loc.end), t3.expression;
          }
          flowParseVariance() {
            let t3 = null;
            return this.match(47) && (t3 = this.startNode(), this.state.value === "+" ? t3.kind = "plus" : t3.kind = "minus", this.next(), this.finishNode(t3, "Variance")), t3;
          }
          parseFunctionBody(t3, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            return e2 ? this.forwardNoArrowParamsConversionAt(t3, () => super.parseFunctionBody(t3, true, s2)) : super.parseFunctionBody(t3, false, s2);
          }
          parseFunctionBodyAndFinish(t3, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            if (this.match(14)) {
              const e3 = this.startNode();
              [e3.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), t3.returnType = e3.typeAnnotation ? this.finishNode(e3, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(t3, e2, s2);
          }
          parseStatement(t3, e2) {
            if (this.state.strict && this.isContextual(119)) {
              if (_c(this.lookahead().type)) {
                const t4 = this.startNode();
                return this.next(), this.flowParseInterface(t4);
              }
            } else if (this.shouldParseEnums() && this.isContextual(116)) {
              const t4 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t4);
            }
            const s2 = super.parseStatement(t3, e2);
            return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
          }
          parseExpressionStatement(t3, e2) {
            if (e2.type === "Identifier") {
              if (e2.name === "declare") {
                if (this.match(74) || Uc(this.state.type) || this.match(62) || this.match(68) || this.match(76))
                  return this.flowParseDeclare(t3);
              } else if (Uc(this.state.type)) {
                if (e2.name === "interface")
                  return this.flowParseInterface(t3);
                if (e2.name === "type")
                  return this.flowParseTypeAlias(t3);
                if (e2.name === "opaque")
                  return this.flowParseOpaqueType(t3, false);
              }
            }
            return super.parseExpressionStatement(t3, e2);
          }
          shouldParseExportDeclaration() {
            const { type: t3 } = this.state;
            return Vc(t3) || this.shouldParseEnums() && t3 === 116 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: t3 } = this.state;
            return Vc(t3) || this.shouldParseEnums() && t3 === 116 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(116)) {
              const t3 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t3);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(t3, e2, s2, r2) {
            if (!this.match(17))
              return t3;
            if (this.state.maybeInArrowParameters) {
              const e3 = this.lookaheadCharCode();
              if (e3 === 44 || e3 === 61 || e3 === 58 || e3 === 41)
                return this.setOptionalParametersError(r2), t3;
            }
            this.expect(17);
            const i2 = this.state.clone(), n2 = this.state.noArrowAt, a2 = this.startNodeAt(e2, s2);
            let { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent(), [h2, p2] = this.getArrowLikeExpressions(o2);
            if (u2 || p2.length > 0) {
              const t4 = [...n2];
              if (p2.length > 0) {
                this.state = i2, this.state.noArrowAt = t4;
                for (let e3 = 0; e3 < p2.length; e3++)
                  t4.push(p2[e3].start);
                ({ consequent: o2, failed: u2 } = this.tryParseConditionalConsequent()), [h2, p2] = this.getArrowLikeExpressions(o2);
              }
              u2 && h2.length > 1 && this.raise(i2.start, Vl.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, t4.push(h2[0].start), this.state.noArrowAt = t4, { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = n2, this.expect(14), a2.test = t3, a2.consequent = o2, a2.alternate = this.forwardNoArrowParamsConversionAt(a2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(a2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const t3 = this.parseMaybeAssignAllowIn(), e2 = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: t3, failed: e2 };
          }
          getArrowLikeExpressions(t3, e2) {
            const s2 = [t3], r2 = [];
            for (; s2.length !== 0; ) {
              const t4 = s2.pop();
              t4.type === "ArrowFunctionExpression" ? (t4.typeParameters || !t4.returnType ? this.finishArrowValidation(t4) : r2.push(t4), s2.push(t4.body)) : t4.type === "ConditionalExpression" && (s2.push(t4.consequent), s2.push(t4.alternate));
            }
            return e2 ? (r2.forEach((t4) => this.finishArrowValidation(t4)), [r2, []]) : function(t4, e3) {
              const s3 = [], r3 = [];
              for (let i2 = 0; i2 < t4.length; i2++)
                (e3(t4[i2], i2, t4) ? s3 : r3).push(t4[i2]);
              return [s3, r3];
            }(r2, (t4) => t4.params.every((t5) => this.isAssignable(t5, true)));
          }
          finishArrowValidation(t3) {
            var e2;
            this.toAssignableList(t3.params, (e2 = t3.extra) == null ? void 0 : e2.trailingComma, false), this.scope.enter(6), super.checkParams(t3, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(t3, e2) {
            let s2;
            return this.state.noArrowParamsConversionAt.indexOf(t3.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = e2(), this.state.noArrowParamsConversionAt.pop()) : s2 = e2(), s2;
          }
          parseParenItem(t3, e2, s2) {
            if (t3 = super.parseParenItem(t3, e2, s2), this.eat(17) && (t3.optional = true, this.resetEndLocation(t3)), this.match(14)) {
              const r2 = this.startNodeAt(e2, s2);
              return r2.expression = t3, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
            }
            return t3;
          }
          assertModuleNodeAllowed(t3) {
            t3.type === "ImportDeclaration" && (t3.importKind === "type" || t3.importKind === "typeof") || t3.type === "ExportNamedDeclaration" && t3.exportKind === "type" || t3.type === "ExportAllDeclaration" && t3.exportKind === "type" || super.assertModuleNodeAllowed(t3);
          }
          parseExport(t3) {
            const e2 = super.parseExport(t3);
            return e2.type !== "ExportNamedDeclaration" && e2.type !== "ExportAllDeclaration" || (e2.exportKind = e2.exportKind || "value"), e2;
          }
          parseExportDeclaration(t3) {
            if (this.isContextual(120)) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.match(5) ? (t3.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(t3), null) : this.flowParseTypeAlias(e2);
            }
            if (this.isContextual(121)) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.flowParseOpaqueType(e2, false);
            }
            if (this.isContextual(119)) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.flowParseInterface(e2);
            }
            if (this.shouldParseEnums() && this.isContextual(116)) {
              t3.exportKind = "value";
              const e2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e2);
            }
            return super.parseExportDeclaration(t3);
          }
          eatExportStar(t3) {
            return !!super.eatExportStar(...arguments) || !(!this.isContextual(120) || this.lookahead().type !== 49) && (t3.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(t3) {
            const e2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(t3);
            return s2 && t3.exportKind === "type" && this.unexpected(e2), s2;
          }
          parseClassId(t3, e2, s2) {
            super.parseClassId(t3, e2, s2), this.match(43) && (t3.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(t3, e2, s2) {
            const r2 = this.state.start;
            if (this.isContextual(115)) {
              if (this.parseClassMemberFromModifier(t3, e2))
                return;
              e2.declare = true;
            }
            super.parseClassMember(t3, e2, s2), e2.declare && (e2.type !== "ClassProperty" && e2.type !== "ClassPrivateProperty" && e2.type !== "PropertyDefinition" ? this.raise(r2, Vl.DeclareClassElement) : e2.value && this.raise(e2.value.start, Vl.DeclareClassFieldInitializer));
          }
          isIterator(t3) {
            return t3 === "iterator" || t3 === "asyncIterator";
          }
          readIterator() {
            const t3 = super.readWord1(), e2 = "@@" + t3;
            this.isIterator(t3) && this.state.inType || this.raise(this.state.pos, Dc.InvalidIdentifier, e2), this.finishToken(122, e2);
          }
          getTokenFromCode(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            return t3 === 123 && e2 === 124 ? this.finishOp(6, 2) : !this.state.inType || t3 !== 62 && t3 !== 60 ? this.state.inType && t3 === 63 ? e2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(t4, e3) {
              return t4 === 64 && e3 === 64;
            }(t3, e2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(t3) : this.finishOp(t3 === 62 ? 44 : 43, 1);
          }
          isAssignable(t3, e2) {
            return t3.type === "TypeCastExpression" ? this.isAssignable(t3.expression, e2) : super.isAssignable(t3, e2);
          }
          toAssignable(t3) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            return t3.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(t3), e2) : super.toAssignable(t3, e2);
          }
          toAssignableList(t3, e2, s2) {
            for (let e3 = 0; e3 < t3.length; e3++) {
              const s3 = t3[e3];
              (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (t3[e3] = this.typeCastToParameter(s3));
            }
            return super.toAssignableList(t3, e2, s2);
          }
          toReferencedList(t3, e2) {
            for (let r2 = 0; r2 < t3.length; r2++) {
              var s2;
              const i2 = t3[r2];
              !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(t3.length > 1) && e2 || this.raise(i2.typeAnnotation.start, Vl.TypeCastInPattern);
            }
            return t3;
          }
          parseArrayLike(t3, e2, s2, r2) {
            const i2 = super.parseArrayLike(t3, e2, s2, r2);
            return e2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
          }
          checkLVal(t3) {
            if (t3.type !== "TypeCastExpression") {
              for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++)
                s2[r2 - 1] = arguments[r2];
              return super.checkLVal(t3, ...s2);
            }
          }
          parseClassProperty(t3) {
            return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t3);
          }
          parseClassPrivateProperty(t3) {
            return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t3);
          }
          isClassMethod() {
            return this.match(43) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(t3) {
            return !this.match(14) && super.isNonstaticConstructor(t3);
          }
          pushClassMethod(t3, e2, s2, r2, i2, n2) {
            if (e2.variance && this.unexpected(e2.variance.start), delete e2.variance, this.match(43) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t3, e2, s2, r2, i2, n2), e2.params && i2) {
              const t4 = e2.params;
              t4.length > 0 && this.isThisParam(t4[0]) && this.raise(e2.start, Vl.ThisParamBannedInConstructor);
            } else if (e2.type === "MethodDefinition" && i2 && e2.value.params) {
              const t4 = e2.value.params;
              t4.length > 0 && this.isThisParam(t4[0]) && this.raise(e2.start, Vl.ThisParamBannedInConstructor);
            }
          }
          pushClassPrivateMethod(t3, e2, s2, r2) {
            e2.variance && this.unexpected(e2.variance.start), delete e2.variance, this.match(43) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t3, e2, s2, r2);
          }
          parseClassSuper(t3) {
            if (super.parseClassSuper(t3), t3.superClass && this.match(43) && (t3.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(104)) {
              this.next();
              const e2 = t3.implements = [];
              do {
                const t4 = this.startNode();
                t4.id = this.flowParseRestrictedIdentifier(true), this.match(43) ? t4.typeParameters = this.flowParseTypeParameterInstantiation() : t4.typeParameters = null, e2.push(this.finishNode(t4, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(t3) {
            super.checkGetterSetterParams(t3);
            const e2 = this.getObjectOrClassMethodParams(t3);
            if (e2.length > 0) {
              const s2 = e2[0];
              this.isThisParam(s2) && t3.kind === "get" ? this.raise(s2.start, Vl.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Vl.SetterMayNotHaveThisParam);
            }
          }
          parsePropertyNamePrefixOperator(t3) {
            t3.variance = this.flowParseVariance();
          }
          parseObjPropValue(t3, e2, s2, r2, i2, n2, a2, o2) {
            let u2;
            t3.variance && this.unexpected(t3.variance.start), delete t3.variance, this.match(43) && !a2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(t3, e2, s2, r2, i2, n2, a2, o2), u2 && ((t3.value || t3).typeParameters = u2);
          }
          parseAssignableListItemTypes(t3) {
            return this.eat(17) && (t3.type !== "Identifier" && this.raise(t3.start, Vl.PatternIsOptional), this.isThisParam(t3) && this.raise(t3.start, Vl.ThisParamMayNotBeOptional), t3.optional = true), this.match(14) ? t3.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t3) && this.raise(t3.start, Vl.ThisParamAnnotationRequired), this.match(27) && this.isThisParam(t3) && this.raise(t3.start, Vl.ThisParamNoDefault), this.resetEndLocation(t3), t3;
          }
          parseMaybeDefault(t3, e2, s2) {
            const r2 = super.parseMaybeDefault(t3, e2, s2);
            return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Vl.TypeBeforeInitializer), r2;
          }
          shouldParseDefaultImport(t3) {
            return ql(t3) ? Wl(this.state.type) : super.shouldParseDefaultImport(t3);
          }
          parseImportSpecifierLocal(t3, e2, s2, r2) {
            e2.local = ql(t3) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(e2.local, r2, 9), t3.specifiers.push(this.finishNode(e2, s2));
          }
          maybeParseDefaultImportSpecifier(t3) {
            t3.importKind = "value";
            let e2 = null;
            if (this.match(81) ? e2 = "typeof" : this.isContextual(120) && (e2 = "type"), e2) {
              const s2 = this.lookahead(), { type: r2 } = s2;
              e2 === "type" && r2 === 49 && this.unexpected(s2.start), (Wl(r2) || r2 === 5 || r2 === 49) && (this.next(), t3.importKind = e2);
            }
            return super.maybeParseDefaultImportSpecifier(t3);
          }
          parseImportSpecifier(t3, e2, s2, r2) {
            const i2 = t3.imported;
            let n2 = null;
            i2.type === "Identifier" && (i2.name === "type" ? n2 = "type" : i2.name === "typeof" && (n2 = "typeof"));
            let a2 = false;
            if (this.isContextual(87) && !this.isLookaheadContextual("as")) {
              const e3 = this.parseIdentifier(true);
              n2 === null || _c(this.state.type) ? (t3.imported = i2, t3.importKind = null, t3.local = this.parseIdentifier()) : (t3.imported = e3, t3.importKind = n2, t3.local = _l(e3));
            } else {
              if (n2 !== null && _c(this.state.type))
                t3.imported = this.parseIdentifier(true), t3.importKind = n2;
              else {
                if (e2)
                  throw this.raise(t3.start, Dc.ImportBindingIsString, i2.value);
                t3.imported = i2, t3.importKind = null;
              }
              this.eatContextual(87) ? t3.local = this.parseIdentifier() : (a2 = true, t3.local = _l(t3.imported));
            }
            const o2 = ql(t3);
            return s2 && o2 && this.raise(t3.start, Vl.ImportTypeShorthandOnlyInPureImport), (s2 || o2) && this.checkReservedType(t3.local.name, t3.local.start, true), !a2 || s2 || o2 || this.checkReservedWord(t3.local.name, t3.start, true, true), this.checkLVal(t3.local, "import specifier", 9), this.finishNode(t3, "ImportSpecifier");
          }
          parseBindingAtom() {
            return this.state.type === 72 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(t3, e2) {
            const s2 = t3.kind;
            s2 !== "get" && s2 !== "set" && this.match(43) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t3, e2);
          }
          parseVarId(t3, e2) {
            super.parseVarId(t3, e2), this.match(14) && (t3.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3.id));
          }
          parseAsyncArrowFromCallExpression(t3, e2) {
            if (this.match(14)) {
              const e3 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, t3.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e3;
            }
            return super.parseAsyncArrowFromCallExpression(t3, e2);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(t3, e2) {
            var s2;
            let r2, i2 = null;
            if (this.hasPlugin("jsx") && (this.match(132) || this.match(43))) {
              if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(t3, e2), i2), !r2.error)
                return r2.node;
              const { context: s3 } = this.state, n3 = s3[s3.length - 1];
              n3 === Ac.j_oTag ? s3.length -= 2 : n3 === Ac.j_expr && (s3.length -= 1);
            }
            if ((s2 = r2) != null && s2.error || this.match(43)) {
              var n2, a2;
              let s3;
              i2 = i2 || this.state.clone();
              const o2 = this.tryParse((r3) => {
                var i3;
                s3 = this.flowParseTypeParameterDeclaration();
                const n3 = this.forwardNoArrowParamsConversionAt(s3, () => {
                  const r4 = super.parseMaybeAssign(t3, e2);
                  return this.resetStartLocationFromNode(r4, s3), r4;
                });
                (i3 = n3.extra) != null && i3.parenthesized && r3();
                const a3 = this.maybeUnwrapTypeCastExpression(n3);
                return a3.type !== "ArrowFunctionExpression" && r3(), a3.typeParameters = s3, this.resetStartLocationFromNode(a3, s3), n3;
              }, i2);
              let u2 = null;
              if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
                if (!o2.error && !o2.aborted)
                  return o2.node.async && this.raise(s3.start, Vl.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
                u2 = o2.node;
              }
              if ((n2 = r2) != null && n2.node)
                return this.state = r2.failState, r2.node;
              if (u2)
                return this.state = o2.failState, u2;
              if ((a2 = r2) != null && a2.thrown)
                throw r2.error;
              if (o2.thrown)
                throw o2.error;
              throw this.raise(s3.start, Vl.UnexpectedTokenAfterTypeParameter);
            }
            return super.parseMaybeAssign(t3, e2);
          }
          parseArrow(t3) {
            if (this.match(14)) {
              const e2 = this.tryParse(() => {
                const e3 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const s2 = this.startNode();
                return [s2.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e3, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), s2;
              });
              if (e2.thrown)
                return null;
              e2.error && (this.state = e2.failState), t3.returnType = e2.node.typeAnnotation ? this.finishNode(e2.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(t3);
          }
          shouldParseArrow(t3) {
            return this.match(14) || super.shouldParseArrow(t3);
          }
          setArrowFunctionParameters(t3, e2) {
            this.state.noArrowParamsConversionAt.indexOf(t3.start) !== -1 ? t3.params = e2 : super.setArrowFunctionParameters(t3, e2);
          }
          checkParams(t3, e2, s2) {
            if (!s2 || this.state.noArrowParamsConversionAt.indexOf(t3.start) === -1) {
              for (let e3 = 0; e3 < t3.params.length; e3++)
                this.isThisParam(t3.params[e3]) && e3 > 0 && this.raise(t3.params[e3].start, Vl.ThisParamMustBeFirst);
              return super.checkParams(...arguments);
            }
          }
          parseParenAndDistinguishExpression(t3) {
            return super.parseParenAndDistinguishExpression(t3 && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(t3, e2, s2, r2) {
            if (t3.type === "Identifier" && t3.name === "async" && this.state.noArrowAt.indexOf(e2) !== -1) {
              this.next();
              const r3 = this.startNodeAt(e2, s2);
              r3.callee = t3, r3.arguments = this.parseCallExpressionArguments(11, false), t3 = this.finishNode(r3, "CallExpression");
            } else if (t3.type === "Identifier" && t3.name === "async" && this.match(43)) {
              const i2 = this.state.clone(), n2 = this.tryParse((t4) => this.parseAsyncArrowWithTypeParameters(e2, s2) || t4(), i2);
              if (!n2.error && !n2.aborted)
                return n2.node;
              const a2 = this.tryParse(() => super.parseSubscripts(t3, e2, s2, r2), i2);
              if (a2.node && !a2.error)
                return a2.node;
              if (n2.node)
                return this.state = n2.failState, n2.node;
              if (a2.node)
                return this.state = a2.failState, a2.node;
              throw n2.error || a2.error;
            }
            return super.parseSubscripts(t3, e2, s2, r2);
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (i2.optionalChainMember = true, r2)
                return i2.stop = true, t3;
              this.next();
              const n2 = this.startNodeAt(e2, s2);
              return n2.callee = t3, n2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n2.arguments = this.parseCallExpressionArguments(11, false), n2.optional = true, this.finishCallExpression(n2, true);
            }
            if (!r2 && this.shouldParseTypes() && this.match(43)) {
              const r3 = this.startNodeAt(e2, s2);
              r3.callee = t3;
              const n2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), r3.arguments = this.parseCallExpressionArguments(11, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
              if (n2.node)
                return n2.error && (this.state = n2.failState), n2.node;
            }
            return super.parseSubscript(t3, e2, s2, r2, i2);
          }
          parseNewArguments(t3) {
            let e2 = null;
            this.shouldParseTypes() && this.match(43) && (e2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t3.typeArguments = e2, super.parseNewArguments(t3);
          }
          parseAsyncArrowWithTypeParameters(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            if (this.parseFunctionParams(s2), this.parseArrow(s2))
              return this.parseArrowExpression(s2, void 0, true);
          }
          readToken_mult_modulo(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            if (t3 === 42 && e2 === 47 && this.state.hasFlowComment)
              return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(t3);
          }
          readToken_pipe_amp(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            t3 !== 124 || e2 !== 125 ? super.readToken_pipe_amp(t3) : this.finishOp(9, 2);
          }
          parseTopLevel(t3, e2) {
            const s2 = super.parseTopLevel(t3, e2);
            return this.state.hasFlowComment && this.raise(this.state.pos, Vl.UnterminatedFlowComment), s2;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment())
              return this.state.hasFlowComment && this.unexpected(null, Vl.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
            if (!this.state.hasFlowComment)
              return super.skipBlockComment();
            {
              const t3 = this.input.indexOf("*-/", this.state.pos += 2);
              if (t3 === -1)
                throw this.raise(this.state.pos - 2, Dc.UnterminatedComment);
              this.state.pos = t3 + 3;
            }
          }
          skipFlowComment() {
            const { pos: t3 } = this.state;
            let e2 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(t3 + e2)); )
              e2++;
            const s2 = this.input.charCodeAt(e2 + t3), r2 = this.input.charCodeAt(e2 + t3 + 1);
            return s2 === 58 && r2 === 58 ? e2 + 2 : this.input.slice(e2 + t3, e2 + t3 + 12) === "flow-include" ? e2 + 12 : s2 === 58 && r2 !== 58 && e2;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(this.state.pos, Dc.UnterminatedComment);
          }
          flowEnumErrorBooleanMemberNotInitialized(t3, e2) {
            let { enumName: s2, memberName: r2 } = e2;
            this.raise(t3, Vl.EnumBooleanMemberNotInitialized, r2, s2);
          }
          flowEnumErrorInvalidMemberName(t3, e2) {
            let { enumName: s2, memberName: r2 } = e2;
            const i2 = r2[0].toUpperCase() + r2.slice(1);
            this.raise(t3, Vl.EnumInvalidMemberName, r2, i2, s2);
          }
          flowEnumErrorDuplicateMemberName(t3, e2) {
            let { enumName: s2, memberName: r2 } = e2;
            this.raise(t3, Vl.EnumDuplicateMemberName, r2, s2);
          }
          flowEnumErrorInconsistentMemberValues(t3, e2) {
            let { enumName: s2 } = e2;
            this.raise(t3, Vl.EnumInconsistentMemberValues, s2);
          }
          flowEnumErrorInvalidExplicitType(t3, e2) {
            let { enumName: s2, suppliedType: r2 } = e2;
            return this.raise(t3, r2 === null ? Vl.EnumInvalidExplicitTypeUnknownSupplied : Vl.EnumInvalidExplicitType, s2, r2);
          }
          flowEnumErrorInvalidMemberInitializer(t3, e2) {
            let { enumName: s2, explicitType: r2, memberName: i2 } = e2, n2 = null;
            switch (r2) {
              case "boolean":
              case "number":
              case "string":
                n2 = Vl.EnumInvalidMemberInitializerPrimaryType;
                break;
              case "symbol":
                n2 = Vl.EnumInvalidMemberInitializerSymbolType;
                break;
              default:
                n2 = Vl.EnumInvalidMemberInitializerUnknownType;
            }
            return this.raise(t3, n2, s2, i2, r2);
          }
          flowEnumErrorNumberMemberNotInitialized(t3, e2) {
            let { enumName: s2, memberName: r2 } = e2;
            this.raise(t3, Vl.EnumNumberMemberNotInitialized, s2, r2);
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(t3, e2) {
            let { enumName: s2 } = e2;
            this.raise(t3, Vl.EnumStringMemberInconsistentlyInitailized, s2);
          }
          flowEnumMemberInit() {
            const t3 = this.state.start, e2 = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 124: {
                const s2 = this.parseNumericLiteral(this.state.value);
                return e2() ? { type: "number", pos: s2.start, value: s2 } : { type: "invalid", pos: t3 };
              }
              case 123: {
                const s2 = this.parseStringLiteral(this.state.value);
                return e2() ? { type: "string", pos: s2.start, value: s2 } : { type: "invalid", pos: t3 };
              }
              case 79:
              case 80: {
                const s2 = this.parseBooleanLiteral(this.match(79));
                return e2() ? { type: "boolean", pos: s2.start, value: s2 } : { type: "invalid", pos: t3 };
              }
              default:
                return { type: "invalid", pos: t3 };
            }
          }
          flowEnumMemberRaw() {
            const t3 = this.state.start;
            return { id: this.parseIdentifier(true), init: this.eat(27) ? this.flowEnumMemberInit() : { type: "none", pos: t3 } };
          }
          flowEnumCheckExplicitTypeMismatch(t3, e2, s2) {
            const { explicitType: r2 } = e2;
            r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(t3, e2);
          }
          flowEnumMembers(t3) {
            let { enumName: e2, explicitType: s2 } = t3;
            const r2 = /* @__PURE__ */ new Set(), i2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let n2 = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                n2 = true;
                break;
              }
              const t4 = this.startNode(), { id: a2, init: o2 } = this.flowEnumMemberRaw(), u2 = a2.name;
              if (u2 === "")
                continue;
              /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(a2.start, { enumName: e2, memberName: u2 }), r2.has(u2) && this.flowEnumErrorDuplicateMemberName(a2.start, { enumName: e2, memberName: u2 }), r2.add(u2);
              const h2 = { enumName: e2, explicitType: s2, memberName: u2 };
              switch (t4.id = a2, o2.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), t4.init = o2.value, i2.booleanMembers.push(this.finishNode(t4, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), t4.init = o2.value, i2.numberMembers.push(this.finishNode(t4, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), t4.init = o2.value, i2.stringMembers.push(this.finishNode(t4, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
                case "none":
                  switch (s2) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
                      break;
                    default:
                      i2.defaultedMembers.push(this.finishNode(t4, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: i2, hasUnknownMembers: n2 };
          }
          flowEnumStringMembers(t3, e2, s2) {
            let { enumName: r2 } = s2;
            if (t3.length === 0)
              return e2;
            if (e2.length === 0)
              return t3;
            if (e2.length > t3.length) {
              for (const e3 of t3)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(e3.start, { enumName: r2 });
              return e2;
            }
            for (const t4 of e2)
              this.flowEnumErrorStringMemberInconsistentlyInitailized(t4.start, { enumName: r2 });
            return t3;
          }
          flowEnumParseExplicitType(t3) {
            let { enumName: e2 } = t3;
            if (this.eatContextual(95)) {
              if (!Uc(this.state.type))
                throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e2, suppliedType: null });
              const { value: t4 } = this.state;
              return this.next(), t4 !== "boolean" && t4 !== "number" && t4 !== "string" && t4 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e2, suppliedType: t4 }), t4;
            }
            return null;
          }
          flowEnumBody(t3, e2) {
            let { enumName: s2, nameLoc: r2 } = e2;
            const i2 = this.flowEnumParseExplicitType({ enumName: s2 });
            this.expect(5);
            const { members: n2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: s2, explicitType: i2 });
            switch (t3.hasUnknownMembers = a2, i2) {
              case "boolean":
                return t3.explicitType = true, t3.members = n2.booleanMembers, this.expect(8), this.finishNode(t3, "EnumBooleanBody");
              case "number":
                return t3.explicitType = true, t3.members = n2.numberMembers, this.expect(8), this.finishNode(t3, "EnumNumberBody");
              case "string":
                return t3.explicitType = true, t3.members = this.flowEnumStringMembers(n2.stringMembers, n2.defaultedMembers, { enumName: s2 }), this.expect(8), this.finishNode(t3, "EnumStringBody");
              case "symbol":
                return t3.members = n2.defaultedMembers, this.expect(8), this.finishNode(t3, "EnumSymbolBody");
              default: {
                const e3 = () => (t3.members = [], this.expect(8), this.finishNode(t3, "EnumStringBody"));
                t3.explicitType = false;
                const i3 = n2.booleanMembers.length, a3 = n2.numberMembers.length, o2 = n2.stringMembers.length, u2 = n2.defaultedMembers.length;
                if (i3 || a3 || o2 || u2) {
                  if (i3 || a3) {
                    if (!a3 && !o2 && i3 >= u2) {
                      for (const t4 of n2.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(t4.start, { enumName: s2, memberName: t4.id.name });
                      return t3.members = n2.booleanMembers, this.expect(8), this.finishNode(t3, "EnumBooleanBody");
                    }
                    if (!i3 && !o2 && a3 >= u2) {
                      for (const t4 of n2.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(t4.start, { enumName: s2, memberName: t4.id.name });
                      return t3.members = n2.numberMembers, this.expect(8), this.finishNode(t3, "EnumNumberBody");
                    }
                    return this.flowEnumErrorInconsistentMemberValues(r2, { enumName: s2 }), e3();
                  }
                  return t3.members = this.flowEnumStringMembers(n2.stringMembers, n2.defaultedMembers, { enumName: s2 }), this.expect(8), this.finishNode(t3, "EnumStringBody");
                }
                return e3();
              }
            }
          }
          flowParseEnumDeclaration(t3) {
            const e2 = this.parseIdentifier();
            return t3.id = e2, t3.body = this.flowEnumBody(this.startNode(), { enumName: e2.name, nameLoc: e2.start }), this.finishNode(t3, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const t3 = this.nextTokenStart();
            if (this.input.charCodeAt(t3) === 60) {
              const e2 = this.input.charCodeAt(t3 + 1);
              return e2 !== 60 && e2 !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(t3) {
            return t3.type === "TypeCastExpression" ? t3.expression : t3;
          }
        }, typescript: (t2) => class extends t2 {
          getScopeHandler() {
            return ed;
          }
          tsIsIdentifier() {
            return Uc(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(49) || this.match(21) || this.match(128) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(t3, e2) {
            if (!Uc(this.state.type))
              return;
            const s2 = this.state.value;
            if (t3.indexOf(s2) !== -1) {
              if (e2 && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return s2;
            }
          }
          tsParseModifiers(t3, e2, s2, r2, i2) {
            const n2 = (e3, s3, r3, i3) => {
              s3 === r3 && t3[i3] && this.raise(e3, rd.InvalidModifiersOrder, r3, i3);
            }, a2 = (e3, s3, r3, i3) => {
              (t3[r3] && s3 === i3 || t3[i3] && s3 === r3) && this.raise(e3, rd.IncompatibleModifiers, r3, i3);
            };
            for (; ; ) {
              const o2 = this.state.start, u2 = this.tsParseModifier(e2.concat(s2 != null ? s2 : []), i2);
              if (!u2)
                break;
              id(u2) ? t3.accessibility ? this.raise(o2, rd.DuplicateAccessibilityModifier) : (n2(o2, u2, u2, "override"), n2(o2, u2, u2, "static"), n2(o2, u2, u2, "readonly"), t3.accessibility = u2) : (Object.hasOwnProperty.call(t3, u2) ? this.raise(o2, rd.DuplicateModifier, u2) : (n2(o2, u2, "static", "readonly"), n2(o2, u2, "static", "override"), n2(o2, u2, "override", "readonly"), n2(o2, u2, "abstract", "override"), a2(o2, u2, "declare", "override"), a2(o2, u2, "static", "abstract")), t3[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
            }
          }
          tsIsListTerminator(t3) {
            switch (t3) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(44);
            }
            throw new Error("Unreachable");
          }
          tsParseList(t3, e2) {
            const s2 = [];
            for (; !this.tsIsListTerminator(t3); )
              s2.push(e2());
            return s2;
          }
          tsParseDelimitedList(t3, e2, s2) {
            return function(t4) {
              if (t4 == null)
                throw new Error("Unexpected ".concat(t4, " value."));
              return t4;
            }(this.tsParseDelimitedListWorker(t3, e2, true, s2));
          }
          tsParseDelimitedListWorker(t3, e2, s2, r2) {
            const i2 = [];
            let n2 = -1;
            for (; !this.tsIsListTerminator(t3); ) {
              n2 = -1;
              const r3 = e2();
              if (r3 == null)
                return;
              if (i2.push(r3), !this.eat(12)) {
                if (this.tsIsListTerminator(t3))
                  break;
                return void (s2 && this.expect(12));
              }
              n2 = this.state.lastTokStart;
            }
            return r2 && (r2.value = n2), i2;
          }
          tsParseBracketedList(t3, e2, s2, r2, i2) {
            r2 || (s2 ? this.expect(0) : this.expect(43));
            const n2 = this.tsParseDelimitedList(t3, e2, i2);
            return s2 ? this.expect(3) : this.expect(44), n2;
          }
          tsParseImportType() {
            const t3 = this.startNode();
            return this.expect(77), this.expect(10), this.match(123) || this.raise(this.state.start, rd.UnsupportedImportTypeArgument), t3.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (t3.qualifier = this.tsParseEntityName(true)), this.match(43) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSImportType");
          }
          tsParseEntityName(t3) {
            let e2 = this.parseIdentifier();
            for (; this.eat(16); ) {
              const s2 = this.startNodeAtNode(e2);
              s2.left = e2, s2.right = this.parseIdentifier(t3), e2 = this.finishNode(s2, "TSQualifiedName");
            }
            return e2;
          }
          tsParseTypeReference() {
            const t3 = this.startNode();
            return t3.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.match(43) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSTypeReference");
          }
          tsParseThisTypePredicate(t3) {
            this.next();
            const e2 = this.startNodeAtNode(t3);
            return e2.parameterName = t3, e2.typeAnnotation = this.tsParseTypeAnnotation(false), e2.asserts = false, this.finishNode(e2, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const t3 = this.startNode();
            return this.next(), this.finishNode(t3, "TSThisType");
          }
          tsParseTypeQuery() {
            const t3 = this.startNode();
            return this.expect(81), this.match(77) ? t3.exprName = this.tsParseImportType() : t3.exprName = this.tsParseEntityName(true), this.finishNode(t3, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const t3 = this.startNode();
            return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsEatThenParseType(75), t3.default = this.tsEatThenParseType(27), this.finishNode(t3, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.match(43))
              return this.tsParseTypeParameters();
          }
          tsParseTypeParameters() {
            const t3 = this.startNode();
            this.match(43) || this.match(132) ? this.next() : this.unexpected();
            const e2 = { value: -1 };
            return t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, e2), t3.params.length === 0 && this.raise(t3.start, rd.EmptyTypeParameters), e2.value !== -1 && this.addExtra(t3, "trailingComma", e2.value), this.finishNode(t3, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            return this.lookahead().type === 69 ? (this.next(), this.tsParseTypeReference()) : null;
          }
          tsFillSignature(t3, e2) {
            const s2 = t3 === 19;
            e2.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), e2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(t3)) && (e2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t3));
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(11, 41).map((t3) => (t3.type !== "Identifier" && t3.type !== "RestElement" && t3.type !== "ObjectPattern" && t3.type !== "ArrayPattern" && this.raise(t3.start, rd.UnsupportedSignatureParameterKind, t3.type), t3));
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(t3, e2) {
            return this.tsFillSignature(14, e2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, t3);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!Uc(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(t3) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(0);
            const e2 = this.parseIdentifier();
            e2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e2), this.expect(3), t3.parameters = [e2];
            const s2 = this.tsTryParseTypeAnnotation();
            return s2 && (t3.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(t3, e2) {
            this.eat(17) && (t3.optional = true);
            const s2 = t3;
            if (this.match(10) || this.match(43)) {
              e2 && this.raise(t3.start, rd.ReadonlyForMethodSignature);
              const r2 = s2;
              if (r2.kind && this.match(43) && this.raise(this.state.pos, rd.AccesorCannotHaveTypeParameters), this.tsFillSignature(14, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
                r2.parameters.length > 0 && (this.raise(this.state.pos, Dc.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, rd.AccesorCannotDeclareThisParameter));
              else if (r2.kind === "set") {
                if (r2.parameters.length !== 1)
                  this.raise(this.state.pos, Dc.BadSetterArity);
                else {
                  const t4 = r2.parameters[0];
                  this.isThisParam(t4) && this.raise(this.state.pos, rd.AccesorCannotDeclareThisParameter), t4.type === "Identifier" && t4.optional && this.raise(this.state.pos, rd.SetAccesorCannotHaveOptionalParameter), t4.type === "RestElement" && this.raise(this.state.pos, rd.SetAccesorCannotHaveRestParameter);
                }
                r2.typeAnnotation && this.raise(r2.typeAnnotation.start, rd.SetAccesorCannotHaveReturnType);
              } else
                r2.kind = "method";
              return this.finishNode(r2, "TSMethodSignature");
            }
            {
              const t4 = s2;
              e2 && (t4.readonly = true);
              const r2 = this.tsTryParseTypeAnnotation();
              return r2 && (t4.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(t4, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const t3 = this.startNode();
            if (this.match(10) || this.match(43))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", t3);
            if (this.match(71)) {
              const e3 = this.startNode();
              return this.next(), this.match(10) || this.match(43) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t3) : (t3.key = this.createIdentifier(e3, "new"), this.tsParsePropertyOrMethodSignature(t3, false));
            }
            this.tsParseModifiers(t3, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], rd.InvalidModifierOnTypeMember);
            const e2 = this.tsTryParseIndexSignature(t3);
            return e2 || (this.parsePropertyName(t3), t3.computed || t3.key.type !== "Identifier" || t3.key.name !== "get" && t3.key.name !== "set" || !this.tsTokenCanFollowModifier() || (t3.kind = t3.key.name, this.parsePropertyName(t3)), this.tsParsePropertyOrMethodSignature(t3, !!t3.readonly));
          }
          tsParseTypeLiteral() {
            const t3 = this.startNode();
            return t3.members = this.tsParseObjectTypeMembers(), this.finishNode(t3, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const t3 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), t3;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(47) ? this.isContextual(112) : (this.isContextual(112) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(52))));
          }
          tsParseMappedTypeParameter() {
            const t3 = this.startNode();
            return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsExpectThenParseType(52), this.finishNode(t3, "TSTypeParameter");
          }
          tsParseMappedType() {
            const t3 = this.startNode();
            return this.expect(5), this.match(47) ? (t3.readonly = this.state.value, this.next(), this.expectContextual(112)) : this.eatContextual(112) && (t3.readonly = true), this.expect(0), t3.typeParameter = this.tsParseMappedTypeParameter(), t3.nameType = this.eatContextual(87) ? this.tsParseType() : null, this.expect(3), this.match(47) ? (t3.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (t3.optional = true), t3.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(t3, "TSMappedType");
          }
          tsParseTupleType() {
            const t3 = this.startNode();
            t3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let e2 = false, s2 = null;
            return t3.elementTypes.forEach((t4) => {
              var r2;
              let { type: i2 } = t4;
              !e2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && t4.optional || this.raise(t4.start, rd.OptionalTypeBeforeRequired), e2 = e2 || i2 === "TSNamedTupleMember" && t4.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (t4 = t4.typeAnnotation).type);
              const n2 = i2 === "TSNamedTupleMember";
              s2 = (r2 = s2) != null ? r2 : n2, s2 !== n2 && this.raise(t4.start, rd.MixedLabeledAndUnlabeledElements);
            }), this.finishNode(t3, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { start: t3, startLoc: e2 } = this.state, s2 = this.eat(21);
            let r2 = this.tsParseType();
            const i2 = this.eat(17);
            if (this.eat(14)) {
              const t4 = this.startNodeAtNode(r2);
              t4.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, rd.InvalidTupleMemberLabel), t4.label = r2) : t4.label = r2.typeName, t4.elementType = this.tsParseType(), r2 = this.finishNode(t4, "TSNamedTupleMember");
            } else if (i2) {
              const t4 = this.startNodeAtNode(r2);
              t4.typeAnnotation = r2, r2 = this.finishNode(t4, "TSOptionalType");
            }
            if (s2) {
              const s3 = this.startNodeAt(t3, e2);
              s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
            }
            return r2;
          }
          tsParseParenthesizedType() {
            const t3 = this.startNode();
            return this.expect(10), t3.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(t3, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(t3, e2) {
            const s2 = this.startNode();
            return t3 === "TSConstructorType" && (s2.abstract = !!e2, e2 && this.next(), this.next()), this.tsFillSignature(19, s2), this.finishNode(s2, t3);
          }
          tsParseLiteralTypeNode() {
            const t3 = this.startNode();
            return t3.literal = (() => {
              switch (this.state.type) {
                case 124:
                case 125:
                case 123:
                case 79:
                case 80:
                  return this.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })(), this.finishNode(t3, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const t3 = this.startNode();
            return t3.literal = this.parseTemplate(false), this.finishNode(t3, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const t3 = this.tsParseThisTypeNode();
            return this.isContextual(107) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t3) : t3;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 123:
              case 124:
              case 125:
              case 79:
              case 80:
                return this.tsParseLiteralTypeNode();
              case 47:
                if (this.state.value === "-") {
                  const t3 = this.startNode(), e2 = this.lookahead();
                  if (e2.type !== 124 && e2.type !== 125)
                    throw this.unexpected();
                  return t3.literal = this.parseMaybeUnary(), this.finishNode(t3, "TSLiteralType");
                }
                break;
              case 72:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 81:
                return this.tsParseTypeQuery();
              case 77:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 22:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: t3 } = this.state;
                if (Uc(t3) || t3 === 82 || t3 === 78) {
                  const e2 = t3 === 82 ? "TSVoidKeyword" : t3 === 78 ? "TSNullKeyword" : function(t4) {
                    switch (t4) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (e2 !== void 0 && this.lookaheadCharCode() !== 46) {
                    const t4 = this.startNode();
                    return this.next(), this.finishNode(t4, e2);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let t3 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                const e2 = this.startNodeAtNode(t3);
                e2.elementType = t3, this.expect(3), t3 = this.finishNode(e2, "TSArrayType");
              } else {
                const e2 = this.startNodeAtNode(t3);
                e2.objectType = t3, e2.indexType = this.tsParseType(), this.expect(3), t3 = this.finishNode(e2, "TSIndexedAccessType");
              }
            return t3;
          }
          tsParseTypeOperator() {
            const t3 = this.startNode(), e2 = this.state.value;
            return this.next(), t3.operator = e2, t3.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t3), this.finishNode(t3, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(t3) {
            switch (t3.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(t3.start, rd.UnexpectedReadonly);
            }
          }
          tsParseInferType() {
            const t3 = this.startNode();
            this.expectContextual(106);
            const e2 = this.startNode();
            return e2.name = this.tsParseTypeParameterName(), t3.typeParameter = this.finishNode(e2, "TSTypeParameter"), this.finishNode(t3, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            var t3;
            return (t3 = this.state.type) >= 111 && t3 <= 113 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(106) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(t3, e2, s2) {
            const r2 = this.startNode(), i2 = this.eat(s2), n2 = [];
            do {
              n2.push(e2());
            } while (this.eat(s2));
            return n2.length !== 1 || i2 ? (r2.types = n2, this.finishNode(r2, t3)) : n2[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 41);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 39);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(43) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (Uc(this.state.type) || this.match(72))
              return this.next(), true;
            if (this.match(5)) {
              let t3 = 1;
              for (this.next(); t3 > 0; )
                this.match(5) ? ++t3 : this.match(8) && --t3, this.next();
              return true;
            }
            if (this.match(0)) {
              let t3 = 1;
              for (this.next(); t3 > 0; )
                this.match(0) ? ++t3 : this.match(3) && --t3, this.next();
              return true;
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21))
              return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(27))
                return true;
              if (this.match(11) && (this.next(), this.match(19)))
                return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(t3) {
            return this.tsInType(() => {
              const e2 = this.startNode();
              this.expect(t3);
              const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r2 && this.match(72)) {
                let t4 = this.tsParseThisTypeOrThisTypePredicate();
                return t4.type === "TSThisType" ? (s2.parameterName = t4, s2.asserts = true, s2.typeAnnotation = null, t4 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(t4, s2), t4.asserts = true), e2.typeAnnotation = t4, this.finishNode(e2, "TSTypeAnnotation");
              }
              const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!i2)
                return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, e2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, e2);
              const n2 = this.tsParseTypeAnnotation(false);
              return s2.parameterName = i2, s2.typeAnnotation = n2, s2.asserts = r2, e2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const t3 = this.parseIdentifier();
            if (this.isContextual(107) && !this.hasPrecedingLineBreak())
              return this.next(), t3;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 100)
              return false;
            const t3 = this.state.containsEsc;
            return this.next(), !(!Uc(this.state.type) && !this.match(72)) && (t3 && this.raise(this.state.lastTokStart, Dc.InvalidEscapedReservedWord, "asserts"), true);
          }
          tsParseTypeAnnotation() {
            let t3 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
            return this.tsInType(() => {
              t3 && this.expect(14), e2.typeAnnotation = this.tsParseType();
            }), this.finishNode(e2, "TSTypeAnnotation");
          }
          tsParseType() {
            sd(this.state.inType);
            const t3 = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(75))
              return t3;
            const e2 = this.startNodeAtNode(t3);
            return e2.checkType = t3, e2.extendsType = this.tsParseNonConditionalType(), this.expect(17), e2.trueType = this.tsParseType(), this.expect(14), e2.falseType = this.tsParseType(), this.finishNode(e2, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(114) && this.lookahead().type === 71;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(71) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(this.state.start, rd.ReservedTypeAssertion);
            const t3 = this.startNode(), e2 = this.tsTryNextParseConstantContext();
            return t3.typeAnnotation = e2 || this.tsNextThenParseType(), this.expect(44), t3.expression = this.parseMaybeUnary(), this.finishNode(t3, "TSTypeAssertion");
          }
          tsParseHeritageClause(t3) {
            const e2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            return s2.length || this.raise(e2, rd.EmptyHeritageClauseType, t3), s2;
          }
          tsParseExpressionWithTypeArguments() {
            const t3 = this.startNode();
            return t3.expression = this.tsParseEntityName(false), this.match(43) && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(t3) {
            Uc(this.state.type) ? (t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript interface declaration", 130)) : (t3.id = null, this.raise(this.state.start, rd.MissingInterfaceName)), t3.typeParameters = this.tsTryParseTypeParameters(), this.eat(75) && (t3.extends = this.tsParseHeritageClause("extends"));
            const e2 = this.startNode();
            return e2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t3.body = this.finishNode(e2, "TSInterfaceBody"), this.finishNode(t3, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(t3) {
            return t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript type alias", 2), t3.typeParameters = this.tsTryParseTypeParameters(), t3.typeAnnotation = this.tsInType(() => {
              if (this.expect(27), this.isContextual(105) && this.lookahead().type !== 16) {
                const t4 = this.startNode();
                return this.next(), this.finishNode(t4, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(t3, "TSTypeAliasDeclaration");
          }
          tsInNoContext(t3) {
            const e2 = this.state.context;
            this.state.context = [e2[0]];
            try {
              return t3();
            } finally {
              this.state.context = e2;
            }
          }
          tsInType(t3) {
            const e2 = this.state.inType;
            this.state.inType = true;
            try {
              return t3();
            } finally {
              this.state.inType = e2;
            }
          }
          tsEatThenParseType(t3) {
            return this.match(t3) ? this.tsNextThenParseType() : void 0;
          }
          tsExpectThenParseType(t3) {
            return this.tsDoThenParseType(() => this.expect(t3));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType(() => this.next());
          }
          tsDoThenParseType(t3) {
            return this.tsInType(() => (t3(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const t3 = this.startNode();
            return t3.id = this.match(123) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(27) && (t3.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(t3, "TSEnumMember");
          }
          tsParseEnumDeclaration(t3, e2) {
            return e2 && (t3.const = true), t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript enum declaration", e2 ? 779 : 267), this.expect(5), t3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(t3, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const t3 = this.startNode();
            return this.scope.enter(0), this.expect(5), this.parseBlockOrModuleBlockBody(t3.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(t3, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(t3) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            if (t3.id = this.parseIdentifier(), e2 || this.checkLVal(t3.id, "module or namespace declaration", 1024), this.eat(16)) {
              const e3 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(e3, true), t3.body = e3;
            } else
              this.scope.enter(Dl), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(t3, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(t3) {
            return this.isContextual(103) ? (t3.global = true, t3.id = this.parseIdentifier()) : this.match(123) ? t3.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(Dl), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t3, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(t3, e2) {
            t3.isExport = e2 || false, t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "import equals declaration", 9), this.expect(27);
            const s2 = this.tsParseModuleReference();
            return t3.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, rd.ImportAliasHasImportType), t3.moduleReference = s2, this.semicolon(), this.finishNode(t3, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(110) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const t3 = this.startNode();
            if (this.expectContextual(110), this.expect(10), !this.match(123))
              throw this.unexpected();
            return t3.expression = this.parseExprAtom(), this.expect(11), this.finishNode(t3, "TSExternalModuleReference");
          }
          tsLookAhead(t3) {
            const e2 = this.state.clone(), s2 = t3();
            return this.state = e2, s2;
          }
          tsTryParseAndCatch(t3) {
            const e2 = this.tryParse((e3) => t3() || e3());
            if (!e2.aborted && e2.node)
              return e2.error && (this.state = e2.failState), e2.node;
          }
          tsTryParse(t3) {
            const e2 = this.state.clone(), s2 = t3();
            return s2 !== void 0 && s2 !== false ? s2 : void (this.state = e2);
          }
          tsTryParseDeclare(t3) {
            if (this.isLineTerminator())
              return;
            let e2, s2 = this.state.type;
            return this.isContextual(93) && (s2 = 68, e2 = "let"), this.tsInAmbientContext(() => {
              switch (s2) {
                case 62:
                  return t3.declare = true, this.parseFunctionStatement(t3, false, true);
                case 74:
                  return t3.declare = true, this.parseClass(t3, true, false);
                case 69:
                  if (this.match(69) && this.isLookaheadContextual("enum"))
                    return this.expect(69), this.expectContextual(116), this.tsParseEnumDeclaration(t3, true);
                case 68:
                  return e2 = e2 || this.state.value, this.parseVarStatement(t3, e2);
                case 103:
                  return this.tsParseAmbientExternalModuleDeclaration(t3);
                default:
                  if (Uc(s2))
                    return this.tsParseDeclaration(t3, this.state.value, true);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
          }
          tsParseExpressionStatement(t3, e2) {
            switch (e2.name) {
              case "declare": {
                const e3 = this.tsTryParseDeclare(t3);
                if (e3)
                  return e3.declare = true, e3;
                break;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(Dl), this.prodParam.enter(0);
                  const s2 = t3;
                  return s2.global = true, s2.id = e2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(t3, e2.name, false);
            }
          }
          tsParseDeclaration(t3, e2, s2) {
            switch (e2) {
              case "abstract":
                if (this.tsCheckLineTerminator(s2) && (this.match(74) || Uc(this.state.type)))
                  return this.tsParseAbstractDeclaration(t3);
                break;
              case "enum":
                if (s2 || Uc(this.state.type))
                  return s2 && this.next(), this.tsParseEnumDeclaration(t3, false);
                break;
              case "interface":
                if (this.tsCheckLineTerminator(s2) && Uc(this.state.type))
                  return this.tsParseInterfaceDeclaration(t3);
                break;
              case "module":
                if (this.tsCheckLineTerminator(s2)) {
                  if (this.match(123))
                    return this.tsParseAmbientExternalModuleDeclaration(t3);
                  if (Uc(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(t3);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(s2) && Uc(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(t3);
                break;
              case "type":
                if (this.tsCheckLineTerminator(s2) && Uc(this.state.type))
                  return this.tsParseTypeAliasDeclaration(t3);
            }
          }
          tsCheckLineTerminator(t3) {
            return t3 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(t3, e2) {
            if (!this.match(43))
              return;
            const s2 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const r2 = this.tsTryParseAndCatch(() => {
              const s3 = this.startNodeAt(t3, e2);
              return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), s3;
            });
            return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
          }
          tsParseTypeArguments() {
            const t3 = this.startNode();
            return t3.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(43), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), t3.params.length === 0 && this.raise(t3.start, rd.EmptyTypeArguments), this.expect(44), this.finishNode(t3, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (t3 = this.state.type) >= 114 && t3 <= 120;
            var t3;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(t3, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc;
            let i2, n2 = false, a2 = false;
            if (t3 !== void 0) {
              const e3 = {};
              this.tsParseModifiers(e3, ["public", "private", "protected", "override", "readonly"]), i2 = e3.accessibility, a2 = e3.override, n2 = e3.readonly, t3 === false && (i2 || n2 || a2) && this.raise(s2, rd.UnexpectedParameterModifier);
            }
            const o2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(o2);
            const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
            if (i2 || n2 || a2) {
              const t4 = this.startNodeAt(s2, r2);
              return e2.length && (t4.decorators = e2), i2 && (t4.accessibility = i2), n2 && (t4.readonly = n2), a2 && (t4.override = a2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(t4.start, rd.UnsupportedParameterPropertyKind), t4.parameter = u2, this.finishNode(t4, "TSParameterProperty");
            }
            return e2.length && (o2.decorators = e2), u2;
          }
          parseFunctionBodyAndFinish(t3, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            this.match(14) && (t3.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const r2 = e2 === "FunctionDeclaration" ? "TSDeclareFunction" : e2 === "ClassMethod" || e2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            r2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(t3, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(t3.start, rd.DeclareFunctionHasImplementation), t3.declare) ? super.parseFunctionBodyAndFinish(t3, r2, s2) : super.parseFunctionBodyAndFinish(t3, e2, s2);
          }
          registerFunctionStatementId(t3) {
            !t3.body && t3.id ? this.checkLVal(t3.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
          }
          tsCheckForInvalidTypeCasts(t3) {
            t3.forEach((t4) => {
              (t4 == null ? void 0 : t4.type) === "TSTypeCastExpression" && this.raise(t4.typeAnnotation.start, rd.UnexpectedTypeAnnotation);
            });
          }
          toReferencedList(t3, e2) {
            return this.tsCheckForInvalidTypeCasts(t3), t3;
          }
          parseArrayLike() {
            const t3 = super.parseArrayLike(...arguments);
            return t3.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t3.elements), t3;
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            if (!this.hasPrecedingLineBreak() && this.match(33)) {
              this.state.canStartJSXElement = false, this.next();
              const r3 = this.startNodeAt(e2, s2);
              return r3.expression = t3, this.finishNode(r3, "TSNonNullExpression");
            }
            let n2 = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (r2)
                return i2.stop = true, t3;
              i2.optionalChainMember = n2 = true, this.next();
            }
            if (this.match(43)) {
              let a2;
              const o2 = this.tsTryParseAndCatch(() => {
                if (!r2 && this.atPossibleAsyncArrow(t3)) {
                  const t4 = this.tsTryParseGenericAsyncArrowFunction(e2, s2);
                  if (t4)
                    return t4;
                }
                const o3 = this.startNodeAt(e2, s2);
                o3.callee = t3;
                const u2 = this.tsParseTypeArguments();
                if (u2) {
                  if (n2 && !this.match(10) && (a2 = this.state.pos, this.unexpected()), !r2 && this.eat(10))
                    return o3.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = n2), this.finishCallExpression(o3, i2.optionalChainMember);
                  if (this.match(22)) {
                    const r3 = this.parseTaggedTemplateExpression(t3, e2, s2, i2);
                    return r3.typeParameters = u2, r3;
                  }
                }
                this.unexpected();
              });
              if (a2 && this.unexpected(a2, 10), o2)
                return o2;
            }
            return super.parseSubscript(t3, e2, s2, r2, i2);
          }
          parseNewArguments(t3) {
            if (this.match(43)) {
              const e2 = this.tsTryParseAndCatch(() => {
                const t4 = this.tsParseTypeArguments();
                return this.match(10) || this.unexpected(), t4;
              });
              e2 && (t3.typeParameters = e2);
            }
            super.parseNewArguments(t3);
          }
          parseExprOp(t3, e2, s2, r2) {
            if (Kc(52) > r2 && !this.hasPrecedingLineBreak() && this.isContextual(87)) {
              const i2 = this.startNodeAt(e2, s2);
              i2.expression = t3;
              const n2 = this.tsTryNextParseConstantContext();
              return i2.typeAnnotation = n2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, e2, s2, r2);
            }
            return super.parseExprOp(t3, e2, s2, r2);
          }
          checkReservedWord(t3, e2, s2, r2) {
          }
          checkDuplicateExports() {
          }
          parseImport(t3) {
            if (t3.importKind = "value", Uc(this.state.type) || this.match(49) || this.match(5)) {
              let e3 = this.lookahead();
              if (this.isContextual(120) && e3.type !== 12 && e3.type !== 91 && e3.type !== 27 && (t3.importKind = "type", this.next(), e3 = this.lookahead()), Uc(this.state.type) && e3.type === 27)
                return this.tsParseImportEqualsDeclaration(t3);
            }
            const e2 = super.parseImport(t3);
            return e2.importKind === "type" && e2.specifiers.length > 1 && e2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(e2.start, rd.TypeImportCannotSpecifyDefaultAndNamed), e2;
          }
          parseExport(t3) {
            if (this.match(77))
              return this.next(), this.isContextual(120) && this.lookaheadCharCode() !== 61 ? (t3.importKind = "type", this.next()) : t3.importKind = "value", this.tsParseImportEqualsDeclaration(t3, true);
            if (this.eat(27)) {
              const e2 = t3;
              return e2.expression = this.parseExpression(), this.semicolon(), this.finishNode(e2, "TSExportAssignment");
            }
            if (this.eatContextual(87)) {
              const e2 = t3;
              return this.expectContextual(118), e2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(e2, "TSNamespaceExportDeclaration");
            }
            return this.isContextual(120) && this.lookahead().type === 5 ? (this.next(), t3.exportKind = "type") : t3.exportKind = "value", super.parseExport(t3);
          }
          isAbstractClass() {
            return this.isContextual(114) && this.lookahead().type === 74;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const t3 = this.startNode();
              return this.next(), t3.abstract = true, this.parseClass(t3, true, true), t3;
            }
            if (this.match(119)) {
              const t3 = this.startNode();
              this.next();
              const e2 = this.tsParseInterfaceDeclaration(t3);
              if (e2)
                return e2;
            }
            return super.parseExportDefaultExpression();
          }
          parseStatementContent(t3, e2) {
            if (this.state.type === 69) {
              if (this.lookahead().type === 116) {
                const t4 = this.startNode();
                return this.next(), this.expectContextual(116), this.tsParseEnumDeclaration(t4, true);
              }
            }
            return super.parseStatementContent(t3, e2);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(t3, e2) {
            return e2.some((e3) => id(e3) ? t3.accessibility === e3 : !!t3[e3]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(98) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(t3, e2, s2) {
            const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers(e2, r2, void 0, void 0, true);
            const i2 = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(e2, r2) && this.raise(this.state.pos, rd.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(t3, e2)) : this.parseClassMemberWithIsStatic(t3, e2, s2, !!e2.static);
            };
            e2.declare ? this.tsInAmbientContext(i2) : i2();
          }
          parseClassMemberWithIsStatic(t3, e2, s2, r2) {
            const i2 = this.tsTryParseIndexSignature(e2);
            if (i2)
              return t3.body.push(i2), e2.abstract && this.raise(e2.start, rd.IndexSignatureHasAbstract), e2.accessibility && this.raise(e2.start, rd.IndexSignatureHasAccessibility, e2.accessibility), e2.declare && this.raise(e2.start, rd.IndexSignatureHasDeclare), void (e2.override && this.raise(e2.start, rd.IndexSignatureHasOverride));
            !this.state.inAbstractClass && e2.abstract && this.raise(e2.start, rd.NonAbstractClassHasAbstractMethod), e2.override && (s2.hadSuperClass || this.raise(e2.start, rd.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(t3, e2, s2, r2);
          }
          parsePostMemberNameModifiers(t3) {
            this.eat(17) && (t3.optional = true), t3.readonly && this.match(10) && this.raise(t3.start, rd.ClassMethodHasReadonly), t3.declare && this.match(10) && this.raise(t3.start, rd.ClassMethodHasDeclare);
          }
          parseExpressionStatement(t3, e2) {
            return (e2.type === "Identifier" ? this.tsParseExpressionStatement(t3, e2) : void 0) || super.parseExpressionStatement(t3, e2);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(t3, e2, s2, r2) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(t3, e2, s2, r2);
            const i2 = this.tryParse(() => super.parseConditional(t3, e2, s2));
            return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), t3);
          }
          parseParenItem(t3, e2, s2) {
            if (t3 = super.parseParenItem(t3, e2, s2), this.eat(17) && (t3.optional = true, this.resetEndLocation(t3)), this.match(14)) {
              const r2 = this.startNodeAt(e2, s2);
              return r2.expression = t3, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
            }
            return t3;
          }
          parseExportDeclaration(t3) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual(115);
            if (r2 && (this.isContextual(115) || !this.shouldParseExportDeclaration()))
              throw this.raise(this.state.start, rd.ExpectedAmbientAfterExportDeclare);
            let i2;
            return Uc(this.state.type) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(t3)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (t3.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, e2, s2), i2.declare = true), i2;
          }
          parseClassId(t3, e2, s2) {
            if ((!e2 || s2) && this.isContextual(104))
              return;
            super.parseClassId(t3, e2, s2, t3.declare ? 1024 : 139);
            const r2 = this.tsTryParseTypeParameters();
            r2 && (t3.typeParameters = r2);
          }
          parseClassPropertyAnnotation(t3) {
            !t3.optional && this.eat(33) && (t3.definite = true);
            const e2 = this.tsTryParseTypeAnnotation();
            e2 && (t3.typeAnnotation = e2);
          }
          parseClassProperty(t3) {
            if (this.parseClassPropertyAnnotation(t3), this.state.isAmbientContext && this.match(27) && this.raise(this.state.start, rd.DeclareClassFieldHasInitializer), t3.abstract && this.match(27)) {
              const { key: e2 } = t3;
              this.raise(this.state.start, rd.AbstractPropertyHasInitializer, e2.type !== "Identifier" || t3.computed ? "[".concat(this.input.slice(e2.start, e2.end), "]") : e2.name);
            }
            return super.parseClassProperty(t3);
          }
          parseClassPrivateProperty(t3) {
            return t3.abstract && this.raise(t3.start, rd.PrivateElementHasAbstract), t3.accessibility && this.raise(t3.start, rd.PrivateElementHasAccessibility, t3.accessibility), this.parseClassPropertyAnnotation(t3), super.parseClassPrivateProperty(t3);
          }
          pushClassMethod(t3, e2, s2, r2, i2, n2) {
            const a2 = this.tsTryParseTypeParameters();
            a2 && i2 && this.raise(a2.start, rd.ConstructorHasTypeParameters), !e2.declare || e2.kind !== "get" && e2.kind !== "set" || this.raise(e2.start, rd.DeclareAccessor, e2.kind), a2 && (e2.typeParameters = a2), super.pushClassMethod(t3, e2, s2, r2, i2, n2);
          }
          pushClassPrivateMethod(t3, e2, s2, r2) {
            const i2 = this.tsTryParseTypeParameters();
            i2 && (e2.typeParameters = i2), super.pushClassPrivateMethod(t3, e2, s2, r2);
          }
          declareClassPrivateMethodInScope(t3, e2) {
            t3.type !== "TSDeclareMethod" && (t3.type !== "MethodDefinition" || t3.value.body) && super.declareClassPrivateMethodInScope(t3, e2);
          }
          parseClassSuper(t3) {
            super.parseClassSuper(t3), t3.superClass && this.match(43) && (t3.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual(104) && (t3.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(t3) {
            const e2 = this.tsTryParseTypeParameters();
            e2 && (t3.typeParameters = e2);
            for (var s2 = arguments.length, r2 = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
              r2[i2 - 1] = arguments[i2];
            super.parseObjPropValue(t3, ...r2);
          }
          parseFunctionParams(t3, e2) {
            const s2 = this.tsTryParseTypeParameters();
            s2 && (t3.typeParameters = s2), super.parseFunctionParams(t3, e2);
          }
          parseVarId(t3, e2) {
            super.parseVarId(t3, e2), t3.id.type === "Identifier" && this.eat(33) && (t3.definite = true);
            const s2 = this.tsTryParseTypeAnnotation();
            s2 && (t3.id.typeAnnotation = s2, this.resetEndLocation(t3.id));
          }
          parseAsyncArrowFromCallExpression(t3, e2) {
            return this.match(14) && (t3.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t3, e2);
          }
          parseMaybeAssign() {
            for (var t3 = arguments.length, e2 = new Array(t3), s2 = 0; s2 < t3; s2++)
              e2[s2] = arguments[s2];
            var r2, i2, n2, a2, o2, u2, h2;
            let p2, c2, l2, d2;
            if (this.hasPlugin("jsx") && (this.match(132) || this.match(43))) {
              if (p2 = this.state.clone(), c2 = this.tryParse(() => super.parseMaybeAssign(...e2), p2), !c2.error)
                return c2.node;
              const { context: t4 } = this.state;
              t4[t4.length - 1] === Ac.j_oTag ? t4.length -= 2 : t4[t4.length - 1] === Ac.j_expr && (t4.length -= 1);
            }
            if (!((r2 = c2) != null && r2.error || this.match(43)))
              return super.parseMaybeAssign(...e2);
            p2 = p2 || this.state.clone();
            const D2 = this.tryParse((t4) => {
              var s3, r3;
              d2 = this.tsParseTypeParameters();
              const i3 = super.parseMaybeAssign(...e2);
              return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t4(), ((r3 = d2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, d2), i3.typeParameters = d2, i3;
            }, p2);
            if (!D2.error && !D2.aborted)
              return d2 && this.reportReservedArrowTypeParam(d2), D2.node;
            if (!c2 && (sd(!this.hasPlugin("jsx")), l2 = this.tryParse(() => super.parseMaybeAssign(...e2), p2), !l2.error))
              return l2.node;
            if ((i2 = c2) != null && i2.node)
              return this.state = c2.failState, c2.node;
            if (D2.node)
              return this.state = D2.failState, d2 && this.reportReservedArrowTypeParam(d2), D2.node;
            if ((n2 = l2) != null && n2.node)
              return this.state = l2.failState, l2.node;
            if ((a2 = c2) != null && a2.thrown)
              throw c2.error;
            if (D2.thrown)
              throw D2.error;
            if ((o2 = l2) != null && o2.thrown)
              throw l2.error;
            throw ((u2 = c2) == null ? void 0 : u2.error) || D2.error || ((h2 = l2) == null ? void 0 : h2.error);
          }
          reportReservedArrowTypeParam(t3) {
            var e2;
            t3.params.length !== 1 || (e2 = t3.extra) != null && e2.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(t3.start, rd.ReservedArrowTypeParam);
          }
          parseMaybeUnary(t3) {
            return !this.hasPlugin("jsx") && this.match(43) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t3);
          }
          parseArrow(t3) {
            if (this.match(14)) {
              const e2 = this.tryParse((t4) => {
                const e3 = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || t4(), e3;
              });
              if (e2.aborted)
                return;
              e2.thrown || (e2.error && (this.state = e2.failState), t3.returnType = e2.node);
            }
            return super.parseArrow(t3);
          }
          parseAssignableListItemTypes(t3) {
            this.eat(17) && (t3.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(t3.start, rd.PatternIsOptional), t3.optional = true);
            const e2 = this.tsTryParseTypeAnnotation();
            return e2 && (t3.typeAnnotation = e2), this.resetEndLocation(t3), t3;
          }
          isAssignable(t3, e2) {
            switch (t3.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(t3.expression, e2);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(t3, e2);
            }
          }
          toAssignable(t3) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            switch (t3.type) {
              case "TSTypeCastExpression":
                return super.toAssignable(this.typeCastToParameter(t3), e2);
              case "TSParameterProperty":
              default:
                return super.toAssignable(t3, e2);
              case "ParenthesizedExpression":
                return this.toAssignableParenthesizedExpression(t3, e2);
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                return t3.expression = this.toAssignable(t3.expression, e2), t3;
            }
          }
          toAssignableParenthesizedExpression(t3, e2) {
            switch (t3.expression.type) {
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                return t3.expression = this.toAssignable(t3.expression, e2), t3;
              default:
                return super.toAssignable(t3, e2);
            }
          }
          checkLVal(t3, e2) {
            for (var s2, r2 = arguments.length, i2 = new Array(r2 > 2 ? r2 - 2 : 0), n2 = 2; n2 < r2; n2++)
              i2[n2 - 2] = arguments[n2];
            switch (t3.type) {
              case "TSTypeCastExpression":
                return;
              case "TSParameterProperty":
                return void this.checkLVal(t3.parameter, "parameter property", ...i2);
              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!(i2[0] || e2 === "parenthesized expression" || (s2 = t3.extra) != null && s2.parenthesized)) {
                  this.raise(t3.start, Dc.InvalidLhs, e2);
                  break;
                }
                return void this.checkLVal(t3.expression, "parenthesized expression", ...i2);
              case "TSNonNullExpression":
                return void this.checkLVal(t3.expression, e2, ...i2);
              default:
                return void super.checkLVal(t3, e2, ...i2);
            }
          }
          parseBindingAtom() {
            return this.state.type === 72 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(t3) {
            if (this.match(43)) {
              const e2 = this.tsParseTypeArguments();
              if (this.match(10)) {
                const s2 = super.parseMaybeDecoratorArguments(t3);
                return s2.typeParameters = e2, s2;
              }
              this.unexpected(this.state.start, 10);
            }
            return super.parseMaybeDecoratorArguments(t3);
          }
          checkCommaAfterRest(t3) {
            this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === t3 ? this.next() : super.checkCommaAfterRest(t3);
          }
          isClassMethod() {
            return this.match(43) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(33) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault() {
            const t3 = super.parseMaybeDefault(...arguments);
            return t3.type === "AssignmentPattern" && t3.typeAnnotation && t3.right.start < t3.typeAnnotation.start && this.raise(t3.typeAnnotation.start, rd.TypeAnnotationAfterAssign), t3;
          }
          getTokenFromCode(t3) {
            if (this.state.inType) {
              if (t3 === 62)
                return this.finishOp(44, 1);
              if (t3 === 60)
                return this.finishOp(43, 1);
            }
            return super.getTokenFromCode(t3);
          }
          reScan_lt_gt() {
            const { type: t3 } = this.state;
            t3 === 43 ? (this.state.pos -= 1, this.readToken_lt()) : t3 === 44 && (this.state.pos -= 1, this.readToken_gt());
          }
          toAssignableList(t3) {
            for (let e2 = 0; e2 < t3.length; e2++) {
              const s2 = t3[e2];
              if (s2)
                switch (s2.type) {
                  case "TSTypeCastExpression":
                    t3[e2] = this.typeCastToParameter(s2);
                    break;
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    this.state.maybeInArrowParameters ? this.raise(s2.start, rd.UnexpectedTypeCastInParameter) : t3[e2] = this.typeCastToParameter(s2);
                }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(t3) {
            return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.end, t3.typeAnnotation.loc.end), t3.expression;
          }
          shouldParseArrow(t3) {
            return this.match(14) ? t3.every((t4) => this.isAssignable(t4, true)) : super.shouldParseArrow(t3);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(t3) {
            if (this.match(43)) {
              const e2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
              e2 && (t3.typeParameters = e2);
            }
            return super.jsxParseOpeningElementAfterName(t3);
          }
          getGetterSetterExpectedParamCount(t3) {
            const e2 = super.getGetterSetterExpectedParamCount(t3), s2 = this.getObjectOrClassMethodParams(t3)[0];
            return s2 && this.isThisParam(s2) ? e2 + 1 : e2;
          }
          parseCatchClauseParam() {
            const t3 = super.parseCatchClauseParam(), e2 = this.tsTryParseTypeAnnotation();
            return e2 && (t3.typeAnnotation = e2, this.resetEndLocation(t3)), t3;
          }
          tsInAmbientContext(t3) {
            const e2 = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return t3();
            } finally {
              this.state.isAmbientContext = e2;
            }
          }
          parseClass(t3) {
            const e2 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!t3.abstract;
            try {
              for (var s2 = arguments.length, r2 = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
                r2[i2 - 1] = arguments[i2];
              return super.parseClass(t3, ...r2);
            } finally {
              this.state.inAbstractClass = e2;
            }
          }
          tsParseAbstractDeclaration(t3) {
            if (this.match(74))
              return t3.abstract = true, this.parseClass(t3, true, false);
            if (this.isContextual(119)) {
              if (!this.hasFollowingLineBreak())
                return t3.abstract = true, this.raise(t3.start, rd.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(t3);
            } else
              this.unexpected(null, 74);
          }
          parseMethod() {
            const t3 = super.parseMethod(...arguments);
            if (t3.abstract) {
              if (this.hasPlugin("estree") ? !!t3.value.body : !!t3.body) {
                const { key: e2 } = t3;
                this.raise(t3.start, rd.AbstractMethodHasImplementation, e2.type !== "Identifier" || t3.computed ? "[".concat(this.input.slice(e2.start, e2.end), "]") : e2.name);
              }
            }
            return t3;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(t3, e2, s2, r2) {
            return !e2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(t3, false, s2), this.finishNode(t3, "ExportSpecifier")) : (t3.exportKind = "value", super.parseExportSpecifier(t3, e2, s2, r2));
          }
          parseImportSpecifier(t3, e2, s2, r2) {
            return !e2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(t3, true, s2), this.finishNode(t3, "ImportSpecifier")) : (t3.importKind = "value", super.parseImportSpecifier(t3, e2, s2, r2));
          }
          parseTypeOnlyImportExportSpecifier(t3, e2, s2) {
            const r2 = e2 ? "imported" : "local", i2 = e2 ? "local" : "exported";
            let n2, a2 = t3[r2], o2 = false, u2 = true;
            const h2 = a2.start;
            if (this.isContextual(87)) {
              const t4 = this.parseIdentifier();
              if (this.isContextual(87)) {
                const e3 = this.parseIdentifier();
                _c(this.state.type) ? (o2 = true, a2 = t4, n2 = this.parseIdentifier(), u2 = false) : (n2 = e3, u2 = false);
              } else
                _c(this.state.type) ? (u2 = false, n2 = this.parseIdentifier()) : (o2 = true, a2 = t4);
            } else
              _c(this.state.type) && (o2 = true, a2 = this.parseIdentifier());
            o2 && s2 && this.raise(h2, e2 ? rd.TypeModifierIsUsedInTypeImports : rd.TypeModifierIsUsedInTypeExports), t3[r2] = a2, t3[i2] = n2;
            t3[e2 ? "importKind" : "exportKind"] = o2 ? "type" : "value", u2 && this.eatContextual(87) && (t3[i2] = e2 ? this.parseIdentifier() : this.parseModuleExportName()), t3[i2] || (t3[i2] = _l(t3[r2])), e2 && this.checkLVal(t3[i2], "import specifier", 9);
          }
        }, v8intrinsic: (t2) => class extends t2 {
          parseV8Intrinsic() {
            if (this.match(48)) {
              const t3 = this.state.start, e2 = this.startNode();
              if (this.next(), Uc(this.state.type)) {
                const t4 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(e2, t4);
                if (s2.type = "V8IntrinsicIdentifier", this.match(10))
                  return s2;
              }
              this.unexpected(t3);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        }, placeholders: (t2) => class extends t2 {
          parsePlaceholder(t3) {
            if (this.match(134)) {
              const e2 = this.startNode();
              return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(134), this.finishPlaceholder(e2, t3);
            }
          }
          finishPlaceholder(t3, e2) {
            const s2 = !(!t3.expectedNode || t3.type !== "Placeholder");
            return t3.expectedNode = e2, s2 ? t3 : this.finishNode(t3, "Placeholder");
          }
          getTokenFromCode(t3) {
            return t3 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(134, 2) : super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(t3) {
            t3 !== void 0 && super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          checkLVal(t3) {
            t3.type !== "Placeholder" && super.checkLVal(...arguments);
          }
          toAssignable(t3) {
            return t3 && t3.type === "Placeholder" && t3.expectedNode === "Expression" ? (t3.expectedNode = "Pattern", t3) : super.toAssignable(...arguments);
          }
          isLet(t3) {
            if (super.isLet(t3))
              return true;
            if (!this.isContextual(93))
              return false;
            if (t3)
              return false;
            return this.lookahead().type === 134;
          }
          verifyBreakContinue(t3) {
            t3.label && t3.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(t3, e2) {
            if (e2.type !== "Placeholder" || e2.extra && e2.extra.parenthesized)
              return super.parseExpressionStatement(...arguments);
            if (this.match(14)) {
              const s2 = t3;
              return s2.label = this.finishPlaceholder(e2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
            }
            return this.semicolon(), t3.name = e2.name, this.finishPlaceholder(t3, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(t3, e2, s2) {
            const r2 = e2 ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(t3);
            const i2 = this.state.strict, n2 = this.parsePlaceholder("Identifier");
            if (n2)
              if (this.match(75) || this.match(134) || this.match(5))
                t3.id = n2;
              else {
                if (s2 || !e2)
                  return t3.id = null, t3.body = this.finishPlaceholder(n2, "ClassBody"), this.finishNode(t3, r2);
                this.unexpected(null, nd.ClassNameIsRequired);
              }
            else
              this.parseClassId(t3, e2, s2);
            return this.parseClassSuper(t3), t3.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t3.superClass, i2), this.finishNode(t3, r2);
          }
          parseExport(t3) {
            const e2 = this.parsePlaceholder("Identifier");
            if (!e2)
              return super.parseExport(...arguments);
            if (!this.isContextual(91) && !this.match(12))
              return t3.specifiers = [], t3.source = null, t3.declaration = this.finishPlaceholder(e2, "Declaration"), this.finishNode(t3, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const s2 = this.startNode();
            return s2.exported = e2, t3.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(t3);
          }
          isExportDefaultSpecifier() {
            if (this.match(59)) {
              const t3 = this.nextTokenStart();
              if (this.isUnparsedContextual(t3, "from") && this.input.startsWith(Wc(134), this.nextTokenStartSince(t3 + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(t3) {
            return !!(t3.specifiers && t3.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(t3) {
            const { specifiers: e2 } = t3;
            e2 != null && e2.length && (t3.specifiers = e2.filter((t4) => t4.exported.type === "Placeholder")), super.checkExport(t3), t3.specifiers = e2;
          }
          parseImport(t3) {
            const e2 = this.parsePlaceholder("Identifier");
            if (!e2)
              return super.parseImport(...arguments);
            if (t3.specifiers = [], !this.isContextual(91) && !this.match(12))
              return t3.source = this.finishPlaceholder(e2, "StringLiteral"), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
            const s2 = this.startNodeAtNode(e2);
            if (s2.local = e2, this.finishNode(s2, "ImportDefaultSpecifier"), t3.specifiers.push(s2), this.eat(12)) {
              this.maybeParseStarImportSpecifier(t3) || this.parseNamedImportSpecifiers(t3);
            }
            return this.expectContextual(91), t3.source = this.parseImportSource(), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
        } }, ld = Object.keys(cd), dd = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
        const Dd = (t2) => t2.type === "ParenthesizedExpression" ? Dd(t2.expression) : t2;
        const md = /* @__PURE__ */ new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
        const fd = { kind: "loop" }, yd = { kind: "switch" }, Ed = /[\uD800-\uDFFF]/u, Ad = /in(?:stanceof)?/y;
        class Cd extends class extends class extends class extends class extends class extends class extends class extends class extends class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t2) {
            return this.plugins.has(t2);
          }
          getPluginOption(t2, e2) {
            if (this.hasPlugin(t2))
              return this.plugins.get(t2)[e2];
          }
        } {
          addComment(t2) {
            this.filename && (t2.loc.filename = this.filename), this.state.comments.push(t2);
          }
          processComment(t2) {
            const { commentStack: e2 } = this.state, s2 = e2.length;
            if (s2 === 0)
              return;
            let r2 = s2 - 1;
            const i2 = e2[r2];
            i2.start === t2.end && (i2.leadingNode = t2, r2--);
            const { start: n2 } = t2;
            for (; r2 >= 0; r2--) {
              const s3 = e2[r2], i3 = s3.end;
              if (!(i3 > n2)) {
                i3 === n2 && (s3.trailingNode = t2);
                break;
              }
              s3.containingNode = t2, this.finalizeComment(s3), e2.splice(r2, 1);
            }
          }
          finalizeComment(t2) {
            const { comments: e2 } = t2;
            if (t2.leadingNode !== null || t2.trailingNode !== null)
              t2.leadingNode !== null && pc(t2.leadingNode, e2), t2.trailingNode !== null && function(t3, e3) {
                t3.leadingComments === void 0 ? t3.leadingComments = e3 : t3.leadingComments.unshift(...e3);
              }(t2.trailingNode, e2);
            else {
              const { containingNode: s2, start: r2 } = t2;
              if (this.input.charCodeAt(r2 - 1) === 44)
                switch (s2.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    lc(s2, s2.properties, t2);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    lc(s2, s2.arguments, t2);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    lc(s2, s2.params, t2);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    lc(s2, s2.elements, t2);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    lc(s2, s2.specifiers, t2);
                    break;
                  default:
                    cc(s2, e2);
                }
              else
                cc(s2, e2);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: t2 } = this.state;
            for (let e2 = t2.length - 1; e2 >= 0; e2--)
              this.finalizeComment(t2[e2]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(t2) {
            const { commentStack: e2 } = this.state, { length: s2 } = e2;
            if (s2 === 0)
              return;
            const r2 = e2[s2 - 1];
            r2.leadingNode === t2 && (r2.leadingNode = null);
          }
          takeSurroundingComments(t2, e2, s2) {
            const { commentStack: r2 } = this.state, i2 = r2.length;
            if (i2 === 0)
              return;
            let n2 = i2 - 1;
            for (; n2 >= 0; n2--) {
              const i3 = r2[n2], a2 = i3.end;
              if (i3.start === s2)
                i3.leadingNode = t2;
              else if (a2 === e2)
                i3.trailingNode = t2;
              else if (a2 < e2)
                break;
            }
          }
        } {
          getLocationForPosition(t2) {
            let e2;
            return e2 = t2 === this.state.start ? this.state.startLoc : t2 === this.state.lastTokStart ? this.state.lastTokStartLoc : t2 === this.state.end ? this.state.endLoc : t2 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(t3, e3) {
              let s2, r2 = 1, i2 = 0;
              for (rc.lastIndex = 0; (s2 = rc.exec(t3)) && s2.index < e3; )
                r2++, i2 = rc.lastIndex;
              return new uc(r2, e3 - i2);
            }(this.input, t2), e2;
          }
          raise(t2, e2) {
            let { code: s2, reasonCode: r2, template: i2 } = e2;
            for (var n2 = arguments.length, a2 = new Array(n2 > 2 ? n2 - 2 : 0), o2 = 2; o2 < n2; o2++)
              a2[o2 - 2] = arguments[o2];
            return this.raiseWithData(t2, { code: s2, reasonCode: r2 }, i2, ...a2);
          }
          raiseOverwrite(t2, e2) {
            let { code: s2, template: r2 } = e2;
            for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), a2 = 2; a2 < i2; a2++)
              n2[a2 - 2] = arguments[a2];
            const o2 = this.getLocationForPosition(t2), u2 = r2.replace(/%(\d+)/g, (t3, e3) => n2[e3]) + " (".concat(o2.line, ":").concat(o2.column, ")");
            if (this.options.errorRecovery) {
              const e3 = this.state.errors;
              for (let s3 = e3.length - 1; s3 >= 0; s3--) {
                const r3 = e3[s3];
                if (r3.pos === t2)
                  return Object.assign(r3, { message: u2 });
                if (r3.pos < t2)
                  break;
              }
            }
            return this._raise({ code: s2, loc: o2, pos: t2 }, u2);
          }
          raiseWithData(t2, e2, s2) {
            for (var r2 = arguments.length, i2 = new Array(r2 > 3 ? r2 - 3 : 0), n2 = 3; n2 < r2; n2++)
              i2[n2 - 3] = arguments[n2];
            const a2 = this.getLocationForPosition(t2), o2 = s2.replace(/%(\d+)/g, (t3, e3) => i2[e3]) + " (".concat(a2.line, ":").concat(a2.column, ")");
            return this._raise(Object.assign({ loc: a2, pos: t2 }, e2), o2);
          }
          _raise(t2, e2) {
            const s2 = new SyntaxError(e2);
            if (Object.assign(s2, t2), this.options.errorRecovery)
              return this.isLookahead || this.state.errors.push(s2), s2;
            throw s2;
          }
        } {
          constructor(t2, e2) {
            super(), this.isLookahead = void 0, this.tokens = [], this.state = new gl(), this.state.init(t2), this.input = e2, this.length = e2.length, this.isLookahead = false;
          }
          pushToken(t2) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new wl(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t2) {
            return !!this.match(t2) && (this.next(), true);
          }
          match(t2) {
            return this.state.type === t2;
          }
          createLookaheadState(t2) {
            return { pos: t2.pos, value: null, type: t2.type, start: t2.start, end: t2.end, lastTokEnd: t2.end, context: [this.curContext()], inType: t2.inType };
          }
          lookahead() {
            const t2 = this.state;
            this.state = this.createLookaheadState(t2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const e2 = this.state;
            return this.state = t2, e2;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t2) {
            return nc.lastIndex = t2, nc.test(this.input) ? nc.lastIndex : t2;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          codePointAtPos(t2) {
            let e2 = this.input.charCodeAt(t2);
            if ((64512 & e2) == 55296 && ++t2 < this.input.length) {
              const s2 = this.input.charCodeAt(t2);
              (64512 & s2) == 56320 && (e2 = 65536 + ((1023 & e2) << 10) + (1023 & s2));
            }
            return e2;
          }
          setStrict(t2) {
            this.state.strict = t2, t2 && (this.state.strictErrors.forEach((t3, e2) => this.raise(e2, t3)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            const t2 = this.curContext();
            t2.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(129) : t2 === Ac.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment() {
            let t2;
            this.isLookahead || (t2 = this.state.curPosition());
            const e2 = this.state.pos, s2 = this.input.indexOf("*/", e2 + 2);
            if (s2 === -1)
              throw this.raise(e2, Dc.UnterminatedComment);
            for (this.state.pos = s2 + 2, rc.lastIndex = e2 + 2; rc.test(this.input) && rc.lastIndex <= s2; )
              ++this.state.curLine, this.state.lineStart = rc.lastIndex;
            if (this.isLookahead)
              return;
            const r2 = { type: "CommentBlock", value: this.input.slice(e2 + 2, s2), start: e2, end: s2 + 2, loc: new hc(t2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(r2), r2;
          }
          skipLineComment(t2) {
            const e2 = this.state.pos;
            let s2;
            this.isLookahead || (s2 = this.state.curPosition());
            let r2 = this.input.charCodeAt(this.state.pos += t2);
            if (this.state.pos < this.length)
              for (; !ic(r2) && ++this.state.pos < this.length; )
                r2 = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            const i2 = this.state.pos, n2 = { type: "CommentLine", value: this.input.slice(e2 + t2, i2), start: e2, end: i2, loc: new hc(s2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(n2), n2;
          }
          skipSpace() {
            const t2 = this.state.pos, e2 = [];
            t:
              for (; this.state.pos < this.length; ) {
                const s2 = this.input.charCodeAt(this.state.pos);
                switch (s2) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        const t3 = this.skipBlockComment();
                        t3 !== void 0 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                        break;
                      }
                      case 47: {
                        const t3 = this.skipLineComment(2);
                        t3 !== void 0 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                        break;
                      }
                      default:
                        break t;
                    }
                    break;
                  default:
                    if (oc(s2))
                      ++this.state.pos;
                    else if (s2 !== 45 || this.inModule) {
                      if (s2 !== 60 || this.inModule)
                        break t;
                      {
                        const t3 = this.state.pos;
                        if (this.input.charCodeAt(t3 + 1) !== 33 || this.input.charCodeAt(t3 + 2) !== 45 || this.input.charCodeAt(t3 + 3) !== 45)
                          break t;
                        {
                          const t4 = this.skipLineComment(4);
                          t4 !== void 0 && (this.addComment(t4), this.options.attachComment && e2.push(t4));
                        }
                      }
                    } else {
                      const s3 = this.state.pos;
                      if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(t2 === 0 || this.state.lineStart > t2))
                        break t;
                      {
                        const t3 = this.skipLineComment(3);
                        t3 !== void 0 && (this.addComment(t3), this.options.attachComment && e2.push(t3));
                      }
                    }
                }
              }
            if (e2.length > 0) {
              const s2 = { start: t2, end: this.state.pos, comments: e2, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(s2);
            }
          }
          finishToken(t2, e2) {
            this.state.end = this.state.pos;
            const s2 = this.state.type;
            this.state.type = t2, this.state.value = e2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
          }
          replaceToken(t2) {
            this.state.type = t2, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            const t2 = this.state.pos + 1, e2 = this.codePointAtPos(t2);
            if (e2 >= 48 && e2 <= 57)
              throw this.raise(this.state.pos, Dc.UnexpectedDigitAfterHash);
            if (e2 === 123 || e2 === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
                throw this.raise(this.state.pos, e2 === 123 ? Dc.RecordExpressionHashIncorrectStartSyntaxType : Dc.TupleExpressionHashIncorrectStartSyntaxType);
              this.state.pos += 2, e2 === 123 ? this.finishToken(7) : this.finishToken(1);
            } else
              el(e2) ? (++this.state.pos, this.finishToken(128, this.readWord1(e2))) : e2 === 92 ? (++this.state.pos, this.finishToken(128, this.readWord1())) : this.finishOp(25, 1);
          }
          readToken_dot() {
            const t2 = this.input.charCodeAt(this.state.pos + 1);
            t2 >= 48 && t2 <= 57 ? this.readNumber(true) : t2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(29, 2) : this.finishOp(50, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            if (t2 !== 33)
              return false;
            const e2 = this.state.pos;
            for (this.state.pos += 1; !ic(t2) && ++this.state.pos < this.length; )
              t2 = this.input.charCodeAt(this.state.pos);
            const s2 = this.input.slice(e2 + 2, this.state.pos);
            return this.finishToken(26, s2), true;
          }
          readToken_mult_modulo(t2) {
            let e2 = t2 === 42 ? 49 : 48, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
            t2 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), e2 = 51), r2 !== 61 || this.state.inType || (s2++, e2 = t2 === 37 ? 31 : 28), this.finishOp(e2, s2);
          }
          readToken_pipe_amp(t2) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 !== t2) {
              if (t2 === 124) {
                if (e2 === 62)
                  return void this.finishOp(35, 2);
                if (this.hasPlugin("recordAndTuple") && e2 === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, Dc.RecordExpressionBarIncorrectEndSyntaxType);
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && e2 === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, Dc.TupleExpressionBarIncorrectEndSyntaxType);
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              e2 !== 61 ? this.finishOp(t2 === 124 ? 39 : 41, 1) : this.finishOp(28, 2);
            } else
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(28, 3) : this.finishOp(t2 === 124 ? 37 : 38, 2);
          }
          readToken_caret() {
            this.input.charCodeAt(this.state.pos + 1) !== 61 || this.state.inType ? this.finishOp(40, 1) : this.finishOp(30, 2);
          }
          readToken_plus_min(t2) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            e2 !== t2 ? e2 === 61 ? this.finishOp(28, 2) : this.finishOp(47, 1) : this.finishOp(32, 2);
          }
          readToken_lt() {
            const { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 60)
              return this.input.charCodeAt(t2 + 2) === 61 ? void this.finishOp(28, 3) : void this.finishOp(46, 2);
            e2 !== 61 ? this.finishOp(43, 1) : this.finishOp(45, 2);
          }
          readToken_gt() {
            const { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 62) {
              const e3 = this.input.charCodeAt(t2 + 2) === 62 ? 3 : 2;
              return this.input.charCodeAt(t2 + e3) === 61 ? void this.finishOp(28, e3 + 1) : void this.finishOp(46, e3);
            }
            e2 !== 61 ? this.finishOp(44, 1) : this.finishOp(45, 2);
          }
          readToken_eq_excl(t2) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 !== 61)
              return t2 === 61 && e2 === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(t2 === 61 ? 27 : 33, 1);
            this.finishOp(42, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const t2 = this.input.charCodeAt(this.state.pos + 1), e2 = this.input.charCodeAt(this.state.pos + 2);
            t2 === 63 ? e2 === 61 ? this.finishOp(28, 3) : this.finishOp(36, 2) : t2 !== 46 || e2 >= 48 && e2 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(t2) {
            switch (t2) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, Dc.TupleExpressionBarIncorrectStartSyntaxType);
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(this.state.pos, Dc.RecordExpressionBarIncorrectStartSyntaxType);
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return ++this.state.pos, void this.finishToken(22);
              case 48: {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                if (t3 === 120 || t3 === 88)
                  return void this.readRadixNumber(16);
                if (t3 === 111 || t3 === 79)
                  return void this.readRadixNumber(8);
                if (t3 === 98 || t3 === 66)
                  return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(t2);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(t2);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(t2);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(t2);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(t2);
              case 126:
                return void this.finishOp(34, 1);
              case 64:
                return ++this.state.pos, void this.finishToken(24);
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (el(t2))
                  return void this.readWord(t2);
            }
            throw this.raise(this.state.pos, Dc.InvalidOrUnexpectedToken, String.fromCodePoint(t2));
          }
          finishOp(t2, e2) {
            const s2 = this.input.slice(this.state.pos, this.state.pos + e2);
            this.state.pos += e2, this.finishToken(t2, s2);
          }
          readRegexp() {
            const t2 = this.state.start + 1;
            let e2, s2, { pos: r2 } = this.state;
            for (; ; ++r2) {
              if (r2 >= this.length)
                throw this.raise(t2, Dc.UnterminatedRegExp);
              const i3 = this.input.charCodeAt(r2);
              if (ic(i3))
                throw this.raise(t2, Dc.UnterminatedRegExp);
              if (e2)
                e2 = false;
              else {
                if (i3 === 91)
                  s2 = true;
                else if (i3 === 93 && s2)
                  s2 = false;
                else if (i3 === 47 && !s2)
                  break;
                e2 = i3 === 92;
              }
            }
            const i2 = this.input.slice(t2, r2);
            ++r2;
            let n2 = "";
            for (; r2 < this.length; ) {
              const t3 = this.codePointAtPos(r2), e3 = String.fromCharCode(t3);
              if (Tl.has(t3))
                n2.includes(e3) && this.raise(r2 + 1, Dc.DuplicateRegExpFlags);
              else {
                if (!sl(t3) && t3 !== 92)
                  break;
                this.raise(r2 + 1, Dc.MalformedRegExpFlags);
              }
              ++r2, n2 += e3;
            }
            this.state.pos = r2, this.finishToken(127, { pattern: i2, flags: n2 });
          }
          readInt(t2, e2, s2) {
            let r2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            const i2 = this.state.pos, n2 = t2 === 16 ? bl.hex : bl.decBinOct, a2 = t2 === 16 ? Sl.hex : t2 === 10 ? Sl.dec : t2 === 8 ? Sl.oct : Sl.bin;
            let o2 = false, u2 = 0;
            for (let i3 = 0, h2 = e2 == null ? 1 / 0 : e2; i3 < h2; ++i3) {
              const e3 = this.input.charCodeAt(this.state.pos);
              let h3;
              if (e3 !== 95) {
                if (h3 = e3 >= 97 ? e3 - 97 + 10 : e3 >= 65 ? e3 - 65 + 10 : Pl(e3) ? e3 - 48 : 1 / 0, h3 >= t2)
                  if (this.options.errorRecovery && h3 <= 9)
                    h3 = 0, this.raise(this.state.start + i3 + 2, Dc.InvalidDigit, t2);
                  else {
                    if (!s2)
                      break;
                    h3 = 0, o2 = true;
                  }
                ++this.state.pos, u2 = u2 * t2 + h3;
              } else {
                const t3 = this.input.charCodeAt(this.state.pos - 1), e4 = this.input.charCodeAt(this.state.pos + 1);
                (a2.indexOf(e4) === -1 || n2.indexOf(t3) > -1 || n2.indexOf(e4) > -1 || Number.isNaN(e4)) && this.raise(this.state.pos, Dc.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Dc.NumericSeparatorInEscapeSequence), ++this.state.pos;
              }
            }
            return this.state.pos === i2 || e2 != null && this.state.pos - i2 !== e2 || o2 ? null : u2;
          }
          readRadixNumber(t2) {
            const e2 = this.state.pos;
            let s2 = false;
            this.state.pos += 2;
            const r2 = this.readInt(t2);
            r2 == null && this.raise(this.state.start + 2, Dc.InvalidDigit, t2);
            const i2 = this.input.charCodeAt(this.state.pos);
            if (i2 === 110)
              ++this.state.pos, s2 = true;
            else if (i2 === 109)
              throw this.raise(e2, Dc.InvalidDecimal);
            if (el(this.codePointAtPos(this.state.pos)))
              throw this.raise(this.state.pos, Dc.NumberIdentifier);
            if (s2) {
              const t3 = this.input.slice(e2, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(125, t3);
            } else
              this.finishToken(124, r2);
          }
          readNumber(t2) {
            const e2 = this.state.pos;
            let s2 = false, r2 = false, i2 = false, n2 = false, a2 = false;
            t2 || this.readInt(10) !== null || this.raise(e2, Dc.InvalidNumber);
            const o2 = this.state.pos - e2 >= 2 && this.input.charCodeAt(e2) === 48;
            if (o2) {
              const t3 = this.input.slice(e2, this.state.pos);
              if (this.recordStrictModeErrors(e2, Dc.StrictOctalLiteral), !this.state.strict) {
                const s3 = t3.indexOf("_");
                s3 > 0 && this.raise(s3 + e2, Dc.ZeroDigitNumericSeparator);
              }
              a2 = o2 && !/[89]/.test(t3);
            }
            let u2 = this.input.charCodeAt(this.state.pos);
            if (u2 !== 46 || a2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || a2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(e2, Dc.InvalidOrMissingExponent), s2 = true, n2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(e2, Dc.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (n2 || o2) && this.raise(e2, Dc.InvalidDecimal), ++this.state.pos, i2 = true), el(this.codePointAtPos(this.state.pos)))
              throw this.raise(this.state.pos, Dc.NumberIdentifier);
            const h2 = this.input.slice(e2, this.state.pos).replace(/[_mn]/g, "");
            if (r2)
              return void this.finishToken(125, h2);
            if (i2)
              return void this.finishToken(126, h2);
            const p2 = a2 ? parseInt(h2, 8) : parseFloat(h2);
            this.finishToken(124, p2);
          }
          readCodePoint(t2) {
            let e2;
            if (this.input.charCodeAt(this.state.pos) === 123) {
              const s2 = ++this.state.pos;
              if (e2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, t2), ++this.state.pos, e2 !== null && e2 > 1114111) {
                if (!t2)
                  return null;
                this.raise(s2, Dc.InvalidCodePoint);
              }
            } else
              e2 = this.readHexChar(4, false, t2);
            return e2;
          }
          readString(t2) {
            let e2 = "", s2 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, Dc.UnterminatedString);
              const r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === t2)
                break;
              if (r2 === 92)
                e2 += this.input.slice(s2, this.state.pos), e2 += this.readEscapedChar(false), s2 = this.state.pos;
              else if (r2 === 8232 || r2 === 8233)
                ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              else {
                if (ic(r2))
                  throw this.raise(this.state.start, Dc.UnterminatedString);
                ++this.state.pos;
              }
            }
            e2 += this.input.slice(s2, this.state.pos++), this.finishToken(123, e2);
          }
          readTmplToken() {
            let t2 = "", e2 = this.state.pos, s2 = false;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, Dc.UnterminatedTemplate);
              const r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
                return this.state.pos === this.state.start && this.match(20) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(23)) : (++this.state.pos, void this.finishToken(22)) : (t2 += this.input.slice(e2, this.state.pos), void this.finishToken(20, s2 ? null : t2));
              if (r2 === 92) {
                t2 += this.input.slice(e2, this.state.pos);
                const r3 = this.readEscapedChar(true);
                r3 === null ? s2 = true : t2 += r3, e2 = this.state.pos;
              } else if (ic(r2)) {
                switch (t2 += this.input.slice(e2, this.state.pos), ++this.state.pos, r2) {
                  case 13:
                    this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                  case 10:
                    t2 += "\n";
                    break;
                  default:
                    t2 += String.fromCharCode(r2);
                }
                ++this.state.curLine, this.state.lineStart = this.state.pos, e2 = this.state.pos;
              } else
                ++this.state.pos;
            }
          }
          recordStrictModeErrors(t2, e2) {
            this.state.strict && !this.state.strictErrors.has(t2) ? this.raise(t2, e2) : this.state.strictErrors.set(t2, e2);
          }
          readEscapedChar(t2) {
            const e2 = !t2, s2 = this.input.charCodeAt(++this.state.pos);
            switch (++this.state.pos, s2) {
              case 110:
                return "\n";
              case 114:
                return "\r";
              case 120: {
                const t3 = this.readHexChar(2, false, e2);
                return t3 === null ? null : String.fromCharCode(t3);
              }
              case 117: {
                const t3 = this.readCodePoint(e2);
                return t3 === null ? null : String.fromCodePoint(t3);
              }
              case 116:
                return "	";
              case 98:
                return "\b";
              case 118:
                return "\v";
              case 102:
                return "\f";
              case 13:
                this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
              case 10:
                this.state.lineStart = this.state.pos, ++this.state.curLine;
              case 8232:
              case 8233:
                return "";
              case 56:
              case 57:
                if (t2)
                  return null;
                this.recordStrictModeErrors(this.state.pos - 1, Dc.StrictNumericEscape);
              default:
                if (s2 >= 48 && s2 <= 55) {
                  const e3 = this.state.pos - 1;
                  let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
                  r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
                  const i2 = this.input.charCodeAt(this.state.pos);
                  if (s3 !== "0" || i2 === 56 || i2 === 57) {
                    if (t2)
                      return null;
                    this.recordStrictModeErrors(e3, Dc.StrictNumericEscape);
                  }
                  return String.fromCharCode(r2);
                }
                return String.fromCharCode(s2);
            }
          }
          readHexChar(t2, e2, s2) {
            const r2 = this.state.pos, i2 = this.readInt(16, t2, e2, false);
            return i2 === null && (s2 ? this.raise(r2, Dc.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
          }
          readWord1(t2) {
            this.state.containsEsc = false;
            let e2 = "";
            const s2 = this.state.pos;
            let r2 = this.state.pos;
            for (t2 !== void 0 && (this.state.pos += t2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const t3 = this.codePointAtPos(this.state.pos);
              if (sl(t3))
                this.state.pos += t3 <= 65535 ? 1 : 2;
              else {
                if (t3 !== 92)
                  break;
                {
                  this.state.containsEsc = true, e2 += this.input.slice(r2, this.state.pos);
                  const t4 = this.state.pos, i2 = this.state.pos === s2 ? el : sl;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(this.state.pos, Dc.MissingUnicodeEscape), r2 = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const n2 = this.readCodePoint(true);
                  n2 !== null && (i2(n2) || this.raise(t4, Dc.EscapedCharNotAnIdentifier), e2 += String.fromCodePoint(n2)), r2 = this.state.pos;
                }
              }
            }
            return e2 + this.input.slice(r2, this.state.pos);
          }
          readWord(t2) {
            const e2 = this.readWord1(t2), s2 = bc.get(e2);
            s2 !== void 0 ? this.finishToken(s2, Wc(s2)) : this.finishToken(122, e2);
          }
          checkKeywordEscapes() {
            const { type: t2 } = this.state;
            qc(t2) && this.state.containsEsc && this.raise(this.state.start, Dc.InvalidEscapedReservedWord, Wc(t2));
          }
          updateContext(t2) {
            const { context: e2, type: s2 } = this.state;
            switch (s2) {
              case 8:
                e2.pop();
                break;
              case 5:
              case 7:
              case 23:
                e2.push(Ac.brace);
                break;
              case 22:
                e2[e2.length - 1] === Ac.template ? e2.pop() : e2.push(Ac.template);
            }
          }
        } {
          addExtra(t2, e2, s2) {
            if (!t2)
              return;
            (t2.extra = t2.extra || {})[e2] = s2;
          }
          isContextual(t2) {
            return this.state.type === t2 && !this.state.containsEsc;
          }
          isUnparsedContextual(t2, e2) {
            const s2 = t2 + e2.length;
            if (this.input.slice(t2, s2) === e2) {
              const t3 = this.input.charCodeAt(s2);
              return !(sl(t3) || (64512 & t3) == 55296);
            }
            return false;
          }
          isLookaheadContextual(t2) {
            const e2 = this.nextTokenStart();
            return this.isUnparsedContextual(e2, t2);
          }
          eatContextual(t2) {
            return !!this.isContextual(t2) && (this.next(), true);
          }
          expectContextual(t2, e2) {
            this.eatContextual(t2) || this.unexpected(null, e2);
          }
          canInsertSemicolon() {
            return this.match(129) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return sc.test(this.input.slice(this.state.lastTokEnd, this.state.start));
          }
          hasFollowingLineBreak() {
            return ac.lastIndex = this.state.end, ac.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon() {
            (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0] ? this.isLineTerminator() : this.eat(13)) || this.raise(this.state.lastTokEnd, Dc.MissingSemicolon);
          }
          expect(t2, e2) {
            this.eat(t2) || this.unexpected(e2, t2);
          }
          assertNoSpace() {
            let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Unexpected space.";
            this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, { code: dc.SyntaxError, reasonCode: "UnexpectedSpace", template: t2 });
          }
          unexpected(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { code: dc.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token" };
            throw typeof e2 == "number" && (e2 = { code: dc.SyntaxError, reasonCode: "UnexpectedToken", template: 'Unexpected token, expected "'.concat(Wc(e2), '"') }), this.raise(t2 != null ? t2 : this.state.start, e2);
          }
          expectPlugin(t2, e2) {
            if (!this.hasPlugin(t2))
              throw this.raiseWithData(e2 != null ? e2 : this.state.start, { missingPlugin: [t2] }, "This experimental syntax requires enabling the parser plugin: '".concat(t2, "'"));
            return true;
          }
          expectOnePlugin(t2, e2) {
            if (!t2.some((t3) => this.hasPlugin(t3)))
              throw this.raiseWithData(e2 != null ? e2 : this.state.start, { missingPlugin: t2 }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t2.join(", "), "'"));
          }
          tryParse(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone();
            const s2 = { node: null };
            try {
              const r2 = t2(function() {
                let t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                throw s2.node = t3, s2;
              });
              if (this.state.errors.length > e2.errors.length) {
                const t3 = this.state;
                return this.state = e2, this.state.tokensLength = t3.tokensLength, { node: r2, error: t3.errors[e2.errors.length], thrown: false, aborted: false, failState: t3 };
              }
              return { node: r2, error: null, thrown: false, aborted: false, failState: null };
            } catch (t3) {
              const r2 = this.state;
              if (this.state = e2, t3 instanceof SyntaxError)
                return { node: null, error: t3, thrown: true, aborted: false, failState: r2 };
              if (t3 === s2)
                return { node: s2.node, error: null, thrown: false, aborted: true, failState: r2 };
              throw t3;
            }
          }
          checkExpressionErrors(t2, e2) {
            if (!t2)
              return false;
            const { shorthandAssign: s2, doubleProto: r2, optionalParameters: i2 } = t2, n2 = s2 + r2 + i2 > -3;
            if (!e2)
              return n2;
            n2 && (s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Dc.DuplicateProto), i2 >= 0 && this.unexpected(i2));
          }
          isLiteralPropertyName() {
            return zc(this.state.type);
          }
          isPrivateName(t2) {
            return t2.type === "PrivateName";
          }
          getPrivateNameSV(t2) {
            return t2.id.name;
          }
          hasPropertyAsPrivateName(t2) {
            return (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression") && this.isPrivateName(t2.property);
          }
          isOptionalChain(t2) {
            return t2.type === "OptionalMemberExpression" || t2.type === "OptionalCallExpression";
          }
          isObjectProperty(t2) {
            return t2.type === "ObjectProperty";
          }
          isObjectMethod(t2) {
            return t2.type === "ObjectMethod";
          }
          initializeScopes() {
            let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module";
            const e2 = this.state.labels;
            this.state.labels = [];
            const s2 = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const r2 = this.inModule;
            this.inModule = t2;
            const i2 = this.scope, n2 = this.getScopeHandler();
            this.scope = new n2(this.raise.bind(this), this.inModule);
            const a2 = this.prodParam;
            this.prodParam = new Ol();
            const o2 = this.classScope;
            this.classScope = new Nl(this.raise.bind(this));
            const u2 = this.expressionScope;
            return this.expressionScope = new kl(this.raise.bind(this)), () => {
              this.state.labels = e2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = a2, this.classScope = o2, this.expressionScope = u2;
            };
          }
          enterInitialScopes() {
            let t2 = 0;
            this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2);
          }
        } {
          startNode() {
            return new jl(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(t2, e2) {
            return new jl(this, t2, e2);
          }
          startNodeAtNode(t2) {
            return this.startNodeAt(t2.start, t2.loc.start);
          }
          finishNode(t2, e2) {
            return this.finishNodeAt(t2, e2, this.state.lastTokEnd, this.state.lastTokEndLoc);
          }
          finishNodeAt(t2, e2, s2, r2) {
            return t2.type = e2, t2.end = s2, t2.loc.end = r2, this.options.ranges && (t2.range[1] = s2), this.options.attachComment && this.processComment(t2), t2;
          }
          resetStartLocation(t2, e2, s2) {
            t2.start = e2, t2.loc.start = s2, this.options.ranges && (t2.range[0] = e2);
          }
          resetEndLocation(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEnd, s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.state.lastTokEndLoc;
            t2.end = e2, t2.loc.end = s2, this.options.ranges && (t2.range[1] = e2);
          }
          resetStartLocationFromNode(t2, e2) {
            this.resetStartLocation(t2, e2.start, e2.loc.start);
          }
        } {
          toAssignable(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            var s2, r2;
            let i2;
            switch ((t2.type === "ParenthesizedExpression" || (s2 = t2.extra) != null && s2.parenthesized) && (i2 = Dd(t2), e2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(t2.start, Dc.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(t2.start, Dc.InvalidParenthesizedAssignment) : this.raise(t2.start, Dc.InvalidParenthesizedAssignment)), t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                t2.type = "ObjectPattern";
                for (let s3 = 0, r3 = t2.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
                  var n2;
                  const r4 = t2.properties[s3], a2 = s3 === i3;
                  this.toAssignableObjectExpressionProp(r4, a2, e2), a2 && r4.type === "RestElement" && (n2 = t2.extra) != null && n2.trailingComma && this.raiseRestNotLast(t2.extra.trailingComma);
                }
                break;
              case "ObjectProperty":
                this.toAssignable(t2.value, e2);
                break;
              case "SpreadElement": {
                this.checkToRestConversion(t2), t2.type = "RestElement";
                const s3 = t2.argument;
                this.toAssignable(s3, e2);
                break;
              }
              case "ArrayExpression":
                t2.type = "ArrayPattern", this.toAssignableList(t2.elements, (r2 = t2.extra) == null ? void 0 : r2.trailingComma, e2);
                break;
              case "AssignmentExpression":
                t2.operator !== "=" && this.raise(t2.left.end, Dc.MissingEqInAssignment), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, e2);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(i2, e2);
            }
            return t2;
          }
          toAssignableObjectExpressionProp(t2, e2, s2) {
            if (t2.type === "ObjectMethod") {
              const e3 = t2.kind === "get" || t2.kind === "set" ? Dc.PatternHasAccessor : Dc.PatternHasMethod;
              this.raise(t2.key.start, e3);
            } else
              t2.type !== "SpreadElement" || e2 ? this.toAssignable(t2, s2) : this.raiseRestNotLast(t2.start);
          }
          toAssignableList(t2, e2, s2) {
            let r2 = t2.length;
            if (r2) {
              const i2 = t2[r2 - 1];
              if ((i2 == null ? void 0 : i2.type) === "RestElement")
                --r2;
              else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
                i2.type = "RestElement";
                let t3 = i2.argument;
                this.toAssignable(t3, s2), t3 = Dd(t3), t3.type !== "Identifier" && t3.type !== "MemberExpression" && t3.type !== "ArrayPattern" && t3.type !== "ObjectPattern" && this.unexpected(t3.start), e2 && this.raiseTrailingCommaAfterRest(e2), --r2;
              }
            }
            for (let e3 = 0; e3 < r2; e3++) {
              const r3 = t2[e3];
              r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
            }
            return t2;
          }
          isAssignable(t2, e2) {
            switch (t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                const e3 = t2.properties.length - 1;
                return t2.properties.every((t3, s2) => t3.type !== "ObjectMethod" && (s2 === e3 || t3.type !== "SpreadElement") && this.isAssignable(t3));
              }
              case "ObjectProperty":
                return this.isAssignable(t2.value);
              case "SpreadElement":
                return this.isAssignable(t2.argument);
              case "ArrayExpression":
                return t2.elements.every((t3) => t3 === null || this.isAssignable(t3));
              case "AssignmentExpression":
                return t2.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(t2.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e2;
              default:
                return false;
            }
          }
          toReferencedList(t2, e2) {
            return t2;
          }
          toReferencedListDeep(t2, e2) {
            this.toReferencedList(t2, e2);
            for (const e3 of t2)
              (e3 == null ? void 0 : e3.type) === "ArrayExpression" && this.toReferencedListDeep(e3.elements);
          }
          parseSpread(t2, e2) {
            const s2 = this.startNode();
            return this.next(), s2.argument = this.parseMaybeAssignAllowIn(t2, void 0, e2), this.finishNode(s2, "SpreadElement");
          }
          parseRestBinding() {
            const t2 = this.startNode();
            return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const t2 = this.startNode();
                return this.next(), t2.elements = this.parseBindingList(3, 93, true), this.finishNode(t2, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t2, e2, s2, r2) {
            const i2 = [];
            let n2 = true;
            for (; !this.eat(t2); )
              if (n2 ? n2 = false : this.expect(12), s2 && this.match(12))
                i2.push(null);
              else {
                if (this.eat(t2))
                  break;
                if (this.match(21)) {
                  i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e2), this.expect(t2);
                  break;
                }
                {
                  const t3 = [];
                  for (this.match(24) && this.hasPlugin("decorators") && this.raise(this.state.start, Dc.UnsupportedParameterDecorator); this.match(24); )
                    t3.push(this.parseDecorator());
                  i2.push(this.parseAssignableListItem(r2, t3));
                }
              }
            return i2;
          }
          parseBindingRestProperty(t2) {
            return this.next(), t2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t2, "RestElement");
          }
          parseBindingProperty() {
            const t2 = this.startNode(), { type: e2, start: s2, startLoc: r2 } = this.state;
            return e2 === 21 ? this.parseBindingRestProperty(t2) : (this.parsePropertyName(t2), t2.method = false, this.parseObjPropValue(t2, s2, r2, false, false, true, false), t2);
          }
          parseAssignableListItem(t2, e2) {
            const s2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s2);
            const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
            return e2.length && (s2.decorators = e2), r2;
          }
          parseAssignableListItemTypes(t2) {
            return t2;
          }
          parseMaybeDefault(t2, e2, s2) {
            var r2, i2, n2;
            if (e2 = (r2 = e2) != null ? r2 : this.state.startLoc, t2 = (i2 = t2) != null ? i2 : this.state.start, s2 = (n2 = s2) != null ? n2 : this.parseBindingAtom(), !this.eat(27))
              return s2;
            const a2 = this.startNodeAt(t2, e2);
            return a2.left = s2, a2.right = this.parseMaybeAssignAllowIn(), this.finishNode(a2, "AssignmentPattern");
          }
          checkLVal(t2, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 64, r2 = arguments.length > 3 ? arguments[3] : void 0, i2 = arguments.length > 4 ? arguments[4] : void 0, n2 = arguments.length > 5 && arguments[5] !== void 0 && arguments[5];
            switch (t2.type) {
              case "Identifier": {
                const { name: e3 } = t2;
                this.state.strict && (n2 ? cl(e3, this.inModule) : pl(e3)) && this.raise(t2.start, s2 === 64 ? Dc.StrictEvalArguments : Dc.StrictEvalArgumentsBinding, e3), r2 && (r2.has(e3) ? this.raise(t2.start, Dc.ParamDupe) : r2.add(e3)), i2 && e3 === "let" && this.raise(t2.start, Dc.LetInLexicalBinding), 64 & s2 || this.scope.declareName(e3, s2, t2.start);
                break;
              }
              case "MemberExpression":
                s2 !== 64 && this.raise(t2.start, Dc.InvalidPropertyBindingPattern);
                break;
              case "ObjectPattern":
                for (let e3 of t2.properties) {
                  if (this.isObjectProperty(e3))
                    e3 = e3.value;
                  else if (this.isObjectMethod(e3))
                    continue;
                  this.checkLVal(e3, "object destructuring pattern", s2, r2, i2);
                }
                break;
              case "ArrayPattern":
                for (const e3 of t2.elements)
                  e3 && this.checkLVal(e3, "array destructuring pattern", s2, r2, i2);
                break;
              case "AssignmentPattern":
                this.checkLVal(t2.left, "assignment pattern", s2, r2);
                break;
              case "RestElement":
                this.checkLVal(t2.argument, "rest element", s2, r2);
                break;
              case "ParenthesizedExpression":
                this.checkLVal(t2.expression, "parenthesized expression", s2, r2);
                break;
              default:
                this.raise(t2.start, s2 === 64 ? Dc.InvalidLhs : Dc.InvalidLhsBinding, e2);
            }
          }
          checkToRestConversion(t2) {
            t2.argument.type !== "Identifier" && t2.argument.type !== "MemberExpression" && this.raise(t2.argument.start, Dc.InvalidRestAssignmentPattern);
          }
          checkCommaAfterRest(t2) {
            this.match(12) && (this.lookaheadCharCode() === t2 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
          }
          raiseRestNotLast(t2) {
            throw this.raise(t2, Dc.ElementAfterRest);
          }
          raiseTrailingCommaAfterRest(t2) {
            this.raise(t2, Dc.RestTrailingComma);
          }
        } {
          checkProto(t2, e2, s2, r2) {
            if (t2.type === "SpreadElement" || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
              return;
            const i2 = t2.key;
            if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
              if (e2)
                return void this.raise(i2.start, Dc.RecordNoProto);
              s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Dc.DuplicateProto)), s2.used = true;
            }
          }
          shouldExitDescending(t2, e2) {
            return t2.type === "ArrowFunctionExpression" && t2.start === e2;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const t2 = this.parseExpression();
            return this.match(129) || this.unexpected(), this.finalizeRemainingComments(), t2.comments = this.state.comments, t2.errors = this.state.errors, this.options.tokens && (t2.tokens = this.tokens), t2;
          }
          parseExpression(t2, e2) {
            return t2 ? this.disallowInAnd(() => this.parseExpressionBase(e2)) : this.allowInAnd(() => this.parseExpressionBase(e2));
          }
          parseExpressionBase(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(t2);
            if (this.match(12)) {
              const i2 = this.startNodeAt(e2, s2);
              for (i2.expressions = [r2]; this.eat(12); )
                i2.expressions.push(this.parseMaybeAssign(t2));
              return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
            }
            return r2;
          }
          parseMaybeAssignDisallowIn(t2, e2) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          parseMaybeAssignAllowIn(t2, e2) {
            return this.allowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          setOptionalParametersError(t2, e2) {
            var s2;
            t2.optionalParameters = (s2 = e2 == null ? void 0 : e2.pos) != null ? s2 : this.state.start;
          }
          parseMaybeAssign(t2, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc;
            if (this.isContextual(99) && this.prodParam.hasYield) {
              let t3 = this.parseYield();
              return e2 && (t3 = e2.call(this, t3, s2, r2)), t3;
            }
            let i2;
            t2 ? i2 = false : (t2 = new Rl(), i2 = true);
            const { type: n2 } = this.state;
            (n2 === 10 || Uc(n2)) && (this.state.potentialArrowAt = this.state.start);
            let a2 = this.parseMaybeConditional(t2);
            if (e2 && (a2 = e2.call(this, a2, s2, r2)), (o2 = this.state.type) >= 27 && o2 <= 31) {
              const e3 = this.startNodeAt(s2, r2), i3 = this.state.value;
              return e3.operator = i3, this.match(27) ? (e3.left = this.toAssignable(a2, true), t2.doubleProto >= s2 && (t2.doubleProto = -1), t2.shorthandAssign >= s2 && (t2.shorthandAssign = -1)) : e3.left = a2, this.checkLVal(a2, "assignment expression"), this.next(), e3.right = this.parseMaybeAssign(), this.finishNode(e3, "AssignmentExpression");
            }
            var o2;
            return i2 && this.checkExpressionErrors(t2, true), a2;
          }
          parseMaybeConditional(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(t2);
            return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, e2, s2, t2);
          }
          parseConditional(t2, e2, s2, r2) {
            if (this.eat(17)) {
              const r3 = this.startNodeAt(e2, s2);
              return r3.test = t2, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
            }
            return t2;
          }
          parseMaybeUnaryOrPrivate(t2) {
            return this.match(128) ? this.parsePrivateName() : this.parseMaybeUnary(t2);
          }
          parseExprOps(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(t2);
            return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, e2, s2, -1);
          }
          parseExprOp(t2, e2, s2, r2) {
            if (this.isPrivateName(t2)) {
              const e3 = this.getPrivateNameSV(t2), { start: s3 } = t2;
              (r2 >= Kc(52) || !this.prodParam.hasIn || !this.match(52)) && this.raise(s3, Dc.PrivateInExpectedIn, e3), this.classScope.usePrivateName(e3, s3);
            }
            const i2 = this.state.type;
            if ((n2 = i2) >= 35 && n2 <= 53 && (this.prodParam.hasIn || !this.match(52))) {
              let n3 = Kc(i2);
              if (n3 > r2) {
                if (i2 === 35) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return t2;
                  this.checkPipelineAtInfixOperator(t2, e2);
                }
                const a2 = this.startNodeAt(e2, s2);
                a2.left = t2, a2.operator = this.state.value;
                const o2 = i2 === 37 || i2 === 38, u2 = i2 === 36;
                if (u2 && (n3 = Kc(38)), this.next(), i2 === 35 && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.state.type === 90 && this.prodParam.hasAwait)
                  throw this.raise(this.state.start, Dc.UnexpectedAwaitAfterPipelineBody);
                a2.right = this.parseExprOpRightExpr(i2, n3), this.finishNode(a2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
                const h2 = this.state.type;
                if (u2 && (h2 === 37 || h2 === 38) || o2 && h2 === 36)
                  throw this.raise(this.state.start, Dc.MixingCoalesceWithLogical);
                return this.parseExprOp(a2, e2, s2, r2);
              }
            }
            var n2;
            return t2;
          }
          parseExprOpRightExpr(t2, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc;
            if (t2 === 35)
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(99))
                      throw this.raise(this.state.start, Dc.PipeBodyIsTighter, this.state.value);
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t2, e2), s2, r2);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e2));
              }
            return this.parseExprOpBaseRightExpr(t2, e2);
          }
          parseExprOpBaseRightExpr(t2, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, t2 === 51 ? e2 - 1 : e2);
          }
          parseHackPipeBody() {
            var t2;
            const { start: e2 } = this.state, s2 = this.parseMaybeAssign();
            return !md.has(s2.type) || (t2 = s2.extra) != null && t2.parenthesized || this.raise(e2, Dc.PipeUnparenthesizedBody, md.get(s2.type)), this.topicReferenceWasUsedInCurrentContext() || this.raise(e2, Dc.PipeTopicUnused), s2;
          }
          checkExponentialAfterUnary(t2) {
            this.match(51) && this.raise(t2.argument.start, Dc.UnexpectedTokenUnaryExponentiation);
          }
          parseMaybeUnary(t2, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual(90);
            if (i2 && this.isAwaitAllowed()) {
              this.next();
              const t3 = this.parseAwait(s2, r2);
              return e2 || this.checkExponentialAfterUnary(t3), t3;
            }
            const n2 = this.match(32), a2 = this.startNode();
            if (o2 = this.state.type, Oc[o2]) {
              a2.operator = this.state.value, a2.prefix = true, this.match(66) && this.expectPlugin("throwExpressions");
              const s3 = this.match(83);
              if (this.next(), a2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && s3) {
                const t3 = a2.argument;
                t3.type === "Identifier" ? this.raise(a2.start, Dc.StrictDelete) : this.hasPropertyAsPrivateName(t3) && this.raise(a2.start, Dc.DeletePrivateField);
              }
              if (!n2)
                return e2 || this.checkExponentialAfterUnary(a2), this.finishNode(a2, "UnaryExpression");
            }
            var o2;
            const u2 = this.parseUpdate(a2, n2, t2);
            if (i2) {
              const { type: t3 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? Hc(t3) : Hc(t3) && !this.match(48)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(s2, Dc.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
            }
            return u2;
          }
          parseUpdate(t2, e2, s2) {
            if (e2)
              return this.checkLVal(t2.argument, "prefix operation"), this.finishNode(t2, "UpdateExpression");
            const r2 = this.state.start, i2 = this.state.startLoc;
            let n2 = this.parseExprSubscripts(s2);
            if (this.checkExpressionErrors(s2, false))
              return n2;
            for (; this.state.type === 32 && !this.canInsertSemicolon(); ) {
              const t3 = this.startNodeAt(r2, i2);
              t3.operator = this.state.value, t3.prefix = false, t3.argument = n2, this.checkLVal(n2, "postfix operation"), this.next(), n2 = this.finishNode(t3, "UpdateExpression");
            }
            return n2;
          }
          parseExprSubscripts(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(t2);
            return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, e2, s2);
          }
          parseSubscripts(t2, e2, s2, r2) {
            const i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t2), stop: false };
            do {
              t2 = this.parseSubscript(t2, e2, s2, r2, i2), i2.maybeAsyncArrow = false;
            } while (!i2.stop);
            return t2;
          }
          parseSubscript(t2, e2, s2, r2, i2) {
            if (!r2 && this.eat(15))
              return this.parseBind(t2, e2, s2, r2, i2);
            if (this.match(22))
              return this.parseTaggedTemplateExpression(t2, e2, s2, i2);
            let n2 = false;
            if (this.match(18)) {
              if (r2 && this.lookaheadCharCode() === 40)
                return i2.stop = true, t2;
              i2.optionalChainMember = n2 = true, this.next();
            }
            if (!r2 && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(t2, e2, s2, i2, n2);
            {
              const r3 = this.eat(0);
              return r3 || n2 || this.eat(16) ? this.parseMember(t2, e2, s2, i2, r3, n2) : (i2.stop = true, t2);
            }
          }
          parseMember(t2, e2, s2, r2, i2, n2) {
            const a2 = this.startNodeAt(e2, s2);
            a2.object = t2, a2.computed = i2;
            const o2 = !i2 && this.match(128) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
            return o2 !== false && (a2.object.type === "Super" && this.raise(e2, Dc.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), a2.property = u2, i2 && this.expect(3), r2.optionalChainMember ? (a2.optional = n2, this.finishNode(a2, "OptionalMemberExpression")) : this.finishNode(a2, "MemberExpression");
          }
          parseBind(t2, e2, s2, r2, i2) {
            const n2 = this.startNodeAt(e2, s2);
            return n2.object = t2, n2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(n2, "BindExpression"), e2, s2, r2);
          }
          parseCoverCallAndAsyncArrowHead(t2, e2, s2, r2, i2) {
            const n2 = this.state.maybeInArrowParameters;
            let a2 = null;
            this.state.maybeInArrowParameters = true, this.next();
            let o2 = this.startNodeAt(e2, s2);
            return o2.callee = t2, r2.maybeAsyncArrow && (this.expressionScope.enter(new vl(2)), a2 = new Rl()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, t2.type === "Import", t2.type !== "Super", o2, a2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(a2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = n2, o2;
          }
          toReferencedArguments(t2, e2) {
            this.toReferencedListDeep(t2.arguments, e2);
          }
          parseTaggedTemplateExpression(t2, e2, s2, r2) {
            const i2 = this.startNodeAt(e2, s2);
            return i2.tag = t2, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(e2, Dc.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t2) {
            return t2.type === "Identifier" && t2.name === "async" && this.state.lastTokEnd === t2.end && !this.canInsertSemicolon() && t2.end - t2.start == 5 && t2.start === this.state.potentialArrowAt;
          }
          finishCallExpression(t2, e2) {
            if (t2.callee.type === "Import")
              if (t2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t2.arguments.length === 0 || t2.arguments.length > 2)
                this.raise(t2.start, Dc.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
              else
                for (const e3 of t2.arguments)
                  e3.type === "SpreadElement" && this.raise(e3.start, Dc.ImportCallSpreadArgument);
            return this.finishNode(t2, e2 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t2, e2, s2, r2, i2) {
            const n2 = [];
            let a2 = true;
            const o2 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
              if (a2)
                a2 = false;
              else if (this.expect(12), this.match(t2)) {
                !e2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Dc.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
                break;
              }
              n2.push(this.parseExprListItem(false, i2, s2));
            }
            return this.state.inFSharpPipelineDirectBody = o2, n2;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t2, e2) {
            var s2;
            return this.resetPreviousNodeTrailingComments(e2), this.expect(19), this.parseArrowExpression(t2, e2.arguments, true, (s2 = e2.extra) == null ? void 0 : s2.trailingComma), e2.innerComments && cc(t2, e2.innerComments), e2.callee.trailingComments && cc(t2, e2.callee.trailingComments), t2;
          }
          parseNoCallExpr() {
            const t2 = this.state.start, e2 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t2, e2, true);
          }
          parseExprAtom(t2) {
            let e2;
            const { type: s2 } = this.state;
            switch (s2) {
              case 73:
                return this.parseSuper();
              case 77:
                return e2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e2) : (this.match(10) || this.raise(this.state.lastTokStart, Dc.UnsupportedImport), this.finishNode(e2, "Import"));
              case 72:
                return e2 = this.startNode(), this.next(), this.finishNode(e2, "ThisExpression");
              case 84:
                return this.parseDo(this.startNode(), false);
              case 50:
              case 29:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 124:
                return this.parseNumericLiteral(this.state.value);
              case 125:
                return this.parseBigIntLiteral(this.state.value);
              case 126:
                return this.parseDecimalLiteral(this.state.value);
              case 123:
                return this.parseStringLiteral(this.state.value);
              case 78:
                return this.parseNullLiteral();
              case 79:
                return this.parseBooleanLiteral(true);
              case 80:
                return this.parseBooleanLiteral(false);
              case 10: {
                const t3 = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(t3);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, t2);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, t2);
              case 62:
                return this.parseFunctionOrFunctionSent();
              case 24:
                this.parseDecorators();
              case 74:
                return e2 = this.startNode(), this.takeDecorators(e2), this.parseClass(e2, false);
              case 71:
                return this.parseNewOrNewTarget();
              case 22:
                return this.parseTemplate(false);
              case 15: {
                e2 = this.startNode(), this.next(), e2.object = null;
                const t3 = e2.callee = this.parseNoCallExpr();
                if (t3.type === "MemberExpression")
                  return this.finishNode(e2, "BindExpression");
                throw this.raise(t3.start, Dc.UnsupportedBind);
              }
              case 128:
                return this.raise(this.state.start, Dc.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
              case 31:
                return this.parseTopicReferenceThenEqualsSign(48, "%");
              case 30:
                return this.parseTopicReferenceThenEqualsSign(40, "^");
              case 40:
              case 48:
              case 25: {
                const t3 = this.getPluginOption("pipelineOperator", "proposal");
                if (t3)
                  return this.parseTopicReference(t3);
                throw this.unexpected();
              }
              case 43: {
                const t3 = this.input.codePointAt(this.nextTokenStart());
                if (el(t3) || t3 === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                  break;
                }
                throw this.unexpected();
              }
              default:
                if (Uc(s2)) {
                  if (this.isContextual(117) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                    return this.parseModuleExpression();
                  const t3 = this.state.potentialArrowAt === this.state.start, e3 = this.state.containsEsc, s3 = this.parseIdentifier();
                  if (!e3 && s3.name === "async" && !this.canInsertSemicolon()) {
                    const { type: t4 } = this.state;
                    if (t4 === 62)
                      return this.resetPreviousNodeTrailingComments(s3), this.next(), this.parseFunction(this.startNodeAtNode(s3), void 0, true);
                    if (Uc(t4))
                      return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s3)) : s3;
                    if (t4 === 84)
                      return this.resetPreviousNodeTrailingComments(s3), this.parseDo(this.startNodeAtNode(s3), true);
                  }
                  return t3 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s3), [s3], false)) : s3;
                }
                throw this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(t2, e2) {
            const s2 = this.getPluginOption("pipelineOperator", "proposal");
            if (s2)
              return this.state.type = t2, this.state.value = e2, this.state.pos--, this.state.end--, this.state.endLoc.column--, this.parseTopicReference(s2);
            throw this.unexpected();
          }
          parseTopicReference(t2) {
            const e2 = this.startNode(), s2 = this.state.start, r2 = this.state.type;
            return this.next(), this.finishTopicReference(e2, s2, t2, r2);
          }
          finishTopicReference(t2, e2, s2, r2) {
            if (this.testTopicReferenceConfiguration(s2, e2, r2)) {
              let r3;
              return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(e2, Dc.PrimaryTopicNotAllowed) : this.raise(e2, Dc.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(t2, r3);
            }
            throw this.raise(e2, Dc.PipeTopicUnconfiguredToken, Wc(r2));
          }
          testTopicReferenceConfiguration(t2, e2, s2) {
            switch (t2) {
              case "hack": {
                const t3 = this.getPluginOption("pipelineOperator", "topicToken");
                return Wc(s2) === t3;
              }
              case "smart":
                return s2 === 25;
              default:
                throw this.raise(e2, Dc.PipeTopicRequiresHackPipes);
            }
          }
          parseAsyncArrowUnaryFunction(t2) {
            this.prodParam.enter(Ml(true, this.prodParam.hasYield));
            const e2 = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Dc.LineTerminatorBeforeArrow), this.expect(19), this.parseArrowExpression(t2, e2, true), t2;
          }
          parseDo(t2, e2) {
            this.expectPlugin("doExpressions"), e2 && this.expectPlugin("asyncDoExpressions"), t2.async = e2, this.next();
            const s2 = this.state.labels;
            return this.state.labels = [], e2 ? (this.prodParam.enter(2), t2.body = this.parseBlock(), this.prodParam.exit()) : t2.body = this.parseBlock(), this.state.labels = s2, this.finishNode(t2, "DoExpression");
          }
          parseSuper() {
            const t2 = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t2.start, Dc.UnexpectedSuper) : this.raise(t2.start, Dc.SuperNotAllowed), this.match(10) || this.match(0) || this.match(16) || this.raise(t2.start, Dc.UnsupportedSuper), this.finishNode(t2, "Super");
          }
          parsePrivateName() {
            const t2 = this.startNode(), e2 = this.startNodeAt(this.state.start + 1, new uc(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
            return this.next(), t2.id = this.createIdentifier(e2, s2), this.finishNode(t2, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const t2 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const e2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
              return this.next(), this.match(96) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t2, e2, "sent");
            }
            return this.parseFunction(t2);
          }
          parseMetaProperty(t2, e2, s2) {
            t2.meta = e2;
            const r2 = this.state.containsEsc;
            return t2.property = this.parseIdentifier(true), (t2.property.name !== s2 || r2) && this.raise(t2.property.start, Dc.UnsupportedMetaProperty, e2.name, s2), this.finishNode(t2, "MetaProperty");
          }
          parseImportMetaProperty(t2) {
            const e2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
            return this.next(), this.isContextual(94) && (this.inModule || this.raise(e2.start, mc.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(t2, e2, "meta");
          }
          parseLiteralAtNode(t2, e2, s2) {
            return this.addExtra(s2, "rawValue", t2), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = t2, this.next(), this.finishNode(s2, e2);
          }
          parseLiteral(t2, e2) {
            const s2 = this.startNode();
            return this.parseLiteralAtNode(t2, e2, s2);
          }
          parseStringLiteral(t2) {
            return this.parseLiteral(t2, "StringLiteral");
          }
          parseNumericLiteral(t2) {
            return this.parseLiteral(t2, "NumericLiteral");
          }
          parseBigIntLiteral(t2) {
            return this.parseLiteral(t2, "BigIntLiteral");
          }
          parseDecimalLiteral(t2) {
            return this.parseLiteral(t2, "DecimalLiteral");
          }
          parseRegExpLiteral(t2) {
            const e2 = this.parseLiteral(t2.value, "RegExpLiteral");
            return e2.pattern = t2.pattern, e2.flags = t2.flags, e2;
          }
          parseBooleanLiteral(t2) {
            const e2 = this.startNode();
            return e2.value = t2, this.next(), this.finishNode(e2, "BooleanLiteral");
          }
          parseNullLiteral() {
            const t2 = this.startNode();
            return this.next(), this.finishNode(t2, "NullLiteral");
          }
          parseParenAndDistinguishExpression(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc;
            let r2;
            this.next(), this.expressionScope.enter(new vl(1));
            const i2 = this.state.maybeInArrowParameters, n2 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const a2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new Rl();
            let p2, c2, l2 = true;
            for (; !this.match(11); ) {
              if (l2)
                l2 = false;
              else if (this.expect(12, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(11)) {
                c2 = this.state.start;
                break;
              }
              if (this.match(21)) {
                const t3 = this.state.start, e3 = this.state.startLoc;
                p2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), t3, e3)), this.checkCommaAfterRest(41);
                break;
              }
              u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
            }
            const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = n2;
            let m2 = this.startNodeAt(e2, s2);
            if (t2 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
              return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
            if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), c2 && this.unexpected(c2), p2 && this.unexpected(p2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(a2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), this.resetEndLocation(r2, d2, D2)) : r2 = u2[0], !this.options.createParenthesizedExpressions)
              return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", e2), this.takeSurroundingComments(r2, e2, this.state.lastTokEnd), r2;
            const f2 = this.startNodeAt(e2, s2);
            return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
          }
          shouldParseArrow(t2) {
            return !this.canInsertSemicolon();
          }
          parseArrow(t2) {
            if (this.eat(19))
              return t2;
          }
          parseParenItem(t2, e2, s2) {
            return t2;
          }
          parseNewOrNewTarget() {
            const t2 = this.startNode();
            if (this.next(), this.match(16)) {
              const e2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
              this.next();
              const s2 = this.parseMetaProperty(t2, e2, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Dc.UnexpectedNewTarget), s2;
            }
            return this.parseNew(t2);
          }
          parseNew(t2) {
            return t2.callee = this.parseNoCallExpr(), t2.callee.type === "Import" ? this.raise(t2.callee.start, Dc.ImportCallNotNewExpression) : this.isOptionalChain(t2.callee) ? this.raise(this.state.lastTokEnd, Dc.OptionalChainingNoNew) : this.eat(18) && this.raise(this.state.start, Dc.OptionalChainingNoNew), this.parseNewArguments(t2), this.finishNode(t2, "NewExpression");
          }
          parseNewArguments(t2) {
            if (this.eat(10)) {
              const e2 = this.parseExprList(11);
              this.toReferencedList(e2), t2.arguments = e2;
            } else
              t2.arguments = [];
          }
          parseTemplateElement(t2) {
            const e2 = this.startNode();
            return this.state.value === null && (t2 || this.raise(this.state.start + 1, Dc.InvalidEscapeSequenceTemplate)), e2.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }, this.next(), e2.tail = this.match(22), this.finishNode(e2, "TemplateElement");
          }
          parseTemplate(t2) {
            const e2 = this.startNode();
            this.next(), e2.expressions = [];
            let s2 = this.parseTemplateElement(t2);
            for (e2.quasis = [s2]; !s2.tail; )
              this.expect(23), e2.expressions.push(this.parseTemplateSubstitution()), this.expect(8), e2.quasis.push(s2 = this.parseTemplateElement(t2));
            return this.next(), this.finishNode(e2, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(t2, e2, s2, r2) {
            s2 && this.expectPlugin("recordAndTuple");
            const i2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const n2 = /* @__PURE__ */ Object.create(null);
            let a2 = true;
            const o2 = this.startNode();
            for (o2.properties = [], this.next(); !this.match(t2); ) {
              if (a2)
                a2 = false;
              else if (this.expect(12), this.match(t2)) {
                this.addExtra(o2, "trailingComma", this.state.lastTokStart);
                break;
              }
              let i3;
              e2 ? i3 = this.parseBindingProperty() : (i3 = this.parsePropertyDefinition(r2), this.checkProto(i3, s2, n2, r2)), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Dc.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = i2;
            let u2 = "ObjectExpression";
            return e2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
          }
          maybeAsyncOrAccessorProp(t2) {
            return !t2.computed && t2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(49));
          }
          parsePropertyDefinition(t2) {
            let e2 = [];
            if (this.match(24))
              for (this.hasPlugin("decorators") && this.raise(this.state.start, Dc.UnsupportedPropertyDecorator); this.match(24); )
                e2.push(this.parseDecorator());
            const s2 = this.startNode();
            let r2, i2, n2 = false, a2 = false;
            if (this.match(21))
              return e2.length && this.unexpected(), this.parseSpread();
            e2.length && (s2.decorators = e2, e2 = []), s2.method = false, t2 && (r2 = this.state.start, i2 = this.state.startLoc);
            let o2 = this.eat(49);
            this.parsePropertyNamePrefixOperator(s2);
            const u2 = this.state.containsEsc, h2 = this.parsePropertyName(s2);
            if (!o2 && !u2 && this.maybeAsyncOrAccessorProp(s2)) {
              const t3 = h2.name;
              t3 !== "async" || this.hasPrecedingLineBreak() || (n2 = true, this.resetPreviousNodeTrailingComments(h2), o2 = this.eat(49), this.parsePropertyName(s2)), t3 !== "get" && t3 !== "set" || (a2 = true, this.resetPreviousNodeTrailingComments(h2), s2.kind = t3, this.match(49) && (o2 = true, this.raise(this.state.pos, Dc.AccessorIsGenerator, t3), this.next()), this.parsePropertyName(s2));
            }
            return this.parseObjPropValue(s2, r2, i2, o2, n2, false, a2, t2), s2;
          }
          getGetterSetterExpectedParamCount(t2) {
            return t2.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(t2) {
            return t2.params;
          }
          checkGetterSetterParams(t2) {
            var e2;
            const s2 = this.getGetterSetterExpectedParamCount(t2), r2 = this.getObjectOrClassMethodParams(t2), i2 = t2.start;
            r2.length !== s2 && (t2.kind === "get" ? this.raise(i2, Dc.BadGetterArity) : this.raise(i2, Dc.BadSetterArity)), t2.kind === "set" && ((e2 = r2[r2.length - 1]) == null ? void 0 : e2.type) === "RestElement" && this.raise(i2, Dc.BadSetterRestParameter);
          }
          parseObjectMethod(t2, e2, s2, r2, i2) {
            return i2 ? (this.parseMethod(t2, e2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(t2), t2) : s2 || e2 || this.match(10) ? (r2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, e2, s2, false, false, "ObjectMethod")) : void 0;
          }
          parseObjectProperty(t2, e2, s2, r2, i2) {
            return t2.shorthand = false, this.eat(14) ? (t2.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(t2, "ObjectProperty")) : t2.computed || t2.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(t2.key.name, t2.key.start, true, false), r2 ? t2.value = this.parseMaybeDefault(e2, s2, _l(t2.key)) : this.match(27) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), t2.value = this.parseMaybeDefault(e2, s2, _l(t2.key))) : t2.value = _l(t2.key), t2.shorthand = true, this.finishNode(t2, "ObjectProperty"));
          }
          parseObjPropValue(t2, e2, s2, r2, i2, n2, a2, o2) {
            const u2 = this.parseObjectMethod(t2, r2, i2, n2, a2) || this.parseObjectProperty(t2, e2, s2, n2, o2);
            return u2 || this.unexpected(), u2;
          }
          parsePropertyName(t2) {
            if (this.eat(0))
              t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: e2, value: s2 } = this.state;
              let r2;
              if (_c(e2))
                r2 = this.parseIdentifier(true);
              else
                switch (e2) {
                  case 124:
                    r2 = this.parseNumericLiteral(s2);
                    break;
                  case 123:
                    r2 = this.parseStringLiteral(s2);
                    break;
                  case 125:
                    r2 = this.parseBigIntLiteral(s2);
                    break;
                  case 126:
                    r2 = this.parseDecimalLiteral(s2);
                    break;
                  case 128: {
                    const t3 = this.state.start + 1;
                    this.raise(t3, Dc.UnexpectedPrivateField), r2 = this.parsePrivateName();
                    break;
                  }
                  default:
                    throw this.unexpected();
                }
              t2.key = r2, e2 !== 128 && (t2.computed = false);
            }
            return t2.key;
          }
          initFunction(t2, e2) {
            t2.id = null, t2.generator = false, t2.async = !!e2;
          }
          parseMethod(t2, e2, s2, r2, i2, n2) {
            let a2 = arguments.length > 6 && arguments[6] !== void 0 && arguments[6];
            this.initFunction(t2, s2), t2.generator = !!e2;
            const o2 = r2;
            return this.scope.enter(18 | (a2 ? dl : 0) | (i2 ? 32 : 0)), this.prodParam.enter(Ml(s2, t2.generator)), this.parseFunctionParams(t2, o2), this.parseFunctionBodyAndFinish(t2, n2, true), this.prodParam.exit(), this.scope.exit(), t2;
          }
          parseArrayLike(t2, e2, s2, r2) {
            s2 && this.expectPlugin("recordAndTuple");
            const i2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const n2 = this.startNode();
            return this.next(), n2.elements = this.parseExprList(t2, !s2, r2, n2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(n2, s2 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t2, e2, s2, r2) {
            this.scope.enter(6);
            let i2 = Ml(s2, false);
            !this.match(0) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(t2, s2);
            const n2 = this.state.maybeInArrowParameters;
            return e2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, e2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n2, this.finishNode(t2, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t2, e2, s2) {
            t2.params = this.toAssignableList(e2, s2, false);
          }
          parseFunctionBodyAndFinish(t2, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            this.parseFunctionBody(t2, false, s2), this.finishNode(t2, e2);
          }
          parseFunctionBody(t2, e2) {
            let s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const r2 = e2 && !this.match(5);
            if (this.expressionScope.enter(Ll()), r2)
              t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, e2, false);
            else {
              const r3 = this.state.strict, i2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t2.body = this.parseBlock(true, false, (i3) => {
                const n2 = !this.isSimpleParamList(t2.params);
                if (i3 && n2) {
                  const e3 = t2.kind !== "method" && t2.kind !== "constructor" || !t2.key ? t2.start : t2.key.end;
                  this.raise(e3, Dc.IllegalLanguageModeDirective);
                }
                const a2 = !r3 && this.state.strict;
                this.checkParams(t2, !(this.state.strict || e2 || s2 || n2), e2, a2), this.state.strict && t2.id && this.checkLVal(t2.id, "function name", 65, void 0, void 0, a2);
              }), this.prodParam.exit(), this.state.labels = i2;
            }
            this.expressionScope.exit();
          }
          isSimpleParamList(t2) {
            for (let e2 = 0, s2 = t2.length; e2 < s2; e2++)
              if (t2[e2].type !== "Identifier")
                return false;
            return true;
          }
          checkParams(t2, e2, s2) {
            let r2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            const i2 = /* @__PURE__ */ new Set();
            for (const s3 of t2.params)
              this.checkLVal(s3, "function parameter list", 5, e2 ? null : i2, void 0, r2);
          }
          parseExprList(t2, e2, s2, r2) {
            const i2 = [];
            let n2 = true;
            for (; !this.eat(t2); ) {
              if (n2)
                n2 = false;
              else if (this.expect(12), this.match(t2)) {
                r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
                break;
              }
              i2.push(this.parseExprListItem(e2, s2));
            }
            return i2;
          }
          parseExprListItem(t2, e2, s2) {
            let r2;
            if (this.match(12))
              t2 || this.raise(this.state.pos, Dc.UnexpectedToken, ","), r2 = null;
            else if (this.match(21)) {
              const t3 = this.state.start, s3 = this.state.startLoc;
              r2 = this.parseParenItem(this.parseSpread(e2), t3, s3);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Dc.UnexpectedArgumentPlaceholder);
              const t3 = this.startNode();
              this.next(), r2 = this.finishNode(t3, "ArgumentPlaceholder");
            } else
              r2 = this.parseMaybeAssignAllowIn(e2, this.parseParenItem);
            return r2;
          }
          parseIdentifier(t2) {
            const e2 = this.startNode(), s2 = this.parseIdentifierName(e2.start, t2);
            return this.createIdentifier(e2, s2);
          }
          createIdentifier(t2, e2) {
            return t2.name = e2, t2.loc.identifierName = e2, this.finishNode(t2, "Identifier");
          }
          parseIdentifierName(t2, e2) {
            let s2;
            const { start: r2, type: i2 } = this.state;
            if (!_c(i2))
              throw this.unexpected();
            s2 = this.state.value;
            const n2 = i2 <= 86;
            return e2 ? n2 && this.replaceToken(122) : this.checkReservedWord(s2, r2, n2, false), this.next(), s2;
          }
          checkReservedWord(t2, e2, s2, r2) {
            if (t2.length > 10)
              return;
            if (!function(t3) {
              return ll.has(t3);
            }(t2))
              return;
            if (t2 === "yield") {
              if (this.prodParam.hasYield)
                return void this.raise(e2, Dc.YieldBindingIdentifier);
            } else if (t2 === "await") {
              if (this.prodParam.hasAwait)
                return void this.raise(e2, Dc.AwaitBindingIdentifier);
              if (this.scope.inStaticBlock)
                return void this.raise(e2, Dc.AwaitBindingIdentifierInStaticBlock);
              this.expressionScope.recordAsyncArrowParametersError(e2, Dc.AwaitBindingIdentifier);
            } else if (t2 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
              return void this.raise(e2, Dc.ArgumentsInClass);
            if (s2 && function(t3) {
              return nl.has(t3);
            }(t2))
              return void this.raise(e2, Dc.UnexpectedKeyword, t2);
            (this.state.strict ? r2 ? cl : hl : ul)(t2, this.inModule) && this.raise(e2, Dc.UnexpectedReservedWord, t2);
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(t2, e2) {
            const s2 = this.startNodeAt(t2, e2);
            return this.expressionScope.recordParameterInitializerError(s2.start, Dc.AwaitExpressionFormalParameter), this.eat(49) && this.raise(s2.start, Dc.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
          }
          isAmbiguousAwait() {
            return this.hasPrecedingLineBreak() || this.match(47) || this.match(10) || this.match(0) || this.match(22) || this.match(127) || this.match(50) || this.hasPlugin("v8intrinsic") && this.match(48);
          }
          parseYield() {
            const t2 = this.startNode();
            this.expressionScope.recordParameterInitializerError(t2.start, Dc.YieldInParameter), this.next();
            let e2 = false, s2 = null;
            if (!this.hasPrecedingLineBreak())
              switch (e2 = this.eat(49), this.state.type) {
                case 13:
                case 129:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!e2)
                    break;
                default:
                  s2 = this.parseMaybeAssign();
              }
            return t2.delegate = e2, t2.argument = s2, this.finishNode(t2, "YieldExpression");
          }
          checkPipelineAtInfixOperator(t2, e2) {
            this.getPluginOption("pipelineOperator", "proposal") === "smart" && t2.type === "SequenceExpression" && this.raise(e2, Dc.PipelineHeadSequenceExpression);
          }
          checkHackPipeBodyEarlyErrors(t2) {
            this.topicReferenceWasUsedInCurrentContext() || this.raise(t2, Dc.PipeTopicUnused);
          }
          parseSmartPipelineBodyInStyle(t2, e2, s2) {
            const r2 = this.startNodeAt(e2, s2);
            return this.isSimpleReference(t2) ? (r2.callee = t2, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(e2), r2.expression = t2, this.finishNode(r2, "PipelineTopicExpression"));
          }
          isSimpleReference(t2) {
            switch (t2.type) {
              case "MemberExpression":
                return !t2.computed && this.isSimpleReference(t2.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(t2) {
            if (this.match(19))
              throw this.raise(this.state.start, Dc.PipelineBodyNoArrow);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(t2, Dc.PipelineTopicUnused);
          }
          withTopicBindingContext(t2) {
            const e2 = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return t2();
            } finally {
              this.state.topicContext = e2;
            }
          }
          withSmartMixTopicForbiddingContext(t2) {
            if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
              return t2();
            {
              const e2 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return t2();
              } finally {
                this.state.topicContext = e2;
              }
            }
          }
          withSoloAwaitPermittingContext(t2) {
            const e2 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t2();
            } finally {
              this.state.soloAwait = e2;
            }
          }
          allowInAnd(t2) {
            const e2 = this.prodParam.currentFlags();
            if (8 & ~e2) {
              this.prodParam.enter(8 | e2);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          disallowInAnd(t2) {
            const e2 = this.prodParam.currentFlags();
            if (8 & e2) {
              this.prodParam.enter(-9 & e2);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t2) {
            const e2 = this.state.start, s2 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const r2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e2, s2, t2);
            return this.state.inFSharpPipelineDirectBody = r2, i2;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const t2 = this.startNode();
            this.next(), this.eat(5);
            const e2 = this.initializeScopes(true);
            this.enterInitialScopes();
            const s2 = this.startNode();
            try {
              t2.body = this.parseProgram(s2, 8, "module");
            } finally {
              e2();
            }
            return this.eat(8), this.finishNode(t2, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(t2) {
          }
        } {
          parseTopLevel(t2, e2) {
            return t2.program = this.parseProgram(e2), t2.comments = this.state.comments, this.options.tokens && (t2.tokens = function(t3) {
              for (let e3 = 0; e3 < t3.length; e3++) {
                const s2 = t3[e3], { type: r2 } = s2;
                if (r2 !== 128)
                  typeof r2 == "number" && (s2.type = Gc(r2));
                else {
                  const { loc: r3, start: i2, value: n2, end: a2 } = s2, o2 = i2 + 1, u2 = new uc(r3.start.line, r3.start.column + 1);
                  t3.splice(e3, 1, new wl({ type: Gc(25), value: "#", start: i2, end: o2, startLoc: r3.start, endLoc: u2 }), new wl({ type: Gc(122), value: n2, start: o2, end: a2, startLoc: u2, endLoc: r3.end })), e3++;
                }
              }
              return t3;
            }(this.tokens)), this.finishNode(t2, "File");
          }
          parseProgram(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 129, s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
            if (t2.sourceType = s2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, e2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (const [t3] of Array.from(this.scope.undefinedExports)) {
                const e3 = this.scope.undefinedExports.get(t3);
                this.raise(e3, Dc.ModuleExportUndefined, t3);
              }
            return this.finishNode(t2, "Program");
          }
          stmtToDirective(t2) {
            const e2 = t2;
            e2.type = "Directive", e2.value = e2.expression, delete e2.expression;
            const s2 = e2.value, r2 = s2.value, i2 = this.input.slice(s2.start, s2.end), n2 = s2.value = i2.slice(1, -1);
            return this.addExtra(s2, "raw", i2), this.addExtra(s2, "rawValue", n2), this.addExtra(s2, "expressionValue", r2), s2.type = "DirectiveLiteral", e2;
          }
          parseInterpreterDirective() {
            if (!this.match(26))
              return null;
            const t2 = this.startNode();
            return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
          }
          isLet(t2) {
            return !!this.isContextual(93) && this.isLetKeyword(t2);
          }
          isLetKeyword(t2) {
            const e2 = this.nextTokenStart(), s2 = this.codePointAtPos(e2);
            if (s2 === 92 || s2 === 91)
              return true;
            if (t2)
              return false;
            if (s2 === 123)
              return true;
            if (el(s2)) {
              if (Ad.lastIndex = e2, Ad.test(this.input)) {
                const t3 = this.codePointAtPos(Ad.lastIndex);
                if (!sl(t3) && t3 !== 92)
                  return false;
              }
              return true;
            }
            return false;
          }
          parseStatement(t2, e2) {
            return this.match(24) && this.parseDecorators(true), this.parseStatementContent(t2, e2);
          }
          parseStatementContent(t2, e2) {
            let s2 = this.state.type;
            const r2 = this.startNode();
            let i2;
            switch (this.isLet(t2) && (s2 = 68, i2 = "let"), s2) {
              case 54:
                return this.parseBreakContinueStatement(r2, true);
              case 57:
                return this.parseBreakContinueStatement(r2, false);
              case 58:
                return this.parseDebuggerStatement(r2);
              case 84:
                return this.parseDoStatement(r2);
              case 85:
                return this.parseForStatement(r2);
              case 62:
                if (this.lookaheadCharCode() === 46)
                  break;
                return t2 && (this.state.strict ? this.raise(this.state.start, Dc.StrictFunction) : t2 !== "if" && t2 !== "label" && this.raise(this.state.start, Dc.SloppyFunction)), this.parseFunctionStatement(r2, false, !t2);
              case 74:
                return t2 && this.unexpected(), this.parseClass(r2, true);
              case 63:
                return this.parseIfStatement(r2);
              case 64:
                return this.parseReturnStatement(r2);
              case 65:
                return this.parseSwitchStatement(r2);
              case 66:
                return this.parseThrowStatement(r2);
              case 67:
                return this.parseTryStatement(r2);
              case 69:
              case 68:
                return i2 = i2 || this.state.value, t2 && i2 !== "var" && this.raise(this.state.start, Dc.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
              case 86:
                return this.parseWhileStatement(r2);
              case 70:
                return this.parseWithStatement(r2);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(r2);
              case 77: {
                const t3 = this.lookaheadCharCode();
                if (t3 === 40 || t3 === 46)
                  break;
              }
              case 76: {
                let t3;
                return this.options.allowImportExportEverywhere || e2 || this.raise(this.state.start, Dc.UnexpectedImportExport), this.next(), s2 === 77 ? (t3 = this.parseImport(r2), t3.type !== "ImportDeclaration" || t3.importKind && t3.importKind !== "value" || (this.sawUnambiguousESM = true)) : (t3 = this.parseExport(r2), (t3.type !== "ExportNamedDeclaration" || t3.exportKind && t3.exportKind !== "value") && (t3.type !== "ExportAllDeclaration" || t3.exportKind && t3.exportKind !== "value") && t3.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), t3;
              }
              default:
                if (this.isAsyncFunction())
                  return t2 && this.raise(this.state.start, Dc.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !t2);
            }
            const n2 = this.state.value, a2 = this.parseExpression();
            return Uc(s2) && a2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r2, n2, a2, t2) : this.parseExpressionStatement(r2, a2);
          }
          assertModuleNodeAllowed(t2) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(t2.start, mc.ImportOutsideModule);
          }
          takeDecorators(t2) {
            const e2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            e2.length && (t2.decorators = e2, this.resetStartLocationFromNode(t2, e2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
          }
          canHaveLeadingDecorator() {
            return this.match(74);
          }
          parseDecorators(t2) {
            const e2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            for (; this.match(24); ) {
              const t3 = this.parseDecorator();
              e2.push(t3);
            }
            if (this.match(76))
              t2 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Dc.DecoratorExportClass);
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(this.state.start, Dc.UnexpectedLeadingDecorator);
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators-legacy", "decorators"]);
            const t2 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              this.state.decoratorStack.push([]);
              const e2 = this.state.start, s2 = this.state.startLoc;
              let r2;
              if (this.eat(10))
                r2 = this.parseExpression(), this.expect(11);
              else
                for (r2 = this.parseIdentifier(false); this.eat(16); ) {
                  const t3 = this.startNodeAt(e2, s2);
                  t3.object = r2, t3.property = this.parseIdentifier(true), t3.computed = false, r2 = this.finishNode(t3, "MemberExpression");
                }
              t2.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
            } else
              t2.expression = this.parseExprSubscripts();
            return this.finishNode(t2, "Decorator");
          }
          parseMaybeDecoratorArguments(t2) {
            if (this.eat(10)) {
              const e2 = this.startNodeAtNode(t2);
              return e2.callee = t2, e2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e2.arguments), this.finishNode(e2, "CallExpression");
            }
            return t2;
          }
          parseBreakContinueStatement(t2, e2) {
            return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, e2), this.finishNode(t2, e2 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t2, e2) {
            let s2;
            for (s2 = 0; s2 < this.state.labels.length; ++s2) {
              const r2 = this.state.labels[s2];
              if (t2.label == null || r2.name === t2.label.name) {
                if (r2.kind != null && (e2 || r2.kind === "loop"))
                  break;
                if (t2.label && e2)
                  break;
              }
            }
            s2 === this.state.labels.length && this.raise(t2.start, Dc.IllegalBreakContinue, e2 ? "break" : "continue");
          }
          parseDebuggerStatement(t2) {
            return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const t2 = this.parseExpression();
            return this.expect(11), t2;
          }
          parseDoStatement(t2) {
            return this.next(), this.state.labels.push(fd), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(86), t2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t2, "DoWhileStatement");
          }
          parseForStatement(t2) {
            this.next(), this.state.labels.push(fd);
            let e2 = -1;
            if (this.isAwaitAllowed() && this.eatContextual(90) && (e2 = this.state.lastTokStart), this.scope.enter(0), this.expect(10), this.match(13))
              return e2 > -1 && this.unexpected(e2), this.parseFor(t2, null);
            const s2 = this.isContextual(93), r2 = s2 && this.isLetKeyword();
            if (this.match(68) || this.match(69) || r2) {
              const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
              return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(52) || this.isContextual(95)) && s3.declarations.length === 1 ? this.parseForIn(t2, s3, e2) : (e2 > -1 && this.unexpected(e2), this.parseFor(t2, s3));
            }
            const i2 = this.isContextual(89), n2 = new Rl(), a2 = this.parseExpression(true, n2), o2 = this.isContextual(95);
            if (o2 && (s2 ? this.raise(a2.start, Dc.ForOfLet) : e2 === -1 && i2 && a2.type === "Identifier" && this.raise(a2.start, Dc.ForOfAsync)), o2 || this.match(52)) {
              this.toAssignable(a2, true);
              const s3 = o2 ? "for-of statement" : "for-in statement";
              return this.checkLVal(a2, s3), this.parseForIn(t2, a2, e2);
            }
            return this.checkExpressionErrors(n2, true), e2 > -1 && this.unexpected(e2), this.parseFor(t2, a2);
          }
          parseFunctionStatement(t2, e2, s2) {
            return this.next(), this.parseFunction(t2, 1 | (s2 ? 0 : 2), e2);
          }
          parseIfStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatement("if"), t2.alternate = this.eat(60) ? this.parseStatement("if") : null, this.finishNode(t2, "IfStatement");
          }
          parseReturnStatement(t2) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Dc.IllegalReturn), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
          }
          parseSwitchStatement(t2) {
            this.next(), t2.discriminant = this.parseHeaderExpression();
            const e2 = t2.cases = [];
            let s2, r2;
            for (this.expect(5), this.state.labels.push(yd), this.scope.enter(0); !this.match(8); )
              if (this.match(55) || this.match(59)) {
                const t3 = this.match(55);
                s2 && this.finishNode(s2, "SwitchCase"), e2.push(s2 = this.startNode()), s2.consequent = [], this.next(), t3 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Dc.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(14);
              } else
                s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
            return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
          }
          parseThrowStatement(t2) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Dc.NewlineAfterThrow), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const t2 = this.parseBindingAtom(), e2 = t2.type === "Identifier";
            return this.scope.enter(e2 ? 8 : 0), this.checkLVal(t2, "catch clause", 9), t2;
          }
          parseTryStatement(t2) {
            if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(56)) {
              const e2 = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), e2.param = this.parseCatchClauseParam(), this.expect(11)) : (e2.param = null, this.scope.enter(0)), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(e2, "CatchClause");
            }
            return t2.finalizer = this.eat(61) ? this.parseBlock() : null, t2.handler || t2.finalizer || this.raise(t2.start, Dc.NoCatchOrFinally), this.finishNode(t2, "TryStatement");
          }
          parseVarStatement(t2, e2) {
            return this.next(), this.parseVar(t2, false, e2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
          }
          parseWhileStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(fd), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
          }
          parseWithStatement(t2) {
            return this.state.strict && this.raise(this.state.start, Dc.StrictWith), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t2, "WithStatement");
          }
          parseEmptyStatement(t2) {
            return this.next(), this.finishNode(t2, "EmptyStatement");
          }
          parseLabeledStatement(t2, e2, s2, r2) {
            for (const t3 of this.state.labels)
              t3.name === e2 && this.raise(s2.start, Dc.LabelRedeclaration, e2);
            const i2 = (n2 = this.state.type) >= 84 && n2 <= 86 ? "loop" : this.match(65) ? "switch" : null;
            var n2;
            for (let e3 = this.state.labels.length - 1; e3 >= 0; e3--) {
              const s3 = this.state.labels[e3];
              if (s3.statementStart !== t2.start)
                break;
              s3.statementStart = this.state.start, s3.kind = i2;
            }
            return this.state.labels.push({ name: e2, kind: i2, statementStart: this.state.start }), t2.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), t2.label = s2, this.finishNode(t2, "LabeledStatement");
          }
          parseExpressionStatement(t2, e2) {
            return t2.expression = e2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
          }
          parseBlock() {
            let t2 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], s2 = arguments.length > 2 ? arguments[2] : void 0;
            const r2 = this.startNode();
            return t2 && this.state.strictErrors.clear(), this.expect(5), e2 && this.scope.enter(0), this.parseBlockBody(r2, t2, false, 8, s2), e2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
          }
          isValidDirective(t2) {
            return t2.type === "ExpressionStatement" && t2.expression.type === "StringLiteral" && !t2.expression.extra.parenthesized;
          }
          parseBlockBody(t2, e2, s2, r2, i2) {
            const n2 = t2.body = [], a2 = t2.directives = [];
            this.parseBlockOrModuleBlockBody(n2, e2 ? a2 : void 0, s2, r2, i2);
          }
          parseBlockOrModuleBlockBody(t2, e2, s2, r2, i2) {
            const n2 = this.state.strict;
            let a2 = false, o2 = false;
            for (; !this.match(r2); ) {
              const r3 = this.parseStatement(null, s2);
              if (e2 && !o2) {
                if (this.isValidDirective(r3)) {
                  const t3 = this.stmtToDirective(r3);
                  e2.push(t3), a2 || t3.value.value !== "use strict" || (a2 = true, this.setStrict(true));
                  continue;
                }
                o2 = true, this.state.strictErrors.clear();
              }
              t2.push(r3);
            }
            i2 && i2.call(this, a2), n2 || this.setStrict(false), this.next();
          }
          parseFor(t2, e2) {
            return t2.init = e2, this.semicolon(false), t2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
          }
          parseForIn(t2, e2, s2) {
            const r2 = this.match(52);
            return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : t2.await = s2 > -1, e2.type !== "VariableDeclaration" || e2.declarations[0].init == null || r2 && !this.state.strict && e2.kind === "var" && e2.declarations[0].id.type === "Identifier" ? e2.type === "AssignmentPattern" && this.raise(e2.start, Dc.InvalidLhs, "for-loop") : this.raise(e2.start, Dc.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), t2.left = e2, t2.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, r2 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t2, e2, s2) {
            const r2 = t2.declarations = [], i2 = this.hasPlugin("typescript");
            for (t2.kind = s2; ; ) {
              const t3 = this.startNode();
              if (this.parseVarId(t3, s2), this.eat(27) ? t3.init = e2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(52) || this.isContextual(95) ? t3.id.type === "Identifier" || e2 && (this.match(52) || this.isContextual(95)) || this.raise(this.state.lastTokEnd, Dc.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Dc.DeclarationMissingInitializer, "Const declarations"), t3.init = null), r2.push(this.finishNode(t3, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return t2;
          }
          parseVarId(t2, e2) {
            t2.id = this.parseBindingAtom(), this.checkLVal(t2.id, "variable declaration", e2 === "var" ? 5 : 9, void 0, e2 !== "var");
          }
          parseFunction(t2) {
            let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const r2 = 1 & e2, i2 = 2 & e2, n2 = !(!r2 || 4 & e2);
            this.initFunction(t2, s2), this.match(49) && i2 && this.raise(this.state.start, Dc.GeneratorInSingleStatementContext), t2.generator = this.eat(49), r2 && (t2.id = this.parseFunctionId(n2));
            const a2 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(Ml(s2, t2.generator)), r2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t2, r2 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = a2, t2;
          }
          parseFunctionId(t2) {
            return t2 || Uc(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t2, e2) {
            this.expect(10), this.expressionScope.enter(new Il(3)), t2.params = this.parseBindingList(11, 41, false, e2), this.expressionScope.exit();
          }
          registerFunctionStatementId(t2) {
            t2.id && this.scope.declareName(t2.id.name, this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t2.id.start);
          }
          parseClass(t2, e2, s2) {
            this.next(), this.takeDecorators(t2);
            const r2 = this.state.strict;
            return this.state.strict = true, this.parseClassId(t2, e2, s2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, r2), this.finishNode(t2, e2 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(27) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          isNonstaticConstructor(t2) {
            return !(t2.computed || t2.static || t2.key.name !== "constructor" && t2.key.value !== "constructor");
          }
          parseClassBody(t2, e2) {
            this.classScope.enter();
            const s2 = { hadConstructor: false, hadSuperClass: t2 };
            let r2 = [];
            const i2 = this.startNode();
            if (i2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (r2.length > 0)
                    throw this.raise(this.state.lastTokEnd, Dc.DecoratorSemicolon);
                  continue;
                }
                if (this.match(24)) {
                  r2.push(this.parseDecorator());
                  continue;
                }
                const t3 = this.startNode();
                r2.length && (t3.decorators = r2, this.resetStartLocationFromNode(t3, r2[0]), r2 = []), this.parseClassMember(i2, t3, s2), t3.kind === "constructor" && t3.decorators && t3.decorators.length > 0 && this.raise(t3.start, Dc.DecoratorConstructor);
              }
            }), this.state.strict = e2, this.next(), r2.length)
              throw this.raise(this.state.start, Dc.TrailingDecorator);
            return this.classScope.exit(), this.finishNode(i2, "ClassBody");
          }
          parseClassMemberFromModifier(t2, e2) {
            const s2 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const r2 = e2;
              return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(t2, r2, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const r2 = e2;
              return r2.computed = false, r2.key = s2, r2.static = false, t2.body.push(this.parseClassProperty(r2)), true;
            }
            return this.resetPreviousNodeTrailingComments(s2), false;
          }
          parseClassMember(t2, e2, s2) {
            const r2 = this.isContextual(98);
            if (r2) {
              if (this.parseClassMemberFromModifier(t2, e2))
                return;
              if (this.eat(5))
                return void this.parseClassStaticBlock(t2, e2);
            }
            this.parseClassMemberWithIsStatic(t2, e2, s2, r2);
          }
          parseClassMemberWithIsStatic(t2, e2, s2, r2) {
            const i2 = e2, n2 = e2, a2 = e2, o2 = e2, u2 = i2, h2 = i2;
            if (e2.static = r2, this.parsePropertyNamePrefixOperator(e2), this.eat(49)) {
              u2.kind = "method";
              const e3 = this.match(128);
              return this.parseClassElementName(u2), e3 ? void this.pushClassPrivateMethod(t2, n2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Dc.ConstructorIsGenerator), void this.pushClassMethod(t2, i2, true, false, false, false));
            }
            const p2 = Uc(this.state.type) && !this.state.containsEsc, c2 = this.match(128), l2 = this.parseClassElementName(e2), d2 = this.state.start;
            if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
              if (u2.kind = "method", c2)
                return void this.pushClassPrivateMethod(t2, n2, false, false);
              const r3 = this.isNonstaticConstructor(i2);
              let a3 = false;
              r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Dc.DuplicateConstructor), r3 && this.hasPlugin("typescript") && e2.override && this.raise(l2.start, Dc.OverrideOnConstructor), s2.hadConstructor = true, a3 = s2.hadSuperClass), this.pushClassMethod(t2, i2, false, false, r3, a3);
            } else if (this.isClassProperty())
              c2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, a2);
            else if (p2 && l2.name === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(l2);
              const e3 = this.eat(49);
              h2.optional && this.unexpected(d2), u2.kind = "method";
              const s3 = this.match(128);
              this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(t2, n2, e3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Dc.ConstructorIsAsync), this.pushClassMethod(t2, i2, e3, true, false, false));
            } else if (!p2 || l2.name !== "get" && l2.name !== "set" || this.match(49) && this.isLineTerminator())
              this.isLineTerminator() ? c2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, a2) : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
              const e3 = this.match(128);
              this.parseClassElementName(i2), e3 ? this.pushClassPrivateMethod(t2, n2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Dc.ConstructorIsAccessor), this.pushClassMethod(t2, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
            }
          }
          parseClassElementName(t2) {
            const { type: e2, value: s2, start: r2 } = this.state;
            if (e2 !== 122 && e2 !== 123 || !t2.static || s2 !== "prototype" || this.raise(r2, Dc.StaticPrototype), e2 === 128) {
              s2 === "constructor" && this.raise(r2, Dc.ConstructorClassPrivateField);
              const e3 = this.parsePrivateName();
              return t2.key = e3, e3;
            }
            return this.parsePropertyName(t2);
          }
          parseClassStaticBlock(t2, e2) {
            var s2;
            this.scope.enter(208);
            const r2 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const i2 = e2.body = [];
            this.parseBlockOrModuleBlockBody(i2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, t2.body.push(this.finishNode(e2, "StaticBlock")), (s2 = e2.decorators) != null && s2.length && this.raise(e2.start, Dc.DecoratorStaticBlock);
          }
          pushClassProperty(t2, e2) {
            e2.computed || e2.key.name !== "constructor" && e2.key.value !== "constructor" || this.raise(e2.key.start, Dc.ConstructorClassField), t2.body.push(this.parseClassProperty(e2));
          }
          pushClassPrivateProperty(t2, e2) {
            const s2 = this.parseClassPrivateProperty(e2);
            t2.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
          }
          pushClassMethod(t2, e2, s2, r2, i2, n2) {
            t2.body.push(this.parseMethod(e2, s2, r2, i2, n2, "ClassMethod", true));
          }
          pushClassPrivateMethod(t2, e2, s2, r2) {
            const i2 = this.parseMethod(e2, s2, r2, false, false, "ClassPrivateMethod", true);
            t2.body.push(i2);
            const n2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(i2, n2);
          }
          declareClassPrivateMethodInScope(t2, e2) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t2.key), e2, t2.key.start);
          }
          parsePostMemberNameModifiers(t2) {
          }
          parseClassPrivateProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
          }
          parseClassProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
          }
          parseInitializer(t2) {
            this.scope.enter(80), this.expressionScope.enter(Ll()), this.prodParam.enter(0), t2.value = this.eat(27) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(t2, e2, s2) {
            let r2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 139;
            Uc(this.state.type) ? (t2.id = this.parseIdentifier(), e2 && this.checkLVal(t2.id, "class name", r2)) : s2 || !e2 ? t2.id = null : this.unexpected(null, Dc.MissingClassName);
          }
          parseClassSuper(t2) {
            t2.superClass = this.eat(75) ? this.parseExprSubscripts() : null;
          }
          parseExport(t2) {
            const e2 = this.maybeParseExportDefaultSpecifier(t2), s2 = !e2 || this.eat(12), r2 = s2 && this.eatExportStar(t2), i2 = r2 && this.maybeParseExportNamespaceSpecifier(t2), n2 = s2 && (!i2 || this.eat(12)), a2 = e2 || r2;
            if (r2 && !i2)
              return e2 && this.unexpected(), this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
            const o2 = this.maybeParseExportNamedSpecifiers(t2);
            if (e2 && s2 && !r2 && !o2 || i2 && n2 && !o2)
              throw this.unexpected(null, 5);
            let u2;
            if (a2 || o2 ? (u2 = false, this.parseExportFrom(t2, a2)) : u2 = this.maybeParseExportDeclaration(t2), a2 || o2 || u2)
              return this.checkExport(t2, true, false, !!t2.source), this.finishNode(t2, "ExportNamedDeclaration");
            if (this.eat(59))
              return t2.declaration = this.parseExportDefaultExpression(), this.checkExport(t2, true, true), this.finishNode(t2, "ExportDefaultDeclaration");
            throw this.unexpected(null, 5);
          }
          eatExportStar(t2) {
            return this.eat(49);
          }
          maybeParseExportDefaultSpecifier(t2) {
            if (this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom");
              const e2 = this.startNode();
              return e2.exported = this.parseIdentifier(true), t2.specifiers = [this.finishNode(e2, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t2) {
            if (this.isContextual(87)) {
              t2.specifiers || (t2.specifiers = []);
              const e2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
              return this.next(), e2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(e2, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t2) {
            if (this.match(5)) {
              t2.specifiers || (t2.specifiers = []);
              const e2 = t2.exportKind === "type";
              return t2.specifiers.push(...this.parseExportSpecifiers(e2)), t2.source = null, t2.declaration = null, this.hasPlugin("importAssertions") && (t2.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(t2) {
            return !!this.shouldParseExportDeclaration() && (t2.specifiers = [], t2.source = null, this.hasPlugin("importAssertions") && (t2.assertions = []), t2.declaration = this.parseExportDeclaration(t2), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(89))
              return false;
            const t2 = this.nextTokenStart();
            return !sc.test(this.input.slice(this.state.pos, t2)) && this.isUnparsedContextual(t2, "function");
          }
          parseExportDefaultExpression() {
            const t2 = this.startNode(), e2 = this.isAsyncFunction();
            if (this.match(62) || e2)
              return this.next(), e2 && this.next(), this.parseFunction(t2, 5, e2);
            if (this.match(74))
              return this.parseClass(t2, true, true);
            if (this.match(24))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Dc.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(t2, true, true);
            if (this.match(69) || this.match(68) || this.isLet())
              throw this.raise(this.state.start, Dc.UnsupportedDefaultExport);
            {
              const t3 = this.parseMaybeAssignAllowIn();
              return this.semicolon(), t3;
            }
          }
          parseExportDeclaration(t2) {
            return this.parseStatement(null);
          }
          isExportDefaultSpecifier() {
            const { type: t2 } = this.state;
            if (Uc(t2)) {
              if (t2 === 89 && !this.state.containsEsc || t2 === 93)
                return false;
              if ((t2 === 120 || t2 === 119) && !this.state.containsEsc) {
                const { type: t3 } = this.lookahead();
                if (Uc(t3) && t3 !== 91 || t3 === 5)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(59))
              return false;
            const e2 = this.nextTokenStart(), s2 = this.isUnparsedContextual(e2, "from");
            if (this.input.charCodeAt(e2) === 44 || Uc(this.state.type) && s2)
              return true;
            if (this.match(59) && s2) {
              const t3 = this.input.charCodeAt(this.nextTokenStartSince(e2 + 4));
              return t3 === 34 || t3 === 39;
            }
            return false;
          }
          parseExportFrom(t2, e2) {
            if (this.eatContextual(91)) {
              t2.source = this.parseImportSource(), this.checkExport(t2);
              const e3 = this.maybeParseImportAssertions();
              e3 && (t2.assertions = e3);
            } else
              e2 && this.unexpected();
            this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: t2 } = this.state;
            if (t2 === 24 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
              if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
                return true;
              this.unexpected(this.state.start, Dc.DecoratorBeforeExport);
            }
            return t2 === 68 || t2 === 69 || t2 === 62 || t2 === 74 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t2, e2, s2, r2) {
            if (e2) {
              if (s2) {
                if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var i2;
                  const e3 = t2.declaration;
                  e3.type !== "Identifier" || e3.name !== "from" || e3.end - e3.start != 4 || (i2 = e3.extra) != null && i2.parenthesized || this.raise(e3.start, Dc.ExportDefaultFromAsIdentifier);
                }
              } else if (t2.specifiers && t2.specifiers.length)
                for (const e3 of t2.specifiers) {
                  const { exported: t3 } = e3, s3 = t3.type === "Identifier" ? t3.name : t3.value;
                  if (this.checkDuplicateExports(e3, s3), !r2 && e3.local) {
                    const { local: t4 } = e3;
                    t4.type !== "Identifier" ? this.raise(e3.start, Dc.ExportBindingIsString, t4.value, s3) : (this.checkReservedWord(t4.name, t4.start, true, false), this.scope.checkLocalExport(t4));
                  }
                }
              else if (t2.declaration) {
                if (t2.declaration.type === "FunctionDeclaration" || t2.declaration.type === "ClassDeclaration") {
                  const e3 = t2.declaration.id;
                  if (!e3)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(t2, e3.name);
                } else if (t2.declaration.type === "VariableDeclaration")
                  for (const e3 of t2.declaration.declarations)
                    this.checkDeclaration(e3.id);
              }
            }
            if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
              throw this.raise(t2.start, Dc.UnsupportedDecoratorExport);
          }
          checkDeclaration(t2) {
            if (t2.type === "Identifier")
              this.checkDuplicateExports(t2, t2.name);
            else if (t2.type === "ObjectPattern")
              for (const e2 of t2.properties)
                this.checkDeclaration(e2);
            else if (t2.type === "ArrayPattern")
              for (const e2 of t2.elements)
                e2 && this.checkDeclaration(e2);
            else
              t2.type === "ObjectProperty" ? this.checkDeclaration(t2.value) : t2.type === "RestElement" ? this.checkDeclaration(t2.argument) : t2.type === "AssignmentPattern" && this.checkDeclaration(t2.left);
          }
          checkDuplicateExports(t2, e2) {
            this.exportedIdentifiers.has(e2) && this.raise(t2.start, e2 === "default" ? Dc.DuplicateDefaultExport : Dc.DuplicateExport, e2), this.exportedIdentifiers.add(e2);
          }
          parseExportSpecifiers(t2) {
            const e2 = [];
            let s2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (s2)
                s2 = false;
              else if (this.expect(12), this.eat(8))
                break;
              const r2 = this.isContextual(120), i2 = this.match(123), n2 = this.startNode();
              n2.local = this.parseModuleExportName(), e2.push(this.parseExportSpecifier(n2, i2, t2, r2));
            }
            return e2;
          }
          parseExportSpecifier(t2, e2, s2, r2) {
            return this.eatContextual(87) ? t2.exported = this.parseModuleExportName() : e2 ? t2.exported = zl(t2.local) : t2.exported || (t2.exported = _l(t2.local)), this.finishNode(t2, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(123)) {
              const t2 = this.parseStringLiteral(this.state.value), e2 = t2.value.match(Ed);
              return e2 && this.raise(t2.start, Dc.ModuleExportNameHasLoneSurrogate, e2[0].charCodeAt(0).toString(16)), t2;
            }
            return this.parseIdentifier(true);
          }
          parseImport(t2) {
            if (t2.specifiers = [], !this.match(123)) {
              const e3 = !this.maybeParseDefaultImportSpecifier(t2) || this.eat(12), s2 = e3 && this.maybeParseStarImportSpecifier(t2);
              e3 && !s2 && this.parseNamedImportSpecifiers(t2), this.expectContextual(91);
            }
            t2.source = this.parseImportSource();
            const e2 = this.maybeParseImportAssertions();
            if (e2)
              t2.assertions = e2;
            else {
              const e3 = this.maybeParseModuleAttributes();
              e3 && (t2.attributes = e3);
            }
            return this.semicolon(), this.finishNode(t2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(123) || this.unexpected(), this.parseExprAtom();
          }
          shouldParseDefaultImport(t2) {
            return Uc(this.state.type);
          }
          parseImportSpecifierLocal(t2, e2, s2, r2) {
            e2.local = this.parseIdentifier(), this.checkLVal(e2.local, r2, 9), t2.specifiers.push(this.finishNode(e2, s2));
          }
          parseAssertEntries() {
            const t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              const s2 = this.startNode(), r2 = this.state.value;
              if (e2.has(r2) && this.raise(this.state.start, Dc.ModuleAttributesWithDuplicateKeys, r2), e2.add(r2), this.match(123) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(14), !this.match(123))
                throw this.unexpected(this.state.start, Dc.ModuleAttributeInvalidValue);
              s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), t2.push(s2);
            } while (this.eat(12));
            return t2;
          }
          maybeParseModuleAttributes() {
            if (!this.match(70) || this.hasPrecedingLineBreak())
              return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            const t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              const s2 = this.startNode();
              if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Dc.ModuleAttributeDifferentFromType, s2.key.name), e2.has(s2.key.name) && this.raise(s2.key.start, Dc.ModuleAttributesWithDuplicateKeys, s2.key.name), e2.add(s2.key.name), this.expect(14), !this.match(123))
                throw this.unexpected(this.state.start, Dc.ModuleAttributeInvalidValue);
              s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), t2.push(s2);
            } while (this.eat(12));
            return t2;
          }
          maybeParseImportAssertions() {
            if (!this.isContextual(88) || this.hasPrecedingLineBreak())
              return this.hasPlugin("importAssertions") ? [] : null;
            this.expectPlugin("importAssertions"), this.next(), this.eat(5);
            const t2 = this.parseAssertEntries();
            return this.eat(8), t2;
          }
          maybeParseDefaultImportSpecifier(t2) {
            return !!this.shouldParseDefaultImport(t2) && (this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
          }
          maybeParseStarImportSpecifier(t2) {
            if (this.match(49)) {
              const e2 = this.startNode();
              return this.next(), this.expectContextual(87), this.parseImportSpecifierLocal(t2, e2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t2) {
            let e2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (e2)
                e2 = false;
              else {
                if (this.eat(14))
                  throw this.raise(this.state.start, Dc.DestructureNamedImport);
                if (this.expect(12), this.eat(8))
                  break;
              }
              const s2 = this.startNode(), r2 = this.match(123), i2 = this.isContextual(120);
              s2.imported = this.parseModuleExportName();
              const n2 = this.parseImportSpecifier(s2, r2, t2.importKind === "type" || t2.importKind === "typeof", i2);
              t2.specifiers.push(n2);
            }
          }
          parseImportSpecifier(t2, e2, s2, r2) {
            if (this.eatContextual(87))
              t2.local = this.parseIdentifier();
            else {
              const { imported: s3 } = t2;
              if (e2)
                throw this.raise(t2.start, Dc.ImportBindingIsString, s3.value);
              this.checkReservedWord(s3.name, t2.start, true, true), t2.local || (t2.local = _l(s3));
            }
            return this.checkLVal(t2.local, "import specifier", 9), this.finishNode(t2, "ImportSpecifier");
          }
          isThisParam(t2) {
            return t2.type === "Identifier" && t2.name === "this";
          }
        } {
          constructor(t2, e2) {
            t2 = function(t3) {
              const e3 = {};
              for (const s2 of Object.keys(dd))
                e3[s2] = t3 && t3[s2] != null ? t3[s2] : dd[s2];
              return e3;
            }(t2), super(t2, e2), this.options = t2, this.initializeScopes(), this.plugins = function(t3) {
              const e3 = /* @__PURE__ */ new Map();
              for (const s2 of t3) {
                const [t4, r2] = Array.isArray(s2) ? s2 : [s2, {}];
                e3.has(t4) || e3.set(t4, r2 || {});
              }
              return e3;
            }(this.options.plugins), this.filename = t2.sourceFilename;
          }
          getScopeHandler() {
            return Cl;
          }
          parse() {
            this.enterInitialScopes();
            const t2 = this.startNode(), e2 = this.startNode();
            return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, e2), t2.errors = this.state.errors, t2;
          }
        }
        const xd = function(t2) {
          const e2 = {};
          for (const s2 of Object.keys(t2))
            e2[s2] = Gc(t2[s2]);
          return e2;
        }(jc);
        function Fd(t2, e2) {
          let s2 = Cd;
          return t2 != null && t2.plugins && (!function(t3) {
            if (ad(t3, "decorators")) {
              if (ad(t3, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const e3 = od(t3, "decorators", "decoratorsBeforeExport");
              if (e3 == null)
                throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
              if (typeof e3 != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (ad(t3, "flow") && ad(t3, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (ad(t3, "placeholders") && ad(t3, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (ad(t3, "pipelineOperator")) {
              const e3 = od(t3, "pipelineOperator", "proposal");
              if (!ud.includes(e3)) {
                const t4 = ud.map((t5) => '"'.concat(t5, '"')).join(", ");
                throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(t4, "."));
              }
              const s3 = ad(t3, "recordAndTuple") && od(t3, "recordAndTuple", "syntaxType") === "hash";
              if (e3 === "hack") {
                if (ad(t3, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (ad(t3, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const e4 = od(t3, "pipelineOperator", "topicToken");
                if (!hd.includes(e4)) {
                  const t4 = hd.map((t5) => '"'.concat(t5, '"')).join(", ");
                  throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(t4, "."));
                }
                if (e4 === "#" && s3)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (e3 === "smart" && s3)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (ad(t3, "moduleAttributes")) {
              if (ad(t3, "importAssertions"))
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (od(t3, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (ad(t3, "recordAndTuple") && !pd.includes(od(t3, "recordAndTuple", "syntaxType")))
              throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + pd.map((t4) => "'".concat(t4, "'")).join(", "));
            if (ad(t3, "asyncDoExpressions") && !ad(t3, "doExpressions")) {
              const t4 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw t4.missingPlugins = "doExpressions", t4;
            }
          }(t2.plugins), s2 = function(t3) {
            const e3 = ld.filter((e4) => ad(t3, e4)), s3 = e3.join("/");
            let r2 = gd[s3];
            if (!r2) {
              r2 = Cd;
              for (const t4 of e3)
                r2 = cd[t4](r2);
              gd[s3] = r2;
            }
            return r2;
          }(t2.plugins)), new s2(t2, e2);
        }
        const gd = {};
        ec.parse = function(t2, e2) {
          var s2;
          if (((s2 = e2) == null ? void 0 : s2.sourceType) !== "unambiguous")
            return Fd(e2, t2).parse();
          e2 = Object.assign({}, e2);
          try {
            e2.sourceType = "module";
            const s3 = Fd(e2, t2), r2 = s3.parse();
            if (s3.sawUnambiguousESM)
              return r2;
            if (s3.ambiguousScriptDifferentAst)
              try {
                return e2.sourceType = "script", Fd(e2, t2).parse();
              } catch (t3) {
              }
            else
              r2.program.sourceType = "script";
            return r2;
          } catch (s3) {
            try {
              return e2.sourceType = "script", Fd(e2, t2).parse();
            } catch (t3) {
            }
            throw s3;
          }
        }, ec.parseExpression = function(t2, e2) {
          const s2 = Fd(e2, t2);
          return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
        }, ec.tokTypes = xd;
        const { isNonEmptyArray: Pd } = Oo, Td = ku, bd = vu, Sd = Ou;
        function wd() {
          let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const { allowComments: e2 = true } = t2;
          return function(t3) {
            const { parseExpression: s2 } = ec;
            let r2;
            try {
              r2 = s2(t3, { tokens: true, ranges: true });
            } catch (t4) {
              throw Sd(t4);
            }
            if (!e2 && Pd(r2.comments))
              throw Bd(r2.comments[0], "Comment");
            return Nd(r2), r2;
          };
        }
        function Bd(t2, e2) {
          const [s2, r2] = [t2.loc.start, t2.loc.end].map((t3) => {
            let { line: e3, column: s3 } = t3;
            return { line: e3, column: s3 + 1 };
          });
          return Td("".concat(e2, " is not allowed in JSON."), { start: s2, end: r2 });
        }
        function Nd(t2) {
          switch (t2.type) {
            case "ArrayExpression":
              for (const e2 of t2.elements)
                e2 !== null && Nd(e2);
              return;
            case "ObjectExpression":
              for (const e2 of t2.properties)
                Nd(e2);
              return;
            case "ObjectProperty":
              if (t2.computed)
                throw Bd(t2.key, "Computed key");
              if (t2.shorthand)
                throw Bd(t2.key, "Shorthand property");
              return t2.key.type !== "Identifier" && Nd(t2.key), void Nd(t2.value);
            case "UnaryExpression": {
              const { operator: e2, argument: s2 } = t2;
              if (e2 !== "+" && e2 !== "-")
                throw Bd(t2, "Operator '".concat(t2.operator, "'"));
              if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
                return;
              throw Bd(s2, "Operator '".concat(e2, "' before '").concat(s2.type, "'"));
            }
            case "Identifier":
              if (t2.name !== "Infinity" && t2.name !== "NaN" && t2.name !== "undefined")
                throw Bd(t2, "Identifier '".concat(t2.name, "'"));
              return;
            case "TemplateLiteral":
              if (Pd(t2.expressions))
                throw Bd(t2.expressions[0], "'TemplateLiteral' with expression");
              for (const e2 of t2.quasis)
                Nd(e2);
              return;
            case "NullLiteral":
            case "BooleanLiteral":
            case "NumericLiteral":
            case "StringLiteral":
            case "TemplateElement":
              return;
            default:
              throw Bd(t2, "'".concat(t2.type, "'"));
          }
        }
        const Id = wd();
        var vd = { json: bd({ parse: Id, hasPragma: () => true }), json5: bd(Id), "json-stringify": bd({ parse: wd({ allowComments: false }), astFormat: "estree-json" }) };
        const kd = xi, { getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ld, getShebang: Od } = Oo, Md = vu, Rd = Ou, jd = tc, Ud = vd, _d = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions"], tokens: true, ranges: true }, zd = ["recordAndTuple", { syntaxType: "hash" }], Hd = "v8intrinsic", Vd = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], qd = function(t2) {
          let e2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _d;
          return Object.assign(Object.assign({}, e2), {}, { plugins: [...e2.plugins, ...t2] });
        }, Wd = /@(?:no)?flow\b/;
        function Kd(t2, e2) {
          if (e2.filepath && e2.filepath.endsWith(".js.flow"))
            return true;
          const s2 = Od(t2);
          s2 && (t2 = t2.slice(s2.length));
          const r2 = Ld(t2, 0);
          return r2 !== false && (t2 = t2.slice(0, r2)), Wd.test(t2);
        }
        function Gd(t2, e2, s2) {
          const r2 = (0, ec[t2])(e2, s2), i2 = r2.errors.find((t3) => !tD.has(t3.reasonCode));
          if (i2)
            throw i2;
          return r2;
        }
        function Xd(t2) {
          for (var e2 = arguments.length, s2 = new Array(e2 > 1 ? e2 - 1 : 0), r2 = 1; r2 < e2; r2++)
            s2[r2 - 1] = arguments[r2];
          return function(e3, r3) {
            let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((i2.parser === "babel" || i2.parser === "__babel_estree") && Kd(e3, i2))
              return i2.parser = "babel-flow", $d(e3, r3, i2);
            let n2 = s2;
            i2.__babelSourceType === "script" && (n2 = n2.map((t3) => Object.assign(Object.assign({}, t3), {}, { sourceType: "script" }))), /#[[{]/.test(e3) && (n2 = n2.map((t3) => qd([zd], t3)));
            const a2 = /%[A-Z]/.test(e3);
            if (e3.includes("|>")) {
              const t3 = a2 ? [...Vd, Hd] : Vd;
              n2 = t3.flatMap((t4) => n2.map((e4) => qd([t4], e4)));
            } else
              a2 && (n2 = n2.map((t3) => qd([Hd], t3)));
            const { result: o2, error: u2 } = kd(...n2.map((s3) => () => Gd(t2, e3, s3)));
            if (!o2)
              throw Rd(u2);
            return i2.originalText = e3, jd(o2, i2);
          };
        }
        const Jd = Xd("parse", qd(["jsx", "flow"])), $d = Xd("parse", qd(["jsx", ["flow", { all: true, enums: true }]])), Yd = Xd("parse", qd(["jsx", "typescript"]), qd(["typescript"])), Qd = Xd("parse", qd(["jsx", "flow", "estree"])), Zd = Xd("parseExpression", qd(["jsx"])), tD = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), eD = Md(Jd), sD = Md(Zd);
        return { parsers: Object.assign(Object.assign({ babel: eD, "babel-flow": Md($d), "babel-ts": Md(Yd) }, Ud), {}, { __js_expression: sD, __vue_expression: sD, __vue_event_binding: eD, __babel_estree: Md(Qd) }) };
      });
    }
  });

  // ../../node_modules/prettier/parser-html.js
  var require_parser_html = __commonJS({
    "../../node_modules/prettier/parser-html.js"(exports, module) {
      !function(e, t) {
        typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : ((e = typeof globalThis != "undefined" ? globalThis : e || self).prettierPlugins = e.prettierPlugins || {}, e.prettierPlugins.html = t());
      }(exports, function() {
        "use strict";
        var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, t = {}, r = {};
        !function(e2) {
          function t2(t3) {
            return e2.$0 <= t3 && t3 <= e2.$9;
          }
          Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96, e2.isWhitespace = function(t3) {
            return t3 >= e2.$TAB && t3 <= e2.$SPACE || t3 == e2.$NBSP;
          }, e2.isDigit = t2, e2.isAsciiLetter = function(t3) {
            return t3 >= e2.$a && t3 <= e2.$z || t3 >= e2.$A && t3 <= e2.$Z;
          }, e2.isAsciiHexDigit = function(r2) {
            return r2 >= e2.$a && r2 <= e2.$f || r2 >= e2.$A && r2 <= e2.$F || t2(r2);
          }, e2.isNewLine = function(t3) {
            return t3 === e2.$LF || t3 === e2.$CR;
          }, e2.isOctalDigit = function(t3) {
            return e2.$0 <= t3 && t3 <= e2.$7;
          };
        }(r);
        var n = {}, i = {};
        Object.defineProperty(i, "__esModule", { value: true });
        class s {
          constructor(e2, t2, r2) {
            this.filePath = e2, this.name = t2, this.members = r2;
          }
          assertNoMembers() {
            if (this.members.length)
              throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
          }
        }
        i.StaticSymbol = s;
        i.StaticSymbolCache = class {
          constructor() {
            this.cache = /* @__PURE__ */ new Map();
          }
          get(e2, t2, r2) {
            const n2 = (r2 = r2 || []).length ? ".".concat(r2.join(".")) : "", i2 = '"'.concat(e2, '".').concat(t2).concat(n2);
            let o2 = this.cache.get(i2);
            return o2 || (o2 = new s(e2, t2, r2), this.cache.set(i2, o2)), o2;
          }
        };
        var o = {};
        Object.defineProperty(o, "__esModule", { value: true });
        const a = /-+([a-z0-9])/g;
        function u(e2, t2, r2) {
          const n2 = e2.indexOf(t2);
          return n2 == -1 ? r2 : [e2.slice(0, n2).trim(), e2.slice(n2 + 1).trim()];
        }
        function c(e2, t2, r2) {
          return Array.isArray(e2) ? t2.visitArray(e2, r2) : typeof (n2 = e2) == "object" && n2 !== null && Object.getPrototypeOf(n2) === h ? t2.visitStringMap(e2, r2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t2.visitPrimitive(e2, r2) : t2.visitOther(e2, r2);
          var n2;
        }
        o.dashCaseToCamelCase = function(e2) {
          return e2.replace(a, function() {
            for (var e3 = arguments.length, t2 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t2[r2] = arguments[r2];
            return t2[1].toUpperCase();
          });
        }, o.splitAtColon = function(e2, t2) {
          return u(e2, ":", t2);
        }, o.splitAtPeriod = function(e2, t2) {
          return u(e2, ".", t2);
        }, o.visitValue = c, o.isDefined = function(e2) {
          return e2 != null;
        }, o.noUndefined = function(e2) {
          return e2 === void 0 ? null : e2;
        };
        o.ValueTransformer = class {
          visitArray(e2, t2) {
            return e2.map((e3) => c(e3, this, t2));
          }
          visitStringMap(e2, t2) {
            const r2 = {};
            return Object.keys(e2).forEach((n2) => {
              r2[n2] = c(e2[n2], this, t2);
            }), r2;
          }
          visitPrimitive(e2, t2) {
            return e2;
          }
          visitOther(e2, t2) {
            return e2;
          }
        }, o.SyncAsync = { assertSync: (e2) => {
          if (D(e2))
            throw new Error("Illegal state: value cannot be a promise");
          return e2;
        }, then: (e2, t2) => D(e2) ? e2.then(t2) : t2(e2), all: (e2) => e2.some(D) ? Promise.all(e2) : e2 }, o.error = function(e2) {
          throw new Error("Internal Error: ".concat(e2));
        }, o.syntaxError = function(e2, t2) {
          const r2 = Error(e2);
          return r2[l] = true, t2 && (r2[p] = t2), r2;
        };
        const l = "ngSyntaxError", p = "ngParseErrors";
        o.isSyntaxError = function(e2) {
          return e2[l];
        }, o.getParseErrors = function(e2) {
          return e2[p] || [];
        }, o.escapeRegExp = function(e2) {
          return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        };
        const h = Object.getPrototypeOf({});
        function D(e2) {
          return !!e2 && typeof e2.then == "function";
        }
        o.utf8Encode = function(e2) {
          let t2 = "";
          for (let r2 = 0; r2 < e2.length; r2++) {
            let n2 = e2.charCodeAt(r2);
            if (n2 >= 55296 && n2 <= 56319 && e2.length > r2 + 1) {
              const t3 = e2.charCodeAt(r2 + 1);
              t3 >= 56320 && t3 <= 57343 && (r2++, n2 = (n2 - 55296 << 10) + t3 - 56320 + 65536);
            }
            n2 <= 127 ? t2 += String.fromCharCode(n2) : n2 <= 2047 ? t2 += String.fromCharCode(n2 >> 6 & 31 | 192, 63 & n2 | 128) : n2 <= 65535 ? t2 += String.fromCharCode(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128) : n2 <= 2097151 && (t2 += String.fromCharCode(n2 >> 18 & 7 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128));
          }
          return t2;
        }, o.stringify = function e2(t2) {
          if (typeof t2 == "string")
            return t2;
          if (t2 instanceof Array)
            return "[" + t2.map(e2).join(", ") + "]";
          if (t2 == null)
            return "" + t2;
          if (t2.overriddenName)
            return "".concat(t2.overriddenName);
          if (t2.name)
            return "".concat(t2.name);
          if (!t2.toString)
            return "object";
          const r2 = t2.toString();
          if (r2 == null)
            return "" + r2;
          const n2 = r2.indexOf("\n");
          return n2 === -1 ? r2 : r2.substring(0, n2);
        }, o.resolveForwardRef = function(e2) {
          return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
        }, o.isPromise = D;
        o.Version = class {
          constructor(e2) {
            this.full = e2;
            const t2 = e2.split(".");
            this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
          }
        };
        const f = typeof window != "undefined" && window, d = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self, g = e !== void 0 && e || f || d;
        o.global = g, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = i, r2 = o, n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function s2(e3) {
            return e3.replace(/\W/g, "_");
          }
          e2.sanitizeIdentifier = s2;
          let a2 = 0;
          function u2(e3) {
            if (!e3 || !e3.reference)
              return null;
            const n3 = e3.reference;
            if (n3 instanceof t2.StaticSymbol)
              return n3.name;
            if (n3.__anonymousType)
              return n3.__anonymousType;
            let i2 = r2.stringify(n3);
            return i2.indexOf("(") >= 0 ? (i2 = "anonymous_".concat(a2++), n3.__anonymousType = i2) : i2 = s2(i2), i2;
          }
          var c2;
          e2.identifierName = u2, e2.identifierModuleUrl = function(e3) {
            const n3 = e3.reference;
            return n3 instanceof t2.StaticSymbol ? n3.filePath : "./".concat(r2.stringify(n3));
          }, e2.viewClassName = function(e3, t3) {
            return "View_".concat(u2({ reference: e3 }), "_").concat(t3);
          }, e2.rendererTypeName = function(e3) {
            return "RenderType_".concat(u2({ reference: e3 }));
          }, e2.hostViewClassName = function(e3) {
            return "HostView_".concat(u2({ reference: e3 }));
          }, e2.componentFactoryName = function(e3) {
            return "".concat(u2({ reference: e3 }), "NgFactory");
          }, function(e3) {
            e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
          }(c2 = e2.CompileSummaryKind || (e2.CompileSummaryKind = {})), e2.tokenName = function(e3) {
            return e3.value != null ? s2(e3.value) : u2(e3.identifier);
          }, e2.tokenReference = function(e3) {
            return e3.identifier != null ? e3.identifier.reference : e3.value;
          };
          e2.CompileStylesheetMetadata = class {
            constructor() {
              let { moduleUrl: e3, styles: t3, styleUrls: r3 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = e3 || null, this.styles = p2(t3), this.styleUrls = p2(r3);
            }
          };
          e2.CompileTemplateMetadata = class {
            constructor(e3) {
              let { encapsulation: t3, template: r3, templateUrl: n3, htmlAst: i2, styles: s3, styleUrls: o2, externalStylesheets: a3, animations: u3, ngContentSelectors: c3, interpolation: l3, isInline: D3, preserveWhitespaces: f2 } = e3;
              if (this.encapsulation = t3, this.template = r3, this.templateUrl = n3, this.htmlAst = i2, this.styles = p2(s3), this.styleUrls = p2(o2), this.externalStylesheets = p2(a3), this.animations = u3 ? h2(u3) : [], this.ngContentSelectors = c3 || [], l3 && l3.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = l3, this.isInline = D3, this.preserveWhitespaces = f2;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          class l2 {
            static create(e3) {
              let { isHost: t3, type: i2, isComponent: s3, selector: o2, exportAs: a3, changeDetection: u3, inputs: c3, outputs: p3, host: h3, providers: D3, viewProviders: f2, queries: d2, guards: g2, viewQueries: m2, entryComponents: E2, template: C2, componentViewType: y2, rendererType: b2, componentFactory: S2 } = e3;
              const T2 = {}, _2 = {}, v2 = {};
              h3 != null && Object.keys(h3).forEach((e4) => {
                const t4 = h3[e4], r3 = e4.match(n2);
                r3 === null ? v2[e4] = t4 : r3[1] != null ? _2[r3[1]] = t4 : r3[2] != null && (T2[r3[2]] = t4);
              });
              const A2 = {};
              c3 != null && c3.forEach((e4) => {
                const t4 = r2.splitAtColon(e4, [e4, e4]);
                A2[t4[0]] = t4[1];
              });
              const F2 = {};
              return p3 != null && p3.forEach((e4) => {
                const t4 = r2.splitAtColon(e4, [e4, e4]);
                F2[t4[0]] = t4[1];
              }), new l2({ isHost: t3, type: i2, isComponent: !!s3, selector: o2, exportAs: a3, changeDetection: u3, inputs: A2, outputs: F2, hostListeners: T2, hostProperties: _2, hostAttributes: v2, providers: D3, viewProviders: f2, queries: d2, guards: g2, viewQueries: m2, entryComponents: E2, template: C2, componentViewType: y2, rendererType: b2, componentFactory: S2 });
            }
            constructor(e3) {
              let { isHost: t3, type: r3, isComponent: n3, selector: i2, exportAs: s3, changeDetection: o2, inputs: a3, outputs: u3, hostListeners: c3, hostProperties: l3, hostAttributes: h3, providers: D3, viewProviders: f2, queries: d2, guards: g2, viewQueries: m2, entryComponents: E2, template: C2, componentViewType: y2, rendererType: b2, componentFactory: S2 } = e3;
              this.isHost = !!t3, this.type = r3, this.isComponent = n3, this.selector = i2, this.exportAs = s3, this.changeDetection = o2, this.inputs = a3, this.outputs = u3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = h3, this.providers = p2(D3), this.viewProviders = p2(f2), this.queries = p2(d2), this.guards = g2, this.viewQueries = p2(m2), this.entryComponents = p2(E2), this.template = C2, this.componentViewType = y2, this.rendererType = b2, this.componentFactory = S2;
            }
            toSummary() {
              return { summaryKind: c2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          }
          e2.CompileDirectiveMetadata = l2;
          e2.CompilePipeMetadata = class {
            constructor(e3) {
              let { type: t3, name: r3, pure: n3 } = e3;
              this.type = t3, this.name = r3, this.pure = !!n3;
            }
            toSummary() {
              return { summaryKind: c2.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e2.CompileShallowModuleMetadata = class {
          };
          e2.CompileNgModuleMetadata = class {
            constructor(e3) {
              let { type: t3, providers: r3, declaredDirectives: n3, exportedDirectives: i2, declaredPipes: s3, exportedPipes: o2, entryComponents: a3, bootstrapComponents: u3, importedModules: c3, exportedModules: l3, schemas: h3, transitiveModule: D3, id: f2 } = e3;
              this.type = t3 || null, this.declaredDirectives = p2(n3), this.exportedDirectives = p2(i2), this.declaredPipes = p2(s3), this.exportedPipes = p2(o2), this.providers = p2(r3), this.entryComponents = p2(a3), this.bootstrapComponents = p2(u3), this.importedModules = p2(c3), this.exportedModules = p2(l3), this.schemas = p2(h3), this.id = f2 || null, this.transitiveModule = D3 || null;
            }
            toSummary() {
              const e3 = this.transitiveModule;
              return { summaryKind: c2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
            }
          };
          function p2(e3) {
            return e3 || [];
          }
          e2.TransitiveCompileNgModuleMetadata = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(e3, t3) {
              this.providers.push({ provider: e3, module: t3 });
            }
            addDirective(e3) {
              this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
            }
            addExportedDirective(e3) {
              this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
            }
            addPipe(e3) {
              this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
            }
            addExportedPipe(e3) {
              this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
            }
            addModule(e3) {
              this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
            }
            addEntryComponent(e3) {
              this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
            }
          };
          function h2(e3) {
            return e3.reduce((e4, t3) => {
              const r3 = Array.isArray(t3) ? h2(t3) : t3;
              return e4.concat(r3);
            }, []);
          }
          function D2(e3) {
            return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          e2.ProviderMeta = class {
            constructor(e3, t3) {
              let { useClass: r3, useValue: n3, useExisting: i2, useFactory: s3, deps: o2, multi: a3 } = t3;
              this.token = e3, this.useClass = r3 || null, this.useValue = n3, this.useExisting = i2, this.useFactory = s3 || null, this.dependencies = o2 || null, this.multi = !!a3;
            }
          }, e2.flatten = h2, e2.templateSourceUrl = function(e3, r3, n3) {
            let i2;
            return i2 = n3.isInline ? r3.type.reference instanceof t2.StaticSymbol ? "".concat(r3.type.reference.filePath, ".").concat(r3.type.reference.name, ".html") : "".concat(u2(e3), "/").concat(u2(r3.type), ".html") : n3.templateUrl, r3.type.reference instanceof t2.StaticSymbol ? i2 : D2(i2);
          }, e2.sharedStylesheetJitUrl = function(e3, t3) {
            const r3 = e3.moduleUrl.split(/\/\\/g), n3 = r3[r3.length - 1];
            return D2("css/".concat(t3).concat(n3, ".ngstyle.js"));
          }, e2.ngModuleJitUrl = function(e3) {
            return D2("".concat(u2(e3.type), "/module.ngfactory.js"));
          }, e2.templateJitUrl = function(e3, t3) {
            return D2("".concat(u2(e3), "/").concat(u2(t3.type), ".ngfactory.js"));
          };
        }(n), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = r, i2 = n;
          class s2 {
            constructor(e3, t3, r2, n2) {
              this.file = e3, this.offset = t3, this.line = r2, this.col = n2;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(e3) {
              const r2 = this.file.content, n2 = r2.length;
              let i3 = this.offset, o3 = this.line, a3 = this.col;
              for (; i3 > 0 && e3 < 0; ) {
                i3--, e3++;
                if (r2.charCodeAt(i3) == t2.$LF) {
                  o3--;
                  const e4 = r2.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(t2.$LF));
                  a3 = e4 > 0 ? i3 - e4 : i3;
                } else
                  a3--;
              }
              for (; i3 < n2 && e3 > 0; ) {
                const n3 = r2.charCodeAt(i3);
                i3++, e3--, n3 == t2.$LF ? (o3++, a3 = 0) : a3++;
              }
              return new s2(this.file, i3, o3, a3);
            }
            getContext(e3, t3) {
              const r2 = this.file.content;
              let n2 = this.offset;
              if (n2 != null) {
                n2 > r2.length - 1 && (n2 = r2.length - 1);
                let i3 = n2, s3 = 0, o3 = 0;
                for (; s3 < e3 && n2 > 0 && (n2--, s3++, r2[n2] != "\n" || ++o3 != t3); )
                  ;
                for (s3 = 0, o3 = 0; s3 < e3 && i3 < r2.length - 1 && (i3++, s3++, r2[i3] != "\n" || ++o3 != t3); )
                  ;
                return { before: r2.substring(n2, this.offset), after: r2.substring(this.offset, i3 + 1) };
              }
              return null;
            }
          }
          e2.ParseLocation = s2;
          class o2 {
            constructor(e3, t3) {
              this.content = e3, this.url = t3;
            }
          }
          e2.ParseSourceFile = o2;
          class a2 {
            constructor(e3, t3) {
              let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = e3, this.end = t3, this.details = r2;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          }
          var u2;
          e2.ParseSourceSpan = a2, e2.EMPTY_PARSE_LOCATION = new s2(new o2("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new a2(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION), function(e3) {
            e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
          }(u2 = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
          e2.ParseError = class {
            constructor(e3, t3) {
              let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u2.ERROR;
              this.span = e3, this.msg = t3, this.level = r2;
            }
            contextualMessage() {
              const e3 = this.span.start.getContext(100, 3);
              return e3 ? "".concat(this.msg, ' ("').concat(e3.before, "[").concat(u2[this.level], " ->]").concat(e3.after, '")') : this.msg;
            }
            toString() {
              const e3 = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e3);
            }
          }, e2.typeSourceSpan = function(e3, t3) {
            const r2 = i2.identifierModuleUrl(t3), n2 = r2 != null ? "in ".concat(e3, " ").concat(i2.identifierName(t3), " in ").concat(r2) : "in ".concat(e3, " ").concat(i2.identifierName(t3)), u3 = new o2("", n2);
            return new a2(new s2(u3, -1, -1, -1), new s2(u3, -1, -1, -1));
          }, e2.r3JitTypeSourceSpan = function(e3, t3, r2) {
            const n2 = "in ".concat(e3, " ").concat(t3, " in ").concat(r2), i3 = new o2("", n2);
            return new a2(new s2(i3, -1, -1, -1), new s2(i3, -1, -1, -1));
          };
        }(t);
        const m = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
        var E = function(e2) {
          const t2 = e2.match(m);
          if (!t2)
            return { content: e2 };
          const { startDelimiter: r2, language: n2, value: i2 = "", endDelimiter: s2 } = t2.groups;
          let o2 = n2.trim() || "yaml";
          if (r2 === "+++" && (o2 = "toml"), o2 !== "yaml" && r2 !== s2)
            return { content: e2 };
          const [a2] = t2;
          return { frontMatter: { type: "front-matter", lang: o2, value: i2, startDelimiter: r2, endDelimiter: s2, raw: a2.replace(/\n$/, "") }, content: a2.replace(/[^\n]/g, " ") + e2.slice(a2.length) };
        };
        var C = (e2) => e2[e2.length - 1];
        var y = function(e2, t2) {
          const r2 = new SyntaxError(e2 + " (" + t2.start.line + ":" + t2.start.column + ")");
          return r2.loc = t2, r2;
        }, b = { exports: {} };
        const S = function() {
          let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(t2, e2 ? void 0 : "g");
        };
        var T = { exports: {} };
        const _ = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
        T.exports = _, T.exports.default = _;
        const v = (e2) => typeof e2 == "string" ? e2.replace(S(), "") : e2, A = T.exports, F = function() {
          return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        }, w = (e2) => {
          if (typeof e2 != "string" || e2.length === 0)
            return 0;
          if ((e2 = v(e2)).length === 0)
            return 0;
          e2 = e2.replace(F(), "  ");
          let t2 = 0;
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2.codePointAt(r2);
            n2 <= 31 || n2 >= 127 && n2 <= 159 || (n2 >= 768 && n2 <= 879 || (n2 > 65535 && r2++, t2 += A(n2) ? 2 : 1));
          }
          return t2;
        };
        b.exports = w, b.exports.default = w;
        function k(e2, t2) {
          if (e2 == null)
            return {};
          var r2, n2, i2 = function(e3, t3) {
            if (e3 == null)
              return {};
            var r3, n3, i3 = {}, s3 = Object.keys(e3);
            for (n3 = 0; n3 < s3.length; n3++)
              r3 = s3[n3], t3.indexOf(r3) >= 0 || (i3[r3] = e3[r3]);
            return i3;
          }(e2, t2);
          if (Object.getOwnPropertySymbols) {
            var s2 = Object.getOwnPropertySymbols(e2);
            for (n2 = 0; n2 < s2.length; n2++)
              r2 = s2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, r2) && (i2[r2] = e2[r2]);
          }
          return i2;
        }
        function N(e2, t2) {
          return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(t2) } }));
        }
        var O = function(e2) {
          return e2 && e2.Math == Math && e2;
        }, x = O(typeof globalThis == "object" && globalThis) || O(typeof window == "object" && window) || O(typeof self == "object" && self) || O(typeof e == "object" && e) || function() {
          return this;
        }() || Function("return this")(), I = {}, P = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        }, R = !P(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        }), L = Function.prototype.call, B = L.bind ? L.bind(L) : function() {
          return L.apply(L, arguments);
        }, q = {}, $ = {}.propertyIsEnumerable, M = Object.getOwnPropertyDescriptor, j = M && !$.call({ 1: 2 }, 1);
        q.f = j ? function(e2) {
          var t2 = M(this, e2);
          return !!t2 && t2.enumerable;
        } : $;
        var U, G, V = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        }, X = Function.prototype, H = X.bind, z = X.call, W = H && H.bind(z), Y = H ? function(e2) {
          return e2 && W(z, e2);
        } : function(e2) {
          return e2 && function() {
            return z.apply(e2, arguments);
          };
        }, Q = Y, J = Q({}.toString), Z = Q("".slice), K = function(e2) {
          return Z(J(e2), 8, -1);
        }, ee = Y, te = P, re = K, ne = x.Object, ie = ee("".split), se = te(function() {
          return !ne("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return re(e2) == "String" ? ie(e2, "") : ne(e2);
        } : ne, oe = x.TypeError, ae = function(e2) {
          if (e2 == null)
            throw oe("Can't call method on " + e2);
          return e2;
        }, ue = se, ce = ae, le = function(e2) {
          return ue(ce(e2));
        }, pe = function(e2) {
          return typeof e2 == "function";
        }, he = pe, De = function(e2) {
          return typeof e2 == "object" ? e2 !== null : he(e2);
        }, fe = x, de = pe, ge = function(e2) {
          return de(e2) ? e2 : void 0;
        }, me = function(e2, t2) {
          return arguments.length < 2 ? ge(fe[e2]) : fe[e2] && fe[e2][t2];
        }, Ee = Y({}.isPrototypeOf), Ce = me("navigator", "userAgent") || "", ye = x, be = Ce, Se = ye.process, Te = ye.Deno, _e = Se && Se.versions || Te && Te.version, ve = _e && _e.v8;
        ve && (G = (U = ve.split("."))[0] > 0 && U[0] < 4 ? 1 : +(U[0] + U[1])), !G && be && (!(U = be.match(/Edge\/(\d+)/)) || U[1] >= 74) && (U = be.match(/Chrome\/(\d+)/)) && (G = +U[1]);
        var Ae = G, Fe = Ae, we = P, ke = !!Object.getOwnPropertySymbols && !we(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Fe && Fe < 41;
        }), Ne = ke && !Symbol.sham && typeof Symbol.iterator == "symbol", Oe = me, xe = pe, Ie = Ee, Pe = Ne, Re = x.Object, Le = Pe ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var t2 = Oe("Symbol");
          return xe(t2) && Ie(t2.prototype, Re(e2));
        }, Be = x.String, qe = function(e2) {
          try {
            return Be(e2);
          } catch (e3) {
            return "Object";
          }
        }, $e = pe, Me = qe, je = x.TypeError, Ue = function(e2) {
          if ($e(e2))
            return e2;
          throw je(Me(e2) + " is not a function");
        }, Ge = Ue, Ve = function(e2, t2) {
          var r2 = e2[t2];
          return r2 == null ? void 0 : Ge(r2);
        }, Xe = B, He = pe, ze = De, We = x.TypeError, Ye = { exports: {} }, Qe = x, Je = Object.defineProperty, Ze = function(e2, t2) {
          try {
            Je(Qe, e2, { value: t2, configurable: true, writable: true });
          } catch (r2) {
            Qe[e2] = t2;
          }
          return t2;
        }, Ke = Ze, et = "__core-js_shared__", tt = x[et] || Ke(et, {}), rt = tt;
        (Ye.exports = function(e2, t2) {
          return rt[e2] || (rt[e2] = t2 !== void 0 ? t2 : {});
        })("versions", []).push({ version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
        var nt = ae, it = x.Object, st = function(e2) {
          return it(nt(e2));
        }, ot = st, at = Y({}.hasOwnProperty), ut = Object.hasOwn || function(e2, t2) {
          return at(ot(e2), t2);
        }, ct = Y, lt = 0, pt = Math.random(), ht = ct(1 .toString), Dt = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + ht(++lt + pt, 36);
        }, ft = x, dt = Ye.exports, gt = ut, mt = Dt, Et = ke, Ct = Ne, yt = dt("wks"), bt = ft.Symbol, St = bt && bt.for, Tt = Ct ? bt : bt && bt.withoutSetter || mt, _t = function(e2) {
          if (!gt(yt, e2) || !Et && typeof yt[e2] != "string") {
            var t2 = "Symbol." + e2;
            Et && gt(bt, e2) ? yt[e2] = bt[e2] : yt[e2] = Ct && St ? St(t2) : Tt(t2);
          }
          return yt[e2];
        }, vt = B, At = De, Ft = Le, wt = Ve, kt = function(e2, t2) {
          var r2, n2;
          if (t2 === "string" && He(r2 = e2.toString) && !ze(n2 = Xe(r2, e2)))
            return n2;
          if (He(r2 = e2.valueOf) && !ze(n2 = Xe(r2, e2)))
            return n2;
          if (t2 !== "string" && He(r2 = e2.toString) && !ze(n2 = Xe(r2, e2)))
            return n2;
          throw We("Can't convert object to primitive value");
        }, Nt = _t, Ot = x.TypeError, xt = Nt("toPrimitive"), It = function(e2, t2) {
          if (!At(e2) || Ft(e2))
            return e2;
          var r2, n2 = wt(e2, xt);
          if (n2) {
            if (t2 === void 0 && (t2 = "default"), r2 = vt(n2, e2, t2), !At(r2) || Ft(r2))
              return r2;
            throw Ot("Can't convert object to primitive value");
          }
          return t2 === void 0 && (t2 = "number"), kt(e2, t2);
        }, Pt = Le, Rt = function(e2) {
          var t2 = It(e2, "string");
          return Pt(t2) ? t2 : t2 + "";
        }, Lt = De, Bt = x.document, qt = Lt(Bt) && Lt(Bt.createElement), $t = function(e2) {
          return qt ? Bt.createElement(e2) : {};
        }, Mt = !R && !P(function() {
          return Object.defineProperty($t("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        }), jt = R, Ut = B, Gt = q, Vt = V, Xt = le, Ht = Rt, zt = ut, Wt = Mt, Yt = Object.getOwnPropertyDescriptor;
        I.f = jt ? Yt : function(e2, t2) {
          if (e2 = Xt(e2), t2 = Ht(t2), Wt)
            try {
              return Yt(e2, t2);
            } catch (e3) {
            }
          if (zt(e2, t2))
            return Vt(!Ut(Gt.f, e2, t2), e2[t2]);
        };
        var Qt = {}, Jt = x, Zt = De, Kt = Jt.String, er = Jt.TypeError, tr = function(e2) {
          if (Zt(e2))
            return e2;
          throw er(Kt(e2) + " is not an object");
        }, rr = R, nr = Mt, ir = tr, sr = Rt, or = x.TypeError, ar = Object.defineProperty;
        Qt.f = rr ? ar : function(e2, t2, r2) {
          if (ir(e2), t2 = sr(t2), ir(r2), nr)
            try {
              return ar(e2, t2, r2);
            } catch (e3) {
            }
          if ("get" in r2 || "set" in r2)
            throw or("Accessors not supported");
          return "value" in r2 && (e2[t2] = r2.value), e2;
        };
        var ur = Qt, cr = V, lr = R ? function(e2, t2, r2) {
          return ur.f(e2, t2, cr(1, r2));
        } : function(e2, t2, r2) {
          return e2[t2] = r2, e2;
        }, pr = { exports: {} }, hr = pe, Dr = tt, fr = Y(Function.toString);
        hr(Dr.inspectSource) || (Dr.inspectSource = function(e2) {
          return fr(e2);
        });
        var dr, gr, mr, Er = Dr.inspectSource, Cr = pe, yr = Er, br = x.WeakMap, Sr = Cr(br) && /native code/.test(yr(br)), Tr = Ye.exports, _r = Dt, vr = Tr("keys"), Ar = {}, Fr = Sr, wr = x, kr = Y, Nr = De, Or = lr, xr = ut, Ir = tt, Pr = function(e2) {
          return vr[e2] || (vr[e2] = _r(e2));
        }, Rr = Ar, Lr = "Object already initialized", Br = wr.TypeError, qr = wr.WeakMap;
        if (Fr || Ir.state) {
          var $r = Ir.state || (Ir.state = new qr()), Mr = kr($r.get), jr = kr($r.has), Ur = kr($r.set);
          dr = function(e2, t2) {
            if (jr($r, e2))
              throw new Br(Lr);
            return t2.facade = e2, Ur($r, e2, t2), t2;
          }, gr = function(e2) {
            return Mr($r, e2) || {};
          }, mr = function(e2) {
            return jr($r, e2);
          };
        } else {
          var Gr = Pr("state");
          Rr[Gr] = true, dr = function(e2, t2) {
            if (xr(e2, Gr))
              throw new Br(Lr);
            return t2.facade = e2, Or(e2, Gr, t2), t2;
          }, gr = function(e2) {
            return xr(e2, Gr) ? e2[Gr] : {};
          }, mr = function(e2) {
            return xr(e2, Gr);
          };
        }
        var Vr = { set: dr, get: gr, has: mr, enforce: function(e2) {
          return mr(e2) ? gr(e2) : dr(e2, {});
        }, getterFor: function(e2) {
          return function(t2) {
            var r2;
            if (!Nr(t2) || (r2 = gr(t2)).type !== e2)
              throw Br("Incompatible receiver, " + e2 + " required");
            return r2;
          };
        } }, Xr = R, Hr = ut, zr = Function.prototype, Wr = Xr && Object.getOwnPropertyDescriptor, Yr = Hr(zr, "name"), Qr = Yr && function() {
        }.name === "something", Jr = Yr && (!Xr || Xr && Wr(zr, "name").configurable), Zr = x, Kr = pe, en = ut, tn = lr, rn = Ze, nn = Er, sn = { EXISTS: Yr, PROPER: Qr, CONFIGURABLE: Jr }.CONFIGURABLE, on = Vr.get, an = Vr.enforce, un = String(String).split("String");
        (pr.exports = function(e2, t2, r2, n2) {
          var i2, s2 = !!n2 && !!n2.unsafe, o2 = !!n2 && !!n2.enumerable, a2 = !!n2 && !!n2.noTargetGet, u2 = n2 && n2.name !== void 0 ? n2.name : t2;
          Kr(r2) && (String(u2).slice(0, 7) === "Symbol(" && (u2 = "[" + String(u2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!en(r2, "name") || sn && r2.name !== u2) && tn(r2, "name", u2), (i2 = an(r2)).source || (i2.source = un.join(typeof u2 == "string" ? u2 : ""))), e2 !== Zr ? (s2 ? !a2 && e2[t2] && (o2 = true) : delete e2[t2], o2 ? e2[t2] = r2 : tn(e2, t2, r2)) : o2 ? e2[t2] = r2 : rn(t2, r2);
        })(Function.prototype, "toString", function() {
          return Kr(this) && on(this).source || nn(this);
        });
        var cn = {}, ln = Math.ceil, pn = Math.floor, hn = function(e2) {
          var t2 = +e2;
          return t2 != t2 || t2 === 0 ? 0 : (t2 > 0 ? pn : ln)(t2);
        }, Dn = hn, fn = Math.max, dn = Math.min, gn = hn, mn = Math.min, En = function(e2) {
          return e2 > 0 ? mn(gn(e2), 9007199254740991) : 0;
        }, Cn = function(e2) {
          return En(e2.length);
        }, yn = le, bn = function(e2, t2) {
          var r2 = Dn(e2);
          return r2 < 0 ? fn(r2 + t2, 0) : dn(r2, t2);
        }, Sn = Cn, Tn = function(e2) {
          return function(t2, r2, n2) {
            var i2, s2 = yn(t2), o2 = Sn(s2), a2 = bn(n2, o2);
            if (e2 && r2 != r2) {
              for (; o2 > a2; )
                if ((i2 = s2[a2++]) != i2)
                  return true;
            } else
              for (; o2 > a2; a2++)
                if ((e2 || a2 in s2) && s2[a2] === r2)
                  return e2 || a2 || 0;
            return !e2 && -1;
          };
        }, _n = { includes: Tn(true), indexOf: Tn(false) }, vn = ut, An = le, Fn = _n.indexOf, wn = Ar, kn = Y([].push), Nn = function(e2, t2) {
          var r2, n2 = An(e2), i2 = 0, s2 = [];
          for (r2 in n2)
            !vn(wn, r2) && vn(n2, r2) && kn(s2, r2);
          for (; t2.length > i2; )
            vn(n2, r2 = t2[i2++]) && (~Fn(s2, r2) || kn(s2, r2));
          return s2;
        }, On = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype");
        cn.f = Object.getOwnPropertyNames || function(e2) {
          return Nn(e2, On);
        };
        var xn = {};
        xn.f = Object.getOwnPropertySymbols;
        var In = me, Pn = cn, Rn = xn, Ln = tr, Bn = Y([].concat), qn = In("Reflect", "ownKeys") || function(e2) {
          var t2 = Pn.f(Ln(e2)), r2 = Rn.f;
          return r2 ? Bn(t2, r2(e2)) : t2;
        }, $n = ut, Mn = qn, jn = I, Un = Qt, Gn = P, Vn = pe, Xn = /#|\.prototype\./, Hn = function(e2, t2) {
          var r2 = Wn[zn(e2)];
          return r2 == Qn || r2 != Yn && (Vn(t2) ? Gn(t2) : !!t2);
        }, zn = Hn.normalize = function(e2) {
          return String(e2).replace(Xn, ".").toLowerCase();
        }, Wn = Hn.data = {}, Yn = Hn.NATIVE = "N", Qn = Hn.POLYFILL = "P", Jn = Hn, Zn = x, Kn = I.f, ei = lr, ti = pr.exports, ri = Ze, ni = function(e2, t2) {
          for (var r2 = Mn(t2), n2 = Un.f, i2 = jn.f, s2 = 0; s2 < r2.length; s2++) {
            var o2 = r2[s2];
            $n(e2, o2) || n2(e2, o2, i2(t2, o2));
          }
        }, ii = Jn, si = function(e2, t2) {
          var r2, n2, i2, s2, o2, a2 = e2.target, u2 = e2.global, c2 = e2.stat;
          if (r2 = u2 ? Zn : c2 ? Zn[a2] || ri(a2, {}) : (Zn[a2] || {}).prototype)
            for (n2 in t2) {
              if (s2 = t2[n2], i2 = e2.noTargetGet ? (o2 = Kn(r2, n2)) && o2.value : r2[n2], !ii(u2 ? n2 : a2 + (c2 ? "." : "#") + n2, e2.forced) && i2 !== void 0) {
                if (typeof s2 == typeof i2)
                  continue;
                ni(s2, i2);
              }
              (e2.sham || i2 && i2.sham) && ei(s2, "sham", true), ti(r2, n2, s2, e2);
            }
        }, oi = K, ai = Array.isArray || function(e2) {
          return oi(e2) == "Array";
        }, ui = Ue, ci = Y(Y.bind), li = function(e2, t2) {
          return ui(e2), t2 === void 0 ? e2 : ci ? ci(e2, t2) : function() {
            return e2.apply(t2, arguments);
          };
        }, pi = ai, hi = Cn, Di = li, fi = x.TypeError, di = function(e2, t2, r2, n2, i2, s2, o2, a2) {
          for (var u2, c2, l2 = i2, p2 = 0, h2 = !!o2 && Di(o2, a2); p2 < n2; ) {
            if (p2 in r2) {
              if (u2 = h2 ? h2(r2[p2], p2, t2) : r2[p2], s2 > 0 && pi(u2))
                c2 = hi(u2), l2 = di(e2, t2, u2, c2, l2, s2 - 1) - 1;
              else {
                if (l2 >= 9007199254740991)
                  throw fi("Exceed the acceptable array length");
                e2[l2] = u2;
              }
              l2++;
            }
            p2++;
          }
          return l2;
        }, gi = di, mi = {};
        mi[_t("toStringTag")] = "z";
        var Ei = x, Ci = String(mi) === "[object z]", yi = pe, bi = K, Si = _t("toStringTag"), Ti = Ei.Object, _i = bi(function() {
          return arguments;
        }()) == "Arguments", vi = Ci ? bi : function(e2) {
          var t2, r2, n2;
          return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = Ti(e2), Si)) == "string" ? r2 : _i ? bi(t2) : (n2 = bi(t2)) == "Object" && yi(t2.callee) ? "Arguments" : n2;
        }, Ai = Y, Fi = P, wi = pe, ki = vi, Ni = Er, Oi = function() {
        }, xi = [], Ii = me("Reflect", "construct"), Pi = /^\s*(?:class|function)\b/, Ri = Ai(Pi.exec), Li = !Pi.exec(Oi), Bi = function(e2) {
          if (!wi(e2))
            return false;
          try {
            return Ii(Oi, xi, e2), true;
          } catch (e3) {
            return false;
          }
        }, qi = !Ii || Fi(function() {
          var e2;
          return Bi(Bi.call) || !Bi(Object) || !Bi(function() {
            e2 = true;
          }) || e2;
        }) ? function(e2) {
          if (!wi(e2))
            return false;
          switch (ki(e2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          return Li || !!Ri(Pi, Ni(e2));
        } : Bi, $i = x, Mi = ai, ji = qi, Ui = De, Gi = _t("species"), Vi = $i.Array, Xi = function(e2) {
          var t2;
          return Mi(e2) && (t2 = e2.constructor, (ji(t2) && (t2 === Vi || Mi(t2.prototype)) || Ui(t2) && (t2 = t2[Gi]) === null) && (t2 = void 0)), t2 === void 0 ? Vi : t2;
        }, Hi = gi, zi = Ue, Wi = st, Yi = Cn, Qi = function(e2, t2) {
          return new (Xi(e2))(t2 === 0 ? 0 : t2);
        };
        si({ target: "Array", proto: true }, { flatMap: function(e2) {
          var t2, r2 = Wi(this), n2 = Yi(r2);
          return zi(e2), (t2 = Qi(r2, 0)).length = Hi(t2, r2, r2, n2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
        } });
        var Ji = vi, Zi = x.String, Ki = Y([].slice), es = Math.floor, ts = function(e2, t2) {
          var r2 = e2.length, n2 = es(r2 / 2);
          return r2 < 8 ? rs(e2, t2) : ns(e2, ts(Ki(e2, 0, n2), t2), ts(Ki(e2, n2), t2), t2);
        }, rs = function(e2, t2) {
          for (var r2, n2, i2 = e2.length, s2 = 1; s2 < i2; ) {
            for (n2 = s2, r2 = e2[s2]; n2 && t2(e2[n2 - 1], r2) > 0; )
              e2[n2] = e2[--n2];
            n2 !== s2++ && (e2[n2] = r2);
          }
          return e2;
        }, ns = function(e2, t2, r2, n2) {
          for (var i2 = t2.length, s2 = r2.length, o2 = 0, a2 = 0; o2 < i2 || a2 < s2; )
            e2[o2 + a2] = o2 < i2 && a2 < s2 ? n2(t2[o2], r2[a2]) <= 0 ? t2[o2++] : r2[a2++] : o2 < i2 ? t2[o2++] : r2[a2++];
          return e2;
        }, is = ts, ss = P, os = Ce.match(/firefox\/(\d+)/i), as = !!os && +os[1], us = /MSIE|Trident/.test(Ce), cs = Ce.match(/AppleWebKit\/(\d+)\./), ls = !!cs && +cs[1], ps = si, hs = Y, Ds = Ue, fs = st, ds = Cn, gs = function(e2) {
          if (Ji(e2) === "Symbol")
            throw TypeError("Cannot convert a Symbol value to a string");
          return Zi(e2);
        }, ms = P, Es = is, Cs = function(e2, t2) {
          var r2 = [][e2];
          return !!r2 && ss(function() {
            r2.call(null, t2 || function() {
              throw 1;
            }, 1);
          });
        }, ys = as, bs = us, Ss = Ae, Ts = ls, _s = [], vs = hs(_s.sort), As = hs(_s.push), Fs = ms(function() {
          _s.sort(void 0);
        }), ws = ms(function() {
          _s.sort(null);
        }), ks = Cs("sort"), Ns = !ms(function() {
          if (Ss)
            return Ss < 70;
          if (!(ys && ys > 3)) {
            if (bs)
              return true;
            if (Ts)
              return Ts < 603;
            var e2, t2, r2, n2, i2 = "";
            for (e2 = 65; e2 < 76; e2++) {
              switch (t2 = String.fromCharCode(e2), e2) {
                case 66:
                case 69:
                case 70:
                case 72:
                  r2 = 3;
                  break;
                case 68:
                case 71:
                  r2 = 4;
                  break;
                default:
                  r2 = 2;
              }
              for (n2 = 0; n2 < 47; n2++)
                _s.push({ k: t2 + n2, v: r2 });
            }
            for (_s.sort(function(e3, t3) {
              return t3.v - e3.v;
            }), n2 = 0; n2 < _s.length; n2++)
              t2 = _s[n2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
            return i2 !== "DGBEFHACIJK";
          }
        });
        ps({ target: "Array", proto: true, forced: Fs || !ws || !ks || !Ns }, { sort: function(e2) {
          e2 !== void 0 && Ds(e2);
          var t2 = fs(this);
          if (Ns)
            return e2 === void 0 ? vs(t2) : vs(t2, e2);
          var r2, n2, i2 = [], s2 = ds(t2);
          for (n2 = 0; n2 < s2; n2++)
            n2 in t2 && As(i2, t2[n2]);
          for (Es(i2, function(e3) {
            return function(t3, r3) {
              return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, r3) || 0 : gs(t3) > gs(r3) ? 1 : -1;
            };
          }(e2)), r2 = i2.length, n2 = 0; n2 < r2; )
            t2[n2] = i2[n2++];
          for (; n2 < s2; )
            delete t2[n2++];
          return t2;
        } });
        var Os = {}, xs = Os, Is = _t("iterator"), Ps = Array.prototype, Rs = vi, Ls = Ve, Bs = Os, qs = _t("iterator"), $s = function(e2) {
          if (e2 != null)
            return Ls(e2, qs) || Ls(e2, "@@iterator") || Bs[Rs(e2)];
        }, Ms = B, js = Ue, Us = tr, Gs = qe, Vs = $s, Xs = x.TypeError, Hs = B, zs = tr, Ws = Ve, Ys = li, Qs = B, Js = tr, Zs = qe, Ks = function(e2) {
          return e2 !== void 0 && (xs.Array === e2 || Ps[Is] === e2);
        }, eo = Cn, to = Ee, ro = function(e2, t2) {
          var r2 = arguments.length < 2 ? Vs(e2) : t2;
          if (js(r2))
            return Us(Ms(r2, e2));
          throw Xs(Gs(e2) + " is not iterable");
        }, no = $s, io = function(e2, t2, r2) {
          var n2, i2;
          zs(e2);
          try {
            if (!(n2 = Ws(e2, "return"))) {
              if (t2 === "throw")
                throw r2;
              return r2;
            }
            n2 = Hs(n2, e2);
          } catch (e3) {
            i2 = true, n2 = e3;
          }
          if (t2 === "throw")
            throw r2;
          if (i2)
            throw n2;
          return zs(n2), r2;
        }, so = x.TypeError, oo = function(e2, t2) {
          this.stopped = e2, this.result = t2;
        }, ao = oo.prototype, uo = Rt, co = Qt, lo = V, po = function(e2, t2, r2) {
          var n2, i2, s2, o2, a2, u2, c2, l2 = r2 && r2.that, p2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), D2 = !(!r2 || !r2.INTERRUPTED), f2 = Ys(t2, l2), d2 = function(e3) {
            return n2 && io(n2, "normal", e3), new oo(true, e3);
          }, g2 = function(e3) {
            return p2 ? (Js(e3), D2 ? f2(e3[0], e3[1], d2) : f2(e3[0], e3[1])) : D2 ? f2(e3, d2) : f2(e3);
          };
          if (h2)
            n2 = e2;
          else {
            if (!(i2 = no(e2)))
              throw so(Zs(e2) + " is not iterable");
            if (Ks(i2)) {
              for (s2 = 0, o2 = eo(e2); o2 > s2; s2++)
                if ((a2 = g2(e2[s2])) && to(ao, a2))
                  return a2;
              return new oo(false);
            }
            n2 = ro(e2, i2);
          }
          for (u2 = n2.next; !(c2 = Qs(u2, n2)).done; ) {
            try {
              a2 = g2(c2.value);
            } catch (e3) {
              io(n2, "throw", e3);
            }
            if (typeof a2 == "object" && a2 && to(ao, a2))
              return a2;
          }
          return new oo(false);
        }, ho = function(e2, t2, r2) {
          var n2 = uo(t2);
          n2 in e2 ? co.f(e2, n2, lo(0, r2)) : e2[n2] = r2;
        };
        si({ target: "Object", stat: true }, { fromEntries: function(e2) {
          var t2 = {};
          return po(e2, function(e3, r2) {
            ho(t2, e3, r2);
          }, { AS_ENTRIES: true }), t2;
        } });
        var Do = Do !== void 0 ? Do : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
        function fo() {
          throw new Error("setTimeout has not been defined");
        }
        function go() {
          throw new Error("clearTimeout has not been defined");
        }
        var mo = fo, Eo = go;
        function Co(e2) {
          if (mo === setTimeout)
            return setTimeout(e2, 0);
          if ((mo === fo || !mo) && setTimeout)
            return mo = setTimeout, setTimeout(e2, 0);
          try {
            return mo(e2, 0);
          } catch (t2) {
            try {
              return mo.call(null, e2, 0);
            } catch (t3) {
              return mo.call(this, e2, 0);
            }
          }
        }
        typeof Do.setTimeout == "function" && (mo = setTimeout), typeof Do.clearTimeout == "function" && (Eo = clearTimeout);
        var yo, bo = [], So = false, To = -1;
        function _o() {
          So && yo && (So = false, yo.length ? bo = yo.concat(bo) : To = -1, bo.length && vo());
        }
        function vo() {
          if (!So) {
            var e2 = Co(_o);
            So = true;
            for (var t2 = bo.length; t2; ) {
              for (yo = bo, bo = []; ++To < t2; )
                yo && yo[To].run();
              To = -1, t2 = bo.length;
            }
            yo = null, So = false, function(e3) {
              if (Eo === clearTimeout)
                return clearTimeout(e3);
              if ((Eo === go || !Eo) && clearTimeout)
                return Eo = clearTimeout, clearTimeout(e3);
              try {
                Eo(e3);
              } catch (t3) {
                try {
                  return Eo.call(null, e3);
                } catch (t4) {
                  return Eo.call(this, e3);
                }
              }
            }(e2);
          }
        }
        function Ao(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        Ao.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        function Fo() {
        }
        var wo = Fo, ko = Fo, No = Fo, Oo = Fo, xo = Fo, Io = Fo, Po = Fo;
        var Ro = Do.performance || {}, Lo = Ro.now || Ro.mozNow || Ro.msNow || Ro.oNow || Ro.webkitNow || function() {
          return new Date().getTime();
        };
        var Bo = new Date();
        var qo = { nextTick: function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r2 = 1; r2 < arguments.length; r2++)
              t2[r2 - 1] = arguments[r2];
          bo.push(new Ao(e2, t2)), bo.length !== 1 || So || Co(vo);
        }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: wo, addListener: ko, once: No, off: Oo, removeListener: xo, removeAllListeners: Io, emit: Po, binding: function(e2) {
          throw new Error("process.binding is not supported");
        }, cwd: function() {
          return "/";
        }, chdir: function(e2) {
          throw new Error("process.chdir is not supported");
        }, umask: function() {
          return 0;
        }, hrtime: function(e2) {
          var t2 = 1e-3 * Lo.call(Ro), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
          return e2 && (r2 -= e2[0], (n2 -= e2[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
        }, platform: "browser", release: {}, config: {}, uptime: function() {
          return (new Date() - Bo) / 1e3;
        } }, $o = qo;
        const Mo = typeof $o == "object" && $o.env && $o.env.NODE_DEBUG && /\bsemver\b/i.test($o.env.NODE_DEBUG) ? function() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          return console.error("SEMVER", ...t2);
        } : () => {
        };
        var jo = Mo;
        var Uo = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, Go = { exports: {} };
        !function(e2, t2) {
          const { MAX_SAFE_COMPONENT_LENGTH: r2 } = Uo, n2 = jo, i2 = (t2 = e2.exports = {}).re = [], s2 = t2.src = [], o2 = t2.t = {};
          let a2 = 0;
          const u2 = (e3, t3, r3) => {
            const u3 = a2++;
            n2(u3, t3), o2[e3] = u3, s2[u3] = t3, i2[u3] = new RegExp(t3, r3 ? "g" : void 0);
          };
          u2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), u2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), u2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), u2("MAINVERSION", "(".concat(s2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(s2[o2.NUMERICIDENTIFIER], ")\\.") + "(".concat(s2[o2.NUMERICIDENTIFIER], ")")), u2("MAINVERSIONLOOSE", "(".concat(s2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s2[o2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s2[o2.NUMERICIDENTIFIERLOOSE], ")")), u2("PRERELEASEIDENTIFIER", "(?:".concat(s2[o2.NUMERICIDENTIFIER], "|").concat(s2[o2.NONNUMERICIDENTIFIER], ")")), u2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(s2[o2.NUMERICIDENTIFIERLOOSE], "|").concat(s2[o2.NONNUMERICIDENTIFIER], ")")), u2("PRERELEASE", "(?:-(".concat(s2[o2.PRERELEASEIDENTIFIER], "(?:\\.").concat(s2[o2.PRERELEASEIDENTIFIER], ")*))")), u2("PRERELEASELOOSE", "(?:-?(".concat(s2[o2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(s2[o2.PRERELEASEIDENTIFIERLOOSE], ")*))")), u2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), u2("BUILD", "(?:\\+(".concat(s2[o2.BUILDIDENTIFIER], "(?:\\.").concat(s2[o2.BUILDIDENTIFIER], ")*))")), u2("FULLPLAIN", "v?".concat(s2[o2.MAINVERSION]).concat(s2[o2.PRERELEASE], "?").concat(s2[o2.BUILD], "?")), u2("FULL", "^".concat(s2[o2.FULLPLAIN], "$")), u2("LOOSEPLAIN", "[v=\\s]*".concat(s2[o2.MAINVERSIONLOOSE]).concat(s2[o2.PRERELEASELOOSE], "?").concat(s2[o2.BUILD], "?")), u2("LOOSE", "^".concat(s2[o2.LOOSEPLAIN], "$")), u2("GTLT", "((?:<|>)?=?)"), u2("XRANGEIDENTIFIERLOOSE", "".concat(s2[o2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), u2("XRANGEIDENTIFIER", "".concat(s2[o2.NUMERICIDENTIFIER], "|x|X|\\*")), u2("XRANGEPLAIN", "[v=\\s]*(".concat(s2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s2[o2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s2[o2.XRANGEIDENTIFIER], ")") + "(?:".concat(s2[o2.PRERELEASE], ")?").concat(s2[o2.BUILD], "?") + ")?)?"), u2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(s2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s2[o2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(s2[o2.PRERELEASELOOSE], ")?").concat(s2[o2.BUILD], "?") + ")?)?"), u2("XRANGE", "^".concat(s2[o2.GTLT], "\\s*").concat(s2[o2.XRANGEPLAIN], "$")), u2("XRANGELOOSE", "^".concat(s2[o2.GTLT], "\\s*").concat(s2[o2.XRANGEPLAINLOOSE], "$")), u2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(r2, "})") + "(?:\\.(\\d{1,".concat(r2, "}))?") + "(?:\\.(\\d{1,".concat(r2, "}))?") + "(?:$|[^\\d])"), u2("COERCERTL", s2[o2.COERCE], true), u2("LONETILDE", "(?:~>?)"), u2("TILDETRIM", "(\\s*)".concat(s2[o2.LONETILDE], "\\s+"), true), t2.tildeTrimReplace = "$1~", u2("TILDE", "^".concat(s2[o2.LONETILDE]).concat(s2[o2.XRANGEPLAIN], "$")), u2("TILDELOOSE", "^".concat(s2[o2.LONETILDE]).concat(s2[o2.XRANGEPLAINLOOSE], "$")), u2("LONECARET", "(?:\\^)"), u2("CARETTRIM", "(\\s*)".concat(s2[o2.LONECARET], "\\s+"), true), t2.caretTrimReplace = "$1^", u2("CARET", "^".concat(s2[o2.LONECARET]).concat(s2[o2.XRANGEPLAIN], "$")), u2("CARETLOOSE", "^".concat(s2[o2.LONECARET]).concat(s2[o2.XRANGEPLAINLOOSE], "$")), u2("COMPARATORLOOSE", "^".concat(s2[o2.GTLT], "\\s*(").concat(s2[o2.LOOSEPLAIN], ")$|^$")), u2("COMPARATOR", "^".concat(s2[o2.GTLT], "\\s*(").concat(s2[o2.FULLPLAIN], ")$|^$")), u2("COMPARATORTRIM", "(\\s*)".concat(s2[o2.GTLT], "\\s*(").concat(s2[o2.LOOSEPLAIN], "|").concat(s2[o2.XRANGEPLAIN], ")"), true), t2.comparatorTrimReplace = "$1$2$3", u2("HYPHENRANGE", "^\\s*(".concat(s2[o2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(s2[o2.XRANGEPLAIN], ")") + "\\s*$"), u2("HYPHENRANGELOOSE", "^\\s*(".concat(s2[o2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(s2[o2.XRANGEPLAINLOOSE], ")") + "\\s*$"), u2("STAR", "(<|>)?=?\\s*\\*"), u2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), u2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        }(Go, Go.exports);
        const Vo = ["includePrerelease", "loose", "rtl"];
        var Xo = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : Vo.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
        const Ho = /^[0-9]+$/, zo = (e2, t2) => {
          const r2 = Ho.test(e2), n2 = Ho.test(t2);
          return r2 && n2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : r2 && !n2 ? -1 : n2 && !r2 ? 1 : e2 < t2 ? -1 : 1;
        };
        var Wo = { compareIdentifiers: zo, rcompareIdentifiers: (e2, t2) => zo(t2, e2) };
        const Yo = jo, { MAX_LENGTH: Qo, MAX_SAFE_INTEGER: Jo } = Uo, { re: Zo, t: Ko } = Go.exports, ea = Xo, { compareIdentifiers: ta } = Wo;
        class ra {
          constructor(e2, t2) {
            if (t2 = ea(t2), e2 instanceof ra) {
              if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
                return e2;
              e2 = e2.version;
            } else if (typeof e2 != "string")
              throw new TypeError("Invalid Version: ".concat(e2));
            if (e2.length > Qo)
              throw new TypeError("version is longer than ".concat(Qo, " characters"));
            Yo("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
            const r2 = e2.trim().match(t2.loose ? Zo[Ko.LOOSE] : Zo[Ko.FULL]);
            if (!r2)
              throw new TypeError("Invalid Version: ".concat(e2));
            if (this.raw = e2, this.major = +r2[1], this.minor = +r2[2], this.patch = +r2[3], this.major > Jo || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > Jo || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > Jo || this.patch < 0)
              throw new TypeError("Invalid patch version");
            r2[4] ? this.prerelease = r2[4].split(".").map((e3) => {
              if (/^[0-9]+$/.test(e3)) {
                const t3 = +e3;
                if (t3 >= 0 && t3 < Jo)
                  return t3;
              }
              return e3;
            }) : this.prerelease = [], this.build = r2[5] ? r2[5].split(".") : [], this.format();
          }
          format() {
            return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
          }
          toString() {
            return this.version;
          }
          compare(e2) {
            if (Yo("SemVer.compare", this.version, this.options, e2), !(e2 instanceof ra)) {
              if (typeof e2 == "string" && e2 === this.version)
                return 0;
              e2 = new ra(e2, this.options);
            }
            return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
          }
          compareMain(e2) {
            return e2 instanceof ra || (e2 = new ra(e2, this.options)), ta(this.major, e2.major) || ta(this.minor, e2.minor) || ta(this.patch, e2.patch);
          }
          comparePre(e2) {
            if (e2 instanceof ra || (e2 = new ra(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
              return -1;
            if (!this.prerelease.length && e2.prerelease.length)
              return 1;
            if (!this.prerelease.length && !e2.prerelease.length)
              return 0;
            let t2 = 0;
            do {
              const r2 = this.prerelease[t2], n2 = e2.prerelease[t2];
              if (Yo("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
                return 0;
              if (n2 === void 0)
                return 1;
              if (r2 === void 0)
                return -1;
              if (r2 !== n2)
                return ta(r2, n2);
            } while (++t2);
          }
          compareBuild(e2) {
            e2 instanceof ra || (e2 = new ra(e2, this.options));
            let t2 = 0;
            do {
              const r2 = this.build[t2], n2 = e2.build[t2];
              if (Yo("prerelease compare", t2, r2, n2), r2 === void 0 && n2 === void 0)
                return 0;
              if (n2 === void 0)
                return 1;
              if (r2 === void 0)
                return -1;
              if (r2 !== n2)
                return ta(r2, n2);
            } while (++t2);
          }
          inc(e2, t2) {
            switch (e2) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let e3 = this.prerelease.length;
                  for (; --e3 >= 0; )
                    typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
                  e3 === -1 && this.prerelease.push(0);
                }
                t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
                break;
              default:
                throw new Error("invalid increment argument: ".concat(e2));
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        const na = ra;
        var ia = (e2, t2, r2) => new na(e2, r2).compare(new na(t2, r2));
        const sa = ia;
        var oa = (e2, t2, r2) => sa(e2, t2, r2) < 0;
        const aa = ia;
        var ua, ca, la, pa, ha, Da, fa = (e2, t2, r2) => aa(e2, t2, r2) >= 0, da = { exports: {} };
        !function(e2, t2) {
          function r2() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
          }
          function n2() {
            return typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : { add: r2, delete: r2, get: r2, set: r2, has: function(e3) {
              return false;
            } };
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
          var i2 = Object.prototype.hasOwnProperty, s2 = function(e3, t3) {
            return i2.call(e3, t3);
          };
          function o2(e3, t3) {
            for (var r3 in t3)
              s2(t3, r3) && (e3[r3] = t3[r3]);
            return e3;
          }
          var a2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function h2(e3, t3, r3) {
            var n3 = 0, i3 = e3[0].match(l2);
            i3 && (n3 = i3[1].length);
            var s3 = new RegExp("(\\r\\n|\\r|\\n).{0," + n3 + "}", "g");
            t3 && (e3 = e3.slice(1));
            var o3 = r3.newline, c3 = r3.trimLeadingNewline, p3 = r3.trimTrailingNewline, h3 = typeof o3 == "string", D3 = e3.length;
            return e3.map(function(e4, t4) {
              return e4 = e4.replace(s3, "$1"), t4 === 0 && c3 && (e4 = e4.replace(a2, "")), t4 === D3 - 1 && p3 && (e4 = e4.replace(u2, "")), h3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
                return o3;
              })), e4;
            });
          }
          function D2(e3, t3) {
            for (var r3 = "", n3 = 0, i3 = e3.length; n3 < i3; n3++)
              r3 += e3[n3], n3 < i3 - 1 && (r3 += t3[n3]);
            return r3;
          }
          function f2(e3) {
            return s2(e3, "raw") && s2(e3, "length");
          }
          var d2 = function e3(t3) {
            var r3 = n2(), i3 = n2(), s3 = o2(function n3(s4) {
              for (var a3 = [], u3 = 1; u3 < arguments.length; u3++)
                a3[u3 - 1] = arguments[u3];
              if (f2(s4)) {
                var l3 = s4, g2 = (a3[0] === n3 || a3[0] === d2) && p2.test(l3[0]) && c2.test(l3[1]), m2 = g2 ? i3 : r3, E2 = m2.get(l3);
                if (E2 || (E2 = h2(l3, g2, t3), m2.set(l3, E2)), a3.length === 0)
                  return E2[0];
                var C2 = D2(E2, g2 ? a3.slice(1) : a3);
                return C2;
              }
              return e3(o2(o2({}, t3), s4 || {}));
            }, { string: function(e4) {
              return h2([e4], false, t3)[0];
            } });
            return s3;
          }({ trimLeadingNewline: true, trimTrailingNewline: true });
          t2.outdent = d2, t2.default = d2;
          try {
            e2.exports = d2, Object.defineProperty(d2, "__esModule", { value: true }), d2.default = d2, d2.outdent = d2;
          } catch (e3) {
          }
        }(da, da.exports);
        const { outdent: ga } = da.exports, ma = "Config", Ea = "Editor", Ca = "Other", ya = "Global", ba = "Special", Sa = { cursorOffset: { since: "1.4.0", category: ba, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: ga(ua || (ua = N(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))), cliCategory: Ea }, endOfLine: { since: "1.15.0", category: ya, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: ga(ca || (ca = N(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]))) }] }, filepath: { since: "1.4.0", category: ba, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: Ca, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: ba, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: Ca }, parser: { since: "0.0.10", category: ya, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: ya, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: ma }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: ya, description: ga(la || (la = N(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))), exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: ma }, printWidth: { since: "0.0.0", category: ya, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: ba, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: ga(pa || (pa = N(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ea }, rangeStart: { since: "1.4.0", category: ba, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: ga(ha || (ha = N(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))), cliCategory: Ea }, requirePragma: { since: "1.7.0", category: ba, type: "boolean", default: false, description: ga(Da || (Da = N(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))), cliCategory: Ca }, tabWidth: { type: "int", category: ya, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: ya, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: ya, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
        const Ta = ["cliName", "cliCategory", "cliDescription"], _a = { compare: ia, lt: oa, gte: fa }, va = (e2, t2) => Object.entries(e2).map((e3) => {
          let [r2, n2] = e3;
          return Object.assign({ [t2]: r2 }, n2);
        }), Aa = "2.5.1", Fa = { CATEGORY_CONFIG: ma, CATEGORY_EDITOR: Ea, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: Ca, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: ya, CATEGORY_SPECIAL: ba, options: Sa }.options;
        function wa(e2, t2, r2) {
          const n2 = new Set(e2.choices.map((e3) => e3.value));
          for (const i2 of t2)
            if (i2.parsers) {
              for (const t3 of i2.parsers)
                if (!n2.has(t3)) {
                  n2.add(t3);
                  const s2 = r2.find((e3) => e3.parsers && e3.parsers[t3]);
                  let o2 = i2.name;
                  s2 && s2.name && (o2 += " (plugin: ".concat(s2.name, ")")), e2.choices.push({ value: t3, description: o2 });
                }
            }
        }
        var ka = { getSupportInfo: function() {
          let { plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: r2 = false, showInternal: n2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const i2 = Aa.split("-", 1)[0], s2 = e2.flatMap((e3) => e3.languages || []).filter(a2), o2 = va(Object.assign({}, ...e2.map((e3) => {
            let { options: t3 } = e3;
            return t3;
          }), Fa), "name").filter((e3) => a2(e3) && u2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(c2).map((t3) => {
            t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(a2).sort((e3, t4) => _a.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => a2(e3) && u2(e3)), t3.name === "parser" && wa(t3, s2, e2));
            const r3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
            return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: r3 });
          });
          return { languages: s2, options: o2 };
          function a2(e3) {
            return t2 || !("since" in e3) || e3.since && _a.gte(i2, e3.since);
          }
          function u2(e3) {
            return r2 || !("deprecated" in e3) || e3.deprecated && _a.lt(i2, e3.deprecated);
          }
          function c2(e3) {
            if (n2)
              return e3;
            return k(e3, Ta);
          }
        } };
        const Na = b.exports, Oa = (e2) => {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }, xa = C, { getSupportInfo: Ia } = ka, Pa = /[^\x20-\x7F]/;
        function Ra(e2) {
          return (t2, r2, n2) => {
            const i2 = n2 && n2.backwards;
            if (r2 === false)
              return false;
            const { length: s2 } = t2;
            let o2 = r2;
            for (; o2 >= 0 && o2 < s2; ) {
              const r3 = t2.charAt(o2);
              if (e2 instanceof RegExp) {
                if (!e2.test(r3))
                  return o2;
              } else if (!e2.includes(r3))
                return o2;
              i2 ? o2-- : o2++;
            }
            return (o2 === -1 || o2 === s2) && o2;
          };
        }
        const La = Ra(/\s/), Ba = Ra(" 	"), qa = Ra(",; 	"), $a = Ra(/[^\n\r]/);
        function Ma(e2, t2) {
          if (t2 === false)
            return false;
          if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
            for (let r2 = t2 + 2; r2 < e2.length; ++r2)
              if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
                return r2 + 2;
          }
          return t2;
        }
        function ja(e2, t2) {
          return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? $a(e2, t2) : t2);
        }
        function Ua(e2, t2, r2) {
          const n2 = r2 && r2.backwards;
          if (t2 === false)
            return false;
          const i2 = e2.charAt(t2);
          if (n2) {
            if (e2.charAt(t2 - 1) === "\r" && i2 === "\n")
              return t2 - 2;
            if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
              return t2 - 1;
          } else {
            if (i2 === "\r" && e2.charAt(t2 + 1) === "\n")
              return t2 + 2;
            if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
              return t2 + 1;
          }
          return t2;
        }
        function Ga(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const n2 = Ba(e2, r2.backwards ? t2 - 1 : t2, r2), i2 = Ua(e2, n2, r2);
          return n2 !== i2;
        }
        function Va(e2, t2) {
          let r2 = null, n2 = t2;
          for (; n2 !== r2; )
            r2 = n2, n2 = qa(e2, n2), n2 = Ma(e2, n2), n2 = Ba(e2, n2);
          return n2 = ja(e2, n2), n2 = Ua(e2, n2), n2 !== false && Ga(e2, n2);
        }
        function Xa(e2, t2) {
          let r2 = null, n2 = t2;
          for (; n2 !== r2; )
            r2 = n2, n2 = Ba(e2, n2), n2 = Ma(e2, n2), n2 = ja(e2, n2), n2 = Ua(e2, n2);
          return n2;
        }
        function Ha(e2, t2, r2) {
          return Xa(e2, r2(t2));
        }
        function za(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n2 = 0;
          for (let i2 = r2; i2 < e2.length; ++i2)
            e2[i2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
          return n2;
        }
        function Wa(e2, t2) {
          const r2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, n2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, i2 = t2 === "'" ? n2 : r2, s2 = i2 === n2 ? r2 : n2;
          let o2 = i2;
          if (e2.includes(i2.quote) || e2.includes(s2.quote)) {
            o2 = (e2.match(i2.regex) || []).length > (e2.match(s2.regex) || []).length ? s2 : i2;
          }
          return o2;
        }
        function Ya(e2, t2, r2) {
          const n2 = t2 === '"' ? "'" : '"', i2 = e2.replace(/\\(.)|(["'])/gs, (e3, i3, s2) => i3 === n2 ? i3 : s2 === t2 ? "\\" + s2 : s2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
          return t2 + i2 + t2;
        }
        function Qa(e2, t2) {
          (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
            const t3 = e3.type || e3.kind || "(unknown type)";
            let r2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
            r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026");
            return t3 + (r2 ? " " + r2 : "");
          }(e2);
        }
        var Ja = { inferParserByLanguage: function(e2, t2) {
          const { languages: r2 } = Ia({ plugins: t2.plugins }), n2 = r2.find((t3) => {
            let { name: r3 } = t3;
            return r3.toLowerCase() === e2;
          }) || r2.find((t3) => {
            let { aliases: r3 } = t3;
            return Array.isArray(r3) && r3.includes(e2);
          }) || r2.find((t3) => {
            let { extensions: r3 } = t3;
            return Array.isArray(r3) && r3.includes(".".concat(e2));
          });
          return n2 && n2.parsers[0];
        }, getStringWidth: function(e2) {
          return e2 ? Pa.test(e2) ? Na(e2) : e2.length : 0;
        }, getMaxContinuousCount: function(e2, t2) {
          const r2 = e2.match(new RegExp("(".concat(Oa(t2), ")+"), "g"));
          return r2 === null ? 0 : r2.reduce((e3, r3) => Math.max(e3, r3.length / t2.length), 0);
        }, getMinNotPresentContinuousCount: function(e2, t2) {
          const r2 = e2.match(new RegExp("(".concat(Oa(t2), ")+"), "g"));
          if (r2 === null)
            return 0;
          const n2 = /* @__PURE__ */ new Map();
          let i2 = 0;
          for (const e3 of r2) {
            const r3 = e3.length / t2.length;
            n2.set(r3, true), r3 > i2 && (i2 = r3);
          }
          for (let e3 = 1; e3 < i2; e3++)
            if (!n2.get(e3))
              return e3;
          return i2 + 1;
        }, getPenultimate: (e2) => e2[e2.length - 2], getLast: xa, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Xa, getNextNonSpaceNonCommentCharacterIndex: Ha, getNextNonSpaceNonCommentCharacter: function(e2, t2, r2) {
          return e2.charAt(Ha(e2, t2, r2));
        }, skip: Ra, skipWhitespace: La, skipSpaces: Ba, skipToLineEnd: qa, skipEverythingButNewLine: $a, skipInlineComment: Ma, skipTrailingComment: ja, skipNewline: Ua, isNextLineEmptyAfterIndex: Va, isNextLineEmpty: function(e2, t2, r2) {
          return Va(e2, r2(t2));
        }, isPreviousLineEmpty: function(e2, t2, r2) {
          let n2 = r2(t2) - 1;
          return n2 = Ba(e2, n2, { backwards: true }), n2 = Ua(e2, n2, { backwards: true }), n2 = Ba(e2, n2, { backwards: true }), n2 !== Ua(e2, n2, { backwards: true });
        }, hasNewline: Ga, hasNewlineInRange: function(e2, t2, r2) {
          for (let n2 = t2; n2 < r2; ++n2)
            if (e2.charAt(n2) === "\n")
              return true;
          return false;
        }, hasSpaces: function(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const n2 = Ba(e2, r2.backwards ? t2 - 1 : t2, r2);
          return n2 !== t2;
        }, getAlignmentSize: za, getIndentSize: function(e2, t2) {
          const r2 = e2.lastIndexOf("\n");
          return r2 === -1 ? 0 : za(e2.slice(r2 + 1).match(/^[\t ]*/)[0], t2);
        }, getPreferredQuote: Wa, printString: function(e2, t2) {
          const r2 = e2.slice(1, -1);
          return Ya(r2, t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Wa(r2, t2.singleQuote ? "'" : '"').quote, !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
        }, printNumber: function(e2) {
          return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        }, makeString: Ya, addLeadingComment: function(e2, t2) {
          t2.leading = true, t2.trailing = false, Qa(e2, t2);
        }, addDanglingComment: function(e2, t2, r2) {
          t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Qa(e2, t2);
        }, addTrailingComment: function(e2, t2) {
          t2.leading = false, t2.trailing = true, Qa(e2, t2);
        }, isFrontMatterNode: function(e2) {
          return e2 && e2.type === "front-matter";
        }, getShebang: function(e2) {
          if (!e2.startsWith("#!"))
            return "";
          const t2 = e2.indexOf("\n");
          return t2 === -1 ? e2 : e2.slice(0, t2);
        }, isNonEmptyArray: function(e2) {
          return Array.isArray(e2) && e2.length > 0;
        }, createGroupIdMapper: function(e2) {
          const t2 = /* @__PURE__ */ new WeakMap();
          return function(r2) {
            return t2.has(r2) || t2.set(r2, Symbol(e2)), t2.get(r2);
          };
        } }, Za = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] };
        function Ka(e2) {
          return { type: "concat", parts: e2 };
        }
        function eu(e2) {
          return { type: "indent", contents: e2 };
        }
        function tu(e2, t2) {
          return { type: "align", contents: t2, n: e2 };
        }
        function ru(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return { type: "group", id: t2.id, contents: e2, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates };
        }
        const nu = { type: "break-parent" }, iu = { type: "line", hard: true }, su = { type: "line", hard: true, literal: true }, ou = Ka([iu, nu]), au = Ka([su, nu]);
        var uu = { concat: Ka, join: function(e2, t2) {
          const r2 = [];
          for (let n2 = 0; n2 < t2.length; n2++)
            n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
          return Ka(r2);
        }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: ou, literalline: au, group: ru, conditionalGroup: function(e2, t2) {
          return ru(e2[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e2 }));
        }, fill: function(e2) {
          return { type: "fill", parts: e2 };
        }, lineSuffix: function(e2) {
          return { type: "line-suffix", contents: e2 };
        }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: nu, ifBreak: function(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return { type: "if-break", breakContents: e2, flatContents: t2, groupId: r2.groupId };
        }, trim: { type: "trim" }, indent: eu, indentIfBreak: function(e2, t2) {
          return { type: "indent-if-break", contents: e2, groupId: t2.groupId, negate: t2.negate };
        }, align: tu, addAlignmentToDoc: function(e2, t2, r2) {
          let n2 = e2;
          if (t2 > 0) {
            for (let e3 = 0; e3 < Math.floor(t2 / r2); ++e3)
              n2 = eu(n2);
            n2 = tu(t2 % r2, n2), n2 = tu(Number.NEGATIVE_INFINITY, n2);
          }
          return n2;
        }, markAsRoot: function(e2) {
          return tu({ type: "root" }, e2);
        }, dedentToRoot: function(e2) {
          return tu(Number.NEGATIVE_INFINITY, e2);
        }, dedent: function(e2) {
          return tu(-1, e2);
        }, hardlineWithoutBreakParent: iu, literallineWithoutBreakParent: su, label: function(e2, t2) {
          return { type: "label", label: e2, contents: t2 };
        } };
        var cu = { guessEndOfLine: function(e2) {
          const t2 = e2.indexOf("\r");
          return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
        }, convertEndOfLineToChars: function(e2) {
          switch (e2) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        }, countEndOfLineChars: function(e2, t2) {
          let r2;
          if (t2 === "\n")
            r2 = /\n/g;
          else if (t2 === "\r")
            r2 = /\r/g;
          else {
            if (t2 !== "\r\n")
              throw new Error('Unexpected "eol" '.concat(JSON.stringify(t2), "."));
            r2 = /\r\n/g;
          }
          const n2 = e2.match(r2);
          return n2 ? n2.length : 0;
        }, normalizeEndOfLine: function(e2) {
          return e2.replace(/\r\n?/g, "\n");
        } };
        const lu = C, { literalline: pu, join: hu } = uu, Du = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", fu = (e2) => {
          if (Array.isArray(e2))
            return e2;
          if (e2.type !== "concat" && e2.type !== "fill")
            throw new Error("Expect doc type to be `concat` or `fill`.");
          return e2.parts;
        }, du = {};
        function gu(e2, t2, r2, n2) {
          const i2 = [e2];
          for (; i2.length > 0; ) {
            const e3 = i2.pop();
            if (e3 !== du) {
              if (r2 && i2.push(e3, du), !t2 || t2(e3) !== false)
                if (Du(e3) || e3.type === "fill") {
                  const t3 = fu(e3);
                  for (let e4 = t3.length - 1; e4 >= 0; --e4)
                    i2.push(t3[e4]);
                } else if (e3.type === "if-break")
                  e3.flatContents && i2.push(e3.flatContents), e3.breakContents && i2.push(e3.breakContents);
                else if (e3.type === "group" && e3.expandedStates)
                  if (n2)
                    for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                      i2.push(e3.expandedStates[t3]);
                  else
                    i2.push(e3.contents);
                else
                  e3.contents && i2.push(e3.contents);
            } else
              r2(i2.pop());
          }
        }
        function mu(e2, t2) {
          const r2 = /* @__PURE__ */ new Map();
          return n2(e2);
          function n2(e3) {
            if (r2.has(e3))
              return r2.get(e3);
            const i2 = function(e4) {
              if (Array.isArray(e4))
                return t2(e4.map(n2));
              if (e4.type === "concat" || e4.type === "fill") {
                const r3 = e4.parts.map(n2);
                return t2(Object.assign(Object.assign({}, e4), {}, { parts: r3 }));
              }
              if (e4.type === "if-break") {
                const r3 = e4.breakContents && n2(e4.breakContents), i3 = e4.flatContents && n2(e4.flatContents);
                return t2(Object.assign(Object.assign({}, e4), {}, { breakContents: r3, flatContents: i3 }));
              }
              if (e4.type === "group" && e4.expandedStates) {
                const r3 = e4.expandedStates.map(n2), i3 = r3[0];
                return t2(Object.assign(Object.assign({}, e4), {}, { contents: i3, expandedStates: r3 }));
              }
              if (e4.contents) {
                const r3 = n2(e4.contents);
                return t2(Object.assign(Object.assign({}, e4), {}, { contents: r3 }));
              }
              return t2(e4);
            }(e3);
            return r2.set(e3, i2), i2;
          }
        }
        function Eu(e2, t2, r2) {
          let n2 = r2, i2 = false;
          return gu(e2, function(e3) {
            const r3 = t2(e3);
            if (r3 !== void 0 && (i2 = true, n2 = r3), i2)
              return false;
          }), n2;
        }
        function Cu(e2) {
          return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
        }
        function yu(e2) {
          if (e2.length > 0) {
            const t2 = lu(e2);
            t2.expandedStates || t2.break || (t2.break = "propagated");
          }
          return null;
        }
        function bu(e2) {
          return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
        }
        const Su = (e2, t2) => e2 && e2.type === "line" && e2.hard && t2 && t2.type === "break-parent";
        function Tu(e2) {
          if (!e2)
            return e2;
          if (Du(e2) || e2.type === "fill") {
            const t2 = fu(e2);
            for (; t2.length > 1 && Su(...t2.slice(-2)); )
              t2.length -= 2;
            if (t2.length > 0) {
              const e3 = Tu(lu(t2));
              t2[t2.length - 1] = e3;
            }
            return Array.isArray(e2) ? t2 : Object.assign(Object.assign({}, e2), {}, { parts: t2 });
          }
          switch (e2.type) {
            case "align":
            case "indent":
            case "indent-if-break":
            case "group":
            case "line-suffix":
            case "label": {
              const t2 = Tu(e2.contents);
              return Object.assign(Object.assign({}, e2), {}, { contents: t2 });
            }
            case "if-break": {
              const t2 = Tu(e2.breakContents), r2 = Tu(e2.flatContents);
              return Object.assign(Object.assign({}, e2), {}, { breakContents: t2, flatContents: r2 });
            }
          }
          return e2;
        }
        function _u(e2) {
          return mu(e2, (e3) => function(e4) {
            switch (e4.type) {
              case "fill":
                if (e4.parts.every((e5) => e5 === ""))
                  return "";
                break;
              case "group":
                if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
                  return "";
                if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
                  return e4.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!e4.contents)
                  return "";
                break;
              case "if-break":
                if (!e4.flatContents && !e4.breakContents)
                  return "";
            }
            if (!Du(e4))
              return e4;
            const t2 = [];
            for (const r2 of fu(e4)) {
              if (!r2)
                continue;
              const [e5, ...n2] = Du(r2) ? fu(r2) : [r2];
              typeof e5 == "string" && typeof lu(t2) == "string" ? t2[t2.length - 1] += e5 : t2.push(e5), t2.push(...n2);
            }
            return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e4) ? t2 : Object.assign(Object.assign({}, e4), {}, { parts: t2 });
          }(e3));
        }
        function vu(e2) {
          const t2 = [], r2 = e2.filter(Boolean);
          for (; r2.length > 0; ) {
            const e3 = r2.shift();
            e3 && (Du(e3) ? r2.unshift(...fu(e3)) : t2.length > 0 && typeof lu(t2) == "string" && typeof e3 == "string" ? t2[t2.length - 1] += e3 : t2.push(e3));
          }
          return t2;
        }
        function Au(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pu;
          return hu(t2, e2.split("\n")).parts;
        }
        function Fu(e2) {
          if (e2.type === "line")
            return true;
        }
        var wu = { isConcat: Du, getDocParts: fu, willBreak: function(e2) {
          return Eu(e2, Cu, false);
        }, traverseDoc: gu, findInDoc: Eu, mapDoc: mu, propagateBreaks: function(e2) {
          const t2 = /* @__PURE__ */ new Set(), r2 = [];
          gu(e2, function(e3) {
            if (e3.type === "break-parent" && yu(r2), e3.type === "group") {
              if (r2.push(e3), t2.has(e3))
                return false;
              t2.add(e3);
            }
          }, function(e3) {
            if (e3.type === "group") {
              r2.pop().break && yu(r2);
            }
          }, true);
        }, removeLines: function(e2) {
          return mu(e2, bu);
        }, stripTrailingHardline: function(e2) {
          return Tu(_u(e2));
        }, normalizeParts: vu, normalizeDoc: function(e2) {
          return mu(e2, (e3) => Array.isArray(e3) ? vu(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: vu(e3.parts) }) : e3);
        }, cleanDoc: _u, replaceTextEndOfLine: Au, replaceEndOfLine: function(e2) {
          return mu(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? Au(e3) : e3);
        }, canBreak: function(e2) {
          return Eu(e2, Fu, false);
        } };
        const { getStringWidth: ku, getLast: Nu } = Ja, { convertEndOfLineToChars: Ou } = cu, { fill: xu, cursor: Iu, indent: Pu } = uu, { isConcat: Ru, getDocParts: Lu } = wu;
        let Bu;
        function qu(e2, t2) {
          return Mu(e2, { type: "indent" }, t2);
        }
        function $u(e2, t2, r2) {
          if (t2 === Number.NEGATIVE_INFINITY)
            return e2.root || { value: "", length: 0, queue: [] };
          if (t2 < 0)
            return Mu(e2, { type: "dedent" }, r2);
          if (!t2)
            return e2;
          if (t2.type === "root")
            return Object.assign(Object.assign({}, e2), {}, { root: e2 });
          return Mu(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2);
        }
        function Mu(e2, t2, r2) {
          const n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2];
          let i2 = "", s2 = 0, o2 = 0, a2 = 0;
          for (const e3 of n2)
            switch (e3.type) {
              case "indent":
                l2(), r2.useTabs ? u2(1) : c2(r2.tabWidth);
                break;
              case "stringAlign":
                l2(), i2 += e3.n, s2 += e3.n.length;
                break;
              case "numberAlign":
                o2 += 1, a2 += e3.n;
                break;
              default:
                throw new Error("Unexpected type '".concat(e3.type, "'"));
            }
          return p2(), Object.assign(Object.assign({}, e2), {}, { value: i2, length: s2, queue: n2 });
          function u2(e3) {
            i2 += "	".repeat(e3), s2 += r2.tabWidth * e3;
          }
          function c2(e3) {
            i2 += " ".repeat(e3), s2 += e3;
          }
          function l2() {
            r2.useTabs ? function() {
              o2 > 0 && u2(o2);
              h2();
            }() : p2();
          }
          function p2() {
            a2 > 0 && c2(a2), h2();
          }
          function h2() {
            o2 = 0, a2 = 0;
          }
        }
        function ju(e2) {
          if (e2.length === 0)
            return 0;
          let t2 = 0;
          for (; e2.length > 0 && typeof Nu(e2) == "string" && /^[\t ]*$/.test(Nu(e2)); )
            t2 += e2.pop().length;
          if (e2.length > 0 && typeof Nu(e2) == "string") {
            const r2 = Nu(e2).replace(/[\t ]*$/, "");
            t2 += Nu(e2).length - r2.length, e2[e2.length - 1] = r2;
          }
          return t2;
        }
        function Uu(e2, t2, r2, n2, i2, s2) {
          let o2 = t2.length;
          const a2 = [e2], u2 = [];
          for (; r2 >= 0; ) {
            if (a2.length === 0) {
              if (o2 === 0)
                return true;
              a2.push(t2[o2 - 1]), o2--;
              continue;
            }
            const [e3, c2, l2] = a2.pop();
            if (typeof l2 == "string")
              u2.push(l2), r2 -= ku(l2);
            else if (Ru(l2)) {
              const t3 = Lu(l2);
              for (let r3 = t3.length - 1; r3 >= 0; r3--)
                a2.push([e3, c2, t3[r3]]);
            } else
              switch (l2.type) {
                case "indent":
                  a2.push([qu(e3, n2), c2, l2.contents]);
                  break;
                case "align":
                  a2.push([$u(e3, l2.n, n2), c2, l2.contents]);
                  break;
                case "trim":
                  r2 += ju(u2);
                  break;
                case "group": {
                  if (s2 && l2.break)
                    return false;
                  const t3 = l2.break ? 1 : c2;
                  a2.push([e3, t3, l2.expandedStates && t3 === 1 ? Nu(l2.expandedStates) : l2.contents]), l2.id && (Bu[l2.id] = t3);
                  break;
                }
                case "fill":
                  for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
                    a2.push([e3, c2, l2.parts[t3]]);
                  break;
                case "if-break":
                case "indent-if-break": {
                  const t3 = l2.groupId ? Bu[l2.groupId] : c2;
                  if (t3 === 1) {
                    const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Pu(l2.contents);
                    t4 && a2.push([e3, c2, t4]);
                  }
                  if (t3 === 2) {
                    const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Pu(l2.contents) : l2.contents;
                    t4 && a2.push([e3, c2, t4]);
                  }
                  break;
                }
                case "line":
                  switch (c2) {
                    case 2:
                      if (!l2.hard) {
                        l2.soft || (u2.push(" "), r2 -= 1);
                        break;
                      }
                      return true;
                    case 1:
                      return true;
                  }
                  break;
                case "line-suffix":
                  i2 = true;
                  break;
                case "line-suffix-boundary":
                  if (i2)
                    return false;
                  break;
                case "label":
                  a2.push([e3, c2, l2.contents]);
              }
          }
          return false;
        }
        var Gu = { printDocToString: function(e2, t2) {
          Bu = {};
          const r2 = t2.printWidth, n2 = Ou(t2.endOfLine);
          let i2 = 0;
          const s2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], o2 = [];
          let a2 = false, u2 = [];
          for (; s2.length > 0; ) {
            const [e3, c3, l2] = s2.pop();
            if (typeof l2 == "string") {
              const e4 = n2 !== "\n" ? l2.replace(/\n/g, n2) : l2;
              o2.push(e4), i2 += ku(e4);
            } else if (Ru(l2)) {
              const t3 = Lu(l2);
              for (let r3 = t3.length - 1; r3 >= 0; r3--)
                s2.push([e3, c3, t3[r3]]);
            } else
              switch (l2.type) {
                case "cursor":
                  o2.push(Iu.placeholder);
                  break;
                case "indent":
                  s2.push([qu(e3, t2), c3, l2.contents]);
                  break;
                case "align":
                  s2.push([$u(e3, l2.n, t2), c3, l2.contents]);
                  break;
                case "trim":
                  i2 -= ju(o2);
                  break;
                case "group":
                  switch (c3) {
                    case 2:
                      if (!a2) {
                        s2.push([e3, l2.break ? 1 : 2, l2.contents]);
                        break;
                      }
                    case 1: {
                      a2 = false;
                      const n3 = [e3, 2, l2.contents], o3 = r2 - i2, c4 = u2.length > 0;
                      if (!l2.break && Uu(n3, s2, o3, t2, c4))
                        s2.push(n3);
                      else if (l2.expandedStates) {
                        const r3 = Nu(l2.expandedStates);
                        if (l2.break) {
                          s2.push([e3, 1, r3]);
                          break;
                        }
                        for (let n4 = 1; n4 < l2.expandedStates.length + 1; n4++) {
                          if (n4 >= l2.expandedStates.length) {
                            s2.push([e3, 1, r3]);
                            break;
                          }
                          {
                            const r4 = [e3, 2, l2.expandedStates[n4]];
                            if (Uu(r4, s2, o3, t2, c4)) {
                              s2.push(r4);
                              break;
                            }
                          }
                        }
                      } else
                        s2.push([e3, 1, l2.contents]);
                      break;
                    }
                  }
                  l2.id && (Bu[l2.id] = Nu(s2)[1]);
                  break;
                case "fill": {
                  const n3 = r2 - i2, { parts: o3 } = l2;
                  if (o3.length === 0)
                    break;
                  const [a3, p2] = o3, h2 = [e3, 2, a3], D2 = [e3, 1, a3], f2 = Uu(h2, [], n3, t2, u2.length > 0, true);
                  if (o3.length === 1) {
                    f2 ? s2.push(h2) : s2.push(D2);
                    break;
                  }
                  const d2 = [e3, 2, p2], g2 = [e3, 1, p2];
                  if (o3.length === 2) {
                    f2 ? s2.push(d2, h2) : s2.push(g2, D2);
                    break;
                  }
                  o3.splice(0, 2);
                  const m2 = [e3, c3, xu(o3)];
                  Uu([e3, 2, [a3, p2, o3[0]]], [], n3, t2, u2.length > 0, true) ? s2.push(m2, d2, h2) : f2 ? s2.push(m2, g2, h2) : s2.push(m2, g2, D2);
                  break;
                }
                case "if-break":
                case "indent-if-break": {
                  const t3 = l2.groupId ? Bu[l2.groupId] : c3;
                  if (t3 === 1) {
                    const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Pu(l2.contents);
                    t4 && s2.push([e3, c3, t4]);
                  }
                  if (t3 === 2) {
                    const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Pu(l2.contents) : l2.contents;
                    t4 && s2.push([e3, c3, t4]);
                  }
                  break;
                }
                case "line-suffix":
                  u2.push([e3, c3, l2.contents]);
                  break;
                case "line-suffix-boundary":
                  u2.length > 0 && s2.push([e3, c3, { type: "line", hard: true }]);
                  break;
                case "line":
                  switch (c3) {
                    case 2:
                      if (!l2.hard) {
                        l2.soft || (o2.push(" "), i2 += 1);
                        break;
                      }
                      a2 = true;
                    case 1:
                      if (u2.length > 0) {
                        s2.push([e3, c3, l2], ...u2.reverse()), u2 = [];
                        break;
                      }
                      l2.literal ? e3.root ? (o2.push(n2, e3.root.value), i2 = e3.root.length) : (o2.push(n2), i2 = 0) : (i2 -= ju(o2), o2.push(n2 + e3.value), i2 = e3.length);
                  }
                  break;
                case "label":
                  s2.push([e3, c3, l2.contents]);
              }
            s2.length === 0 && u2.length > 0 && (s2.push(...u2.reverse()), u2 = []);
          }
          const c2 = o2.indexOf(Iu.placeholder);
          if (c2 !== -1) {
            const e3 = o2.indexOf(Iu.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), r3 = o2.slice(c2 + 1, e3).join("");
            return { formatted: t3 + r3 + o2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: r3 };
          }
          return { formatted: o2.join("") };
        } };
        const { isConcat: Vu, getDocParts: Xu } = wu;
        function Hu(e2) {
          if (!e2)
            return "";
          if (Vu(e2)) {
            const t2 = [];
            for (const r2 of Xu(e2))
              if (Vu(r2))
                t2.push(...Hu(r2).parts);
              else {
                const e3 = Hu(r2);
                e3 !== "" && t2.push(e3);
              }
            return { type: "concat", parts: t2 };
          }
          return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: Hu(e2.breakContents), flatContents: Hu(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: Hu(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(Hu) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(Hu) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: Hu(e2.contents) }) : e2;
        }
        var zu = { printDocToDebug: function(e2) {
          const t2 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Set();
          return function e3(t3, r3, i2) {
            if (typeof t3 == "string")
              return JSON.stringify(t3);
            if (Vu(t3)) {
              const r4 = Xu(t3).map(e3).filter(Boolean);
              return r4.length === 1 ? r4[0] : "[".concat(r4.join(", "), "]");
            }
            if (t3.type === "line") {
              const e4 = Array.isArray(i2) && i2[r3 + 1] && i2[r3 + 1].type === "break-parent";
              return t3.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
            }
            if (t3.type === "break-parent") {
              return Array.isArray(i2) && i2[r3 - 1] && i2[r3 - 1].type === "line" && i2[r3 - 1].hard ? void 0 : "breakParent";
            }
            if (t3.type === "trim")
              return "trim";
            if (t3.type === "indent")
              return "indent(" + e3(t3.contents) + ")";
            if (t3.type === "align")
              return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e3(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e3(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e3(t3.contents) + ")";
            if (t3.type === "if-break")
              return "ifBreak(" + e3(t3.breakContents) + (t3.flatContents ? ", " + e3(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + ", { groupId: ".concat(n2(t3.groupId), " }") : "") + ")";
            if (t3.type === "indent-if-break") {
              const r4 = [];
              t3.negate && r4.push("negate: true"), t3.groupId && r4.push("groupId: ".concat(n2(t3.groupId)));
              const i3 = r4.length > 0 ? ", { ".concat(r4.join(", "), " }") : "";
              return "indentIfBreak(".concat(e3(t3.contents)).concat(i3, ")");
            }
            if (t3.type === "group") {
              const r4 = [];
              t3.break && t3.break !== "propagated" && r4.push("shouldBreak: true"), t3.id && r4.push("id: ".concat(n2(t3.id)));
              const i3 = r4.length > 0 ? ", { ".concat(r4.join(", "), " }") : "";
              return t3.expandedStates ? "conditionalGroup([".concat(t3.expandedStates.map((t4) => e3(t4)).join(","), "]").concat(i3, ")") : "group(".concat(e3(t3.contents)).concat(i3, ")");
            }
            if (t3.type === "fill")
              return "fill([".concat(t3.parts.map((t4) => e3(t4)).join(", "), "])");
            if (t3.type === "line-suffix")
              return "lineSuffix(" + e3(t3.contents) + ")";
            if (t3.type === "line-suffix-boundary")
              return "lineSuffixBoundary";
            if (t3.type === "label")
              return "label(".concat(JSON.stringify(t3.label), ", ").concat(e3(t3.contents), ")");
            throw new Error("Unknown doc type " + t3.type);
          }(Hu(e2));
          function n2(e3) {
            if (typeof e3 != "symbol")
              return JSON.stringify(String(e3));
            if (e3 in t2)
              return t2[e3];
            const n3 = String(e3).slice(7, -1) || "symbol";
            for (let i2 = 0; ; i2++) {
              const s2 = n3 + (i2 > 0 ? " #".concat(i2) : "");
              if (!r2.has(s2))
                return r2.add(s2), t2[e3] = "Symbol.for(".concat(JSON.stringify(s2), ")");
            }
          }
        } }, Wu = { builders: uu, printer: Gu, utils: wu, debug: zu };
        const Yu = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"], Qu = Za, { inferParserByLanguage: Ju, isFrontMatterNode: Zu } = Ja, { builders: { line: Ku, hardline: ec, join: tc }, utils: { getDocParts: rc, replaceTextEndOfLine: nc } } = Wu, { CSS_DISPLAY_TAGS: ic, CSS_DISPLAY_DEFAULT: sc, CSS_WHITE_SPACE_TAGS: oc, CSS_WHITE_SPACE_DEFAULT: ac } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, uc = fc(Yu), cc = function(e2, t2) {
          const r2 = /* @__PURE__ */ Object.create(null);
          for (const [n2, i2] of Object.entries(e2))
            r2[n2] = t2(i2, n2);
          return r2;
        }(Qu, fc), lc = /* @__PURE__ */ new Set(["	", "\n", "\f", "\r", " "]), pc = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), hc = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(pc(e2)), Dc = (e2) => e2.split(/[\t\n\f\r ]+/);
        function fc(e2) {
          const t2 = /* @__PURE__ */ Object.create(null);
          for (const r2 of e2)
            t2[r2] = true;
          return t2;
        }
        function dc(e2) {
          return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || Ac(e2) && (e2.name === "script" || e2.name === "style"));
        }
        function gc(e2) {
          return Fc(e2).startsWith("pre");
        }
        function mc(e2) {
          return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
        }
        function Ec(e2) {
          return Sc(e2) || e2.type === "element" && e2.fullName === "br" || Cc(e2);
        }
        function Cc(e2) {
          return yc(e2) && bc(e2);
        }
        function yc(e2) {
          return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
        }
        function bc(e2) {
          return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
        }
        function Sc(e2) {
          switch (e2.type) {
            case "ieConditionalComment":
            case "comment":
            case "directive":
              return true;
            case "element":
              return ["script", "select"].includes(e2.name);
          }
          return false;
        }
        function Tc(e2) {
          const { type: t2, lang: r2 } = e2.attrMap;
          return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || r2 === "jsx" ? "babel" : t2 === "application/x-typescript" || r2 === "ts" || r2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
        }
        function _c(e2) {
          return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
        }
        function vc(e2) {
          return Fc(e2).startsWith("pre");
        }
        function Ac(e2) {
          return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
        }
        function Fc(e2) {
          return e2.type === "element" && (!e2.namespace || Ac(e2)) && oc[e2.name] || ac;
        }
        function wc(e2) {
          let t2 = Number.POSITIVE_INFINITY;
          for (const n2 of e2.split("\n")) {
            if (n2.length === 0)
              continue;
            if (!lc.has(n2[0]))
              return 0;
            const e3 = (r2 = n2, r2.match(/^[\t\n\f\r ]*/)[0]).length;
            n2.length !== e3 && (e3 < t2 && (t2 = e3));
          }
          var r2;
          return t2 === Number.POSITIVE_INFINITY ? 0 : t2;
        }
        function kc(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : wc(e2);
          return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
        }
        const Nc = /* @__PURE__ */ new Set(["template", "style", "script"]);
        function Oc(e2, t2) {
          return xc(e2, t2) && !Nc.has(e2.fullName);
        }
        function xc(e2, t2) {
          return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
        }
        function Ic(e2, t2) {
          return xc(e2, t2) && (Oc(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
        }
        var Pc = { HTML_ELEMENT_ATTRIBUTES: cc, HTML_TAGS: uc, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(pc(e2)), htmlTrimPreserveIndentation: hc, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
          const [, t2, r2, n2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
          return { leadingWhitespace: t2, trailingWhitespace: n2, text: r2 };
        }, canHaveInterpolation: function(e2) {
          return e2.children && !dc(e2);
        }, countChars: function(e2, t2) {
          let r2 = 0;
          for (let n2 = 0; n2 < e2.length; n2++)
            e2[n2] === t2 && r2++;
          return r2;
        }, countParents: function(e2, t2) {
          let r2 = 0;
          for (let n2 = e2.stack.length - 1; n2 >= 0; n2--) {
            const i2 = e2.stack[n2];
            i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && r2++;
          }
          return r2;
        }, dedentString: kc, forceBreakChildren: mc, forceBreakContent: function(e2) {
          return mc(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
            return e4.children && e4.children.some((e5) => e5.type !== "text");
          }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && yc(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || bc(e2.lastChild));
        }, forceNextEmptyLine: function(e2) {
          return Zu(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
        }, getLastDescendant: function e2(t2) {
          return t2.lastChild ? e2(t2.lastChild) : t2;
        }, getNodeCssStyleDisplay: function(e2, t2) {
          if (e2.prev && e2.prev.type === "comment") {
            const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t3)
              return t3[1];
          }
          let r2 = false;
          if (e2.type === "element" && e2.namespace === "svg") {
            if (!function(e3, t3) {
              let r3 = e3;
              for (; r3; ) {
                if (t3(r3))
                  return true;
                r3 = r3.parent;
              }
              return false;
            }(e2, (e3) => e3.fullName === "svg:foreignObject"))
              return e2.name === "svg" ? "inline-block" : "block";
            r2 = true;
          }
          switch (t2.htmlWhitespaceSensitivity) {
            case "strict":
              return "inline";
            case "ignore":
              return "block";
            default:
              return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || r2 || Ac(e2)) && ic[e2.name] || sc;
          }
        }, getNodeCssStyleWhiteSpace: Fc, hasPrettierIgnore: function(e2) {
          return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
            return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
          }(e2.parent.children[e2.index - 1])));
        }, inferScriptParser: function(e2, t2) {
          return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
            const { lang: t3 } = e3.attrMap;
            return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
          }(e2) : t2 && Ic(e2, t2) ? Tc(e2) || !("src" in e2.attrMap) && Ju(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? Tc(e2) : "babel";
        }, isVueCustomBlock: Oc, isVueNonHtmlBlock: Ic, isVueSlotAttribute: function(e2) {
          const t2 = e2.fullName;
          return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
        }, isVueSfcBindingsAttribute: function(e2, t2) {
          const r2 = e2.parent;
          if (!xc(r2, t2))
            return false;
          const n2 = r2.fullName, i2 = e2.fullName;
          return n2 === "script" && i2 === "setup" || n2 === "style" && i2 === "vars";
        }, isDanglingSpaceSensitiveNode: function(e2) {
          return !(t2 = e2.cssDisplay, _c(t2) || t2 === "inline-block" || dc(e2));
          var t2;
        }, isIndentationSensitiveNode: gc, isLeadingSpaceSensitiveNode: function(e2, t2) {
          const r2 = function() {
            if (Zu(e2))
              return false;
            if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
              return true;
            if (!e2.parent || e2.parent.cssDisplay === "none")
              return false;
            if (vc(e2.parent))
              return true;
            if (!e2.prev && (e2.parent.type === "root" || vc(e2) && e2.parent || dc(e2.parent) || Oc(e2.parent, t2) || (r3 = e2.parent.cssDisplay, _c(r3) || r3 === "inline-block")))
              return false;
            var r3;
            if (e2.prev && !function(e3) {
              return !_c(e3);
            }(e2.prev.cssDisplay))
              return false;
            return true;
          }();
          return r2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : r2;
        }, isPreLikeNode: vc, isScriptLikeTag: dc, isTextLikeNode: function(e2) {
          return e2.type === "text" || e2.type === "comment";
        }, isTrailingSpaceSensitiveNode: function(e2, t2) {
          return !Zu(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!vc(e2.parent) || !(!e2.next && (e2.parent.type === "root" || vc(e2) && e2.parent || dc(e2.parent) || Oc(e2.parent, t2) || (r2 = e2.parent.cssDisplay, _c(r2) || r2 === "inline-block"))) && !(e2.next && !function(e3) {
            return !_c(e3);
          }(e2.next.cssDisplay))));
          var r2;
        }, isWhitespaceSensitiveNode: function(e2) {
          return dc(e2) || e2.type === "interpolation" || gc(e2);
        }, isUnknownNamespace: Ac, preferHardlineAsLeadingSpaces: function(e2) {
          return Sc(e2) || e2.prev && Ec(e2.prev) || Cc(e2);
        }, preferHardlineAsTrailingSpaces: Ec, shouldPreserveContent: function(e2, t2) {
          return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!vc(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!Ic(e2, t2) || dc(e2) || e2.type === "interpolation")));
        }, unescapeQuoteEntities: function(e2) {
          return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
        }, getTextValueParts: function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e2.value;
          return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? nc(t2) : nc(kc(hc(t2)), ec) : rc(tc(Ku, Dc(t2)));
        } };
        var Rc = { hasPragma: function(e2) {
          return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
        }, insertPragma: function(e2) {
          return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
        } };
        const { isNonEmptyArray: Lc } = Ja, Bc = C, qc = { attrs: true, children: true };
        class $c {
          constructor() {
            let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            for (const [t2, r2] of Object.entries(e2))
              t2 in qc ? this._setNodes(t2, r2) : this[t2] = r2;
          }
          _setNodes(e2, t2) {
            t2 !== this[e2] && (this[e2] = function(e3, t3) {
              const r2 = e3.map((e4) => e4 instanceof $c ? e4.clone() : new $c(e4));
              let n2 = null, i2 = r2[0], s2 = r2[1] || null;
              for (let e4 = 0; e4 < r2.length; e4++)
                jc(i2, { index: e4, siblings: r2, prev: n2, next: s2, parent: t3 }), n2 = i2, i2 = s2, s2 = r2[e4 + 2] || null;
              return r2;
            }(t2, this), e2 === "attrs" && jc(this, { attrMap: Object.fromEntries(this[e2].map((e3) => [e3.fullName, e3.value])) }));
          }
          map(e2) {
            let t2 = null;
            for (const r2 in qc) {
              const n2 = this[r2];
              if (n2) {
                const i2 = Mc(n2, (t3) => t3.map(e2));
                t2 !== n2 && (t2 || (t2 = new $c()), t2._setNodes(r2, i2));
              }
            }
            if (t2) {
              for (const e4 in this)
                e4 in qc || (t2[e4] = this[e4]);
              const { index: e3, siblings: r2, prev: n2, next: i2, parent: s2 } = this;
              jc(t2, { index: e3, siblings: r2, prev: n2, next: i2, parent: s2 });
            }
            return e2(t2 || this);
          }
          walk(e2) {
            for (const t2 in qc) {
              const r2 = this[t2];
              if (r2)
                for (let t3 = 0; t3 < r2.length; t3++)
                  r2[t3].walk(e2);
            }
            e2(this);
          }
          clone(e2) {
            return new $c(e2 ? Object.assign(Object.assign({}, this), e2) : this);
          }
          setChildren(e2) {
            this._setNodes("children", e2);
          }
          get firstChild() {
            return Lc(this.children) ? this.children[0] : null;
          }
          get lastChild() {
            return Lc(this.children) ? Bc(this.children) : null;
          }
          get rawName() {
            return this.hasExplicitNamespace ? this.fullName : this.name;
          }
          get fullName() {
            return this.namespace ? this.namespace + ":" + this.name : this.name;
          }
        }
        function Mc(e2, t2) {
          const r2 = e2.map(t2);
          return r2.some((t3, r3) => t3 !== e2[r3]) ? r2 : e2;
        }
        function jc(e2, t2) {
          const r2 = Object.fromEntries(Object.entries(t2).map((e3) => {
            let [t3, r3] = e3;
            return [t3, { value: r3, enumerable: false }];
          }));
          Object.defineProperties(e2, r2);
        }
        var Uc = { Node: $c };
        const { ParseSourceSpan: Gc } = t, Vc = [{ regex: /^(\[if([^\]]*?)]>)(.*?)<!\s*\[endif]$/s, parse: function(e2, t2, r2) {
          const [, n2, i2, s2] = r2, o2 = "<!--".length + n2.length, a2 = e2.sourceSpan.start.moveBy(o2), u2 = a2.moveBy(s2.length), [c2, l2] = (() => {
            try {
              return [true, t2(s2, a2).children];
            } catch (e3) {
              return [false, [{ type: "text", value: s2, sourceSpan: new Gc(a2, u2) }]];
            }
          })();
          return { type: "ieConditionalComment", complete: c2, children: l2, condition: i2.trim().replace(/\s+/g, " "), sourceSpan: e2.sourceSpan, startSourceSpan: new Gc(e2.sourceSpan.start, a2), endSourceSpan: new Gc(u2, e2.sourceSpan.end) };
        } }, { regex: /^\[if([^\]]*?)]><!$/, parse: function(e2, t2, r2) {
          const [, n2] = r2;
          return { type: "ieConditionalStartComment", condition: n2.trim().replace(/\s+/g, " "), sourceSpan: e2.sourceSpan };
        } }, { regex: /^<!\s*\[endif]$/, parse: function(e2) {
          return { type: "ieConditionalEndComment", sourceSpan: e2.sourceSpan };
        } }];
        var Xc = { parseIeConditionalComment: function(e2, t2) {
          if (e2.value)
            for (const { regex: r2, parse: n2 } of Vc) {
              const i2 = e2.value.match(r2);
              if (i2)
                return n2(e2, t2, i2);
            }
          return null;
        } };
        var Hc = { locStart: function(e2) {
          return e2.sourceSpan.start.offset;
        }, locEnd: function(e2) {
          return e2.sourceSpan.end.offset;
        } }, zc = {}, Wc = {}, Yc = {}, Qc = {};
        !function(e2) {
          var t2;
          function r2(e3) {
            if (e3[0] != ":")
              return [null, e3];
            const t3 = e3.indexOf(":", 1);
            if (t3 == -1)
              throw new Error('Unsupported format "'.concat(e3, '" expecting ":namespace:name"'));
            return [e3.slice(1, t3), e3.slice(t3 + 1)];
          }
          Object.defineProperty(e2, "__esModule", { value: true }), (t2 = e2.TagContentType || (e2.TagContentType = {}))[t2.RAW_TEXT = 0] = "RAW_TEXT", t2[t2.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t2[t2.PARSABLE_DATA = 2] = "PARSABLE_DATA", e2.splitNsName = r2, e2.isNgContainer = function(e3) {
            return r2(e3)[1] === "ng-container";
          }, e2.isNgContent = function(e3) {
            return r2(e3)[1] === "ng-content";
          }, e2.isNgTemplate = function(e3) {
            return r2(e3)[1] === "ng-template";
          }, e2.getNsPrefix = function(e3) {
            return e3 === null ? null : r2(e3)[0];
          }, e2.mergeNsAndName = function(e3, t3) {
            return e3 ? ":".concat(e3, ":").concat(t3) : t3;
          }, e2.NAMED_ENTITIES = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, e2.NGSP_UNICODE = "\uE500", e2.NAMED_ENTITIES.ngsp = e2.NGSP_UNICODE;
        }(Qc), Object.defineProperty(Yc, "__esModule", { value: true });
        const Jc = Qc;
        class Zc {
          constructor() {
            let { closedByChildren: e2, implicitNamespacePrefix: t2, contentType: r2 = Jc.TagContentType.PARSABLE_DATA, closedByParent: n2 = false, isVoid: i2 = false, ignoreFirstLf: s2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, e2 && e2.length > 0 && e2.forEach((e3) => this.closedByChildren[e3] = true), this.isVoid = i2, this.closedByParent = n2 || i2, this.implicitNamespacePrefix = t2 || null, this.contentType = r2, this.ignoreFirstLf = s2;
          }
          isClosedByChild(e2) {
            return this.isVoid || e2.toLowerCase() in this.closedByChildren;
          }
        }
        let Kc, el;
        Yc.HtmlTagDefinition = Zc, Yc.getHtmlTagDefinition = function(e2) {
          return el || (Kc = new Zc(), el = { base: new Zc({ isVoid: true }), meta: new Zc({ isVoid: true }), area: new Zc({ isVoid: true }), embed: new Zc({ isVoid: true }), link: new Zc({ isVoid: true }), img: new Zc({ isVoid: true }), input: new Zc({ isVoid: true }), param: new Zc({ isVoid: true }), hr: new Zc({ isVoid: true }), br: new Zc({ isVoid: true }), source: new Zc({ isVoid: true }), track: new Zc({ isVoid: true }), wbr: new Zc({ isVoid: true }), p: new Zc({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new Zc({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Zc({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new Zc({ closedByChildren: ["tbody"], closedByParent: true }), tr: new Zc({ closedByChildren: ["tr"], closedByParent: true }), td: new Zc({ closedByChildren: ["td", "th"], closedByParent: true }), th: new Zc({ closedByChildren: ["td", "th"], closedByParent: true }), col: new Zc({ isVoid: true }), svg: new Zc({ implicitNamespacePrefix: "svg" }), math: new Zc({ implicitNamespacePrefix: "math" }), li: new Zc({ closedByChildren: ["li"], closedByParent: true }), dt: new Zc({ closedByChildren: ["dt", "dd"] }), dd: new Zc({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new Zc({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new Zc({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new Zc({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new Zc({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new Zc({ closedByChildren: ["optgroup"], closedByParent: true }), option: new Zc({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new Zc({ ignoreFirstLf: true }), listing: new Zc({ ignoreFirstLf: true }), style: new Zc({ contentType: Jc.TagContentType.RAW_TEXT }), script: new Zc({ contentType: Jc.TagContentType.RAW_TEXT }), title: new Zc({ contentType: Jc.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new Zc({ contentType: Jc.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), el[e2] || Kc;
        };
        var tl = {}, rl = {}, nl = {};
        Object.defineProperty(nl, "__esModule", { value: true });
        nl.AstPath = class {
          constructor(e2) {
            let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
            this.path = e2, this.position = t2;
          }
          get empty() {
            return !this.path || !this.path.length;
          }
          get head() {
            return this.path[0];
          }
          get tail() {
            return this.path[this.path.length - 1];
          }
          parentOf(e2) {
            return e2 && this.path[this.path.indexOf(e2) - 1];
          }
          childOf(e2) {
            return this.path[this.path.indexOf(e2) + 1];
          }
          first(e2) {
            for (let t2 = this.path.length - 1; t2 >= 0; t2--) {
              let r2 = this.path[t2];
              if (r2 instanceof e2)
                return r2;
            }
          }
          push(e2) {
            this.path.push(e2);
          }
          pop() {
            return this.path.pop();
          }
        }, Object.defineProperty(rl, "__esModule", { value: true });
        const il = nl;
        rl.Text = class {
          constructor(e2, t2, r2) {
            this.value = e2, this.sourceSpan = t2, this.i18n = r2, this.type = "text";
          }
          visit(e2, t2) {
            return e2.visitText(this, t2);
          }
        };
        rl.CDATA = class {
          constructor(e2, t2) {
            this.value = e2, this.sourceSpan = t2, this.type = "cdata";
          }
          visit(e2, t2) {
            return e2.visitCdata(this, t2);
          }
        };
        rl.Expansion = class {
          constructor(e2, t2, r2, n2, i2, s2) {
            this.switchValue = e2, this.type = t2, this.cases = r2, this.sourceSpan = n2, this.switchValueSourceSpan = i2, this.i18n = s2;
          }
          visit(e2, t2) {
            return e2.visitExpansion(this, t2);
          }
        };
        rl.ExpansionCase = class {
          constructor(e2, t2, r2, n2, i2) {
            this.value = e2, this.expression = t2, this.sourceSpan = r2, this.valueSourceSpan = n2, this.expSourceSpan = i2;
          }
          visit(e2, t2) {
            return e2.visitExpansionCase(this, t2);
          }
        };
        rl.Attribute = class {
          constructor(e2, t2, r2) {
            let n2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, i2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, s2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
            this.name = e2, this.value = t2, this.sourceSpan = r2, this.valueSpan = n2, this.nameSpan = i2, this.i18n = s2, this.type = "attribute";
          }
          visit(e2, t2) {
            return e2.visitAttribute(this, t2);
          }
        };
        class sl {
          constructor(e2, t2, r2, n2) {
            let i2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, s2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, o2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, a2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
            this.name = e2, this.attrs = t2, this.children = r2, this.sourceSpan = n2, this.startSourceSpan = i2, this.endSourceSpan = s2, this.nameSpan = o2, this.i18n = a2, this.type = "element";
          }
          visit(e2, t2) {
            return e2.visitElement(this, t2);
          }
        }
        rl.Element = sl;
        rl.Comment = class {
          constructor(e2, t2) {
            this.value = e2, this.sourceSpan = t2, this.type = "comment";
          }
          visit(e2, t2) {
            return e2.visitComment(this, t2);
          }
        };
        function ol(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          const n2 = [], i2 = e2.visit ? (t3) => e2.visit(t3, r2) || t3.visit(e2, r2) : (t3) => t3.visit(e2, r2);
          return t2.forEach((e3) => {
            const t3 = i2(e3);
            t3 && n2.push(t3);
          }), n2;
        }
        rl.DocType = class {
          constructor(e2, t2) {
            this.value = e2, this.sourceSpan = t2, this.type = "docType";
          }
          visit(e2, t2) {
            return e2.visitDocType(this, t2);
          }
        }, rl.visitAll = ol;
        class al {
          constructor() {
          }
          visitElement(e2, t2) {
            this.visitChildren(t2, (t3) => {
              t3(e2.attrs), t3(e2.children);
            });
          }
          visitAttribute(e2, t2) {
          }
          visitText(e2, t2) {
          }
          visitCdata(e2, t2) {
          }
          visitComment(e2, t2) {
          }
          visitDocType(e2, t2) {
          }
          visitExpansion(e2, t2) {
            return this.visitChildren(t2, (t3) => {
              t3(e2.cases);
            });
          }
          visitExpansionCase(e2, t2) {
          }
          visitChildren(e2, t2) {
            let r2 = [], n2 = this;
            return t2(function(t3) {
              t3 && r2.push(ol(n2, t3, e2));
            }), Array.prototype.concat.apply([], r2);
          }
        }
        function ul(e2) {
          const t2 = e2.sourceSpan.start.offset;
          let r2 = e2.sourceSpan.end.offset;
          return e2 instanceof sl && (e2.endSourceSpan ? r2 = e2.endSourceSpan.end.offset : e2.children && e2.children.length && (r2 = ul(e2.children[e2.children.length - 1]).end)), { start: t2, end: r2 };
        }
        rl.RecursiveVisitor = al, rl.findNode = function(e2, t2) {
          const r2 = [], n2 = new class extends al {
            visit(e3, n3) {
              const i2 = ul(e3);
              if (!(i2.start <= t2 && t2 < i2.end))
                return true;
              r2.push(e3);
            }
          }();
          return ol(n2, e2), new il.AstPath(r2, t2);
        };
        var cl = {}, ll = {}, pl = {};
        Object.defineProperty(pl, "__esModule", { value: true }), pl.assertArrayOfStrings = function(e2, t2) {
          if (t2 != null) {
            if (!Array.isArray(t2))
              throw new Error("Expected '".concat(e2, "' to be an array of strings."));
            for (let r2 = 0; r2 < t2.length; r2 += 1)
              if (typeof t2[r2] != "string")
                throw new Error("Expected '".concat(e2, "' to be an array of strings."));
          }
        };
        const hl = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
        pl.assertInterpolationSymbols = function(e2, t2) {
          if (!(t2 == null || Array.isArray(t2) && t2.length == 2))
            throw new Error("Expected '".concat(e2, "' to be an array, [start, end]."));
          if (t2 != null) {
            const e3 = t2[0], r2 = t2[1];
            hl.forEach((t3) => {
              if (t3.test(e3) || t3.test(r2))
                throw new Error("['".concat(e3, "', '").concat(r2, "'] contains unusable interpolation symbol."));
            });
          }
        }, function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const t2 = pl;
          class r2 {
            constructor(e3, t3) {
              this.start = e3, this.end = t3;
            }
            static fromArray(n2) {
              return n2 ? (t2.assertInterpolationSymbols("interpolation", n2), new r2(n2[0], n2[1])) : e2.DEFAULT_INTERPOLATION_CONFIG;
            }
          }
          e2.InterpolationConfig = r2, e2.DEFAULT_INTERPOLATION_CONFIG = new r2("{{", "}}");
        }(ll), function(e2) {
          Object.defineProperty(e2, "__esModule", { value: true });
          const n2 = r, i2 = t, s2 = ll, o2 = Qc;
          var a2;
          !function(e3) {
            e3[e3.TAG_OPEN_START = 0] = "TAG_OPEN_START", e3[e3.TAG_OPEN_END = 1] = "TAG_OPEN_END", e3[e3.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e3[e3.TAG_CLOSE = 3] = "TAG_CLOSE", e3[e3.TEXT = 4] = "TEXT", e3[e3.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e3[e3.RAW_TEXT = 6] = "RAW_TEXT", e3[e3.COMMENT_START = 7] = "COMMENT_START", e3[e3.COMMENT_END = 8] = "COMMENT_END", e3[e3.CDATA_START = 9] = "CDATA_START", e3[e3.CDATA_END = 10] = "CDATA_END", e3[e3.ATTR_NAME = 11] = "ATTR_NAME", e3[e3.ATTR_QUOTE = 12] = "ATTR_QUOTE", e3[e3.ATTR_VALUE = 13] = "ATTR_VALUE", e3[e3.DOC_TYPE_START = 14] = "DOC_TYPE_START", e3[e3.DOC_TYPE_END = 15] = "DOC_TYPE_END", e3[e3.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e3[e3.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e3[e3.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e3[e3.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e3[e3.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e3[e3.EOF = 21] = "EOF";
          }(a2 = e2.TokenType || (e2.TokenType = {}));
          class u2 {
            constructor(e3, t2, r2) {
              this.type = e3, this.parts = t2, this.sourceSpan = r2;
            }
          }
          e2.Token = u2;
          class c2 extends i2.ParseError {
            constructor(e3, t2, r2) {
              super(r2, e3), this.tokenType = t2;
            }
          }
          e2.TokenError = c2;
          class l2 {
            constructor(e3, t2) {
              this.tokens = e3, this.errors = t2;
            }
          }
          e2.TokenizeResult = l2, e2.tokenize = function(e3, t2, r2) {
            let n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return new d2(new i2.ParseSourceFile(e3, t2), r2, n3).tokenize();
          };
          const p2 = /\r\n?/g;
          function h2(e3) {
            const t2 = e3 === n2.$EOF ? "EOF" : String.fromCharCode(e3);
            return 'Unexpected character "'.concat(t2, '"');
          }
          function D2(e3) {
            return 'Unknown entity "'.concat(e3, '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax');
          }
          class f2 {
            constructor(e3) {
              this.error = e3;
            }
          }
          class d2 {
            constructor(e3, t2, r2) {
              this._getTagContentType = t2, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = r2.tokenizeExpansionForms || false, this._interpolationConfig = r2.interpolationConfig || s2.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = r2.leadingTriviaChars && r2.leadingTriviaChars.map((e4) => e4.codePointAt(0) || 0), this._canSelfClose = r2.canSelfClose || false, this._allowHtmComponentClosingTags = r2.allowHtmComponentClosingTags || false;
              const n3 = r2.range || { endPos: e3.content.length, startPos: 0, startLine: 0, startCol: 0 };
              this._cursor = r2.escapedString ? new S2(e3, n3) : new b2(e3, n3);
              try {
                this._cursor.init();
              } catch (e4) {
                this.handleError(e4);
              }
            }
            _processCarriageReturns(e3) {
              return e3.replace(p2, "\n");
            }
            tokenize() {
              for (; this._cursor.peek() !== n2.$EOF; ) {
                const e3 = this._cursor.clone();
                try {
                  if (this._attemptCharCode(n2.$LT))
                    if (this._attemptCharCode(n2.$BANG))
                      this._attemptStr("[CDATA[") ? this._consumeCdata(e3) : this._attemptStr("--") ? this._consumeComment(e3) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e3) : this._consumeBogusComment(e3);
                    else if (this._attemptCharCode(n2.$SLASH))
                      this._consumeTagClose(e3);
                    else {
                      const t2 = this._cursor.clone();
                      this._attemptCharCode(n2.$QUESTION) ? (this._cursor = t2, this._consumeBogusComment(e3)) : this._consumeTagOpen(e3);
                    }
                  else
                    this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
                } catch (e4) {
                  this.handleError(e4);
                }
              }
              return this._beginToken(a2.EOF), this._endToken([]), new l2(function(e3) {
                const t2 = [];
                let r2;
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  r2 && r2.type == a2.TEXT && i3.type == a2.TEXT ? (r2.parts[0] += i3.parts[0], r2.sourceSpan.end = i3.sourceSpan.end) : (r2 = i3, t2.push(r2));
                }
                return t2;
              }(this.tokens), this.errors);
            }
            _tokenizeExpansionForm() {
              if (this.isExpansionFormStart())
                return this._consumeExpansionFormStart(), true;
              if (((e3 = this._cursor.peek()) === n2.$EQ || n2.isAsciiLetter(e3) || n2.isDigit(e3)) && this._isInExpansionForm())
                return this._consumeExpansionCaseStart(), true;
              var e3;
              if (this._cursor.peek() === n2.$RBRACE) {
                if (this._isInExpansionCase())
                  return this._consumeExpansionCaseEnd(), true;
                if (this._isInExpansionForm())
                  return this._consumeExpansionFormEnd(), true;
              }
              return false;
            }
            _beginToken(e3) {
              let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
              this._currentTokenStart = t2, this._currentTokenType = e3;
            }
            _endToken(e3) {
              let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
              if (this._currentTokenStart === null)
                throw new c2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t2));
              if (this._currentTokenType === null)
                throw new c2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
              const r2 = new u2(this._currentTokenType, e3, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
              return this.tokens.push(r2), this._currentTokenStart = null, this._currentTokenType = null, r2;
            }
            _createError(e3, t2) {
              this._isInExpansionForm() && (e3 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
              const r2 = new c2(e3, this._currentTokenType, t2);
              return this._currentTokenStart = null, this._currentTokenType = null, new f2(r2);
            }
            handleError(e3) {
              if (e3 instanceof T2 && (e3 = this._createError(e3.msg, this._cursor.getSpan(e3.cursor))), !(e3 instanceof f2))
                throw e3;
              this.errors.push(e3.error);
            }
            _attemptCharCode(e3) {
              return this._cursor.peek() === e3 && (this._cursor.advance(), true);
            }
            _attemptCharCodeCaseInsensitive(e3) {
              return t2 = this._cursor.peek(), r2 = e3, y2(t2) == y2(r2) && (this._cursor.advance(), true);
              var t2, r2;
            }
            _requireCharCode(e3) {
              const t2 = this._cursor.clone();
              if (!this._attemptCharCode(e3))
                throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan(t2));
            }
            _attemptStr(e3) {
              const t2 = e3.length;
              if (this._cursor.charsLeft() < t2)
                return false;
              const r2 = this._cursor.clone();
              for (let n3 = 0; n3 < t2; n3++)
                if (!this._attemptCharCode(e3.charCodeAt(n3)))
                  return this._cursor = r2, false;
              return true;
            }
            _attemptStrCaseInsensitive(e3) {
              for (let t2 = 0; t2 < e3.length; t2++)
                if (!this._attemptCharCodeCaseInsensitive(e3.charCodeAt(t2)))
                  return false;
              return true;
            }
            _requireStr(e3) {
              const t2 = this._cursor.clone();
              if (!this._attemptStr(e3))
                throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan(t2));
            }
            _requireStrCaseInsensitive(e3) {
              const t2 = this._cursor.clone();
              if (!this._attemptStrCaseInsensitive(e3))
                throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan(t2));
            }
            _attemptCharCodeUntilFn(e3) {
              for (; !e3(this._cursor.peek()); )
                this._cursor.advance();
            }
            _requireCharCodeUntilFn(e3, t2) {
              const r2 = this._cursor.clone();
              this._attemptCharCodeUntilFn(e3);
              if (this._cursor.clone().diff(r2) < t2)
                throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan(r2));
            }
            _attemptUntilChar(e3) {
              for (; this._cursor.peek() !== e3; )
                this._cursor.advance();
            }
            _readChar(e3) {
              if (e3 && this._cursor.peek() === n2.$AMPERSAND)
                return this._decodeEntity();
              {
                const e4 = String.fromCodePoint(this._cursor.peek());
                return this._cursor.advance(), e4;
              }
            }
            _decodeEntity() {
              const e3 = this._cursor.clone();
              if (this._cursor.advance(), !this._attemptCharCode(n2.$HASH)) {
                const t2 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(C2), this._cursor.peek() != n2.$SEMICOLON)
                  return this._cursor = t2, "&";
                const r2 = this._cursor.getChars(t2);
                this._cursor.advance();
                const i3 = o2.NAMED_ENTITIES[r2];
                if (!i3)
                  throw this._createError(D2(r2), this._cursor.getSpan(e3));
                return i3;
              }
              {
                const t2 = this._attemptCharCode(n2.$x) || this._attemptCharCode(n2.$X), r2 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(E2), this._cursor.peek() != n2.$SEMICOLON)
                  throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan());
                const i3 = this._cursor.getChars(r2);
                this._cursor.advance();
                try {
                  const e4 = parseInt(i3, t2 ? 16 : 10);
                  return String.fromCharCode(e4);
                } catch (t3) {
                  throw this._createError(D2(this._cursor.getChars(e3)), this._cursor.getSpan());
                }
              }
            }
            _consumeRawText(e3, t2) {
              this._beginToken(e3 ? a2.ESCAPABLE_RAW_TEXT : a2.RAW_TEXT);
              const r2 = [];
              for (; ; ) {
                const n3 = this._cursor.clone(), i3 = t2();
                if (this._cursor = n3, i3)
                  break;
                r2.push(this._readChar(e3));
              }
              return this._endToken([this._processCarriageReturns(r2.join(""))]);
            }
            _consumeComment(e3) {
              this._beginToken(a2.COMMENT_START, e3), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(a2.COMMENT_END), this._requireStr("-->"), this._endToken([]);
            }
            _consumeBogusComment(e3) {
              this._beginToken(a2.COMMENT_START, e3), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(a2.COMMENT_END), this._cursor.advance(), this._endToken([]);
            }
            _consumeCdata(e3) {
              this._beginToken(a2.CDATA_START, e3), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(a2.CDATA_END), this._requireStr("]]>"), this._endToken([]);
            }
            _consumeDocType(e3) {
              this._beginToken(a2.DOC_TYPE_START, e3), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === n2.$GT), this._beginToken(a2.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
            }
            _consumePrefixAndName() {
              const e3 = this._cursor.clone();
              let t2 = "";
              for (; this._cursor.peek() !== n2.$COLON && !(((r2 = this._cursor.peek()) < n2.$a || n2.$z < r2) && (r2 < n2.$A || n2.$Z < r2) && (r2 < n2.$0 || r2 > n2.$9)); )
                this._cursor.advance();
              var r2;
              let i3;
              this._cursor.peek() === n2.$COLON ? (t2 = this._cursor.getChars(e3), this._cursor.advance(), i3 = this._cursor.clone()) : i3 = e3, this._requireCharCodeUntilFn(m2, t2 === "" ? 0 : 1);
              return [t2, this._cursor.getChars(i3)];
            }
            _consumeTagOpen(e3) {
              let t2, r2, i3, s3 = this.tokens.length;
              const u3 = this._cursor.clone(), c3 = [];
              try {
                if (!n2.isAsciiLetter(this._cursor.peek()))
                  throw this._createError(h2(this._cursor.peek()), this._cursor.getSpan(e3));
                for (i3 = this._consumeTagOpenStart(e3), r2 = i3.parts[0], t2 = i3.parts[1], this._attemptCharCodeUntilFn(g2); this._cursor.peek() !== n2.$SLASH && this._cursor.peek() !== n2.$GT; ) {
                  const [e4, t3] = this._consumeAttributeName();
                  if (this._attemptCharCodeUntilFn(g2), this._attemptCharCode(n2.$EQ)) {
                    this._attemptCharCodeUntilFn(g2);
                    const r3 = this._consumeAttributeValue();
                    c3.push({ prefix: e4, name: t3, value: r3 });
                  } else
                    c3.push({ prefix: e4, name: t3 });
                  this._attemptCharCodeUntilFn(g2);
                }
                this._consumeTagOpenEnd();
              } catch (t3) {
                if (t3 instanceof f2)
                  return this._cursor = u3, i3 && (this.tokens.length = s3), this._beginToken(a2.TEXT, e3), void this._endToken(["<"]);
                throw t3;
              }
              if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === a2.TAG_OPEN_END_VOID)
                return;
              const l3 = this._getTagContentType(t2, r2, this._fullNameStack.length > 0, c3);
              this._handleFullNameStackForTagOpen(r2, t2), l3 === o2.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(r2, t2, false) : l3 === o2.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r2, t2, true);
            }
            _consumeRawTextWithTagClose(e3, t2, r2) {
              this._consumeRawText(r2, () => !!this._attemptCharCode(n2.$LT) && (!!this._attemptCharCode(n2.$SLASH) && (this._attemptCharCodeUntilFn(g2), !!this._attemptStrCaseInsensitive(e3 ? "".concat(e3, ":").concat(t2) : t2) && (this._attemptCharCodeUntilFn(g2), this._attemptCharCode(n2.$GT))))), this._beginToken(a2.TAG_CLOSE), this._requireCharCodeUntilFn((e4) => e4 === n2.$GT, 3), this._cursor.advance(), this._endToken([e3, t2]), this._handleFullNameStackForTagClose(e3, t2);
            }
            _consumeTagOpenStart(e3) {
              this._beginToken(a2.TAG_OPEN_START, e3);
              const t2 = this._consumePrefixAndName();
              return this._endToken(t2);
            }
            _consumeAttributeName() {
              const e3 = this._cursor.peek();
              if (e3 === n2.$SQ || e3 === n2.$DQ)
                throw this._createError(h2(e3), this._cursor.getSpan());
              this._beginToken(a2.ATTR_NAME);
              const t2 = this._consumePrefixAndName();
              return this._endToken(t2), t2;
            }
            _consumeAttributeValue() {
              let e3;
              if (this._cursor.peek() === n2.$SQ || this._cursor.peek() === n2.$DQ) {
                this._beginToken(a2.ATTR_QUOTE);
                const t2 = this._cursor.peek();
                this._cursor.advance(), this._endToken([String.fromCodePoint(t2)]), this._beginToken(a2.ATTR_VALUE);
                const r2 = [];
                for (; this._cursor.peek() !== t2; )
                  r2.push(this._readChar(true));
                e3 = this._processCarriageReturns(r2.join("")), this._endToken([e3]), this._beginToken(a2.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t2)]);
              } else {
                this._beginToken(a2.ATTR_VALUE);
                const t2 = this._cursor.clone();
                this._requireCharCodeUntilFn(m2, 1), e3 = this._processCarriageReturns(this._cursor.getChars(t2)), this._endToken([e3]);
              }
              return e3;
            }
            _consumeTagOpenEnd() {
              const e3 = this._attemptCharCode(n2.$SLASH) ? a2.TAG_OPEN_END_VOID : a2.TAG_OPEN_END;
              this._beginToken(e3), this._requireCharCode(n2.$GT), this._endToken([]);
            }
            _consumeTagClose(e3) {
              if (this._beginToken(a2.TAG_CLOSE, e3), this._attemptCharCodeUntilFn(g2), this._allowHtmComponentClosingTags && this._attemptCharCode(n2.$SLASH))
                this._attemptCharCodeUntilFn(g2), this._requireCharCode(n2.$GT), this._endToken([]);
              else {
                const [e4, t2] = this._consumePrefixAndName();
                this._attemptCharCodeUntilFn(g2), this._requireCharCode(n2.$GT), this._endToken([e4, t2]), this._handleFullNameStackForTagClose(e4, t2);
              }
            }
            _consumeExpansionFormStart() {
              this._beginToken(a2.EXPANSION_FORM_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._expansionCaseStack.push(a2.EXPANSION_FORM_START), this._beginToken(a2.RAW_TEXT);
              const e3 = this._readUntil(n2.$COMMA);
              this._endToken([e3]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(g2), this._beginToken(a2.RAW_TEXT);
              const t2 = this._readUntil(n2.$COMMA);
              this._endToken([t2]), this._requireCharCode(n2.$COMMA), this._attemptCharCodeUntilFn(g2);
            }
            _consumeExpansionCaseStart() {
              this._beginToken(a2.EXPANSION_CASE_VALUE);
              const e3 = this._readUntil(n2.$LBRACE).trim();
              this._endToken([e3]), this._attemptCharCodeUntilFn(g2), this._beginToken(a2.EXPANSION_CASE_EXP_START), this._requireCharCode(n2.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(g2), this._expansionCaseStack.push(a2.EXPANSION_CASE_EXP_START);
            }
            _consumeExpansionCaseEnd() {
              this._beginToken(a2.EXPANSION_CASE_EXP_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(g2), this._expansionCaseStack.pop();
            }
            _consumeExpansionFormEnd() {
              this._beginToken(a2.EXPANSION_FORM_END), this._requireCharCode(n2.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
            }
            _consumeText() {
              const e3 = this._cursor.clone();
              this._beginToken(a2.TEXT, e3);
              const t2 = [];
              do {
                this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t2.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t2.push(this._interpolationConfig.end), this._inInterpolation = false) : t2.push(this._readChar(true));
              } while (!this._isTextEnd());
              this._endToken([this._processCarriageReturns(t2.join(""))]);
            }
            _isTextEnd() {
              if (this._cursor.peek() === n2.$LT || this._cursor.peek() === n2.$EOF)
                return true;
              if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart())
                  return true;
                if (this._cursor.peek() === n2.$RBRACE && this._isInExpansionCase())
                  return true;
              }
              return false;
            }
            _readUntil(e3) {
              const t2 = this._cursor.clone();
              return this._attemptUntilChar(e3), this._cursor.getChars(t2);
            }
            _isInExpansionCase() {
              return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === a2.EXPANSION_CASE_EXP_START;
            }
            _isInExpansionForm() {
              return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === a2.EXPANSION_FORM_START;
            }
            isExpansionFormStart() {
              if (this._cursor.peek() !== n2.$LBRACE)
                return false;
              if (this._interpolationConfig) {
                const e3 = this._cursor.clone(), t2 = this._attemptStr(this._interpolationConfig.start);
                return this._cursor = e3, !t2;
              }
              return true;
            }
            _handleFullNameStackForTagOpen(e3, t2) {
              const r2 = o2.mergeNsAndName(e3, t2);
              this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] !== r2 || this._fullNameStack.push(r2);
            }
            _handleFullNameStackForTagClose(e3, t2) {
              const r2 = o2.mergeNsAndName(e3, t2);
              this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r2 && this._fullNameStack.pop();
            }
          }
          function g2(e3) {
            return !n2.isWhitespace(e3) || e3 === n2.$EOF;
          }
          function m2(e3) {
            return n2.isWhitespace(e3) || e3 === n2.$GT || e3 === n2.$SLASH || e3 === n2.$SQ || e3 === n2.$DQ || e3 === n2.$EQ;
          }
          function E2(e3) {
            return e3 == n2.$SEMICOLON || e3 == n2.$EOF || !n2.isAsciiHexDigit(e3);
          }
          function C2(e3) {
            return e3 == n2.$SEMICOLON || e3 == n2.$EOF || !n2.isAsciiLetter(e3);
          }
          function y2(e3) {
            return e3 >= n2.$a && e3 <= n2.$z ? e3 - n2.$a + n2.$A : e3;
          }
          class b2 {
            constructor(e3, t2) {
              if (e3 instanceof b2)
                this.file = e3.file, this.input = e3.input, this.end = e3.end, this.state = Object.assign({}, e3.state);
              else {
                if (!t2)
                  throw new Error("Programming error: the range argument must be provided with a file argument.");
                this.file = e3, this.input = e3.content, this.end = t2.endPos, this.state = { peek: -1, offset: t2.startPos, line: t2.startLine, column: t2.startCol };
              }
            }
            clone() {
              return new b2(this);
            }
            peek() {
              return this.state.peek;
            }
            charsLeft() {
              return this.end - this.state.offset;
            }
            diff(e3) {
              return this.state.offset - e3.state.offset;
            }
            advance() {
              this.advanceState(this.state);
            }
            init() {
              this.updatePeek(this.state);
            }
            getSpan(e3, t2) {
              if (e3 = e3 || this, t2)
                for (e3 = e3.clone(); this.diff(e3) > 0 && t2.indexOf(e3.peek()) !== -1; )
                  e3.advance();
              return new i2.ParseSourceSpan(new i2.ParseLocation(e3.file, e3.state.offset, e3.state.line, e3.state.column), new i2.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
            }
            getChars(e3) {
              return this.input.substring(e3.state.offset, this.state.offset);
            }
            charAt(e3) {
              return this.input.charCodeAt(e3);
            }
            advanceState(e3) {
              if (e3.offset >= this.end)
                throw this.state = e3, new T2('Unexpected character "EOF"', this);
              const t2 = this.charAt(e3.offset);
              t2 === n2.$LF ? (e3.line++, e3.column = 0) : n2.isNewLine(t2) || e3.column++, e3.offset++, this.updatePeek(e3);
            }
            updatePeek(e3) {
              e3.peek = e3.offset >= this.end ? n2.$EOF : this.charAt(e3.offset);
            }
          }
          class S2 extends b2 {
            constructor(e3, t2) {
              e3 instanceof S2 ? (super(e3), this.internalState = Object.assign({}, e3.internalState)) : (super(e3, t2), this.internalState = this.state);
            }
            advance() {
              this.state = this.internalState, super.advance(), this.processEscapeSequence();
            }
            init() {
              super.init(), this.processEscapeSequence();
            }
            clone() {
              return new S2(this);
            }
            getChars(e3) {
              const t2 = e3.clone();
              let r2 = "";
              for (; t2.internalState.offset < this.internalState.offset; )
                r2 += String.fromCodePoint(t2.peek()), t2.advance();
              return r2;
            }
            processEscapeSequence() {
              const e3 = () => this.internalState.peek;
              if (e3() === n2.$BACKSLASH)
                if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), e3() === n2.$n)
                  this.state.peek = n2.$LF;
                else if (e3() === n2.$r)
                  this.state.peek = n2.$CR;
                else if (e3() === n2.$v)
                  this.state.peek = n2.$VTAB;
                else if (e3() === n2.$t)
                  this.state.peek = n2.$TAB;
                else if (e3() === n2.$b)
                  this.state.peek = n2.$BSPACE;
                else if (e3() === n2.$f)
                  this.state.peek = n2.$FF;
                else if (e3() === n2.$u)
                  if (this.advanceState(this.internalState), e3() === n2.$LBRACE) {
                    this.advanceState(this.internalState);
                    const t2 = this.clone();
                    let r2 = 0;
                    for (; e3() !== n2.$RBRACE; )
                      this.advanceState(this.internalState), r2++;
                    this.state.peek = this.decodeHexDigits(t2, r2);
                  } else {
                    const e4 = this.clone();
                    this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e4, 4);
                  }
                else if (e3() === n2.$x) {
                  this.advanceState(this.internalState);
                  const e4 = this.clone();
                  this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e4, 2);
                } else if (n2.isOctalDigit(e3())) {
                  let t2 = "", r2 = 0, i3 = this.clone();
                  for (; n2.isOctalDigit(e3()) && r2 < 3; )
                    i3 = this.clone(), t2 += String.fromCodePoint(e3()), this.advanceState(this.internalState), r2++;
                  this.state.peek = parseInt(t2, 8), this.internalState = i3.internalState;
                } else
                  n2.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
            }
            decodeHexDigits(e3, t2) {
              const r2 = this.input.substr(e3.internalState.offset, t2), n3 = parseInt(r2, 16);
              if (isNaN(n3))
                throw e3.state = e3.internalState, new T2("Invalid hexadecimal escape sequence", e3);
              return n3;
            }
          }
          class T2 {
            constructor(e3, t2) {
              this.msg = e3, this.cursor = t2;
            }
          }
          e2.CursorError = T2;
        }(cl), Object.defineProperty(tl, "__esModule", { value: true });
        const Dl = t, fl = rl, dl = cl, gl = Qc;
        class ml extends Dl.ParseError {
          constructor(e2, t2, r2) {
            super(t2, r2), this.elementName = e2;
          }
          static create(e2, t2, r2) {
            return new ml(e2, t2, r2);
          }
        }
        tl.TreeError = ml;
        class El {
          constructor(e2, t2) {
            this.rootNodes = e2, this.errors = t2;
          }
        }
        tl.ParseTreeResult = El;
        tl.Parser = class {
          constructor(e2) {
            this.getTagDefinition = e2;
          }
          parse(e2, t2, r2) {
            let n2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3], i2 = arguments.length > 4 ? arguments[4] : void 0;
            const s2 = (e3) => function(t3) {
              for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), i3 = 1; i3 < r3; i3++)
                n3[i3 - 1] = arguments[i3];
              return e3(t3.toLowerCase(), ...n3);
            }, o2 = n2 ? this.getTagDefinition : s2(this.getTagDefinition), a2 = (e3) => o2(e3).contentType, u2 = n2 ? i2 : s2(i2), c2 = i2 ? (e3, t3, r3, n3) => {
              const i3 = u2(e3, t3, r3, n3);
              return i3 !== void 0 ? i3 : a2(e3);
            } : a2, l2 = dl.tokenize(e2, t2, c2, r2), p2 = r2 && r2.canSelfClose || false, h2 = r2 && r2.allowHtmComponentClosingTags || false, D2 = new Cl(l2.tokens, o2, p2, h2, n2).build();
            return new El(D2.rootNodes, l2.errors.concat(D2.errors));
          }
        };
        class Cl {
          constructor(e2, t2, r2, n2, i2) {
            this.tokens = e2, this.getTagDefinition = t2, this.canSelfClose = r2, this.allowHtmComponentClosingTags = n2, this.isTagNameCaseSensitive = i2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
          }
          build() {
            for (; this._peek.type !== dl.TokenType.EOF; )
              this._peek.type === dl.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === dl.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === dl.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === dl.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === dl.TokenType.TEXT || this._peek.type === dl.TokenType.RAW_TEXT || this._peek.type === dl.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === dl.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === dl.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
            return new El(this._rootNodes, this._errors);
          }
          _advance() {
            const e2 = this._peek;
            return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e2;
          }
          _advanceIf(e2) {
            return this._peek.type === e2 ? this._advance() : null;
          }
          _consumeCdata(e2) {
            const t2 = this._advance(), r2 = this._getText(t2), n2 = this._advanceIf(dl.TokenType.CDATA_END);
            this._addToParent(new fl.CDATA(r2, new Dl.ParseSourceSpan(e2.sourceSpan.start, (n2 || t2).sourceSpan.end)));
          }
          _consumeComment(e2) {
            const t2 = this._advanceIf(dl.TokenType.RAW_TEXT), r2 = this._advanceIf(dl.TokenType.COMMENT_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new Dl.ParseSourceSpan(e2.sourceSpan.start, (r2 || t2 || e2).sourceSpan.end);
            this._addToParent(new fl.Comment(n2, i2));
          }
          _consumeDocType(e2) {
            const t2 = this._advanceIf(dl.TokenType.RAW_TEXT), r2 = this._advanceIf(dl.TokenType.DOC_TYPE_END), n2 = t2 != null ? t2.parts[0].trim() : null, i2 = new Dl.ParseSourceSpan(e2.sourceSpan.start, (r2 || t2 || e2).sourceSpan.end);
            this._addToParent(new fl.DocType(n2, i2));
          }
          _consumeExpansion(e2) {
            const t2 = this._advance(), r2 = this._advance(), n2 = [];
            for (; this._peek.type === dl.TokenType.EXPANSION_CASE_VALUE; ) {
              const e3 = this._parseExpansionCase();
              if (!e3)
                return;
              n2.push(e3);
            }
            if (this._peek.type !== dl.TokenType.EXPANSION_FORM_END)
              return void this._errors.push(ml.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
            const i2 = new Dl.ParseSourceSpan(e2.sourceSpan.start, this._peek.sourceSpan.end);
            this._addToParent(new fl.Expansion(t2.parts[0], r2.parts[0], n2, i2, t2.sourceSpan)), this._advance();
          }
          _parseExpansionCase() {
            const e2 = this._advance();
            if (this._peek.type !== dl.TokenType.EXPANSION_CASE_EXP_START)
              return this._errors.push(ml.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
            const t2 = this._advance(), r2 = this._collectExpansionExpTokens(t2);
            if (!r2)
              return null;
            const n2 = this._advance();
            r2.push(new dl.Token(dl.TokenType.EOF, [], n2.sourceSpan));
            const i2 = new Cl(r2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
            if (i2.errors.length > 0)
              return this._errors = this._errors.concat(i2.errors), null;
            const s2 = new Dl.ParseSourceSpan(e2.sourceSpan.start, n2.sourceSpan.end), o2 = new Dl.ParseSourceSpan(t2.sourceSpan.start, n2.sourceSpan.end);
            return new fl.ExpansionCase(e2.parts[0], i2.rootNodes, s2, e2.sourceSpan, o2);
          }
          _collectExpansionExpTokens(e2) {
            const t2 = [], r2 = [dl.TokenType.EXPANSION_CASE_EXP_START];
            for (; ; ) {
              if (this._peek.type !== dl.TokenType.EXPANSION_FORM_START && this._peek.type !== dl.TokenType.EXPANSION_CASE_EXP_START || r2.push(this._peek.type), this._peek.type === dl.TokenType.EXPANSION_CASE_EXP_END) {
                if (!yl(r2, dl.TokenType.EXPANSION_CASE_EXP_START))
                  return this._errors.push(ml.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                if (r2.pop(), r2.length == 0)
                  return t2;
              }
              if (this._peek.type === dl.TokenType.EXPANSION_FORM_END) {
                if (!yl(r2, dl.TokenType.EXPANSION_FORM_START))
                  return this._errors.push(ml.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                r2.pop();
              }
              if (this._peek.type === dl.TokenType.EOF)
                return this._errors.push(ml.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
              t2.push(this._advance());
            }
          }
          _getText(e2) {
            let t2 = e2.parts[0];
            if (t2.length > 0 && t2[0] == "\n") {
              const e3 = this._getParentElement();
              e3 != null && e3.children.length == 0 && this.getTagDefinition(e3.name).ignoreFirstLf && (t2 = t2.substring(1));
            }
            return t2;
          }
          _consumeText(e2) {
            const t2 = this._getText(e2);
            t2.length > 0 && this._addToParent(new fl.Text(t2, e2.sourceSpan));
          }
          _closeVoidElement() {
            const e2 = this._getParentElement();
            e2 && this.getTagDefinition(e2.name).isVoid && this._elementStack.pop();
          }
          _consumeStartTag(e2) {
            const t2 = e2.parts[0], r2 = e2.parts[1], n2 = [];
            for (; this._peek.type === dl.TokenType.ATTR_NAME; )
              n2.push(this._consumeAttr(this._advance()));
            const i2 = this._getElementFullName(t2, r2, this._getParentElement());
            let s2 = false;
            if (this._peek.type === dl.TokenType.TAG_OPEN_END_VOID) {
              this._advance(), s2 = true;
              const t3 = this.getTagDefinition(i2);
              this.canSelfClose || t3.canSelfClose || gl.getNsPrefix(i2) !== null || t3.isVoid || this._errors.push(ml.create(i2, e2.sourceSpan, 'Only void and foreign elements can be self closed "'.concat(e2.parts[1], '"')));
            } else
              this._peek.type === dl.TokenType.TAG_OPEN_END && (this._advance(), s2 = false);
            const o2 = this._peek.sourceSpan.start, a2 = new Dl.ParseSourceSpan(e2.sourceSpan.start, o2), u2 = new Dl.ParseSourceSpan(e2.sourceSpan.start.moveBy(1), e2.sourceSpan.end), c2 = new fl.Element(i2, n2, [], a2, a2, void 0, u2);
            this._pushElement(c2), s2 && (this._popElement(i2), c2.endSourceSpan = a2);
          }
          _pushElement(e2) {
            const t2 = this._getParentElement();
            t2 && this.getTagDefinition(t2.name).isClosedByChild(e2.name) && this._elementStack.pop(), this._addToParent(e2), this._elementStack.push(e2);
          }
          _consumeEndTag(e2) {
            const t2 = this.allowHtmComponentClosingTags && e2.parts.length === 0 ? null : this._getElementFullName(e2.parts[0], e2.parts[1], this._getParentElement());
            if (this._getParentElement() && (this._getParentElement().endSourceSpan = e2.sourceSpan), t2 && this.getTagDefinition(t2).isVoid)
              this._errors.push(ml.create(t2, e2.sourceSpan, 'Void elements do not have end tags "'.concat(e2.parts[1], '"')));
            else if (!this._popElement(t2)) {
              const r2 = 'Unexpected closing tag "'.concat(t2, '". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags');
              this._errors.push(ml.create(t2, e2.sourceSpan, r2));
            }
          }
          _popElement(e2) {
            for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
              const r2 = this._elementStack[t2];
              if (!e2 || (gl.getNsPrefix(r2.name) ? r2.name == e2 : r2.name.toLowerCase() == e2.toLowerCase()))
                return this._elementStack.splice(t2, this._elementStack.length - t2), true;
              if (!this.getTagDefinition(r2.name).closedByParent)
                return false;
            }
            return false;
          }
          _consumeAttr(e2) {
            const t2 = gl.mergeNsAndName(e2.parts[0], e2.parts[1]);
            let r2, n2, i2 = e2.sourceSpan.end, s2 = "";
            if (this._peek.type === dl.TokenType.ATTR_QUOTE) {
              n2 = this._advance().sourceSpan.start;
            }
            if (this._peek.type === dl.TokenType.ATTR_VALUE) {
              const e3 = this._advance();
              s2 = e3.parts[0], i2 = e3.sourceSpan.end, r2 = e3.sourceSpan;
            }
            if (this._peek.type === dl.TokenType.ATTR_QUOTE) {
              i2 = this._advance().sourceSpan.end, r2 = new Dl.ParseSourceSpan(n2, i2);
            }
            return new fl.Attribute(t2, s2, new Dl.ParseSourceSpan(e2.sourceSpan.start, i2), r2, e2.sourceSpan);
          }
          _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
          }
          _getParentElementSkippingContainers() {
            let e2 = null;
            for (let t2 = this._elementStack.length - 1; t2 >= 0; t2--) {
              if (!gl.isNgContainer(this._elementStack[t2].name))
                return { parent: this._elementStack[t2], container: e2 };
              e2 = this._elementStack[t2];
            }
            return { parent: null, container: e2 };
          }
          _addToParent(e2) {
            const t2 = this._getParentElement();
            t2 != null ? t2.children.push(e2) : this._rootNodes.push(e2);
          }
          _insertBeforeContainer(e2, t2, r2) {
            if (t2) {
              if (e2) {
                const n2 = e2.children.indexOf(t2);
                e2.children[n2] = r2;
              } else
                this._rootNodes.push(r2);
              r2.children.push(t2), this._elementStack.splice(this._elementStack.indexOf(t2), 0, r2);
            } else
              this._addToParent(r2), this._elementStack.push(r2);
          }
          _getElementFullName(e2, t2, r2) {
            return e2 === "" && (e2 = this.getTagDefinition(t2).implicitNamespacePrefix || "") === "" && r2 != null && (e2 = gl.getNsPrefix(r2.name)), gl.mergeNsAndName(e2, t2);
          }
        }
        function yl(e2, t2) {
          return e2.length > 0 && e2[e2.length - 1] === t2;
        }
        Object.defineProperty(Wc, "__esModule", { value: true });
        const bl = Yc, Sl = tl;
        var Tl = tl;
        Wc.ParseTreeResult = Tl.ParseTreeResult, Wc.TreeError = Tl.TreeError;
        class _l extends Sl.Parser {
          constructor() {
            super(bl.getHtmlTagDefinition);
          }
          parse(e2, t2, r2) {
            let n2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3], i2 = arguments.length > 4 ? arguments[4] : void 0;
            return super.parse(e2, t2, r2, n2, i2);
          }
        }
        Wc.HtmlParser = _l, Object.defineProperty(zc, "__esModule", { value: true });
        const vl = Wc, Al = Qc;
        zc.TagContentType = Al.TagContentType;
        let Fl = null;
        const wl = () => (Fl || (Fl = new vl.HtmlParser()), Fl);
        zc.parse = function(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const { canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: i2 = false, getTagContentType: s2 } = t2;
          return wl().parse(e2, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: r2, allowHtmComponentClosingTags: n2 }, i2, s2);
        };
        const { ParseSourceSpan: kl, ParseLocation: Nl, ParseSourceFile: Ol } = t, xl = E, Il = C, Pl = y, { inferParserByLanguage: Rl } = Ja, { HTML_ELEMENT_ATTRIBUTES: Ll, HTML_TAGS: Bl, isUnknownNamespace: ql } = Pc, { hasPragma: $l } = Rc, { Node: Ml } = Uc, { parseIeConditionalComment: jl } = Xc, { locStart: Ul, locEnd: Gl } = Hc;
        function Vl(e2, r2, n2) {
          let { recognizeSelfClosing: i2, normalizeTagName: s2, normalizeAttributeName: o2, allowHtmComponentClosingTags: a2, isTagNameCaseSensitive: u2, getTagContentType: c2 } = r2;
          const l2 = zc, { RecursiveVisitor: p2, visitAll: h2 } = rl, { ParseSourceSpan: D2 } = t, { getHtmlTagDefinition: f2 } = Yc;
          let { rootNodes: d2, errors: g2 } = l2.parse(e2, { canSelfClose: i2, allowHtmComponentClosingTags: a2, isTagNameCaseSensitive: u2, getTagContentType: c2 });
          if (n2.parser === "vue") {
            if (d2.some((e3) => e3.type === "docType" && e3.value === "html" || e3.type === "element" && e3.name.toLowerCase() === "html")) {
              i2 = true, s2 = true, o2 = true, a2 = true, u2 = false;
              const t2 = l2.parse(e2, { canSelfClose: i2, allowHtmComponentClosingTags: a2, isTagNameCaseSensitive: u2 });
              d2 = t2.rootNodes, g2 = t2.errors;
            } else {
              const t2 = (e3) => {
                if (!e3)
                  return false;
                if (e3.type !== "element" || e3.name !== "template")
                  return false;
                const t3 = e3.attrs.find((e4) => e4.name === "lang"), r3 = t3 && t3.value;
                return !r3 || Rl(r3, n2) === "html";
              };
              if (d2.some(t2)) {
                let r3;
                const n3 = () => l2.parse(e2, { canSelfClose: i2, allowHtmComponentClosingTags: a2, isTagNameCaseSensitive: u2 }), s3 = () => r3 || (r3 = n3()), o3 = (e3) => s3().rootNodes.find((t3) => {
                  let { startSourceSpan: r4 } = t3;
                  return r4 && r4.start.offset === e3.startSourceSpan.start.offset;
                });
                for (let e3 = 0; e3 < d2.length; e3++) {
                  const r4 = d2[e3], { endSourceSpan: n4, startSourceSpan: i3 } = r4;
                  if (n4 === null) {
                    g2 = s3().errors, d2[e3] = o3(r4) || r4;
                  } else if (t2(r4)) {
                    const t3 = s3(), a3 = i3.end.offset, u3 = n4.start.offset;
                    for (const e4 of t3.errors) {
                      const { offset: t4 } = e4.span.start;
                      if (a3 < t4 && t4 < u3) {
                        g2 = [e4];
                        break;
                      }
                    }
                    d2[e3] = o3(r4) || r4;
                  }
                }
              }
            }
          }
          if (g2.length > 0) {
            const { msg: e3, span: { start: t2, end: r3 } } = g2[0];
            throw Pl(e3, { start: { line: t2.line + 1, column: t2.col + 1 }, end: { line: r3.line + 1, column: r3.col + 1 } });
          }
          const m2 = (e3) => {
            const t2 = e3.name.startsWith(":") ? e3.name.slice(1).split(":")[0] : null, r3 = e3.nameSpan.toString(), n3 = t2 !== null && r3.startsWith("".concat(t2, ":")), i3 = n3 ? r3.slice(t2.length + 1) : r3;
            e3.name = i3, e3.namespace = t2, e3.hasExplicitNamespace = n3;
          }, E2 = (e3, t2) => {
            const r3 = e3.toLowerCase();
            return t2(r3) ? r3 : e3;
          };
          return h2(new class extends p2 {
            visit(e3) {
              ((e4) => {
                if (e4.type === "element") {
                  m2(e4);
                  for (const t2 of e4.attrs)
                    m2(t2), t2.valueSpan ? (t2.value = t2.valueSpan.toString(), /["']/.test(t2.value[0]) && (t2.value = t2.value.slice(1, -1))) : t2.value = null;
                } else
                  e4.type === "comment" ? e4.value = e4.sourceSpan.toString().slice("<!--".length, -"-->".length) : e4.type === "text" && (e4.value = e4.sourceSpan.toString());
              })(e3), ((e4) => {
                if (e4.type === "element") {
                  const t2 = f2(u2 ? e4.name : e4.name.toLowerCase());
                  !e4.namespace || e4.namespace === t2.implicitNamespacePrefix || ql(e4) ? e4.tagDefinition = t2 : e4.tagDefinition = f2("");
                }
              })(e3), ((e4) => {
                if (e4.type === "element" && (!s2 || e4.namespace && e4.namespace !== e4.tagDefinition.implicitNamespacePrefix && !ql(e4) || (e4.name = E2(e4.name, (e5) => e5 in Bl)), o2)) {
                  const t2 = Ll[e4.name] || /* @__PURE__ */ Object.create(null);
                  for (const r3 of e4.attrs)
                    r3.namespace || (r3.name = E2(r3.name, (r4) => e4.name in Ll && (r4 in Ll["*"] || r4 in t2)));
                }
              })(e3), ((e4) => {
                e4.sourceSpan && e4.endSourceSpan && (e4.sourceSpan = new D2(e4.sourceSpan.start, e4.endSourceSpan.end));
              })(e3);
            }
          }(), d2), d2;
        }
        function Xl(e2, t2, r2) {
          let n2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
          const { frontMatter: i2, content: s2 } = n2 ? xl(e2) : { frontMatter: null, content: e2 }, o2 = new Ol(e2, t2.filepath), a2 = new Nl(o2, 0, 0, 0), u2 = a2.moveBy(e2.length), c2 = { type: "root", sourceSpan: new kl(a2, u2), children: Vl(s2, r2, t2) };
          if (i2) {
            const e3 = new Nl(o2, 0, 0, 0), t3 = e3.moveBy(i2.raw.length);
            i2.sourceSpan = new kl(e3, t3), c2.children.unshift(i2);
          }
          const l2 = new Ml(c2), p2 = (n3, i3) => {
            const { offset: s3 } = i3, o3 = Xl(e2.slice(0, s3).replace(/[^\n\r]/g, " ") + n3, t2, r2, false);
            o3.sourceSpan = new kl(i3, Il(o3.children).sourceSpan.end);
            const a3 = o3.children[0];
            return a3.length === s3 ? o3.children.shift() : (a3.sourceSpan = new kl(a3.sourceSpan.start.moveBy(s3), a3.sourceSpan.end), a3.value = a3.value.slice(s3)), o3;
          };
          return l2.map((e3) => {
            if (e3.type === "comment") {
              const t3 = jl(e3, p2);
              if (t3)
                return t3;
            }
            return e3;
          });
        }
        function Hl() {
          let { name: e2, recognizeSelfClosing: t2 = false, normalizeTagName: r2 = false, normalizeAttributeName: n2 = false, allowHtmComponentClosingTags: i2 = false, isTagNameCaseSensitive: s2 = false, getTagContentType: o2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return { parse: (a2, u2, c2) => Xl(a2, Object.assign({ parser: e2 }, c2), { recognizeSelfClosing: t2, normalizeTagName: r2, normalizeAttributeName: n2, allowHtmComponentClosingTags: i2, isTagNameCaseSensitive: s2, getTagContentType: o2 }), hasPragma: $l, astFormat: "html", locStart: Ul, locEnd: Gl };
        }
        var zl = { parsers: { html: Hl({ name: "html", recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: Hl({ name: "angular" }), vue: Hl({ name: "vue", recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e2, t2, r2, n2) => {
          if (e2.toLowerCase() !== "html" && !r2 && (e2 !== "template" || n2.some((e3) => {
            let { name: t3, value: r3 } = e3;
            return t3 === "lang" && r3 !== "html";
          })))
            return zc.TagContentType.RAW_TEXT;
        } }), lwc: Hl({ name: "lwc" }) } };
        return zl;
      });
    }
  });

  // ../../node_modules/comlink/dist/esm/comlink.mjs
  var proxyMarker = Symbol("Comlink.proxy");
  var createEndpoint = Symbol("Comlink.endpoint");
  var releaseProxy = Symbol("Comlink.releaseProxy");
  var throwMarker = Symbol("Comlink.thrown");
  var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
  var proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap(port);
    }
  };
  var throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  var transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function expose(obj, ep = self) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      const { id, type, path } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value = new rawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
        }
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap(ep, target) {
    return createProxy(ep, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function createProxy(ep, path = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            return requestResponseMessage(ep, {
              type: "RELEASE",
              path: path.map((p) => p.toString())
            }).then(() => {
              closeEndPoint(ep);
              isProxyReleased = true;
            });
          };
        }
        if (prop === "then") {
          if (path.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, {
            type: "GET",
            path: path.map((p) => p.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, [...path, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, {
          type: "SET",
          path: [...path, prop].map((p) => p.toString()),
          value
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path[path.length - 1];
        if (last === createEndpoint) {
          return requestResponseMessage(ep, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last === "bind") {
          return createProxy(ep, path.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, {
          type: "APPLY",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, {
          type: "CONSTRUCT",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  var transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function windowEndpoint(w, context = self, targetOrigin = "*") {
    return {
      postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
      addEventListener: context.addEventListener.bind(context),
      removeEventListener: context.removeEventListener.bind(context)
    };
  }
  function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const [serializedValue, transferables] = handler.serialize(value);
        return [
          {
            type: "HANDLER",
            name,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value
      },
      transferCache.get(value) || []
    ];
  }
  function fromWireValue(value) {
    switch (value.type) {
      case "HANDLER":
        return transferHandlers.get(value.name).deserialize(value.value);
      case "RAW":
        return value.value;
    }
  }
  function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
      const id = generateUUID();
      ep.addEventListener("message", function l(ev) {
        if (!ev.data || !ev.data.id || ev.data.id !== id) {
          return;
        }
        ep.removeEventListener("message", l);
        resolve(ev.data);
      });
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }

  // js/workers/prettier.worker.js
  var import_standalone = __toESM(require_standalone());
  var import_parser_babel = __toESM(require_parser_babel());
  var import_parser_html = __toESM(require_parser_html());
  function formatter(code) {
    const formatted = import_standalone.default.format(code, {
      arrowParens: "always",
      bracketSpacing: true,
      embeddedLanguageFormatting: "auto",
      htmlWhitespaceSensitivity: "css",
      insertPragma: false,
      bracketSameLine: true,
      jsxSingleQuote: false,
      printWidth: 90,
      proseWrap: "preserve",
      quoteProps: "as-needed",
      requirePragma: false,
      semi: true,
      singleQuote: true,
      tabWidth: 2,
      trailingComma: "all",
      useTabs: false,
      parser: "babel-ts",
      plugins: [import_parser_babel.default, import_parser_html.default]
    });
    return formatted;
  }
  self.addEventListener("connect", (e) => expose(formatter, e.ports[0]));
  self.addEventListener("message", (event) => {
    if (event.data.comlinkInit) {
      expose(formatter, event.data.port);
    }
  });
})();
//# sourceMappingURL=prettier.worker.js.map

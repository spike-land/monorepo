{
  "version": 3,
  "sources": ["../quickStart.mjs", "../ws.mjs"],
  "sourcesContent": ["import { jsx } from \"@emotion/react\";\n\nlet formatter;\nlet transform;\n\nlet esbuildEsmTransform;\n// Let esbuildTransform;\n// let babelTransform;\nlet getHtmlAndCss;\nlet initSess;\n\nexport const initSession = async (room, initData) => {\n  initSess = initSess || (await import(\"./session\")).default;\n\n  return initSess(room, initData);\n};\n\nexport const prettier = async (code) => {\n  formatter = formatter || (await import(\"./formatter.mjs\")).formatter;\n  return await formatter(code);\n};\n\n// //\n\nexport async function startMonacoWithSession(session) {\n  const shadDom = document.querySelector(\"#shadowEditor\");\n\n  const { startMonaco } = await import(\"./editor.ts\");\n  const throttle = (await import(\"lodash/throttle\")).default;\n  const onchangeCode = (code, changes) =>\n    runner(code, changes, session, ++session.i);\n  const { editor, monaco } = await startMonaco(\n    /**\n     * @param {any} code\n     */\n    {\n      language: \"typescript\",\n      container: shadDom,\n      code: session.code,\n      /**\n       * @param {string} code\n       */\n    },\n  );\n\n  editor.onDidChangeModelContent(throttle(onchangeCode, 100));\n\n  window.monaco = monaco;\n  session.editor = editor;\n\n  monaco.languages.registerOnTypeFormattingEditProvider(\"typescript\", {\n    autoFormatTriggerCharacters: [\"}\", \"{\", \")\", \"(\", \";\"],\n\n    async provideOnTypeFormattingEdits(model) {\n      const text = await formatter(model.getValue());\n\n      return [\n        {\n          range: model.getFullModelRange(),\n\n          text,\n        },\n      ];\n    },\n  });\n\n  window.sess = session;\n}\n\nasync function getErrors({ monaco, editor }) {\n  if (!monaco) {\n    return [{ messageText: \"Error with the error checking. Try to reload!\" }];\n  }\n\n  const model = editor.getModels()[0];\n  const worker = await monaco.languages.typescript.getTypeScriptWorker();\n  const client = await worker(model);\n\n  const filename = model.uri.toString();\n  const diag = client.getSemanticDiagnostics(filename);\n  const comp = client.getCompilerOptionsDiagnostics(filename);\n  const syntax = client.getSyntacticDiagnostics(filename);\n  const fastError = await Promise.race([diag, comp, syntax]);\n\n  // Model.dispose();\n  console.log(fastError);\n  return [];\n}\n\n// Let getHtmlAndCss;\n\nasync function runner(c, changes = null, session, counter) {\n  // If (!esbuildEsmTransform || !formatter ) session.broad({...session, code: c, errorText: \"PRE\" })\n\n  session.changes.push(changes);\n  formatter = formatter || (await import(\"./formatter.mjs\")).formatter;\n  esbuildEsmTransform = esbuildEsmTransform ||\n    (await import(\"./esbuildEsm.mjs\")).transform;\n\n  transform = esbuildEsmTransform;\n\n  session.errorText = \"\";\n\n  const { monaco } = session;\n\n  try {\n    const cd = await formatter(c);\n\n    const transpiled = await transform(cd);\n\n    let restartError = false;\n    /// yellow\n    if (transpiled.length > 0) {\n      if (counter < session.i) {\n        return;\n      }\n\n      try {\n        getHtmlAndCss = getHtmlAndCss ||\n          (await import(\"./renderToString\")).getHtmlAndCss;\n\n        if (counter < session.i) {\n          return;\n        }\n\n        const App = await getApp(transpiled);\n        const { html, css } = getHtmlAndCss(App);\n\n        session.transpiled = transpiled;\n        session.html = html;\n\n        const children = await getReactChild(transpiled);\n\n        // Session.html = zbody.innerHTML;\n\n        session.setChild((c) => [...c, children]);\n        session.children = children;\n        restartError = !html;\n        session.code = cd;\n        session.codeNonFormatted = c;\n        // GetCss = getCss || (await import(\"./templates.ts\")).getCss;\n        // setTimeout(async () => {\n        //     session.html = document.getElementById(\"zbody\").innerHTML;\n        // const css = getCss(session);\n        const code = cd;\n        session.css = css;\n        if (session.i !== counter) {\n          return;\n        }\n\n        session.saveCode &&\n          await session.saveCode({ transpiled, code, i: counter, css, html });\n        monaco.editor.setTheme(\"vs-dark\");\n        // }, 10);\n        return;\n      } catch (error) {\n        console.error(\"EXCEPTION\");\n        console.log({ e: error });\n        restartError = true;\n        console.error({ restartError });\n      }\n    }\n\n    if (session.i > counter) {\n      return;\n    }\n\n    const error = await getErrors(session);\n    if (session.i > counter) {\n      return;\n    }\n\n    if (restartError) {\n      error.push(\n        { messageText: \"Error while starting the app. Check the console!\" },\n      );\n    }\n\n    if (error.length > 0) {\n      console.log({ err: error });\n    }\n\n    monaco.editor.setTheme(\"vs-dark\");\n  } catch (error) {\n    monaco.editor.setTheme(\"vs-light\");\n    setTimeout(() => {\n      monaco.editor.setTheme(\"hc-black\");\n    }, 50);\n    session.errorText = error.message;\n    console.error(error.message);\n  }\n}\n\nexport const startFromCode = async ({ code }) => {\n  const session = {\n    code,\n    i: 0,\n    changes: [],\n    saveCode: () => {},\n    setChild: () => {},\n  };\n  await runner(code, null, session);\n  await quickStart(session);\n};\n\nexport async function quickStart(session, room, keepFullScreen, saveCode) {\n  session.saveCode = saveCode;\n  // Session.children = await getReactChild(session.transpiled);\n  session.children = null;\n  const { renderPreviewWindow } = await import(\n    \"./renderPreviewWindow\"\n  );\n\n  await renderPreviewWindow(session, room, keepFullScreen);\n\n  // If (localStorage && session) {\n  //   const { code, transpiled, html, css, i } = session;\n  //   localStorage.setItem(\n  //     `state-${session.room}`,\n  //     JSON.stringify({ code, transpiled, html, css, i }),\n  //   );\n  // }\n  // // document.getElementById(\"root\").remove();\n\n  if (!keepFullScreen) {\n    await startMonacoWithSession(session);\n  }\n\n  session.update = (c) => runner(c, null, session);\n  runner(session.code, null, session, -1);\n}\n\nasync function getReactChild(transpiled, mode = \"window\") {\n  const codeToHydrate = mode === \"window\"\n    ? transpiled.replace(\"body{\", \"#zbody{\")\n    : transpiled;\n\n  const objectUrl = createJsBlob(\n    codeToHydrate,\n  );\n\n  const mod = (await import(objectUrl));\n  URL.revokeObjectURL(objectUrl);\n\n  return jsx(mod.default);\n}\n\n// Function createPatch(oldCode, newCode, createDelta) {\n//   return JSON.stringify(createDelta(oldCode, newCode));\n// }\n\n/**\n * @param {BlobPart} code\n */\nfunction createJsBlob(code) {\n  const blob = new Blob([code], { type: \"application/javascript\" });\n\n  return URL.createObjectURL(blob);\n}\n\nasync function getApp(transpiled, mode = \"window\") {\n  const codeToHydrate = mode === \"window\"\n    ? transpiled.replace(\"body{\", \"#zbody{\")\n    : transpiled;\n\n  const objectUrl = createJsBlob(\n    codeToHydrate,\n  );\n\n  const App = (await import(objectUrl)).default;\n\n  URL.revokeObjectURL(objectUrl);\n\n  return App;\n}\n", "/*eslint-disable */\n\n/* eslint-enable */\n\n// import initSession from \"./dist/session.mjs\";\n\nimport { initSession, quickStart } from \"./quickStart.mjs\";\n\nlet currentWebSocket = null;\nlet sess = false;\n// Let sanyiProcess = null;\n\nconst webRtcArray = [];\nconst hostname = \"spike.land\";\nconst mod = {};\n\nlet wsLastHashCode = \"\";\nlet webRTCLastSeenHashCode = \"\";\nlet roomName = \"\";\nlet username = \"\";\nlet lastSeenTimestamp = 0;\nlet lastSeenNow = 0;\nlet ws;\nlet chCode;\nlet startTime;\nlet rejoined = false;\nlet sendChannel;\nlet deltaSent = \"\";\n// Let createDelta;\n// let applyPatch;\nlet mySession = null;\nconst mST = () => mySession.session.get(\"state\");\n\nlet intervalHandler = null;\n\n// Function createPatch(oldCode, newCode) {\n//   return JSON.stringify(createDelta(oldCode, newCode));\n// }\n\n// let importTools = async () => {\n// if (toolsImported) return toolsImported;\n\n// import(\"textdiff-create\").then((mod) => createDelta = mod.default);\n// import(\"textdiff-patch\").then((mod) => applyPatch = mod.default);\n\n// toolsImported = true;\n// return toolsImported;\n// };\nsetInterval(() => {\n  if (Date.now() - lastSeenNow > 40_000) {\n    rejoin();\n  } else {\n    console.log(\"no_need_to_rejoin\");\n  }\n}, 30_000);\n\nchCode = globalThis.chCode = async (code, i) => {\n  if (!code) {\n    return;\n  }\n\n  if (i < window.sess.i) {\n    return;\n  }\n\n  if (code === window.sess.code) {\n    return;\n  }\n\n  try {\n    if (window.sess && window.sess.editor) {\n      window.sess.editor.getModel().setValue(code);\n    } else {\n      window.sess.update(code);\n    }\n  } catch (error) {\n    console.error({ e: error });\n  }\n};\n\nasync function rejoin() {\n  if (!rejoined) {\n    rejoined = true;\n    currentWebSocket = null;\n    // MySession.addEvent({\n    //   type: \"joined\"\n    // });\n\n    // Clear the roster.\n    //  while (roster.firstChild) {\n    //   roster.removeChild(roster.firstChild);\n    //    }\n\n    // Don't try to reconnect too rapidly.\n    const timeSinceLastJoin = Date.now() - startTime;\n    if (timeSinceLastJoin < 10_000) {\n      // Less than 10 seconds elapsed since last join. Pause a bit.\n      await new Promise((resolve) =>\n        setTimeout(resolve, 10_000 - timeSinceLastJoin)\n      );\n    }\n\n    // OK, reconnect now!\n    join();\n  }\n}\n\nasync function broad(\n  { code, transpiled, html, css, i },\n) {\n  if (sendChannel) {\n    const now = Date.now();\n    mod.i = i;\n    if (mod.lastRtcUpdate) {\n      const diff = now - mod.lastUpdate;\n      if (diff < 1000) {\n        await wait(200 - diff);\n        if (i !== mod.i) {\n          return;\n        }\n      }\n    }\n\n    mod.lastRtcUpdate = Date.now();\n    const updatedState = mST().toJSON();\n\n    updatedState.html = html;\n    updatedState.css = css;\n    updatedState.transpiled = transpiled;\n    updatedState.code = code;\n    updatedState.i = i;\n    const message = webRTCLastSeenHashCode\n      ? mySession.createPatchFromHashCode(webRTCLastSeenHashCode, updatedState)\n      : mySession.createPatch(updatedState);\n    if (message && message.patch !== \"\") {\n      sendChannel.send(message);\n    }\n  }\n\n  if (currentWebSocket) {\n    const now = Date.now();\n    mod.i = i;\n    if (mod.lastUpdate) {\n      const diff = now - mod.lastUpdate;\n      if (diff < 1000) {\n        await wait(1000 - diff);\n        if (i !== mod.i) {\n          return;\n        }\n      }\n    }\n\n    mod.lastUpdate = Date.now();\n    const updatedState = mST().toJSON();\n\n    updatedState.html = html;\n    updatedState.css = css;\n    updatedState.transpiled = transpiled;\n    updatedState.code = code;\n    updatedState.i = i;\n    const message = wsLastHashCode\n      ? mySession.createPatchFromHashCode(wsLastHashCode, updatedState)\n      : mySession.createPatch(updatedState);\n\n    // Console.log(\"APPLY\");\n    // mySession.applyPatch(message);\n    // console.log(mySession.hashCode());\n\n    if (!message) {\n      return;\n    }\n\n    const messageString = JSON.stringify({ ...message, name: username });\n    if (message.patch !== \"\") {\n      currentWebSocket.send(messageString);\n    }\n  }\n}\n\nexport const join = async (room, user, delta) => {\n  roomName = roomName || room || \"code-main\";\n  window.room = room;\n  if (user) {\n    username = user;\n  }\n\n  const resp = await fetch(\n    `https://spike.land/api/room/${roomName}/session`,\n  );\n  const state = await resp.json();\n\n  mySession = mySession || await initSession(roomName, {\n    name: username,\n    room: roomName,\n    state,\n    events: [],\n  });\n\n  window.mySession = mySession;\n  if (!delta) {\n    if (!window.sess) {\n      const session = {\n        ...mST().toJSON(),\n        setChild: () => {},\n        changes: [],\n\n        children: [null],\n        errorText: \"\",\n      };\n      const throttle = (await import(\"lodash/throttle\")).default;\n\n      const stayFullscreen = location.pathname.endsWith(\"public\");\n      quickStart(\n        session,\n        roomName,\n        stayFullscreen,\n        throttle(broad, 100),\n      );\n      window.sess = session;\n    }\n  }\n\n  if (sess) {\n    return;\n  }\n\n  sess = true;\n\n  setTimeout(() => {\n    sess = false;\n  }, 10_000);\n\n  ws = new WebSocket(\n    \"wss://\" + hostname + \"/api/room/\" + roomName + \"/websocket\",\n  );\n  rejoined = false;\n  startTime = Date.now();\n\n  ws.addEventListener(\"open\", () => {\n    if (delta) {\n      if (delta !== deltaSent) {\n        deltaSent = delta;\n        ws.send(JSON.stringify({\n          type: \"delta\",\n          delta,\n        }));\n      }\n      return;\n    }\n    if (intervalHandler) {\n      clearInterval(intervalHandler);\n    } else {\n      intervalHandler = setInterval(() => {\n        const now = Date.now();\n        const diff = now - lastSeenNow;\n\n        if (now - lastSeenNow > 30_000) {\n          try {\n            ws.send(\n              JSON.stringify({\n                name: username,\n                time: lastSeenTimestamp + diff,\n              }),\n            );\n          } catch {\n            rejoin();\n          }\n        }\n      }, 30_000);\n    }\n\n    currentWebSocket = ws;\n\n    globalThis.broad = broad;\n    globalThis.chCode = chCode;\n\n    // Send user info message.\n    ws.send(JSON.stringify({ name: username }));\n  });\n\n  ws.addEventListener(\"message\", (message) => processWsMessage(message, \"ws\"));\n\n  ws.addEventListener(\"close\", (event) => {\n    console.log(\"WebSocket closed, reconnecting:\", event.code, event.reason);\n    rejoin();\n  });\n  ws.addEventListener(\"error\", (event) => {\n    console.log(\"WebSocket error, reconnecting:\", event);\n    rejoin();\n  });\n};\n\n// Create the RTCPeerConnection which knows how to talk to our\n// selected STUN/TURN server and then uses getUserMedia() to find\n// our camera and microphone and add that stream to the connection for\n// use in our video call. Then we configure event handlers to get\n// needed notifications on the call.\n\nlet myHostname = window.location.hostname;\nif (!myHostname) {\n  myHostname = \"localhost\";\n}\n\nlog(\"Hostname: \" + myHostname);\n\n// WebSocket chat/signaling channel variables.\n\n// The media constraints object describes what sort of stream we want\n// to request from the local A/V hardware (typically a webcam and\n// microphone). Here, we specify only that we want both audio and\n// video; however, you can be more specific. It's possible to state\n// that you would prefer (or require) specific resolutions of video,\n// whether to prefer the user-facing or rear-facing camera (if available),\n// and so on.\n//\n// See also:\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n//\n\nconst connections = {}; // To st/ RTCPeerConnection\n// var transceiver = null;         // RTCRtpTransceiver\n// var webcamStream = null;        // MediaStream from webcam\n\n// Output logging information to console.\nglobalThis.connections = connections;\nfunction log(text) {\n  const time = new Date();\n\n  console.log(\"[\" + time.toLocaleTimeString() + \"] \" + text);\n}\n\n// Output an error message to console.\n\nfunction log_error(text) {\n  const time = new Date();\n\n  console.trace(\"[\" + time.toLocaleTimeString() + \"] \" + text);\n}\n\nasync function createPeerConnection(target) {\n  log(\"Setting up a connection...\");\n\n  // Create an RTCPeerConnection which knows to use our chosen\n  // STUN server.\n\n  const rcpOptions = {\n    iceServers: [\"stun3.l.google.com:19302\"].map((url) => ({\n      urls: `stun:${url}`,\n    })),\n  };\n\n  rcpOptions.iceServers = [{ urls: \"stun:stun.stunprotocol.org:3478\" }, {\n    urls: \"stun:stun.l.google.com:19302\",\n  }];\n\n  connections[target] = connections[target] || new RTCPeerConnection(\n    rcpOptions,\n  );\n\n  // Set up event handlers for the ICE negotiation process.\n\n  connections[target].onicecandidate = handleICECandidateEvent;\n  connections[target].oniceconnectionstatechange =\n    handleICEConnectionStateChangeEvent;\n  connections[target].onicegatheringstatechange =\n    handleICEGatheringStateChangeEvent;\n  connections[target].onsignalingstatechange = handleSignalingStateChangeEvent;\n  connections[target].onnegotiationneeded = handleNegotiationNeededEvent;\n  connections[target].ontrack = handleTrackEvent;\n\n  connections[target].addEventListener(\"datachannel\", receiveChannelCallback);\n\n  const dataChannelOptions = {\n    ordered: true, // Do not guarantee order\n    reliable: true,\n    maxPacketLifeTime: 3000, // In milliseconds\n  };\n\n  const rtc = connections[target].createDataChannel(\n    target,\n    dataChannelOptions,\n  );\n\n  rtc.binaryType = \"arraybuffer\";\n\n  rtc.addEventListener(\"message\", (message) => {\n    console.log(\"***********RTC***\", { msg: message });\n\n    const data = JSON.parse(message.data);\n    if (data && data.hashCode) {\n      webRTCLastSeenHashCode = data.hashCode;\n    }\n\n    if (data && data.newHash) {\n      webRTCLastSeenHashCode = data.newHash;\n    }\n\n    return processWsMessage(message, \"rtc\");\n  });\n\n  rtc.addEventListener(\"error\", (error) => {\n    console.log(\"xxxxxx-  Data Channel Error:\", error);\n  });\n\n  // Rtc.onmessage = (msg) => processWsMessage(msg, \"rtc\");\n\n  rtc.addEventListener(\"open\", () => {\n    console.log(\"@@@@@@@@RTC IS OPEN&&&&&&&&\");\n    rtc.target = target;\n    webRtcArray.push(rtc);\n    connections[target].sendChannel = rtc;\n\n    window.sendChannel = sendChannel = {\n      send: ((data) => {\n        const target = data.target;\n        data.name = data.name || username;\n        const messageString = JSON.stringify(data);\n        webRtcArray.map((ch) =>\n          ch.readyState === \"open\" &&\n          (!target || target && ch.target === target) && ch.send(messageString)\n        );\n      }),\n    };\n  });\n\n  rtc.addEventListener(\"close\", () => {\n    console.log(\"xxxxxxxx- The Data Channel is Closed\");\n  });\n\n  return connections[target];\n\n  function receiveChannelCallback(event) {\n    console.log(\"Receive Channel Callback\");\n    const rtc = event.channel;\n    rtc.binaryType = \"arraybuffer\";\n    rtc.addEventListener(\"close\", onReceiveChannelClosed);\n\n    rtc.addEventListener(\n      \"message\",\n      (message) => processWsMessage(message, \"rtc\"),\n    );\n    webRtcArray.push(rtc);\n  }\n\n  function onReceiveChannelClosed() {\n    console.log(\"Receive channel is closed\");\n    connections[target].close();\n    connections[target] = null;\n    console.log(\"Closed remote peer connection\");\n  }\n\n  async function handleNegotiationNeededEvent() {\n    log(\"*** Negotiation needed\");\n\n    try {\n      log(\"---> Creating offer\");\n      const offer = await connections[target].createOffer();\n\n      // If the connection hasn't yet achieved the \"stable\" state,\n      // return to the caller. Another negotiationneeded event\n      // will be fired when the state stabilizes.\n\n      if (connections[target].signalingState != \"stable\") {\n        log(\"     -- The connection isn't stable yet; postponing...\");\n        return;\n      }\n\n      // Establish the offer as the local peer's current\n      // description.\n\n      log(\"---> Setting local description to the offer\");\n      await connections[target].setLocalDescription(offer);\n\n      // Send the offer to the remote peer.\n\n      log(\"---> Sending the offer to the remote peer\");\n      ws.send(JSON.stringify({\n        target,\n        name: username,\n        type: \"video-offer\",\n        sdp: connections[target].localDescription,\n      }));\n    } catch {\n      log(\n        \"*** The following error occurred while handling the negotiationneeded event:\",\n      );\n      // ReportError(err);\n    }\n  }\n\n  // Called by the WebRTC layer when events occur on the media tracks\n  // on our WebRTC call. This includes when streams are added to and\n  // removed from the call.\n  //\n  // track events include the following fields:\n  //\n  // RTCRtpReceiver       receiver\n  // MediaStreamTrack     track\n  // MediaStream[]        streams\n  // RTCRtpTransceiver    transceiver\n  //\n  // In our case, we're just taking the first stream found and attaching\n  // it to the <video> element for incoming media.\n\n  function handleTrackEvent(event) {\n    log(\"*** Track event\");\n    document.querySelector(\"#received_video\").srcObject = event.streams[0];\n    document.querySelector(\"#hangup-button\").disabled = false;\n  }\n\n  // Handles |icecandidate| events by forwarding the specified\n  // ICE candidate (created by our local ICE agent) to the other\n  // peer through the signaling server.\n\n  function handleICECandidateEvent(event) {\n    if (event.candidate) {\n      log(\"*** Outgoing ICE candidate: \" + event.candidate);\n\n      ws.send(JSON.stringify({\n        type: \"new-ice-candidate\",\n        target,\n        name: username,\n        candidate: event.candidate,\n      }));\n    }\n  }\n\n  // Handle |iceconnectionstatechange| events. This will detect\n  // when the ICE connection is closed, failed, or disconnected.\n  //\n  // This is called when the state of the ICE agent changes.\n\n  function handleICEConnectionStateChangeEvent() {\n    log(\n      \"*** ICE connection state changed to \" +\n        connections[target].iceConnectionState,\n    );\n\n    switch (connections[target].iceConnectionState) {\n      case \"closed\":\n      case \"failed\":\n      case \"disconnected\":\n        break;\n    }\n  }\n\n  // Set up a |signalingstatechange| event handler. This will detect when\n  // the signaling connection is closed.\n  //\n  // NOTE: This will actually move to the new RTCPeerConnectionState enum\n  // returned in the property RTCPeerConnection.connectionState when\n  // browsers catch up with the latest version of the specification!\n\n  function handleSignalingStateChangeEvent() {\n    log(\n      \"*** connections[target].signalingState  changed to: \" +\n        connections[target].signalingState,\n    );\n    switch (connections[target].signalingState) {\n      case \"closed\":\n        break;\n    }\n  }\n\n  // Handle the |icegatheringstatechange| event. This lets us know what the\n  // ICE engine is currently working on: \"new\" means no networking has happened\n  // yet, \"gathering\" means the ICE engine is currently gathering candidates,\n  // and \"complete\" means gathering is complete. Note that the engine can\n  // alternate between \"gathering\" and \"complete\" repeatedly as needs and\n  // circumstances change.\n  //\n  // We don't need to do anything when this happens, but we log it to the\n  // console so you can see what's going on when playing with the sample.\n\n  function handleICEGatheringStateChangeEvent() {\n    log(\n      \"*** connections[target].iceGatheringState changed to: \" +\n        connections[target].iceGatheringState,\n    );\n  }\n}\n\nasync function handleNewICECandidateMessage(message, target) {\n  log(\n    \"*** Adding received ICE candidate: \" + JSON.stringify(message.candidate),\n  );\n  const candidate = new RTCIceCandidate(message.candidate);\n\n  // Lo\n  console.log(connections[target]);\n  await connections[target].addIceCandidate(candidate);\n}\n\nasync function handleChatAnswerMessage(message, target) {\n  log(\"*** Call recipient has accepted our call\");\n\n  // Configure the remote description, which is the SDP payload\n  // in our \"video-answer\" message.\n\n  const desc = new RTCSessionDescription(message.sdp);\n\n  await connections[target].setRemoteDescription(desc).catch(console.error);\n}\n\nasync function handleChatOffer(message, target) {\n  connections[target] || await createPeerConnection(target);\n\n  // If we're not already connected, create an RTCPeerConnection\n  // to be linked to the caller.\n\n  // log(\"Received chat offer from \" + target);\n  // ed to set the remote description to the received SDP offer\n  // so that our local WebRTC layer knows how to talk to the caller.\n\n  const desc = new RTCSessionDescription(message.sdp);\n\n  // If the connection isn't stable yet, wait for it...\n\n  if (connections[target].signalingState != \"stable\") {\n    log(\"  - But the signaling state isn't stable, so triggering rollback\");\n\n    // Set the local and remove descriptions for rollback; don't proceed\n    // until both return.\n    await Promise.all([\n      connections[target].setLocalDescription({ type: \"rollback\" }),\n      connections[target].setRemoteDescription(desc),\n    ]);\n    return;\n  }\n\n  log(\"  - Setting remote description\");\n  await connections[target].setRemoteDescription(desc);\n\n  // Get the webcam stream if we don't already have it\n\n  log(\"---> Creating and sending answer to caller\");\n\n  await connections[target].setLocalDescription(\n    await connections[target].createAnswer(),\n  );\n\n  ws.send(JSON.stringify({\n    target,\n    name: username,\n    type: \"video-answer\",\n    sdp: connections[target].localDescription,\n  }));\n}\n\n// Called by the WebRTC layer to let us know when it's time to\n// begin, resume, or restart ICE negotiation.\nasync function processWsMessage(event, source) {\n  lastSeenNow = Date.now();\n\n  const data = JSON.parse(event.data);\n\n  // MySession.addEvent(data);\n\n  if (\n    data.name && data.name !== username && !connections[data.name]\n  ) {\n    try {\n      await createPeerConnection(data.name);\n    } catch (error) {\n      console.log({ e: error });\n      log_error(\"Error with p2p\");\n    }\n  }\n\n  console.log(source, data.name);\n\n  if (data.type === \"new-ice-candidate\") {\n    await handleNewICECandidateMessage(data, data.name);\n    return;\n  }\n\n  if (data.type === \"video-offer\") {\n    await handleChatOffer(data, data.name);\n    return;\n  }\n\n  if (data.type === \"video-answer\") {\n    await handleChatAnswerMessage(data, data.name);\n\n    return;\n  }\n\n  if (source === ws && data.hashCode) {\n    wsLastHashCode = data.hashCode;\n  }\n\n  if (data.patch && source === \"ws\" || data.name !== username) {\n    if (data.newHash === mySession.hashCode()) {\n      return;\n    }\n\n    if (data.oldHash === mySession.hashCode()) {\n      // Console.log(\"******** APPLY PATCH ******\");\n      mySession.applyPatch(data);\n      chCode(\n        mySession.session.get(\"state\").code,\n        mySession.session.get(\"state\").i,\n      );\n      if (sendChannel) {\n        sendChannel.send({ hashCode: data.newHash });\n      }\n\n      return;\n    }\n\n    if (data.newHash === mySession.hashCode()) {\n      return;\n    }\n\n    if (data.code && data.transpiled) {\n      const messageData = mySession.createPatch(data);\n      mySession.applyPatch(messageData);\n      chCode(data.code);\n      if (sendChannel) {\n        sendChannel.send({ hashCode: messageData.newHash });\n      }\n\n      return;\n    }\n\n    return;\n  }\n\n  if (data.timestamp) {\n    lastSeenNow = Date.now();\n    lastSeenTimestamp = data.timestamp;\n  }\n\n  if (data.name === username) {\n    return;\n  }\n\n  lastSeenTimestamp = data.timestamp;\n}\n\nfunction wait(delay) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, delay);\n  });\n}\n"],
  "mappings": "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",
  "names": []
}

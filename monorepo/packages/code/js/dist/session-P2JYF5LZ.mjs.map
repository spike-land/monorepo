{
  "version": 3,
  "sources": ["../session.tsx"],
  "sourcesContent": ["import { fromJS, isKeyed, Record } from \"immutable\";\n// @ts-expect-error\nimport createDelta from \"textdiff-create\";\n// @ts-expect-error\nimport applyPatch from \"textdiff-patch\";\n// Import * as Immutable from \"immutable\"\n\ntype IUsername = string;\n\nexport interface ICodeSession {\n  code: string;\n  i: number;\n  errorDiff: string;\n  transpiled: string;\n  html: string;\n  css: string;\n}\n\nexport interface INewWSConnection {\n  uuid: string;\n  timestamp: number;\n  hashCode: number;\n  type: \"new-ws-connection\";\n}\n\ninterface ICodeInitEvent extends ICodeSession {\n  name: IUsername;\n  uuid: string;\n  type: \"code-init\";\n  hashOfCode: string;\n}\n\ninterface OtherEvent {\n  name: IUsername;\n  uuid: string;\n  target: IUsername | \"broadcast\";\n  type: \"start\" | \"open\" | \"quit\" | \"get-cid\" | \"provide-cid\" | \"new-ws\";\n  timestamp: number;\n}\n\nexport type IEvent =\n  | INewWSConnection\n  | OtherEvent\n  | ICodeInitEvent;\n\ninterface ICapabilities {\n  prettier: boolean;\n  babel: boolean;\n  sessionStorage?: boolean;\n  webRRT: boolean;\n  prerender: boolean;\n  IPFS: boolean;\n}\n\nexport interface IUserJSON {\n  name: IUsername;\n  capabilities: ICapabilities;\n  state: ICodeSession;\n  users: Record<object>;\n  events: IEvent[];\n}\n\ninterface IQTaskEvent {\n  uuid: string;\n  name: string;\n  operation: string;\n  data: string;\n}\n\nexport interface IUser extends\n  Record<{\n    name: IUsername;\n    room: string;\n    state: Record<ICodeSession>;\n    capabilities: ICapabilities;\n    users: Record<object>;\n    events: IEvent[];\n  }> {\n}\n\nfunction initSession(room: string, u: IUserJSON) {\n  return Record({ ...u, room, state: Record(u.state)() });\n}\n\nexport interface ICodeSess {\n  room: string;\n  hashCodeSession: number;\n  hashCode: () => number;\n  addEvent: (e: IEvent) => void;\n  setRoom: (room: string) => void;\n  json: () => IUserJSON;\n  processEvents: () => void;\n}\n\nconst hashStore: { [key: number]: Record<ICodeSession> } = {};\nexport class CodeSession implements ICodeSess {\n  session: IUser;\n  hashCodeSession: number;\n  public room = \"\";\n  created: string = new Date().toISOString();\n  constructor(room: string, user: IUserJSON) {\n    const savedState: ICodeSession | null = null;\n    this.room = room;\n    // If (user.state.code === \"\" && room) {\n    // const cacheKey = `state-${room}`;\n\n    // if (storageAvailable(\"localStorage\")) {\n    //   const savedStateStr = localStorage.getItem(cacheKey);\n    //   if (savedStateStr) {\n    //     savedState = JSON.parse(savedStateStr);\n    //   } else {\n    //     fetch(`https://spike.land/api/room/${room}/mySession`).then(\n    //       (resp) => resp.json(),\n    //     ).then((session: IUserJSON) => {\n    //       localStorage.setItem(cacheKey, JSON.stringify(session.state));\n    //       this.session.set(\"state\", Record(session.state)());\n    //     });\n    //   }\n    // }\n    // }\n\n    this.session = initSession(room, {\n      ...user,\n      state: savedState ? savedState : user.state,\n\n      capabilities: {\n        ...user.capabilities,\n        sessionStorage: storageAvailable(\"sessionStorage\"),\n      },\n    })();\n\n    this.hashCodeSession = this.session.get(\"state\").hashCode();\n    hashStore[this.session.get(\"state\").hashCode()] = this.session.get(\"state\");\n  }\n\n  public addEvent(e: IEvent) {\n    this.session.get(\"events\").push({\n      ...e,\n    });\n    setTimeout(() => this.processEvents);\n  }\n\n  public hashCode() {\n    return this.session.get(\"state\").hashCode();\n  }\n\n  processEvents() {\n    const events = this.session.get(\"events\");\n    const event = events.shift();\n\n    if (event) {\n      switch (event.type) {\n        case \"code-init\":\n          const { code, transpiled, i, css, errorDiff, html } = event;\n          const sess: ICodeSession = {\n            code,\n            transpiled,\n            i,\n            css,\n            errorDiff,\n            html,\n          };\n\n          this.session.set(\"events\", events);\n          this.session.set(\"state\", Record(sess)());\n\n          // Const cacheKey = `state-${this.room}`;\n\n          // if (storageAvailable(\"localStorage\")) {\n          //   localStorage.setItem(cacheKey, JSON.stringify(sess));\n          // }\n          // this.session.set(\"events\", events);\n      }\n    }\n  }\n\n  public createPatchFromHashCode(oldHash: number, state: ICodeSession) {\n    if (hashStore[oldHash]) {\n      const oldRec = hashStore[oldHash];\n      const oldState = JSON.stringify(oldRec.toJSON());\n\n      const newRec = oldRec.merge(state);\n      const newHash = newRec.hashCode();\n      hashStore[newHash] = newRec;\n\n      const newState = JSON.stringify(newRec.toJSON());\n      const patch = createPatch(oldState, newState);\n      return {\n        oldHash,\n        newHash,\n        patch,\n      };\n    }\n  }\n\n  public createPatch(state: ICodeSession) {\n    if (state.code === this.session.get(\"state\").get(\"code\")) {\n      return {\n        oldHash: this.session.get(\"state\").hashCode(),\n        newHash: this.session.get(\"state\").hashCode(),\n        patch: \"\",\n      };\n    }\n\n    const oldState = JSON.stringify(this.session.get(\"state\").toJSON());\n\n    const oldHash = this.session.get(\"state\").hashCode();\n    hashStore[oldHash] = this.session.get(\"state\");\n    const oldRec = this.session.get(\"state\");\n\n    const newRec = oldRec.merge(state);\n    const newHash = newRec.hashCode();\n\n    hashStore[newHash] = newRec;\n\n    const newState = JSON.stringify(newRec.toJSON());\n    const patch = createPatch(oldState, newState);\n    return {\n      oldHash,\n      newHash,\n      patch,\n    };\n  }\n\n  public applyPatch({\n    oldHash,\n    newHash,\n    patch,\n  }: { oldHash: number; newHash: number; patch: string }) {\n    const oldHashCheck = this.session.get(\"state\").hashCode();\n\n    if (oldHashCheck !== oldHash) {\n      console.error(\"Cant update\");\n      return;\n    }\n\n    const oldST = this.session.get(\"state\").toJSON();\n    const oldState = JSON.stringify(oldST);\n    const oldCode = oldST.code;\n    const newState = JSON.parse(applyPatch(oldState, JSON.parse(patch)));\n    const newRec: Record<ICodeSession> = Record<ICodeSession>(newState)();\n\n    console.log({ newState });\n    console.log(newRec.hashCode());\n\n    const newRecord = this.session.get(\"state\").merge(newRec);\n    const newCode = newRecord.get(\"code\");\n    if (oldCode === newCode) {\n      return;\n    }\n\n    console.log(newRecord.hashCode());\n    const newHashCheck = newRecord.hashCode();\n\n    if (newHashCheck === newHash) {\n      this.session = this.session.set(\"state\", newRecord);\n      //  Console.error(\"WRONG update\");\n    } else {\n      console.log(\"WRONG\");\n      console.log({\n        newState,\n      });\n    }\n  }\n\n  public json() {\n    const user = this.session.toJSON();\n    const state = user.state.toJSON();\n    return { ...user, state };\n  }\n\n  public setRoom(room: string) {\n    const user = this.session.set(\"room\", room);\n    this.session = user;\n  }\n}\n\nconst session: CodeSession | null = null;\nexport default (room: string, u: IUserJSON): ICodeSess =>\n  session || new CodeSession(room, u);\n\nfunction storageAvailable(type: string) {\n  try {\n    if (!window.hasOwnProperty(type)) {\n      return;\n    }\n\n    const storage = window[type as keyof Window];\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction createPatch(oldCode: string, newCode: string) {\n  return JSON.stringify(createDelta(oldCode, newCode));\n}\n"],
  "mappings": "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",
  "names": []
}

import{a as G}from"./chunk-CWAIQPIX.mjs";import{a as N,b as k,g as F}from"./chunk-R25N5FFR.mjs";var A=F(G()),T=null,x=!1,I=[],$="spike.land",p={},H="",D="",u="",f="",J=0,b=0,w,M,S=!1,m=null;var l=null,P=()=>l.session.get("state"),R=null;setInterval(()=>{Date.now()-b>4e4?(S=!1,v()):console.log("no_need_to_rejoin")},3e4);var W=async(e,t)=>{if(!!e&&!(t<window.sess.i)&&e!==window.sess.code)try{window.sess&&window.sess.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(n){console.error({e:n})}};async function v(){if(!S){T=null;let e=Date.now()-M;e<1e4&&await new Promise(t=>setTimeout(t,1e4-e)),V()}}var Z=(0,A.default)(B,100);async function B(e){let{i:t,code:n,transpiled:r,html:g,css:C}=e;if((async()=>{try{if(m){let i=Date.now();p.i=t,p.lastRtcUpdate=Date.now();let a=P().toJSON();a.html=g,a.css=C,a.transpiled=r,a.code=n,a.i=t;let h=D?l.createPatchFromHashCode(D,a):l.createPatch(a);h&&h.patch!==""&&m.send(h)}}catch(i){console.error("Error sending RTC...",{e:i})}})(),T){let i=Date.now();if(p.i=t,p.lastUpdate){let E=i-p.lastUpdate;if(E<1e3&&(await Y(1e3-E),t!==p.i))return}p.lastUpdate=Date.now();let a=P().toJSON();a.html=g,a.css=C,a.transpiled=r,a.code=n,a.i=t;let h=H?l.createPatchFromHashCode(H,a):l.createPatch(a);if(!h)return;let y=JSON.stringify(k(N({},h),{name:f}));h.patch!==""&&T.send(y)}else S=!1,await v()}var V=async(e,t,n)=>{if(u=u||e||"code-main",window.room=e,t&&(f=t),S)return;S=!0;let g=await(await fetch(`https://spike.land/api/room/${u}/session`)).json(),{startSession:C}=await import("./session-BO4AL4K3.mjs");if(l=l||await C(u,{name:f,room:u,state:g,events:[]}),window.mySession=l,!n&&!window.sess){let i=k(N({},P().toJSON()),{setChild:()=>{},changes:[],children:[globalThis.App],errorText:""}),a=(await import("./throttle-UJQ536PU.mjs")).default,h=location.pathname.endsWith("public"),{quickStart:y}=await import("./quickStart-A62WTMMX.mjs");y(i,u,h),window.sess=i}x||(x=!0,setTimeout(()=>{x=!1},1e4),w=new WebSocket("wss://"+$+"/api/room/"+u+"/websocket"),S=!1,M=Date.now(),w.addEventListener("open",()=>{R?clearInterval(R):R=setInterval(()=>{let i=Date.now(),a=i-b;if(i-b>3e4)try{w.send(JSON.stringify({name:f,time:J+a}))}catch(h){v()}},3e4),T=w,w.send(JSON.stringify({name:f}))}),w.addEventListener("message",i=>j(i,"ws")),w.addEventListener("close",i=>{console.log("WebSocket closed, reconnecting:",i.code,i.reason),v()}),w.addEventListener("error",i=>{console.log("WebSocket error, reconnecting:",i),v()}))},_=window.location.hostname;_||(_="localhost");c("Hostname: "+_);var o={};globalThis.connections=o;function c(e){let t=new Date;console.log("["+t.toLocaleTimeString()+"] "+e)}function z(e){let t=new Date;console.trace("["+t.toLocaleTimeString()+"] "+e)}async function U(e){c("Setting up a connection...");let t={iceServers:["stun3.l.google.com:19302"].map(s=>({urls:`stun:${s}`}))};t.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}],o[e]=o[e]||new RTCPeerConnection(t),o[e].onicecandidate=h,o[e].oniceconnectionstatechange=y,o[e].onicegatheringstatechange=q,o[e].onsignalingstatechange=E,o[e].onnegotiationneeded=i,o[e].ontrack=a,o[e].addEventListener("datachannel",g);let n={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},r=o[e].createDataChannel(e,n);return r.binaryType="arraybuffer",r.addEventListener("message",s=>{console.log("***********RTC***",{msg:s});let d=JSON.parse(s.data);return d&&d.hashCode&&(D=d.hashCode),d&&d.newHash&&(D=d.newHash),j(s,"rtc")}),r.addEventListener("error",s=>{console.log("xxxxxx-  Data Channel Error:",s)}),r.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),r.target=e,I.push(r),o[e].sendChannel=r,m=m={send:s=>{let d=s.target;s.name=s.name||f;let O=JSON.stringify(s);I.map(L=>L.readyState==="open"&&(!d||d&&L.target===d)&&L.send(O))}}}),r.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function g(s){console.log("Receive Channel Callback");let d=s.channel;d.binaryType="arraybuffer",d.addEventListener("close",C),d.addEventListener("message",O=>j(O,"rtc")),I.push(d)}function C(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function i(){c("*** Negotiation needed");try{c("---> Creating offer");let s=await o[e].createOffer();if(o[e].signalingState!="stable"){c("     -- The connection isn't stable yet; postponing...");return}c("---> Setting local description to the offer"),await o[e].setLocalDescription(s),c("---> Sending the offer to the remote peer"),w.send(JSON.stringify({target:e,name:f,type:"video-offer",sdp:o[e].localDescription}))}catch(s){c("*** The following error occurred while handling the negotiationneeded event:")}}function a(s){c("*** Track event"),document.querySelector("#received_video").srcObject=s.streams[0],document.querySelector("#hangup-button").disabled=!1}function h(s){s.candidate&&(c("*** Outgoing ICE candidate: "+s.candidate),w.send(JSON.stringify({type:"new-ice-candidate",target:e,name:f,candidate:s.candidate})))}function y(){switch(c("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function E(){switch(c("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function q(){c("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function K(e,t){c("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let n=new RTCIceCandidate(e.candidate);console.log(o[t]),await o[t].addIceCandidate(n)}async function Q(e,t){c("*** Call recipient has accepted our call");let n=new RTCSessionDescription(e.sdp);await o[t].setRemoteDescription(n).catch(console.error)}async function X(e,t){o[t]||await U(t);let n=new RTCSessionDescription(e.sdp);if(o[t].signalingState!="stable"){c("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[t].setLocalDescription({type:"rollback"}),o[t].setRemoteDescription(n)]);return}c("  - Setting remote description"),await o[t].setRemoteDescription(n),c("---> Creating and sending answer to caller"),await o[t].setLocalDescription(await o[t].createAnswer()),w.send(JSON.stringify({target:t,name:f,type:"video-answer",sdp:o[t].localDescription}))}async function j(e,t){console.log(t,{event:e}),b=Date.now();let n=JSON.parse(e.data);if(n.name&&n.name!==f&&!o[n.name])try{await U(n.name)}catch(r){console.log({e:r}),z("Error with p2p")}if(console.log(t,n.name),n.type==="new-ice-candidate"){await K(n,n.name);return}if(n.type==="video-offer"){await X(n,n.name);return}if(n.type==="video-answer"){await Q(n,n.name);return}if(t==="ws"&&n.hashCode&&(H=n.hashCode),n.patch&&t==="ws"||n.name!==f){if(n.newHash===l.hashCode())return;if(n.oldHash===l.hashCode()){l.applyPatch(n),W(l.session.get("state").code,l.session.get("state").i),m&&m.send({hashCode:n.newHash});return}if(n.newHash===l.hashCode())return;if(n.code&&n.transpiled){let r=l.createPatch(n);l.applyPatch(r),W(n.code,n.i),m&&m.send({hashCode:r.newHash});return}return}n.timestamp&&(b=Date.now(),J=n.timestamp),n.name!==f&&(J=n.timestamp)}var Y=e=>new Promise(t=>setTimeout(t,e));export{V as join,Z as saveCode};

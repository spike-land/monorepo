import{b as q}from"./chunk-U4KKEQGU.mjs";import{e as M}from"./chunk-6XRSRXUF.mjs";var N=M(q());var y,F=new Uint8Array(16);function G(){if(!y&&(y=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!y))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return y(F)}var B=/^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;function z(e){return typeof e=="string"&&B.test(e)}var c=[];for(let e=0;e<256;++e)c.push((e+256).toString(16).slice(1));function K(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(c[e[n+0]]+c[e[n+1]]+c[e[n+2]]+c[e[n+3]]+"-"+c[e[n+4]]+c[e[n+5]]+"-"+c[e[n+6]]+c[e[n+7]]+"-"+c[e[n+8]]+c[e[n+9]]+"-"+c[e[n+10]]+c[e[n+11]]+c[e[n+12]]+c[e[n+13]]+c[e[n+14]]+c[e[n+15]]).toLowerCase();if(!z(t))throw new TypeError("Stringified UUID is invalid");return t}function x(e,n,t){e=e||{};let s=e.random||(e.rng||G)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,n){t=t||0;for(let p=0;p<16;++p)n[t+p]=s[p];return n}return K(s)}var E=[],Q=window.location.hostname||"spike.land",w=location.pathname.split("/"),X=(w[1]==="api"&&w[2]==="room"?w[3]:(w.pop()||w.pop()).slice(-12))||"code-main",I=(self&&self.crypto&&self.crypto.randomUUID&&self.crypto.randomUUID()||x()).slice(0,8),D=0,S=0,m="",f="",R=0,C=0,r=null,h=!1,u=null,Y=await fetch(`https://spike.land/api/room/${m}/session`),Z=await Y.json(),{startSession:ee}=await import("./session-WSJMEIM2.mjs"),d=ee(m,{name:f,state:Z}),H=()=>d.json().state,T=null;setInterval(()=>{Date.now()-C>4e4?(h=!1,g()):console.log("no_need_to_rejoin")},3e4);var O=async(e,n)=>{if(!e)return;let t=H();if(!(n<t.i)&&e!==t.code)try{t&&window.sess.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(s){console.error({e:s})}};async function g(){return!h||r===null?(r=null,r||(r=await te(),r)):r}var le=(0,N.default)(ne,500);async function ne(e){if((async()=>{try{if(u){let n=S?d.createPatchFromHashCode(S,e):d.createPatch(e);n&&n.patch!==""&&u.send(n)}}catch(n){console.error("Error sending RTC...",{e:n})}})(),r){let n=D?d.createPatchFromHashCode(D,e):d.createPatch(e);if(!n)return;let t=JSON.stringify({...n,name:f});n.patch!==""&&r.send(t)}else h=!1,await g()}async function te(){if(m=m||X||"code-main",I&&(f=I),r!==null)return r;h=!0;let e=new WebSocket("wss://"+Q+"/api/room/"+m+"/websocket");if(h=!1,e.addEventListener("open",()=>(r=e,T&&clearInterval(T),T=setInterval(()=>{let n=Date.now(),t=n-C;if(n-C>3e4)try{e.send(JSON.stringify({name:f,time:R+t}))}catch{h=!1,g()}},3e4),e.send(JSON.stringify({name:f})),e)),!window.sess){let n={...H(),setChild:()=>{},changes:[],children:[globalThis.App],errorText:""},t=location.pathname.endsWith("public"),{quickStart:s}=await import("./quickStart-5PZWOAMY.mjs");s(n,m,t),window.sess=n}return e.addEventListener("message",n=>L(n,"ws")),e.addEventListener("close",n=>{console.log("WebSocket closed, reconnecting:",n.code,n.reason),h=!1,g()}),e.addEventListener("error",n=>{console.log("WebSocket error, reconnecting:",n),h=!1,g()}),e}var k=window.location.hostname;k||(k="localhost");a("Hostname: "+k);var o={};function a(e){let n=new Date;console.log("["+n.toLocaleTimeString()+"] "+e)}function oe(e){let n=new Date;console.trace("["+n.toLocaleTimeString()+"] "+e)}var P={iceServers:["stun3.l.google.com:19302"].map(e=>({urls:`stun:${e}`}))};P.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}];async function _(e){if(a(`Setting up a connection with ${e}`),o[e]){a(`Aborting, since we have connection with this ${e}`);return}o[e]=new RTCPeerConnection(P),o[e].onicecandidate=V,o[e].oniceconnectionstatechange=A,o[e].onicegatheringstatechange=W,o[e].onsignalingstatechange=U,o[e].onnegotiationneeded=J,o[e].ontrack=j,o[e].addEventListener("datachannel",s);let n={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},t=o[e].createDataChannel(e,n);return t.binaryType="arraybuffer",t.addEventListener("message",i=>{console.log("***********RTC***",{msg:i});let l=JSON.parse(i.data);return l&&l.hashCode&&(S=l.hashCode),l&&l.newHash&&(S=l.newHash),L(i,"rtc")}),t.addEventListener("error",i=>{console.log("xxxxxx-  Data Channel Error:",i)}),t.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),t.target=e,E.push(t),o[e].sendChannel=t,u=u={send:i=>{let l=i.target,b=JSON.stringify({...i,name:i.name||f});E.map(v=>{try{if(v.readyState!=="open")return;v.target===l&&v.send(b)}catch($){console.error("Error in broadcasting event",{e:$})}})}}}),t.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function s(i){console.log("Receive Channel Callback");let l=i.channel;l.binaryType="arraybuffer",l.addEventListener("close",p),l.addEventListener("message",b=>L(b,"rtc")),E.push(l)}function p(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function J(){a("*** Negotiation needed");try{a("---> Creating offer");let i=await o[e].createOffer();if(o[e].signalingState!="stable"){a("     -- The connection isn't stable yet; postponing...");return}a("---> Setting local description to the offer"),await o[e].setLocalDescription(i),a("---> Sending the offer to the remote peer"),r.send(JSON.stringify({target:e,name:f,type:"offer",sdp:o[e].localDescription}))}catch{a("*** The following error occurred while handling the negotiationneeded event:")}}function j(i){a("*** Track event"),document.querySelector("#received_video").srcObject=i.streams[0],document.querySelector("#hangup-button").disabled=!1}function V(i){i.candidate&&(a("*** Outgoing ICE candidate: "+i.candidate),r.send(JSON.stringify({type:"new-ice-candidate",target:e,name:f,candidate:i.candidate})))}function A(){switch(a("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function U(){switch(a("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function W(){a("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function se(e,n){a("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let t=new RTCIceCandidate(e.candidate);console.log(o[n]),await o[n].addIceCandidate(t)}async function ie(e,n){a("*** Call recipient has accepted our call");let t=new RTCSessionDescription(e.sdp);await o[n].setRemoteDescription(t).catch(console.error)}async function ae(e,n){if(o[n]||await _(n),!e.sdp)return;let t=new RTCSessionDescription(e.sdp);if(o[n].signalingState!="stable"){a("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[n].setLocalDescription({type:"rollback"}),o[n].setRemoteDescription(t)]);return}a("  - Setting remote description"),await o[n].setRemoteDescription(t),a("---> Creating and sending answer to caller"),await o[n].setLocalDescription(await o[n].createAnswer());let s=r||await g();s!==null&&s.send(JSON.stringify({target:n,name:f,type:"answer",sdp:o[n].localDescription}))}async function L(e,n){console.log(n,{event:e}),C=Date.now();let t=JSON.parse(e.data);if(t.name&&t.name!==f&&!o[t.name])try{await _(t.name)}catch(s){console.log({e:s}),oe("Error with p2p")}if(console.log(n,t.name),t.type==="new-ice-candidate"){await se(t,t.name);return}if(t.type==="offer"){await ae(t,t.name);return}if(t.type==="answer"){await ie(t,t.name);return}if(n==="ws"&&t.hashCode&&(D=t.hashCode),t.patch&&n==="ws"||t.name!==f){if(t.newHash===d.hashCode())return;if(t.oldHash===d.hashCode()){d.applyPatch(t),O(d.session.get("state").code,d.session.get("state").i),u&&u.send({hashCode:t.newHash});return}if(t.newHash===d.hashCode())return;if(t.code&&t.transpiled){let s=d.createPatch(t);d.applyPatch(s),O(t.code,t.i),u&&u.send({hashCode:s.newHash});return}return}t.timestamp&&(C=Date.now(),R=t.timestamp),t.name!==f&&(R=t.timestamp)}export{te as join,le as saveCode};

import{a as k,b as O}from"./chunk-AH6KKUH7.mjs";import{jsx as Z}from"https://spike.land/dist/emotion.mjs";var R,_=async(e,n)=>(R=R||(await import("./session-ZFHLRVN4.mjs")).default,R(e,n));var v=null,N=!1,P=[],z="spike.land",m={},J="",E="",u="",f="",I=0,S=0,w,D,q,y=!1,g;var l=null,M=()=>l.session.get("state"),H=null;setInterval(()=>{Date.now()-S>4e4?T():console.log("no_need_to_rejoin")},3e4);D=globalThis.chCode=async(e,n)=>{if(!!e&&!(n<window.sess.i)&&e!==window.sess.code)try{window.sess&&window.sess.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(t){console.error({e:t})}};async function T(){if(!y){y=!0,v=null;let e=Date.now()-q;e<1e4&&await new Promise(n=>setTimeout(n,1e4-e)),V()}}async function A({code:e,transpiled:n,html:t,css:c,i:p}){if(g){let s=Date.now();if(m.i=p,m.lastRtcUpdate){let C=s-m.lastUpdate;if(C<1e3&&(await W(200-C),p!==m.i))return}m.lastRtcUpdate=Date.now();let i=M().toJSON();i.html=t,i.css=c,i.transpiled=n,i.code=e,i.i=p;let h=E?l.createPatchFromHashCode(E,i):l.createPatch(i);h&&h.patch!==""&&g.send(h)}if(v){let s=Date.now();if(m.i=p,m.lastUpdate){let b=s-m.lastUpdate;if(b<1e3&&(await W(1e3-b),p!==m.i))return}m.lastUpdate=Date.now();let i=M().toJSON();i.html=t,i.css=c,i.transpiled=n,i.code=e,i.i=p;let h=J?l.createPatchFromHashCode(J,i):l.createPatch(i);if(!h)return;let C=JSON.stringify(O(k({},h),{name:f}));h.patch!==""&&v.send(C)}}var V=async(e,n,t)=>{if(u=u||e||"code-main",window.room=e,n&&(f=n),y)return;y=!0;let p=await(await fetch(`https://spike.land/api/room/${u}/session`)).json();if(l=l||await _(u,{name:f,room:u,state:p,events:[]}),window.mySession=l,!t&&!window.sess){let s=O(k({},M().toJSON()),{setChild:()=>{},changes:[],children:[globalThis.App],errorText:""}),i=(await import("./throttle-Z6JZ56VC.mjs")).default,h=location.pathname.endsWith("public");quickStart(s,u,h,i(A,100)),window.sess=s}N||(N=!0,setTimeout(()=>{N=!1},1e4),w=new WebSocket("wss://"+z+"/api/room/"+u+"/websocket"),y=!1,q=Date.now(),w.addEventListener("open",()=>{H?clearInterval(H):H=setInterval(()=>{let s=Date.now(),i=s-S;if(s-S>3e4)try{w.send(JSON.stringify({name:f,time:I+i}))}catch(h){T()}},3e4),v=w,globalThis.broad=A,globalThis.chCode=D,w.send(JSON.stringify({name:f}))}),w.addEventListener("message",s=>j(s,"ws")),w.addEventListener("close",s=>{console.log("WebSocket closed, reconnecting:",s.code,s.reason),T()}),w.addEventListener("error",s=>{console.log("WebSocket error, reconnecting:",s),T()}))},U=window.location.hostname;U||(U="localhost");r("Hostname: "+U);var o={};globalThis.connections=o;function r(e){let n=new Date;console.log("["+n.toLocaleTimeString()+"] "+e)}function $(e){let n=new Date;console.trace("["+n.toLocaleTimeString()+"] "+e)}async function F(e){r("Setting up a connection...");let n={iceServers:["stun3.l.google.com:19302"].map(a=>({urls:`stun:${a}`}))};n.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}],o[e]=o[e]||new RTCPeerConnection(n),o[e].onicecandidate=C,o[e].oniceconnectionstatechange=b,o[e].onicegatheringstatechange=G,o[e].onsignalingstatechange=B,o[e].onnegotiationneeded=i,o[e].ontrack=h,o[e].addEventListener("datachannel",p);let t={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},c=o[e].createDataChannel(e,t);return c.binaryType="arraybuffer",c.addEventListener("message",a=>{console.log("***********RTC***",{msg:a});let d=JSON.parse(a.data);return d&&d.hashCode&&(E=d.hashCode),d&&d.newHash&&(E=d.newHash),j(a,"rtc")}),c.addEventListener("error",a=>{console.log("xxxxxx-  Data Channel Error:",a)}),c.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),c.target=e,P.push(c),o[e].sendChannel=c,window.sendChannel=g={send:a=>{let d=a.target;a.name=a.name||f;let x=JSON.stringify(a);P.map(L=>L.readyState==="open"&&(!d||d&&L.target===d)&&L.send(x))}}}),c.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function p(a){console.log("Receive Channel Callback");let d=a.channel;d.binaryType="arraybuffer",d.addEventListener("close",s),d.addEventListener("message",x=>j(x,"rtc")),P.push(d)}function s(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function i(){r("*** Negotiation needed");try{r("---> Creating offer");let a=await o[e].createOffer();if(o[e].signalingState!="stable"){r("     -- The connection isn't stable yet; postponing...");return}r("---> Setting local description to the offer"),await o[e].setLocalDescription(a),r("---> Sending the offer to the remote peer"),w.send(JSON.stringify({target:e,name:f,type:"video-offer",sdp:o[e].localDescription}))}catch(a){r("*** The following error occurred while handling the negotiationneeded event:")}}function h(a){r("*** Track event"),document.querySelector("#received_video").srcObject=a.streams[0],document.querySelector("#hangup-button").disabled=!1}function C(a){a.candidate&&(r("*** Outgoing ICE candidate: "+a.candidate),w.send(JSON.stringify({type:"new-ice-candidate",target:e,name:f,candidate:a.candidate})))}function b(){switch(r("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function B(){switch(r("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function G(){r("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function X(e,n){r("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let t=new RTCIceCandidate(e.candidate);console.log(o[n]),await o[n].addIceCandidate(t)}async function K(e,n){r("*** Call recipient has accepted our call");let t=new RTCSessionDescription(e.sdp);await o[n].setRemoteDescription(t).catch(console.error)}async function Q(e,n){o[n]||await F(n);let t=new RTCSessionDescription(e.sdp);if(o[n].signalingState!="stable"){r("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[n].setLocalDescription({type:"rollback"}),o[n].setRemoteDescription(t)]);return}r("  - Setting remote description"),await o[n].setRemoteDescription(t),r("---> Creating and sending answer to caller"),await o[n].setLocalDescription(await o[n].createAnswer()),w.send(JSON.stringify({target:n,name:f,type:"video-answer",sdp:o[n].localDescription}))}async function j(e,n){console.log(n,{event:e}),S=Date.now();let t=JSON.parse(e.data);if(t.name&&t.name!==f&&!o[t.name])try{await F(t.name)}catch(c){console.log({e:c}),$("Error with p2p")}if(console.log(n,t.name),t.type==="new-ice-candidate"){await X(t,t.name);return}if(t.type==="video-offer"){await Q(t,t.name);return}if(t.type==="video-answer"){await K(t,t.name);return}if(n===w&&t.hashCode&&(J=t.hashCode),t.patch&&n==="ws"||t.name!==f){if(t.newHash===l.hashCode())return;if(t.oldHash===l.hashCode()){l.applyPatch(t),D(l.session.get("state").code,l.session.get("state").i),g&&g.send({hashCode:t.newHash});return}if(t.newHash===l.hashCode())return;if(t.code&&t.transpiled){let c=l.createPatch(t);l.applyPatch(c),D(t.code),g&&g.send({hashCode:c.newHash});return}return}t.timestamp&&(S=Date.now(),I=t.timestamp),t.name!==f&&(I=t.timestamp)}function W(e){return new Promise(n=>{setTimeout(()=>{n()},e)})}export{V as join};

import{b as F}from"./chunk-U4KKEQGU.mjs";import{e as q}from"./chunk-6XRSRXUF.mjs";var H=q(F());var C,G=new Uint8Array(16);function B(){if(!C&&(C=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!C))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return C(G)}var z=/^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;function K(e){return typeof e=="string"&&z.test(e)}var c=[];for(let e=0;e<256;++e)c.push((e+256).toString(16).slice(1));function Q(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(c[e[n+0]]+c[e[n+1]]+c[e[n+2]]+c[e[n+3]]+"-"+c[e[n+4]]+c[e[n+5]]+"-"+c[e[n+6]]+c[e[n+7]]+"-"+c[e[n+8]]+c[e[n+9]]+"-"+c[e[n+10]]+c[e[n+11]]+c[e[n+12]]+c[e[n+13]]+c[e[n+14]]+c[e[n+15]]).toLowerCase();if(!K(t))throw new TypeError("Stringified UUID is invalid");return t}function I(e,n,t){e=e||{};let s=e.random||(e.rng||B)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,n){t=t||0;for(let p=0;p<16;++p)n[t+p]=s[p];return n}return Q(s)}var E=[],X=window.location.hostname||"spike.land",g=location.pathname.split("/"),x=(g[1]==="api"&&g[2]==="room"?g[3]:(g.pop()||g.pop()).slice(-12))||"code-main",O=(self&&self.crypto&&self.crypto.randomUUID&&self.crypto.randomUUID()||I()).slice(0,8),D=0,S=0,y="",f="",R=0,w=0,r=null,h=!1,u=null,Y=await fetch(`https://spike.land/api/room/${x}/session`),Z=await Y.json(),{startSession:ee}=await import("./session-DAWSVOXB.mjs"),d=ee(x,{name:f,state:Z}),P=()=>d.json().state,T=null;setInterval(()=>{Date.now()-w>4e4?(h=!1,m()):console.log("no_need_to_rejoin")},3e4);var N=async(e,n)=>{if(!e)return;let t=P();if(!(n<t.i)&&e!==t.code)try{t&&window.sess.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(s){console.error({e:s})}};async function m(){return!h||r===null?(r=null,r||(r=await te(),r)):r}var le=(0,H.default)(ne,500);async function ne(e){if((async()=>{try{if(u){let n=S?d.createPatchFromHashCode(S,e):d.createPatch(e);n&&n.patch!==""&&u.send(n)}}catch(n){console.error("Error sending RTC...",{e:n})}})(),r){let n=D?d.createPatchFromHashCode(D,e):d.createPatch(e);if(!n)return;let t=JSON.stringify({...n,name:f});n.patch!==""&&r.send(t)}else h=!1,await m()}async function te(){if(y=y||x||"code-main",O&&(f=O),r!==null)return r;h=!0;let e=new WebSocket("wss://"+X+"/api/room/"+y+"/websocket");if(h=!1,e.addEventListener("open",()=>(r=e,T&&clearInterval(T),T=setInterval(()=>{let n=Date.now(),t=n-w;if(n-w>3e4)try{e.send(JSON.stringify({name:f,time:R+t}))}catch{h=!1,m()}},3e4),e.send(JSON.stringify({name:f})),e)),!window.sess){let n={...P(),setChild:()=>{},changes:[],children:[globalThis.App],errorText:""},t=location.pathname.endsWith("public"),{quickStart:s}=await import("./quickStart-LC4M73NG.mjs");s(n,y,t),window.sess=n}return e.addEventListener("message",n=>L(n,"ws")),e.addEventListener("close",n=>{console.log("WebSocket closed, reconnecting:",n.code,n.reason),h=!1,m()}),e.addEventListener("error",n=>{console.log("WebSocket error, reconnecting:",n),h=!1,m()}),e}var k=window.location.hostname;k||(k="localhost");a("Hostname: "+k);var o={};function a(e){let n=new Date;console.log("["+n.toLocaleTimeString()+"] "+e)}function oe(e){let n=new Date;console.trace("["+n.toLocaleTimeString()+"] "+e)}var _={iceServers:["stun3.l.google.com:19302"].map(e=>({urls:`stun:${e}`}))};_.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}];async function J(e){if(a(`Setting up a connection with ${e}`),o[e]){a(`Aborting, since we have connection with this ${e}`);return}o[e]=new RTCPeerConnection(_),o[e].onicecandidate=A,o[e].oniceconnectionstatechange=U,o[e].onicegatheringstatechange=$,o[e].onsignalingstatechange=W,o[e].onnegotiationneeded=j,o[e].ontrack=V,o[e].addEventListener("datachannel",s);let n={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},t=o[e].createDataChannel(e,n);return t.binaryType="arraybuffer",t.addEventListener("message",i=>{console.log("***********RTC***",{msg:i});let l=JSON.parse(i.data);return l&&l.hashCode&&(S=l.hashCode),l&&l.newHash&&(S=l.newHash),L(i,"rtc")}),t.addEventListener("error",i=>{console.log("xxxxxx-  Data Channel Error:",i)}),t.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),t.target=e,E.push(t),o[e].sendChannel=t,u=u={send:i=>{let l=i.target,b=JSON.stringify({...i,name:i.name||f});E.map(v=>{try{if(v.readyState!=="open")return;v.target===l&&v.send(b)}catch(M){console.error("Error in broadcasting event",{e:M})}})}}}),t.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function s(i){console.log("Receive Channel Callback");let l=i.channel;l.binaryType="arraybuffer",l.addEventListener("close",p),l.addEventListener("message",b=>L(b,"rtc")),E.push(l)}function p(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function j(){a("*** Negotiation needed");try{a("---> Creating offer");let i=await o[e].createOffer();if(o[e].signalingState!="stable"){a("     -- The connection isn't stable yet; postponing...");return}a("---> Setting local description to the offer"),await o[e].setLocalDescription(i),a("---> Sending the offer to the remote peer"),r.send(JSON.stringify({target:e,name:f,type:"offer",sdp:o[e].localDescription}))}catch{a("*** The following error occurred while handling the negotiationneeded event:")}}function V(i){a("*** Track event"),document.querySelector("#received_video").srcObject=i.streams[0],document.querySelector("#hangup-button").disabled=!1}function A(i){i.candidate&&(a("*** Outgoing ICE candidate: "+i.candidate),r.send(JSON.stringify({type:"new-ice-candidate",target:e,name:f,candidate:i.candidate})))}function U(){switch(a("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function W(){switch(a("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function $(){a("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function se(e,n){a("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let t=new RTCIceCandidate(e.candidate);console.log(o[n]),await o[n].addIceCandidate(t)}async function ie(e,n){a("*** Call recipient has accepted our call");let t=new RTCSessionDescription(e.sdp);await o[n].setRemoteDescription(t).catch(console.error)}async function ae(e,n){if(o[n]||await J(n),!e.sdp)return;let t=new RTCSessionDescription(e.sdp);if(o[n].signalingState!="stable"){a("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[n].setLocalDescription({type:"rollback"}),o[n].setRemoteDescription(t)]);return}a("  - Setting remote description"),await o[n].setRemoteDescription(t),a("---> Creating and sending answer to caller"),await o[n].setLocalDescription(await o[n].createAnswer());let s=r||await m();s!==null&&s.send(JSON.stringify({target:n,name:f,type:"answer",sdp:o[n].localDescription}))}async function L(e,n){console.log(n,{event:e}),w=Date.now();let t=JSON.parse(e.data);if(t.name&&t.name!==f&&!o[t.name])try{await J(t.name)}catch(s){console.log({e:s}),oe("Error with p2p")}if(console.log(n,t.name),t.type==="new-ice-candidate"){await se(t,t.name);return}if(t.type==="offer"){await ae(t,t.name);return}if(t.type==="answer"){await ie(t,t.name);return}if(n==="ws"&&t.hashCode&&(D=t.hashCode),t.patch&&n==="ws"||t.name!==f){if(t.newHash===d.hashCode())return;if(t.oldHash===d.hashCode()){d.applyPatch(t),N(d.session.get("state").code,d.session.get("state").i),u&&u.send({hashCode:t.newHash});return}if(t.newHash===d.hashCode())return;if(t.code&&t.transpiled){let s=d.createPatch(t);d.applyPatch(s),N(t.code,t.i),u&&u.send({hashCode:s.newHash});return}return}t.timestamp&&(w=Date.now(),R=t.timestamp),t.name!==f&&(R=t.timestamp)}export{te as join,le as saveCode};

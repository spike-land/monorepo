{
  "version": 3,
  "sources": ["../../../../../node_modules/esbuild-wasm/lib/browser.js", "../../esbuildEsm.ts"],
  "sourcesContent": ["(module=>{\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// lib/npm/browser.ts\nvar browser_exports = {};\n__export(browser_exports, {\n  analyzeMetafile: () => analyzeMetafile,\n  analyzeMetafileSync: () => analyzeMetafileSync,\n  build: () => build,\n  buildSync: () => buildSync,\n  formatMessages: () => formatMessages,\n  formatMessagesSync: () => formatMessagesSync,\n  initialize: () => initialize,\n  serve: () => serve,\n  transform: () => transform,\n  transformSync: () => transformSync,\n  version: () => version\n});\n\n// lib/shared/stdio_protocol.ts\nfunction encodePacket(packet) {\n  let visit = (value) => {\n    if (value === null) {\n      bb.write8(0);\n    } else if (typeof value === \"boolean\") {\n      bb.write8(1);\n      bb.write8(+value);\n    } else if (typeof value === \"number\") {\n      bb.write8(2);\n      bb.write32(value | 0);\n    } else if (typeof value === \"string\") {\n      bb.write8(3);\n      bb.write(encodeUTF8(value));\n    } else if (value instanceof Uint8Array) {\n      bb.write8(4);\n      bb.write(value);\n    } else if (value instanceof Array) {\n      bb.write8(5);\n      bb.write32(value.length);\n      for (let item of value) {\n        visit(item);\n      }\n    } else {\n      let keys = Object.keys(value);\n      bb.write8(6);\n      bb.write32(keys.length);\n      for (let key of keys) {\n        bb.write(encodeUTF8(key));\n        visit(value[key]);\n      }\n    }\n  };\n  let bb = new ByteBuffer();\n  bb.write32(0);\n  bb.write32(packet.id << 1 | +!packet.isRequest);\n  visit(packet.value);\n  writeUInt32LE(bb.buf, bb.len - 4, 0);\n  return bb.buf.subarray(0, bb.len);\n}\nfunction decodePacket(bytes) {\n  let visit = () => {\n    switch (bb.read8()) {\n      case 0:\n        return null;\n      case 1:\n        return !!bb.read8();\n      case 2:\n        return bb.read32();\n      case 3:\n        return decodeUTF8(bb.read());\n      case 4:\n        return bb.read();\n      case 5: {\n        let count = bb.read32();\n        let value2 = [];\n        for (let i = 0; i < count; i++) {\n          value2.push(visit());\n        }\n        return value2;\n      }\n      case 6: {\n        let count = bb.read32();\n        let value2 = {};\n        for (let i = 0; i < count; i++) {\n          value2[decodeUTF8(bb.read())] = visit();\n        }\n        return value2;\n      }\n      default:\n        throw new Error(\"Invalid packet\");\n    }\n  };\n  let bb = new ByteBuffer(bytes);\n  let id = bb.read32();\n  let isRequest = (id & 1) === 0;\n  id >>>= 1;\n  let value = visit();\n  if (bb.ptr !== bytes.length) {\n    throw new Error(\"Invalid packet\");\n  }\n  return { id, isRequest, value };\n}\nvar ByteBuffer = class {\n  constructor(buf = new Uint8Array(1024)) {\n    this.buf = buf;\n    this.len = 0;\n    this.ptr = 0;\n  }\n  _write(delta) {\n    if (this.len + delta > this.buf.length) {\n      let clone = new Uint8Array((this.len + delta) * 2);\n      clone.set(this.buf);\n      this.buf = clone;\n    }\n    this.len += delta;\n    return this.len - delta;\n  }\n  write8(value) {\n    let offset = this._write(1);\n    this.buf[offset] = value;\n  }\n  write32(value) {\n    let offset = this._write(4);\n    writeUInt32LE(this.buf, value, offset);\n  }\n  write(bytes) {\n    let offset = this._write(4 + bytes.length);\n    writeUInt32LE(this.buf, bytes.length, offset);\n    this.buf.set(bytes, offset + 4);\n  }\n  _read(delta) {\n    if (this.ptr + delta > this.buf.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    this.ptr += delta;\n    return this.ptr - delta;\n  }\n  read8() {\n    return this.buf[this._read(1)];\n  }\n  read32() {\n    return readUInt32LE(this.buf, this._read(4));\n  }\n  read() {\n    let length = this.read32();\n    let bytes = new Uint8Array(length);\n    let ptr = this._read(bytes.length);\n    bytes.set(this.buf.subarray(ptr, ptr + length));\n    return bytes;\n  }\n};\nvar encodeUTF8;\nvar decodeUTF8;\nif (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  encodeUTF8 = (text) => encoder.encode(text);\n  decodeUTF8 = (bytes) => decoder.decode(bytes);\n} else if (typeof Buffer !== \"undefined\") {\n  encodeUTF8 = (text) => {\n    let buffer = Buffer.from(text);\n    if (!(buffer instanceof Uint8Array)) {\n      buffer = new Uint8Array(buffer);\n    }\n    return buffer;\n  };\n  decodeUTF8 = (bytes) => {\n    let { buffer, byteOffset, byteLength } = bytes;\n    return Buffer.from(buffer, byteOffset, byteLength).toString();\n  };\n} else {\n  throw new Error(\"No UTF-8 codec found\");\n}\nfunction readUInt32LE(buffer, offset) {\n  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  buffer[offset++] = value;\n  buffer[offset++] = value >> 8;\n  buffer[offset++] = value >> 16;\n  buffer[offset++] = value >> 24;\n}\n\n// lib/shared/common.ts\nfunction validateTarget(target) {\n  target += \"\";\n  if (target.indexOf(\",\") >= 0)\n    throw new Error(`Invalid target: ${target}`);\n  return target;\n}\nvar canBeAnything = () => null;\nvar mustBeBoolean = (value) => typeof value === \"boolean\" ? null : \"a boolean\";\nvar mustBeBooleanOrObject = (value) => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\nvar mustBeString = (value) => typeof value === \"string\" ? null : \"a string\";\nvar mustBeRegExp = (value) => value instanceof RegExp ? null : \"a RegExp object\";\nvar mustBeInteger = (value) => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\nvar mustBeFunction = (value) => typeof value === \"function\" ? null : \"a function\";\nvar mustBeArray = (value) => Array.isArray(value) ? null : \"an array\";\nvar mustBeObject = (value) => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\nvar mustBeArrayOrRecord = (value) => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\nvar mustBeObjectOrNull = (value) => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\nvar mustBeStringOrBoolean = (value) => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\nvar mustBeStringOrObject = (value) => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\nvar mustBeStringOrArray = (value) => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\nvar mustBeStringOrUint8Array = (value) => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\nfunction getFlag(object, keys, key, mustBeFn) {\n  let value = object[key];\n  keys[key + \"\"] = true;\n  if (value === void 0)\n    return void 0;\n  let mustBe = mustBeFn(value);\n  if (mustBe !== null)\n    throw new Error(`\"${key}\" must be ${mustBe}`);\n  return value;\n}\nfunction checkForInvalidFlags(object, keys, where) {\n  for (let key in object) {\n    if (!(key in keys)) {\n      throw new Error(`Invalid option ${where}: \"${key}\"`);\n    }\n  }\n}\nfunction validateInitializeOptions(options) {\n  let keys = /* @__PURE__ */ Object.create(null);\n  let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n  let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n  checkForInvalidFlags(options, keys, \"in startService() call\");\n  return {\n    wasmURL,\n    worker\n  };\n}\nfunction pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n  let color = getFlag(options, keys, \"color\", mustBeBoolean);\n  let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n  let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n  if (color !== void 0)\n    flags.push(`--color=${color}`);\n  else if (isTTY)\n    flags.push(`--color=true`);\n  flags.push(`--log-level=${logLevel || logLevelDefault}`);\n  flags.push(`--log-limit=${logLimit || 0}`);\n}\nfunction pushCommonFlags(flags, options, keys) {\n  let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n  let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n  let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n  let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n  let format = getFlag(options, keys, \"format\", mustBeString);\n  let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n  let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n  let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n  let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n  let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n  let drop = getFlag(options, keys, \"drop\", mustBeArray);\n  let charset = getFlag(options, keys, \"charset\", mustBeString);\n  let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n  let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n  let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n  let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n  let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n  let define = getFlag(options, keys, \"define\", mustBeObject);\n  let pure = getFlag(options, keys, \"pure\", mustBeArray);\n  let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n  if (legalComments)\n    flags.push(`--legal-comments=${legalComments}`);\n  if (sourceRoot !== void 0)\n    flags.push(`--source-root=${sourceRoot}`);\n  if (sourcesContent !== void 0)\n    flags.push(`--sources-content=${sourcesContent}`);\n  if (target) {\n    if (Array.isArray(target))\n      flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);\n    else\n      flags.push(`--target=${validateTarget(target)}`);\n  }\n  if (format)\n    flags.push(`--format=${format}`);\n  if (globalName)\n    flags.push(`--global-name=${globalName}`);\n  if (minify)\n    flags.push(\"--minify\");\n  if (minifySyntax)\n    flags.push(\"--minify-syntax\");\n  if (minifyWhitespace)\n    flags.push(\"--minify-whitespace\");\n  if (minifyIdentifiers)\n    flags.push(\"--minify-identifiers\");\n  if (charset)\n    flags.push(`--charset=${charset}`);\n  if (treeShaking !== void 0)\n    flags.push(`--tree-shaking=${treeShaking}`);\n  if (ignoreAnnotations)\n    flags.push(`--ignore-annotations`);\n  if (drop)\n    for (let what of drop)\n      flags.push(`--drop:${what}`);\n  if (jsx)\n    flags.push(`--jsx=${jsx}`);\n  if (jsxFactory)\n    flags.push(`--jsx-factory=${jsxFactory}`);\n  if (jsxFragment)\n    flags.push(`--jsx-fragment=${jsxFragment}`);\n  if (define) {\n    for (let key in define) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid define: ${key}`);\n      flags.push(`--define:${key}=${define[key]}`);\n    }\n  }\n  if (pure)\n    for (let fn of pure)\n      flags.push(`--pure:${fn}`);\n  if (keepNames)\n    flags.push(`--keep-names`);\n}\nfunction flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n  var _a;\n  let flags = [];\n  let entries = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  let stdinContents = null;\n  let stdinResolveDir = null;\n  let watchMode = null;\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n  let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n  let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n  let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n  let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n  let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n  let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n  let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n  let platform = getFlag(options, keys, \"platform\", mustBeString);\n  let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n  let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n  let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n  let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n  let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n  let external = getFlag(options, keys, \"external\", mustBeArray);\n  let loader = getFlag(options, keys, \"loader\", mustBeObject);\n  let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n  let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n  let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n  let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n  let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n  let inject = getFlag(options, keys, \"inject\", mustBeArray);\n  let banner = getFlag(options, keys, \"banner\", mustBeObject);\n  let footer = getFlag(options, keys, \"footer\", mustBeObject);\n  let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n  let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n  let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n  let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n  let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n  let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n  keys.plugins = true;\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n  if (bundle)\n    flags.push(\"--bundle\");\n  if (allowOverwrite)\n    flags.push(\"--allow-overwrite\");\n  if (watch) {\n    flags.push(\"--watch\");\n    if (typeof watch === \"boolean\") {\n      watchMode = {};\n    } else {\n      let watchKeys = /* @__PURE__ */ Object.create(null);\n      let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n      checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n      watchMode = { onRebuild };\n    }\n  }\n  if (splitting)\n    flags.push(\"--splitting\");\n  if (preserveSymlinks)\n    flags.push(\"--preserve-symlinks\");\n  if (metafile)\n    flags.push(`--metafile`);\n  if (outfile)\n    flags.push(`--outfile=${outfile}`);\n  if (outdir)\n    flags.push(`--outdir=${outdir}`);\n  if (outbase)\n    flags.push(`--outbase=${outbase}`);\n  if (platform)\n    flags.push(`--platform=${platform}`);\n  if (tsconfig)\n    flags.push(`--tsconfig=${tsconfig}`);\n  if (resolveExtensions) {\n    let values = [];\n    for (let value of resolveExtensions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid resolve extension: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--resolve-extensions=${values.join(\",\")}`);\n  }\n  if (publicPath)\n    flags.push(`--public-path=${publicPath}`);\n  if (entryNames)\n    flags.push(`--entry-names=${entryNames}`);\n  if (chunkNames)\n    flags.push(`--chunk-names=${chunkNames}`);\n  if (assetNames)\n    flags.push(`--asset-names=${assetNames}`);\n  if (mainFields) {\n    let values = [];\n    for (let value of mainFields) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid main field: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--main-fields=${values.join(\",\")}`);\n  }\n  if (conditions) {\n    let values = [];\n    for (let value of conditions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid condition: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--conditions=${values.join(\",\")}`);\n  }\n  if (external)\n    for (let name of external)\n      flags.push(`--external:${name}`);\n  if (banner) {\n    for (let type in banner) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid banner file type: ${type}`);\n      flags.push(`--banner:${type}=${banner[type]}`);\n    }\n  }\n  if (footer) {\n    for (let type in footer) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid footer file type: ${type}`);\n      flags.push(`--footer:${type}=${footer[type]}`);\n    }\n  }\n  if (inject)\n    for (let path of inject)\n      flags.push(`--inject:${path}`);\n  if (loader) {\n    for (let ext in loader) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid loader extension: ${ext}`);\n      flags.push(`--loader:${ext}=${loader[ext]}`);\n    }\n  }\n  if (outExtension) {\n    for (let ext in outExtension) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid out extension: ${ext}`);\n      flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n    }\n  }\n  if (entryPoints) {\n    if (Array.isArray(entryPoints)) {\n      for (let entryPoint of entryPoints) {\n        entries.push([\"\", entryPoint + \"\"]);\n      }\n    } else {\n      for (let [key, value] of Object.entries(entryPoints)) {\n        entries.push([key + \"\", value + \"\"]);\n      }\n    }\n  }\n  if (stdin) {\n    let stdinKeys = /* @__PURE__ */ Object.create(null);\n    let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeString);\n    let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n    let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n    let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n    checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n    if (sourcefile)\n      flags.push(`--sourcefile=${sourcefile}`);\n    if (loader2)\n      flags.push(`--loader=${loader2}`);\n    if (resolveDir)\n      stdinResolveDir = resolveDir + \"\";\n    stdinContents = contents ? contents + \"\" : \"\";\n  }\n  let nodePaths = [];\n  if (nodePathsInput) {\n    for (let value of nodePathsInput) {\n      value += \"\";\n      nodePaths.push(value);\n    }\n  }\n  return {\n    entries,\n    flags,\n    write,\n    stdinContents,\n    stdinResolveDir,\n    absWorkingDir,\n    incremental,\n    nodePaths,\n    watch: watchMode\n  };\n}\nfunction flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n  let flags = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n  let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n  let loader = getFlag(options, keys, \"loader\", mustBeString);\n  let banner = getFlag(options, keys, \"banner\", mustBeString);\n  let footer = getFlag(options, keys, \"footer\", mustBeString);\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n  if (tsconfigRaw)\n    flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n  if (sourcefile)\n    flags.push(`--sourcefile=${sourcefile}`);\n  if (loader)\n    flags.push(`--loader=${loader}`);\n  if (banner)\n    flags.push(`--banner=${banner}`);\n  if (footer)\n    flags.push(`--footer=${footer}`);\n  return flags;\n}\nfunction createChannel(streamIn) {\n  let responseCallbacks = /* @__PURE__ */ new Map();\n  let pluginCallbacks = /* @__PURE__ */ new Map();\n  let watchCallbacks = /* @__PURE__ */ new Map();\n  let serveCallbacks = /* @__PURE__ */ new Map();\n  let isClosed = false;\n  let nextRequestID = 0;\n  let nextBuildKey = 0;\n  let stdout = new Uint8Array(16 * 1024);\n  let stdoutUsed = 0;\n  let readFromStdout = (chunk) => {\n    let limit = stdoutUsed + chunk.length;\n    if (limit > stdout.length) {\n      let swap = new Uint8Array(limit * 2);\n      swap.set(stdout);\n      stdout = swap;\n    }\n    stdout.set(chunk, stdoutUsed);\n    stdoutUsed += chunk.length;\n    let offset = 0;\n    while (offset + 4 <= stdoutUsed) {\n      let length = readUInt32LE(stdout, offset);\n      if (offset + 4 + length > stdoutUsed) {\n        break;\n      }\n      offset += 4;\n      handleIncomingPacket(stdout.subarray(offset, offset + length));\n      offset += length;\n    }\n    if (offset > 0) {\n      stdout.copyWithin(0, offset, stdoutUsed);\n      stdoutUsed -= offset;\n    }\n  };\n  let afterClose = () => {\n    isClosed = true;\n    for (let callback of responseCallbacks.values()) {\n      callback(\"The service was stopped\", null);\n    }\n    responseCallbacks.clear();\n    for (let callbacks of serveCallbacks.values()) {\n      callbacks.onWait(\"The service was stopped\");\n    }\n    serveCallbacks.clear();\n    for (let callback of watchCallbacks.values()) {\n      try {\n        callback(new Error(\"The service was stopped\"), null);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    watchCallbacks.clear();\n  };\n  let sendRequest = (refs, value, callback) => {\n    if (isClosed)\n      return callback(\"The service is no longer running\", null);\n    let id = nextRequestID++;\n    responseCallbacks.set(id, (error, response) => {\n      try {\n        callback(error, response);\n      } finally {\n        if (refs)\n          refs.unref();\n      }\n    });\n    if (refs)\n      refs.ref();\n    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));\n  };\n  let sendResponse = (id, value) => {\n    if (isClosed)\n      throw new Error(\"The service is no longer running\");\n    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));\n  };\n  let handleRequest = (id, request) => __async(this, null, function* () {\n    try {\n      switch (request.command) {\n        case \"ping\": {\n          sendResponse(id, {});\n          break;\n        }\n        case \"on-start\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-resolve\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-load\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"serve-request\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks && callbacks.onRequest)\n            callbacks.onRequest(request.args);\n          sendResponse(id, {});\n          break;\n        }\n        case \"serve-wait\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks)\n            callbacks.onWait(request.error);\n          sendResponse(id, {});\n          break;\n        }\n        case \"watch-rebuild\": {\n          let callback = watchCallbacks.get(request.key);\n          try {\n            if (callback)\n              callback(null, request.args);\n          } catch (err) {\n            console.error(err);\n          }\n          sendResponse(id, {});\n          break;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    } catch (e) {\n      sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")] });\n    }\n  });\n  let isFirstPacket = true;\n  let handleIncomingPacket = (bytes) => {\n    if (isFirstPacket) {\n      isFirstPacket = false;\n      let binaryVersion = String.fromCharCode(...bytes);\n      if (binaryVersion !== \"0.14.13\") {\n        throw new Error(`Cannot start service: Host version \"${\"0.14.13\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n      }\n      return;\n    }\n    let packet = decodePacket(bytes);\n    if (packet.isRequest) {\n      handleRequest(packet.id, packet.value);\n    } else {\n      let callback = responseCallbacks.get(packet.id);\n      responseCallbacks.delete(packet.id);\n      if (packet.value.error)\n        callback(packet.value.error, {});\n      else\n        callback(null, packet.value);\n    }\n  };\n  let handlePlugins = (initialOptions, plugins, buildKey, stash, refs) => __async(this, null, function* () {\n    let onStartCallbacks = [];\n    let onEndCallbacks = [];\n    let onResolveCallbacks = {};\n    let onLoadCallbacks = {};\n    let nextCallbackID = 0;\n    let i = 0;\n    let requestPlugins = [];\n    let isSetupDone = false;\n    plugins = [...plugins];\n    for (let item of plugins) {\n      let keys = {};\n      if (typeof item !== \"object\")\n        throw new Error(`Plugin at index ${i} must be an object`);\n      const name = getFlag(item, keys, \"name\", mustBeString);\n      if (typeof name !== \"string\" || name === \"\")\n        throw new Error(`Plugin at index ${i} is missing a name`);\n      try {\n        let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n        if (typeof setup !== \"function\")\n          throw new Error(`Plugin is missing a setup function`);\n        checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n        let plugin = {\n          name,\n          onResolve: [],\n          onLoad: []\n        };\n        i++;\n        let resolve = (path, options = {}) => {\n          if (!isSetupDone)\n            throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n          if (typeof path !== \"string\")\n            throw new Error(`The path to resolve must be a string`);\n          let keys2 = /* @__PURE__ */ Object.create(null);\n          let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n          let importer = getFlag(options, keys2, \"importer\", mustBeString);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n          let kind = getFlag(options, keys2, \"kind\", mustBeString);\n          let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n          checkForInvalidFlags(options, keys2, \"in resolve() call\");\n          return new Promise((resolve2, reject) => {\n            const request = {\n              command: \"resolve\",\n              path,\n              key: buildKey,\n              pluginName: name\n            };\n            if (pluginName != null)\n              request.pluginName = pluginName;\n            if (importer != null)\n              request.importer = importer;\n            if (namespace != null)\n              request.namespace = namespace;\n            if (resolveDir != null)\n              request.resolveDir = resolveDir;\n            if (kind != null)\n              request.kind = kind;\n            if (pluginData != null)\n              request.pluginData = stash.store(pluginData);\n            sendRequest(refs, request, (error, response) => {\n              if (error !== null)\n                reject(new Error(error));\n              else\n                resolve2({\n                  errors: replaceDetailsInMessages(response.errors, stash),\n                  warnings: replaceDetailsInMessages(response.warnings, stash),\n                  path: response.path,\n                  external: response.external,\n                  sideEffects: response.sideEffects,\n                  namespace: response.namespace,\n                  suffix: response.suffix,\n                  pluginData: stash.load(response.pluginData)\n                });\n            });\n          });\n        };\n        let promise = setup({\n          initialOptions,\n          resolve,\n          onStart(callback2) {\n            let registeredText = `This error came from the \"onStart\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n            onStartCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onEnd(callback2) {\n            let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n            onEndCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onResolve(options, callback2) {\n            let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onResolve() call is missing a filter`);\n            let id = nextCallbackID++;\n            onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          onLoad(options, callback2) {\n            let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onLoad() call is missing a filter`);\n            let id = nextCallbackID++;\n            onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          esbuild: streamIn.esbuild\n        });\n        if (promise)\n          yield promise;\n        requestPlugins.push(plugin);\n      } catch (e) {\n        return { ok: false, error: e, pluginName: name };\n      }\n    }\n    const callback = (request) => __async(this, null, function* () {\n      switch (request.command) {\n        case \"on-start\": {\n          let response = { errors: [], warnings: [] };\n          yield Promise.all(onStartCallbacks.map((_0) => __async(this, [_0], function* ({ name, callback: callback2, note }) {\n            try {\n              let result = yield callback2();\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                if (errors != null)\n                  response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                if (warnings != null)\n                  response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n              }\n            } catch (e) {\n              response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n            }\n          })));\n          return response;\n        }\n        case \"on-resolve\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onResolveCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                importer: request.importer,\n                namespace: request.namespace,\n                resolveDir: request.resolveDir,\n                kind: request.kind,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let path = getFlag(result, keys, \"path\", mustBeString);\n                let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (path != null)\n                  response.path = path;\n                if (namespace != null)\n                  response.namespace = namespace;\n                if (suffix != null)\n                  response.suffix = suffix;\n                if (external != null)\n                  response.external = external;\n                if (sideEffects != null)\n                  response.sideEffects = sideEffects;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        case \"on-load\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onLoadCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                namespace: request.namespace,\n                suffix: request.suffix,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let loader = getFlag(result, keys, \"loader\", mustBeString);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (contents instanceof Uint8Array)\n                  response.contents = contents;\n                else if (contents != null)\n                  response.contents = encodeUTF8(contents);\n                if (resolveDir != null)\n                  response.resolveDir = resolveDir;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (loader != null)\n                  response.loader = loader;\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    });\n    let runOnEndCallbacks = (result, logPluginError, done) => done();\n    if (onEndCallbacks.length > 0) {\n      runOnEndCallbacks = (result, logPluginError, done) => {\n        (() => __async(this, null, function* () {\n          for (const { name, callback: callback2, note } of onEndCallbacks) {\n            try {\n              yield callback2(result);\n            } catch (e) {\n              result.errors.push(yield new Promise((resolve) => logPluginError(e, name, note && note(), resolve)));\n            }\n          }\n        }))().then(done);\n      };\n    }\n    isSetupDone = true;\n    let refCount = 0;\n    return {\n      ok: true,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs: {\n        ref() {\n          if (++refCount === 1)\n            pluginCallbacks.set(buildKey, callback);\n        },\n        unref() {\n          if (--refCount === 0)\n            pluginCallbacks.delete(buildKey);\n        }\n      }\n    };\n  });\n  let buildServeData = (refs, options, request, key) => {\n    let keys = {};\n    let port = getFlag(options, keys, \"port\", mustBeInteger);\n    let host = getFlag(options, keys, \"host\", mustBeString);\n    let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n    let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n    let onWait;\n    let wait = new Promise((resolve, reject) => {\n      onWait = (error) => {\n        serveCallbacks.delete(key);\n        if (error !== null)\n          reject(new Error(error));\n        else\n          resolve();\n      };\n    });\n    request.serve = {};\n    checkForInvalidFlags(options, keys, `in serve() call`);\n    if (port !== void 0)\n      request.serve.port = port;\n    if (host !== void 0)\n      request.serve.host = host;\n    if (servedir !== void 0)\n      request.serve.servedir = servedir;\n    serveCallbacks.set(key, {\n      onRequest,\n      onWait\n    });\n    return {\n      wait,\n      stop() {\n        sendRequest(refs, { command: \"serve-stop\", key }, () => {\n        });\n      }\n    };\n  };\n  const buildLogLevelDefault = \"warning\";\n  const transformLogLevelDefault = \"silent\";\n  let buildOrServe = (args) => {\n    let key = nextBuildKey++;\n    const details = createObjectStash();\n    let plugins;\n    let { refs, options, isTTY, callback } = args;\n    if (typeof options === \"object\") {\n      let value = options.plugins;\n      if (value !== void 0) {\n        if (!Array.isArray(value))\n          throw new Error(`\"plugins\" must be an array`);\n        plugins = value;\n      }\n    }\n    let logPluginError = (e, pluginName, note, done) => {\n      let flags = [];\n      try {\n        pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n      } catch (e2) {\n      }\n      const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n      sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n        message.detail = details.load(message.detail);\n        done(message);\n      });\n    };\n    let handleError = (e, pluginName) => {\n      logPluginError(e, pluginName, void 0, (error) => {\n        callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n      });\n    };\n    if (plugins && plugins.length > 0) {\n      if (streamIn.isSync)\n        return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n      handlePlugins(options, plugins, key, details, refs).then((result) => {\n        if (!result.ok) {\n          handleError(result.error, result.pluginName);\n        } else {\n          try {\n            buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n              key,\n              details,\n              logPluginError,\n              requestPlugins: result.requestPlugins,\n              runOnEndCallbacks: result.runOnEndCallbacks,\n              pluginRefs: result.pluginRefs\n            }));\n          } catch (e) {\n            handleError(e, \"\");\n          }\n        }\n      }, (e) => handleError(e, \"\"));\n    } else {\n      try {\n        buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n          key,\n          details,\n          logPluginError,\n          requestPlugins: null,\n          runOnEndCallbacks: (result, logPluginError2, done) => done(),\n          pluginRefs: null\n        }));\n      } catch (e) {\n        handleError(e, \"\");\n      }\n    }\n  };\n  let buildOrServeContinue = ({\n    callName,\n    refs: callerRefs,\n    serveOptions,\n    options,\n    isTTY,\n    defaultWD,\n    callback,\n    key,\n    details,\n    logPluginError,\n    requestPlugins,\n    runOnEndCallbacks,\n    pluginRefs\n  }) => {\n    const refs = {\n      ref() {\n        if (pluginRefs)\n          pluginRefs.ref();\n        if (callerRefs)\n          callerRefs.ref();\n      },\n      unref() {\n        if (pluginRefs)\n          pluginRefs.unref();\n        if (callerRefs)\n          callerRefs.unref();\n      }\n    };\n    let writeDefault = !streamIn.isBrowser;\n    let {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch\n    } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n    let request = {\n      command: \"build\",\n      key,\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir: absWorkingDir || defaultWD,\n      incremental,\n      nodePaths\n    };\n    if (requestPlugins)\n      request.plugins = requestPlugins;\n    let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key);\n    let rebuild;\n    let stop;\n    let copyResponseToResult = (response, result) => {\n      if (response.outputFiles)\n        result.outputFiles = response.outputFiles.map(convertOutputFiles);\n      if (response.metafile)\n        result.metafile = JSON.parse(response.metafile);\n      if (response.writeToStdout !== void 0)\n        console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n    };\n    let buildResponseToResult = (response, callback2) => {\n      let result = {\n        errors: replaceDetailsInMessages(response.errors, details),\n        warnings: replaceDetailsInMessages(response.warnings, details)\n      };\n      copyResponseToResult(response, result);\n      runOnEndCallbacks(result, logPluginError, () => {\n        if (result.errors.length > 0) {\n          return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n        }\n        if (response.rebuild) {\n          if (!rebuild) {\n            let isDisposed = false;\n            rebuild = () => new Promise((resolve, reject) => {\n              if (isDisposed || isClosed)\n                throw new Error(\"Cannot rebuild\");\n              sendRequest(refs, { command: \"rebuild\", key }, (error2, response2) => {\n                if (error2) {\n                  const message = { pluginName: \"\", text: error2, location: null, notes: [], detail: void 0 };\n                  return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                }\n                buildResponseToResult(response2, (error3, result3) => {\n                  if (error3)\n                    reject(error3);\n                  else\n                    resolve(result3);\n                });\n              });\n            });\n            refs.ref();\n            rebuild.dispose = () => {\n              if (isDisposed)\n                return;\n              isDisposed = true;\n              sendRequest(refs, { command: \"rebuild-dispose\", key }, () => {\n              });\n              refs.unref();\n            };\n          }\n          result.rebuild = rebuild;\n        }\n        if (response.watch) {\n          if (!stop) {\n            let isStopped = false;\n            refs.ref();\n            stop = () => {\n              if (isStopped)\n                return;\n              isStopped = true;\n              watchCallbacks.delete(key);\n              sendRequest(refs, { command: \"watch-stop\", key }, () => {\n              });\n              refs.unref();\n            };\n            if (watch) {\n              watchCallbacks.set(key, (serviceStopError, watchResponse) => {\n                if (serviceStopError) {\n                  if (watch.onRebuild)\n                    watch.onRebuild(serviceStopError, null);\n                  return;\n                }\n                let result2 = {\n                  errors: replaceDetailsInMessages(watchResponse.errors, details),\n                  warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                };\n                copyResponseToResult(watchResponse, result2);\n                runOnEndCallbacks(result2, logPluginError, () => {\n                  if (result2.errors.length > 0) {\n                    if (watch.onRebuild)\n                      watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                    return;\n                  }\n                  if (watchResponse.rebuildID !== void 0)\n                    result2.rebuild = rebuild;\n                  result2.stop = stop;\n                  if (watch.onRebuild)\n                    watch.onRebuild(null, result2);\n                });\n              });\n            }\n          }\n          result.stop = stop;\n        }\n        callback2(null, result);\n      });\n    };\n    if (write && streamIn.isBrowser)\n      throw new Error(`Cannot enable \"write\" in the browser`);\n    if (incremental && streamIn.isSync)\n      throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n    if (watch && streamIn.isSync)\n      throw new Error(`Cannot use \"watch\" with a synchronous build`);\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      if (serve2) {\n        let serveResponse = response;\n        let isStopped = false;\n        refs.ref();\n        let result = {\n          port: serveResponse.port,\n          host: serveResponse.host,\n          wait: serve2.wait,\n          stop() {\n            if (isStopped)\n              return;\n            isStopped = true;\n            serve2.stop();\n            refs.unref();\n          }\n        };\n        refs.ref();\n        serve2.wait.then(refs.unref, refs.unref);\n        return callback(null, result);\n      }\n      return buildResponseToResult(response, callback);\n    });\n  };\n  let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n    const details = createObjectStash();\n    let start = (inputPath) => {\n      try {\n        if (typeof input !== \"string\")\n          throw new Error('The input to \"transform\" must be a string');\n        let flags = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n        let request = {\n          command: \"transform\",\n          flags,\n          inputFS: inputPath !== null,\n          input: inputPath !== null ? inputPath : input\n        };\n        sendRequest(refs, request, (error, response) => {\n          if (error)\n            return callback(new Error(error), null);\n          let errors = replaceDetailsInMessages(response.errors, details);\n          let warnings = replaceDetailsInMessages(response.warnings, details);\n          let outstanding = 1;\n          let next = () => --outstanding === 0 && callback(null, { warnings, code: response.code, map: response.map });\n          if (errors.length > 0)\n            return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n          if (response.codeFS) {\n            outstanding++;\n            fs.readFile(response.code, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.code = contents;\n                next();\n              }\n            });\n          }\n          if (response.mapFS) {\n            outstanding++;\n            fs.readFile(response.map, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.map = contents;\n                next();\n              }\n            });\n          }\n          next();\n        });\n      } catch (e) {\n        let flags = [];\n        try {\n          pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n        } catch (e2) {\n        }\n        const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n        sendRequest(refs, { command: \"error\", flags, error }, () => {\n          error.detail = details.load(error.detail);\n          callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n        });\n      }\n    };\n    if (typeof input === \"string\" && input.length > 1024 * 1024) {\n      let next = start;\n      start = () => fs.writeFile(input, next);\n    }\n    start(null);\n  };\n  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n    let result = sanitizeMessages(messages, \"messages\", null, \"\");\n    if (!options)\n      throw new Error(`Missing second argument in ${callName}() call`);\n    let keys = {};\n    let kind = getFlag(options, keys, \"kind\", mustBeString);\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (kind === void 0)\n      throw new Error(`Missing \"kind\" in ${callName}() call`);\n    if (kind !== \"error\" && kind !== \"warning\")\n      throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n    let request = {\n      command: \"format-msgs\",\n      messages: result,\n      isWarning: kind === \"warning\"\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (terminalWidth !== void 0)\n      request.terminalWidth = terminalWidth;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.messages);\n    });\n  };\n  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n    if (options === void 0)\n      options = {};\n    let keys = {};\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    let request = {\n      command: \"analyze-metafile\",\n      metafile\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (verbose !== void 0)\n      request.verbose = verbose;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.result);\n    });\n  };\n  return {\n    readFromStdout,\n    afterClose,\n    service: {\n      buildOrServe,\n      transform: transform2,\n      formatMessages: formatMessages2,\n      analyzeMetafile: analyzeMetafile2\n    }\n  };\n}\nfunction createObjectStash() {\n  const map = /* @__PURE__ */ new Map();\n  let nextID = 0;\n  return {\n    load(id) {\n      return map.get(id);\n    },\n    store(value) {\n      if (value === void 0)\n        return -1;\n      const id = nextID++;\n      map.set(id, value);\n      return id;\n    }\n  };\n}\nfunction extractCallerV8(e, streamIn, ident) {\n  let note;\n  let tried = false;\n  return () => {\n    if (tried)\n      return note;\n    tried = true;\n    try {\n      let lines = (e.stack + \"\").split(\"\\n\");\n      lines.splice(1, 1);\n      let location = parseStackLinesV8(streamIn, lines, ident);\n      if (location) {\n        note = { text: e.message, location };\n        return note;\n      }\n    } catch (e2) {\n    }\n  };\n}\nfunction extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n  let text = \"Internal error\";\n  let location = null;\n  try {\n    text = (e && e.message || e) + \"\";\n  } catch (e2) {\n  }\n  try {\n    location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n  } catch (e2) {\n  }\n  return { pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n}\nfunction parseStackLinesV8(streamIn, lines, ident) {\n  let at = \"    at \";\n  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i];\n      if (!line.startsWith(at))\n        continue;\n      line = line.slice(at.length);\n      while (true) {\n        let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n        if (match) {\n          let contents;\n          try {\n            contents = streamIn.readFileSync(match[1], \"utf8\");\n          } catch (e) {\n            break;\n          }\n          let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n          let column = +match[3] - 1;\n          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n          return {\n            file: match[1],\n            namespace: \"file\",\n            line: +match[2],\n            column: encodeUTF8(lineText.slice(0, column)).length,\n            length: encodeUTF8(lineText.slice(column, column + length)).length,\n            lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n            suggestion: \"\"\n          };\n        }\n        break;\n      }\n    }\n  }\n  return null;\n}\nfunction failureErrorWithLog(text, errors, warnings) {\n  let limit = 5;\n  let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n    if (i === limit)\n      return \"\\n...\";\n    if (!e.location)\n      return `\nerror: ${e.text}`;\n    let { file, line, column } = e.location;\n    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n    return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n  }).join(\"\");\n  let error = new Error(`${text}${summary}`);\n  error.errors = errors;\n  error.warnings = warnings;\n  return error;\n}\nfunction replaceDetailsInMessages(messages, stash) {\n  for (const message of messages) {\n    message.detail = stash.load(message.detail);\n  }\n  return messages;\n}\nfunction sanitizeLocation(location, where) {\n  if (location == null)\n    return null;\n  let keys = {};\n  let file = getFlag(location, keys, \"file\", mustBeString);\n  let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n  let line = getFlag(location, keys, \"line\", mustBeInteger);\n  let column = getFlag(location, keys, \"column\", mustBeInteger);\n  let length = getFlag(location, keys, \"length\", mustBeInteger);\n  let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n  let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n  checkForInvalidFlags(location, keys, where);\n  return {\n    file: file || \"\",\n    namespace: namespace || \"\",\n    line: line || 0,\n    column: column || 0,\n    length: length || 0,\n    lineText: lineText || \"\",\n    suggestion: suggestion || \"\"\n  };\n}\nfunction sanitizeMessages(messages, property, stash, fallbackPluginName) {\n  let messagesClone = [];\n  let index = 0;\n  for (const message of messages) {\n    let keys = {};\n    let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n    let text = getFlag(message, keys, \"text\", mustBeString);\n    let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n    let notes = getFlag(message, keys, \"notes\", mustBeArray);\n    let detail = getFlag(message, keys, \"detail\", canBeAnything);\n    let where = `in element ${index} of \"${property}\"`;\n    checkForInvalidFlags(message, keys, where);\n    let notesClone = [];\n    if (notes) {\n      for (const note of notes) {\n        let noteKeys = {};\n        let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n        let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n        checkForInvalidFlags(note, noteKeys, where);\n        notesClone.push({\n          text: noteText || \"\",\n          location: sanitizeLocation(noteLocation, where)\n        });\n      }\n    }\n    messagesClone.push({\n      pluginName: pluginName || fallbackPluginName,\n      text: text || \"\",\n      location: sanitizeLocation(location, where),\n      notes: notesClone,\n      detail: stash ? stash.store(detail) : -1\n    });\n    index++;\n  }\n  return messagesClone;\n}\nfunction sanitizeStringArray(values, property) {\n  const result = [];\n  for (const value of values) {\n    if (typeof value !== \"string\")\n      throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n    result.push(value);\n  }\n  return result;\n}\nfunction convertOutputFiles({ path, contents }) {\n  let text = null;\n  return {\n    path,\n    contents,\n    get text() {\n      if (text === null)\n        text = decodeUTF8(contents);\n      return text;\n    }\n  };\n}\n\n// lib/npm/browser.ts\nvar version = \"0.14.13\";\nvar build = (options) => ensureServiceIsRunning().build(options);\nvar serve = () => {\n  throw new Error(`The \"serve\" API only works in node`);\n};\nvar transform = (input, options) => ensureServiceIsRunning().transform(input, options);\nvar formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\nvar analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\nvar buildSync = () => {\n  throw new Error(`The \"buildSync\" API only works in node`);\n};\nvar transformSync = () => {\n  throw new Error(`The \"transformSync\" API only works in node`);\n};\nvar formatMessagesSync = () => {\n  throw new Error(`The \"formatMessagesSync\" API only works in node`);\n};\nvar analyzeMetafileSync = () => {\n  throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n};\nvar initializePromise;\nvar longLivedService;\nvar ensureServiceIsRunning = () => {\n  if (longLivedService)\n    return longLivedService;\n  if (initializePromise)\n    throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n  throw new Error('You need to call \"initialize\" before calling this');\n};\nvar initialize = (options) => {\n  options = validateInitializeOptions(options || {});\n  let wasmURL = options.wasmURL;\n  let useWorker = options.worker !== false;\n  if (!wasmURL)\n    throw new Error('Must provide the \"wasmURL\" option');\n  wasmURL += \"\";\n  if (initializePromise)\n    throw new Error('Cannot call \"initialize\" more than once');\n  initializePromise = startRunningService(wasmURL, useWorker);\n  initializePromise.catch(() => {\n    initializePromise = void 0;\n  });\n  return initializePromise;\n};\nvar startRunningService = (wasmURL, useWorker) => __async(void 0, null, function* () {\n  let res = yield fetch(wasmURL);\n  if (!res.ok)\n    throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n  let wasm = yield res.arrayBuffer();\n  let code = `{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\t// - Webpack\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tconst fs = require(\"fs\");\n\t\tif (typeof fs === \"object\" && fs !== null && Object.keys(fs).length !== 0) {\n\t\t\t\n    global.fs = Object.assign({}, fs, {\n      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550\n      write(fd, buf, offset, length, position, callback) {\n        if (offset === 0 && length === buf.length && position === null) {\n          if (fd === process.stdout.fd) {\n            try {\n              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n          if (fd === process.stderr.fd) {\n            try {\n              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n        }\n        fs.write(fd, buf, offset, length, position, callback);\n      },\n    });\n  \n\t\t}\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto && global.require) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\tif (!global.crypto) {\n\t\tthrow new Error(\"global.crypto is not available, polyfill required (getRandomValues only)\");\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder && global.require) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\tif (!global.TextEncoder) {\n\t\tthrow new Error(\"global.TextEncoder is not available, polyfill required\");\n\t}\n\n\tif (!global.TextDecoder && global.require) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\tif (!global.TextDecoder) {\n\t\tthrow new Error(\"global.TextDecoder is not available, polyfill required\");\n\t}\n\n\t// End of polyfills for common API.\n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis.argv = [\"js\"];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = (code) => {\n\t\t\t\tif (code !== 0) {\n\t\t\t\t\tconsole.warn(\"exit code:\", code);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise((resolve) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t});\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tthis.mem.setUint32(addr + 0, v, true);\n\t\t\t\tthis.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = this.mem.getUint32(addr + 0, true);\n\t\t\t\tconst high = this.mem.getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = this.mem.getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = this.mem.getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\" && v !== 0) {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tthis.mem.setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tthis.mem.setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.mem.setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tthis.mem.setFloat64(addr, 0, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tthis.mem.setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn new Uint8Array(this._inst.exports.mem.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (addr) => {\n\t\t\t\tconst saddr = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst code = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._goRefCounts;\n\t\t\t\t\t\tdelete this._ids;\n\t\t\t\t\t\tdelete this._idPool;\n\t\t\t\t\t\tthis.exit(code);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst fd = getInt64(sp + 8);\n\t\t\t\t\t\tconst p = getInt64(sp + 16);\n\t\t\t\t\t\tconst n = this.mem.getInt32(sp + 24, true);\n\t\t\t\t\t\tfs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func resetMemoryDataView()\n\t\t\t\t\t\"runtime.resetMemoryDataView\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime1() int64\n\t\t\t\t\t\"runtime.nanotime1\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst msec = (new Date).getTime();\n\t\t\t\t\t\tsetInt64(sp + 8, msec / 1000);\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set(id, setTimeout(\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\twhile (this._scheduledTimeouts.has(id)) {\n\t\t\t\t\t\t\t\t\t// for some reason Go failed to register the timeout event, log and try again\n\t\t\t\t\t\t\t\t\t// (temporary workaround for https://github.com/golang/go/issues/28975)\n\t\t\t\t\t\t\t\t\tconsole.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\t\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, id, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tclearTimeout(this._scheduledTimeouts.get(id));\n\t\t\t\t\t\tthis._scheduledTimeouts.delete(id);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getUint32(sp + 8, true);\n\t\t\t\t\t\tthis._goRefCounts[id]--;\n\t\t\t\t\t\tif (this._goRefCounts[id] === 0) {\n\t\t\t\t\t\t\tconst v = this._values[id];\n\t\t\t\t\t\t\tthis._values[id] = null;\n\t\t\t\t\t\t\tthis._ids.delete(v);\n\t\t\t\t\t\t\tthis._idPool.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, loadString(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\tstoreValue(sp + 32, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst m = Reflect.get(v, loadString(sp + 16));\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 32);\n\t\t\t\t\t\t\tconst result = Reflect.apply(m, v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.apply(v, undefined, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.construct(v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = encoder.encode(String(loadValue(sp + 8)));\n\t\t\t\t\t\tstoreValue(sp + 16, str);\n\t\t\t\t\t\tsetInt64(sp + 24, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = loadValue(sp + 8);\n\t\t\t\t\t\tloadSlice(sp + 16).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadSlice(sp + 8);\n\t\t\t\t\t\tconst src = loadValue(sp + 32);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadValue(sp + 8);\n\t\t\t\t\t\tconst src = loadSlice(sp + 16);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": (value) => {\n\t\t\t\t\t\tconsole.log(value);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tif (!(instance instanceof WebAssembly.Instance)) {\n\t\t\t\tthrow new Error(\"Go.run: WebAssembly.Instance expected\");\n\t\t\t}\n\t\t\tthis._inst = instance;\n\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map([ // mapping from JS values to reference ids\n\t\t\t\t[0, 1],\n\t\t\t\t[null, 2],\n\t\t\t\t[true, 3],\n\t\t\t\t[false, 4],\n\t\t\t\t[global, 5],\n\t\t\t\t[this, 6],\n\t\t\t]);\n\t\t\tthis._idPool = [];   // unused ids that have been garbage collected\n\t\t\tthis.exited = false; // whether the Go program has exited\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = (str) => {\n\t\t\t\tconst ptr = offset;\n\t\t\t\tconst bytes = encoder.encode(str + \"\\\\0\");\n\t\t\t\tnew Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n\t\t\t\toffset += bytes.length;\n\t\t\t\tif (offset % 8 !== 0) {\n\t\t\t\t\toffset += 8 - (offset % 8);\n\t\t\t\t}\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach((arg) => {\n\t\t\t\targvPtrs.push(strPtr(arg));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst keys = Object.keys(this.env).sort();\n\t\t\tkeys.forEach((key) => {\n\t\t\t\targvPtrs.push(strPtr(\\`\\${key}=\\${this.env[key]}\\`));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach((ptr) => {\n\t\t\t\tthis.mem.setUint32(offset, ptr, true);\n\t\t\t\tthis.mem.setUint32(offset + 4, 0, true);\n\t\t\t\toffset += 8;\n\t\t\t});\n\n\t\t\t// The linker guarantees global data starts from at least wasmMinDataAddr.\n\t\t\t// Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\t\t\tconst wasmMinDataAddr = 4096 + 8192;\n\t\t\tif (offset >= wasmMinDataAddr) {\n\t\t\t\tthrow new Error(\"total length of command line and environment variables exceeds limit\");\n\t\t\t}\n\n\t\t\tthis._inst.exports.run(argc, argv);\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\ttypeof module !== \"undefined\" &&\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length < 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tgo.argv = process.argv.slice(2);\n\t\tgo.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n\t\tgo.exit = process.exit;\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\tprocess.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n\t\t\t\tif (code === 0 && !go.exited) {\n\t\t\t\t\t// deadlock, make Go print error and stack traces\n\t\t\t\t\tgo._pendingEvent = { id: 0 };\n\t\t\t\t\tgo._resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();\nonmessage = ({ data: wasm }) => {\n  let decoder = new TextDecoder();\n  let fs = global.fs;\n  let stderr = \"\";\n  fs.writeSync = (fd, buffer) => {\n    if (fd === 1) {\n      postMessage(buffer);\n    } else if (fd === 2) {\n      stderr += decoder.decode(buffer);\n      let parts = stderr.split(\"\\\\n\");\n      if (parts.length > 1)\n        console.log(parts.slice(0, -1).join(\"\\\\n\"));\n      stderr = parts[parts.length - 1];\n    } else {\n      throw new Error(\"Bad write\");\n    }\n    return buffer.length;\n  };\n  let stdin = [];\n  let resumeStdin;\n  let stdinPos = 0;\n  onmessage = ({ data }) => {\n    if (data.length > 0) {\n      stdin.push(data);\n      if (resumeStdin)\n        resumeStdin();\n    }\n  };\n  fs.read = (fd, buffer, offset, length, position, callback) => {\n    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n      throw new Error(\"Bad read\");\n    }\n    if (stdin.length === 0) {\n      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n      return;\n    }\n    let first = stdin[0];\n    let count = Math.max(0, Math.min(length, first.length - stdinPos));\n    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n    stdinPos += count;\n    if (stdinPos === first.length) {\n      stdin.shift();\n      stdinPos = 0;\n    }\n    callback(null, count);\n  };\n  let go = new global.Go();\n  go.argv = [\"\", \\`--service=\\${\"0.14.13\"}\\`];\n  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n};}`;\n  let worker;\n  if (useWorker) {\n    let blob = new Blob([code], { type: \"text/javascript\" });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    let fn = new Function(\"postMessage\", code + `var onmessage; return m => onmessage(m)`);\n    let onmessage = fn((data) => worker.onmessage({ data }));\n    worker = {\n      onmessage: null,\n      postMessage: (data) => onmessage({ data }),\n      terminate() {\n      }\n    };\n  }\n  worker.postMessage(wasm);\n  worker.onmessage = ({ data }) => readFromStdout(data);\n  let { readFromStdout, service } = createChannel({\n    writeToStdin(bytes) {\n      worker.postMessage(bytes);\n    },\n    isSync: false,\n    isBrowser: true,\n    esbuild: browser_exports\n  });\n  longLivedService = {\n    build: (options) => new Promise((resolve, reject) => service.buildOrServe({\n      callName: \"build\",\n      refs: null,\n      serveOptions: null,\n      options,\n      isTTY: false,\n      defaultWD: \"/\",\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    transform: (input, options) => new Promise((resolve, reject) => service.transform({\n      callName: \"transform\",\n      refs: null,\n      input,\n      options: options || {},\n      isTTY: false,\n      fs: {\n        readFile(_, callback) {\n          callback(new Error(\"Internal error\"), null);\n        },\n        writeFile(_, callback) {\n          callback(null);\n        }\n      },\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n      callName: \"formatMessages\",\n      refs: null,\n      messages,\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n      callName: \"analyzeMetafile\",\n      refs: null,\n      metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    }))\n  };\n});\nmodule.exports = __toCommonJS(browser_exports);\n})(typeof module===\"object\"?module:{set exports(x){(typeof self!==\"undefined\"?self:this).esbuild=x}});\n", "import { Mutex } from \"async-mutex\";\nimport * as esbuild from \"esbuild-wasm\";\nimport esbuildWasm from \"./vendor/esbuild.wasm\";\nimport { wait } from \"./wait\";\n\nfunction createWasmBlob(wasm: string) {\n  const blob = new Blob([wasm], { type: \"application/wasm\" });\n\n  return URL.createObjectURL(blob);\n}\n\nconst init = esbuild.initialize({\n  wasmURL: createWasmBlob(esbuildWasm),\n});\n\nlet initFinished = false;\nconst mutex = new Mutex();\n\nexport const transform = async (code, retry = 4) => {\n  const startTime = performance.now();\n\n  if (initFinished || await init) {\n    initFinished = true;\n  }\n\n  let result;\n  try {\n    await mutex.waitForUnlock();\n    result = await esbuild.transform(code, {\n      loader: \"tsx\",\n      target: \"es2018\",\n    });\n  } catch (e) {\n    if (retry > 0) {\n      await wait(100);\n      return transform(code, retry - 1);\n    }\n    throw e;\n  }\n\n  const endTime = performance.now();\n\n  console.log(`esbuildEsmTransform: took ${endTime - startTime} milliseconds`);\n  return result.code;\n};\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": []
}

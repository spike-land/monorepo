import{b as M}from"./chunk-7PQ4F5JZ.mjs";import"./chunk-AA5DZHZL.mjs";import"./chunk-SVD4IHMW.mjs";import{Vj as L}from"./chunk-DCJ5ZKBM.mjs";import{d as A}from"./chunk-URSQB37F.mjs";var H=A(M());var y,W=new Uint8Array(16);function $(){if(!y&&(y=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!y))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return y(W)}var G=/^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;function F(e){return typeof e=="string"&&G.test(e)}var a=[];for(let e=0;e<256;++e)a.push((e+256).toString(16).slice(1));function B(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(a[e[n+0]]+a[e[n+1]]+a[e[n+2]]+a[e[n+3]]+"-"+a[e[n+4]]+a[e[n+5]]+"-"+a[e[n+6]]+a[e[n+7]]+"-"+a[e[n+8]]+a[e[n+9]]+"-"+a[e[n+10]]+a[e[n+11]]+a[e[n+12]]+a[e[n+13]]+a[e[n+14]]+a[e[n+15]]).toLowerCase();if(!F(t))throw new TypeError("Stringified UUID is invalid");return t}function O(e,n,t){e=e||{};let s=e.random||(e.rng||$)();if(s[6]=s[6]&15|64,s[8]=s[8]&63|128,n){t=t||0;for(let f=0;f<16;++f)n[t+f]=s[f];return n}return B(s)}var D=[],q=window.location.hostname||"spike.land",w=location.pathname.split("/"),I=(w[1]==="api"&&w[2]==="room"?w[3]:(w.pop()||w.pop()).slice(-12))||"code-main",k=(self&&self.crypto&&self.crypto.randomUUID&&self.crypto.randomUUID()||O()).slice(0,8),E=0,S=0,b="",l="",R=0,C=0,c=null,u=!1,m={send:e=>{let n=e.target,t=JSON.stringify({...e,name:e.name||l});D.map(s=>{try{if(s.readyState!=="open")return;s.target===n&&s.send(t)}catch(f){console.error("Error in broadcasting event",{e:f})}})}},z=await fetch(`https://spike.land/api/room/${I}/session`),K=await z.json(),{startSession:Q}=await import("./session-NZCY52AC.mjs"),d=Q(I,{name:l,state:K}),X=()=>d.json().state,v=null;setInterval(()=>{Date.now()-C>4e4?(u=!1,g()):console.log("no_need_to_rejoin")},3e4);var p=window,N=async(e,n)=>{if(!e)return;let t=X();if(!(n<t.i)&&e!==t.code)try{let s=L.parse("file:///app/index.tsx");if(p.sess&&p.sess.editor&&p.sess.editor.getModel&&p.sess.editor.getModel(s)){let f=p.sess.editor.getModel(s);f&&f.setValue(e)}else p.sess&&p.sess.update&&p.sess.update(e)}catch(s){console.error({e:s})}};async function g(){return!u||c===null?(c=null,c||(c=await Z(),c)):c}var ce=(0,H.default)(Y,500);async function Y(e){if((async()=>{try{if(m){let n=S?d.createPatchFromHashCode(S,e):d.createPatch(e);n&&n.patch!==""&&m.send(n)}}catch(n){console.error("Error sending RTC...",{e:n})}})(),c){let n=E?d.createPatchFromHashCode(E,e):d.createPatch(e);if(!n)return;let t=JSON.stringify({...n,name:l});n.patch!==""&&c.send(t)}else u=!1,await g()}async function Z(){if(b=b||I||"code-main",k&&(l=k),c!==null)return c;u=!0;let e=new WebSocket("wss://"+q+"/api/room/"+b+"/websocket");return u=!1,e.addEventListener("open",()=>(c=e,v&&clearInterval(v),v=setInterval(()=>{let n=Date.now(),t=n-C;if(n-C>3e4)try{e.send(JSON.stringify({name:l,time:R+t}))}catch{u=!1,g()}},3e4),e.send(JSON.stringify({name:l})),e)),e.addEventListener("message",n=>x(n,"ws")),e.addEventListener("close",n=>{console.log("WebSocket closed, reconnecting:",n.code,n.reason),u=!1,g()}),e.addEventListener("error",n=>{console.log("WebSocket error, reconnecting:",n),u=!1,g()}),e}var T=window.location.hostname;T||(T="localhost");i("Hostname: "+T);var o={};function i(e){let n=new Date;console.log("["+n.toLocaleTimeString()+"] "+e)}function ee(e){let n=new Date;console.trace("["+n.toLocaleTimeString()+"] "+e)}var P={iceServers:["stun3.l.google.com:19302"].map(e=>({urls:`stun:${e}`}))};P.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}];async function J(e){if(i(`Setting up a connection with ${e}`),o[e]){i(`Aborting, since we have connection with this ${e}`);return}o[e]=new RTCPeerConnection(P),o[e].onicecandidate=r=>{r.candidate&&(i("*** Outgoing ICE candidate: "+r.candidate),c.send(JSON.stringify({type:"new-ice-candidate",target:e,name:l,candidate:r.candidate})))},o[e].oniceconnectionstatechange=_,o[e].onicegatheringstatechange=j,o[e].onsignalingstatechange=()=>{switch(i("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}},o[e].onnegotiationneeded=f,o[e].ontrack=r=>console.log(r),o[e].ondatachannel=r=>{console.log("Receive Channel Callback");let h=r.channel;h.binaryType="arraybuffer",h.addEventListener("close",s),h.addEventListener("message",V=>x(V,"rtc"));let U=Object.assign(h,{target:e});D.push(U)};let n={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},t=Object.assign(o[e].createDataChannel(e,n),{target:e});return t.binaryType="arraybuffer",t.addEventListener("message",r=>{console.log("***********RTC***",{msg:r});let h=JSON.parse(r.data);return h&&h.hashCode&&(S=h.hashCode),h&&h.newHash&&(S=h.newHash),x(r,"rtc")}),t.addEventListener("error",r=>{console.log("xxxxxx-  Data Channel Error:",r)}),t.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),D.push(t)}),t.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function s(){console.log("Receive channel is closed"),o[e].close(),delete o[e],console.log("Closed remote peer connection")}async function f(){i("*** Negotiation needed");try{i("---> Creating offer");let r=await o[e].createOffer();if(o[e].signalingState!="stable"){i("     -- The connection isn't stable yet; postponing...");return}i("---> Setting local description to the offer"),await o[e].setLocalDescription(r),i("---> Sending the offer to the remote peer"),c&&c.send(JSON.stringify({target:e,name:l,type:"offer",sdp:o[e].localDescription}))}catch{i("*** The following error occurred while handling the negotiationneeded event:")}}function _(){switch(i("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function j(){i("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function ne(e,n){i("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let t=new RTCIceCandidate(e);console.log(o[n]),await o[n].addIceCandidate(t)}async function te(e,n){i("*** Call recipient has accepted our call");let t=new RTCSessionDescription(e);await o[n].setRemoteDescription(t).catch(console.error)}async function oe(e,n){if(o[n]||await J(n),!e.sdp)return;let t=new RTCSessionDescription(e);if(o[n].signalingState!="stable"){i("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[n].setLocalDescription({type:"rollback"}),o[n].setRemoteDescription(t)]);return}i("  - Setting remote description"),await o[n].setRemoteDescription(t),i("---> Creating and sending answer to caller"),await o[n].setLocalDescription(await o[n].createAnswer());let s=c||await g();s!==null&&s.send(JSON.stringify({target:n,name:l,type:"answer",sdp:o[n].localDescription}))}async function x(e,n){console.log(n,{event:e}),C=Date.now();let t=JSON.parse(e.data);if(t.name&&t.name!==l&&!o[t.name])try{await J(t.name)}catch(s){console.log({e:s}),ee("Error with p2p")}if(console.log(n,t.name),t.type==="new-ice-candidate"){await ne(t,t.name);return}if(t.type==="offer"){await oe(t,t.name);return}if(t.type==="answer"){await te(t,t.name);return}if(n==="ws"&&t.hashCode&&(E=t.hashCode),t.patch&&n==="ws"||t.name!==l){if(t.newHash===d.hashCode())return;if(t.oldHash===d.hashCode()){d.applyPatch(t),N(d.session.get("state").code,d.session.get("state").i),m&&m.send({hashCode:t.newHash});return}if(t.newHash===d.hashCode())return;if(t.code&&t.transpiled){let s=d.createPatch(t);d.applyPatch(s),N(t.code,t.i),m&&m.send({hashCode:s.newHash});return}return}t.timestamp&&(C=Date.now(),R=t.timestamp),t.name!==l&&(R=t.timestamp)}export{Z as join,ce as saveCode};

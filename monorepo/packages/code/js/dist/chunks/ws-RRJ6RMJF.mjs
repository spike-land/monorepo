import{a as q}from"./chunk-CWAIQPIX.mjs";import{a as v,b as E,g as M}from"./chunk-R25N5FFR.mjs";var j=M(q());var T,F=new Uint8Array(16);function G(){if(!T&&(T=typeof crypto!="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!="undefined"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!T))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return T(F)}var B=/^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;function z(e){return typeof e=="string"&&B.test(e)}var c=[];for(let e=0;e<256;++e)c.push((e+256).toString(16).slice(1));function K(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,n=(c[e[t+0]]+c[e[t+1]]+c[e[t+2]]+c[e[t+3]]+"-"+c[e[t+4]]+c[e[t+5]]+"-"+c[e[t+6]]+c[e[t+7]]+"-"+c[e[t+8]]+c[e[t+9]]+"-"+c[e[t+10]]+c[e[t+11]]+c[e[t+12]]+c[e[t+13]]+c[e[t+14]]+c[e[t+15]]).toLowerCase();if(!z(n))throw new TypeError("Stringified UUID is invalid");return n}function J(e,t,n){e=e||{};let i=e.random||(e.rng||G)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,t){n=n||0;for(let p=0;p<16;++p)t[n+p]=i[p];return t}return K(i)}var L=[],Q=window.location.hostname||"spike.land",O="",D="",w="",h="",N=0,y=0,l=null,m=!1,X=Date.now(),g=null,r=null,V=()=>r.session.get("state"),x=null;setInterval(()=>{Date.now()-y>4e4?(m=!1,C()):console.log("no_need_to_rejoin")},3e4);var _=async(e,t)=>{if(!e)return;let n=V().toJSON();if(!(t<n.i)&&e!==n.code)try{n&&n.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(i){console.error({e:i})}};async function C(){return!m||l===null?(l=null,l||(l=await Z(),l)):l}var ae=(0,j.default)(Y,100);async function Y(e){if((async()=>{try{if(g){let t=D?r.createPatchFromHashCode(D,e):r.createPatch(e);t&&t.patch!==""&&g.send(t)}}catch(t){console.error("Error sending RTC...",{e:t})}})(),l){let t=O?r.createPatchFromHashCode(O,e):r.createPatch(e);if(!t)return;let n=JSON.stringify(E(v({},t),{name:h}));t.patch!==""&&l.send(n)}else m=!1,await C()}var Z=async()=>{let e=location.pathname.split("/"),t=(e[1]==="api"&&e[2]==="room"?e[3]:(e.pop()||e.pop()).slice(-12))||"code-main",n=(self&&self.crypto&&self.crypto.randomUUID&&self.crypto.randomUUID()||J()).slice(0,8);if(w=w||t||"code-main",n&&(h=n),l!==null)return l;m=!0;let p=await(await fetch(`https://spike.land/api/room/${w}/session`)).json(),{startSession:R}=await import("./session-5LRPDRHJ.mjs");r=r||await R(w,{name:h,state:p});let u=new WebSocket("wss://"+Q+"/api/room/"+w+"/websocket");if(m=!1,X=Date.now(),u.addEventListener("open",()=>(l=u,x&&clearInterval(x),x=setInterval(()=>{let d=Date.now(),S=d-y;if(d-y>3e4)try{u.send(JSON.stringify({name:h,time:N+S}))}catch(b){m=!1,C()}},3e4),u.send(JSON.stringify({name:h})),u)),!window.sess){let d=E(v({},V().toJSON()),{setChild:()=>{},changes:[],children:[globalThis.App],errorText:""}),S=location.pathname.endsWith("public"),{quickStart:b}=await import("./quickStart-7XK2E23F.mjs");b(d,w,S),window.sess=d}return u.addEventListener("message",d=>P(d,"ws")),u.addEventListener("close",d=>{console.log("WebSocket closed, reconnecting:",d.code,d.reason),m=!1,C()}),u.addEventListener("error",d=>{console.log("WebSocket error, reconnecting:",d),m=!1,C()}),u},H=window.location.hostname;H||(H="localhost");a("Hostname: "+H);var o={};function a(e){let t=new Date;console.log("["+t.toLocaleTimeString()+"] "+e)}function ee(e){let t=new Date;console.trace("["+t.toLocaleTimeString()+"] "+e)}var A={iceServers:["stun3.l.google.com:19302"].map(e=>({urls:`stun:${e}`}))};A.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}];async function U(e){if(a(`Setting up a connection with ${e}`),o[e]){a(`Aborting, since we have connection with this ${e}`);return}o[e]=new RTCPeerConnection(A),o[e].onicecandidate=d,o[e].oniceconnectionstatechange=S,o[e].onicegatheringstatechange=W,o[e].onsignalingstatechange=b,o[e].onnegotiationneeded=R,o[e].ontrack=u,o[e].addEventListener("datachannel",i);let t={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},n=o[e].createDataChannel(e,t);return n.binaryType="arraybuffer",n.addEventListener("message",s=>{console.log("***********RTC***",{msg:s});let f=JSON.parse(s.data);return f&&f.hashCode&&(D=f.hashCode),f&&f.newHash&&(D=f.newHash),P(s,"rtc")}),n.addEventListener("error",s=>{console.log("xxxxxx-  Data Channel Error:",s)}),n.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),n.target=e,L.push(n),o[e].sendChannel=n,g=g={send:s=>{let f=s.target,k=JSON.stringify(E(v({},s),{name:s.name||h}));L.map(I=>{try{if(I.readyState!=="open")return;I.target===f&&I.send(k)}catch($){console.error("Error in broadcasting event",{e:$})}})}}}),n.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function i(s){console.log("Receive Channel Callback");let f=s.channel;f.binaryType="arraybuffer",f.addEventListener("close",p),f.addEventListener("message",k=>P(k,"rtc")),L.push(f)}function p(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function R(){a("*** Negotiation needed");try{a("---> Creating offer");let s=await o[e].createOffer();if(o[e].signalingState!="stable"){a("     -- The connection isn't stable yet; postponing...");return}a("---> Setting local description to the offer"),await o[e].setLocalDescription(s),a("---> Sending the offer to the remote peer"),l.send(JSON.stringify({target:e,name:h,type:"offer",sdp:o[e].localDescription}))}catch(s){a("*** The following error occurred while handling the negotiationneeded event:")}}function u(s){a("*** Track event"),document.querySelector("#received_video").srcObject=s.streams[0],document.querySelector("#hangup-button").disabled=!1}function d(s){s.candidate&&(a("*** Outgoing ICE candidate: "+s.candidate),l.send(JSON.stringify({type:"new-ice-candidate",target:e,name:h,candidate:s.candidate})))}function S(){switch(a("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function b(){switch(a("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function W(){a("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function ne(e,t){a("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let n=new RTCIceCandidate(e.candidate);console.log(o[t]),await o[t].addIceCandidate(n)}async function te(e,t){a("*** Call recipient has accepted our call");let n=new RTCSessionDescription(e.sdp);await o[t].setRemoteDescription(n).catch(console.error)}async function oe(e,t){if(o[t]||await U(t),!e.sdp)return;let n=new RTCSessionDescription(e.sdp);if(o[t].signalingState!="stable"){a("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[t].setLocalDescription({type:"rollback"}),o[t].setRemoteDescription(n)]);return}a("  - Setting remote description"),await o[t].setRemoteDescription(n),a("---> Creating and sending answer to caller"),await o[t].setLocalDescription(await o[t].createAnswer());let i=l||await C();i!==null&&i.send(JSON.stringify({target:t,name:h,type:"answer",sdp:o[t].localDescription}))}async function P(e,t){console.log(t,{event:e}),y=Date.now();let n=JSON.parse(e.data);if(n.name&&n.name!==h&&!o[n.name])try{await U(n.name)}catch(i){console.log({e:i}),ee("Error with p2p")}if(console.log(t,n.name),n.type==="new-ice-candidate"){await ne(n,n.name);return}if(n.type==="offer"){await oe(n,n.name);return}if(n.type==="answer"){await te(n,n.name);return}if(t==="ws"&&n.hashCode&&(O=n.hashCode),n.patch&&t==="ws"||n.name!==h){if(n.newHash===r.hashCode())return;if(n.oldHash===r.hashCode()){r.applyPatch(n),_(r.session.get("state").code,r.session.get("state").i),g&&g.send({hashCode:n.newHash});return}if(n.newHash===r.hashCode())return;if(n.code&&n.transpiled){let i=r.createPatch(n);r.applyPatch(i),_(n.code,n.i),g&&g.send({hashCode:i.newHash});return}return}n.timestamp&&(y=Date.now(),N=n.timestamp),n.name!==h&&(N=n.timestamp)}export{Z as join,ae as saveCode};

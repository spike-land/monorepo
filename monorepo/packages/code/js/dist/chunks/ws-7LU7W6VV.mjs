import{a as F}from"./chunk-CWAIQPIX.mjs";import{a as v,b as E,g as q}from"./chunk-R25N5FFR.mjs";var j=q(F()),O=!1,N=[],G=window.location.hostname||"spike.land",I="",T="",m="",f="",R=0,b=0,l=null,W,u=!1,p=null;var r=null,H=()=>r.session.get("state"),x=null;setInterval(()=>{Date.now()-b>4e4?(u=!1,y()):console.log("no_need_to_rejoin")},3e4);var _=async(e,t)=>{if(!!e&&!(t<window.sess.i)&&e!==window.sess.code)try{window.sess&&window.sess.editor?window.sess.editor.getModel().setValue(e):window.sess.update(e)}catch(n){console.error({e:n})}};async function y(){if(!u||l===null){l=null;let e=Date.now()-W;return e<1e4&&await new Promise(t=>setTimeout(t,1e4-e)),l||(l=await V(),l)}return l}var X=(0,j.default)(B,100);async function B(e){let{i:t,code:n,transpiled:d,html:g,css:C}=e;if((async()=>{try{if(p){let a=H().toJSON();a.html=g,a.css=C,a.transpiled=d,a.code=n,a.i=t;let s=T?r.createPatchFromHashCode(T,a):r.createPatch(a);s&&s.patch!==""&&p.send(s)}}catch(a){console.error("Error sending RTC...",{e:a})}})(),l){let a=Date.now(),s=H().toJSON();s.html=g,s.css=C,s.transpiled=d,s.code=n,s.i=t;let w=I?r.createPatchFromHashCode(I,s):r.createPatch(s);if(!w)return;let S=JSON.stringify(E(v({},w),{name:f}));w.patch!==""&&currentWebSocket.send(S)}else u=!1,await y()}var V=async(e,t,n)=>{if(m=m||e||"code-main",window.room=e,t&&(f=t),l!==null)return l;u=!0;let g=await(await fetch(`https://spike.land/api/room/${m}/session`)).json(),{startSession:C}=await import("./session-BO4AL4K3.mjs");if(r=r||await C(m,{name:f,room:m,state:g,events:[]}),window.mySession=r,!n&&!window.sess){let s=E(v({},H().toJSON()),{setChild:()=>{},changes:[],children:[globalThis.App],errorText:""}),w=(await import("./throttle-UJQ536PU.mjs")).default,S=location.pathname.endsWith("public"),{quickStart:D}=await import("./quickStart-JKEYXMZC.mjs");D(s,m,S),window.sess=s}if(O)return;O=!0,setTimeout(()=>{O=!1},1e4);let a=new WebSocket("wss://"+G+"/api/room/"+m+"/websocket");u=!1,W=Date.now(),a.addEventListener("open",()=>(l=a,x&&clearInterval(x),x=setInterval(()=>{let s=Date.now(),w=s-b;if(s-b>3e4)try{l.send(JSON.stringify({name:f,time:R+w}))}catch(S){u=!1,y()}},3e4),a.send(JSON.stringify({name:f})),a)),a.addEventListener("message",s=>P(s,"ws")),a.addEventListener("close",s=>{console.log("WebSocket closed, reconnecting:",s.code,s.reason),u=!1,y()}),a.addEventListener("error",s=>{console.log("WebSocket error, reconnecting:",s),u=!1,y()})},J=window.location.hostname;J||(J="localhost");c("Hostname: "+J);var o={};function c(e){let t=new Date;console.log("["+t.toLocaleTimeString()+"] "+e)}function z(e){let t=new Date;console.trace("["+t.toLocaleTimeString()+"] "+e)}var A={iceServers:["stun3.l.google.com:19302"].map(e=>({urls:`stun:${e}`}))};A.iceServers=[{urls:"stun:stun.stunprotocol.org:3478"},{urls:"stun:stun.l.google.com:19302"}];async function M(e){if(c(`Setting up a connection with ${e}`),o[e]){c(`Aborting, since we have connection with this ${e}`);return}o[e]=new RTCPeerConnection(A),o[e].onicecandidate=s,o[e].oniceconnectionstatechange=w,o[e].onicegatheringstatechange=D,o[e].onsignalingstatechange=S,o[e].onnegotiationneeded=C,o[e].ontrack=a,o[e].addEventListener("datachannel",d);let t={ordered:!0,reliable:!0,maxPacketLifeTime:3e3},n=o[e].createDataChannel(e,t);return n.binaryType="arraybuffer",n.addEventListener("message",i=>{console.log("***********RTC***",{msg:i});let h=JSON.parse(i.data);return h&&h.hashCode&&(T=h.hashCode),h&&h.newHash&&(T=h.newHash),P(i,"rtc")}),n.addEventListener("error",i=>{console.log("xxxxxx-  Data Channel Error:",i)}),n.addEventListener("open",()=>{console.log("@@@@@@@@RTC IS OPEN&&&&&&&&"),n.target=e,N.push(n),o[e].sendChannel=n,p=p={send:i=>{let h=i.target,k=JSON.stringify(E(v({},i),{name:i.name||f}));N.map(L=>{try{if(L.readyState!=="open")return;L.target===h&&L.send(k)}catch($){console.error("Error in broadcasting event",{e:$})}})}}}),n.addEventListener("close",()=>{console.log("xxxxxxxx- The Data Channel is Closed")}),o[e];function d(i){console.log("Receive Channel Callback");let h=i.channel;h.binaryType="arraybuffer",h.addEventListener("close",g),h.addEventListener("message",k=>P(k,"rtc")),N.push(h)}function g(){console.log("Receive channel is closed"),o[e].close(),o[e]=null,console.log("Closed remote peer connection")}async function C(){c("*** Negotiation needed");try{c("---> Creating offer");let i=await o[e].createOffer();if(o[e].signalingState!="stable"){c("     -- The connection isn't stable yet; postponing...");return}c("---> Setting local description to the offer"),await o[e].setLocalDescription(i),c("---> Sending the offer to the remote peer"),l.send(JSON.stringify({target:e,name:f,type:"offer",sdp:o[e].localDescription}))}catch(i){c("*** The following error occurred while handling the negotiationneeded event:")}}function a(i){c("*** Track event"),document.querySelector("#received_video").srcObject=i.streams[0],document.querySelector("#hangup-button").disabled=!1}function s(i){i.candidate&&(c("*** Outgoing ICE candidate: "+i.candidate),l.send(JSON.stringify({type:"new-ice-candidate",target:e,name:f,candidate:i.candidate})))}function w(){switch(c("*** ICE connection state changed to "+o[e].iceConnectionState),o[e].iceConnectionState){case"closed":case"failed":case"disconnected":break}}function S(){switch(c("*** connections[target].signalingState  changed to: "+o[e].signalingState),o[e].signalingState){case"closed":break}}function D(){c("*** connections[target].iceGatheringState changed to: "+o[e].iceGatheringState)}}async function K(e,t){c("*** Adding received ICE candidate: "+JSON.stringify(e.candidate));let n=new RTCIceCandidate(e.candidate);console.log(o[t]),await o[t].addIceCandidate(n)}async function Q(e,t){c("*** Call recipient has accepted our call");let n=new RTCSessionDescription(e.sdp);await o[t].setRemoteDescription(n).catch(console.error)}async function U(e,t){if(o[t]||await M(t),!e.sdp)return;let n=new RTCSessionDescription(e.sdp);if(o[t].signalingState!="stable"){c("  - But the signaling state isn't stable, so triggering rollback"),await Promise.all([o[t].setLocalDescription({type:"rollback"}),o[t].setRemoteDescription(n)]);return}c("  - Setting remote description"),await o[t].setRemoteDescription(n),c("---> Creating and sending answer to caller"),await o[t].setLocalDescription(await o[t].createAnswer());let d=l||await y();d!==null&&d.send(JSON.stringify({target:t,name:f,type:"answer",sdp:o[t].localDescription}))}async function P(e,t){console.log(t,{event:e}),b=Date.now();let n=JSON.parse(e.data);if(n.name&&n.name!==f&&!o[n.name])try{await M(n.name)}catch(d){console.log({e:d}),z("Error with p2p")}if(console.log(t,n.name),n.type==="new-ice-candidate"){await K(n,n.name);return}if(n.type==="offer"){await U(n,n.name);return}if(n.type==="answer"){await Q(n,n.name);return}if(t==="ws"&&n.hashCode&&(I=n.hashCode),n.patch&&t==="ws"||n.name!==f){if(n.newHash===r.hashCode())return;if(n.oldHash===r.hashCode()){r.applyPatch(n),_(r.session.get("state").code,r.session.get("state").i),p&&p.send({hashCode:n.newHash});return}if(n.newHash===r.hashCode())return;if(n.code&&n.transpiled){let d=r.createPatch(n);r.applyPatch(d),_(n.code,n.i),p&&p.send({hashCode:d.newHash});return}return}n.timestamp&&(b=Date.now(),R=n.timestamp),n.name!==f&&(R=n.timestamp)}export{V as join,X as saveCode};

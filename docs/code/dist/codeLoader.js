function e3() {
    return (e3 = Object.assign || function(e1) {
        for(var t = 1; t < arguments.length; t++){
            var o = arguments[t];
            for(var n in o)Object.prototype.hasOwnProperty.call(o, n) && (e1[n] = o[n]);
        }
        return e1;
    }).apply(this, arguments);
}
const t6 = (e1, t1 = [])=>{
    if ("https://" === e1.slice(0, 8)) return window.document.head.querySelector(`script[src="${e1}"]`) || new Promise(function(o, n) {
        const s = window.document.createElement("script");
        s.src = e1, s.type = "application/javascript", s.onload = ()=>{
            0 === t1.length && o(window);
            const e2 = {
            };
            t1.forEach((t2)=>Object.assign(e2, window[t2])
            ), o(e2);
        }, s.onerror = n, window.document.head.appendChild(s);
    });
}, o1 = ()=>"undefined" != typeof window && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent)
;
let n3 = {
};
const __default = async ({ onChange: s , code: i , language: a , options: d  })=>{
    const { document: c  } = window;
    let p = c.getElementById("container");
    p || (p = c.createElement("container"), p.id = "container", c.body.appendChild(p));
    const r = "typescript" === a ? "file:///main.tsx" : "file:///main.html";
    if (o1()) {
        const e1 = window.document.createElement("div");
        e1.id = "ace", window.document.body.appendChild(e1), await t6("https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js"), "typescript" === a ? await t6("https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/mode-typescript.min.js") : await t6("https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/mode-html.min.js"), await t6("https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/theme-monokai.min.js"), window.document.getElementById("ace").style.setProperty("display", "block"), p.style.setProperty("display", "none"), n3 = window.ace.edit("ace"), n3.getSession().setMode("ace/mode/typescript");
        const o1 = (e2)=>setTimeout(()=>{
                const t1 = (void 0).edit("ace");
                "ace/theme/monokai " !== t1.getTheme() && (t1.setOptions({
                    fontSize: "14pt"
                }), t1.setTheme("ace/theme/monokai"), o1(2 * e2));
            }, e2)
        ;
        o1(100), n3 && n3.setValue(i), n3 && n3.blur();
    }
    const l = await (async ()=>{
        const { require: e1  } = await t6("https://unpkg.com/monaco-editor@0.21.2/min/vs/loader.js");
        return e1.config({
            paths: {
                vs: "https://unpkg.com/monaco-editor@0.21.2/min/vs"
            }
        }), await new Promise((t1)=>e1([
                "vs/editor/editor.main"
            ], (e2)=>t1(e2)
            )
        );
    })();
    let m;
    try {
        m = l.editor.getModel(r), m.getValue() !== i && m.setValue(i);
    } catch (e) {
        m = await l.editor.createModel(i, a, l.Uri.parse(r));
    }
    const u = {
        monaco: l,
        editor: l.editor.create(window.document.getElementById("container"), e3({
            formatOnType: !1,
            scrollbar: {
                horizontal: "hidden",
                verticalHasArrows: !0,
                verticalScrollbarSize: 20
            },
            minimap: {
                enabled: !1
            },
            folding: !1,
            glyphMargin: !1,
            wordWrap: "off",
            mouseWheelZoom: !1,
            wordWrapColumn: 80,
            useTabStops: !1,
            dragAndDrop: !1,
            disableLayerHinting: !0,
            formatOnPaste: !1,
            disableMonospaceOptimizations: !0,
            showUnused: !0,
            automaticLayout: !0,
            scrollBeyondLastLine: !1,
            autoIndent: "full",
            accessibilitySupport: "off",
            autoClosingQuotes: "beforeWhitespace",
            padding: {
                bottom: 300
            },
            lineNumbers: "on",
            autoClosingBrackets: "beforeWhitespace",
            autoClosingOvertype: "auto",
            suggest: {
            },
            codeLens: !0,
            autoSurround: "languageDefined",
            trimAutoWhitespace: !1,
            codeActionsOnSaveTimeout: 100,
            model: m,
            value: i,
            language: a,
            theme: "vs-dark"
        }, d))
    };
    if (o1() && (u.editor.onDidChangeModelContent(()=>s(u.editor.getValue())
    ), n3 && n3.session.on("change", function() {
        const e1 = n3.getValue();
        u.editor.setValue(e1), s(e1);
    }), n3 && c.getElementById("container").replaceWith(c.getElementById("ace"))), u.monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
        noSuggestionDiagnostics: !0,
        noSemanticValidation: !0,
        noSyntaxValidation: !0
    }), "typescript" === a) {
        const e1 = [
            {
                name: "react",
                url: "https://unpkg.com/@types/react@17.0.0/index.d.ts",
                depend: [
                    "global",
                    "csstype",
                    "react-dom",
                    "prop-types"
                ]
            },
            {
                name: "global",
                url: "https://unpkg.com/@types/react@17.0.0/global.d.ts",
                depend: []
            },
            {
                name: "prop-types",
                url: "https://unpkg.com/@types/prop-types@15.7.3/index.d.ts",
                depend: []
            },
            {
                name: "react-dom",
                url: "https://unpkg.com/@types/react-dom@17.0.0/index.d.ts",
                depend: []
            },
            {
                name: "csstype",
                url: "https://unpkg.com/csstype@3.0.5/index.d.ts",
                depend: []
            },
            {
                name: "@emotion/styled/base.d.ts",
                url: "https://unpkg.com/@emotion/styled@11.0.0/types/base.d.ts",
                depend: [
                    "@emotion/react",
                    "@emotion/serialize",
                    "react"
                ]
            },
            {
                name: "@emotion/styled/index.d.ts",
                url: "https://unpkg.com/@emotion/styled@11.0.0/types/index.d.ts",
                depend: [
                    "@emotion/react",
                    "@emotion/serialize",
                    "react"
                ]
            },
            {
                name: "@emotion/cache/index.d.ts",
                url: "https://unpkg.com/@emotion/cache@11.0.0/types/index.d.ts",
                depend: [
                    "@emotion/utils"
                ]
            },
            {
                name: "@emotion/react/index.d.ts",
                url: "https://unpkg.com/@emotion/react@11.1.3/types/index.d.ts",
                depend: [
                    "@emotion/cache"
                ]
            },
            {
                name: "@emotion/react/jsx-namespace.d.ts",
                url: "https://unpkg.com/@emotion/react@11.1.3/types/jsx-namespace.d.ts",
                depend: [
                    "@emotion/utils",
                    "csstype"
                ]
            },
            {
                name: "@emotion/react/css-prop.d.ts",
                url: "https://unpkg.com/@emotion/react@11.1.3/types/css-prop.d.ts",
                depend: [
                    "@emotion/utils",
                    "csstype"
                ]
            },
            {
                name: "@emotion/react/helper.d.ts",
                url: "https://unpkg.com/@emotion/react@11.1.3/types/helper.d.ts",
                depend: [
                    "@emotion/utils",
                    "csstype"
                ]
            },
            {
                name: "@emotion/react/theming.d.ts",
                url: "https://unpkg.com/@emotion/react@11.1.3/types/theming.d.ts",
                depend: [
                    "@emotion/utils",
                    "csstype"
                ]
            },
            {
                name: "@emotion/serialize/index.d.ts",
                url: "https://unpkg.com/@emotion/serialize@1.0.0/types/index.d.ts",
                depend: [
                    "@emotion/utils",
                    "csstype"
                ]
            },
            {
                name: "@emotion/utils/index.d.ts",
                url: "https://unpkg.com/@emotion/utils@1.0.0/types/index.d.ts",
                depend: []
            },
            {
                name: "framer-motion",
                url: "https://unpkg.com/framer-motion@3.1.1/dist/framer-motion.d.ts",
                depend: []
            },
            {
                name: "popmotion",
                url: "https://unpkg.com/popmotion@9.0.2/lib/index.d.ts"
            },
            {
                name: "@zedvision/qrious/index.d.ts",
                url: "https://unpkg.com/@zedvision/qrious@8.5.7/dist/qrious.d.ts"
            }
        ].map(({ name: e2 , url: t1  })=>(async ()=>u.monaco.languages.typescript.typescriptDefaults.addExtraLib(await (await fetch(t1)).text(), e2.includes("@") ? `file:///node_modules/${e2}` : `file:///node_modules/@types/${e2}/index.d.ts`)
            )()
        );
        return u.monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
            target: u.monaco.languages.typescript.ScriptTarget.ESNext,
            allowNonTsExtensions: !0,
            allowUmdGlobalAccess: !0,
            strict: !0,
            allowJs: !0,
            noEmitOnError: !0,
            allowSyntheticDefaultImports: !0,
            moduleResolution: u.monaco.languages.typescript.ModuleResolutionKind.Nodejs,
            module: u.monaco.languages.typescript.ModuleKind.CommonJS,
            noEmit: !0,
            typeRoots: [
                "node_modules/@types"
            ],
            jsx: "react-jsx",
            esModuleInterop: !0
        }), await Promise.all(e1), u.monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
            noSuggestionDiagnostics: !1,
            noSemanticValidation: !1,
            noSyntaxValidation: !1
        }), u;
    }
};
(function(d, w) {
    typeof exports == "object" && typeof module != "undefined" ? w(exports) : typeof define == "function" && define.amd ? define([
        "exports"
    ], w) : (d = d || self, w(d.Diff = {
    }));
})(this, function(d) {
    "use strict";
    function w() {
    }
    w.prototype = {
        diff: function(n1, t1) {
            var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            }, f = r.callback;
            typeof r == "function" && (f = r, r = {
            }), this.options = r;
            var i = this;
            function l(c) {
                return f ? (setTimeout(function() {
                    f(void 0, c);
                }, 0), !0) : c;
            }
            n1 = this.castInput(n1), t1 = this.castInput(t1), n1 = this.removeEmpty(this.tokenize(n1)), t1 = this.removeEmpty(this.tokenize(t1));
            var s = t1.length, o1 = n1.length, u = 1, p = s + o1, v = [
                {
                    newPos: -1,
                    components: []
                }
            ], a = this.extractCommon(v[0], t1, n1, 0);
            if (v[0].newPos + 1 >= s && a + 1 >= o1) return l([
                {
                    value: this.join(t1),
                    count: t1.length
                }
            ]);
            function h() {
                for(var c = -1 * u; c <= u; c += 2){
                    var L = void 0, x = v[c - 1], m = v[c + 1], F = (m ? m.newPos : 0) - c;
                    x && (v[c - 1] = void 0);
                    var y = x && x.newPos + 1 < s, E = m && 0 <= F && F < o1;
                    if (!y && !E) {
                        v[c] = void 0;
                        continue;
                    }
                    if (!y || E && x.newPos < m.newPos ? (L = I(m), i.pushComponent(L.components, void 0, !0)) : (L = x, L.newPos++, i.pushComponent(L.components, !0, void 0)), F = i.extractCommon(L, t1, n1, c), L.newPos + 1 >= s && F + 1 >= o1) return l(H(i, L.components, t1, n1, i.useLongestToken));
                    v[c] = L;
                }
                u++;
            }
            if (f) (function c() {
                setTimeout(function() {
                    if (u > p) return f();
                    h() || c();
                }, 0);
            })();
            else for(; u <= p;){
                var g = h();
                if (g) return g;
            }
        },
        pushComponent: function(n1, t1, r) {
            var f = n1[n1.length - 1];
            f && f.added === t1 && f.removed === r ? n1[n1.length - 1] = {
                count: f.count + 1,
                added: t1,
                removed: r
            } : n1.push({
                count: 1,
                added: t1,
                removed: r
            });
        },
        extractCommon: function(n1, t1, r, f) {
            for(var i = t1.length, l = r.length, s = n1.newPos, o1 = s - f, u = 0; s + 1 < i && o1 + 1 < l && this.equals(t1[s + 1], r[o1 + 1]);)s++, o1++, u++;
            return u && n1.components.push({
                count: u
            }), n1.newPos = s, o1;
        },
        equals: function(n1, t1) {
            return this.options.comparator ? this.options.comparator(n1, t1) : n1 === t1 || this.options.ignoreCase && n1.toLowerCase() === t1.toLowerCase();
        },
        removeEmpty: function(n1) {
            for(var t1 = [], r = 0; r < n1.length; r++)n1[r] && t1.push(n1[r]);
            return t1;
        },
        castInput: function(n1) {
            return n1;
        },
        tokenize: function(n1) {
            return n1.split("");
        },
        join: function(n1) {
            return n1.join("");
        }
    };
    function H(e1, n1, t1, r, f) {
        for(var i = 0, l = n1.length, s = 0, o1 = 0; i < l; i++){
            var u = n1[i];
            if (u.removed) {
                if ((u.value = e1.join(r.slice(o1, o1 + u.count)), o1 += u.count, i && n1[i - 1].added)) {
                    var v = n1[i - 1];
                    n1[i - 1] = n1[i], n1[i] = v;
                }
            } else {
                if (!u.added && f) {
                    var p = t1.slice(s, s + u.count);
                    p = p.map(function(h, g) {
                        var c = r[o1 + g];
                        return c.length > h.length ? c : h;
                    }), u.value = e1.join(p);
                } else u.value = e1.join(t1.slice(s, s + u.count));
                s += u.count, u.added || (o1 += u.count);
            }
        }
        var a = n1[l - 1];
        return (l > 1 && typeof a.value == "string" && (a.added || a.removed) && e1.equals("", a.value) && (n1[l - 2].value += a.value, n1.pop()), n1);
    }
    function I(e1) {
        return {
            newPos: e1.newPos,
            components: e1.components.slice(0)
        };
    }
    var S = new w;
    function W(e1, n1, t1) {
        return S.diff(e1, n1, t1);
    }
    function $(e1, n1) {
        if (typeof e1 == "function") n1.callback = e1;
        else if (e1) for(var t1 in e1)e1.hasOwnProperty(t1) && (n1[t1] = e1[t1]);
        return n1;
    }
    var P = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, fe = /\S/, U = new w;
    U.equals = function(e1, n1) {
        return this.options.ignoreCase && (e1 = e1.toLowerCase(), n1 = n1.toLowerCase()), e1 === n1 || this.options.ignoreWhitespace && !fe.test(e1) && !fe.test(n1);
    }, U.tokenize = function(e1) {
        for(var n1 = e1.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), t1 = 0; t1 < n1.length - 1; t1++)!n1[t1 + 1] && n1[t1 + 2] && P.test(n1[t1]) && P.test(n1[t1 + 2]) && (n1[t1] += n1[t1 + 2], n1.splice(t1 + 1, 2), t1--);
        return n1;
    };
    function me(e1, n1, t1) {
        return (t1 = $(t1, {
            ignoreWhitespace: !0
        }), U.diff(e1, n1, t1));
    }
    function xe(e1, n1, t1) {
        return U.diff(e1, n1, t1);
    }
    var V = new w;
    V.tokenize = function(e1) {
        var n1 = [], t1 = e1.split(/(\n|\r\n)/);
        t1[t1.length - 1] || t1.pop();
        for(var r = 0; r < t1.length; r++){
            var f = t1[r];
            r % 2 && !this.options.newlineIsToken ? n1[n1.length - 1] += f : (this.options.ignoreWhitespace && (f = f.trim()), n1.push(f));
        }
        return n1;
    };
    function le(e1, n1, t1) {
        return V.diff(e1, n1, t1);
    }
    function Fe(e1, n1, t1) {
        var r = $(t1, {
            ignoreWhitespace: !0
        });
        return V.diff(e1, n1, r);
    }
    var se = new w;
    se.tokenize = function(e1) {
        return e1.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function Ne(e1, n1, t1) {
        return se.diff(e1, n1, t1);
    }
    var oe = new w;
    oe.tokenize = function(e1) {
        return e1.split(/([{}:;,]|\s+)/);
    };
    function Se(e1, n1, t1) {
        return oe.diff(e1, n1, t1);
    }
    function X(e1) {
        return (typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? X = function(n1) {
            return typeof n1;
        } : X = function(n1) {
            return n1 && typeof Symbol == "function" && n1.constructor === Symbol && n1 !== Symbol.prototype ? "symbol" : typeof n1;
        }, X(e1));
    }
    function b(e1) {
        return He(e1) || Ie(e1) || be(e1) || Ee();
    }
    function He(e1) {
        if (Array.isArray(e1)) return j(e1);
    }
    function Ie(e1) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e1)) return Array.from(e1);
    }
    function be(e1, n1) {
        if (!e1) return;
        if (typeof e1 == "string") return j(e1, n1);
        var t1 = Object.prototype.toString.call(e1).slice(8, -1);
        if ((t1 === "Object" && e1.constructor && (t1 = e1.constructor.name), t1 === "Map" || t1 === "Set")) return Array.from(e1);
        if (t1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t1)) return j(e1, n1);
    }
    function j(e1, n1) {
        (n1 == null || n1 > e1.length) && (n1 = e1.length);
        for(var t1 = 0, r = new Array(n1); t1 < n1; t1++)r[t1] = e1[t1];
        return r;
    }
    function Ee() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Ae = Object.prototype.toString, J = new w;
    J.useLongestToken = !0, J.tokenize = V.tokenize, J.castInput = function(e1) {
        var n1 = this.options, t1 = n1.undefinedReplacement, r = n1.stringifyReplacer, f = r === void 0 ? function(i, l) {
            return typeof l == "undefined" ? t1 : l;
        } : r;
        return typeof e1 == "string" ? e1 : JSON.stringify(Z(e1, null, null, f), f, "  ");
    }, J.equals = function(e1, n1) {
        return w.prototype.equals.call(J, e1.replace(/,([\r\n])/g, "$1"), n1.replace(/,([\r\n])/g, "$1"));
    };
    function Te(e1, n1, t1) {
        return J.diff(e1, n1, t1);
    }
    function Z(e1, n1, t1, r, f) {
        n1 = n1 || [], t1 = t1 || [], r && (e1 = r(f, e1));
        var i;
        for(i = 0; i < n1.length; i += 1)if (n1[i] === e1) return t1[i];
        var l;
        if (Ae.call(e1) === "[object Array]") {
            for((n1.push(e1), l = new Array(e1.length), t1.push(l), i = 0); i < e1.length; i += 1)l[i] = Z(e1[i], n1, t1, r, f);
            return (n1.pop(), t1.pop(), l);
        }
        if ((e1 && e1.toJSON && (e1 = e1.toJSON()), X(e1) === "object" && e1 !== null)) {
            n1.push(e1), l = {
            }, t1.push(l);
            var s = [], o1;
            for(o1 in e1)e1.hasOwnProperty(o1) && s.push(o1);
            for((s.sort(), i = 0); i < s.length; i += 1)o1 = s[i], l[o1] = Z(e1[o1], n1, t1, r, o1);
            n1.pop(), t1.pop();
        } else l = e1;
        return l;
    }
    var B = new w;
    B.tokenize = function(e1) {
        return e1.slice();
    }, B.join = B.removeEmpty = function(e1) {
        return e1;
    };
    function Oe(e1, n1, t1) {
        return B.diff(e1, n1, t1);
    }
    function G(e1) {
        var n1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        }, t1 = e1.split(/\r\n|[\n\v\f\r\x85]/), r = e1.match(/\r\n|[\n\v\f\r\x85]/g) || [], f = [], i = 0;
        function l() {
            var u = {
            };
            for(f.push(u); i < t1.length;){
                var p = t1[i];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(p)) break;
                var v = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(p);
                v && (u.index = v[1]), i++;
            }
            for((s(u), s(u), u.hunks = []); i < t1.length;){
                var a = t1[i];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(a)) break;
                if (/^@@/.test(a)) u.hunks.push(o2());
                else {
                    if (a && n1.strict) throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(a));
                    i++;
                }
            }
        }
        function s(u) {
            var p = /^(---|\+\+\+)\s+(.*)$/.exec(t1[i]);
            if (p) {
                var v = p[1] === "---" ? "old" : "new", a = p[2].split("	", 2), h = a[0].replace(/\\\\/g, "\\");
                /^".*"$/.test(h) && (h = h.substr(1, h.length - 2)), u[v + "FileName"] = h, u[v + "Header"] = (a[1] || "").trim(), i++;
            }
        }
        function o2() {
            var u = i, p = t1[i++], v = p.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), a = {
                oldStart: +v[1],
                oldLines: typeof v[2] == "undefined" ? 1 : +v[2],
                newStart: +v[3],
                newLines: typeof v[4] == "undefined" ? 1 : +v[4],
                lines: [],
                linedelimiters: []
            };
            a.oldLines === 0 && (a.oldStart += 1), a.newLines === 0 && (a.newStart += 1);
            for(var h = 0, g = 0; i < t1.length && !(t1[i].indexOf("--- ") === 0 && i + 2 < t1.length && t1[i + 1].indexOf("+++ ") === 0 && t1[i + 2].indexOf("@@") === 0); i++){
                var c = t1[i].length == 0 && i != t1.length - 1 ? " " : t1[i][0];
                if (c === "+" || c === "-" || c === " " || c === "\\") a.lines.push(t1[i]), a.linedelimiters.push(r[i] || `\n`), c === "+" ? h++ : c === "-" ? g++ : c === " " && (h++, g++);
                else break;
            }
            if ((!h && a.newLines === 1 && (a.newLines = 0), !g && a.oldLines === 1 && (a.oldLines = 0), n1.strict)) {
                if (h !== a.newLines) throw new Error("Added line count did not match for hunk at line " + (u + 1));
                if (g !== a.oldLines) throw new Error("Removed line count did not match for hunk at line " + (u + 1));
            }
            return a;
        }
        for(; i < t1.length;)l();
        return f;
    }
    function ze(e1, n1, t1) {
        var r = !0, f = !1, i = !1, l = 1;
        return function s() {
            if (r && !i) {
                if ((f ? l++ : r = !1, e1 + l <= t1)) return l;
                i = !0;
            }
            if (!f) return (i || (r = !0), n1 <= e1 - l ? -l++ : (f = !0, s()));
        };
    }
    function ue(e1, n1) {
        var t1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        };
        if ((typeof n1 == "string" && (n1 = G(n1)), Array.isArray(n1))) {
            if (n1.length > 1) throw new Error("applyPatch only works with a single input.");
            n1 = n1[0];
        }
        var r = e1.split(/\r\n|[\n\v\f\r\x85]/), f = e1.match(/\r\n|[\n\v\f\r\x85]/g) || [], i = n1.hunks, l = t1.compareLine || function(re, D, K, C) {
            return D === C;
        }, s = 0, o2 = t1.fuzzFactor || 0, u = 0, p = 0, v, a;
        function h(re, D) {
            for(var K = 0; K < re.lines.length; K++){
                var C = re.lines[K], ie = C.length > 0 ? C[0] : " ", Ze = C.length > 0 ? C.substr(1) : C;
                if (ie === " " || ie === "-") {
                    if (!l(D + 1, r[D], ie, Ze) && (s++, s > o2)) return !1;
                    D++;
                }
            }
            return !0;
        }
        for(var g = 0; g < i.length; g++){
            for(var c = i[g], L = r.length - c.oldLines, x = 0, m = p + c.oldStart - 1, F = ze(m, u, L); x !== void 0; x = F())if (h(c, m + x)) {
                c.offset = p += x;
                break;
            }
            if (x === void 0) return !1;
            u = c.offset + c.oldStart + c.oldLines;
        }
        for(var y = 0, E = 0; E < i.length; E++){
            var N = i[E], A = N.oldStart + N.offset + y - 1;
            y += N.newLines - N.oldLines;
            for(var T = 0; T < N.lines.length; T++){
                var O = N.lines[T], z = O.length > 0 ? O[0] : " ", Y = O.length > 0 ? O.substr(1) : O, te = N.linedelimiters[T];
                if (z === " ") A++;
                else if (z === "-") r.splice(A, 1), f.splice(A, 1);
                else if (z === "+") r.splice(A, 0, Y), f.splice(A, 0, te), A++;
                else if (z === "\\") {
                    var R = N.lines[T - 1] ? N.lines[T - 1][0] : null;
                    R === "+" ? v = !0 : R === "-" && (a = !0);
                }
            }
        }
        if (v) for(; !r[r.length - 1];)r.pop(), f.pop();
        else a && (r.push(""), f.push(`\n`));
        for(var q = 0; q < r.length - 1; q++)r[q] = r[q] + f[q];
        return r.join("");
    }
    function We(e1, n1) {
        typeof e1 == "string" && (e1 = G(e1));
        var t1 = 0;
        function r() {
            var f = e1[t1++];
            if (!f) return n1.complete();
            n1.loadFile(f, function(i, l) {
                if (i) return n1.complete(i);
                var s = ue(l, f, n1);
                n1.patched(f, s, function(o2) {
                    if (o2) return n1.complete(o2);
                    r();
                });
            });
        }
        r();
    }
    function _(e1, n1, t1, r, f, i, l) {
        l || (l = {
        }), typeof l.context == "undefined" && (l.context = 4);
        var s = le(t1, r, l);
        s.push({
            value: "",
            lines: []
        });
        function o2(x) {
            return x.map(function(m) {
                return " " + m;
            });
        }
        for(var u = [], p = 0, v = 0, a = [], h = 1, g = 1, c = function(m) {
            var F = s[m], y = F.lines || F.value.replace(/\n$/, "").split(`\n`);
            if ((F.lines = y, F.added || F.removed)) {
                var E;
                if (!p) {
                    var N = s[m - 1];
                    p = h, v = g, N && (a = l.context > 0 ? o2(N.lines.slice(-l.context)) : [], p -= a.length, v -= a.length);
                }
                (E = a).push.apply(E, b(y.map(function(q) {
                    return (F.added ? "+" : "-") + q;
                }))), F.added ? g += y.length : h += y.length;
            } else {
                if (p) {
                    if (y.length <= l.context * 2 && m < s.length - 2) {
                        var A;
                        (A = a).push.apply(A, b(o2(y)));
                    } else {
                        var T, O = Math.min(y.length, l.context);
                        (T = a).push.apply(T, b(o2(y.slice(0, O))));
                        var z = {
                            oldStart: p,
                            oldLines: h - p + O,
                            newStart: v,
                            newLines: g - v + O,
                            lines: a
                        };
                        if (m >= s.length - 2 && y.length <= l.context) {
                            var Y = /\n$/.test(t1), te = /\n$/.test(r), R = y.length == 0 && a.length > z.oldLines;
                            !Y && R && t1.length > 0 && a.splice(z.oldLines, 0, "\\ No newline at end of file"), (!Y && !R || !te) && a.push("\\ No newline at end of file");
                        }
                        u.push(z), p = 0, v = 0, a = [];
                    }
                }
                h += y.length, g += y.length;
            }
        }, L = 0; L < s.length; L++)c(L);
        return {
            oldFileName: e1,
            newFileName: n1,
            oldHeader: f,
            newHeader: i,
            hunks: u
        };
    }
    function Me(e1) {
        var n1 = [];
        e1.oldFileName == e1.newFileName && n1.push("Index: " + e1.oldFileName), n1.push("==================================================================="), n1.push("--- " + e1.oldFileName + (typeof e1.oldHeader == "undefined" ? "" : "	" + e1.oldHeader)), n1.push("+++ " + e1.newFileName + (typeof e1.newHeader == "undefined" ? "" : "	" + e1.newHeader));
        for(var t1 = 0; t1 < e1.hunks.length; t1++){
            var r = e1.hunks[t1];
            r.oldLines === 0 && (r.oldStart -= 1), r.newLines === 0 && (r.newStart -= 1), n1.push("@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," + r.newLines + " @@"), n1.push.apply(n1, r.lines);
        }
        return n1.join(`\n`) + `\n`;
    }
    function ae(e1, n1, t1, r, f, i, l) {
        return Me(_(e1, n1, t1, r, f, i, l));
    }
    function qe(e1, n1, t1, r, f, i) {
        return ae(e1, e1, n1, t1, r, f, i);
    }
    function Ce(e1, n1) {
        return e1.length !== n1.length ? !1 : k(e1, n1);
    }
    function k(e1, n1) {
        if (n1.length > e1.length) return !1;
        for(var t1 = 0; t1 < n1.length; t1++)if (n1[t1] !== e1[t1]) return !1;
        return !0;
    }
    function Je(e1) {
        var n1 = ne(e1.lines), t1 = n1.oldLines, r = n1.newLines;
        t1 !== void 0 ? e1.oldLines = t1 : delete e1.oldLines, r !== void 0 ? e1.newLines = r : delete e1.newLines;
    }
    function $e(e1, n1, t1) {
        e1 = de(e1, t1), n1 = de(n1, t1);
        var r = {
        };
        (e1.index || n1.index) && (r.index = e1.index || n1.index), (e1.newFileName || n1.newFileName) && (ce(e1) ? ce(n1) ? (r.oldFileName = Q(r, e1.oldFileName, n1.oldFileName), r.newFileName = Q(r, e1.newFileName, n1.newFileName), r.oldHeader = Q(r, e1.oldHeader, n1.oldHeader), r.newHeader = Q(r, e1.newHeader, n1.newHeader)) : (r.oldFileName = e1.oldFileName, r.newFileName = e1.newFileName, r.oldHeader = e1.oldHeader, r.newHeader = e1.newHeader) : (r.oldFileName = n1.oldFileName || e1.oldFileName, r.newFileName = n1.newFileName || e1.newFileName, r.oldHeader = n1.oldHeader || e1.oldHeader, r.newHeader = n1.newHeader || e1.newHeader)), r.hunks = [];
        for(var f = 0, i = 0, l = 0, s = 0; f < e1.hunks.length || i < n1.hunks.length;){
            var o2 = e1.hunks[f] || {
                oldStart: Infinity
            }, u = n1.hunks[i] || {
                oldStart: Infinity
            };
            if (pe(o2, u)) r.hunks.push(ve(o2, l)), f++, s += o2.newLines - o2.oldLines;
            else if (pe(u, o2)) r.hunks.push(ve(u, s)), i++, l += u.newLines - u.oldLines;
            else {
                var p = {
                    oldStart: Math.min(o2.oldStart, u.oldStart),
                    oldLines: 0,
                    newStart: Math.min(o2.newStart + l, u.oldStart + s),
                    newLines: 0,
                    lines: []
                };
                Re(p, o2.oldStart, o2.lines, u.oldStart, u.lines), i++, f++, r.hunks.push(p);
            }
        }
        return r;
    }
    function de(e1, n1) {
        if (typeof e1 == "string") {
            if (/^@@/m.test(e1) || /^Index:/m.test(e1)) return G(e1)[0];
            if (!n1) throw new Error("Must provide a base reference or pass in a patch");
            return _(void 0, void 0, n1, e1);
        }
        return e1;
    }
    function ce(e1) {
        return e1.newFileName && e1.newFileName !== e1.oldFileName;
    }
    function Q(e1, n1, t1) {
        return n1 === t1 ? n1 : (e1.conflict = !0, {
            mine: n1,
            theirs: t1
        });
    }
    function pe(e1, n1) {
        return e1.oldStart < n1.oldStart && e1.oldStart + e1.oldLines < n1.oldStart;
    }
    function ve(e1, n1) {
        return {
            oldStart: e1.oldStart,
            oldLines: e1.oldLines,
            newStart: e1.newStart + n1,
            newLines: e1.newLines,
            lines: e1.lines
        };
    }
    function Re(e1, n1, t1, r, f) {
        var i = {
            offset: n1,
            lines: t1,
            index: 0
        }, l = {
            offset: r,
            lines: f,
            index: 0
        };
        for((we(e1, i, l), we(e1, l, i)); i.index < i.lines.length && l.index < l.lines.length;){
            var s = i.lines[i.index], o2 = l.lines[l.index];
            if ((s[0] === "-" || s[0] === "+") && (o2[0] === "-" || o2[0] === "+")) De(e1, i, l);
            else if (s[0] === "+" && o2[0] === " ") {
                var u;
                (u = e1.lines).push.apply(u, b(M(i)));
            } else if (o2[0] === "+" && s[0] === " ") {
                var p;
                (p = e1.lines).push.apply(p, b(M(l)));
            } else s[0] === "-" && o2[0] === " " ? he(e1, i, l) : o2[0] === "-" && s[0] === " " ? he(e1, l, i, !0) : s === o2 ? (e1.lines.push(s), i.index++, l.index++) : ee(e1, M(i), M(l));
        }
        ge(e1, i), ge(e1, l), Je(e1);
    }
    function De(e1, n1, t1) {
        var r = M(n1), f = M(t1);
        if (ye(r) && ye(f)) {
            if (k(r, f) && Le(t1, r, r.length - f.length)) {
                var i;
                (i = e1.lines).push.apply(i, b(r));
                return;
            } else if (k(f, r) && Le(n1, f, f.length - r.length)) {
                var l;
                (l = e1.lines).push.apply(l, b(f));
                return;
            }
        } else if (Ce(r, f)) {
            var s;
            (s = e1.lines).push.apply(s, b(r));
            return;
        }
        ee(e1, r, f);
    }
    function he(e1, n1, t1, r) {
        var f = M(n1), i = Pe(t1, f);
        if (i.merged) {
            var l;
            (l = e1.lines).push.apply(l, b(i.merged));
        } else ee(e1, r ? i : f, r ? f : i);
    }
    function ee(e1, n1, t1) {
        e1.conflict = !0, e1.lines.push({
            conflict: !0,
            mine: n1,
            theirs: t1
        });
    }
    function we(e1, n1, t1) {
        for(; n1.offset < t1.offset && n1.index < n1.lines.length;){
            var r = n1.lines[n1.index++];
            e1.lines.push(r), n1.offset++;
        }
    }
    function ge(e1, n1) {
        for(; n1.index < n1.lines.length;){
            var t1 = n1.lines[n1.index++];
            e1.lines.push(t1);
        }
    }
    function M(e1) {
        for(var n1 = [], t1 = e1.lines[e1.index][0]; e1.index < e1.lines.length;){
            var r = e1.lines[e1.index];
            if ((t1 === "-" && r[0] === "+" && (t1 = "+"), t1 === r[0])) n1.push(r), e1.index++;
            else break;
        }
        return n1;
    }
    function Pe(e1, n1) {
        for(var t1 = [], r = [], f = 0, i = !1, l = !1; f < n1.length && e1.index < e1.lines.length;){
            var s = e1.lines[e1.index], o2 = n1[f];
            if (o2[0] === "+") break;
            if ((i = i || s[0] !== " ", r.push(o2), f++, s[0] === "+")) for(l = !0; s[0] === "+";)t1.push(s), s = e1.lines[++e1.index];
            o2.substr(1) === s.substr(1) ? (t1.push(s), e1.index++) : l = !0;
        }
        if (((n1[f] || "")[0] === "+" && i && (l = !0), l)) return t1;
        for(; f < n1.length;)r.push(n1[f++]);
        return {
            merged: r,
            changes: t1
        };
    }
    function ye(e1) {
        return e1.reduce(function(n1, t1) {
            return n1 && t1[0] === "-";
        }, !0);
    }
    function Le(e1, n1, t1) {
        for(var r = 0; r < t1; r++){
            var f = n1[n1.length - t1 + r].substr(1);
            if (e1.lines[e1.index + r] !== " " + f) return !1;
        }
        return (e1.index += t1, !0);
    }
    function ne(e1) {
        var n1 = 0, t1 = 0;
        return (e1.forEach(function(r) {
            if (typeof r != "string") {
                var f = ne(r.mine), i = ne(r.theirs);
                n1 !== void 0 && (f.oldLines === i.oldLines ? n1 += f.oldLines : n1 = void 0), t1 !== void 0 && (f.newLines === i.newLines ? t1 += f.newLines : t1 = void 0);
            } else t1 !== void 0 && (r[0] === "+" || r[0] === " ") && t1++, n1 !== void 0 && (r[0] === "-" || r[0] === " ") && n1++;
        }), {
            oldLines: n1,
            newLines: t1
        });
    }
    function Ue(e1) {
        for(var n1 = [], t1, r, f = 0; f < e1.length; f++)t1 = e1[f], t1.added ? r = 1 : t1.removed ? r = -1 : r = 0, n1.push([
            r,
            t1.value
        ]);
        return n1;
    }
    function Ve(e1) {
        for(var n1 = [], t1 = 0; t1 < e1.length; t1++){
            var r = e1[t1];
            r.added ? n1.push("<ins>") : r.removed && n1.push("<del>"), n1.push(Xe(r.value)), r.added ? n1.push("</ins>") : r.removed && n1.push("</del>");
        }
        return n1.join("");
    }
    function Xe(e1) {
        var n1 = e1;
        return (n1 = n1.replace(/&/g, "&amp;"), n1 = n1.replace(/</g, "&lt;"), n1 = n1.replace(/>/g, "&gt;"), n1 = n1.replace(/"/g, "&quot;"), n1);
    }
    d.Diff = w, d.applyPatch = ue, d.applyPatches = We, d.canonicalize = Z, d.convertChangesToDMP = Ue, d.convertChangesToXML = Ve, d.createPatch = qe, d.createTwoFilesPatch = ae, d.diffArrays = Oe, d.diffChars = W, d.diffCss = Se, d.diffJson = Te, d.diffLines = le, d.diffSentences = Ne, d.diffTrimmedLines = Fe, d.diffWords = me, d.diffWordsWithSpace = xe, d.merge = $e, d.parsePatch = G, d.structuredPatch = _, Object.defineProperty(d, "__esModule", {
        value: !0
    });
});
const Be = async (d)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof d == "string" ? new TextEncoder().encode(d) : d)).slice(0, 4)).map((w)=>("00" + w.toString(16)).slice(-2)
    ).join("")
;
const diff = async (d, w)=>{
    const H = Be(d), I = Diff.diffChars(d, w);
    return {
        b: await H,
        c: I.map((S)=>S.added ? S.value : S.removed ? -S.count : S.count
        )
    };
};
function e1(e2, t1) {
    if (null == e2) return {
    };
    var n1, r, o2 = {
    }, u = Object.keys(e2);
    for(r = 0; r < u.length; r++)n1 = u[r], t1.indexOf(n1) >= 0 || (o2[n1] = e2[n1]);
    return o2;
}
function t1(e2, t2) {
    return t2 || (t2 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, {
        raw: {
            value: Object.freeze(t2)
        }
    }));
}
var n1 = {
    name: "prettier",
    version: "2.2.1",
    description: "Prettier is an opinionated code formatter",
    bin: "./bin/prettier.js",
    repository: "prettier/prettier",
    homepage: "https://prettier.io",
    author: "James Long",
    license: "MIT",
    main: "./index.js",
    browser: "./standalone.js",
    unpkg: "./standalone.js",
    engines: {
        node: ">=10.13.0"
    },
    files: [
        "index.js",
        "standalone.js",
        "src",
        "bin"
    ],
    dependencies: {
        "@angular/compiler": "10.2.3",
        "@babel/code-frame": "7.10.4",
        "@babel/parser": "7.12.5",
        "@glimmer/syntax": "0.66.0",
        "@iarna/toml": "2.2.5",
        "@typescript-eslint/typescript-estree": "4.8.1",
        "angular-estree-parser": "2.2.1",
        "angular-html-parser": "1.7.1",
        camelcase: "6.2.0",
        chalk: "4.1.0",
        "ci-info": "watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540",
        "cjk-regex": "2.0.0",
        cosmiconfig: "7.0.0",
        dashify: "2.0.0",
        diff: "5.0.0",
        editorconfig: "0.15.3",
        "editorconfig-to-prettier": "0.2.0",
        "escape-string-regexp": "4.0.0",
        espree: "7.3.0",
        esutils: "2.0.3",
        "fast-glob": "3.2.4",
        "fast-json-stable-stringify": "2.1.0",
        "find-parent-dir": "0.3.0",
        "flow-parser": "0.138.0",
        "get-stdin": "8.0.0",
        globby: "11.0.1",
        graphql: "15.4.0",
        "html-element-attributes": "2.3.0",
        "html-styles": "1.0.0",
        "html-tag-names": "1.1.5",
        "html-void-elements": "1.0.5",
        ignore: "4.0.6",
        "jest-docblock": "26.0.0",
        json5: "2.1.3",
        leven: "3.1.0",
        "lines-and-columns": "1.1.6",
        "linguist-languages": "7.12.1",
        lodash: "4.17.20",
        mem: "8.0.0",
        meriyah: "3.1.6",
        minimatch: "3.0.4",
        minimist: "1.2.5",
        "n-readlines": "1.0.1",
        outdent: "0.7.1",
        "parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee",
        "please-upgrade-node": "3.2.0",
        "postcss-less": "3.1.4",
        "postcss-media-query-parser": "0.2.3",
        "postcss-scss": "2.1.1",
        "postcss-selector-parser": "2.2.3",
        "postcss-values-parser": "2.0.1",
        "regexp-util": "1.2.2",
        "remark-footnotes": "2.0.0",
        "remark-math": "3.0.1",
        "remark-parse": "8.0.3",
        resolve: "1.19.0",
        semver: "7.3.2",
        "string-width": "4.2.0",
        typescript: "4.1.2",
        "unicode-regex": "3.0.0",
        unified: "9.2.0",
        vnopts: "1.0.2",
        "yaml-unist-parser": "1.3.1"
    },
    devDependencies: {
        "@babel/core": "7.12.3",
        "@babel/preset-env": "7.12.1",
        "@babel/types": "7.12.6",
        "@glimmer/reference": "0.66.0",
        "@rollup/plugin-alias": "3.1.1",
        "@rollup/plugin-babel": "5.2.1",
        "@rollup/plugin-commonjs": "16.0.0",
        "@rollup/plugin-json": "4.1.0",
        "@rollup/plugin-node-resolve": "10.0.0",
        "@rollup/plugin-replace": "2.3.4",
        "@types/estree": "0.0.45",
        "@types/node": "14.14.0",
        "@typescript-eslint/types": "4.8.1",
        "babel-jest": "26.6.3",
        "babel-loader": "8.2.1",
        benchmark: "2.1.4",
        "builtin-modules": "3.1.0",
        "cross-env": "7.0.2",
        cspell: "4.2.2",
        eslint: "7.13.0",
        "eslint-config-prettier": "6.15.0",
        "eslint-formatter-friendly": "7.0.0",
        "eslint-plugin-import": "2.22.1",
        "eslint-plugin-jest": "24.1.3",
        "eslint-plugin-prettier-internal-rules": "file:scripts/tools/eslint-plugin-prettier-internal-rules",
        "eslint-plugin-react": "7.21.5",
        "eslint-plugin-unicorn": "23.0.0",
        execa: "4.1.0",
        jest: "26.6.3",
        "jest-snapshot-serializer-ansi": "1.0.0",
        "jest-snapshot-serializer-raw": "1.1.0",
        "jest-watch-typeahead": "0.6.1",
        "npm-run-all": "4.1.5",
        "path-browserify": "1.0.1",
        prettier: "2.2.0",
        rimraf: "3.0.2",
        rollup: "2.33.3",
        "rollup-plugin-node-globals": "1.4.0",
        "rollup-plugin-terser": "7.0.2",
        shelljs: "0.8.4",
        "snapshot-diff": "0.8.1",
        "strip-ansi": "6.0.0",
        "synchronous-promise": "2.0.15",
        tempy: "1.0.0",
        "terser-webpack-plugin": "5.0.3",
        webpack: "5.5.1"
    },
    scripts: {
        prepublishOnly: 'echo "Error: must publish from dist/" && exit 1',
        "prepare-release": "yarn && yarn build && yarn test:dist",
        test: "jest",
        "test:dev-package": "cross-env INSTALL_PACKAGE=1 jest",
        "test:dist": "cross-env NODE_ENV=production jest",
        "test:dist-standalone": "cross-env NODE_ENV=production TEST_STANDALONE=1 jest",
        "test:integration": "jest tests_integration",
        "perf:repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        "perf:repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        "perf:benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        lint: "run-p lint:*",
        "lint:typecheck": "tsc",
        "lint:eslint": "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly",
        "lint:changelog": "node ./scripts/lint-changelog.js",
        "lint:prettier": 'prettier . "!test*" --check',
        "lint:dist": 'eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2018 "dist/!(bin-prettier|index|third-party).js"',
        "lint:spellcheck": 'cspell "**/*" ".github/**/*"',
        "lint:deps": "node ./scripts/check-deps.js",
        fix: "run-s fix:eslint fix:prettier",
        "fix:eslint": "yarn lint:eslint --fix",
        "fix:prettier": "yarn lint:prettier --write",
        build: "node --max-old-space-size=3072 ./scripts/build/build.js",
        "build-docs": "node ./scripts/build-docs.js"
    }
};
function r1() {
}
function o2(e2, t2, n2, r1, o3) {
    for(var u = 0, i = t2.length, a = 0, s = 0; u < i; u++){
        var l = t2[u];
        if (l.removed) {
            if (l.value = e2.join(r1.slice(s, s + l.count)), s += l.count, u && t2[u - 1].added) {
                var c = t2[u - 1];
                t2[u - 1] = t2[u], t2[u] = c;
            }
        } else {
            if (!l.added && o3) {
                var p = n2.slice(a, a + l.count);
                p = p.map(function(e3, t3) {
                    var n3 = r1[s + t3];
                    return n3.length > e3.length ? n3 : e3;
                }), l.value = e2.join(p);
            } else l.value = e2.join(n2.slice(a, a + l.count));
            a += l.count, l.added || (s += l.count);
        }
    }
    var d = t2[i - 1];
    return i > 1 && "string" == typeof d.value && (d.added || d.removed) && e2.equals("", d.value) && (t2[i - 2].value += d.value, t2.pop()), t2;
}
function u1(e2) {
    return {
        newPos: e2.newPos,
        components: e2.components.slice(0)
    };
}
r1.prototype = {
    diff: function(e2, t2) {
        var n2 = arguments.length > 2 && (void 0) !== arguments[2] ? arguments[2] : {
        }, r1 = n2.callback;
        "function" == typeof n2 && (r1 = n2, n2 = {
        }), this.options = n2;
        var i = this;
        function a(e3) {
            return r1 ? (setTimeout(function() {
                r1(void 0, e3);
            }, 0), !0) : e3;
        }
        e2 = this.castInput(e2), t2 = this.castInput(t2), e2 = this.removeEmpty(this.tokenize(e2));
        var s = (t2 = this.removeEmpty(this.tokenize(t2))).length, l = e2.length, c = 1, p = s + l, d = [
            {
                newPos: -1,
                components: []
            }
        ], f = this.extractCommon(d[0], t2, e2, 0);
        if (d[0].newPos + 1 >= s && f + 1 >= l) return a([
            {
                value: this.join(t2),
                count: t2.length
            }
        ]);
        function h() {
            for(var n3 = -1 * c; n3 <= c; n3 += 2){
                var r2 = void 0, p1 = d[n3 - 1], f1 = d[n3 + 1], h = (f1 ? f1.newPos : 0) - n3;
                p1 && (d[n3 - 1] = void 0);
                var m = p1 && p1.newPos + 1 < s, g = f1 && 0 <= h && h < l;
                if (m || g) {
                    if (!m || g && p1.newPos < f1.newPos ? (r2 = u1(f1), i.pushComponent(r2.components, void 0, !0)) : ((r2 = p1).newPos++, i.pushComponent(r2.components, !0, void 0)), h = i.extractCommon(r2, t2, e2, n3), r2.newPos + 1 >= s && h + 1 >= l) return a(o2(i, r2.components, t2, e2, i.useLongestToken));
                    d[n3] = r2;
                } else d[n3] = void 0;
            }
            c++;
        }
        if (r1) !(function e2() {
            setTimeout(function() {
                if (c > p) return r1();
                h() || e2();
            }, 0);
        })();
        else for(; c <= p;){
            var m = h();
            if (m) return m;
        }
    },
    pushComponent: function(e2, t2, n2) {
        var r1 = e2[e2.length - 1];
        r1 && r1.added === t2 && r1.removed === n2 ? e2[e2.length - 1] = {
            count: r1.count + 1,
            added: t2,
            removed: n2
        } : e2.push({
            count: 1,
            added: t2,
            removed: n2
        });
    },
    extractCommon: function(e2, t2, n2, r1) {
        for(var o3 = t2.length, u1 = n2.length, i = e2.newPos, a = i - r1, s = 0; i + 1 < o3 && a + 1 < u1 && this.equals(t2[i + 1], n2[a + 1]);)i++, a++, s++;
        return s && e2.components.push({
            count: s
        }), e2.newPos = i, a;
    },
    equals: function(e2, t2) {
        return this.options.comparator ? this.options.comparator(e2, t2) : e2 === t2 || this.options.ignoreCase && e2.toLowerCase() === t2.toLowerCase();
    },
    removeEmpty: function(e2) {
        for(var t2 = [], n2 = 0; n2 < e2.length; n2++)e2[n2] && t2.push(e2[n2]);
        return t2;
    },
    castInput: function(e2) {
        return e2;
    },
    tokenize: function(e2) {
        return e2.split("");
    },
    join: function(e2) {
        return e2.join("");
    }
};
var i1 = new r1;
function a1(e2, t2) {
    if ("function" == typeof e2) t2.callback = e2;
    else if (e2) for(var n2 in e2)e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
    return t2;
}
var s1 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, l1 = /\S/, c1 = new r1;
c1.equals = function(e2, t2) {
    return this.options.ignoreCase && (e2 = e2.toLowerCase(), t2 = t2.toLowerCase()), e2 === t2 || this.options.ignoreWhitespace && !l1.test(e2) && !l1.test(t2);
}, c1.tokenize = function(e2) {
    for(var t2 = e2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n2 = 0; n2 < t2.length - 1; n2++)!t2[n2 + 1] && t2[n2 + 2] && s1.test(t2[n2]) && s1.test(t2[n2 + 2]) && (t2[n2] += t2[n2 + 2], t2.splice(n2 + 1, 2), n2--);
    return t2;
};
var p1 = new r1;
function d1(e2, t2, n2) {
    return p1.diff(e2, t2, n2);
}
p1.tokenize = function(e2) {
    var t2 = [], n2 = e2.split(/(\n|\r\n)/);
    n2[n2.length - 1] || n2.pop();
    for(var r1 = 0; r1 < n2.length; r1++){
        var o3 = n2[r1];
        r1 % 2 && !this.options.newlineIsToken ? t2[t2.length - 1] += o3 : (this.options.ignoreWhitespace && (o3 = o3.trim()), t2.push(o3));
    }
    return t2;
};
var f2 = new r1;
f2.tokenize = function(e2) {
    return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var h3 = new r1;
function m2(e2) {
    return (m2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
        return typeof e3;
    } : function(e3) {
        return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
    })(e2);
}
function D3(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for(var n2 = 0, r1 = new Array(t2); n2 < t2; n2++)r1[n2] = e2[n2];
    return r1;
}
h3.tokenize = function(e2) {
    return e2.split(/([{}:;,]|\s+)/);
};
var y2 = Object.prototype.toString, E2 = new r1;
function C1(e2, t2, n2, r1, o3) {
    var u1, i1;
    for(t2 = t2 || [], n2 = n2 || [], r1 && (e2 = r1(o3, e2)), u1 = 0; u1 < t2.length; u1 += 1)if (t2[u1] === e2) return n2[u1];
    if ("[object Array]" === y2.call(e2)) {
        for(t2.push(e2), i1 = new Array(e2.length), n2.push(i1), u1 = 0; u1 < e2.length; u1 += 1)i1[u1] = C1(e2[u1], t2, n2, r1, o3);
        return t2.pop(), n2.pop(), i1;
    }
    if (e2 && e2.toJSON && (e2 = e2.toJSON()), "object" === m2(e2) && null !== e2) {
        t2.push(e2), i1 = {
        }, n2.push(i1);
        var a1, s1 = [];
        for(a1 in e2)e2.hasOwnProperty(a1) && s1.push(a1);
        for(s1.sort(), u1 = 0; u1 < s1.length; u1 += 1)i1[a1 = s1[u1]] = C1(e2[a1], t2, n2, r1, a1);
        t2.pop(), n2.pop();
    } else i1 = e2;
    return i1;
}
E2.useLongestToken = !0, E2.tokenize = p1.tokenize, E2.castInput = function(e2) {
    var t2 = this.options, n2 = t2.undefinedReplacement, r1 = t2.stringifyReplacer, o3 = (void 0) === r1 ? function(e3, t3) {
        return (void 0) === t3 ? n2 : t3;
    } : r1;
    return "string" == typeof e2 ? e2 : JSON.stringify(C1(e2, null, null, o3), o3, "  ");
}, E2.equals = function(e2, t2) {
    return r1.prototype.equals.call(E2, e2.replace(/,([\r\n])/g, "$1"), t2.replace(/,([\r\n])/g, "$1"));
};
var b = new r1;
function v(e2) {
    var t2 = arguments.length > 1 && (void 0) !== arguments[1] ? arguments[1] : {
    }, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r1 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], o3 = [], u1 = 0;
    function i1() {
        var e3 = {
        };
        for(o3.push(e3); u1 < n2.length;){
            var r2 = n2[u1];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(r2)) break;
            var i1 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r2);
            i1 && (e3.index = i1[1]), u1++;
        }
        for(a2(e3), a2(e3), e3.hunks = []; u1 < n2.length;){
            var l1 = n2[u1];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(l1)) break;
            if (/^@@/.test(l1)) e3.hunks.push(s2());
            else {
                if (l1 && t2.strict) throw new Error("Unknown line " + (u1 + 1) + " " + JSON.stringify(l1));
                u1++;
            }
        }
    }
    function a2(e3) {
        var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u1]);
        if (t3) {
            var r2 = "---" === t3[1] ? "old" : "new", o4 = t3[2].split("\t", 2), i2 = o4[0].replace(/\\\\/g, "\\");
            /^".*"$/.test(i2) && (i2 = i2.substr(1, i2.length - 2)), e3[r2 + "FileName"] = i2, e3[r2 + "Header"] = (o4[1] || "").trim(), u1++;
        }
    }
    function s2() {
        var e3 = u1, o4 = n2[u1++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), i2 = {
            oldStart: +o4[1],
            oldLines: (void 0) === o4[2] ? 1 : +o4[2],
            newStart: +o4[3],
            newLines: (void 0) === o4[4] ? 1 : +o4[4],
            lines: [],
            linedelimiters: []
        };
        0 === i2.oldLines && (i2.oldStart += 1), 0 === i2.newLines && (i2.newStart += 1);
        for(var a3 = 0, s2 = 0; u1 < n2.length && !(0 === n2[u1].indexOf("--- ") && u1 + 2 < n2.length && 0 === n2[u1 + 1].indexOf("+++ ") && 0 === n2[u1 + 2].indexOf("@@")); u1++){
            var l1 = 0 == n2[u1].length && u1 != n2.length - 1 ? " " : n2[u1][0];
            if ("+" !== l1 && "-" !== l1 && " " !== l1 && "\\" !== l1) break;
            i2.lines.push(n2[u1]), i2.linedelimiters.push(r1[u1] || "\n"), "+" === l1 ? a3++ : "-" === l1 ? s2++ : " " === l1 && (a3++, s2++);
        }
        if (a3 || 1 !== i2.newLines || (i2.newLines = 0), s2 || 1 !== i2.oldLines || (i2.oldLines = 0), t2.strict) {
            if (a3 !== i2.newLines) throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
            if (s2 !== i2.oldLines) throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
        }
        return i2;
    }
    for(; u1 < n2.length;)i1();
    return o3;
}
function A(e2, t2, n2) {
    var r1 = !0, o3 = !1, u1 = !1, i1 = 1;
    return function a2() {
        if (r1 && !u1) {
            if (o3 ? i1++ : r1 = !1, e2 + i1 <= n2) return i1;
            u1 = !0;
        }
        if (!o3) return u1 || (r1 = !0), t2 <= e2 - i1 ? -i1++ : (o3 = !0, a2());
    };
}
function F(e2, t2) {
    var n2 = arguments.length > 2 && (void 0) !== arguments[2] ? arguments[2] : {
    };
    if ("string" == typeof t2 && (t2 = v(t2)), Array.isArray(t2)) {
        if (t2.length > 1) throw new Error("applyPatch only works with a single input.");
        t2 = t2[0];
    }
    var r1, o3, u1 = e2.split(/\r\n|[\n\v\f\r\x85]/), i1 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], a2 = t2.hunks, s2 = n2.compareLine || function(e3, t3, n3, r2) {
        return t3 === r2;
    }, l1 = 0, c1 = n2.fuzzFactor || 0, p1 = 0, d1 = 0;
    function f1(e3, t3) {
        for(var n3 = 0; n3 < e3.lines.length; n3++){
            var r2 = e3.lines[n3], o4 = r2.length > 0 ? r2[0] : " ", i2 = r2.length > 0 ? r2.substr(1) : r2;
            if (" " === o4 || "-" === o4) {
                if (!s2(t3 + 1, u1[t3], o4, i2) && (++l1) > c1) return !1;
                t3++;
            }
        }
        return !0;
    }
    for(var h1 = 0; h1 < a2.length; h1++){
        for(var m1 = a2[h1], g = u1.length - m1.oldLines, D1 = 0, y1 = d1 + m1.oldStart - 1, E1 = A(y1, p1, g); (void 0) !== D1; D1 = E1())if (f1(m1, y1 + D1)) {
            m1.offset = d1 += D1;
            break;
        }
        if ((void 0) === D1) return !1;
        p1 = m1.offset + m1.oldStart + m1.oldLines;
    }
    for(var C1 = 0, b1 = 0; b1 < a2.length; b1++){
        var F = a2[b1], x = F.oldStart + F.offset + C1 - 1;
        C1 += F.newLines - F.oldLines;
        for(var S = 0; S < F.lines.length; S++){
            var w = F.lines[S], T = w.length > 0 ? w[0] : " ", B = w.length > 0 ? w.substr(1) : w, N = F.linedelimiters[S];
            if (" " === T) x++;
            else if ("-" === T) u1.splice(x, 1), i1.splice(x, 1);
            else if ("+" === T) u1.splice(x, 0, B), i1.splice(x, 0, N), x++;
            else if ("\\" === T) {
                var k = F.lines[S - 1] ? F.lines[S - 1][0] : null;
                "+" === k ? r1 = !0 : "-" === k && (o3 = !0);
            }
        }
    }
    if (r1) for(; !u1[u1.length - 1];)u1.pop(), i1.pop();
    else o3 && (u1.push(""), i1.push("\n"));
    for(var P = 0; P < u1.length - 1; P++)u1[P] = u1[P] + i1[P];
    return u1.join("");
}
function w(e2, t2) {
    if (t2.length > e2.length) return !1;
    for(var n2 = 0; n2 < t2.length; n2++)if (t2[n2] !== e2[n2]) return !1;
    return !0;
}
function N(e2) {
    return e2.newFileName && e2.newFileName !== e2.oldFileName;
}
function k5(e2, t2, n2) {
    return t2 === n2 ? t2 : (e2.conflict = !0, {
        mine: t2,
        theirs: n2
    });
}
function P3(e2, t2) {
    return e2.oldStart < t2.oldStart && e2.oldStart + e2.oldLines < t2.oldStart;
}
function O(e2, t2) {
    return {
        oldStart: e2.oldStart,
        oldLines: e2.oldLines,
        newStart: e2.newStart + t2,
        newLines: e2.newLines,
        lines: e2.lines
    };
}
function j3(e2, t2, n2) {
    e2.conflict = !0, e2.lines.push({
        conflict: !0,
        mine: t2,
        theirs: n2
    });
}
function _(e2, t2, n2) {
    for(; t2.offset < n2.offset && t2.index < t2.lines.length;){
        var r1 = t2.lines[t2.index++];
        e2.lines.push(r1), t2.offset++;
    }
}
function R(e2, t2) {
    for(; t2.index < t2.lines.length;){
        var n2 = t2.lines[t2.index++];
        e2.lines.push(n2);
    }
}
function V(e2) {
    for(var t2 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length;){
        var r1 = e2.lines[e2.index];
        if ("-" === n2 && "+" === r1[0] && (n2 = "+"), n2 !== r1[0]) break;
        t2.push(r1), e2.index++;
    }
    return t2;
}
function $(e2) {
    return e2.reduce(function(e3, t2) {
        return e3 && "-" === t2[0];
    }, !0);
}
function q(e2, t2, n2) {
    for(var r1 = 0; r1 < n2; r1++){
        var o3 = t2[t2.length - n2 + r1].substr(1);
        if (e2.lines[e2.index + r1] !== " " + o3) return !1;
    }
    return e2.index += n2, !0;
}
function W(e2) {
    var t2 = 0, n2 = 0;
    return e2.forEach(function(e3) {
        if ("string" != typeof e3) {
            var r1 = W(e3.mine), o3 = W(e3.theirs);
            (void 0) !== t2 && (r1.oldLines === o3.oldLines ? t2 += r1.oldLines : t2 = void 0), (void 0) !== n2 && (r1.newLines === o3.newLines ? n2 += r1.newLines : n2 = void 0);
        } else (void 0) === n2 || "+" !== e3[0] && " " !== e3[0] || n2++, (void 0) === t2 || "-" !== e3[0] && " " !== e3[0] || t2++;
    }), {
        oldLines: t2,
        newLines: n2
    };
}
function U(e2) {
    var t2 = e2;
    return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
}
b.tokenize = function(e2) {
    return e2.slice();
}, b.join = b.removeEmpty = function(e2) {
    return e2;
};
function z(e2) {
    return {
        type: "concat",
        parts: e2
    };
}
function G(e2) {
    return {
        type: "indent",
        contents: e2
    };
}
function H3(e2, t2) {
    return {
        type: "align",
        contents: t2,
        n: e2
    };
}
function X(e2, t2) {
    return {
        type: "group",
        id: (t2 = t2 || {
        }).id,
        contents: e2,
        break: !!t2.shouldBreak,
        expandedStates: t2.expandedStates
    };
}
const Y = {
    type: "break-parent"
}, K = z([
    {
        type: "line",
        hard: !0
    },
    Y
]), Q2 = z([
    {
        type: "line",
        hard: !0,
        literal: !0
    },
    Y
]);
var Z3 = {
    concat: z,
    join: function(e2, t2) {
        const n2 = [];
        for(let r1 = 0; r1 < t2.length; r1++)0 !== r1 && n2.push(e2), n2.push(t2[r1]);
        return z(n2);
    },
    line: {
        type: "line"
    },
    softline: {
        type: "line",
        soft: !0
    },
    hardline: K,
    literalline: Q2,
    group: X,
    conditionalGroup: function(e2, t2) {
        return X(e2[0], Object.assign({
        }, t2, {
            expandedStates: e2
        }));
    },
    fill: function(e2) {
        return {
            type: "fill",
            parts: e2
        };
    },
    lineSuffix: function(e2) {
        return {
            type: "line-suffix",
            contents: e2
        };
    },
    lineSuffixBoundary: {
        type: "line-suffix-boundary"
    },
    cursor: {
        type: "cursor",
        placeholder: Symbol("cursor")
    },
    breakParent: Y,
    ifBreak: function(e2, t2, n2) {
        return {
            type: "if-break",
            breakContents: e2,
            flatContents: t2,
            groupId: (n2 = n2 || {
            }).groupId
        };
    },
    trim: {
        type: "trim"
    },
    indent: G,
    align: H3,
    addAlignmentToDoc: function(e2, t2, n2) {
        let r1 = e2;
        if (t2 > 0) {
            for(let e3 = 0; e3 < Math.floor(t2 / n2); ++e3)r1 = G(r1);
            r1 = H3(t2 % n2, r1), r1 = H3(-1 / 0, r1);
        }
        return r1;
    },
    markAsRoot: function(e2) {
        return H3({
            type: "root"
        }, e2);
    },
    dedentToRoot: function(e2) {
        return H3(-1 / 0, e2);
    },
    dedent: function(e2) {
        return H3(-1, e2);
    }
}, ee2 = (e2)=>"string" == typeof e2 ? e2.replace((({ onlyFirst: e3 = !1  } = {
    })=>{
        const t2 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(t2, e3 ? void 0 : "g");
    })(), "") : e2
;
const te = (e2)=>!Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || 9001 === e2 || 9002 === e2 || 11904 <= e2 && e2 <= 12871 && 12351 !== e2 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141))
;
var ne2 = te, re = te;
ne2.default = re;
const oe = (e2)=>{
    if ("string" != typeof (e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === e2.length) return 0;
    e2 = ee2(e2);
    let t2 = 0;
    for(let n2 = 0; n2 < e2.length; n2++){
        const r1 = e2.codePointAt(n2);
        r1 <= 31 || r1 >= 127 && r1 <= 159 || (r1 >= 768 && r1 <= 879 || (r1 > 65535 && n2++, t2 += ne2(r1) ? 2 : 1));
    }
    return t2;
};
var ue = oe, ie = oe;
ue.default = ie;
var ae = (e2)=>{
    if ("string" != typeof e2) throw new TypeError("Expected a string");
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, se = (e2)=>e2[e2.length - 1]
, le = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function ce3() {
    throw new Error("setTimeout has not been defined");
}
function pe2() {
    throw new Error("clearTimeout has not been defined");
}
var de3 = ce3, fe = pe2;
function he3(e2) {
    if (de3 === setTimeout) return setTimeout(e2, 0);
    if ((de3 === ce3 || !de3) && setTimeout) return de3 = setTimeout, setTimeout(e2, 0);
    try {
        return de3(e2, 0);
    } catch (t) {
        try {
            return de3.call(null, e2, 0);
        } catch (t) {
            return de3.call(this, e2, 0);
        }
    }
}
"function" == typeof le.setTimeout && (de3 = setTimeout), "function" == typeof le.clearTimeout && (fe = clearTimeout);
var me, ge3 = [], De2 = !1, ye2 = -1;
function be2(e2, t2) {
    this.fun = e2, this.array = t2;
}
be2.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function ve3() {
}
var Ae = ve3, Fe = ve3, xe = ve3, Se = ve3, we3 = ve3, Te = ve3, Be1 = ve3;
var Ne = le.performance || {
}, ke = Ne.now || Ne.mozNow || Ne.msNow || Ne.oNow || Ne.webkitNow || function() {
    return (new Date).getTime();
};
var Pe3 = new Date;
var Le3 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
}, Me = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {
};
function je(e2, t2, n2) {
    return e2(n2 = {
        path: t2,
        exports: {
        },
        require: function(e3, t3) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == t3 && n2.path);
        }
    }, n2.exports), n2.exports;
}
function _e(e2) {
    return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
const Ve = /^[0-9]+$/, $e = (e2, t2)=>{
    const n2 = Ve.test(e2), r1 = Ve.test(t2);
    return n2 && r1 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : n2 && !r1 ? -1 : r1 && !n2 ? 1 : e2 < t2 ? -1 : 1;
};
var qe = {
    compareIdentifiers: $e,
    rcompareIdentifiers: (e2, t2)=>$e(t2, e2)
};
function et() {
    const e2 = t1([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return et = function() {
        return e2;
    }, e2;
}
function tt() {
    const e2 = t1([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return tt = function() {
        return e2;
    }, e2;
}
function nt() {
    const e2 = t1([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return nt = function() {
        return e2;
    }, e2;
}
function rt() {
    const e2 = t1([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return rt = function() {
        return e2;
    }, e2;
}
function ot() {
    const e2 = t1([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return ot = function() {
        return e2;
    }, e2;
}
function ut() {
    const e2 = t1([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return ut = function() {
        return e2;
    }, e2;
}
function ht(e2) {
    return (t2, n2, r1)=>{
        const o3 = r1 && r1.backwards;
        if (!1 === n2) return !1;
        const { length: u1  } = t2;
        let i1 = n2;
        for(; i1 >= 0 && i1 < u1;){
            const n3 = t2.charAt(i1);
            if (e2 instanceof RegExp) {
                if (!e2.test(n3)) return i1;
            } else if (!e2.includes(n3)) return i1;
            o3 ? i1-- : i1++;
        }
        return (-1 === i1 || i1 === u1) && i1;
    };
}
const mt = ht(/\s/), gt = ht(" \t"), Dt = ht(",; \t"), yt = ht(/[^\n\r]/);
function Et(e2, t2) {
    if (!1 === t2) return !1;
    if ("/" === e2.charAt(t2) && "*" === e2.charAt(t2 + 1)) for(let n2 = t2 + 2; n2 < e2.length; ++n2)if ("*" === e2.charAt(n2) && "/" === e2.charAt(n2 + 1)) return n2 + 2;
    return t2;
}
function Ct(e2, t2) {
    return !1 !== t2 && ("/" === e2.charAt(t2) && "/" === e2.charAt(t2 + 1) ? yt(e2, t2) : t2);
}
function bt(e2, t2, n2) {
    const r1 = n2 && n2.backwards;
    if (!1 === t2) return !1;
    const o3 = e2.charAt(t2);
    if (r1) {
        if ("\r" === e2.charAt(t2 - 1) && "\n" === o3) return t2 - 2;
        if ("\n" === o3 || "\r" === o3 || "\u2028" === o3 || "\u2029" === o3) return t2 - 1;
    } else {
        if ("\r" === o3 && "\n" === e2.charAt(t2 + 1)) return t2 + 2;
        if ("\n" === o3 || "\r" === o3 || "\u2028" === o3 || "\u2029" === o3) return t2 + 1;
    }
    return t2;
}
function vt(e2, t2, n2) {
    const r1 = gt(e2, (n2 = n2 || {
    }).backwards ? t2 - 1 : t2, n2);
    return r1 !== bt(e2, r1, n2);
}
function At(e2, t2) {
    let n2 = null, r1 = t2;
    for(; r1 !== n2;)n2 = r1, r1 = Dt(e2, r1), r1 = Et(e2, r1), r1 = gt(e2, r1);
    return r1 = Ct(e2, r1), r1 = bt(e2, r1), !1 !== r1 && vt(e2, r1);
}
function Ft(e2, t2) {
    let n2 = null, r1 = t2;
    for(; r1 !== n2;)n2 = r1, r1 = gt(e2, r1), r1 = Et(e2, r1), r1 = Ct(e2, r1), r1 = bt(e2, r1);
    return r1;
}
function xt(e2, t2, n2) {
    return Ft(e2, n2(t2));
}
function St2(e2, t2, n2) {
    let r1 = 0;
    for(let o3 = n2 = n2 || 0; o3 < e2.length; ++o3)"\t" === e2[o3] ? r1 = r1 + t2 - r1 % t2 : r1++;
    return r1;
}
function wt(e2, t2) {
    const n2 = e2.slice(1, -1), r1 = {
        quote: '"',
        regex: /"/g
    }, o3 = {
        quote: "'",
        regex: /'/g
    }, u1 = "'" === t2 ? o3 : r1, i1 = u1 === o3 ? r1 : o3;
    let a2 = u1.quote;
    if (n2.includes(u1.quote) || n2.includes(i1.quote)) {
        a2 = (n2.match(u1.regex) || []).length > (n2.match(i1.regex) || []).length ? i1.quote : u1.quote;
    }
    return a2;
}
function Tt(e2, t2, n2) {
    const r1 = '"' === t2 ? "'" : '"', o3 = e2.replace(/\\([\S\s])|(["'])/g, (e3, o4, u1)=>o4 === r1 ? o4 : u1 === t2 ? "\\" + u1 : u1 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o4) ? o4 : "\\" + o4)
    );
    return t2 + o3 + t2;
}
function Bt(e2, t2) {
    (e2.comments || (e2.comments = [])).push(t2), t2.printed = !1, "JSXText" === e2.type && (t2.printed = !0);
}
var kt = {
    guessEndOfLine: function(e2) {
        const t2 = e2.indexOf("\r");
        return t2 >= 0 ? "\n" === e2.charAt(t2 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(e2) {
        switch(e2){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(e2, t2) {
        let n2;
        if ("\n" === t2) n2 = /\n/g;
        else if ("\r" === t2) n2 = /\r/g;
        else {
            if ("\r\n" !== t2) throw new Error('Unexpected "eol" '.concat(JSON.stringify(t2), "."));
            n2 = /\r\n/g;
        }
        const r1 = e2.match(n2);
        return r1 ? r1.length : 0;
    },
    normalizeEndOfLine: function(e2) {
        return e2.replace(/\r\n?/g, "\n");
    }
};
let jt;
function Vt(e2, t2, n2) {
    const r1 = "dedent" === t2.type ? e2.queue.slice(0, -1) : e2.queue.concat(t2);
    let o3 = "", u1 = 0, i1 = 0, a2 = 0;
    for (const e3 of r1)switch(e3.type){
        case "indent":
            c2(), n2.useTabs ? s2(1) : l2(n2.tabWidth);
            break;
        case "stringAlign":
            c2(), o3 += e3.n, u1 += e3.n.length;
            break;
        case "numberAlign":
            i1 += 1, a2 += e3.n;
            break;
        default:
            throw new Error("Unexpected type '".concat(e3.type, "'"));
    }
    return p2(), Object.assign({
    }, e2, {
        value: o3,
        length: u1,
        queue: r1
    });
    function s2(e4) {
        o3 += "\t".repeat(e4), u1 += n2.tabWidth * e4;
    }
    function l2(e4) {
        o3 += " ".repeat(e4), u1 += e4;
    }
    function c2() {
        n2.useTabs ? (function() {
            i1 > 0 && s2(i1);
            d2();
        })() : p2();
    }
    function p2() {
        a2 > 0 && l2(a2), d2();
    }
    function d2() {
        i1 = 0, a2 = 0;
    }
}
function $t(e2) {
    if (0 === e2.length) return 0;
    let t2 = 0;
    for(; e2.length > 0 && "string" == typeof e2[e2.length - 1] && e2[e2.length - 1].match(/^[\t ]*$/);)t2 += e2.pop().length;
    if (e2.length && "string" == typeof e2[e2.length - 1]) {
        const n2 = e2[e2.length - 1].replace(/[\t ]*$/, "");
        t2 += e2[e2.length - 1].length - n2.length, e2[e2.length - 1] = n2;
    }
    return t2;
}
const { literalline: Ut , concat: Jt  } = Z3, zt2 = {
};
function Gt(e2, t2, n2, r1) {
    const o3 = [
        e2
    ];
    for(; 0 !== o3.length;){
        const e3 = o3.pop();
        if (e3 !== zt2) {
            if (n2 && o3.push(e3, zt2), !t2 || !1 !== t2(e3)) {
                if ("concat" === e3.type || "fill" === e3.type) for(let t3 = e3.parts.length - 1; t3 >= 0; --t3)o3.push(e3.parts[t3]);
                else if ("if-break" === e3.type) e3.flatContents && o3.push(e3.flatContents), e3.breakContents && o3.push(e3.breakContents);
                else if ("group" === e3.type && e3.expandedStates) {
                    if (r1) for(let t4 = e3.expandedStates.length - 1; t4 >= 0; --t4)o3.push(e3.expandedStates[t4]);
                    else o3.push(e3.contents);
                } else e3.contents && o3.push(e3.contents);
            }
        } else n2(o3.pop());
    }
}
function Ht(e2, t2) {
    if ("concat" === e2.type || "fill" === e2.type) {
        const n2 = e2.parts.map((e3)=>Ht(e3, t2)
        );
        return t2(Object.assign({
        }, e2, {
            parts: n2
        }));
    }
    if ("if-break" === e2.type) {
        const n2 = e2.breakContents && Ht(e2.breakContents, t2), r1 = e2.flatContents && Ht(e2.flatContents, t2);
        return t2(Object.assign({
        }, e2, {
            breakContents: n2,
            flatContents: r1
        }));
    }
    if (e2.contents) {
        const n2 = Ht(e2.contents, t2);
        return t2(Object.assign({
        }, e2, {
            contents: n2
        }));
    }
    return t2(e2);
}
function Xt(e2, t2, n2) {
    let r1 = n2, o3 = !1;
    return Gt(e2, function(e3) {
        const n3 = t2(e3);
        if (((void 0) !== n3 && (o3 = !0, r1 = n3), o3)) return !1;
    }), r1;
}
function Yt(e2) {
    return "string" != typeof e2 && ("line" === e2.type || void 0);
}
function Kt(e2) {
    return !("group" !== e2.type || !e2.break) || (!("line" !== e2.type || !e2.hard) || ("break-parent" === e2.type || void 0));
}
function Qt2(e2) {
    if (e2.length > 0) {
        const t2 = e2[e2.length - 1];
        t2.expandedStates || (t2.break = !0);
    }
    return null;
}
function Zt(e2) {
    return "line" !== e2.type || e2.hard ? "if-break" === e2.type ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
}
function en(e2) {
    const t2 = [], n2 = e2.filter(Boolean);
    for(; 0 !== n2.length;){
        const e3 = n2.shift();
        e3 && ("concat" !== e3.type ? 0 === t2.length || "string" != typeof t2[t2.length - 1] || "string" != typeof e3 ? t2.push(e3) : t2[t2.length - 1] += e3 : n2.unshift(...e3.parts));
    }
    return t2;
}
function tn(e2) {
    if ("concat" === e2.type) {
        const t2 = [];
        for(let n2 = 0; n2 < e2.parts.length; ++n2){
            const r1 = e2.parts[n2];
            if ("string" != typeof r1 && "concat" === r1.type) t2.push(...tn(r1).parts);
            else {
                const e3 = tn(r1);
                "" !== e3 && t2.push(e3);
            }
        }
        return Object.assign({
        }, e2, {
            parts: t2
        });
    }
    return "if-break" === e2.type ? Object.assign({
    }, e2, {
        breakContents: null != e2.breakContents ? tn(e2.breakContents) : null,
        flatContents: null != e2.flatContents ? tn(e2.flatContents) : null
    }) : "group" === e2.type ? Object.assign({
    }, e2, {
        contents: tn(e2.contents),
        expandedStates: e2.expandedStates ? e2.expandedStates.map(tn) : e2.expandedStates
    }) : e2.contents ? Object.assign({
    }, e2, {
        contents: tn(e2.contents)
    }) : e2;
}
function nn(e2) {
    if ("string" == typeof e2) return JSON.stringify(e2);
    if ("line" === e2.type) return e2.literal ? "literalline" : e2.hard ? "hardline" : e2.soft ? "softline" : "line";
    if ("break-parent" === e2.type) return "breakParent";
    if ("trim" === e2.type) return "trim";
    if ("concat" === e2.type) return "[" + e2.parts.map(nn).join(", ") + "]";
    if ("indent" === e2.type) return "indent(" + nn(e2.contents) + ")";
    if ("align" === e2.type) return e2.n === -1 / 0 ? "dedentToRoot(" + nn(e2.contents) + ")" : e2.n < 0 ? "dedent(" + nn(e2.contents) + ")" : "root" === e2.n.type ? "markAsRoot(" + nn(e2.contents) + ")" : "align(" + JSON.stringify(e2.n) + ", " + nn(e2.contents) + ")";
    if ("if-break" === e2.type) return "ifBreak(" + nn(e2.breakContents) + (e2.flatContents ? ", " + nn(e2.flatContents) : "") + ")";
    if ("group" === e2.type) return e2.expandedStates ? "conditionalGroup([" + e2.expandedStates.map(nn).join(",") + "])" : (e2.break ? "wrappedGroup" : "group") + "(" + nn(e2.contents) + ")";
    if ("fill" === e2.type) return "fill(" + e2.parts.map(nn).join(", ") + ")";
    if ("line-suffix" === e2.type) return "lineSuffix(" + nn(e2.contents) + ")";
    if ("line-suffix-boundary" === e2.type) return "lineSuffixBoundary";
    throw new Error("Unknown doc type " + e2.type);
}
const on = ()=>!1
, un = ()=>""
;
var an = {
    existsSync: on,
    readFileSync: un
}, sn = Object.freeze({
    __proto__: null,
    existsSync: on,
    readFileSync: un,
    default: an
});
function ln(e2) {
    if ("string" != typeof e2) throw new TypeError("Path must be a string. Received " + JSON.stringify(e2));
}
function cn(e2, t2) {
    for(var n2, r1 = "", o3 = 0, u1 = -1, i1 = 0, a2 = 0; a2 <= e2.length; ++a2){
        if (a2 < e2.length) n2 = e2.charCodeAt(a2);
        else {
            if (47 === n2) break;
            n2 = 47;
        }
        if (47 === n2) {
            if (u1 === a2 - 1 || 1 === i1) ;
            else if (u1 !== a2 - 1 && 2 === i1) {
                if (r1.length < 2 || 2 !== o3 || 46 !== r1.charCodeAt(r1.length - 1) || 46 !== r1.charCodeAt(r1.length - 2)) {
                    if (r1.length > 2) {
                        var s2 = r1.lastIndexOf("/");
                        if (s2 !== r1.length - 1) {
                            -1 === s2 ? (r1 = "", o3 = 0) : o3 = (r1 = r1.slice(0, s2)).length - 1 - r1.lastIndexOf("/"), u1 = a2, i1 = 0;
                            continue;
                        }
                    } else if (2 === r1.length || 1 === r1.length) {
                        r1 = "", o3 = 0, u1 = a2, i1 = 0;
                        continue;
                    }
                }
                t2 && (r1.length > 0 ? r1 += "/.." : r1 = "..", o3 = 2);
            } else r1.length > 0 ? r1 += "/" + e2.slice(u1 + 1, a2) : r1 = e2.slice(u1 + 1, a2), o3 = a2 - u1 - 1;
            u1 = a2, i1 = 0;
        } else 46 === n2 && -1 !== i1 ? ++i1 : i1 = -1;
    }
    return r1;
}
function bn(e2, t2, n2, r1, o3) {
    var u1, i1, a2 = 8 * o3 - r1 - 1, s2 = (1 << a2) - 1, l2 = s2 >> 1, c2 = -7, p2 = n2 ? o3 - 1 : 0, d2 = n2 ? -1 : 1, f1 = e2[t2 + p2];
    for(p2 += d2, u1 = f1 & (1 << -c2) - 1, f1 >>= -c2, c2 += a2; c2 > 0; u1 = 256 * u1 + e2[t2 + p2], p2 += d2, c2 -= 8);
    for(i1 = u1 & (1 << -c2) - 1, u1 >>= -c2, c2 += r1; c2 > 0; i1 = 256 * i1 + e2[t2 + p2], p2 += d2, c2 -= 8);
    if (0 === u1) u1 = 1 - l2;
    else {
        if (u1 === s2) return i1 ? NaN : 1 / 0 * (f1 ? -1 : 1);
        i1 += Math.pow(2, r1), u1 -= l2;
    }
    return (f1 ? -1 : 1) * i1 * Math.pow(2, u1 - r1);
}
function vn(e2, t2, n2, r1, o3, u1) {
    var i1, a2, s2, l2 = 8 * u1 - o3 - 1, c2 = (1 << l2) - 1, p2 = c2 >> 1, d2 = 23 === o3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f1 = r1 ? 0 : u1 - 1, h1 = r1 ? 1 : -1, m1 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
    for(t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (a2 = isNaN(t2) ? 1 : 0, i1 = c2) : (i1 = Math.floor(Math.log(t2) / Math.LN2), t2 * (s2 = Math.pow(2, -i1)) < 1 && (i1--, s2 *= 2), (t2 += i1 + p2 >= 1 ? d2 / s2 : d2 * Math.pow(2, 1 - p2)) * s2 >= 2 && (i1++, s2 /= 2), i1 + p2 >= c2 ? (a2 = 0, i1 = c2) : i1 + p2 >= 1 ? (a2 = (t2 * s2 - 1) * Math.pow(2, o3), i1 += p2) : (a2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, o3), i1 = 0)); o3 >= 8; e2[n2 + f1] = 255 & a2, f1 += h1, a2 /= 256, o3 -= 8);
    for(i1 = i1 << o3 | a2, l2 += o3; l2 > 0; e2[n2 + f1] = 255 & i1, f1 += h1, i1 /= 256, l2 -= 8);
    e2[n2 + f1 - h1] |= 128 * m1;
}
var An = {
}.toString, Fn = Array.isArray || function(e2) {
    return "[object Array]" == An.call(e2);
};
function Bn(e2) {
    if ("number" != typeof e2) throw new TypeError('"size" argument must be a number');
    if (e2 < 0) throw new RangeError('"size" argument must not be negative');
}
function On(e2) {
    return !(null == e2 || !e2._isBuffer);
}
function Mn(e2, t2, n2) {
    var r1 = e2[t2];
    e2[t2] = e2[n2], e2[n2] = r1;
}
function _n(e2, t2, n2, r1, o3) {
    var u1, i1 = 1, a2 = e2.length, s2 = t2.length;
    if ((void 0) !== r1 && ("ucs2" === (r1 = String(r1).toLowerCase()) || "ucs-2" === r1 || "utf16le" === r1 || "utf-16le" === r1)) {
        if (e2.length < 2 || t2.length < 2) return -1;
        i1 = 2, a2 /= 2, s2 /= 2, n2 /= 2;
    }
    function l2(e3, t3) {
        return 1 === i1 ? e3[t3] : e3.readUInt16BE(t3 * i1);
    }
    if (o3) {
        var c2 = -1;
        for(u1 = n2; u1 < a2; u1++)if (l2(e2, u1) === l2(t2, -1 === c2 ? 0 : u1 - c2)) {
            if (-1 === c2 && (c2 = u1), u1 - c2 + 1 === s2) return c2 * i1;
        } else -1 !== c2 && (u1 -= u1 - c2), c2 = -1;
    } else for(n2 + s2 > a2 && (n2 = a2 - s2), u1 = n2; u1 >= 0; u1--){
        for(var p2 = !0, d2 = 0; d2 < s2; d2++)if (l2(e2, u1 + d2) !== l2(t2, d2)) {
            p2 = !1;
            break;
        }
        if (p2) return u1;
    }
    return -1;
}
function Rn(e2, t2, n2, r1) {
    n2 = Number(n2) || 0;
    var o3 = e2.length - n2;
    r1 ? (r1 = Number(r1)) > o3 && (r1 = o3) : r1 = o3;
    var u1 = t2.length;
    if (u1 % 2 != 0) throw new TypeError("Invalid hex string");
    r1 > u1 / 2 && (r1 = u1 / 2);
    for(var i1 = 0; i1 < r1; ++i1){
        var a2 = parseInt(t2.substr(2 * i1, 2), 16);
        if (isNaN(a2)) return i1;
        e2[n2 + i1] = a2;
    }
    return i1;
}
function zn(e2, t2, n2) {
    n2 = Math.min(e2.length, n2);
    for(var r1 = [], o3 = t2; o3 < n2;){
        var u1, i1, a2, s2, l2 = e2[o3], c2 = null, p2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
        if (o3 + p2 <= n2) switch(p2){
            case 1:
                l2 < 128 && (c2 = l2);
                break;
            case 2:
                128 == (192 & (u1 = e2[o3 + 1])) && (s2 = (31 & l2) << 6 | 63 & u1) > 127 && (c2 = s2);
                break;
            case 3:
                u1 = e2[o3 + 1], i1 = e2[o3 + 2], 128 == (192 & u1) && 128 == (192 & i1) && (s2 = (15 & l2) << 12 | (63 & u1) << 6 | 63 & i1) > 2047 && (s2 < 55296 || s2 > 57343) && (c2 = s2);
                break;
            case 4:
                u1 = e2[o3 + 1], i1 = e2[o3 + 2], a2 = e2[o3 + 3], 128 == (192 & u1) && 128 == (192 & i1) && 128 == (192 & a2) && (s2 = (15 & l2) << 18 | (63 & u1) << 12 | (63 & i1) << 6 | 63 & a2) > 65535 && s2 < 1114112 && (c2 = s2);
        }
        null === c2 ? (c2 = 65533, p2 = 1) : c2 > 65535 && (c2 -= 65536, r1.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r1.push(c2), o3 += p2;
    }
    return (function(e3) {
        var t3 = e3.length;
        if (t3 <= 4096) return String.fromCharCode.apply(String, e3);
        var n3 = "", r2 = 0;
        for(; r2 < t3;)n3 += String.fromCharCode.apply(String, e3.slice(r2, r2 += 4096));
        return n3;
    })(r1);
}
function Gn(e2, t2, n2) {
    var r1 = "";
    n2 = Math.min(e2.length, n2);
    for(var o3 = t2; o3 < n2; ++o3)r1 += String.fromCharCode(127 & e2[o3]);
    return r1;
}
function Hn(e2, t2, n2) {
    var r1 = "";
    n2 = Math.min(e2.length, n2);
    for(var o3 = t2; o3 < n2; ++o3)r1 += String.fromCharCode(e2[o3]);
    return r1;
}
function Yn(e2, t2, n2) {
    for(var r1 = e2.slice(t2, n2), o3 = "", u1 = 0; u1 < r1.length; u1 += 2)o3 += String.fromCharCode(r1[u1] + 256 * r1[u1 + 1]);
    return o3;
}
function Kn(e2, t2, n2) {
    if (e2 % 1 != 0 || e2 < 0) throw new RangeError("offset is not uint");
    if (e2 + t2 > n2) throw new RangeError("Trying to access beyond buffer length");
}
function Qn(e2, t2, n2, r1, o3, u1) {
    if (!On(e2)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t2 > o3 || t2 < u1) throw new RangeError('"value" argument is out of bounds');
    if (n2 + r1 > e2.length) throw new RangeError("Index out of range");
}
function Zn(e2, t2, n2, r1) {
    t2 < 0 && (t2 = 65535 + t2 + 1);
    for(var o3 = 0, u1 = Math.min(e2.length - n2, 2); o3 < u1; ++o3)e2[n2 + o3] = (t2 & 255 << 8 * (r1 ? o3 : 1 - o3)) >>> 8 * (r1 ? o3 : 1 - o3);
}
function er(e2, t2, n2, r1) {
    t2 < 0 && (t2 = 4294967295 + t2 + 1);
    for(var o3 = 0, u1 = Math.min(e2.length - n2, 4); o3 < u1; ++o3)e2[n2 + o3] = t2 >>> 8 * (r1 ? o3 : 3 - o3) & 255;
}
function tr(e2, t2, n2, r1, o3, u1) {
    if (n2 + r1 > e2.length) throw new RangeError("Index out of range");
    if (n2 < 0) throw new RangeError("Index out of range");
}
function nr(e2, t2, n2, r1, o3) {
    return o3 || tr(e2, 0, n2, 4), vn(e2, t2, n2, r1, 23, 4), n2 + 4;
}
function rr(e2, t2, n2, r1, o3) {
    return o3 || tr(e2, 0, n2, 8), vn(e2, t2, n2, r1, 52, 8), n2 + 8;
}
var or = /[^+\/0-9A-Za-z-_]/g;
function ur(e2) {
    return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
}
function ir(e2, t2) {
    var n2;
    t2 = t2 || 1 / 0;
    for(var r1 = e2.length, o3 = null, u1 = [], i1 = 0; i1 < r1; ++i1){
        if ((n2 = e2.charCodeAt(i1)) > 55295 && n2 < 57344) {
            if (!o3) {
                if (n2 > 56319) {
                    (t2 -= 3) > -1 && u1.push(239, 191, 189);
                    continue;
                }
                if (i1 + 1 === r1) {
                    (t2 -= 3) > -1 && u1.push(239, 191, 189);
                    continue;
                }
                o3 = n2;
                continue;
            }
            if (n2 < 56320) {
                (t2 -= 3) > -1 && u1.push(239, 191, 189), o3 = n2;
                continue;
            }
            n2 = 65536 + (o3 - 55296 << 10 | n2 - 56320);
        } else o3 && (t2 -= 3) > -1 && u1.push(239, 191, 189);
        if (o3 = null, n2 < 128) {
            if ((t2 -= 1) < 0) break;
            u1.push(n2);
        } else if (n2 < 2048) {
            if ((t2 -= 2) < 0) break;
            u1.push(n2 >> 6 | 192, 63 & n2 | 128);
        } else if (n2 < 65536) {
            if ((t2 -= 3) < 0) break;
            u1.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
        } else {
            if (!(n2 < 1114112)) throw new Error("Invalid code point");
            if ((t2 -= 4) < 0) break;
            u1.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
        }
    }
    return u1;
}
function sr(e2, t2, n2, r1) {
    for(var o3 = 0; o3 < r1 && !(o3 + n2 >= t2.length || o3 >= e2.length); ++o3)t2[o3 + n2] = e2[o3];
    return o3;
}
function lr(e2) {
    return !!e2.constructor && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
}
var cr = _e(sn);
var dr = function(e2) {
    for(var t2 = -1, n2 = null == e2 ? 0 : e2.length, r1 = {
    }; (++t2) < n2;){
        var o3 = e2[t2];
        r1[o3[0]] = o3[1];
    }
    return r1;
};
var Dr = function(e2, t2) {
    return (Dr = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(e3, t3) {
        e3.__proto__ = t3;
    } || function(e3, t3) {
        for(var n2 in t3)t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
    })(e2, t2);
};
var yr = function() {
    return (yr = Object.assign || function(e2) {
        for(var t2, n2 = 1, r1 = arguments.length; n2 < r1; n2++)for(var o3 in t2 = arguments[n2])Object.prototype.hasOwnProperty.call(t2, o3) && (e2[o3] = t2[o3]);
        return e2;
    }).apply(this, arguments);
};
function Er(e2) {
    var t2 = "function" == typeof Symbol && Symbol.iterator, n2 = t2 && e2[t2], r1 = 0;
    if (n2) return n2.call(e2);
    if (e2 && "number" == typeof e2.length) return {
        next: function() {
            return e2 && r1 >= e2.length && (e2 = void 0), {
                value: e2 && e2[r1++],
                done: !e2
            };
        }
    };
    throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Cr(e2, t2) {
    var n2 = "function" == typeof Symbol && e2[Symbol.iterator];
    if (!n2) return e2;
    var r1, o3, u1 = n2.call(e2), i1 = [];
    try {
        for(; ((void 0) === t2 || (t2--) > 0) && !(r1 = u1.next()).done;)i1.push(r1.value);
    } catch (e) {
        o3 = {
            error: e
        };
    } finally{
        try {
            r1 && !r1.done && (n2 = u1.return) && n2.call(u1);
        } finally{
            if (o3) throw o3.error;
        }
    }
    return i1;
}
function br(e2) {
    return this instanceof br ? (this.v = e2, this) : new br(e2);
}
var vr = Object.freeze({
    __proto__: null,
    __extends: function(e2, t2) {
        function n2() {
            this.constructor = e2;
        }
        Dr(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2);
    },
    get __assign () {
        return yr;
    },
    __rest: function(e2, t2) {
        var n2 = {
        };
        for(var r1 in e2)Object.prototype.hasOwnProperty.call(e2, r1) && t2.indexOf(r1) < 0 && (n2[r1] = e2[r1]);
        if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
            var o3 = 0;
            for(r1 = Object.getOwnPropertySymbols(e2); o3 < r1.length; o3++)t2.indexOf(r1[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r1[o3]) && (n2[r1[o3]] = e2[r1[o3]]);
        }
        return n2;
    },
    __decorate: function(e2, t2, n2, r1) {
        var o3, u1 = arguments.length, i1 = u1 < 3 ? t2 : null === r1 ? r1 = Object.getOwnPropertyDescriptor(t2, n2) : r1;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i1 = Reflect.decorate(e2, t2, n2, r1);
        else for(var a2 = e2.length - 1; a2 >= 0; a2--)(o3 = e2[a2]) && (i1 = (u1 < 3 ? o3(i1) : u1 > 3 ? o3(t2, n2, i1) : o3(t2, n2)) || i1);
        return (u1 > 3 && i1 && Object.defineProperty(t2, n2, i1), i1);
    },
    __param: function(e2, t2) {
        return function(n2, r1) {
            t2(n2, r1, e2);
        };
    },
    __metadata: function(e2, t2) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e2, t2);
    },
    __awaiter: function(e2, t2, n2, r1) {
        return new (n2 || (n2 = Promise))(function(o3, u1) {
            function i1(e3) {
                try {
                    s2(r1.next(e3));
                } catch (e) {
                    u1(e);
                }
            }
            function a2(e3) {
                try {
                    s2(r1.throw(e3));
                } catch (e) {
                    u1(e);
                }
            }
            function s2(e3) {
                var t3;
                e3.done ? o3(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
                    e4(t3);
                })).then(i1, a2);
            }
            s2((r1 = r1.apply(e2, t2 || [])).next());
        });
    },
    __generator: function(e2, t2) {
        var n2, r1, o3, u1, i1 = {
            label: 0,
            sent: function() {
                if (1 & o3[0]) throw o3[1];
                return o3[1];
            },
            trys: [],
            ops: []
        };
        return (u1 = {
            next: a2(0),
            throw: a2(1),
            return: a2(2)
        }, "function" == typeof Symbol && (u1[Symbol.iterator] = function() {
            return this;
        }), u1);
        function a2(u2) {
            return function(a3) {
                return function(u3) {
                    if (n2) throw new TypeError("Generator is already executing.");
                    for(; i1;)try {
                        if (n2 = 1, r1 && (o3 = 2 & u3[0] ? r1.return : u3[0] ? r1.throw || ((o3 = r1.return) && o3.call(r1), 0) : r1.next) && !(o3 = o3.call(r1, u3[1])).done) return o3;
                        switch(r1 = 0, o3 && (u3 = [
                            2 & u3[0],
                            o3.value
                        ]), u3[0]){
                            case 0:
                            case 1:
                                o3 = u3;
                                break;
                            case 4:
                                return i1.label++, {
                                    value: u3[1],
                                    done: !1
                                };
                            case 5:
                                i1.label++, r1 = u3[1], u3 = [
                                    0
                                ];
                                continue;
                            case 7:
                                u3 = i1.ops.pop(), i1.trys.pop();
                                continue;
                            default:
                                if (!(o3 = i1.trys, (o3 = o3.length > 0 && o3[o3.length - 1]) || 6 !== u3[0] && 2 !== u3[0])) {
                                    i1 = 0;
                                    continue;
                                }
                                if (3 === u3[0] && (!o3 || u3[1] > o3[0] && u3[1] < o3[3])) {
                                    i1.label = u3[1];
                                    break;
                                }
                                if (6 === u3[0] && i1.label < o3[1]) {
                                    i1.label = o3[1], o3 = u3;
                                    break;
                                }
                                if (o3 && i1.label < o3[2]) {
                                    i1.label = o3[2], i1.ops.push(u3);
                                    break;
                                }
                                o3[2] && i1.ops.pop(), i1.trys.pop();
                                continue;
                        }
                        u3 = t2.call(e2, i1);
                    } catch (e) {
                        u3 = [
                            6,
                            e
                        ], r1 = 0;
                    } finally{
                        n2 = o3 = 0;
                    }
                    if (5 & u3[0]) throw u3[1];
                    return {
                        value: u3[0] ? u3[1] : void 0,
                        done: !0
                    };
                }([
                    u2,
                    a3
                ]);
            };
        }
    },
    __createBinding: function(e2, t2, n2, r1) {
        (void 0) === r1 && (r1 = n2), e2[r1] = t2[n2];
    },
    __exportStar: function(e2, t2) {
        for(var n2 in e2)"default" === n2 || t2.hasOwnProperty(n2) || (t2[n2] = e2[n2]);
    },
    __values: Er,
    __read: Cr,
    __spread: function() {
        for(var e2 = [], t2 = 0; t2 < arguments.length; t2++)e2 = e2.concat(Cr(arguments[t2]));
        return e2;
    },
    __spreadArrays: function() {
        for(var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)e2 += arguments[t2].length;
        var r1 = Array(e2), o3 = 0;
        for(t2 = 0; t2 < n2; t2++)for(var u1 = arguments[t2], i1 = 0, a2 = u1.length; i1 < a2; (i1++, o3++))r1[o3] = u1[i1];
        return r1;
    },
    __await: br,
    __asyncGenerator: function(e2, t2, n2) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var r1, o3 = n2.apply(e2, t2 || []), u1 = [];
        return (r1 = {
        }, i2("next"), i2("throw"), i2("return"), r1[Symbol.asyncIterator] = function() {
            return this;
        }, r1);
        function i2(e3) {
            o3[e3] && (r1[e3] = function(t3) {
                return new Promise(function(n3, r2) {
                    u1.push([
                        e3,
                        t3,
                        n3,
                        r2
                    ]) > 1 || a2(e3, t3);
                });
            });
        }
        function a2(e3, t3) {
            try {
                (n4 = o3[e3](t3)).value instanceof br ? Promise.resolve(n4.value.v).then(s2, l2) : c2(u1[0][2], n4);
            } catch (e) {
                c2(u1[0][3], e);
            }
            var n4;
        }
        function s2(e3) {
            a2("next", e3);
        }
        function l2(e3) {
            a2("throw", e3);
        }
        function c2(e3, t3) {
            e3(t3), u1.shift(), u1.length && a2(u1[0][0], u1[0][1]);
        }
    },
    __asyncDelegator: function(e2) {
        var t2, n2;
        return (t2 = {
        }, r2("next"), r2("throw", function(e3) {
            throw e3;
        }), r2("return"), t2[Symbol.iterator] = function() {
            return this;
        }, t2);
        function r2(r3, o3) {
            t2[r3] = e2[r3] ? function(t3) {
                return (n2 = !n2) ? {
                    value: br(e2[r3](t3)),
                    done: "return" === r3
                } : o3 ? o3(t3) : t3;
            } : o3;
        }
    },
    __asyncValues: function(e2) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var t2, n2 = e2[Symbol.asyncIterator];
        return n2 ? n2.call(e2) : (e2 = Er(e2), t2 = {
        }, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
            return this;
        }, t2);
        function r2(n4) {
            t2[n4] = e2[n4] && function(t3) {
                return new Promise(function(r3, o3) {
                    (function(e3, t4, n5, r4) {
                        Promise.resolve(r4).then(function(t5) {
                            e3({
                                value: t5,
                                done: n5
                            });
                        }, t4);
                    })(r3, o3, (t3 = e2[n4](t3)).done, t3.value);
                });
            };
        }
    },
    __makeTemplateObject: function(e2, t2) {
        return (Object.defineProperty ? Object.defineProperty(e2, "raw", {
            value: t2
        }) : e2.raw = t2, e2);
    },
    __importStar: function(e2) {
        if (e2 && e2.__esModule) return e2;
        var t2 = {
        };
        if (null != e2) for(var n2 in e2)Object.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
        return (t2.default = e2, t2);
    },
    __importDefault: function(e2) {
        return e2 && e2.__esModule ? e2 : {
            default: e2
        };
    },
    __classPrivateFieldGet: function(e2, t2) {
        if (!t2.has(e2)) throw new TypeError("attempted to get private field on non-instance");
        return t2.get(e2);
    },
    __classPrivateFieldSet: function(e2, t2, n2) {
        if (!t2.has(e2)) throw new TypeError("attempted to set private field on non-instance");
        return (t2.set(e2, n2), n2);
    }
}), Ar = je(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), t2.apiDescriptor = {
        key: (e3)=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3)
        ,
        value (e) {
            if (null === e || "object" != typeof e) return JSON.stringify(e);
            if (Array.isArray(e)) return "[".concat(e.map((e4)=>t2.apiDescriptor.value(e4)
            ).join(", "), "]");
            const n2 = Object.keys(e);
            return 0 === n2.length ? "{}" : "{ ".concat(n2.map((n4)=>"".concat(t2.apiDescriptor.key(n4), ": ").concat(t2.apiDescriptor.value(e[n4]))
            ).join(", "), " }");
        },
        pair: ({ key: e4 , value: n2  })=>t2.apiDescriptor.value({
                [e4]: n2
            })
    };
}), Fr = je(function(e2, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), vr.__exportStar(Ar, t2);
}), xr = /[|\\{}()[\]^$+*?.]/g, Sr = function(e2) {
    if ("string" != typeof e2) throw new TypeError("Expected a string");
    return e2.replace(xr, "\\$&");
}, wr = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, Tr = je(function(e2) {
    var t2 = {
    };
    for(var n2 in wr)wr.hasOwnProperty(n2) && (t2[wr[n2]] = n2);
    var r2 = e2.exports = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    for(var o3 in r2)if (r2.hasOwnProperty(o3)) {
        if (!("channels" in r2[o3])) throw new Error("missing channels property: " + o3);
        if (!("labels" in r2[o3])) throw new Error("missing channel labels property: " + o3);
        if (r2[o3].labels.length !== r2[o3].channels) throw new Error("channel and label counts mismatch: " + o3);
        var u1 = r2[o3].channels, i2 = r2[o3].labels;
        delete r2[o3].channels, delete r2[o3].labels, Object.defineProperty(r2[o3], "channels", {
            value: u1
        }), Object.defineProperty(r2[o3], "labels", {
            value: i2
        });
    }
    r2.rgb.hsl = function(e4) {
        var t3, n4, r3 = e4[0] / 255, o4 = e4[1] / 255, u1 = e4[2] / 255, i2 = Math.min(r3, o4, u1), a2 = Math.max(r3, o4, u1), s2 = a2 - i2;
        return a2 === i2 ? t3 = 0 : r3 === a2 ? t3 = (o4 - u1) / s2 : o4 === a2 ? t3 = 2 + (u1 - r3) / s2 : u1 === a2 && (t3 = 4 + (r3 - o4) / s2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n4 = (i2 + a2) / 2, [
            t3,
            100 * (a2 === i2 ? 0 : n4 <= 0.5 ? s2 / (a2 + i2) : s2 / (2 - a2 - i2)),
            100 * n4
        ];
    }, r2.rgb.hsv = function(e4) {
        var t3, n4, r3, o4, u1, i2 = e4[0] / 255, a2 = e4[1] / 255, s2 = e4[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e5) {
            return (l2 - e5) / 6 / c2 + 0.5;
        };
        return 0 === c2 ? o4 = u1 = 0 : (u1 = c2 / l2, t3 = p2(i2), n4 = p2(a2), r3 = p2(s2), i2 === l2 ? o4 = r3 - n4 : a2 === l2 ? o4 = 1 / 3 + t3 - r3 : s2 === l2 && (o4 = 2 / 3 + n4 - t3), o4 < 0 ? o4 += 1 : o4 > 1 && (o4 -= 1)), [
            360 * o4,
            100 * u1,
            100 * l2
        ];
    }, r2.rgb.hwb = function(e4) {
        var t3 = e4[0], n4 = e4[1], o4 = e4[2];
        return [
            r2.rgb.hsl(e4)[0],
            100 * (1 / 255 * Math.min(t3, Math.min(n4, o4))),
            100 * (o4 = 1 - 1 / 255 * Math.max(t3, Math.max(n4, o4)))
        ];
    }, r2.rgb.cmyk = function(e4) {
        var t3, n4 = e4[0] / 255, r3 = e4[1] / 255, o4 = e4[2] / 255;
        return [
            100 * ((1 - n4 - (t3 = Math.min(1 - n4, 1 - r3, 1 - o4))) / (1 - t3) || 0),
            100 * ((1 - r3 - t3) / (1 - t3) || 0),
            100 * ((1 - o4 - t3) / (1 - t3) || 0),
            100 * t3
        ];
    }, r2.rgb.keyword = function(e4) {
        var n4 = t2[e4];
        if (n4) return n4;
        var r3, o4, u1, i2 = 1 / 0;
        for(var a2 in wr)if (wr.hasOwnProperty(a2)) {
            var s2 = wr[a2], l2 = (o4 = e4, u1 = s2, Math.pow(o4[0] - u1[0], 2) + Math.pow(o4[1] - u1[1], 2) + Math.pow(o4[2] - u1[2], 2));
            l2 < i2 && (i2 = l2, r3 = a2);
        }
        return r3;
    }, r2.keyword.rgb = function(e4) {
        return wr[e4];
    }, r2.rgb.xyz = function(e4) {
        var t3 = e4[0] / 255, n4 = e4[1] / 255, r3 = e4[2] / 255;
        return [
            100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n4 = n4 > 0.04045 ? Math.pow((n4 + 0.055) / 1.055, 2.4) : n4 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)),
            100 * (0.2126 * t3 + 0.7152 * n4 + 0.0722 * r3),
            100 * (0.0193 * t3 + 0.1192 * n4 + 0.9505 * r3)
        ];
    }, r2.rgb.lab = function(e4) {
        var t3 = r2.rgb.xyz(e4), n4 = t3[0], o4 = t3[1], u1 = t3[2];
        return o4 /= 100, u1 /= 108.883, n4 = (n4 /= 95.047) > 0.008856 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116, [
            116 * (o4 = o4 > 0.008856 ? Math.pow(o4, 1 / 3) : 7.787 * o4 + 16 / 116) - 16,
            500 * (n4 - o4),
            200 * (o4 - (u1 = u1 > 0.008856 ? Math.pow(u1, 1 / 3) : 7.787 * u1 + 16 / 116))
        ];
    }, r2.hsl.rgb = function(e4) {
        var t3, n4, r3, o4, u1, i2 = e4[0] / 360, a2 = e4[1] / 100, s2 = e4[2] / 100;
        if (0 === a2) return [
            u1 = 255 * s2,
            u1,
            u1
        ];
        t3 = 2 * s2 - (n4 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2), o4 = [
            0,
            0,
            0
        ];
        for(var l2 = 0; l2 < 3; l2++)(r3 = i2 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, u1 = 6 * r3 < 1 ? t3 + 6 * (n4 - t3) * r3 : 2 * r3 < 1 ? n4 : 3 * r3 < 2 ? t3 + (n4 - t3) * (2 / 3 - r3) * 6 : t3, o4[l2] = 255 * u1;
        return o4;
    }, r2.hsl.hsv = function(e4) {
        var t3 = e4[0], n4 = e4[1] / 100, r3 = e4[2] / 100, o4 = n4, u1 = Math.max(r3, 0.01);
        return n4 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, o4 *= u1 <= 1 ? u1 : 2 - u1, [
            t3,
            100 * (0 === r3 ? 2 * o4 / (u1 + o4) : 2 * n4 / (r3 + n4)),
            100 * ((r3 + n4) / 2)
        ];
    }, r2.hsv.rgb = function(e4) {
        var t3 = e4[0] / 60, n4 = e4[1] / 100, r3 = e4[2] / 100, o4 = Math.floor(t3) % 6, u1 = t3 - Math.floor(t3), i2 = 255 * r3 * (1 - n4), a2 = 255 * r3 * (1 - n4 * u1), s2 = 255 * r3 * (1 - n4 * (1 - u1));
        switch(r3 *= 255, o4){
            case 0:
                return [
                    r3,
                    s2,
                    i2
                ];
            case 1:
                return [
                    a2,
                    r3,
                    i2
                ];
            case 2:
                return [
                    i2,
                    r3,
                    s2
                ];
            case 3:
                return [
                    i2,
                    a2,
                    r3
                ];
            case 4:
                return [
                    s2,
                    i2,
                    r3
                ];
            case 5:
                return [
                    r3,
                    i2,
                    a2
                ];
        }
    }, r2.hsv.hsl = function(e4) {
        var t3, n4, r3, o4 = e4[0], u1 = e4[1] / 100, i2 = e4[2] / 100, a2 = Math.max(i2, 0.01);
        return r3 = (2 - u1) * i2, n4 = u1 * a2, [
            o4,
            100 * (n4 = (n4 /= (t3 = (2 - u1) * a2) <= 1 ? t3 : 2 - t3) || 0),
            100 * (r3 /= 2)
        ];
    }, r2.hwb.rgb = function(e4) {
        var t3, n4, r3, o4, u1, i2, a2, s2 = e4[0] / 360, l2 = e4[1] / 100, c2 = e4[2] / 100, p2 = l2 + c2;
        switch(p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t3 = Math.floor(6 * s2)), 0 != (1 & t3) && (r3 = 1 - r3), o4 = l2 + r3 * ((n4 = 1 - c2) - l2), t3){
            default:
            case 6:
            case 0:
                u1 = n4, i2 = o4, a2 = l2;
                break;
            case 1:
                u1 = o4, i2 = n4, a2 = l2;
                break;
            case 2:
                u1 = l2, i2 = n4, a2 = o4;
                break;
            case 3:
                u1 = l2, i2 = o4, a2 = n4;
                break;
            case 4:
                u1 = o4, i2 = l2, a2 = n4;
                break;
            case 5:
                u1 = n4, i2 = l2, a2 = o4;
        }
        return [
            255 * u1,
            255 * i2,
            255 * a2
        ];
    }, r2.cmyk.rgb = function(e4) {
        var t3 = e4[0] / 100, n4 = e4[1] / 100, r3 = e4[2] / 100, o4 = e4[3] / 100;
        return [
            255 * (1 - Math.min(1, t3 * (1 - o4) + o4)),
            255 * (1 - Math.min(1, n4 * (1 - o4) + o4)),
            255 * (1 - Math.min(1, r3 * (1 - o4) + o4))
        ];
    }, r2.xyz.rgb = function(e4) {
        var t3, n4, r3, o4 = e4[0] / 100, u1 = e4[1] / 100, i2 = e4[2] / 100;
        return n4 = -0.9689 * o4 + 1.8758 * u1 + 0.0415 * i2, r3 = 0.0557 * o4 + -0.204 * u1 + 1.057 * i2, t3 = (t3 = 3.2406 * o4 + -1.5372 * u1 + -0.4986 * i2) > 0.0031308 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n4 = n4 > 0.0031308 ? 1.055 * Math.pow(n4, 1 / 2.4) - 0.055 : 12.92 * n4, r3 = r3 > 0.0031308 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [
            255 * (t3 = Math.min(Math.max(0, t3), 1)),
            255 * (n4 = Math.min(Math.max(0, n4), 1)),
            255 * (r3 = Math.min(Math.max(0, r3), 1))
        ];
    }, r2.xyz.lab = function(e4) {
        var t3 = e4[0], n4 = e4[1], r3 = e4[2];
        return n4 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 0.008856 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [
            116 * (n4 = n4 > 0.008856 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116) - 16,
            500 * (t3 - n4),
            200 * (n4 - (r3 = r3 > 0.008856 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))
        ];
    }, r2.lab.xyz = function(e4) {
        var t3, n4, r3, o4 = e4[0];
        t3 = e4[1] / 500 + (n4 = (o4 + 16) / 116), r3 = n4 - e4[2] / 200;
        var u1 = Math.pow(n4, 3), i2 = Math.pow(t3, 3), a2 = Math.pow(r3, 3);
        return n4 = u1 > 0.008856 ? u1 : (n4 - 16 / 116) / 7.787, t3 = i2 > 0.008856 ? i2 : (t3 - 16 / 116) / 7.787, r3 = a2 > 0.008856 ? a2 : (r3 - 16 / 116) / 7.787, [
            t3 *= 95.047,
            n4 *= 100,
            r3 *= 108.883
        ];
    }, r2.lab.lch = function(e4) {
        var t3, n4 = e4[0], r3 = e4[1], o4 = e4[2];
        return (t3 = 360 * Math.atan2(o4, r3) / 2 / Math.PI) < 0 && (t3 += 360), [
            n4,
            Math.sqrt(r3 * r3 + o4 * o4),
            t3
        ];
    }, r2.lch.lab = function(e4) {
        var t3, n4 = e4[0], r3 = e4[1];
        return t3 = e4[2] / 360 * 2 * Math.PI, [
            n4,
            r3 * Math.cos(t3),
            r3 * Math.sin(t3)
        ];
    }, r2.rgb.ansi16 = function(e4) {
        var t3 = e4[0], n4 = e4[1], o4 = e4[2], u1 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e4)[2];
        if (0 === (u1 = Math.round(u1 / 50))) return 30;
        var i2 = 30 + (Math.round(o4 / 255) << 2 | Math.round(n4 / 255) << 1 | Math.round(t3 / 255));
        return 2 === u1 && (i2 += 60), i2;
    }, r2.hsv.ansi16 = function(e4) {
        return r2.rgb.ansi16(r2.hsv.rgb(e4), e4[2]);
    }, r2.rgb.ansi256 = function(e4) {
        var t3 = e4[0], n4 = e4[1], r3 = e4[2];
        return t3 === n4 && n4 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n4 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e4) {
        var t3 = e4 % 10;
        if (0 === t3 || 7 === t3) return e4 > 50 && (t3 += 3.5), [
            t3 = t3 / 10.5 * 255,
            t3,
            t3
        ];
        var n4 = 0.5 * (1 + ~~(e4 > 50));
        return [
            (1 & t3) * n4 * 255,
            (t3 >> 1 & 1) * n4 * 255,
            (t3 >> 2 & 1) * n4 * 255
        ];
    }, r2.ansi256.rgb = function(e4) {
        if (e4 >= 232) {
            var t3 = 10 * (e4 - 232) + 8;
            return [
                t3,
                t3,
                t3
            ];
        }
        var n4;
        return e4 -= 16, [
            Math.floor(e4 / 36) / 5 * 255,
            Math.floor((n4 = e4 % 36) / 6) / 5 * 255,
            n4 % 6 / 5 * 255
        ];
    }, r2.rgb.hex = function(e4) {
        var t3 = (((255 & Math.round(e4[0])) << 16) + ((255 & Math.round(e4[1])) << 8) + (255 & Math.round(e4[2]))).toString(16).toUpperCase();
        return "000000".substring(t3.length) + t3;
    }, r2.hex.rgb = function(e4) {
        var t3 = e4.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t3) return [
            0,
            0,
            0
        ];
        var n4 = t3[0];
        3 === t3[0].length && (n4 = n4.split("").map(function(e5) {
            return e5 + e5;
        }).join(""));
        var r3 = parseInt(n4, 16);
        return [
            r3 >> 16 & 255,
            r3 >> 8 & 255,
            255 & r3
        ];
    }, r2.rgb.hcg = function(e4) {
        var t3, n4 = e4[0] / 255, r3 = e4[1] / 255, o4 = e4[2] / 255, u1 = Math.max(Math.max(n4, r3), o4), i2 = Math.min(Math.min(n4, r3), o4), a2 = u1 - i2;
        return t3 = a2 <= 0 ? 0 : u1 === n4 ? (r3 - o4) / a2 % 6 : u1 === r3 ? 2 + (o4 - n4) / a2 : 4 + (n4 - r3) / a2 + 4, t3 /= 6, [
            360 * (t3 %= 1),
            100 * a2,
            100 * (a2 < 1 ? i2 / (1 - a2) : 0)
        ];
    }, r2.hsl.hcg = function(e4) {
        var t3 = e4[1] / 100, n4 = e4[2] / 100, r3 = 1, o4 = 0;
        return (r3 = n4 < 0.5 ? 2 * t3 * n4 : 2 * t3 * (1 - n4)) < 1 && (o4 = (n4 - 0.5 * r3) / (1 - r3)), [
            e4[0],
            100 * r3,
            100 * o4
        ];
    }, r2.hsv.hcg = function(e4) {
        var t3 = e4[1] / 100, n4 = e4[2] / 100, r3 = t3 * n4, o4 = 0;
        return r3 < 1 && (o4 = (n4 - r3) / (1 - r3)), [
            e4[0],
            100 * r3,
            100 * o4
        ];
    }, r2.hcg.rgb = function(e4) {
        var t3 = e4[0] / 360, n4 = e4[1] / 100, r3 = e4[2] / 100;
        if (0 === n4) return [
            255 * r3,
            255 * r3,
            255 * r3
        ];
        var o4, u1 = [
            0,
            0,
            0
        ], i2 = t3 % 1 * 6, a2 = i2 % 1, s2 = 1 - a2;
        switch(Math.floor(i2)){
            case 0:
                u1[0] = 1, u1[1] = a2, u1[2] = 0;
                break;
            case 1:
                u1[0] = s2, u1[1] = 1, u1[2] = 0;
                break;
            case 2:
                u1[0] = 0, u1[1] = 1, u1[2] = a2;
                break;
            case 3:
                u1[0] = 0, u1[1] = s2, u1[2] = 1;
                break;
            case 4:
                u1[0] = a2, u1[1] = 0, u1[2] = 1;
                break;
            default:
                u1[0] = 1, u1[1] = 0, u1[2] = s2;
        }
        return o4 = (1 - n4) * r3, [
            255 * (n4 * u1[0] + o4),
            255 * (n4 * u1[1] + o4),
            255 * (n4 * u1[2] + o4)
        ];
    }, r2.hcg.hsv = function(e4) {
        var t3 = e4[1] / 100, n4 = t3 + e4[2] / 100 * (1 - t3), r3 = 0;
        return n4 > 0 && (r3 = t3 / n4), [
            e4[0],
            100 * r3,
            100 * n4
        ];
    }, r2.hcg.hsl = function(e4) {
        var t3 = e4[1] / 100, n4 = e4[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
        return n4 > 0 && n4 < 0.5 ? r3 = t3 / (2 * n4) : n4 >= 0.5 && n4 < 1 && (r3 = t3 / (2 * (1 - n4))), [
            e4[0],
            100 * r3,
            100 * n4
        ];
    }, r2.hcg.hwb = function(e4) {
        var t3 = e4[1] / 100, n4 = t3 + e4[2] / 100 * (1 - t3);
        return [
            e4[0],
            100 * (n4 - t3),
            100 * (1 - n4)
        ];
    }, r2.hwb.hcg = function(e4) {
        var t3 = e4[1] / 100, n4 = 1 - e4[2] / 100, r3 = n4 - t3, o4 = 0;
        return r3 < 1 && (o4 = (n4 - r3) / (1 - r3)), [
            e4[0],
            100 * r3,
            100 * o4
        ];
    }, r2.apple.rgb = function(e4) {
        return [
            e4[0] / 65535 * 255,
            e4[1] / 65535 * 255,
            e4[2] / 65535 * 255
        ];
    }, r2.rgb.apple = function(e4) {
        return [
            e4[0] / 255 * 65535,
            e4[1] / 255 * 65535,
            e4[2] / 255 * 65535
        ];
    }, r2.gray.rgb = function(e4) {
        return [
            e4[0] / 100 * 255,
            e4[0] / 100 * 255,
            e4[0] / 100 * 255
        ];
    }, r2.gray.hsl = r2.gray.hsv = function(e4) {
        return [
            0,
            0,
            e4[0]
        ];
    }, r2.gray.hwb = function(e4) {
        return [
            0,
            100,
            e4[0]
        ];
    }, r2.gray.cmyk = function(e4) {
        return [
            0,
            0,
            0,
            e4[0]
        ];
    }, r2.gray.lab = function(e4) {
        return [
            e4[0],
            0,
            0
        ];
    }, r2.gray.hex = function(e4) {
        var t3 = 255 & Math.round(e4[0] / 100 * 255), n4 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
        return "000000".substring(n4.length) + n4;
    }, r2.rgb.gray = function(e4) {
        return [
            (e4[0] + e4[1] + e4[2]) / 3 / 255 * 100
        ];
    };
});
function Br(e2) {
    var t2 = function() {
        for(var e4 = {
        }, t2 = Object.keys(Tr), n2 = t2.length, r2 = 0; r2 < n2; r2++)e4[t2[r2]] = {
            distance: -1,
            parent: null
        };
        return e4;
    }(), n2 = [
        e2
    ];
    for(t2[e2].distance = 0; n2.length;)for(var r2 = n2.pop(), o3 = Object.keys(Tr[r2]), u1 = o3.length, i2 = 0; i2 < u1; i2++){
        var a2 = o3[i2], s2 = t2[a2];
        -1 === s2.distance && (s2.distance = t2[r2].distance + 1, s2.parent = r2, n2.unshift(a2));
    }
    return t2;
}
function Nr(e2, t2) {
    return function(n2) {
        return t2(e2(n2));
    };
}
function kr(e2, t2) {
    for(var n2 = [
        t2[e2].parent,
        e2
    ], r2 = Tr[t2[e2].parent][e2], o3 = t2[e2].parent; t2[o3].parent;)n2.unshift(t2[o3].parent), r2 = Nr(Tr[t2[o3].parent][o3], r2), o3 = t2[o3].parent;
    return r2.conversion = n2, r2;
}
var Pr = {
};
Object.keys(Tr).forEach(function(e2) {
    Pr[e2] = {
    }, Object.defineProperty(Pr[e2], "channels", {
        value: Tr[e2].channels
    }), Object.defineProperty(Pr[e2], "labels", {
        value: Tr[e2].labels
    });
    var t2 = function(e4) {
        for(var t2 = Br(e4), n2 = {
        }, r2 = Object.keys(t2), o3 = r2.length, u1 = 0; u1 < o3; u1++){
            var i2 = r2[u1];
            null !== t2[i2].parent && (n2[i2] = kr(i2, t2));
        }
        return n2;
    }(e2);
    Object.keys(t2).forEach(function(n2) {
        var r2 = t2[n2];
        Pr[e2][n2] = (function(e4) {
            var t3 = function(t4) {
                if (null == t4) return t4;
                arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
                var n4 = e4(t4);
                if ("object" == typeof n4) for(var r3 = n4.length, o3 = 0; o3 < r3; o3++)n4[o3] = Math.round(n4[o3]);
                return n4;
            };
            return "conversion" in e4 && (t3.conversion = e4.conversion), t3;
        })(r2), Pr[e2][n2].raw = (function(e4) {
            var t3 = function(t4) {
                return null == t4 ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e4(t4));
            };
            return "conversion" in e4 && (t3.conversion = e4.conversion), t3;
        })(r2);
    });
});
let _r;
const $r = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, qr = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Wr = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Ur = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Jr = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function zr(e2) {
    return "u" === e2[0] && 5 === e2.length || "x" === e2[0] && 3 === e2.length ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Jr.get(e2) || e2;
}
function Gr(e2, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let o3;
    for (const t3 of r2)if (isNaN(t3)) {
        if (!(o3 = t3.match(Wr))) throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e2, "')"));
        n2.push(o3[2].replace(Ur, (e4, t4, n4)=>t4 ? zr(t4) : n4
        ));
    } else n2.push(Number(t3));
    return n2;
}
function Hr(e2) {
    qr.lastIndex = 0;
    const t2 = [];
    let n2;
    for(; null !== (n2 = qr.exec(e2));){
        const e4 = n2[1];
        if (n2[2]) {
            const r2 = Gr(e4, n2[2]);
            t2.push([
                e4
            ].concat(r2));
        } else t2.push([
            e4
        ]);
    }
    return t2;
}
function Xr(e2, t2) {
    const n2 = {
    };
    for (const e4 of t2)for (const t3 of e4.styles)n2[t3[0]] = e4.inverse ? null : t3.slice(1);
    let r2 = e2;
    for (const e5 of Object.keys(n2))if (Array.isArray(n2[e5])) {
        if (!(e5 in r2)) throw new Error("Unknown Chalk style: ".concat(e5));
        r2 = n2[e5].length > 0 ? r2[e5].apply(r2, n2[e5]) : r2[e5];
    }
    return r2;
}
const vo = [], Ao = [], Fo = (e2, t2)=>{
    if (e2 === t2) return 0;
    const n2 = e2;
    e2.length > t2.length && (e2 = t2, t2 = e2);
    let r2 = e2.length, o3 = t2.length;
    for(; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-o3);)r2--, o3--;
    let u1, i2, a2, s2, l2 = 0;
    for(; l2 < r2 && e2.charCodeAt(l2) === t2.charCodeAt(l2);)l2++;
    if (r2 -= l2, o3 -= l2, 0 === r2) return o3;
    let c2 = 0, p2 = 0;
    for(; c2 < r2;)Ao[c2] = e2.charCodeAt(l2 + c2), vo[c2] = ++c2;
    for(; p2 < o3;)for(u1 = t2.charCodeAt(l2 + p2), a2 = p2++, i2 = p2, c2 = 0; c2 < r2; c2++)s2 = u1 === Ao[c2] ? a2 : a2 + 1, a2 = vo[c2], i2 = vo[c2] = a2 > i2 ? s2 > i2 ? i2 + 1 : s2 : s2 > a2 ? a2 + 1 : s2;
    return i2;
};
var xo = Fo, So = Fo;
xo.default = So;
var wo = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};
const To = {
};
for (const e2 of Object.keys(wo))To[wo[e2]] = e2;
const Bo = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    hex: {
        channels: 1,
        labels: [
            "hex"
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            "keyword"
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            "ansi16"
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            "ansi256"
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            "h",
            "c",
            "g"
        ]
    },
    apple: {
        channels: 3,
        labels: [
            "r16",
            "g16",
            "b16"
        ]
    },
    gray: {
        channels: 1,
        labels: [
            "gray"
        ]
    }
};
var No = Bo;
for (const e4 of Object.keys(Bo)){
    if (!("channels" in Bo[e4])) throw new Error("missing channels property: " + e4);
    if (!("labels" in Bo[e4])) throw new Error("missing channel labels property: " + e4);
    if (Bo[e4].labels.length !== Bo[e4].channels) throw new Error("channel and label counts mismatch: " + e4);
    const { channels: t2 , labels: n2  } = Bo[e4];
    delete Bo[e4].channels, delete Bo[e4].labels, Object.defineProperty(Bo[e4], "channels", {
        value: t2
    }), Object.defineProperty(Bo[e4], "labels", {
        value: n2
    });
}
function ko(e5) {
    const t2 = function() {
        const e6 = {
        }, t3 = Object.keys(No);
        for(let n2 = t3.length, r2 = 0; r2 < n2; r2++)e6[t3[r2]] = {
            distance: -1,
            parent: null
        };
        return e6;
    }(), n2 = [
        e5
    ];
    for(t2[e5].distance = 0; n2.length;){
        const e6 = n2.pop(), r2 = Object.keys(No[e6]);
        for(let o3 = r2.length, u1 = 0; u1 < o3; u1++){
            const o3 = r2[u1], i2 = t2[o3];
            -1 === i2.distance && (i2.distance = t2[e6].distance + 1, i2.parent = e6, n2.unshift(o3));
        }
    }
    return t2;
}
function Po(e5, t2) {
    return function(n2) {
        return t2(e5(n2));
    };
}
function Oo(e5, t2) {
    const n2 = [
        t2[e5].parent,
        e5
    ];
    let r2 = No[t2[e5].parent][e5], o3 = t2[e5].parent;
    for(; t2[o3].parent;)n2.unshift(t2[o3].parent), r2 = Po(No[t2[o3].parent][o3], r2), o3 = t2[o3].parent;
    return r2.conversion = n2, r2;
}
Bo.rgb.hsl = function(e5) {
    const t2 = e5[0] / 255, n2 = e5[1] / 255, r2 = e5[2] / 255, o3 = Math.min(t2, n2, r2), u1 = Math.max(t2, n2, r2), i2 = u1 - o3;
    let a2, s2;
    u1 === o3 ? a2 = 0 : t2 === u1 ? a2 = (n2 - r2) / i2 : n2 === u1 ? a2 = 2 + (r2 - t2) / i2 : r2 === u1 && (a2 = 4 + (t2 - n2) / i2), a2 = Math.min(60 * a2, 360), a2 < 0 && (a2 += 360);
    const l2 = (o3 + u1) / 2;
    return s2 = u1 === o3 ? 0 : l2 <= 0.5 ? i2 / (u1 + o3) : i2 / (2 - u1 - o3), [
        a2,
        100 * s2,
        100 * l2
    ];
}, Bo.rgb.hsv = function(e5) {
    let t2, n2, r2, o3, u1;
    const i2 = e5[0] / 255, a2 = e5[1] / 255, s2 = e5[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e6) {
        return (l2 - e6) / 6 / c2 + 0.5;
    };
    return 0 === c2 ? (o3 = 0, u1 = 0) : (u1 = c2 / l2, t2 = p2(i2), n2 = p2(a2), r2 = p2(s2), i2 === l2 ? o3 = r2 - n2 : a2 === l2 ? o3 = 1 / 3 + t2 - r2 : s2 === l2 && (o3 = 2 / 3 + n2 - t2), o3 < 0 ? o3 += 1 : o3 > 1 && (o3 -= 1)), [
        360 * o3,
        100 * u1,
        100 * l2
    ];
}, Bo.rgb.hwb = function(e5) {
    const t2 = e5[0], n2 = e5[1];
    let r2 = e5[2];
    const o3 = Bo.rgb.hsl(e5)[0], u1 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
    return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [
        o3,
        100 * u1,
        100 * r2
    ];
}, Bo.rgb.cmyk = function(e5) {
    const t2 = e5[0] / 255, n2 = e5[1] / 255, r2 = e5[2] / 255, o3 = Math.min(1 - t2, 1 - n2, 1 - r2);
    return [
        100 * ((1 - t2 - o3) / (1 - o3) || 0),
        100 * ((1 - n2 - o3) / (1 - o3) || 0),
        100 * ((1 - r2 - o3) / (1 - o3) || 0),
        100 * o3
    ];
}, Bo.rgb.keyword = function(e5) {
    const t2 = To[e5];
    if (t2) return t2;
    let n2, r2 = 1 / 0;
    for (const t3 of Object.keys(wo)){
        const i2 = (u2 = wo[t3], ((o3 = e5)[0] - u2[0]) ** 2 + (o3[1] - u2[1]) ** 2 + (o3[2] - u2[2]) ** 2);
        i2 < r2 && (r2 = i2, n2 = t3);
    }
    var o3, u2;
    return n2;
}, Bo.keyword.rgb = function(e5) {
    return wo[e5];
}, Bo.rgb.xyz = function(e5) {
    let t2 = e5[0] / 255, n2 = e5[1] / 255, r2 = e5[2] / 255;
    t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
    return [
        100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2),
        100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2),
        100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)
    ];
}, Bo.rgb.lab = function(e5) {
    const t2 = Bo.rgb.xyz(e5);
    let n2 = t2[0], r2 = t2[1], o3 = t2[2];
    n2 /= 95.047, r2 /= 100, o3 /= 108.883, n2 = n2 > 0.008856 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 0.008856 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, o3 = o3 > 0.008856 ? o3 ** (1 / 3) : 7.787 * o3 + 16 / 116;
    return [
        116 * r2 - 16,
        500 * (n2 - r2),
        200 * (r2 - o3)
    ];
}, Bo.hsl.rgb = function(e5) {
    const t2 = e5[0] / 360, n2 = e5[1] / 100, r2 = e5[2] / 100;
    let o3, u2, i2;
    if (0 === n2) return i2 = 255 * r2, [
        i2,
        i2,
        i2
    ];
    o3 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
    const a2 = 2 * r2 - o3, s2 = [
        0,
        0,
        0
    ];
    for(let e6 = 0; e6 < 3; e6++)u2 = t2 + 1 / 3 * -(e6 - 1), u2 < 0 && u2++, u2 > 1 && u2--, i2 = 6 * u2 < 1 ? a2 + 6 * (o3 - a2) * u2 : 2 * u2 < 1 ? o3 : 3 * u2 < 2 ? a2 + (o3 - a2) * (2 / 3 - u2) * 6 : a2, s2[e6] = 255 * i2;
    return s2;
}, Bo.hsl.hsv = function(e5) {
    const t2 = e5[0];
    let n2 = e5[1] / 100, r2 = e5[2] / 100, o3 = n2;
    const u2 = Math.max(r2, 0.01);
    r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, o3 *= u2 <= 1 ? u2 : 2 - u2;
    return [
        t2,
        100 * (0 === r2 ? 2 * o3 / (u2 + o3) : 2 * n2 / (r2 + n2)),
        100 * ((r2 + n2) / 2)
    ];
}, Bo.hsv.rgb = function(e5) {
    const t2 = e5[0] / 60, n2 = e5[1] / 100;
    let r2 = e5[2] / 100;
    const o3 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), i2 = 255 * r2 * (1 - n2), a2 = 255 * r2 * (1 - n2 * u2), s2 = 255 * r2 * (1 - n2 * (1 - u2));
    switch(r2 *= 255, o3){
        case 0:
            return [
                r2,
                s2,
                i2
            ];
        case 1:
            return [
                a2,
                r2,
                i2
            ];
        case 2:
            return [
                i2,
                r2,
                s2
            ];
        case 3:
            return [
                i2,
                a2,
                r2
            ];
        case 4:
            return [
                s2,
                i2,
                r2
            ];
        case 5:
            return [
                r2,
                i2,
                a2
            ];
    }
}, Bo.hsv.hsl = function(e5) {
    const t2 = e5[0], n2 = e5[1] / 100, r2 = e5[2] / 100, o3 = Math.max(r2, 0.01);
    let u2, i2;
    i2 = (2 - n2) * r2;
    const a2 = (2 - n2) * o3;
    return u2 = n2 * o3, u2 /= a2 <= 1 ? a2 : 2 - a2, u2 = u2 || 0, i2 /= 2, [
        t2,
        100 * u2,
        100 * i2
    ];
}, Bo.hwb.rgb = function(e5) {
    const t2 = e5[0] / 360;
    let n2 = e5[1] / 100, r2 = e5[2] / 100;
    const o3 = n2 + r2;
    let u2;
    o3 > 1 && (n2 /= o3, r2 /= o3);
    const i2 = Math.floor(6 * t2), a2 = 1 - r2;
    u2 = 6 * t2 - i2, 0 != (1 & i2) && (u2 = 1 - u2);
    const s2 = n2 + u2 * (a2 - n2);
    let l2, c2, p2;
    switch(i2){
        default:
        case 6:
        case 0:
            l2 = a2, c2 = s2, p2 = n2;
            break;
        case 1:
            l2 = s2, c2 = a2, p2 = n2;
            break;
        case 2:
            l2 = n2, c2 = a2, p2 = s2;
            break;
        case 3:
            l2 = n2, c2 = s2, p2 = a2;
            break;
        case 4:
            l2 = s2, c2 = n2, p2 = a2;
            break;
        case 5:
            l2 = a2, c2 = n2, p2 = s2;
    }
    return [
        255 * l2,
        255 * c2,
        255 * p2
    ];
}, Bo.cmyk.rgb = function(e5) {
    const t2 = e5[0] / 100, n2 = e5[1] / 100, r2 = e5[2] / 100, o3 = e5[3] / 100;
    return [
        255 * (1 - Math.min(1, t2 * (1 - o3) + o3)),
        255 * (1 - Math.min(1, n2 * (1 - o3) + o3)),
        255 * (1 - Math.min(1, r2 * (1 - o3) + o3))
    ];
}, Bo.xyz.rgb = function(e5) {
    const t2 = e5[0] / 100, n2 = e5[1] / 100, r2 = e5[2] / 100;
    let o3, u2, i2;
    return o3 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, i2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, o3 = o3 > 0.0031308 ? 1.055 * o3 ** (1 / 2.4) - 0.055 : 12.92 * o3, u2 = u2 > 0.0031308 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, i2 = i2 > 0.0031308 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, o3 = Math.min(Math.max(0, o3), 1), u2 = Math.min(Math.max(0, u2), 1), i2 = Math.min(Math.max(0, i2), 1), [
        255 * o3,
        255 * u2,
        255 * i2
    ];
}, Bo.xyz.lab = function(e5) {
    let t2 = e5[0], n2 = e5[1], r2 = e5[2];
    t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 0.008856 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 0.008856 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 0.008856 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
    return [
        116 * n2 - 16,
        500 * (t2 - n2),
        200 * (n2 - r2)
    ];
}, Bo.lab.xyz = function(e5) {
    let t2, n2, r2;
    n2 = (e5[0] + 16) / 116, t2 = e5[1] / 500 + n2, r2 = n2 - e5[2] / 200;
    const o3 = n2 ** 3, u2 = t2 ** 3, i2 = r2 ** 3;
    return n2 = o3 > 0.008856 ? o3 : (n2 - 16 / 116) / 7.787, t2 = u2 > 0.008856 ? u2 : (t2 - 16 / 116) / 7.787, r2 = i2 > 0.008856 ? i2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [
        t2,
        n2,
        r2
    ];
}, Bo.lab.lch = function(e5) {
    const t2 = e5[0], n2 = e5[1], r2 = e5[2];
    let o3;
    o3 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, o3 < 0 && (o3 += 360);
    return [
        t2,
        Math.sqrt(n2 * n2 + r2 * r2),
        o3
    ];
}, Bo.lch.lab = function(e5) {
    const t2 = e5[0], n2 = e5[1], r2 = e5[2] / 360 * 2 * Math.PI;
    return [
        t2,
        n2 * Math.cos(r2),
        n2 * Math.sin(r2)
    ];
}, Bo.rgb.ansi16 = function(e5, t2 = null) {
    const [n2, r2, o3] = e5;
    let u2 = null === t2 ? Bo.rgb.hsv(e5)[2] : t2;
    if (u2 = Math.round(u2 / 50), 0 === u2) return 30;
    let i2 = 30 + (Math.round(o3 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
    return 2 === u2 && (i2 += 60), i2;
}, Bo.hsv.ansi16 = function(e5) {
    return Bo.rgb.ansi16(Bo.hsv.rgb(e5), e5[2]);
}, Bo.rgb.ansi256 = function(e5) {
    const t2 = e5[0], n2 = e5[1], r2 = e5[2];
    if (t2 === n2 && n2 === r2) return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
    return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
}, Bo.ansi16.rgb = function(e5) {
    let t2 = e5 % 10;
    if (0 === t2 || 7 === t2) return e5 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [
        t2,
        t2,
        t2
    ];
    const n2 = 0.5 * (1 + ~~(e5 > 50));
    return [
        (1 & t2) * n2 * 255,
        (t2 >> 1 & 1) * n2 * 255,
        (t2 >> 2 & 1) * n2 * 255
    ];
}, Bo.ansi256.rgb = function(e5) {
    if (e5 >= 232) {
        const t2 = 10 * (e5 - 232) + 8;
        return [
            t2,
            t2,
            t2
        ];
    }
    let t2;
    e5 -= 16;
    return [
        Math.floor(e5 / 36) / 5 * 255,
        Math.floor((t2 = e5 % 36) / 6) / 5 * 255,
        t2 % 6 / 5 * 255
    ];
}, Bo.rgb.hex = function(e5) {
    const t2 = (((255 & Math.round(e5[0])) << 16) + ((255 & Math.round(e5[1])) << 8) + (255 & Math.round(e5[2]))).toString(16).toUpperCase();
    return "000000".substring(t2.length) + t2;
}, Bo.hex.rgb = function(e5) {
    const t2 = e5.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t2) return [
        0,
        0,
        0
    ];
    let n2 = t2[0];
    3 === t2[0].length && (n2 = n2.split("").map((e6)=>e6 + e6
    ).join(""));
    const r2 = parseInt(n2, 16);
    return [
        r2 >> 16 & 255,
        r2 >> 8 & 255,
        255 & r2
    ];
}, Bo.rgb.hcg = function(e5) {
    const t2 = e5[0] / 255, n2 = e5[1] / 255, r2 = e5[2] / 255, o3 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), i2 = o3 - u2;
    let a2, s2;
    return a2 = i2 < 1 ? u2 / (1 - i2) : 0, s2 = i2 <= 0 ? 0 : o3 === t2 ? (n2 - r2) / i2 % 6 : o3 === n2 ? 2 + (r2 - t2) / i2 : 4 + (t2 - n2) / i2, s2 /= 6, s2 %= 1, [
        360 * s2,
        100 * i2,
        100 * a2
    ];
}, Bo.hsl.hcg = function(e5) {
    const t2 = e5[1] / 100, n2 = e5[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
    let o3 = 0;
    return r2 < 1 && (o3 = (n2 - 0.5 * r2) / (1 - r2)), [
        e5[0],
        100 * r2,
        100 * o3
    ];
}, Bo.hsv.hcg = function(e5) {
    const t2 = e5[1] / 100, n2 = e5[2] / 100, r2 = t2 * n2;
    let o3 = 0;
    return r2 < 1 && (o3 = (n2 - r2) / (1 - r2)), [
        e5[0],
        100 * r2,
        100 * o3
    ];
}, Bo.hcg.rgb = function(e5) {
    const t2 = e5[0] / 360, n2 = e5[1] / 100, r2 = e5[2] / 100;
    if (0 === n2) return [
        255 * r2,
        255 * r2,
        255 * r2
    ];
    const o3 = [
        0,
        0,
        0
    ], u2 = t2 % 1 * 6, i2 = u2 % 1, a2 = 1 - i2;
    let s2 = 0;
    switch(Math.floor(u2)){
        case 0:
            o3[0] = 1, o3[1] = i2, o3[2] = 0;
            break;
        case 1:
            o3[0] = a2, o3[1] = 1, o3[2] = 0;
            break;
        case 2:
            o3[0] = 0, o3[1] = 1, o3[2] = i2;
            break;
        case 3:
            o3[0] = 0, o3[1] = a2, o3[2] = 1;
            break;
        case 4:
            o3[0] = i2, o3[1] = 0, o3[2] = 1;
            break;
        default:
            o3[0] = 1, o3[1] = 0, o3[2] = a2;
    }
    return s2 = (1 - n2) * r2, [
        255 * (n2 * o3[0] + s2),
        255 * (n2 * o3[1] + s2),
        255 * (n2 * o3[2] + s2)
    ];
}, Bo.hcg.hsv = function(e5) {
    const t2 = e5[1] / 100, n2 = t2 + e5[2] / 100 * (1 - t2);
    let r2 = 0;
    return n2 > 0 && (r2 = t2 / n2), [
        e5[0],
        100 * r2,
        100 * n2
    ];
}, Bo.hcg.hsl = function(e5) {
    const t2 = e5[1] / 100, n2 = e5[2] / 100 * (1 - t2) + 0.5 * t2;
    let r2 = 0;
    return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [
        e5[0],
        100 * r2,
        100 * n2
    ];
}, Bo.hcg.hwb = function(e5) {
    const t2 = e5[1] / 100, n2 = t2 + e5[2] / 100 * (1 - t2);
    return [
        e5[0],
        100 * (n2 - t2),
        100 * (1 - n2)
    ];
}, Bo.hwb.hcg = function(e5) {
    const t2 = e5[1] / 100, n2 = 1 - e5[2] / 100, r2 = n2 - t2;
    let o3 = 0;
    return r2 < 1 && (o3 = (n2 - r2) / (1 - r2)), [
        e5[0],
        100 * r2,
        100 * o3
    ];
}, Bo.apple.rgb = function(e5) {
    return [
        e5[0] / 65535 * 255,
        e5[1] / 65535 * 255,
        e5[2] / 65535 * 255
    ];
}, Bo.rgb.apple = function(e5) {
    return [
        e5[0] / 255 * 65535,
        e5[1] / 255 * 65535,
        e5[2] / 255 * 65535
    ];
}, Bo.gray.rgb = function(e5) {
    return [
        e5[0] / 100 * 255,
        e5[0] / 100 * 255,
        e5[0] / 100 * 255
    ];
}, Bo.gray.hsl = function(e5) {
    return [
        0,
        0,
        e5[0]
    ];
}, Bo.gray.hsv = Bo.gray.hsl, Bo.gray.hwb = function(e5) {
    return [
        0,
        100,
        e5[0]
    ];
}, Bo.gray.cmyk = function(e5) {
    return [
        0,
        0,
        0,
        e5[0]
    ];
}, Bo.gray.lab = function(e5) {
    return [
        e5[0],
        0,
        0
    ];
}, Bo.gray.hex = function(e5) {
    const t2 = 255 & Math.round(e5[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
    return "000000".substring(n2.length) + n2;
}, Bo.rgb.gray = function(e5) {
    return [
        (e5[0] + e5[1] + e5[2]) / 3 / 255 * 100
    ];
};
const Io = {
};
Object.keys(No).forEach((e5)=>{
    Io[e5] = {
    }, Object.defineProperty(Io[e5], "channels", {
        value: No[e5].channels
    }), Object.defineProperty(Io[e5], "labels", {
        value: No[e5].labels
    });
    const t2 = function(e6) {
        const t3 = ko(e6), n2 = {
        }, r2 = Object.keys(t3);
        for(let e7 = r2.length, o3 = 0; o3 < e7; o3++){
            const e7 = r2[o3];
            null !== t3[e7].parent && (n2[e7] = Oo(e7, t3));
        }
        return n2;
    }(e5);
    Object.keys(t2).forEach((n2)=>{
        const r2 = t2[n2];
        Io[e5][n2] = (function(e6) {
            const t3 = function(...t4) {
                const n4 = t4[0];
                if (null == n4) return n4;
                n4.length > 1 && (t4 = n4);
                const r3 = e6(t4);
                if ("object" == typeof r3) for(let e7 = r3.length, t5 = 0; t5 < e7; t5++)r3[t5] = Math.round(r3[t5]);
                return r3;
            };
            return "conversion" in e6 && (t3.conversion = e6.conversion), t3;
        })(r2), Io[e5][n2].raw = (function(e6) {
            const t3 = function(...t4) {
                const n4 = t4[0];
                return null == n4 ? n4 : (n4.length > 1 && (t4 = n4), e6(t4));
            };
            return "conversion" in e6 && (t3.conversion = e6.conversion), t3;
        })(r2);
    });
});
var Lo = Io, Mo = je(function(e5) {
    const t2 = (e6, t3)=>(...n2)=>{
            const r2 = e6(...n2);
            return "\x1b[".concat(r2 + t3, "m");
        }
    , n2 = (e6, t3)=>(...n4)=>{
            const r2 = e6(...n4);
            return "\x1b[".concat(38 + t3, ";5;").concat(r2, "m");
        }
    , r2 = (e6, t3)=>(...n4)=>{
            const r3 = e6(...n4);
            return "\x1b[".concat(38 + t3, ";2;").concat(r3[0], ";").concat(r3[1], ";").concat(r3[2], "m");
        }
    , o3 = (e6)=>e6
    , u2 = (e6, t3, n4)=>[
            e6,
            t3,
            n4
        ]
    , i2 = (e6, t3, n4)=>{
        Object.defineProperty(e6, t3, {
            get: ()=>{
                const r3 = n4();
                return Object.defineProperty(e6, t3, {
                    value: r3,
                    enumerable: !0,
                    configurable: !0
                }), r3;
            },
            enumerable: !0,
            configurable: !0
        });
    };
    let a2;
    const s2 = (e6, t3, n4, r3)=>{
        (void 0) === a2 && (a2 = Lo);
        const o4 = r3 ? 10 : 0, u3 = {
        };
        for (const [r4, i3] of Object.entries(a2)){
            const a3 = "ansi16" === r4 ? "ansi" : r4;
            r4 === t3 ? u3[a3] = e6(n4, o4) : "object" == typeof i3 && (u3[a3] = e6(i3[t3], o4));
        }
        return u3;
    };
    Object.defineProperty(e5, "exports", {
        enumerable: !0,
        get: function() {
            const e6 = new Map, a3 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            a3.color.gray = a3.color.blackBright, a3.bgColor.bgGray = a3.bgColor.bgBlackBright, a3.color.grey = a3.color.blackBright, a3.bgColor.bgGrey = a3.bgColor.bgBlackBright;
            for (const [t3, n4] of Object.entries(a3)){
                for (const [t4, r3] of Object.entries(n4))a3[t4] = {
                    open: "\x1b[".concat(r3[0], "m"),
                    close: "\x1b[".concat(r3[1], "m")
                }, n4[t4] = a3[t4], e6.set(r3[0], r3[1]);
                Object.defineProperty(a3, t3, {
                    value: n4,
                    enumerable: !1
                });
            }
            return (Object.defineProperty(a3, "codes", {
                value: e6,
                enumerable: !1
            }), a3.color.close = "\x1b[39m", a3.bgColor.close = "\x1b[49m", i2(a3.color, "ansi", ()=>s2(t2, "ansi16", o3, !1)
            ), i2(a3.color, "ansi256", ()=>s2(n2, "ansi256", o3, !1)
            ), i2(a3.color, "ansi16m", ()=>s2(r2, "rgb", u2, !1)
            ), i2(a3.bgColor, "ansi", ()=>s2(t2, "ansi16", o3, !0)
            ), i2(a3.bgColor, "ansi256", ()=>s2(n2, "ansi256", o3, !0)
            ), i2(a3.bgColor, "ansi16m", ()=>s2(r2, "rgb", u2, !0)
            ), a3);
        }
    });
}), jo = {
    isatty: ()=>!1
}, _o = (e5, t2 = Oe2.argv)=>{
    const n2 = e5.startsWith("-") ? "" : 1 === e5.length ? "-" : "--", r2 = t2.indexOf(n2 + e5), o3 = t2.indexOf("--");
    return -1 !== r2 && (-1 === o3 || r2 < o3);
}, Ro = _e(Object.freeze({
    __proto__: null,
    default: jo
}));
let $o;
function qo(e5) {
    return 0 !== e5 && {
        level: e5,
        hasBasic: !0,
        has256: e5 >= 2,
        has16m: e5 >= 3
    };
}
var Jo = {
    stringReplaceAll: (e5, t2, n2)=>{
        let r2 = e5.indexOf(t2);
        if (-1 === r2) return e5;
        const o3 = t2.length;
        let u2 = 0, i2 = "";
        do {
            i2 += e5.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + o3, r2 = e5.indexOf(t2, u2);
        }while (-1 !== r2)
        return i2 += e5.substr(u2), i2;
    },
    stringEncaseCRLFWithFirstIndex: (e5, t2, n2, r2)=>{
        let o3 = 0, u2 = "";
        do {
            const i2 = "\r" === e5[r2 - 1];
            u2 += e5.substr(o3, (i2 ? r2 - 1 : r2) - o3) + t2 + (i2 ? "\r\n" : "\n") + n2, o3 = r2 + 1, r2 = e5.indexOf("\n", o3);
        }while (-1 !== r2)
        return u2 += e5.substr(o3), u2;
    }
};
const zo = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Go = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Ho = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Xo = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, Yo = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function Ko(e5) {
    const t2 = "u" === e5[0], n2 = "{" === e5[1];
    return t2 && !n2 && 5 === e5.length || "x" === e5[0] && 3 === e5.length ? String.fromCharCode(parseInt(e5.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e5.slice(2, -1), 16)) : Yo.get(e5) || e5;
}
function Qo(e5, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let o3;
    for (const t3 of r2){
        const r3 = Number(t3);
        if (Number.isNaN(r3)) {
            if (!(o3 = t3.match(Ho))) throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e5, "')"));
            n2.push(o3[2].replace(Xo, (e6, t4, n4)=>t4 ? Ko(t4) : n4
            ));
        } else n2.push(r3);
    }
    return n2;
}
function Zo(e5) {
    Go.lastIndex = 0;
    const t2 = [];
    let n2;
    for(; null !== (n2 = Go.exec(e5));){
        const e6 = n2[1];
        if (n2[2]) {
            const r2 = Qo(e6, n2[2]);
            t2.push([
                e6
            ].concat(r2));
        } else t2.push([
            e6
        ]);
    }
    return t2;
}
function eu(e5, t2) {
    const n2 = {
    };
    for (const e6 of t2)for (const t3 of e6.styles)n2[t3[0]] = e6.inverse ? null : t3.slice(1);
    let r2 = e5;
    for (const [e7, t4] of Object.entries(n2))if (Array.isArray(t4)) {
        if (!(e7 in r2)) throw new Error("Unknown Chalk style: ".concat(e7));
        r2 = t4.length > 0 ? r2[e7](...t4) : r2[e7];
    }
    return r2;
}
var tu = (e5, t2)=>{
    const n2 = [], r2 = [];
    let o3 = [];
    if (t2.replace(zo, (t3, u2, i2, a2, s2, l2)=>{
        if (u2) o3.push(Ko(u2));
        else if (a2) {
            const t4 = o3.join("");
            o3 = [], r2.push(0 === n2.length ? t4 : eu(e5, n2)(t4)), n2.push({
                inverse: i2,
                styles: Zo(a2)
            });
        } else if (s2) {
            if (0 === n2.length) throw new Error("Found extraneous } in Chalk template literal");
            r2.push(eu(e5, n2)(o3.join(""))), o3 = [], n2.pop();
        } else o3.push(l2);
    }), r2.push(o3.join("")), n2.length > 0) {
        const e6 = "Chalk template literal is missing ".concat(n2.length, " closing bracket").concat(1 === n2.length ? "" : "s", " (`}`)");
        throw new Error(e6);
    }
    return r2.join("");
};
const du = [
    "rgb",
    "hex",
    "keyword",
    "hsl",
    "hsv",
    "hwb",
    "ansi",
    "ansi256"
];
let Du;
var bu = function(e5, t2) {
    for(var n2 = -1, r2 = t2.length, o3 = e5.length; (++n2) < r2;)e5[o3 + n2] = t2[n2];
    return e5;
}, vu = "object" == typeof Me && Me && Me.Object === Object && Me, Au = "object" == typeof self && self && self.Object === Object && self, Fu = (vu || Au || Function("return this")()).Symbol, xu = Object.prototype, Su = xu.hasOwnProperty, wu = xu.toString, Tu = Fu ? Fu.toStringTag : void 0;
var Bu = function(e5) {
    var t2 = Su.call(e5, Tu), n2 = e5[Tu];
    try {
        e5[Tu] = void 0;
        var r2 = !0;
    } catch (e) {
    }
    var o3 = wu.call(e5);
    return (r2 && (t2 ? e5[Tu] = n2 : delete e5[Tu]), o3);
}, Nu = Object.prototype.toString;
var ku = function(e5) {
    return Nu.call(e5);
}, Pu = Fu ? Fu.toStringTag : void 0;
var Ou = function(e5) {
    return null == e5 ? (void 0) === e5 ? "[object Undefined]" : "[object Null]" : Pu && Pu in Object(e5) ? Bu(e5) : ku(e5);
};
var Iu = function(e5) {
    return null != e5 && "object" == typeof e5;
};
var Lu = function(e5) {
    return Iu(e5) && "[object Arguments]" == Ou(e5);
}, Mu = Object.prototype, ju = Mu.hasOwnProperty, _u = Mu.propertyIsEnumerable, Ru = Lu(function() {
    return arguments;
}()) ? Lu : function(e5) {
    return Iu(e5) && ju.call(e5, "callee") && !_u.call(e5, "callee");
}, Vu = Array.isArray, $u = Fu ? Fu.isConcatSpreadable : void 0;
var qu = function(e5) {
    return Vu(e5) || Ru(e5) || !!($u && e5 && e5[$u]);
};
var Wu = function e1(t2, n2, r2, o3, u2) {
    var i2 = -1, a2 = t2.length;
    for((r2 || (r2 = qu), u2 || (u2 = [])); (++i2) < a2;){
        var s2 = t2[i2];
        n2 > 0 && r2(s2) ? n2 > 1 ? e1(s2, n2 - 1, r2, o3, u2) : bu(u2, s2) : o3 || (u2[u2.length] = s2);
    }
    return u2;
};
var Uu = function(e5) {
    return (null == e5 ? 0 : e5.length) ? Wu(e5, 1) : [];
};
let Gu;
function Ku(e5, t2) {
    const { ignoreDecorators: n2  } = t2 || {
    };
    if (!n2) {
        const t3 = e5.declaration && e5.declaration.decorators || e5.decorators;
        if (t3 && t3.length > 0) return Ku(t3[0]);
    }
    return e5.range ? e5.range[0] : e5.start;
}
function Qu(e5) {
    const t2 = e5.range ? e5.range[1] : e5.end;
    return e5.typeAnnotation ? Math.max(t2, Qu(e5.typeAnnotation)) : t2;
}
function Zu(e5, t2) {
    return Ku(e5) === Ku(t2);
}
var ei = {
    locStart: Ku,
    locEnd: Qu,
    composeLoc: function(e5, t2 = e5) {
        const n2 = Ku(e5);
        return [
            n2,
            "number" == typeof t2 ? n2 + t2 : Qu(t2)
        ];
    },
    hasSameLocStart: Zu,
    hasSameLoc: function(e5, t2) {
        return Zu(e5, t2) && function(e6, t3) {
            return Qu(e6) === Qu(t3);
        }(e5, t2);
    }
}, ti = je(function(e5, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), t2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t2.matchToToken = function(e6) {
        var t3 = {
            type: "invalid",
            value: e6[0],
            closed: void 0
        };
        return e6[1] ? (t3.type = "string", t3.closed = !(!e6[3] && !e6[4])) : e6[5] ? t3.type = "comment" : e6[6] ? (t3.type = "comment", t3.closed = !!e6[7]) : e6[8] ? t3.type = "regex" : e6[9] ? t3.type = "number" : e6[10] ? t3.type = "name" : e6[11] ? t3.type = "punctuator" : e6[12] && (t3.type = "whitespace"), t3;
    };
}), ni = je(function(e5, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), t2.isIdentifierStart = l2, t2.isIdentifierChar = c2, t2.isIdentifierName = function(e6) {
        let t3 = !0;
        for(let n2 = 0, r2 = Array.from(e6); n2 < r2.length; n2++){
            const e7 = r2[n2].codePointAt(0);
            if (t3) {
                if (!l2(e7)) return !1;
                t3 = !1;
            } else if (!c2(e7)) return !1;
        }
        return !t3;
    };
    let n2 = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc", r2 = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    const o3 = new RegExp("[" + n2 + "]"), u2 = new RegExp("[" + n2 + r2 + "]");
    n2 = r2 = null;
    const i2 = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ], a2 = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    function s2(e6, t3) {
        let n4 = 65536;
        for(let r3 = 0, o4 = t3.length; r3 < o4; r3 += 2){
            if ((n4 += t3[r3], n4 > e6)) return !1;
            if ((n4 += t3[r3 + 1], n4 >= e6)) return !0;
        }
        return !1;
    }
    function l2(e6) {
        return e6 < 65 ? 36 === e6 : e6 <= 90 || (e6 < 97 ? 95 === e6 : e6 <= 122 || (e6 <= 65535 ? e6 >= 170 && o3.test(String.fromCharCode(e6)) : s2(e6, i2)));
    }
    function c2(e6) {
        return e6 < 48 ? 36 === e6 : e6 < 58 || !(e6 < 65) && (e6 <= 90 || (e6 < 97 ? 95 === e6 : e6 <= 122 || (e6 <= 65535 ? e6 >= 170 && u2.test(String.fromCharCode(e6)) : s2(e6, i2) || s2(e6, a2))));
    }
}), ri = je(function(e5, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), t2.isReservedWord = a2, t2.isStrictReservedWord = s2, t2.isStrictBindOnlyReservedWord = l2, t2.isStrictBindReservedWord = function(e6, t3) {
        return s2(e6, t3) || l2(e6);
    }, t2.isKeyword = function(e6) {
        return o3.has(e6);
    };
    const n2 = [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ], r2 = [
        "eval",
        "arguments"
    ], o3 = new Set([
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ]), u2 = new Set(n2), i2 = new Set(r2);
    function a2(e6, t3) {
        return t3 && "await" === e6 || "enum" === e6;
    }
    function s2(e6, t3) {
        return a2(e6, t3) || u2.has(e6);
    }
    function l2(e6) {
        return i2.has(e6);
    }
}), oi = je(function(e5, t2) {
    Object.defineProperty(t2, "__esModule", {
        value: !0
    }), Object.defineProperty(t2, "isIdentifierName", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierName;
        }
    }), Object.defineProperty(t2, "isIdentifierChar", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierChar;
        }
    }), Object.defineProperty(t2, "isIdentifierStart", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierStart;
        }
    }), Object.defineProperty(t2, "isReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isReservedWord;
        }
    }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictBindOnlyReservedWord;
        }
    }), Object.defineProperty(t2, "isStrictBindReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictBindReservedWord;
        }
    }), Object.defineProperty(t2, "isStrictReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictReservedWord;
        }
    }), Object.defineProperty(t2, "isKeyword", {
        enumerable: !0,
        get: function() {
            return ri.isKeyword;
        }
    });
}), ui = /[|\\{}()[\]^$+*?.]/g, ii = function(e5) {
    if ("string" != typeof e5) throw new TypeError("Expected a string");
    return e5.replace(ui, "\\$&");
}, ai = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, si = je(function(e5) {
    var t2 = {
    };
    for(var n2 in ai)ai.hasOwnProperty(n2) && (t2[ai[n2]] = n2);
    var r2 = e5.exports = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    for(var o3 in r2)if (r2.hasOwnProperty(o3)) {
        if (!("channels" in r2[o3])) throw new Error("missing channels property: " + o3);
        if (!("labels" in r2[o3])) throw new Error("missing channel labels property: " + o3);
        if (r2[o3].labels.length !== r2[o3].channels) throw new Error("channel and label counts mismatch: " + o3);
        var u2 = r2[o3].channels, i2 = r2[o3].labels;
        delete r2[o3].channels, delete r2[o3].labels, Object.defineProperty(r2[o3], "channels", {
            value: u2
        }), Object.defineProperty(r2[o3], "labels", {
            value: i2
        });
    }
    r2.rgb.hsl = function(e6) {
        var t3, n4, r3 = e6[0] / 255, o4 = e6[1] / 255, u2 = e6[2] / 255, i2 = Math.min(r3, o4, u2), a2 = Math.max(r3, o4, u2), s2 = a2 - i2;
        return a2 === i2 ? t3 = 0 : r3 === a2 ? t3 = (o4 - u2) / s2 : o4 === a2 ? t3 = 2 + (u2 - r3) / s2 : u2 === a2 && (t3 = 4 + (r3 - o4) / s2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n4 = (i2 + a2) / 2, [
            t3,
            100 * (a2 === i2 ? 0 : n4 <= 0.5 ? s2 / (a2 + i2) : s2 / (2 - a2 - i2)),
            100 * n4
        ];
    }, r2.rgb.hsv = function(e6) {
        var t3, n4, r3, o4, u2, i2 = e6[0] / 255, a2 = e6[1] / 255, s2 = e6[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e7) {
            return (l2 - e7) / 6 / c2 + 0.5;
        };
        return 0 === c2 ? o4 = u2 = 0 : (u2 = c2 / l2, t3 = p2(i2), n4 = p2(a2), r3 = p2(s2), i2 === l2 ? o4 = r3 - n4 : a2 === l2 ? o4 = 1 / 3 + t3 - r3 : s2 === l2 && (o4 = 2 / 3 + n4 - t3), o4 < 0 ? o4 += 1 : o4 > 1 && (o4 -= 1)), [
            360 * o4,
            100 * u2,
            100 * l2
        ];
    }, r2.rgb.hwb = function(e6) {
        var t3 = e6[0], n4 = e6[1], o4 = e6[2];
        return [
            r2.rgb.hsl(e6)[0],
            100 * (1 / 255 * Math.min(t3, Math.min(n4, o4))),
            100 * (o4 = 1 - 1 / 255 * Math.max(t3, Math.max(n4, o4)))
        ];
    }, r2.rgb.cmyk = function(e6) {
        var t3, n4 = e6[0] / 255, r3 = e6[1] / 255, o4 = e6[2] / 255;
        return [
            100 * ((1 - n4 - (t3 = Math.min(1 - n4, 1 - r3, 1 - o4))) / (1 - t3) || 0),
            100 * ((1 - r3 - t3) / (1 - t3) || 0),
            100 * ((1 - o4 - t3) / (1 - t3) || 0),
            100 * t3
        ];
    }, r2.rgb.keyword = function(e6) {
        var n4 = t2[e6];
        if (n4) return n4;
        var r3, o4, u2, i2 = 1 / 0;
        for(var a2 in ai)if (ai.hasOwnProperty(a2)) {
            var s2 = ai[a2], l2 = (o4 = e6, u2 = s2, Math.pow(o4[0] - u2[0], 2) + Math.pow(o4[1] - u2[1], 2) + Math.pow(o4[2] - u2[2], 2));
            l2 < i2 && (i2 = l2, r3 = a2);
        }
        return r3;
    }, r2.keyword.rgb = function(e6) {
        return ai[e6];
    }, r2.rgb.xyz = function(e6) {
        var t3 = e6[0] / 255, n4 = e6[1] / 255, r3 = e6[2] / 255;
        return [
            100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n4 = n4 > 0.04045 ? Math.pow((n4 + 0.055) / 1.055, 2.4) : n4 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)),
            100 * (0.2126 * t3 + 0.7152 * n4 + 0.0722 * r3),
            100 * (0.0193 * t3 + 0.1192 * n4 + 0.9505 * r3)
        ];
    }, r2.rgb.lab = function(e6) {
        var t3 = r2.rgb.xyz(e6), n4 = t3[0], o4 = t3[1], u2 = t3[2];
        return o4 /= 100, u2 /= 108.883, n4 = (n4 /= 95.047) > 0.008856 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116, [
            116 * (o4 = o4 > 0.008856 ? Math.pow(o4, 1 / 3) : 7.787 * o4 + 16 / 116) - 16,
            500 * (n4 - o4),
            200 * (o4 - (u2 = u2 > 0.008856 ? Math.pow(u2, 1 / 3) : 7.787 * u2 + 16 / 116))
        ];
    }, r2.hsl.rgb = function(e6) {
        var t3, n4, r3, o4, u2, i2 = e6[0] / 360, a2 = e6[1] / 100, s2 = e6[2] / 100;
        if (0 === a2) return [
            u2 = 255 * s2,
            u2,
            u2
        ];
        t3 = 2 * s2 - (n4 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2), o4 = [
            0,
            0,
            0
        ];
        for(var l2 = 0; l2 < 3; l2++)(r3 = i2 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, u2 = 6 * r3 < 1 ? t3 + 6 * (n4 - t3) * r3 : 2 * r3 < 1 ? n4 : 3 * r3 < 2 ? t3 + (n4 - t3) * (2 / 3 - r3) * 6 : t3, o4[l2] = 255 * u2;
        return o4;
    }, r2.hsl.hsv = function(e6) {
        var t3 = e6[0], n4 = e6[1] / 100, r3 = e6[2] / 100, o4 = n4, u2 = Math.max(r3, 0.01);
        return n4 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, o4 *= u2 <= 1 ? u2 : 2 - u2, [
            t3,
            100 * (0 === r3 ? 2 * o4 / (u2 + o4) : 2 * n4 / (r3 + n4)),
            100 * ((r3 + n4) / 2)
        ];
    }, r2.hsv.rgb = function(e6) {
        var t3 = e6[0] / 60, n4 = e6[1] / 100, r3 = e6[2] / 100, o4 = Math.floor(t3) % 6, u2 = t3 - Math.floor(t3), i2 = 255 * r3 * (1 - n4), a2 = 255 * r3 * (1 - n4 * u2), s2 = 255 * r3 * (1 - n4 * (1 - u2));
        switch(r3 *= 255, o4){
            case 0:
                return [
                    r3,
                    s2,
                    i2
                ];
            case 1:
                return [
                    a2,
                    r3,
                    i2
                ];
            case 2:
                return [
                    i2,
                    r3,
                    s2
                ];
            case 3:
                return [
                    i2,
                    a2,
                    r3
                ];
            case 4:
                return [
                    s2,
                    i2,
                    r3
                ];
            case 5:
                return [
                    r3,
                    i2,
                    a2
                ];
        }
    }, r2.hsv.hsl = function(e6) {
        var t3, n4, r3, o4 = e6[0], u2 = e6[1] / 100, i2 = e6[2] / 100, a2 = Math.max(i2, 0.01);
        return r3 = (2 - u2) * i2, n4 = u2 * a2, [
            o4,
            100 * (n4 = (n4 /= (t3 = (2 - u2) * a2) <= 1 ? t3 : 2 - t3) || 0),
            100 * (r3 /= 2)
        ];
    }, r2.hwb.rgb = function(e6) {
        var t3, n4, r3, o4, u2, i2, a2, s2 = e6[0] / 360, l2 = e6[1] / 100, c2 = e6[2] / 100, p2 = l2 + c2;
        switch(p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t3 = Math.floor(6 * s2)), 0 != (1 & t3) && (r3 = 1 - r3), o4 = l2 + r3 * ((n4 = 1 - c2) - l2), t3){
            default:
            case 6:
            case 0:
                u2 = n4, i2 = o4, a2 = l2;
                break;
            case 1:
                u2 = o4, i2 = n4, a2 = l2;
                break;
            case 2:
                u2 = l2, i2 = n4, a2 = o4;
                break;
            case 3:
                u2 = l2, i2 = o4, a2 = n4;
                break;
            case 4:
                u2 = o4, i2 = l2, a2 = n4;
                break;
            case 5:
                u2 = n4, i2 = l2, a2 = o4;
        }
        return [
            255 * u2,
            255 * i2,
            255 * a2
        ];
    }, r2.cmyk.rgb = function(e6) {
        var t3 = e6[0] / 100, n4 = e6[1] / 100, r3 = e6[2] / 100, o4 = e6[3] / 100;
        return [
            255 * (1 - Math.min(1, t3 * (1 - o4) + o4)),
            255 * (1 - Math.min(1, n4 * (1 - o4) + o4)),
            255 * (1 - Math.min(1, r3 * (1 - o4) + o4))
        ];
    }, r2.xyz.rgb = function(e6) {
        var t3, n4, r3, o4 = e6[0] / 100, u2 = e6[1] / 100, i2 = e6[2] / 100;
        return n4 = -0.9689 * o4 + 1.8758 * u2 + 0.0415 * i2, r3 = 0.0557 * o4 + -0.204 * u2 + 1.057 * i2, t3 = (t3 = 3.2406 * o4 + -1.5372 * u2 + -0.4986 * i2) > 0.0031308 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n4 = n4 > 0.0031308 ? 1.055 * Math.pow(n4, 1 / 2.4) - 0.055 : 12.92 * n4, r3 = r3 > 0.0031308 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [
            255 * (t3 = Math.min(Math.max(0, t3), 1)),
            255 * (n4 = Math.min(Math.max(0, n4), 1)),
            255 * (r3 = Math.min(Math.max(0, r3), 1))
        ];
    }, r2.xyz.lab = function(e6) {
        var t3 = e6[0], n4 = e6[1], r3 = e6[2];
        return n4 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 0.008856 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [
            116 * (n4 = n4 > 0.008856 ? Math.pow(n4, 1 / 3) : 7.787 * n4 + 16 / 116) - 16,
            500 * (t3 - n4),
            200 * (n4 - (r3 = r3 > 0.008856 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))
        ];
    }, r2.lab.xyz = function(e6) {
        var t3, n4, r3, o4 = e6[0];
        t3 = e6[1] / 500 + (n4 = (o4 + 16) / 116), r3 = n4 - e6[2] / 200;
        var u2 = Math.pow(n4, 3), i2 = Math.pow(t3, 3), a2 = Math.pow(r3, 3);
        return n4 = u2 > 0.008856 ? u2 : (n4 - 16 / 116) / 7.787, t3 = i2 > 0.008856 ? i2 : (t3 - 16 / 116) / 7.787, r3 = a2 > 0.008856 ? a2 : (r3 - 16 / 116) / 7.787, [
            t3 *= 95.047,
            n4 *= 100,
            r3 *= 108.883
        ];
    }, r2.lab.lch = function(e6) {
        var t3, n4 = e6[0], r3 = e6[1], o4 = e6[2];
        return (t3 = 360 * Math.atan2(o4, r3) / 2 / Math.PI) < 0 && (t3 += 360), [
            n4,
            Math.sqrt(r3 * r3 + o4 * o4),
            t3
        ];
    }, r2.lch.lab = function(e6) {
        var t3, n4 = e6[0], r3 = e6[1];
        return t3 = e6[2] / 360 * 2 * Math.PI, [
            n4,
            r3 * Math.cos(t3),
            r3 * Math.sin(t3)
        ];
    }, r2.rgb.ansi16 = function(e6) {
        var t3 = e6[0], n4 = e6[1], o4 = e6[2], u2 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e6)[2];
        if (0 === (u2 = Math.round(u2 / 50))) return 30;
        var i2 = 30 + (Math.round(o4 / 255) << 2 | Math.round(n4 / 255) << 1 | Math.round(t3 / 255));
        return 2 === u2 && (i2 += 60), i2;
    }, r2.hsv.ansi16 = function(e6) {
        return r2.rgb.ansi16(r2.hsv.rgb(e6), e6[2]);
    }, r2.rgb.ansi256 = function(e6) {
        var t3 = e6[0], n4 = e6[1], r3 = e6[2];
        return t3 === n4 && n4 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n4 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e6) {
        var t3 = e6 % 10;
        if (0 === t3 || 7 === t3) return e6 > 50 && (t3 += 3.5), [
            t3 = t3 / 10.5 * 255,
            t3,
            t3
        ];
        var n4 = 0.5 * (1 + ~~(e6 > 50));
        return [
            (1 & t3) * n4 * 255,
            (t3 >> 1 & 1) * n4 * 255,
            (t3 >> 2 & 1) * n4 * 255
        ];
    }, r2.ansi256.rgb = function(e6) {
        if (e6 >= 232) {
            var t3 = 10 * (e6 - 232) + 8;
            return [
                t3,
                t3,
                t3
            ];
        }
        var n4;
        return e6 -= 16, [
            Math.floor(e6 / 36) / 5 * 255,
            Math.floor((n4 = e6 % 36) / 6) / 5 * 255,
            n4 % 6 / 5 * 255
        ];
    }, r2.rgb.hex = function(e6) {
        var t3 = (((255 & Math.round(e6[0])) << 16) + ((255 & Math.round(e6[1])) << 8) + (255 & Math.round(e6[2]))).toString(16).toUpperCase();
        return "000000".substring(t3.length) + t3;
    }, r2.hex.rgb = function(e6) {
        var t3 = e6.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t3) return [
            0,
            0,
            0
        ];
        var n4 = t3[0];
        3 === t3[0].length && (n4 = n4.split("").map(function(e7) {
            return e7 + e7;
        }).join(""));
        var r3 = parseInt(n4, 16);
        return [
            r3 >> 16 & 255,
            r3 >> 8 & 255,
            255 & r3
        ];
    }, r2.rgb.hcg = function(e6) {
        var t3, n4 = e6[0] / 255, r3 = e6[1] / 255, o4 = e6[2] / 255, u2 = Math.max(Math.max(n4, r3), o4), i2 = Math.min(Math.min(n4, r3), o4), a2 = u2 - i2;
        return t3 = a2 <= 0 ? 0 : u2 === n4 ? (r3 - o4) / a2 % 6 : u2 === r3 ? 2 + (o4 - n4) / a2 : 4 + (n4 - r3) / a2 + 4, t3 /= 6, [
            360 * (t3 %= 1),
            100 * a2,
            100 * (a2 < 1 ? i2 / (1 - a2) : 0)
        ];
    }, r2.hsl.hcg = function(e6) {
        var t3 = e6[1] / 100, n4 = e6[2] / 100, r3 = 1, o4 = 0;
        return (r3 = n4 < 0.5 ? 2 * t3 * n4 : 2 * t3 * (1 - n4)) < 1 && (o4 = (n4 - 0.5 * r3) / (1 - r3)), [
            e6[0],
            100 * r3,
            100 * o4
        ];
    }, r2.hsv.hcg = function(e6) {
        var t3 = e6[1] / 100, n4 = e6[2] / 100, r3 = t3 * n4, o4 = 0;
        return r3 < 1 && (o4 = (n4 - r3) / (1 - r3)), [
            e6[0],
            100 * r3,
            100 * o4
        ];
    }, r2.hcg.rgb = function(e6) {
        var t3 = e6[0] / 360, n4 = e6[1] / 100, r3 = e6[2] / 100;
        if (0 === n4) return [
            255 * r3,
            255 * r3,
            255 * r3
        ];
        var o4, u2 = [
            0,
            0,
            0
        ], i2 = t3 % 1 * 6, a2 = i2 % 1, s2 = 1 - a2;
        switch(Math.floor(i2)){
            case 0:
                u2[0] = 1, u2[1] = a2, u2[2] = 0;
                break;
            case 1:
                u2[0] = s2, u2[1] = 1, u2[2] = 0;
                break;
            case 2:
                u2[0] = 0, u2[1] = 1, u2[2] = a2;
                break;
            case 3:
                u2[0] = 0, u2[1] = s2, u2[2] = 1;
                break;
            case 4:
                u2[0] = a2, u2[1] = 0, u2[2] = 1;
                break;
            default:
                u2[0] = 1, u2[1] = 0, u2[2] = s2;
        }
        return o4 = (1 - n4) * r3, [
            255 * (n4 * u2[0] + o4),
            255 * (n4 * u2[1] + o4),
            255 * (n4 * u2[2] + o4)
        ];
    }, r2.hcg.hsv = function(e6) {
        var t3 = e6[1] / 100, n4 = t3 + e6[2] / 100 * (1 - t3), r3 = 0;
        return n4 > 0 && (r3 = t3 / n4), [
            e6[0],
            100 * r3,
            100 * n4
        ];
    }, r2.hcg.hsl = function(e6) {
        var t3 = e6[1] / 100, n4 = e6[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
        return n4 > 0 && n4 < 0.5 ? r3 = t3 / (2 * n4) : n4 >= 0.5 && n4 < 1 && (r3 = t3 / (2 * (1 - n4))), [
            e6[0],
            100 * r3,
            100 * n4
        ];
    }, r2.hcg.hwb = function(e6) {
        var t3 = e6[1] / 100, n4 = t3 + e6[2] / 100 * (1 - t3);
        return [
            e6[0],
            100 * (n4 - t3),
            100 * (1 - n4)
        ];
    }, r2.hwb.hcg = function(e6) {
        var t3 = e6[1] / 100, n4 = 1 - e6[2] / 100, r3 = n4 - t3, o4 = 0;
        return r3 < 1 && (o4 = (n4 - r3) / (1 - r3)), [
            e6[0],
            100 * r3,
            100 * o4
        ];
    }, r2.apple.rgb = function(e6) {
        return [
            e6[0] / 65535 * 255,
            e6[1] / 65535 * 255,
            e6[2] / 65535 * 255
        ];
    }, r2.rgb.apple = function(e6) {
        return [
            e6[0] / 255 * 65535,
            e6[1] / 255 * 65535,
            e6[2] / 255 * 65535
        ];
    }, r2.gray.rgb = function(e6) {
        return [
            e6[0] / 100 * 255,
            e6[0] / 100 * 255,
            e6[0] / 100 * 255
        ];
    }, r2.gray.hsl = r2.gray.hsv = function(e6) {
        return [
            0,
            0,
            e6[0]
        ];
    }, r2.gray.hwb = function(e6) {
        return [
            0,
            100,
            e6[0]
        ];
    }, r2.gray.cmyk = function(e6) {
        return [
            0,
            0,
            0,
            e6[0]
        ];
    }, r2.gray.lab = function(e6) {
        return [
            e6[0],
            0,
            0
        ];
    }, r2.gray.hex = function(e6) {
        var t3 = 255 & Math.round(e6[0] / 100 * 255), n4 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
        return "000000".substring(n4.length) + n4;
    }, r2.rgb.gray = function(e6) {
        return [
            (e6[0] + e6[1] + e6[2]) / 3 / 255 * 100
        ];
    };
});
function li(e5) {
    var t2 = function() {
        for(var e6 = {
        }, t2 = Object.keys(si), n2 = t2.length, r2 = 0; r2 < n2; r2++)e6[t2[r2]] = {
            distance: -1,
            parent: null
        };
        return e6;
    }(), n2 = [
        e5
    ];
    for(t2[e5].distance = 0; n2.length;)for(var r2 = n2.pop(), o3 = Object.keys(si[r2]), u2 = o3.length, i2 = 0; i2 < u2; i2++){
        var a2 = o3[i2], s2 = t2[a2];
        -1 === s2.distance && (s2.distance = t2[r2].distance + 1, s2.parent = r2, n2.unshift(a2));
    }
    return t2;
}
function ci(e5, t2) {
    return function(n2) {
        return t2(e5(n2));
    };
}
function pi(e5, t2) {
    for(var n2 = [
        t2[e5].parent,
        e5
    ], r2 = si[t2[e5].parent][e5], o3 = t2[e5].parent; t2[o3].parent;)n2.unshift(t2[o3].parent), r2 = ci(si[t2[o3].parent][o3], r2), o3 = t2[o3].parent;
    return r2.conversion = n2, r2;
}
var di = {
};
Object.keys(si).forEach(function(e5) {
    di[e5] = {
    }, Object.defineProperty(di[e5], "channels", {
        value: si[e5].channels
    }), Object.defineProperty(di[e5], "labels", {
        value: si[e5].labels
    });
    var t2 = function(e6) {
        for(var t2 = li(e6), n2 = {
        }, r2 = Object.keys(t2), o3 = r2.length, u2 = 0; u2 < o3; u2++){
            var i2 = r2[u2];
            null !== t2[i2].parent && (n2[i2] = pi(i2, t2));
        }
        return n2;
    }(e5);
    Object.keys(t2).forEach(function(n2) {
        var r2 = t2[n2];
        di[e5][n2] = (function(e6) {
            var t3 = function(t4) {
                if (null == t4) return t4;
                arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
                var n4 = e6(t4);
                if ("object" == typeof n4) for(var r3 = n4.length, o3 = 0; o3 < r3; o3++)n4[o3] = Math.round(n4[o3]);
                return n4;
            };
            return "conversion" in e6 && (t3.conversion = e6.conversion), t3;
        })(r2), di[e5][n2].raw = (function(e6) {
            var t3 = function(t4) {
                return null == t4 ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e6(t4));
            };
            return "conversion" in e6 && (t3.conversion = e6.conversion), t3;
        })(r2);
    });
});
var fi = di, hi = je(function(e5) {
    const t2 = (e6, t3)=>function() {
            const n2 = e6.apply(fi, arguments);
            return "\x1b[".concat(n2 + t3, "m");
        }
    , n2 = (e6, t3)=>function() {
            const n4 = e6.apply(fi, arguments);
            return "\x1b[".concat(38 + t3, ";5;").concat(n4, "m");
        }
    , r2 = (e6, t3)=>function() {
            const n4 = e6.apply(fi, arguments);
            return "\x1b[".concat(38 + t3, ";2;").concat(n4[0], ";").concat(n4[1], ";").concat(n4[2], "m");
        }
    ;
    Object.defineProperty(e5, "exports", {
        enumerable: !0,
        get: function() {
            const e6 = new Map, o3 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    gray: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            o3.color.grey = o3.color.gray;
            for (const t3 of Object.keys(o3)){
                const n4 = o3[t3];
                for (const t4 of Object.keys(n4)){
                    const r3 = n4[t4];
                    o3[t4] = {
                        open: "\x1b[".concat(r3[0], "m"),
                        close: "\x1b[".concat(r3[1], "m")
                    }, n4[t4] = o3[t4], e6.set(r3[0], r3[1]);
                }
                Object.defineProperty(o3, t3, {
                    value: n4,
                    enumerable: !1
                }), Object.defineProperty(o3, "codes", {
                    value: e6,
                    enumerable: !1
                });
            }
            const u2 = (e7)=>e7
            , i2 = (e7, t4, n4)=>[
                    e7,
                    t4,
                    n4
                ]
            ;
            o3.color.close = "\x1b[39m", o3.bgColor.close = "\x1b[49m", o3.color.ansi = {
                ansi: t2(u2, 0)
            }, o3.color.ansi256 = {
                ansi256: n2(u2, 0)
            }, o3.color.ansi16m = {
                rgb: r2(i2, 0)
            }, o3.bgColor.ansi = {
                ansi: t2(u2, 10)
            }, o3.bgColor.ansi256 = {
                ansi256: n2(u2, 10)
            }, o3.bgColor.ansi16m = {
                rgb: r2(i2, 10)
            };
            for (let e7 of Object.keys(fi)){
                if ("object" != typeof fi[e7]) continue;
                const u3 = fi[e7];
                "ansi16" === e7 && (e7 = "ansi"), "ansi16" in u3 && (o3.color.ansi[e7] = t2(u3.ansi16, 0), o3.bgColor.ansi[e7] = t2(u3.ansi16, 10)), "ansi256" in u3 && (o3.color.ansi256[e7] = n2(u3.ansi256, 0), o3.bgColor.ansi256[e7] = n2(u3.ansi256, 10)), "rgb" in u3 && (o3.color.ansi16m[e7] = r2(u3.rgb, 0), o3.bgColor.ansi16m[e7] = r2(u3.rgb, 10));
            }
            return o3;
        }
    });
});
let gi;
const Ei = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ci = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, bi = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, vi = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ai = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function Fi(e5) {
    return "u" === e5[0] && 5 === e5.length || "x" === e5[0] && 3 === e5.length ? String.fromCharCode(parseInt(e5.slice(1), 16)) : Ai.get(e5) || e5;
}
function xi(e5, t2) {
    const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
    let o3;
    for (const t3 of r2)if (isNaN(t3)) {
        if (!(o3 = t3.match(bi))) throw new Error("Invalid Chalk template style argument: ".concat(t3, " (in style '").concat(e5, "')"));
        n2.push(o3[2].replace(vi, (e6, t4, n4)=>t4 ? Fi(t4) : n4
        ));
    } else n2.push(Number(t3));
    return n2;
}
function Si(e5) {
    Ci.lastIndex = 0;
    const t2 = [];
    let n2;
    for(; null !== (n2 = Ci.exec(e5));){
        const e6 = n2[1];
        if (n2[2]) {
            const r2 = xi(e6, n2[2]);
            t2.push([
                e6
            ].concat(r2));
        } else t2.push([
            e6
        ]);
    }
    return t2;
}
function wi(e5, t2) {
    const n2 = {
    };
    for (const e6 of t2)for (const t3 of e6.styles)n2[t3[0]] = e6.inverse ? null : t3.slice(1);
    let r2 = e5;
    for (const e7 of Object.keys(n2))if (Array.isArray(n2[e7])) {
        if (!(e7 in r2)) throw new Error("Unknown Chalk style: ".concat(e7));
        r2 = n2[e7].length > 0 ? r2[e7].apply(r2, n2[e7]) : r2[e7];
    }
    return r2;
}
const { locStart: Ii , locEnd: Li  } = ei, Mi = Object.getOwnPropertyNames, ji = Object.getOwnPropertyDescriptor;
function _i(e5) {
    const t2 = {
    };
    for (const n2 of e5.plugins)if (n2.parsers) for (const e6 of Mi(n2.parsers))Object.defineProperty(t2, e6, ji(n2.parsers, e6));
    return t2;
}
function Ri(e5, t2) {
    if (t2 = t2 || _i(e5), "function" == typeof e5.parser) return {
        parse: e5.parser,
        astFormat: "estree",
        locStart: Ii,
        locEnd: Li
    };
    if ("string" == typeof e5.parser) {
        if (Object.prototype.hasOwnProperty.call(t2, e5.parser)) return t2[e5.parser];
        throw new Oi("Couldn't resolve parser \"".concat(e5.parser, '". Parsers must be explicitly added to the standalone bundle.'));
    }
}
var Gi = function e1(t2, n2, r2) {
    if (Array.isArray(t2)) return t2.map((t3)=>e1(t3, n2, r2)
    ).filter(Boolean);
    if (!t2 || "object" != typeof t2) return t2;
    const o3 = n2.printer.massageAstNode;
    let u2;
    u2 = o3 && o3.ignoredProperties ? o3.ignoredProperties : new Set;
    const i2 = {
    };
    for (const r3 of Object.keys(t2))u2.has(r3) || "function" == typeof t2[r3] || (i2[r3] = e1(t2[r3], n2, t2));
    if (o3) {
        const e5 = o3(t2, i2, r2);
        if (null === e5) return;
        if (e5) return e5;
    }
    return i2;
};
function Hi() {
}
Hi.ok = function() {
}, Hi.strictEqual = function() {
};
var Xi = _e(Object.freeze({
    __proto__: null,
    default: Hi
}));
function ma(e5, t2) {
    return e5.getValue().printed = !0, t2.printer.printComment(e5, t2);
}
function ga(e5, t2, n2) {
    const r2 = n2.locStart(t2) - 1;
    for(let t3 = 1; t3 < e5.length; ++t3)if (r2 < n2.locStart(e5[t3])) return t3 - 1;
    return 0;
}
function Ca(e5, t2) {
    for(let n2 = e5.length - 1; n2 >= 0; n2 -= 2){
        const r2 = e5[n2];
        if (r2 && !Array.isArray(r2) && (--t2) < 0) return n2;
    }
    return -1;
}
const La = new Set([
    "ObjectExpression",
    "ArrayExpression",
    "StringLiteral",
    "NumericLiteral",
    "BooleanLiteral",
    "NullLiteral"
]), Ma = new Set([
    "OperationDefinition",
    "FragmentDefinition",
    "VariableDefinition",
    "TypeExtensionDefinition",
    "ObjectTypeDefinition",
    "FieldDefinition",
    "DirectiveDefinition",
    "EnumTypeDefinition",
    "EnumValueDefinition",
    "InputValueDefinition",
    "InputObjectTypeDefinition",
    "SchemaDefinition",
    "OperationTypeDefinition",
    "InterfaceTypeDefinition",
    "UnionTypeDefinition",
    "ScalarTypeDefinition"
]);
function ja(e5, t2) {
    if (null == t2) return !1;
    switch(e5.parser){
        case "flow":
        case "babel":
        case "babel-flow":
        case "babel-ts":
        case "typescript":
        case "espree":
        case "meriyah":
            return (function(e6) {
                return "Directive" === e6 || "TypeAlias" === e6 || "TSExportAssignment" === e6 || e6.startsWith("Declare") || e6.startsWith("TSDeclare") || e6.endsWith("Statement") || e6.endsWith("Declaration");
            })(t2.type);
        case "json":
            return La.has(t2.type);
        case "graphql":
            return Ma.has(t2.kind);
        case "vue":
            return "root" !== t2.tag;
    }
    return !1;
}
function Ya(e5, t2, n2) {
    return "number" != typeof t2 || isNaN(t2) || t2 < 0 || t2 > e5.length ? n2 : t2;
}
function Ka(e5, t2) {
    let { cursorOffset: n2 , rangeStart: r2 , rangeEnd: o3  } = t2;
    return n2 = Ya(e5, n2, -1), r2 = Ya(e5, r2, 0), o3 = Ya(e5, o3, e5.length), Object.assign({
    }, t2, {
        cursorOffset: n2,
        rangeStart: r2,
        rangeEnd: o3
    });
}
function Rs(e5, t2) {
    if (!e5 || "object" != typeof e5) return !1;
    if (Array.isArray(e5)) return e5.some((e6)=>Rs(e6, t2)
    );
    const n2 = t2(e5);
    return "boolean" == typeof n2 ? n2 : Object.keys(e5).some((n4)=>Rs(e5[n4], t2)
    );
}
function Vs(e5) {
    return "AssignmentExpression" === e5.type || "BinaryExpression" === e5.type || "LogicalExpression" === e5.type || "NGPipeExpression" === e5.type || "ConditionalExpression" === e5.type || "CallExpression" === e5.type || "OptionalCallExpression" === e5.type || "MemberExpression" === e5.type || "OptionalMemberExpression" === e5.type || "SequenceExpression" === e5.type || "TaggedTemplateExpression" === e5.type || "BindExpression" === e5.type || "UpdateExpression" === e5.type && !e5.prefix || "TSAsExpression" === e5.type || "TSNonNullExpression" === e5.type;
}
function $s(e5) {
    return "Block" === e5.type || "CommentBlock" === e5.type || "MultiLine" === e5.type;
}
const qs = new Set([
    "ExportDefaultDeclaration",
    "ExportDefaultSpecifier",
    "DeclareExportDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration"
]);
function Ws1(e5) {
    return e5 && qs.has(e5.type);
}
function Us(e5) {
    return "BooleanLiteral" === e5.type || "DirectiveLiteral" === e5.type || "Literal" === e5.type || "NullLiteral" === e5.type || "NumericLiteral" === e5.type || "BigIntLiteral" === e5.type || "DecimalLiteral" === e5.type || "RegExpLiteral" === e5.type || "StringLiteral" === e5.type || "TemplateLiteral" === e5.type || "TSTypeLiteral" === e5.type || "JSXText" === e5.type;
}
function Js(e5) {
    return "NumericLiteral" === e5.type || "Literal" === e5.type && "number" == typeof e5.value;
}
function zs(e5) {
    return "StringLiteral" === e5.type || "Literal" === e5.type && "string" == typeof e5.value;
}
function Gs(e5) {
    return "FunctionExpression" === e5.type || "ArrowFunctionExpression" === e5.type;
}
function Hs(e5) {
    return !("CallExpression" !== e5.type && "OptionalCallExpression" !== e5.type || "Identifier" !== e5.callee.type || "async" !== e5.callee.name && "inject" !== e5.callee.name && "fakeAsync" !== e5.callee.name);
}
function Xs(e5) {
    return "JSXElement" === e5.type || "JSXFragment" === e5.type;
}
function Ys(e5) {
    return "get" === e5.kind || "set" === e5.kind;
}
const Qs = new Set([
    "BinaryExpression",
    "LogicalExpression",
    "NGPipeExpression"
]);
const Zs = new Set([
    "AnyTypeAnnotation",
    "TSAnyKeyword",
    "NullLiteralTypeAnnotation",
    "TSNullKeyword",
    "ThisTypeAnnotation",
    "TSThisType",
    "NumberTypeAnnotation",
    "TSNumberKeyword",
    "VoidTypeAnnotation",
    "TSVoidKeyword",
    "BooleanTypeAnnotation",
    "TSBooleanKeyword",
    "BigIntTypeAnnotation",
    "TSBigIntKeyword",
    "SymbolTypeAnnotation",
    "TSSymbolKeyword",
    "StringTypeAnnotation",
    "TSStringKeyword",
    "BooleanLiteralTypeAnnotation",
    "StringLiteralTypeAnnotation",
    "BigIntLiteralTypeAnnotation",
    "NumberLiteralTypeAnnotation",
    "TSLiteralType",
    "TSTemplateLiteralType",
    "EmptyTypeAnnotation",
    "MixedTypeAnnotation",
    "TSNeverKeyword",
    "TSObjectKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword"
]);
const el = /^(skip|[fx]?(it|describe|test))$/;
function tl(e5) {
    return "CallExpression" === e5.type || "OptionalCallExpression" === e5.type;
}
const nl = new RegExp("([ \n\r\t]+)"), rl = new RegExp("[^ \n\r\t]");
function il(e5) {
    return /^(\d+|\d+\.\d+)$/.test(e5);
}
function al(e5) {
    return e5.quasis.some((e6)=>e6.value.raw.includes("\n")
    );
}
function sl(e5) {
    return e5.extra ? e5.extra.raw : e5.raw;
}
const ll = {
    "==": !0,
    "!=": !0,
    "===": !0,
    "!==": !0
}, cl = {
    "*": !0,
    "/": !0,
    "%": !0
}, pl = {
    ">>": !0,
    ">>>": !0,
    "<<": !0
};
const dl = {
};
function fl(e5) {
    return dl[e5];
}
[
    [
        "|>"
    ],
    [
        "??"
    ],
    [
        "||"
    ],
    [
        "&&"
    ],
    [
        "|"
    ],
    [
        "^"
    ],
    [
        "&"
    ],
    [
        "==",
        "===",
        "!=",
        "!=="
    ],
    [
        "<",
        ">",
        "<=",
        ">=",
        "in",
        "instanceof"
    ],
    [
        ">>",
        "<<",
        ">>>"
    ],
    [
        "+",
        "-"
    ],
    [
        "*",
        "/",
        "%"
    ],
    [
        "**"
    ]
].forEach((e5, t2)=>{
    e5.forEach((e6)=>{
        dl[e6] = t2;
    });
});
const hl = new WeakMap;
function ml(e5) {
    if (hl.has(e5)) return hl.get(e5);
    const t2 = [];
    return e5.this && t2.push(e5.this), Array.isArray(e5.parameters) ? t2.push(...e5.parameters) : Array.isArray(e5.params) && t2.push(...e5.params), e5.rest && t2.push(e5.rest), hl.set(e5, t2), t2;
}
const gl = new WeakMap;
function Dl(e5) {
    return "prettier-ignore" === e5.value.trim();
}
function yl(e5) {
    return e5 && (e5.comments && e5.comments.length > 0 && e5.comments.some((e6)=>Dl(e6) && !e6.unignore
    ) || e5.prettierIgnore);
}
function El(e5) {
    return yl(e5.getValue());
}
function Kl(e5) {
    return "ArrowFunctionExpression" === e5.type || "FunctionExpression" === e5.type || "FunctionDeclaration" === e5.type || "ObjectMethod" === e5.type || "ClassMethod" === e5.type || "TSDeclareFunction" === e5.type || "TSCallSignatureDeclaration" === e5.type || "TSConstructSignatureDeclaration" === e5.type || "TSMethodSignature" === e5.type || "TSConstructorType" === e5.type || "TSFunctionType" === e5.type || "TSDeclareMethod" === e5.type;
}
function gc(e5) {
    return e5.replace(/([\\`]|\${)/g, "\\$1");
}
let Xc = 0;
const ep = [
    (e5, t2)=>"ObjectExpression" === e5.type && "properties" === t2
    ,
    (e5, t2)=>"CallExpression" === e5.type && "Identifier" === e5.callee.type && "Component" === e5.callee.name && "arguments" === t2
    ,
    (e5, t2)=>"Decorator" === e5.type && "expression" === t2
];
function tp(e5) {
    return "Identifier" === e5.type && "styled" === e5.name;
}
function np(e5) {
    return /^[A-Z]/.test(e5.object.name) && "extend" === e5.property.name;
}
const lp = (e5)=>{
    if ("string" != typeof e5) throw new TypeError("Expected a string");
    const t2 = e5.match(/(?:\r?\n)/g) || [];
    if (0 === t2.length) return;
    const n2 = t2.filter((e6)=>"\r\n" === e6
    ).length;
    return n2 > t2.length - n2 ? "\r\n" : "\n";
};
var cp = lp;
cp.graceful = (e5)=>"string" == typeof e5 && lp(e5) || "\n"
;
function Np(e5) {
    const t2 = e5.getValue(), n2 = e5.getParentNode(), r2 = e5.getName();
    switch(n2.type){
        case "NGPipeExpression":
            if ("number" == typeof r2 && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2) return e5.callParent(Np);
            break;
        case "ObjectProperty":
            if ("value" === r2) {
                const t3 = e5.getParentNode(1);
                return t3.properties[t3.properties.length - 1] === n2;
            }
            break;
        case "BinaryExpression":
        case "LogicalExpression":
            if ("right" === r2) return e5.callParent(Np);
            break;
        case "ConditionalExpression":
            if ("alternate" === r2) return e5.callParent(Np);
            break;
        case "UnaryExpression":
            if (n2.prefix) return e5.callParent(Np);
    }
    return !1;
}
var Vp = function(e5, t2) {
    switch(t2.parser){
        case "json":
        case "json5":
        case "json-stringify":
        case "__js_expression":
        case "__vue_expression":
            return Object.assign({
            }, e5, {
                type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
                node: e5,
                comments: [],
                rootMarker: t2.rootMarker
            });
        default:
            return e5;
    }
};
let $D = 0;
function vC(e5) {
    const t2 = e5.flags.split("").sort().join("");
    return "/".concat(e5.pattern, "/").concat(t2);
}
const TC = new Set([
    "start",
    "end",
    "extra",
    "loc",
    "comments",
    "errors",
    "range"
]);
function BC(e5, t2) {
    const { type: n2  } = e5;
    return "Identifier" === n2 ? {
        type: "StringLiteral",
        value: e5.name
    } : "UnaryExpression" === n2 && "+" === e5.operator ? t2.argument : void 0;
}
BC.ignoredProperties = TC;
var kC = {
    bracketSpacing: {
        since: "0.0.0",
        category: "Common",
        type: "boolean",
        default: !0,
        description: "Print spaces between brackets.",
        oppositeDescription: "Do not print spaces between brackets."
    },
    singleQuote: {
        since: "0.0.0",
        category: "Common",
        type: "boolean",
        default: !1,
        description: "Use single quotes instead of double quotes."
    },
    proseWrap: {
        since: "1.8.2",
        category: "Common",
        type: "choice",
        default: [
            {
                since: "1.8.2",
                value: !0
            },
            {
                since: "1.9.0",
                value: "preserve"
            }
        ],
        description: "How to wrap prose.",
        choices: [
            {
                since: "1.9.0",
                value: "always",
                description: "Wrap prose if it exceeds the print width."
            },
            {
                since: "1.9.0",
                value: "never",
                description: "Do not wrap prose."
            },
            {
                since: "1.9.0",
                value: "preserve",
                description: "Wrap prose as-is."
            }
        ]
    }
};
var PC = {
    arrowParens: {
        since: "1.9.0",
        category: "JavaScript",
        type: "choice",
        default: [
            {
                since: "1.9.0",
                value: "avoid"
            },
            {
                since: "2.0.0",
                value: "always"
            }
        ],
        description: "Include parentheses around a sole arrow function parameter.",
        choices: [
            {
                value: "always",
                description: "Always include parens. Example: `(x) => x`"
            },
            {
                value: "avoid",
                description: "Omit parens when possible. Example: `x => x`"
            }
        ]
    },
    bracketSpacing: kC.bracketSpacing,
    jsxBracketSameLine: {
        since: "0.17.0",
        category: "JavaScript",
        type: "boolean",
        default: !1,
        description: "Put > on the last line instead of at a new line."
    },
    semi: {
        since: "1.0.0",
        category: "JavaScript",
        type: "boolean",
        default: !0,
        description: "Print semicolons.",
        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
    },
    singleQuote: kC.singleQuote,
    jsxSingleQuote: {
        since: "1.15.0",
        category: "JavaScript",
        type: "boolean",
        default: !1,
        description: "Use single quotes in JSX."
    },
    quoteProps: {
        since: "1.17.0",
        category: "JavaScript",
        type: "choice",
        default: "as-needed",
        description: "Change when properties in objects are quoted.",
        choices: [
            {
                value: "as-needed",
                description: "Only add quotes around object properties where required."
            },
            {
                value: "consistent",
                description: "If at least one property in an object requires quotes, quote all properties."
            },
            {
                value: "preserve",
                description: "Respect the input use of quotes in object properties."
            }
        ]
    },
    trailingComma: {
        since: "0.0.0",
        category: "JavaScript",
        type: "choice",
        default: [
            {
                since: "0.0.0",
                value: !1
            },
            {
                since: "0.19.0",
                value: "none"
            },
            {
                since: "2.0.0",
                value: "es5"
            }
        ],
        description: "Print trailing commas wherever possible when multi-line.",
        choices: [
            {
                value: "es5",
                description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
            },
            {
                value: "none",
                description: "No trailing commas."
            },
            {
                value: "all",
                description: "Trailing commas wherever possible (including function arguments)."
            }
        ]
    }
}, OC = {
    name: "JavaScript",
    type: "programming",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    color: "#f1e05a",
    aliases: [
        "js",
        "node"
    ],
    extensions: [
        ".js",
        "._js",
        ".bones",
        ".cjs",
        ".es",
        ".es6",
        ".frag",
        ".gs",
        ".jake",
        ".jsb",
        ".jscad",
        ".jsfl",
        ".jsm",
        ".jss",
        ".mjs",
        ".njs",
        ".pac",
        ".sjs",
        ".ssjs",
        ".xsjs",
        ".xsjslib"
    ],
    filenames: [
        "Jakefile"
    ],
    interpreters: [
        "chakra",
        "d8",
        "gjs",
        "js",
        "node",
        "nodejs",
        "qjs",
        "rhino",
        "v8",
        "v8-shell"
    ],
    languageId: 183
}, IC = {
    name: "JSX",
    type: "programming",
    group: "JavaScript",
    extensions: [
        ".jsx"
    ],
    tmScope: "source.js.jsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    languageId: 178
}, LC = {
    name: "TypeScript",
    type: "programming",
    color: "#2b7489",
    aliases: [
        "ts"
    ],
    interpreters: [
        "deno",
        "ts-node"
    ],
    extensions: [
        ".ts"
    ],
    tmScope: "source.ts",
    aceMode: "typescript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/typescript",
    languageId: 378
}, MC = {
    name: "TSX",
    type: "programming",
    group: "TypeScript",
    extensions: [
        ".tsx"
    ],
    tmScope: "source.tsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    languageId: 94901924
}, jC = {
    name: "JSON",
    type: "data",
    tmScope: "source.json",
    aceMode: "json",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    searchable: !1,
    extensions: [
        ".json",
        ".avsc",
        ".geojson",
        ".gltf",
        ".har",
        ".ice",
        ".JSON-tmLanguage",
        ".jsonl",
        ".mcmeta",
        ".tfstate",
        ".tfstate.backup",
        ".topojson",
        ".webapp",
        ".webmanifest",
        ".yy",
        ".yyp"
    ],
    filenames: [
        ".arcconfig",
        ".htmlhintrc",
        ".tern-config",
        ".tern-project",
        ".watchmanconfig",
        "composer.lock",
        "mcmod.info"
    ],
    languageId: 174
}, _C = {
    name: "JSON with Comments",
    type: "data",
    group: "JSON",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    aliases: [
        "jsonc"
    ],
    extensions: [
        ".jsonc",
        ".sublime-build",
        ".sublime-commands",
        ".sublime-completions",
        ".sublime-keymap",
        ".sublime-macro",
        ".sublime-menu",
        ".sublime-mousemap",
        ".sublime-project",
        ".sublime-settings",
        ".sublime-theme",
        ".sublime-workspace",
        ".sublime_metrics",
        ".sublime_session"
    ],
    filenames: [
        ".babelrc",
        ".eslintrc.json",
        ".jscsrc",
        ".jshintrc",
        ".jslintrc",
        "devcontainer.json",
        "jsconfig.json",
        "language-configuration.json",
        "tsconfig.json",
        "tslint.json"
    ],
    languageId: 423
}, RC = {
    name: "JSON5",
    type: "data",
    extensions: [
        ".json5"
    ],
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    languageId: 175
};
const nb = new Set([
    "red",
    "green",
    "blue",
    "alpha",
    "a",
    "rgb",
    "hue",
    "h",
    "saturation",
    "s",
    "lightness",
    "l",
    "whiteness",
    "w",
    "blackness",
    "b",
    "tint",
    "shade",
    "blend",
    "blenda",
    "contrast",
    "hsl",
    "hsla",
    "hwb",
    "hwba"
]);
function rb(e5, t2) {
    const n2 = [].concat(t2);
    let r2, o3 = -1;
    for(; r2 = e5.getParentNode(++o3);)if (n2.includes(r2.type)) return o3;
    return -1;
}
function ob(e5, t2) {
    const n2 = rb(e5, t2);
    return -1 === n2 ? null : e5.getParentNode(n2);
}
function ub(e5) {
    return "value-operator" === e5.type && "*" === e5.value;
}
function ib(e5) {
    return "value-operator" === e5.type && "/" === e5.value;
}
function ab(e5) {
    return "value-operator" === e5.type && "+" === e5.value;
}
function sb(e5) {
    return "value-operator" === e5.type && "-" === e5.value;
}
function lb(e5) {
    return "value-operator" === e5.type && "%" === e5.value;
}
function cb(e5) {
    return "value-comma_group" === e5.type && e5.groups && e5.groups[1] && "value-colon" === e5.groups[1].type;
}
function pb(e5) {
    return "value-paren_group" === e5.type && e5.groups && e5.groups[0] && cb(e5.groups[0]);
}
var db2 = {
    getAncestorCounter: rb,
    getAncestorNode: ob,
    getPropOfDeclNode: function(e5) {
        const t2 = ob(e5, "css-decl");
        return t2 && t2.prop && t2.prop.toLowerCase();
    },
    hasSCSSInterpolation: function(e5) {
        if (e5 && e5.length) for(let t2 = e5.length - 1; t2 > 0; t2--)if ("word" === e5[t2].type && "{" === e5[t2].value && "word" === e5[t2 - 1].type && e5[t2 - 1].value.endsWith("#")) return !0;
        return !1;
    },
    hasStringOrFunction: function(e5) {
        if (e5 && e5.length) for(let t2 = 0; t2 < e5.length; t2++)if ("string" === e5[t2].type || "func" === e5[t2].type) return !0;
        return !1;
    },
    maybeToLowerCase: function(e5) {
        return e5.includes("$") || e5.includes("@") || e5.includes("#") || e5.startsWith("%") || e5.startsWith("--") || e5.startsWith(":--") || e5.includes("(") && e5.includes(")") ? e5 : e5.toLowerCase();
    },
    insideValueFunctionNode: function(e5, t2) {
        const n2 = ob(e5, "value-func");
        return n2 && n2.value && n2.value.toLowerCase() === t2;
    },
    insideICSSRuleNode: function(e5) {
        const t2 = ob(e5, "css-rule");
        return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
    },
    insideAtRuleNode: function(e5, t2) {
        const n2 = [].concat(t2), r2 = ob(e5, "css-atrule");
        return r2 && n2.includes(r2.name.toLowerCase());
    },
    insideURLFunctionInImportAtRuleNode: function(e5) {
        const t2 = e5.getValue(), n2 = ob(e5, "css-atrule");
        return n2 && "import" === n2.name && "url" === t2.groups[0].value && 2 === t2.groups.length;
    },
    isKeyframeAtRuleKeywords: function(e5, t2) {
        const n2 = ob(e5, "css-atrule");
        return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && [
            "from",
            "to"
        ].includes(t2.toLowerCase());
    },
    isWideKeywords: function(e5) {
        return [
            "initial",
            "inherit",
            "unset",
            "revert"
        ].includes(e5.toLowerCase());
    },
    isSCSS: function(e5, t2) {
        return "less" === e5 || "scss" === e5 ? "scss" === e5 : /(\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
    },
    isSCSSVariable: function(e5) {
        return !(!e5 || "word" !== e5.type || !e5.value.startsWith("$"));
    },
    isLastNode: function(e5, t2) {
        const n2 = e5.getParentNode();
        if (!n2) return !1;
        const { nodes: r2  } = n2;
        return r2 && r2.indexOf(t2) === r2.length - 1;
    },
    isLessParser: function(e5) {
        return "css" === e5.parser || "less" === e5.parser;
    },
    isSCSSControlDirectiveNode: function(e5) {
        return "css-atrule" === e5.type && [
            "if",
            "else",
            "for",
            "each",
            "while"
        ].includes(e5.name);
    },
    isDetachedRulesetDeclarationNode: function(e5) {
        return !!e5.selector && ("string" == typeof e5.selector && /^@.+:.*$/.test(e5.selector) || e5.selector.value && /^@.+:.*$/.test(e5.selector.value));
    },
    isRelationalOperatorNode: function(e5) {
        return "value-word" === e5.type && [
            "<",
            ">",
            "<=",
            ">="
        ].includes(e5.value);
    },
    isEqualityOperatorNode: function(e5) {
        return "value-word" === e5.type && [
            "==",
            "!="
        ].includes(e5.value);
    },
    isMultiplicationNode: ub,
    isDivisionNode: ib,
    isAdditionNode: ab,
    isSubtractionNode: sb,
    isModuloNode: lb,
    isMathOperatorNode: function(e5) {
        return ub(e5) || ib(e5) || ab(e5) || sb(e5) || lb(e5);
    },
    isEachKeywordNode: function(e5) {
        return "value-word" === e5.type && "in" === e5.value;
    },
    isForKeywordNode: function(e5) {
        return "value-word" === e5.type && [
            "from",
            "through",
            "end"
        ].includes(e5.value);
    },
    isURLFunctionNode: function(e5) {
        return "value-func" === e5.type && "url" === e5.value.toLowerCase();
    },
    isIfElseKeywordNode: function(e5) {
        return "value-word" === e5.type && [
            "and",
            "or",
            "not"
        ].includes(e5.value);
    },
    hasComposesNode: function(e5) {
        return e5.value && "value-root" === e5.value.type && e5.value.group && "value-value" === e5.value.group.type && "composes" === e5.prop.toLowerCase();
    },
    hasParensAroundNode: function(e5) {
        return e5.value && e5.value.group && e5.value.group.group && "value-paren_group" === e5.value.group.group.type && null !== e5.value.group.group.open && null !== e5.value.group.group.close;
    },
    hasEmptyRawBefore: function(e5) {
        return e5.raws && "" === e5.raws.before;
    },
    isSCSSNestedPropertyNode: function(e5) {
        return !!e5.selector && e5.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
    },
    isDetachedRulesetCallNode: function(e5) {
        return e5.raws && e5.raws.params && /^\(\s*\)$/.test(e5.raws.params);
    },
    isTemplatePlaceholderNode: function(e5) {
        return e5.name.startsWith("prettier-placeholder");
    },
    isTemplatePropNode: function(e5) {
        return e5.prop.startsWith("@prettier-placeholder");
    },
    isPostcssSimpleVarNode: function(e5, t2) {
        return "$$" === e5.value && "value-func" === e5.type && t2 && "value-word" === t2.type && !t2.raws.before;
    },
    isKeyValuePairNode: cb,
    isKeyValuePairInParenGroupNode: pb,
    isSCSSMapItemNode: function(e5) {
        const t2 = e5.getValue();
        if (0 === t2.groups.length) return !1;
        const n2 = e5.getParentNode(1);
        if (!(pb(t2) || n2 && pb(n2))) return !1;
        const r2 = ob(e5, "css-decl");
        return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!pb(n2) || "value-func" === n2.type);
    },
    isInlineValueCommentNode: function(e5) {
        return "value-comment" === e5.type && e5.inline;
    },
    isHashNode: function(e5) {
        return "value-word" === e5.type && "#" === e5.value;
    },
    isLeftCurlyBraceNode: function(e5) {
        return "value-word" === e5.type && "{" === e5.value;
    },
    isRightCurlyBraceNode: function(e5) {
        return "value-word" === e5.type && "}" === e5.value;
    },
    isWordNode: function(e5) {
        return [
            "value-word",
            "value-atword"
        ].includes(e5.type);
    },
    isColonNode: function(e5) {
        return "value-colon" === e5.type;
    },
    isMediaAndSupportsKeywords: function(e5) {
        return e5.value && [
            "not",
            "and",
            "or"
        ].includes(e5.value.toLowerCase());
    },
    isColorAdjusterFuncNode: function(e5) {
        return "value-func" === e5.type && nb.has(e5.value.toLowerCase());
    },
    lastLineHasInlineComment: function(e5) {
        return /\/\//.test(e5.split(/[\n\r]/).pop());
    },
    stringifyNode: function e5(t2) {
        if (t2.groups) {
            return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n2, r2, o3)=>n2 + e5(r2) + ("comma_group" === t2.groups[0].type && o3 !== t2.groups.length - 1 ? "," : "")
            , "") + (t2.close && t2.close.value ? t2.close.value : "");
        }
        const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
        return n2 + r2 + ("atword" === t2.type ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e5(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
    },
    isAtWordPlaceholderNode: function(e6) {
        return e6 && "value-atword" === e6.type && e6.value.startsWith("prettier-placeholder-");
    }
}, fb = function(e5, t2) {
    let n2 = 0;
    for(let r2 = 0; r2 < e5.line - 1; ++r2)n2 = t2.indexOf("\n", n2) + 1;
    return n2 + e5.column;
};
function gb(e5, t2) {
    return "number" == typeof e5.sourceIndex ? e5.sourceIndex : e5.source ? fb(e5.source.start, t2) - 1 : null;
}
function Eb(e5) {
    let t2 = e5.source.startOffset;
    return "string" == typeof e5.prop && (t2 += e5.prop.length), "css-atrule" === e5.type && "string" == typeof e5.name && (t2 += 1 + e5.name.length + e5.raws.afterName.match(/^\s*:?\s*/)[0].length), "css-atrule" !== e5.type && e5.raws && "string" == typeof e5.raws.between && (t2 += e5.raws.between.length), t2;
}
function kv(e5) {
    return "es5" === e5.trailingComma || "all" === e5.trailingComma;
}
const Ov = /(["'])(?:(?!\1)[^\\]|\\[\S\s])*\1/g, Iv = new RegExp(Ov.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
function Mv(e5, t2) {
    const n2 = t2.singleQuote ? "'" : '"';
    return e5.includes('"') || e5.includes("'") ? e5 : n2 + e5 + n2;
}
var Jv = {
    locStart: function(e5) {
        return e5.loc.start.offset;
    },
    locEnd: function(e5) {
        return e5.loc.end.offset;
    }
};
function zv(e5, t2) {
    if ("TextNode" === e5.type) {
        const n2 = e5.chars.trim();
        if (!n2) return null;
        t2.chars = n2;
    }
}
zv.ignoredProperties = new Set([
    "loc",
    "selfClosing"
]);
var Gv = zv;
const Hv = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
]);
function Yv(e5, t2) {
    return e5 && t2.some((t3)=>e5.type === t3
    );
}
function Kv(e5, t2) {
    const n2 = e5.getValue(), r2 = e5.getParentNode(0) || {
    }, o3 = r2.children || r2.body || r2.parts || [], u2 = o3.indexOf(n2);
    return -1 !== u2 && o3[u2 + t2];
}
function Qv(e5, t2 = 1) {
    return Kv(e5, -t2);
}
function Zv(e5) {
    return Kv(e5, 1);
}
function eA(e5) {
    return Yv(e5, [
        "MustacheCommentStatement"
    ]) && "string" == typeof e5.value && "prettier-ignore" === e5.value.trim();
}
function $A(e5) {
    return (e5 = "string" == typeof e5 ? e5 : "").split("\n").length - 1;
}
function zA(e5, t2) {
    return e5.call(t2, "path");
}
var KA = {
    hasPragma: function(e5) {
        return /^\s*#[^\S\n]*@(format|prettier)\s*(\n|$)/.test(e5);
    },
    insertPragma: function(e5) {
        return "# @format\n\n" + e5;
    }
};
var QA = {
    locStart: function(e5) {
        return "number" == typeof e5.start ? e5.start : e5.loc && e5.loc.start;
    },
    locEnd: function(e5) {
        return "number" == typeof e5.end ? e5.end : e5.loc && e5.loc.end;
    }
};
function hF() {
}
hF.ignoredProperties = new Set([
    "loc",
    "comments"
]);
var yF = {
    locStart: function(e5) {
        return e5.position.start.offset;
    },
    locEnd: function(e5) {
        return e5.position.end.offset;
    }
};
function BF(e5, t2) {
    const [, n2, r2, o3] = t2.slice(e5.position.start.offset, e5.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return {
        numberText: n2,
        marker: r2,
        leadingSpaces: o3
    };
}
function Lx(e5, t2) {
    return (function(e6, t3, n2) {
        n2 = n2 || (()=>!0
        );
        let r2 = -1;
        for (const o3 of t3.children)if (o3.type === e6.type && n2(o3) ? r2++ : r2 = -1, o3 === e6) return r2;
    })(e5, t2, (t3)=>t3.ordered === e5.ordered
    );
}
function Mx(e5, t2) {
    const n2 = [].concat(t2);
    let r2, o3 = -1;
    for(; r2 = e5.getParentNode(++o3);)if (n2.includes(r2.type)) return o3;
    return -1;
}
function jx(e5, t2) {
    const n2 = Mx(e5, t2);
    return -1 === n2 ? null : e5.getParentNode(n2);
}
function $x(e5) {
    let t2 = e5;
    for(; t2.children && 0 !== t2.children.length;)t2 = t2.children[t2.children.length - 1];
    return t2;
}
function qx(e5) {
    if ("html" !== e5.type) return !1;
    const t2 = e5.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return null !== t2 && (t2[1] ? t2[1] : "next");
}
function Wx(e5, t2) {
    const n2 = t2.prevNode && "list" === t2.prevNode.type, r2 = "code" === e5.type && e5.isIndented;
    return n2 && r2;
}
function Ux(e5, t2) {
    const n2 = [
        " "
    ].concat(t2 || []);
    return new RegExp(n2.map((e6)=>"\\".concat(e6)
    ).join("|")).test(e5) ? "<".concat(e5, ">") : e5;
}
function Jx(e5, t2, n2) {
    if (null == n2 && (n2 = !0), !e5) return "";
    if (n2) return " " + Jx(e5, t2, !1);
    if ((e5 = e5.replace(/\\(["')])/g, "$1")).includes('"') && e5.includes("'") && !e5.includes(")")) return "(".concat(e5, ")");
    const r2 = e5.split("'").length - 1, o3 = e5.split('"').length - 1, u2 = r2 > o3 ? '"' : o3 > r2 || t2.singleQuote ? "'" : '"';
    return e5 = (e5 = e5.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(u2, ")"), "g"), "\\$1"), "".concat(u2).concat(e5).concat(u2);
}
function dS(e5) {
    const t2 = Object.create(null);
    for (const n2 of e5)t2[n2] = !0;
    return t2;
}
function hS(e5) {
    if ("attribute" === e5.type) return !1;
    if (!e5.parent) return !1;
    if ("number" != typeof e5.index || 0 === e5.index) return !1;
    return (function(e6) {
        return "comment" === e6.type && "prettier-ignore" === e6.value.trim();
    })(e5.parent.children[e5.index - 1]);
}
function DS(e5) {
    return "element" === e5.type && 0 !== e5.children.length && ([
        "html",
        "head",
        "ul",
        "ol",
        "select"
    ].includes(e5.name) || e5.cssDisplay.startsWith("table") && "table-cell" !== e5.cssDisplay);
}
function CS(e5) {
    return e5.hasLeadingSpaces && (e5.prev ? e5.prev.sourceSpan.end.line < e5.sourceSpan.start.line : "root" === e5.parent.type || e5.parent.startSourceSpan.end.line < e5.sourceSpan.start.line);
}
function bS(e5) {
    return e5.hasTrailingSpaces && (e5.next ? e5.next.sourceSpan.start.line > e5.sourceSpan.end.line : "root" === e5.parent.type || e5.parent.endSourceSpan && e5.parent.endSourceSpan.start.line > e5.sourceSpan.end.line);
}
function vS(e5) {
    switch(e5.type){
        case "ieConditionalComment":
        case "comment":
        case "directive":
            return !0;
        case "element":
            return [
                "script",
                "select"
            ].includes(e5.name);
    }
    return !1;
}
function AS(e5) {
    const { type: t2 , lang: n2  } = e5.attrMap;
    return "module" === t2 || "text/javascript" === t2 || "text/babel" === t2 || "application/javascript" === t2 || "jsx" === n2 ? "babel" : "application/x-typescript" === t2 || "ts" === n2 || "tsx" === n2 ? "typescript" : "text/markdown" === t2 ? "markdown" : "text/html" === t2 ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : "text/x-handlebars-template" === t2 ? "glimmer" : void 0;
}
function FS(e5) {
    return "block" === e5 || "list-item" === e5 || e5.startsWith("table");
}
function SS(e5) {
    return "element" === e5.type && !e5.hasExplicitNamespace && ![
        "html",
        "svg"
    ].includes(e5.namespace);
}
const TS = new Set([
    "template",
    "style",
    "script"
]);
function NS(e5, t2) {
    return "vue" === t2.parser && "element" === e5.type && "root" === e5.parent.type && "html" !== e5.fullName.toLowerCase();
}
var KS = {
    hasPragma: function(e5) {
        return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e5);
    },
    insertPragma: function(e5) {
        return "\x3c!-- @format --\x3e\n\n" + e5.replace(/^\s*\n/, "");
    }
};
var QS = {
    locStart: function(e5) {
        return e5.sourceSpan.start.offset;
    },
    locEnd: function(e5) {
        return e5.sourceSpan.end.offset;
    }
};
function dT(e5) {
    return !e5.prev && e5.isLeadingSpaceSensitive && !e5.hasLeadingSpaces;
}
function ET(e5) {
    switch(e5.type){
        case "ieConditionalComment":
        case "ieConditionalStartComment":
            return "\x3c!--[if ".concat(e5.condition);
        case "ieConditionalEndComment":
            return "\x3c!--<!";
        case "interpolation":
            return "{{";
        case "docType":
            return "<!DOCTYPE";
        case "element":
            if (e5.condition) return "\x3c!--[if ".concat(e5.condition, "]>\x3c!--\x3e<").concat(e5.rawName);
        default:
            return "<".concat(e5.rawName);
    }
}
function CT(e5) {
    switch(Xi(!e5.isSelfClosing), e5.type){
        case "ieConditionalComment":
            return "]>";
        case "element":
            if (e5.condition) return ">\x3c!--<![endif]--\x3e";
        default:
            return ">";
    }
}
var xT = {
    htmlWhitespaceSensitivity: {
        since: "1.15.0",
        category: "HTML",
        type: "choice",
        default: "css",
        description: "How to handle whitespaces in HTML.",
        choices: [
            {
                value: "css",
                description: "Respect the default value of CSS display property."
            },
            {
                value: "strict",
                description: "Whitespaces are considered sensitive."
            },
            {
                value: "ignore",
                description: "Whitespaces are considered insensitive."
            }
        ]
    },
    vueIndentScriptAndStyle: {
        since: "1.19.0",
        category: "HTML",
        type: "boolean",
        default: !1,
        description: "Indent script and style tags in Vue files."
    }
}, ST = {
    name: "HTML",
    type: "markup",
    tmScope: "text.html.basic",
    aceMode: "html",
    codemirrorMode: "htmlmixed",
    codemirrorMimeType: "text/html",
    color: "#e34c26",
    aliases: [
        "xhtml"
    ],
    extensions: [
        ".html",
        ".htm",
        ".html.hl",
        ".inc",
        ".st",
        ".xht",
        ".xhtml"
    ],
    languageId: 146
}, wT = {
    name: "Vue",
    type: "markup",
    color: "#2c3e50",
    extensions: [
        ".vue"
    ],
    tmScope: "text.html.vue",
    aceMode: "html",
    languageId: 391
};
var BT = {
    isPragma: function(e5) {
        return /^\s*@(prettier|format)\s*$/.test(e5);
    },
    hasPragma: function(e5) {
        return /^\s*#[^\S\n]*@(prettier|format)\s*?(\n|$)/.test(e5);
    },
    insertPragma: function(e5) {
        return "# @format\n\n".concat(e5);
    }
};
var NT = {
    locStart: function(e5) {
        return e5.position.start.offset;
    },
    locEnd: function(e5) {
        return e5.position.end.offset;
    }
};
function PT(e5, t2) {
    return e5 && "string" == typeof e5.type && (!t2 || t2.includes(e5.type));
}
function OT(e5) {
    return "prettier-ignore" === e5.value.trim();
}
function IT(e5) {
    return e5 && e5.leadingComments && 0 !== e5.leadingComments.length;
}
function LT(e5) {
    return e5 && e5.middleComments && 0 !== e5.middleComments.length;
}
function MT(e5) {
    return e5 && e5.indicatorComment;
}
function jT(e5) {
    return e5 && e5.trailingComment;
}
function _T(e5) {
    return e5 && e5.endComments && 0 !== e5.endComments.length;
}
function RT(e5) {
    const t2 = [];
    let n2;
    for (const r2 of e5.split(/( +)/g))" " !== r2 ? " " === n2 ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : (void 0) === n2 && t2.unshift(""), n2 = r2;
    return " " === n2 && t2.push((t2.pop() || "") + " "), "" === t2[0] && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
}
function TB(e5) {
    if (!e5) return !0;
    switch(e5.type){
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
        case "alias":
        case "flowMapping":
        case "flowSequence":
            return !0;
        default:
            return !1;
    }
}
function PB(e5, t2) {
    if (!e5) return !0;
    switch(e5.type){
        case "plain":
        case "quoteSingle":
        case "quoteDouble": break;
        case "alias":
            return !0;
        default:
            return !1;
    }
    if ("preserve" === t2.proseWrap) return e5.position.start.line === e5.position.end.line;
    if (/\\$/m.test(t2.originalText.slice(e5.position.start.offset, e5.position.end.offset))) return !1;
    switch(t2.proseWrap){
        case "never":
            return !e5.value.includes("\n");
        case "always":
            return !/[\n ]/.test(e5.value);
        default:
            return !1;
    }
}
function OB(e5) {
    return e5.key.content && "alias" === e5.key.content.type;
}
const LB = new WeakMap;
var t2 = function(t3, e5) {
    const s2 = new SyntaxError(t3 + " (" + e5.start.line + ":" + e5.start.column + ")");
    return (s2.loc = e5, s2);
}, e5 = (t3)=>"string" == typeof t3 ? t3.replace((({ onlyFirst: t4 = !1  } = {
    })=>{
        const e6 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(e6, t4 ? void 0 : "g");
    })(), "") : t3
;
const s2 = (t3)=>!Number.isNaN(t3) && (t3 >= 4352 && (t3 <= 4447 || 9001 === t3 || 9002 === t3 || 11904 <= t3 && t3 <= 12871 && 12351 !== t3 || 12880 <= t3 && t3 <= 19903 || 19968 <= t3 && t3 <= 42182 || 43360 <= t3 && t3 <= 43388 || 44032 <= t3 && t3 <= 55203 || 63744 <= t3 && t3 <= 64255 || 65040 <= t3 && t3 <= 65049 || 65072 <= t3 && t3 <= 65131 || 65281 <= t3 && t3 <= 65376 || 65504 <= t3 && t3 <= 65510 || 110592 <= t3 && t3 <= 110593 || 127488 <= t3 && t3 <= 127569 || 131072 <= t3 && t3 <= 262141))
;
var r2 = s2, i2 = s2;
r2.default = i2;
const n2 = (t3)=>{
    if ("string" != typeof (t3 = t3.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === t3.length) return 0;
    t3 = e5(t3);
    let s3 = 0;
    for(let e6 = 0; e6 < t3.length; e6++){
        const i3 = t3.codePointAt(e6);
        i3 <= 31 || i3 >= 127 && i3 <= 159 || (i3 >= 768 && i3 <= 879 || (i3 > 65535 && e6++, s3 += r2(i3) ? 2 : 1));
    }
    return s3;
};
var a2 = n2, o3 = n2;
a2.default = o3;
var u2 = (t3)=>{
    if ("string" != typeof t3) throw new TypeError("Expected a string");
    return t3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function h1(t3, e6) {
    return e6 || (e6 = t3.slice(0)), Object.freeze(Object.defineProperties(t3, {
        raw: {
            value: Object.freeze(e6)
        }
    }));
}
var c2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function p2() {
    throw new Error("setTimeout has not been defined");
}
function l2() {
    throw new Error("clearTimeout has not been defined");
}
var d2 = p2, D1 = l2;
function m1(t3) {
    if (d2 === setTimeout) return setTimeout(t3, 0);
    if ((d2 === p2 || !d2) && setTimeout) return d2 = setTimeout, setTimeout(t3, 0);
    try {
        return d2(t3, 0);
    } catch (e) {
        try {
            return d2.call(null, t3, 0);
        } catch (e) {
            return d2.call(this, t3, 0);
        }
    }
}
"function" == typeof c2.setTimeout && (d2 = setTimeout), "function" == typeof c2.clearTimeout && (D1 = clearTimeout);
var f1, y1 = [], E1 = !1, A1 = -1;
function F1(t3, e6) {
    this.fun = t3, this.array = e6;
}
F1.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function g1() {
}
var b1 = g1, P1 = g1, T1 = g1, w1 = g1, B = g1, S = g1, N1 = g1;
var I3 = c2.performance || {
}, v1 = I3.now || I3.mozNow || I3.msNow || I3.oNow || I3.webkitNow || function() {
    return (new Date).getTime();
};
var k1 = new Date;
var M3 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
};
function R1(t3, e6, s3) {
    return t3(s3 = {
        path: e6,
        exports: {
        },
        require: function(t4, e7) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == e7 && s3.path);
        }
    }, s3.exports), s3.exports;
}
function _1(t3) {
    return t3 && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
}
const U1 = /^[0-9]+$/, q1 = (t3, e6)=>{
    const s3 = U1.test(t3), r3 = U1.test(e6);
    return s3 && r3 && (t3 = +t3, e6 = +e6), t3 === e6 ? 0 : s3 && !r3 ? -1 : r3 && !s3 ? 1 : t3 < e6 ? -1 : 1;
};
var V1 = {
    compareIdentifiers: q1,
    rcompareIdentifiers: (t3, e6)=>q1(e6, t3)
};
function et1() {
    const t3 = h1([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return et1 = function() {
        return t3;
    }, t3;
}
function st() {
    const t3 = h1([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return st = function() {
        return t3;
    }, t3;
}
function rt1() {
    const t3 = h1([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return rt1 = function() {
        return t3;
    }, t3;
}
function it() {
    const t3 = h1([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return it = function() {
        return t3;
    }, t3;
}
function nt1() {
    const t3 = h1([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return nt1 = function() {
        return t3;
    }, t3;
}
function at() {
    const t3 = h1([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return at = function() {
        return t3;
    }, t3;
}
function mt1(t3) {
    return (e6, s3, r3)=>{
        const i3 = r3 && r3.backwards;
        if (!1 === s3) return !1;
        const { length: n4  } = e6;
        let a3 = s3;
        for(; a3 >= 0 && a3 < n4;){
            const s4 = e6.charAt(a3);
            if (t3 instanceof RegExp) {
                if (!t3.test(s4)) return a3;
            } else if (!t3.includes(s4)) return a3;
            i3 ? a3-- : a3++;
        }
        return (-1 === a3 || a3 === n4) && a3;
    };
}
const ft = mt1(/\s/), yt1 = mt1(" \t"), Et1 = mt1(",; \t"), At1 = mt1(/[^\n\r]/);
function Ct1(t3, e6) {
    if (!1 === e6) return !1;
    if ("/" === t3.charAt(e6) && "*" === t3.charAt(e6 + 1)) for(let s3 = e6 + 2; s3 < t3.length; ++s3)if ("*" === t3.charAt(s3) && "/" === t3.charAt(s3 + 1)) return s3 + 2;
    return e6;
}
function xt1(t3, e6) {
    return !1 !== e6 && ("/" === t3.charAt(e6) && "/" === t3.charAt(e6 + 1) ? At1(t3, e6) : e6);
}
function Ft1(t3, e6, s3) {
    const r3 = s3 && s3.backwards;
    if (!1 === e6) return !1;
    const i3 = t3.charAt(e6);
    if (r3) {
        if ("\r" === t3.charAt(e6 - 1) && "\n" === i3) return e6 - 2;
        if ("\n" === i3 || "\r" === i3 || "\u2028" === i3 || "\u2029" === i3) return e6 - 1;
    } else {
        if ("\r" === i3 && "\n" === t3.charAt(e6 + 1)) return e6 + 2;
        if ("\n" === i3 || "\r" === i3 || "\u2028" === i3 || "\u2029" === i3) return e6 + 1;
    }
    return e6;
}
function gt1(t3, e6, s3) {
    const r3 = yt1(t3, (s3 = s3 || {
    }).backwards ? e6 - 1 : e6, s3);
    return r3 !== Ft1(t3, r3, s3);
}
function bt1(t3, e6) {
    let s3 = null, r3 = e6;
    for(; r3 !== s3;)s3 = r3, r3 = Et1(t3, r3), r3 = Ct1(t3, r3), r3 = yt1(t3, r3);
    return r3 = xt1(t3, r3), r3 = Ft1(t3, r3), !1 !== r3 && gt1(t3, r3);
}
function Pt(t3, e6) {
    let s3 = null, r3 = e6;
    for(; r3 !== s3;)s3 = r3, r3 = yt1(t3, r3), r3 = Ct1(t3, r3), r3 = xt1(t3, r3), r3 = Ft1(t3, r3);
    return r3;
}
function Tt1(t3, e6, s3) {
    return Pt(t3, s3(e6));
}
function wt1(t3, e6, s3) {
    let r3 = 0;
    for(let i3 = s3 = s3 || 0; i3 < t3.length; ++i3)"\t" === t3[i3] ? r3 = r3 + e6 - r3 % e6 : r3++;
    return r3;
}
function Bt1(t3, e6) {
    const s3 = t3.slice(1, -1), r3 = {
        quote: '"',
        regex: /"/g
    }, i3 = {
        quote: "'",
        regex: /'/g
    }, n4 = "'" === e6 ? i3 : r3, a3 = n4 === i3 ? r3 : i3;
    let o4 = n4.quote;
    if (s3.includes(n4.quote) || s3.includes(a3.quote)) {
        o4 = (s3.match(n4.regex) || []).length > (s3.match(a3.regex) || []).length ? a3.quote : n4.quote;
    }
    return o4;
}
function St1(t3, e6, s3) {
    const r3 = '"' === e6 ? "'" : '"', i3 = t3.replace(/\\([\S\s])|(["'])/g, (t4, i4, n4)=>i4 === r3 ? i4 : n4 === e6 ? "\\" + n4 : n4 || (s3 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i4) ? i4 : "\\" + i4)
    );
    return e6 + i3 + e6;
}
function Nt(t3, e6) {
    (t3.comments || (t3.comments = [])).push(e6), e6.printed = !1, "JSXText" === t3.type && (e6.printed = !0);
}
const kt1 = (t3)=>{
    if ("string" != typeof t3) throw new TypeError("Expected a string");
    const e6 = t3.match(/(?:\r?\n)/g) || [];
    if (0 === e6.length) return;
    const s3 = e6.filter((t4)=>"\r\n" === t4
    ).length;
    return s3 > e6.length - s3 ? "\r\n" : "\n";
};
var Lt = kt1;
Lt.graceful = (t3)=>"string" == typeof t3 && kt1(t3) || "\n"
;
var Rt = {
    guessEndOfLine: function(t3) {
        const e6 = t3.indexOf("\r");
        return e6 >= 0 ? "\n" === t3.charAt(e6 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(t3) {
        switch(t3){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(t3, e6) {
        let s3;
        if ("\n" === e6) s3 = /\n/g;
        else if ("\r" === e6) s3 = /\r/g;
        else {
            if ("\r\n" !== e6) throw new Error('Unexpected "eol" '.concat(JSON.stringify(e6), "."));
            s3 = /\r\n/g;
        }
        const r3 = t3.match(s3);
        return r3 ? r3.length : 0;
    },
    normalizeEndOfLine: function(t3) {
        return t3.replace(/\r\n?/g, "\n");
    }
};
function Gt1(t3, e6) {
    const { ignoreDecorators: s3  } = e6 || {
    };
    if (!s3) {
        const e7 = t3.declaration && t3.declaration.decorators || t3.decorators;
        if (e7 && e7.length > 0) return Gt1(e7[0]);
    }
    return t3.range ? t3.range[0] : t3.start;
}
function Xt1(t3) {
    const e6 = t3.range ? t3.range[1] : t3.end;
    return t3.typeAnnotation ? Math.max(e6, Xt1(t3.typeAnnotation)) : e6;
}
function Kt1(t3, e6) {
    return Gt1(t3) === Gt1(e6);
}
var Jt1 = {
    locStart: Gt1,
    locEnd: Xt1,
    composeLoc: function(t3, e6 = t3) {
        const s3 = Gt1(t3);
        return [
            s3,
            "number" == typeof e6 ? s3 + e6 : Xt1(e6)
        ];
    },
    hasSameLocStart: Kt1,
    hasSameLoc: function(t3, e6) {
        return Kt1(t3, e6) && function(t4, e7) {
            return Xt1(t4) === Xt1(e7);
        }(t3, e6);
    }
}, $t1 = R1(function(t3) {
    !(function() {
        function e6(t4) {
            if (null == t4) return !1;
            switch(t4.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                    return !0;
            }
            return !1;
        }
        function s3(t4) {
            switch(t4.type){
                case "IfStatement":
                    return null != t4.alternate ? t4.alternate : t4.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                    return t4.body;
            }
            return null;
        }
        t3.exports = {
            isExpression: function(t4) {
                if (null == t4) return !1;
                switch(t4.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                        return !0;
                }
                return !1;
            },
            isStatement: e6,
            isIterationStatement: function(t4) {
                if (null == t4) return !1;
                switch(t4.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                        return !0;
                }
                return !1;
            },
            isSourceElement: function(t4) {
                return e6(t4) || null != t4 && "FunctionDeclaration" === t4.type;
            },
            isProblematicIfStatement: function(t4) {
                var e7;
                if ("IfStatement" !== t4.type) return !1;
                if (null == t4.alternate) return !1;
                e7 = t4.consequent;
                do {
                    if ("IfStatement" === e7.type && null == e7.alternate) return !0;
                    e7 = s3(e7);
                }while (e7)
                return !1;
            },
            trailingStatement: s3
        };
    })();
}), Yt1 = R1(function(t3) {
    !(function() {
        var e6, s3, r3, i3, n4, a3;
        function o4(t4) {
            return t4 <= 65535 ? String.fromCharCode(t4) : String.fromCharCode(Math.floor((t4 - 65536) / 1024) + 55296) + String.fromCharCode((t4 - 65536) % 1024 + 56320);
        }
        for(s3 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        }, e6 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        }, r3 = [
            5760,
            8192,
            8193,
            8194,
            8195,
            8196,
            8197,
            8198,
            8199,
            8200,
            8201,
            8202,
            8239,
            8287,
            12288,
            65279
        ], i3 = new Array(128), a3 = 0; a3 < 128; ++a3)i3[a3] = a3 >= 97 && a3 <= 122 || a3 >= 65 && a3 <= 90 || 36 === a3 || 95 === a3;
        for(n4 = new Array(128), a3 = 0; a3 < 128; ++a3)n4[a3] = a3 >= 97 && a3 <= 122 || a3 >= 65 && a3 <= 90 || a3 >= 48 && a3 <= 57 || 36 === a3 || 95 === a3;
        t3.exports = {
            isDecimalDigit: function(t4) {
                return 48 <= t4 && t4 <= 57;
            },
            isHexDigit: function(t4) {
                return 48 <= t4 && t4 <= 57 || 97 <= t4 && t4 <= 102 || 65 <= t4 && t4 <= 70;
            },
            isOctalDigit: function(t4) {
                return t4 >= 48 && t4 <= 55;
            },
            isWhiteSpace: function(t4) {
                return 32 === t4 || 9 === t4 || 11 === t4 || 12 === t4 || 160 === t4 || t4 >= 5760 && r3.indexOf(t4) >= 0;
            },
            isLineTerminator: function(t4) {
                return 10 === t4 || 13 === t4 || 8232 === t4 || 8233 === t4;
            },
            isIdentifierStartES5: function(t4) {
                return t4 < 128 ? i3[t4] : s3.NonAsciiIdentifierStart.test(o4(t4));
            },
            isIdentifierPartES5: function(t4) {
                return t4 < 128 ? n4[t4] : s3.NonAsciiIdentifierPart.test(o4(t4));
            },
            isIdentifierStartES6: function(t4) {
                return t4 < 128 ? i3[t4] : e6.NonAsciiIdentifierStart.test(o4(t4));
            },
            isIdentifierPartES6: function(t4) {
                return t4 < 128 ? n4[t4] : e6.NonAsciiIdentifierPart.test(o4(t4));
            }
        };
    })();
}), Qt1 = R1(function(t3) {
    !(function() {
        var e6 = Yt1;
        function s3(t4, e7) {
            return !(!e7 && "yield" === t4) && r3(t4, e7);
        }
        function r3(t4, e7) {
            if (e7 && (function(t5) {
                switch(t5){
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                        return !0;
                    default:
                        return !1;
                }
            })(t4)) return !0;
            switch(t4.length){
                case 2:
                    return "if" === t4 || "in" === t4 || "do" === t4;
                case 3:
                    return "var" === t4 || "for" === t4 || "new" === t4 || "try" === t4;
                case 4:
                    return "this" === t4 || "else" === t4 || "case" === t4 || "void" === t4 || "with" === t4 || "enum" === t4;
                case 5:
                    return "while" === t4 || "break" === t4 || "catch" === t4 || "throw" === t4 || "const" === t4 || "yield" === t4 || "class" === t4 || "super" === t4;
                case 6:
                    return "return" === t4 || "typeof" === t4 || "delete" === t4 || "switch" === t4 || "export" === t4 || "import" === t4;
                case 7:
                    return "default" === t4 || "finally" === t4 || "extends" === t4;
                case 8:
                    return "function" === t4 || "continue" === t4 || "debugger" === t4;
                case 10:
                    return "instanceof" === t4;
                default:
                    return !1;
            }
        }
        function i3(t4, e7) {
            return "null" === t4 || "true" === t4 || "false" === t4 || s3(t4, e7);
        }
        function n4(t4, e7) {
            return "null" === t4 || "true" === t4 || "false" === t4 || r3(t4, e7);
        }
        function a3(t4) {
            var s4, r4, i4;
            if (0 === t4.length) return !1;
            if (i4 = t4.charCodeAt(0), !e6.isIdentifierStartES5(i4)) return !1;
            for(s4 = 1, r4 = t4.length; s4 < r4; ++s4)if (i4 = t4.charCodeAt(s4), !e6.isIdentifierPartES5(i4)) return !1;
            return !0;
        }
        function o4(t4) {
            var s4, r4, i4, n5, a4;
            if (0 === t4.length) return !1;
            for(a4 = e6.isIdentifierStartES6, s4 = 0, r4 = t4.length; s4 < r4; ++s4){
                if (55296 <= (i4 = t4.charCodeAt(s4)) && i4 <= 56319) {
                    if ((++s4) >= r4) return !1;
                    if (!(56320 <= (n5 = t4.charCodeAt(s4)) && n5 <= 57343)) return !1;
                    i4 = 1024 * (i4 - 55296) + (n5 - 56320) + 65536;
                }
                if (!a4(i4)) return !1;
                a4 = e6.isIdentifierPartES6;
            }
            return !0;
        }
        t3.exports = {
            isKeywordES5: s3,
            isKeywordES6: r3,
            isReservedWordES5: i3,
            isReservedWordES6: n4,
            isRestrictedWord: function(t4) {
                return "eval" === t4 || "arguments" === t4;
            },
            isIdentifierNameES5: a3,
            isIdentifierNameES6: o4,
            isIdentifierES5: function(t4, e7) {
                return a3(t4) && !i3(t4, e7);
            },
            isIdentifierES6: function(t4, e7) {
                return o4(t4) && !n4(t4, e7);
            }
        };
    })();
});
function he1(t3, e6) {
    if (!t3 || "object" != typeof t3) return !1;
    if (Array.isArray(t3)) return t3.some((t4)=>he1(t4, e6)
    );
    const s3 = e6(t3);
    return "boolean" == typeof s3 ? s3 : Object.keys(t3).some((s4)=>he1(t3[s4], e6)
    );
}
function ce1(t3) {
    return "AssignmentExpression" === t3.type || "BinaryExpression" === t3.type || "LogicalExpression" === t3.type || "NGPipeExpression" === t3.type || "ConditionalExpression" === t3.type || "CallExpression" === t3.type || "OptionalCallExpression" === t3.type || "MemberExpression" === t3.type || "OptionalMemberExpression" === t3.type || "SequenceExpression" === t3.type || "TaggedTemplateExpression" === t3.type || "BindExpression" === t3.type || "UpdateExpression" === t3.type && !t3.prefix || "TSAsExpression" === t3.type || "TSNonNullExpression" === t3.type;
}
function pe1(t3) {
    return "Block" === t3.type || "CommentBlock" === t3.type || "MultiLine" === t3.type;
}
const le1 = new Set([
    "ExportDefaultDeclaration",
    "ExportDefaultSpecifier",
    "DeclareExportDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration"
]);
function de1(t3) {
    return t3 && le1.has(t3.type);
}
function De1(t3) {
    return "BooleanLiteral" === t3.type || "DirectiveLiteral" === t3.type || "Literal" === t3.type || "NullLiteral" === t3.type || "NumericLiteral" === t3.type || "BigIntLiteral" === t3.type || "DecimalLiteral" === t3.type || "RegExpLiteral" === t3.type || "StringLiteral" === t3.type || "TemplateLiteral" === t3.type || "TSTypeLiteral" === t3.type || "JSXText" === t3.type;
}
function me1(t3) {
    return "NumericLiteral" === t3.type || "Literal" === t3.type && "number" == typeof t3.value;
}
function fe1(t3) {
    return "StringLiteral" === t3.type || "Literal" === t3.type && "string" == typeof t3.value;
}
function ye1(t3) {
    return "FunctionExpression" === t3.type || "ArrowFunctionExpression" === t3.type;
}
function Ee2(t3) {
    return !("CallExpression" !== t3.type && "OptionalCallExpression" !== t3.type || "Identifier" !== t3.callee.type || "async" !== t3.callee.name && "inject" !== t3.callee.name && "fakeAsync" !== t3.callee.name);
}
function Ae1(t3) {
    return "JSXElement" === t3.type || "JSXFragment" === t3.type;
}
function Ce1(t3) {
    return "get" === t3.kind || "set" === t3.kind;
}
const Fe1 = new Set([
    "BinaryExpression",
    "LogicalExpression",
    "NGPipeExpression"
]);
const ge1 = new Set([
    "AnyTypeAnnotation",
    "TSAnyKeyword",
    "NullLiteralTypeAnnotation",
    "TSNullKeyword",
    "ThisTypeAnnotation",
    "TSThisType",
    "NumberTypeAnnotation",
    "TSNumberKeyword",
    "VoidTypeAnnotation",
    "TSVoidKeyword",
    "BooleanTypeAnnotation",
    "TSBooleanKeyword",
    "BigIntTypeAnnotation",
    "TSBigIntKeyword",
    "SymbolTypeAnnotation",
    "TSSymbolKeyword",
    "StringTypeAnnotation",
    "TSStringKeyword",
    "BooleanLiteralTypeAnnotation",
    "StringLiteralTypeAnnotation",
    "BigIntLiteralTypeAnnotation",
    "NumberLiteralTypeAnnotation",
    "TSLiteralType",
    "TSTemplateLiteralType",
    "EmptyTypeAnnotation",
    "MixedTypeAnnotation",
    "TSNeverKeyword",
    "TSObjectKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword"
]);
const be1 = /^(skip|[fx]?(it|describe|test))$/;
function Pe1(t3) {
    return "CallExpression" === t3.type || "OptionalCallExpression" === t3.type;
}
const Te1 = new RegExp("([ \n\r\t]+)"), we1 = new RegExp("[^ \n\r\t]");
function Ne1(t3) {
    return /^(\d+|\d+\.\d+)$/.test(t3);
}
function Ie2(t3) {
    return t3.quasis.some((t4)=>t4.value.raw.includes("\n")
    );
}
function ve1(t3) {
    return t3.extra ? t3.extra.raw : t3.raw;
}
const ke1 = {
    "==": !0,
    "!=": !0,
    "===": !0,
    "!==": !0
}, Le1 = {
    "*": !0,
    "/": !0,
    "%": !0
}, Oe = {
    ">>": !0,
    ">>>": !0,
    "<<": !0
};
const Me1 = {
};
function Re2(t3) {
    return Me1[t3];
}
[
    [
        "|>"
    ],
    [
        "??"
    ],
    [
        "||"
    ],
    [
        "&&"
    ],
    [
        "|"
    ],
    [
        "^"
    ],
    [
        "&"
    ],
    [
        "==",
        "===",
        "!=",
        "!=="
    ],
    [
        "<",
        ">",
        "<=",
        ">=",
        "in",
        "instanceof"
    ],
    [
        ">>",
        "<<",
        ">>>"
    ],
    [
        "+",
        "-"
    ],
    [
        "*",
        "/",
        "%"
    ],
    [
        "**"
    ]
].forEach((t3, e6)=>{
    t3.forEach((t4)=>{
        Me1[t4] = e6;
    });
});
const _e1 = new WeakMap;
function je1(t3) {
    if (_e1.has(t3)) return _e1.get(t3);
    const e6 = [];
    return t3.this && e6.push(t3.this), Array.isArray(t3.parameters) ? e6.push(...t3.parameters) : Array.isArray(t3.params) && e6.push(...t3.params), t3.rest && e6.push(t3.rest), _e1.set(t3, e6), e6;
}
const Ue = new WeakMap;
function qe1(t3) {
    return "prettier-ignore" === t3.value.trim();
}
function Ve1(t3) {
    return t3 && (t3.comments && t3.comments.length > 0 && t3.comments.some((t4)=>qe1(t4) && !t4.unignore
    ) || t3.prettierIgnore);
}
function ze(t3) {
    return Ve1(t3.getValue());
}
function xs(t3) {
    return "ArrowFunctionExpression" === t3.type || "FunctionExpression" === t3.type || "FunctionDeclaration" === t3.type || "ObjectMethod" === t3.type || "ClassMethod" === t3.type || "TSDeclareFunction" === t3.type || "TSCallSignatureDeclaration" === t3.type || "TSConstructSignatureDeclaration" === t3.type || "TSMethodSignature" === t3.type || "TSConstructorType" === t3.type || "TSFunctionType" === t3.type || "TSDeclareMethod" === t3.type;
}
function Is(t3) {
    return "CallExpression" === t3.type ? (t3.type = "OptionalCallExpression", t3.callee = Is(t3.callee)) : "MemberExpression" === t3.type ? (t3.type = "OptionalMemberExpression", t3.object = Is(t3.object)) : "TSNonNullExpression" === t3.type && (t3.expression = Is(t3.expression)), t3;
}
function vs(t3, e6) {
    let s3;
    if (Array.isArray(t3)) s3 = t3.entries();
    else {
        if (!t3 || "object" != typeof t3 || "string" != typeof t3.type) return t3;
        s3 = Object.entries(t3);
    }
    for (const [r3, i3] of s3)t3[r3] = vs(i3, e6);
    return Array.isArray(t3) ? t3 : e6(t3) || t3;
}
function ks(t3) {
    return "LogicalExpression" === t3.type && "LogicalExpression" === t3.right.type && t3.operator === t3.right.operator;
}
const Vs1 = /@(?:no)?flow\b/;
const Ks = new Set([
    "Did not expect a type annotation here.",
    "The only accepted module attribute is `type`",
    "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`"
]);
function Js1(t3) {
    const e6 = t3.errors.find((t4)=>(function(t5) {
            const [, e7] = t5.message.match(/(.*?)\s*\(\d+:\d+\)/);
            return Ks.has(e7);
        })(t4)
    );
    if (e6) throw e6;
    return t3;
}
function $s1(e6, s3) {
    switch(e6.type){
        case "ArrayExpression":
            return e6.elements.forEach(r3);
        case "ObjectExpression":
            return e6.properties.forEach(r3);
        case "ObjectProperty":
            if (e6.computed) throw i3("computed");
            if (e6.shorthand) throw i3("shorthand");
            return [
                e6.key,
                e6.value
            ].forEach(r3);
        case "UnaryExpression":
            switch(e6.operator){
                case "+":
                case "-":
                    return r3(e6.argument);
                default:
                    throw i3("operator");
            }
        case "Identifier":
            if (s3 && "ObjectProperty" === s3.type && s3.key === e6) return;
            throw i3();
        case "NullLiteral":
        case "BooleanLiteral":
        case "NumericLiteral":
        case "StringLiteral":
            return;
        default:
            throw i3();
    }
    function r3(t3) {
        return $s1(t3, e6);
    }
    function i3(s4) {
        const r4 = s4 ? "".concat(e6.type, " with ").concat(s4, "=").concat(JSON.stringify(e6[s4])) : e6.type;
        return t2("".concat(r4, " is not allowed in JSON."), {
            start: {
                line: e6.loc.start.line,
                column: e6.loc.start.column + 1
            }
        });
    }
}
function t3(e6, t4, n4) {
    return e6(n4 = {
        path: t4,
        exports: {
        },
        require: function(e7, t5) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == t5 && n4.path);
        }
    }, n4.exports), n4.exports;
}
var n4 = t3(function(e6, t4) {
    function n4(e7) {
        return t4.$0 <= e7 && e7 <= t4.$9;
    }
    Object.defineProperty(t4, "__esModule", {
        value: !0
    }), t4.$EOF = 0, t4.$BSPACE = 8, t4.$TAB = 9, t4.$LF = 10, t4.$VTAB = 11, t4.$FF = 12, t4.$CR = 13, t4.$SPACE = 32, t4.$BANG = 33, t4.$DQ = 34, t4.$HASH = 35, t4.$$ = 36, t4.$PERCENT = 37, t4.$AMPERSAND = 38, t4.$SQ = 39, t4.$LPAREN = 40, t4.$RPAREN = 41, t4.$STAR = 42, t4.$PLUS = 43, t4.$COMMA = 44, t4.$MINUS = 45, t4.$PERIOD = 46, t4.$SLASH = 47, t4.$COLON = 58, t4.$SEMICOLON = 59, t4.$LT = 60, t4.$EQ = 61, t4.$GT = 62, t4.$QUESTION = 63, t4.$0 = 48, t4.$7 = 55, t4.$9 = 57, t4.$A = 65, t4.$E = 69, t4.$F = 70, t4.$X = 88, t4.$Z = 90, t4.$LBRACKET = 91, t4.$BACKSLASH = 92, t4.$RBRACKET = 93, t4.$CARET = 94, t4.$_ = 95, t4.$a = 97, t4.$b = 98, t4.$e = 101, t4.$f = 102, t4.$n = 110, t4.$r = 114, t4.$t = 116, t4.$u = 117, t4.$v = 118, t4.$x = 120, t4.$z = 122, t4.$LBRACE = 123, t4.$BAR = 124, t4.$RBRACE = 125, t4.$NBSP = 160, t4.$PIPE = 124, t4.$TILDA = 126, t4.$AT = 64, t4.$BT = 96, t4.isWhitespace = function(e7) {
        return e7 >= t4.$TAB && e7 <= t4.$SPACE || e7 == t4.$NBSP;
    }, t4.isDigit = n4, t4.isAsciiLetter = function(e7) {
        return e7 >= t4.$a && e7 <= t4.$z || e7 >= t4.$A && e7 <= t4.$Z;
    }, t4.isAsciiHexDigit = function(e7) {
        return e7 >= t4.$a && e7 <= t4.$f || e7 >= t4.$A && e7 <= t4.$F || n4(e7);
    }, t4.isNewLine = function(e7) {
        return e7 === t4.$LF || e7 === t4.$CR;
    }, t4.isOctalDigit = function(e7) {
        return t4.$0 <= e7 && e7 <= t4.$7;
    };
}), r3 = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    class n5 {
        constructor(e7, t5, n6){
            this.filePath = e7, this.name = t5, this.members = n6;
        }
        assertNoMembers() {
            if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
        }
    }
    t4.StaticSymbol = n5;
    t4.StaticSymbolCache = class {
        constructor(){
            this.cache = new Map;
        }
        get(e, t, r) {
            const s3 = (r = r || []).length ? ".".concat(r.join(".")) : "", i3 = '"'.concat(e, '".').concat(t).concat(s3);
            let o4 = this.cache.get(i3);
            return o4 || (o4 = new n5(e, t, r), this.cache.set(i3, o4)), o4;
        }
    };
}), s3 = t3(function(t4, n5) {
    Object.defineProperty(n5, "__esModule", {
        value: !0
    });
    const r4 = /-+([a-z0-9])/g;
    function s3(e6, t5, n6) {
        const r5 = e6.indexOf(t5);
        return -1 == r5 ? n6 : [
            e6.slice(0, r5).trim(),
            e6.slice(r5 + 1).trim()
        ];
    }
    function i3(e6, t5, n6) {
        return Array.isArray(e6) ? t5.visitArray(e6, n6) : "object" == typeof (r5 = e6) && null !== r5 && Object.getPrototypeOf(r5) === u3 ? t5.visitStringMap(e6, n6) : null == e6 || "string" == typeof e6 || "number" == typeof e6 || "boolean" == typeof e6 ? t5.visitPrimitive(e6, n6) : t5.visitOther(e6, n6);
        var r5;
    }
    n5.dashCaseToCamelCase = function(e6) {
        return e6.replace(r4, (...e7)=>e7[1].toUpperCase()
        );
    }, n5.splitAtColon = function(e6, t5) {
        return s3(e6, ":", t5);
    }, n5.splitAtPeriod = function(e6, t5) {
        return s3(e6, ".", t5);
    }, n5.visitValue = i3, n5.isDefined = function(e6) {
        return null != e6;
    }, n5.noUndefined = function(e6) {
        return (void 0) === e6 ? null : e6;
    };
    n5.ValueTransformer = class {
        visitArray(e, t) {
            return e.map((e6)=>i3(e6, this, t)
            );
        }
        visitStringMap(e, t) {
            const n6 = {
            };
            return Object.keys(e).forEach((r5)=>{
                n6[r5] = i3(e[r5], this, t);
            }), n6;
        }
        visitPrimitive(e, t) {
            return e;
        }
        visitOther(e, t) {
            return e;
        }
    }, n5.SyncAsync = {
        assertSync: (e6)=>{
            if (c3(e6)) throw new Error("Illegal state: value cannot be a promise");
            return e6;
        },
        then: (e6, t5)=>c3(e6) ? e6.then(t5) : t5(e6)
        ,
        all: (e6)=>e6.some(c3) ? Promise.all(e6) : e6
    }, n5.error = function(e6) {
        throw new Error("Internal Error: ".concat(e6));
    }, n5.syntaxError = function(e6, t5) {
        const n6 = Error(e6);
        return n6[o4] = !0, t5 && (n6[a3] = t5), n6;
    };
    const o4 = "ngSyntaxError", a3 = "ngParseErrors";
    n5.isSyntaxError = function(e6) {
        return e6[o4];
    }, n5.getParseErrors = function(e6) {
        return e6[a3] || [];
    }, n5.escapeRegExp = function(e6) {
        return e6.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const u3 = Object.getPrototypeOf({
    });
    function c3(e6) {
        return !!e6 && "function" == typeof e6.then;
    }
    n5.utf8Encode = function(e6) {
        let t5 = "";
        for(let n6 = 0; n6 < e6.length; n6++){
            let r5 = e6.charCodeAt(n6);
            if (r5 >= 55296 && r5 <= 56319 && e6.length > n6 + 1) {
                const t7 = e6.charCodeAt(n6 + 1);
                t7 >= 56320 && t7 <= 57343 && (n6++, r5 = (r5 - 55296 << 10) + t7 - 56320 + 65536);
            }
            r5 <= 127 ? t5 += String.fromCharCode(r5) : r5 <= 2047 ? t5 += String.fromCharCode(r5 >> 6 & 31 | 192, 63 & r5 | 128) : r5 <= 65535 ? t5 += String.fromCharCode(r5 >> 12 | 224, r5 >> 6 & 63 | 128, 63 & r5 | 128) : r5 <= 2097151 && (t5 += String.fromCharCode(r5 >> 18 & 7 | 240, r5 >> 12 & 63 | 128, r5 >> 6 & 63 | 128, 63 & r5 | 128));
        }
        return t5;
    }, n5.stringify = function e6(t5) {
        if ("string" == typeof t5) return t5;
        if (t5 instanceof Array) return "[" + t5.map(e6).join(", ") + "]";
        if (null == t5) return "" + t5;
        if (t5.overriddenName) return "".concat(t5.overriddenName);
        if (t5.name) return "".concat(t5.name);
        if (!t5.toString) return "object";
        const n6 = t5.toString();
        if (null == n6) return "" + n6;
        const r5 = n6.indexOf("\n");
        return -1 === r5 ? n6 : n6.substring(0, r5);
    }, n5.resolveForwardRef = function(e7) {
        return "function" == typeof e7 && e7.hasOwnProperty("__forward_ref__") ? e7() : e7;
    }, n5.isPromise = c3;
    n5.Version = class {
        constructor(e7){
            this.full = e7;
            const t5 = e7.split(".");
            this.major = t5[0], this.minor = t5[1], this.patch = t5.slice(2).join(".");
        }
    };
    const l3 = "undefined" != typeof window && window, p3 = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, D2 = (void 0) !== e6 && e6 || l3 || p3;
    n5.global = D2;
}), i3 = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    const n5 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function i3(e7) {
        return e7.replace(/\W/g, "_");
    }
    t4.sanitizeIdentifier = i3;
    let o4 = 0;
    function a3(e7) {
        if (!e7 || !e7.reference) return null;
        const t5 = e7.reference;
        if (t5 instanceof r3.StaticSymbol) return t5.name;
        if (t5.__anonymousType) return t5.__anonymousType;
        let n6 = s3.stringify(t5);
        return (n6.indexOf("(") >= 0 ? (n6 = "anonymous_".concat(o4++), t5.__anonymousType = n6) : n6 = i3(n6), n6);
    }
    var u3;
    t4.identifierName = a3, t4.identifierModuleUrl = function(e7) {
        const t5 = e7.reference;
        return t5 instanceof r3.StaticSymbol ? t5.filePath : "./".concat(s3.stringify(t5));
    }, t4.viewClassName = function(e7, t5) {
        return "View_".concat(a3({
            reference: e7
        }), "_").concat(t5);
    }, t4.rendererTypeName = function(e7) {
        return "RenderType_".concat(a3({
            reference: e7
        }));
    }, t4.hostViewClassName = function(e7) {
        return "HostView_".concat(a3({
            reference: e7
        }));
    }, t4.componentFactoryName = function(e7) {
        return "".concat(a3({
            reference: e7
        }), "NgFactory");
    }, (function(e7) {
        e7[e7.Pipe = 0] = "Pipe", e7[e7.Directive = 1] = "Directive", e7[e7.NgModule = 2] = "NgModule", e7[e7.Injectable = 3] = "Injectable";
    })(u3 = t4.CompileSummaryKind || (t4.CompileSummaryKind = {
    })), t4.tokenName = function(e7) {
        return null != e7.value ? i3(e7.value) : a3(e7.identifier);
    }, t4.tokenReference = function(e7) {
        return null != e7.identifier ? e7.identifier.reference : e7.value;
    };
    t4.CompileStylesheetMetadata = class {
        constructor({ moduleUrl: e7 , styles: t5 , styleUrls: n6  } = {
        }){
            this.moduleUrl = e7 || null, this.styles = l3(t5), this.styleUrls = l3(n6);
        }
    };
    t4.CompileTemplateMetadata = class {
        constructor({ encapsulation: e8 , template: t7 , templateUrl: n7 , htmlAst: r4 , styles: s4 , styleUrls: i4 , externalStylesheets: o5 , animations: a4 , ngContentSelectors: u4 , interpolation: c3 , isInline: D2 , preserveWhitespaces: h2  }){
            if (this.encapsulation = e8, this.template = t7, this.templateUrl = n7, this.htmlAst = r4, this.styles = l3(s4), this.styleUrls = l3(i4), this.externalStylesheets = l3(o5), this.animations = a4 ? p5(a4) : [], this.ngContentSelectors = u4 || [], c3 && 2 != c3.length) throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = c3, this.isInline = D2, this.preserveWhitespaces = h2;
        }
        toSummary() {
            return {
                ngContentSelectors: this.ngContentSelectors,
                encapsulation: this.encapsulation,
                styles: this.styles,
                animations: this.animations
            };
        }
    };
    class c4 {
        static create({ isHost: e , type: t , isComponent: r , selector: i , exportAs: o , changeDetection: a , inputs: u , outputs: l , host: p , providers: D , viewProviders: h , queries: d , guards: f , viewQueries: m , entryComponents: g , template: E , componentViewType: C , rendererType: T , componentFactory: y  }) {
            const S1 = {
            }, _2 = {
            }, b2 = {
            };
            null != p && Object.keys(p).forEach((e9)=>{
                const t8 = p[e9], r5 = e9.match(n5);
                null === r5 ? b2[e9] = t8 : null != r5[1] ? _2[r5[1]] = t8 : null != r5[2] && (S1[r5[2]] = t8);
            });
            const F2 = {
            };
            null != u && u.forEach((e9)=>{
                const t8 = s3.splitAtColon(e9, [
                    e9,
                    e9
                ]);
                F2[t8[0]] = t8[1];
            });
            const A2 = {
            };
            return null != l && l.forEach((e9)=>{
                const t8 = s3.splitAtColon(e9, [
                    e9,
                    e9
                ]);
                A2[t8[0]] = t8[1];
            }), new c4({
                isHost: e,
                type: t,
                isComponent: !!r,
                selector: i,
                exportAs: o,
                changeDetection: a,
                inputs: F2,
                outputs: A2,
                hostListeners: S1,
                hostProperties: _2,
                hostAttributes: b2,
                providers: D,
                viewProviders: h,
                queries: d,
                guards: f,
                viewQueries: m,
                entryComponents: g,
                template: E,
                componentViewType: C,
                rendererType: T,
                componentFactory: y
            });
        }
        constructor({ isHost: e9 , type: t8 , isComponent: n8 , selector: r5 , exportAs: s5 , changeDetection: i5 , inputs: o6 , outputs: a5 , hostListeners: u5 , hostProperties: c5 , hostAttributes: p3 , providers: D4 , viewProviders: h4 , queries: d3 , guards: f3 , viewQueries: m3 , entryComponents: g2 , template: E3 , componentViewType: C2 , rendererType: T2 , componentFactory: y3  }){
            this.isHost = !!e9, this.type = t8, this.isComponent = n8, this.selector = r5, this.exportAs = s5, this.changeDetection = i5, this.inputs = o6, this.outputs = a5, this.hostListeners = u5, this.hostProperties = c5, this.hostAttributes = p3, this.providers = l3(D4), this.viewProviders = l3(h4), this.queries = l3(d3), this.guards = f3, this.viewQueries = l3(m3), this.entryComponents = l3(g2), this.template = E3, this.componentViewType = C2, this.rendererType = T2, this.componentFactory = y3;
        }
        toSummary() {
            return {
                summaryKind: u3.Directive,
                type: this.type,
                isComponent: this.isComponent,
                selector: this.selector,
                exportAs: this.exportAs,
                inputs: this.inputs,
                outputs: this.outputs,
                hostListeners: this.hostListeners,
                hostProperties: this.hostProperties,
                hostAttributes: this.hostAttributes,
                providers: this.providers,
                viewProviders: this.viewProviders,
                queries: this.queries,
                guards: this.guards,
                viewQueries: this.viewQueries,
                entryComponents: this.entryComponents,
                changeDetection: this.changeDetection,
                template: this.template && this.template.toSummary(),
                componentViewType: this.componentViewType,
                rendererType: this.rendererType,
                componentFactory: this.componentFactory
            };
        }
    }
    t4.CompileDirectiveMetadata = c4;
    t4.CompilePipeMetadata = class {
        constructor({ type: e10 , name: t9 , pure: n9  }){
            this.type = e10, this.name = t9, this.pure = !!n9;
        }
        toSummary() {
            return {
                summaryKind: u3.Pipe,
                type: this.type,
                name: this.name,
                pure: this.pure
            };
        }
    };
    t4.CompileShallowModuleMetadata = class {
    };
    t4.CompileNgModuleMetadata = class {
        constructor({ type: e13 , providers: t10 , declaredDirectives: n10 , exportedDirectives: r6 , declaredPipes: s6 , exportedPipes: i6 , entryComponents: o7 , bootstrapComponents: a6 , importedModules: u6 , exportedModules: c6 , schemas: p4 , transitiveModule: D5 , id: h5  }){
            this.type = e13 || null, this.declaredDirectives = l3(n10), this.exportedDirectives = l3(r6), this.declaredPipes = l3(s6), this.exportedPipes = l3(i6), this.providers = l3(t10), this.entryComponents = l3(o7), this.bootstrapComponents = l3(a6), this.importedModules = l3(u6), this.exportedModules = l3(c6), this.schemas = l3(p4), this.id = h5 || null, this.transitiveModule = D5 || null;
        }
        toSummary() {
            const e14 = this.transitiveModule;
            return {
                summaryKind: u3.NgModule,
                type: this.type,
                entryComponents: e14.entryComponents,
                providers: e14.providers,
                modules: e14.modules,
                exportedDirectives: e14.exportedDirectives,
                exportedPipes: e14.exportedPipes
            };
        }
    };
    function l3(e14) {
        return e14 || [];
    }
    t4.TransitiveCompileNgModuleMetadata = class {
        constructor(){
            this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
        }
        addProvider(e, t) {
            this.providers.push({
                provider: e,
                module: t
            });
        }
        addDirective(e) {
            this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e));
        }
        addExportedDirective(e) {
            this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e));
        }
        addPipe(e) {
            this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e));
        }
        addExportedPipe(e) {
            this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e));
        }
        addModule(e) {
            this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e));
        }
        addEntryComponent(e) {
            this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e));
        }
    };
    function p5(e14) {
        return e14.reduce((e15, t11)=>{
            const n11 = Array.isArray(t11) ? p5(t11) : t11;
            return e15.concat(n11);
        }, []);
    }
    function D6(e14) {
        return e14.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t4.ProviderMeta = class {
        constructor(e14, { useClass: t11 , useValue: n11 , useExisting: r7 , useFactory: s7 , deps: i7 , multi: o8  }){
            this.token = e14, this.useClass = t11 || null, this.useValue = n11, this.useExisting = r7, this.useFactory = s7 || null, this.dependencies = i7 || null, this.multi = !!o8;
        }
    }, t4.flatten = p5, t4.templateSourceUrl = function(e15, t12, n12) {
        let s8;
        return s8 = n12.isInline ? t12.type.reference instanceof r3.StaticSymbol ? "".concat(t12.type.reference.filePath, ".").concat(t12.type.reference.name, ".html") : "".concat(a3(e15), "/").concat(a3(t12.type), ".html") : n12.templateUrl, t12.type.reference instanceof r3.StaticSymbol ? s8 : D6(s8);
    }, t4.sharedStylesheetJitUrl = function(e15, t12) {
        const n12 = e15.moduleUrl.split(/\/\\/g), r8 = n12[n12.length - 1];
        return D6("css/".concat(t12).concat(r8, ".ngstyle.js"));
    }, t4.ngModuleJitUrl = function(e15) {
        return D6("".concat(a3(e15.type), "/module.ngfactory.js"));
    }, t4.templateJitUrl = function(e15, t12) {
        return D6("".concat(a3(e15), "/").concat(a3(t12.type), ".ngfactory.js"));
    };
}), o4 = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    class r4 {
        constructor(e7, t5, n5, r5){
            this.file = e7, this.offset = t5, this.line = n5, this.col = r5;
        }
        toString() {
            return null != this.offset ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
        moveBy(e) {
            const t7 = this.file.content, s4 = t7.length;
            let i4 = this.offset, o5 = this.line, a3 = this.col;
            for(; i4 > 0 && e < 0;){
                i4--, e++;
                if (t7.charCodeAt(i4) == n4.$LF) {
                    o5--;
                    const e8 = t7.substr(0, i4 - 1).lastIndexOf(String.fromCharCode(n4.$LF));
                    a3 = e8 > 0 ? i4 - e8 : i4;
                } else a3--;
            }
            for(; i4 < s4 && e > 0;){
                const r6 = t7.charCodeAt(i4);
                i4++, e--, r6 == n4.$LF ? (o5++, a3 = 0) : a3++;
            }
            return new r4(this.file, i4, o5, a3);
        }
        getContext(e, t) {
            const n6 = this.file.content;
            let r6 = this.offset;
            if (null != r6) {
                r6 > n6.length - 1 && (r6 = n6.length - 1);
                let s4 = r6, i4 = 0, o5 = 0;
                for(; i4 < e && r6 > 0 && (r6--, i4++, "\n" != n6[r6] || (++o5) != t););
                for(i4 = 0, o5 = 0; i4 < e && s4 < n6.length - 1 && (s4++, i4++, "\n" != n6[s4] || (++o5) != t););
                return {
                    before: n6.substring(r6, this.offset),
                    after: n6.substring(this.offset, s4 + 1)
                };
            }
            return null;
        }
    }
    t4.ParseLocation = r4;
    class s4 {
        constructor(e8, t7){
            this.content = e8, this.url = t7;
        }
    }
    t4.ParseSourceFile = s4;
    class o5 {
        constructor(e9, t8, n6 = null){
            this.start = e9, this.end = t8, this.details = n6;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var a3;
    t4.ParseSourceSpan = o5, t4.EMPTY_PARSE_LOCATION = new r4(new s4("", ""), 0, 0, 0), t4.EMPTY_SOURCE_SPAN = new o5(t4.EMPTY_PARSE_LOCATION, t4.EMPTY_PARSE_LOCATION), (function(e10) {
        e10[e10.WARNING = 0] = "WARNING", e10[e10.ERROR = 1] = "ERROR";
    })(a3 = t4.ParseErrorLevel || (t4.ParseErrorLevel = {
    }));
    t4.ParseError = class {
        constructor(e10, t9, n7 = a3.ERROR){
            this.span = e10, this.msg = t9, this.level = n7;
        }
        contextualMessage() {
            const e13 = this.span.start.getContext(100, 3);
            return e13 ? "".concat(this.msg, ' ("').concat(e13.before, "[").concat(a3[this.level], " ->]").concat(e13.after, '")') : this.msg;
        }
        toString() {
            const e13 = this.span.details ? ", ".concat(this.span.details) : "";
            return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e13);
        }
    }, t4.typeSourceSpan = function(e13, t10) {
        const n8 = i3.identifierModuleUrl(t10), a4 = null != n8 ? "in ".concat(e13, " ").concat(i3.identifierName(t10), " in ").concat(n8) : "in ".concat(e13, " ").concat(i3.identifierName(t10)), u3 = new s4("", a4);
        return new o5(new r4(u3, -1, -1, -1), new r4(u3, -1, -1, -1));
    }, t4.r3JitTypeSourceSpan = function(e13, t10, n8) {
        const i4 = "in ".concat(e13, " ").concat(t10, " in ").concat(n8), a4 = new s4("", i4);
        return new o5(new r4(a4, -1, -1, -1), new r4(a4, -1, -1, -1));
    };
}), a3 = (e6)=>{
    if ("string" != typeof e6) throw new TypeError("Expected a string");
    return e6.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function u3(e6) {
    return {
        type: "concat",
        parts: e6
    };
}
function c3(e6) {
    return {
        type: "indent",
        contents: e6
    };
}
function l3(e6, t4) {
    return {
        type: "align",
        contents: t4,
        n: e6
    };
}
function p3(e6, t4) {
    return {
        type: "group",
        id: (t4 = t4 || {
        }).id,
        contents: e6,
        break: !!t4.shouldBreak,
        expandedStates: t4.expandedStates
    };
}
const D2 = {
    type: "break-parent"
}, h2 = u3([
    {
        type: "line",
        hard: !0
    },
    D2
]), d3 = u3([
    {
        type: "line",
        hard: !0,
        literal: !0
    },
    D2
]);
var f3 = {
    concat: u3,
    join: function(e6, t4) {
        const n5 = [];
        for(let r4 = 0; r4 < t4.length; r4++)0 !== r4 && n5.push(e6), n5.push(t4[r4]);
        return u3(n5);
    },
    line: {
        type: "line"
    },
    softline: {
        type: "line",
        soft: !0
    },
    hardline: h2,
    literalline: d3,
    group: p3,
    conditionalGroup: function(e6, t4) {
        return p3(e6[0], Object.assign({
        }, t4, {
            expandedStates: e6
        }));
    },
    fill: function(e6) {
        return {
            type: "fill",
            parts: e6
        };
    },
    lineSuffix: function(e6) {
        return {
            type: "line-suffix",
            contents: e6
        };
    },
    lineSuffixBoundary: {
        type: "line-suffix-boundary"
    },
    cursor: {
        type: "cursor",
        placeholder: Symbol("cursor")
    },
    breakParent: D2,
    ifBreak: function(e6, t4, n5) {
        return {
            type: "if-break",
            breakContents: e6,
            flatContents: t4,
            groupId: (n5 = n5 || {
            }).groupId
        };
    },
    trim: {
        type: "trim"
    },
    indent: c3,
    align: l3,
    addAlignmentToDoc: function(e6, t4, n5) {
        let r4 = e6;
        if (t4 > 0) {
            for(let e7 = 0; e7 < Math.floor(t4 / n5); ++e7)r4 = c3(r4);
            r4 = l3(t4 % n5, r4), r4 = l3(-1 / 0, r4);
        }
        return r4;
    },
    markAsRoot: function(e6) {
        return l3({
            type: "root"
        }, e6);
    },
    dedentToRoot: function(e6) {
        return l3(-1 / 0, e6);
    },
    dedent: function(e6) {
        return l3(-1, e6);
    }
}, m3 = (e6)=>"string" == typeof e6 ? e6.replace((({ onlyFirst: e7 = !1  } = {
    })=>{
        const t4 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(t4, e7 ? void 0 : "g");
    })(), "") : e6
;
const g2 = (e6)=>!Number.isNaN(e6) && (e6 >= 4352 && (e6 <= 4447 || 9001 === e6 || 9002 === e6 || 11904 <= e6 && e6 <= 12871 && 12351 !== e6 || 12880 <= e6 && e6 <= 19903 || 19968 <= e6 && e6 <= 42182 || 43360 <= e6 && e6 <= 43388 || 44032 <= e6 && e6 <= 55203 || 63744 <= e6 && e6 <= 64255 || 65040 <= e6 && e6 <= 65049 || 65072 <= e6 && e6 <= 65131 || 65281 <= e6 && e6 <= 65376 || 65504 <= e6 && e6 <= 65510 || 110592 <= e6 && e6 <= 110593 || 127488 <= e6 && e6 <= 127569 || 131072 <= e6 && e6 <= 262141))
;
var E3 = g2, C2 = g2;
E3.default = C2;
const T2 = (e6)=>{
    if ("string" != typeof (e6 = e6.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === e6.length) return 0;
    e6 = m3(e6);
    let t4 = 0;
    for(let n5 = 0; n5 < e6.length; n5++){
        const r4 = e6.codePointAt(n5);
        r4 <= 31 || r4 >= 127 && r4 <= 159 || (r4 >= 768 && r4 <= 879 || (r4 > 65535 && n5++, t4 += E3(r4) ? 2 : 1));
    }
    return t4;
};
var y3 = T2, S1 = T2;
y3.default = S1;
function _2(e6, t4) {
    return t4 || (t4 = e6.slice(0)), Object.freeze(Object.defineProperties(e6, {
        raw: {
            value: Object.freeze(t4)
        }
    }));
}
var b2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function F2() {
    throw new Error("setTimeout has not been defined");
}
function A2() {
    throw new Error("clearTimeout has not been defined");
}
var v2 = F2, w2 = A2;
function k2(e6) {
    if (v2 === setTimeout) return setTimeout(e6, 0);
    if ((v2 === F2 || !v2) && setTimeout) return v2 = setTimeout, setTimeout(e6, 0);
    try {
        return v2(e6, 0);
    } catch (t) {
        try {
            return v2.call(null, e6, 0);
        } catch (t) {
            return v2.call(this, e6, 0);
        }
    }
}
"function" == typeof b2.setTimeout && (v2 = setTimeout), "function" == typeof b2.clearTimeout && (w2 = clearTimeout);
var N2, x4 = [], O1 = !1, R2 = -1;
function B1(e6, t4) {
    this.fun = e6, this.array = t4;
}
B1.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function I1() {
}
var q2 = I1, $1 = I1, M1 = I1, U2 = I1, G1 = I1, V2 = I1, j1 = I1;
var H1 = b2.performance || {
}, X1 = H1.now || H1.mozNow || H1.msNow || H1.oNow || H1.webkitNow || function() {
    return (new Date).getTime();
};
var z1 = new Date;
const Z1 = /^[0-9]+$/, K1 = (e6, t4)=>{
    const n5 = Z1.test(e6), r4 = Z1.test(t4);
    return n5 && r4 && (e6 = +e6, t4 = +t4), e6 === t4 ? 0 : n5 && !r4 ? -1 : r4 && !n5 ? 1 : e6 < t4 ? -1 : 1;
};
var ee1 = {
    compareIdentifiers: K1,
    rcompareIdentifiers: (e6, t4)=>K1(t4, e6)
};
function he2() {
    const e6 = _2([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return he2 = function() {
        return e6;
    }, e6;
}
function de2() {
    const e6 = _2([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return de2 = function() {
        return e6;
    }, e6;
}
function fe2() {
    const e6 = _2([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return fe2 = function() {
        return e6;
    }, e6;
}
function me2() {
    const e6 = _2([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return me2 = function() {
        return e6;
    }, e6;
}
function ge2() {
    const e6 = _2([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return ge2 = function() {
        return e6;
    }, e6;
}
function Ee1() {
    const e6 = _2([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return Ee1 = function() {
        return e6;
    }, e6;
}
function ve2(e6) {
    return (t4, n5, r4)=>{
        const s4 = r4 && r4.backwards;
        if (!1 === n5) return !1;
        const { length: i4  } = t4;
        let o5 = n5;
        for(; o5 >= 0 && o5 < i4;){
            const n6 = t4.charAt(o5);
            if (e6 instanceof RegExp) {
                if (!e6.test(n6)) return o5;
            } else if (!e6.includes(n6)) return o5;
            s4 ? o5-- : o5++;
        }
        return (-1 === o5 || o5 === i4) && o5;
    };
}
const we2 = ve2(/\s/), ke2 = ve2(" \t"), Ne2 = ve2(",; \t"), xe1 = ve2(/[^\n\r]/);
function Oe1(e6, t4) {
    if (!1 === t4) return !1;
    if ("/" === e6.charAt(t4) && "*" === e6.charAt(t4 + 1)) for(let n5 = t4 + 2; n5 < e6.length; ++n5)if ("*" === e6.charAt(n5) && "/" === e6.charAt(n5 + 1)) return n5 + 2;
    return t4;
}
function Re1(e6, t4) {
    return !1 !== t4 && ("/" === e6.charAt(t4) && "/" === e6.charAt(t4 + 1) ? xe1(e6, t4) : t4);
}
function Le2(e6, t4, n5) {
    const r4 = n5 && n5.backwards;
    if (!1 === t4) return !1;
    const s4 = e6.charAt(t4);
    if (r4) {
        if ("\r" === e6.charAt(t4 - 1) && "\n" === s4) return t4 - 2;
        if ("\n" === s4 || "\r" === s4 || "\u2028" === s4 || "\u2029" === s4) return t4 - 1;
    } else {
        if ("\r" === s4 && "\n" === e6.charAt(t4 + 1)) return t4 + 2;
        if ("\n" === s4 || "\r" === s4 || "\u2028" === s4 || "\u2029" === s4) return t4 + 1;
    }
    return t4;
}
function Pe2(e6, t4, n5) {
    const r4 = ke2(e6, (n5 = n5 || {
    }).backwards ? t4 - 1 : t4, n5);
    return r4 !== Le2(e6, r4, n5);
}
function Be2(e6, t4) {
    let n5 = null, r4 = t4;
    for(; r4 !== n5;)n5 = r4, r4 = Ne2(e6, r4), r4 = Oe1(e6, r4), r4 = ke2(e6, r4);
    return r4 = Re1(e6, r4), r4 = Le2(e6, r4), !1 !== r4 && Pe2(e6, r4);
}
function Ie1(e6, t4) {
    let n5 = null, r4 = t4;
    for(; r4 !== n5;)n5 = r4, r4 = ke2(e6, r4), r4 = Oe1(e6, r4), r4 = Re1(e6, r4), r4 = Le2(e6, r4);
    return r4;
}
function qe2(e6, t4, n5) {
    return Ie1(e6, n5(t4));
}
function $e1(e6, t4, n5) {
    let r4 = 0;
    for(let s4 = n5 = n5 || 0; s4 < e6.length; ++s4)"\t" === e6[s4] ? r4 = r4 + t4 - r4 % t4 : r4++;
    return r4;
}
function Me2(e6, t4) {
    const n5 = e6.slice(1, -1), r4 = {
        quote: '"',
        regex: /"/g
    }, s4 = {
        quote: "'",
        regex: /'/g
    }, i4 = "'" === t4 ? s4 : r4, o5 = i4 === s4 ? r4 : s4;
    let a4 = i4.quote;
    if (n5.includes(i4.quote) || n5.includes(o5.quote)) {
        a4 = (n5.match(i4.regex) || []).length > (n5.match(o5.regex) || []).length ? o5.quote : i4.quote;
    }
    return a4;
}
function Ue1(e6, t4, n5) {
    const r4 = '"' === t4 ? "'" : '"', s4 = e6.replace(/\\([\S\s])|(["'])/g, (e7, s5, i4)=>s5 === r4 ? s5 : i4 === t4 ? "\\" + i4 : i4 || (n5 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s5) ? s5 : "\\" + s5)
    );
    return t4 + s4 + t4;
}
function Ge(e6, t4) {
    (e6.comments || (e6.comments = [])).push(t4), t4.printed = !1, "JSXText" === e6.type && (t4.printed = !0);
}
var je2 = {
    guessEndOfLine: function(e6) {
        const t4 = e6.indexOf("\r");
        return t4 >= 0 ? "\n" === e6.charAt(t4 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(e6) {
        switch(e6){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(e6, t4) {
        let n5;
        if ("\n" === t4) n5 = /\n/g;
        else if ("\r" === t4) n5 = /\r/g;
        else {
            if ("\r\n" !== t4) throw new Error('Unexpected "eol" '.concat(JSON.stringify(t4), "."));
            n5 = /\r\n/g;
        }
        const r4 = e6.match(n5);
        return r4 ? r4.length : 0;
    },
    normalizeEndOfLine: function(e6) {
        return e6.replace(/\r\n?/g, "\n");
    }
};
let Ye;
function Ke(e6, t4, n5) {
    const r4 = "dedent" === t4.type ? e6.queue.slice(0, -1) : e6.queue.concat(t4);
    let s4 = "", i4 = 0, o5 = 0, a4 = 0;
    for (const e7 of r4)switch(e7.type){
        case "indent":
            l4(), n5.useTabs ? u4(1) : c4(n5.tabWidth);
            break;
        case "stringAlign":
            l4(), s4 += e7.n, i4 += e7.n.length;
            break;
        case "numberAlign":
            o5 += 1, a4 += e7.n;
            break;
        default:
            throw new Error("Unexpected type '".concat(e7.type, "'"));
    }
    return p4(), Object.assign({
    }, e6, {
        value: s4,
        length: i4,
        queue: r4
    });
    function u4(e8) {
        s4 += "\t".repeat(e8), i4 += n5.tabWidth * e8;
    }
    function c4(e8) {
        s4 += " ".repeat(e8), i4 += e8;
    }
    function l4() {
        n5.useTabs ? (function() {
            o5 > 0 && u4(o5);
            D4();
        })() : p4();
    }
    function p4() {
        a4 > 0 && c4(a4), D4();
    }
    function D4() {
        o5 = 0, a4 = 0;
    }
}
function et2(e6) {
    if (0 === e6.length) return 0;
    let t4 = 0;
    for(; e6.length > 0 && "string" == typeof e6[e6.length - 1] && e6[e6.length - 1].match(/^[\t ]*$/);)t4 += e6.pop().length;
    if (e6.length && "string" == typeof e6[e6.length - 1]) {
        const n5 = e6[e6.length - 1].replace(/[\t ]*$/, "");
        t4 += e6[e6.length - 1].length - n5.length, e6[e6.length - 1] = n5;
    }
    return t4;
}
const { literalline: rt2 , concat: st1  } = f3, it1 = {
};
function ot1(e6, t4, n5, r4) {
    const s4 = [
        e6
    ];
    for(; 0 !== s4.length;){
        const e7 = s4.pop();
        if (e7 !== it1) {
            if (n5 && s4.push(e7, it1), !t4 || !1 !== t4(e7)) {
                if ("concat" === e7.type || "fill" === e7.type) for(let t5 = e7.parts.length - 1; t5 >= 0; --t5)s4.push(e7.parts[t5]);
                else if ("if-break" === e7.type) e7.flatContents && s4.push(e7.flatContents), e7.breakContents && s4.push(e7.breakContents);
                else if ("group" === e7.type && e7.expandedStates) {
                    if (r4) for(let t7 = e7.expandedStates.length - 1; t7 >= 0; --t7)s4.push(e7.expandedStates[t7]);
                    else s4.push(e7.contents);
                } else e7.contents && s4.push(e7.contents);
            }
        } else n5(s4.pop());
    }
}
function at1(e6, t4) {
    if ("concat" === e6.type || "fill" === e6.type) {
        const n5 = e6.parts.map((e7)=>at1(e7, t4)
        );
        return t4(Object.assign({
        }, e6, {
            parts: n5
        }));
    }
    if ("if-break" === e6.type) {
        const n5 = e6.breakContents && at1(e6.breakContents, t4), r4 = e6.flatContents && at1(e6.flatContents, t4);
        return t4(Object.assign({
        }, e6, {
            breakContents: n5,
            flatContents: r4
        }));
    }
    if (e6.contents) {
        const n5 = at1(e6.contents, t4);
        return t4(Object.assign({
        }, e6, {
            contents: n5
        }));
    }
    return t4(e6);
}
function ut1(e6, t4, n5) {
    let r4 = n5, s4 = !1;
    return ot1(e6, function(e7) {
        const n6 = t4(e7);
        if (((void 0) !== n6 && (s4 = !0, r4 = n6), s4)) return !1;
    }), r4;
}
function ct(e6) {
    return "string" != typeof e6 && ("line" === e6.type || void 0);
}
function lt(e6) {
    return !("group" !== e6.type || !e6.break) || (!("line" !== e6.type || !e6.hard) || ("break-parent" === e6.type || void 0));
}
function pt(e6) {
    if (e6.length > 0) {
        const t4 = e6[e6.length - 1];
        t4.expandedStates || (t4.break = !0);
    }
    return null;
}
function Dt1(e6) {
    return "line" !== e6.type || e6.hard ? "if-break" === e6.type ? e6.flatContents || "" : e6 : e6.soft ? "" : " ";
}
function ht1(e6) {
    const t4 = [], n5 = e6.filter(Boolean);
    for(; 0 !== n5.length;){
        const e7 = n5.shift();
        e7 && ("concat" !== e7.type ? 0 === t4.length || "string" != typeof t4[t4.length - 1] || "string" != typeof e7 ? t4.push(e7) : t4[t4.length - 1] += e7 : n5.unshift(...e7.parts));
    }
    return t4;
}
function dt(e6) {
    if ("concat" === e6.type) {
        const t4 = [];
        for(let n5 = 0; n5 < e6.parts.length; ++n5){
            const r4 = e6.parts[n5];
            if ("string" != typeof r4 && "concat" === r4.type) t4.push(...dt(r4).parts);
            else {
                const e7 = dt(r4);
                "" !== e7 && t4.push(e7);
            }
        }
        return Object.assign({
        }, e6, {
            parts: t4
        });
    }
    return "if-break" === e6.type ? Object.assign({
    }, e6, {
        breakContents: null != e6.breakContents ? dt(e6.breakContents) : null,
        flatContents: null != e6.flatContents ? dt(e6.flatContents) : null
    }) : "group" === e6.type ? Object.assign({
    }, e6, {
        contents: dt(e6.contents),
        expandedStates: e6.expandedStates ? e6.expandedStates.map(dt) : e6.expandedStates
    }) : e6.contents ? Object.assign({
    }, e6, {
        contents: dt(e6.contents)
    }) : e6;
}
function ft1(e6) {
    if ("string" == typeof e6) return JSON.stringify(e6);
    if ("line" === e6.type) return e6.literal ? "literalline" : e6.hard ? "hardline" : e6.soft ? "softline" : "line";
    if ("break-parent" === e6.type) return "breakParent";
    if ("trim" === e6.type) return "trim";
    if ("concat" === e6.type) return "[" + e6.parts.map(ft1).join(", ") + "]";
    if ("indent" === e6.type) return "indent(" + ft1(e6.contents) + ")";
    if ("align" === e6.type) return e6.n === -1 / 0 ? "dedentToRoot(" + ft1(e6.contents) + ")" : e6.n < 0 ? "dedent(" + ft1(e6.contents) + ")" : "root" === e6.n.type ? "markAsRoot(" + ft1(e6.contents) + ")" : "align(" + JSON.stringify(e6.n) + ", " + ft1(e6.contents) + ")";
    if ("if-break" === e6.type) return "ifBreak(" + ft1(e6.breakContents) + (e6.flatContents ? ", " + ft1(e6.flatContents) : "") + ")";
    if ("group" === e6.type) return e6.expandedStates ? "conditionalGroup([" + e6.expandedStates.map(ft1).join(",") + "])" : (e6.break ? "wrappedGroup" : "group") + "(" + ft1(e6.contents) + ")";
    if ("fill" === e6.type) return "fill(" + e6.parts.map(ft1).join(", ") + ")";
    if ("line-suffix" === e6.type) return "lineSuffix(" + ft1(e6.contents) + ")";
    if ("line-suffix-boundary" === e6.type) return "lineSuffixBoundary";
    throw new Error("Unknown doc type " + e6.type);
}
var _t = {
    "*": [
        "accesskey",
        "autocapitalize",
        "autofocus",
        "class",
        "contenteditable",
        "dir",
        "draggable",
        "enterkeyhint",
        "hidden",
        "id",
        "inputmode",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemscope",
        "itemtype",
        "lang",
        "nonce",
        "slot",
        "spellcheck",
        "style",
        "tabindex",
        "title",
        "translate"
    ],
    a: [
        "accesskey",
        "charset",
        "coords",
        "download",
        "href",
        "hreflang",
        "name",
        "ping",
        "referrerpolicy",
        "rel",
        "rev",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    abbr: [
        "title"
    ],
    applet: [
        "align",
        "alt",
        "archive",
        "code",
        "codebase",
        "height",
        "hspace",
        "name",
        "object",
        "vspace",
        "width"
    ],
    area: [
        "accesskey",
        "alt",
        "coords",
        "download",
        "href",
        "hreflang",
        "nohref",
        "ping",
        "referrerpolicy",
        "rel",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
    ],
    base: [
        "href",
        "target"
    ],
    basefont: [
        "color",
        "face",
        "size"
    ],
    bdo: [
        "dir"
    ],
    blockquote: [
        "cite"
    ],
    body: [
        "alink",
        "background",
        "bgcolor",
        "link",
        "text",
        "vlink"
    ],
    br: [
        "clear"
    ],
    button: [
        "accesskey",
        "autofocus",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "name",
        "tabindex",
        "type",
        "value"
    ],
    canvas: [
        "height",
        "width"
    ],
    caption: [
        "align"
    ],
    col: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    colgroup: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    data: [
        "value"
    ],
    del: [
        "cite",
        "datetime"
    ],
    details: [
        "open"
    ],
    dfn: [
        "title"
    ],
    dialog: [
        "open"
    ],
    dir: [
        "compact"
    ],
    div: [
        "align"
    ],
    dl: [
        "compact"
    ],
    embed: [
        "height",
        "src",
        "type",
        "width"
    ],
    fieldset: [
        "disabled",
        "form",
        "name"
    ],
    font: [
        "color",
        "face",
        "size"
    ],
    form: [
        "accept",
        "accept-charset",
        "action",
        "autocomplete",
        "enctype",
        "method",
        "name",
        "novalidate",
        "target"
    ],
    frame: [
        "frameborder",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "noresize",
        "scrolling",
        "src"
    ],
    frameset: [
        "cols",
        "rows"
    ],
    h1: [
        "align"
    ],
    h2: [
        "align"
    ],
    h3: [
        "align"
    ],
    h4: [
        "align"
    ],
    h5: [
        "align"
    ],
    h6: [
        "align"
    ],
    head: [
        "profile"
    ],
    hr: [
        "align",
        "noshade",
        "size",
        "width"
    ],
    html: [
        "manifest",
        "version"
    ],
    iframe: [
        "align",
        "allow",
        "allowfullscreen",
        "allowpaymentrequest",
        "allowusermedia",
        "frameborder",
        "height",
        "loading",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "referrerpolicy",
        "sandbox",
        "scrolling",
        "src",
        "srcdoc",
        "width"
    ],
    img: [
        "align",
        "alt",
        "border",
        "crossorigin",
        "decoding",
        "height",
        "hspace",
        "ismap",
        "loading",
        "longdesc",
        "name",
        "referrerpolicy",
        "sizes",
        "src",
        "srcset",
        "usemap",
        "vspace",
        "width"
    ],
    input: [
        "accept",
        "accesskey",
        "align",
        "alt",
        "autocomplete",
        "autofocus",
        "checked",
        "dirname",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "height",
        "ismap",
        "list",
        "max",
        "maxlength",
        "min",
        "minlength",
        "multiple",
        "name",
        "pattern",
        "placeholder",
        "readonly",
        "required",
        "size",
        "src",
        "step",
        "tabindex",
        "title",
        "type",
        "usemap",
        "value",
        "width"
    ],
    ins: [
        "cite",
        "datetime"
    ],
    isindex: [
        "prompt"
    ],
    label: [
        "accesskey",
        "for",
        "form"
    ],
    legend: [
        "accesskey",
        "align"
    ],
    li: [
        "type",
        "value"
    ],
    link: [
        "as",
        "charset",
        "color",
        "crossorigin",
        "disabled",
        "href",
        "hreflang",
        "imagesizes",
        "imagesrcset",
        "integrity",
        "media",
        "nonce",
        "referrerpolicy",
        "rel",
        "rev",
        "sizes",
        "target",
        "title",
        "type"
    ],
    map: [
        "name"
    ],
    menu: [
        "compact"
    ],
    meta: [
        "charset",
        "content",
        "http-equiv",
        "name",
        "scheme"
    ],
    meter: [
        "high",
        "low",
        "max",
        "min",
        "optimum",
        "value"
    ],
    object: [
        "align",
        "archive",
        "border",
        "classid",
        "codebase",
        "codetype",
        "data",
        "declare",
        "form",
        "height",
        "hspace",
        "name",
        "standby",
        "tabindex",
        "type",
        "typemustmatch",
        "usemap",
        "vspace",
        "width"
    ],
    ol: [
        "compact",
        "reversed",
        "start",
        "type"
    ],
    optgroup: [
        "disabled",
        "label"
    ],
    option: [
        "disabled",
        "label",
        "selected",
        "value"
    ],
    output: [
        "for",
        "form",
        "name"
    ],
    p: [
        "align"
    ],
    param: [
        "name",
        "type",
        "value",
        "valuetype"
    ],
    pre: [
        "width"
    ],
    progress: [
        "max",
        "value"
    ],
    q: [
        "cite"
    ],
    script: [
        "async",
        "charset",
        "crossorigin",
        "defer",
        "integrity",
        "language",
        "nomodule",
        "nonce",
        "referrerpolicy",
        "src",
        "type"
    ],
    select: [
        "autocomplete",
        "autofocus",
        "disabled",
        "form",
        "multiple",
        "name",
        "required",
        "size",
        "tabindex"
    ],
    slot: [
        "name"
    ],
    source: [
        "media",
        "sizes",
        "src",
        "srcset",
        "type"
    ],
    style: [
        "media",
        "nonce",
        "title",
        "type"
    ],
    table: [
        "align",
        "bgcolor",
        "border",
        "cellpadding",
        "cellspacing",
        "frame",
        "rules",
        "summary",
        "width"
    ],
    tbody: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    td: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    textarea: [
        "accesskey",
        "autocomplete",
        "autofocus",
        "cols",
        "dirname",
        "disabled",
        "form",
        "maxlength",
        "minlength",
        "name",
        "placeholder",
        "readonly",
        "required",
        "rows",
        "tabindex",
        "wrap"
    ],
    tfoot: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    th: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    thead: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    time: [
        "datetime"
    ],
    tr: [
        "align",
        "bgcolor",
        "char",
        "charoff",
        "valign"
    ],
    track: [
        "default",
        "kind",
        "label",
        "src",
        "srclang"
    ],
    ul: [
        "compact",
        "type"
    ],
    video: [
        "autoplay",
        "controls",
        "crossorigin",
        "height",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "width"
    ]
};
function Lt1(e6) {
    const t4 = Object.create(null);
    for (const n5 of e6)t4[n5] = !0;
    return t4;
}
function Bt2(e6) {
    if ("attribute" === e6.type) return !1;
    if (!e6.parent) return !1;
    if ("number" != typeof e6.index || 0 === e6.index) return !1;
    return (function(e7) {
        return "comment" === e7.type && "prettier-ignore" === e7.value.trim();
    })(e6.parent.children[e6.index - 1]);
}
function $t2(e6) {
    return "element" === e6.type && 0 !== e6.children.length && ([
        "html",
        "head",
        "ul",
        "ol",
        "select"
    ].includes(e6.name) || e6.cssDisplay.startsWith("table") && "table-cell" !== e6.cssDisplay);
}
function Gt2(e6) {
    return e6.hasLeadingSpaces && (e6.prev ? e6.prev.sourceSpan.end.line < e6.sourceSpan.start.line : "root" === e6.parent.type || e6.parent.startSourceSpan.end.line < e6.sourceSpan.start.line);
}
function Vt1(e6) {
    return e6.hasTrailingSpaces && (e6.next ? e6.next.sourceSpan.start.line > e6.sourceSpan.end.line : "root" === e6.parent.type || e6.parent.endSourceSpan && e6.parent.endSourceSpan.start.line > e6.sourceSpan.end.line);
}
function jt1(e6) {
    switch(e6.type){
        case "ieConditionalComment":
        case "comment":
        case "directive":
            return !0;
        case "element":
            return [
                "script",
                "select"
            ].includes(e6.name);
    }
    return !1;
}
function Ht1(e6) {
    const { type: t4 , lang: n5  } = e6.attrMap;
    return "module" === t4 || "text/javascript" === t4 || "text/babel" === t4 || "application/javascript" === t4 || "jsx" === n5 ? "babel" : "application/x-typescript" === t4 || "ts" === n5 || "tsx" === n5 ? "typescript" : "text/markdown" === t4 ? "markdown" : "text/html" === t4 ? "html" : t4 && (t4.endsWith("json") || t4.endsWith("importmap")) ? "json" : "text/x-handlebars-template" === t4 ? "glimmer" : void 0;
}
function Xt2(e6) {
    return "block" === e6 || "list-item" === e6 || e6.startsWith("table");
}
function Wt(e6) {
    return "element" === e6.type && !e6.hasExplicitNamespace && ![
        "html",
        "svg"
    ].includes(e6.namespace);
}
const Yt2 = new Set([
    "template",
    "style",
    "script"
]);
function Zt1(e6, t4) {
    return "vue" === t4.parser && "element" === e6.type && "root" === e6.parent.type && "html" !== e6.fullName.toLowerCase();
}
var tn1 = {
    hasPragma: function(e6) {
        return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e6);
    },
    insertPragma: function(e6) {
        return "\x3c!-- @format --\x3e\n\n" + e6.replace(/^\s*\n/, "");
    }
};
const nn1 = {
    attrs: !0,
    children: !0
};
function sn1(e6, t4) {
    const n5 = e6.map(t4);
    return n5.some((t5, n6)=>t5 !== e6[n6]
    ) ? n5 : e6;
}
function on1(e6, t4) {
    const n5 = Object.keys(t4).reduce((e7, n6)=>(e7[n6] = {
            value: t4[n6],
            enumerable: !1
        }, e7)
    , {
    });
    Object.defineProperties(e6, n5);
}
const { ParseSourceSpan: un1  } = o4, cn1 = [
    [
        /^(\[if([^\]]*?)]>)([\S\s]*?)<!\s*\[endif]$/,
        function(e6, t4, n5) {
            const [, r4, s4, i4] = n5, o5 = "\x3c!--".length + r4.length, a4 = e6.sourceSpan.start.moveBy(o5), u4 = a4.moveBy(i4.length), [c4, l4] = (()=>{
                try {
                    return [
                        !0,
                        t4(i4, a4).children
                    ];
                } catch (e) {
                    return [
                        !1,
                        [
                            {
                                type: "text",
                                value: i4,
                                sourceSpan: new un1(a4, u4)
                            }
                        ]
                    ];
                }
            })();
            return {
                type: "ieConditionalComment",
                complete: c4,
                children: l4,
                condition: s4.trim().replace(/\s+/g, " "),
                sourceSpan: e6.sourceSpan,
                startSourceSpan: new un1(e6.sourceSpan.start, a4),
                endSourceSpan: new un1(u4, e6.sourceSpan.end)
            };
        }
    ],
    [
        /^\[if([^\]]*?)]><!$/,
        function(e6, t4, n5) {
            const [, r4] = n5;
            return {
                type: "ieConditionalStartComment",
                condition: r4.trim().replace(/\s+/g, " "),
                sourceSpan: e6.sourceSpan
            };
        }
    ],
    [
        /^<!\s*\[endif]$/,
        function(e6) {
            return {
                type: "ieConditionalEndComment",
                sourceSpan: e6.sourceSpan
            };
        }
    ]
];
var ln1 = {
    parseIeConditionalComment: function(e6, t4) {
        if (e6.value) {
            let n5;
            for (const [r4, s4] of cn1)if (n5 = e6.value.match(r4)) return s4(e6, t4, n5);
        }
        return null;
    }
};
var pn = {
    locStart: function(e6) {
        return e6.sourceSpan.start.offset;
    },
    locEnd: function(e6) {
        return e6.sourceSpan.end.offset;
    }
}, Dn = t3(function(e6, t4) {
    function n5(e7) {
        if (":" != e7[0]) return [
            null,
            e7
        ];
        const t5 = e7.indexOf(":", 1);
        if (-1 == t5) throw new Error('Unsupported format "'.concat(e7, '" expecting ":namespace:name"'));
        return [
            e7.slice(1, t5),
            e7.slice(t5 + 1)
        ];
    }
    Object.defineProperty(t4, "__esModule", {
        value: !0
    }), (function(e7) {
        e7[e7.RAW_TEXT = 0] = "RAW_TEXT", e7[e7.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e7[e7.PARSABLE_DATA = 2] = "PARSABLE_DATA";
    })(t4.TagContentType || (t4.TagContentType = {
    })), t4.splitNsName = n5, t4.isNgContainer = function(e7) {
        return "ng-container" === n5(e7)[1];
    }, t4.isNgContent = function(e7) {
        return "ng-content" === n5(e7)[1];
    }, t4.isNgTemplate = function(e7) {
        return "ng-template" === n5(e7)[1];
    }, t4.getNsPrefix = function(e7) {
        return null === e7 ? null : n5(e7)[0];
    }, t4.mergeNsAndName = function(e7, t5) {
        return e7 ? ":".concat(e7, ":").concat(t5) : t5;
    }, t4.NAMED_ENTITIES = {
        Aacute: "\xc1",
        aacute: "\xe1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223e",
        acd: "\u223f",
        acE: "\u223e\u0333",
        Acirc: "\xc2",
        acirc: "\xe2",
        acute: "\xb4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xc6",
        aelig: "\xe6",
        af: "\u2061",
        Afr: "\ud835\udd04",
        afr: "\ud835\udd1e",
        Agrave: "\xc0",
        agrave: "\xe0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03b1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2a3f",
        AMP: "&",
        amp: "&",
        And: "\u2a53",
        and: "\u2227",
        andand: "\u2a55",
        andd: "\u2a5c",
        andslope: "\u2a58",
        andv: "\u2a5a",
        ang: "\u2220",
        ange: "\u29a4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29a8",
        angmsdab: "\u29a9",
        angmsdac: "\u29aa",
        angmsdad: "\u29ab",
        angmsdae: "\u29ac",
        angmsdaf: "\u29ad",
        angmsdag: "\u29ae",
        angmsdah: "\u29af",
        angrt: "\u221f",
        angrtvb: "\u22be",
        angrtvbd: "\u299d",
        angsph: "\u2222",
        angst: "\xc5",
        angzarr: "\u237c",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\ud835\udd38",
        aopf: "\ud835\udd52",
        ap: "\u2248",
        apacir: "\u2a6f",
        apE: "\u2a70",
        ape: "\u224a",
        apid: "\u224b",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224a",
        Aring: "\xc5",
        aring: "\xe5",
        Ascr: "\ud835\udc9c",
        ascr: "\ud835\udcb6",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224d",
        Atilde: "\xc3",
        atilde: "\xe3",
        Auml: "\xc4",
        auml: "\xe4",
        awconint: "\u2233",
        awint: "\u2a11",
        backcong: "\u224c",
        backepsilon: "\u03f6",
        backprime: "\u2035",
        backsim: "\u223d",
        backsimeq: "\u22cd",
        Backslash: "\u2216",
        Barv: "\u2ae7",
        barvee: "\u22bd",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23b5",
        bbrktbrk: "\u23b6",
        bcong: "\u224c",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201e",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29b0",
        bepsi: "\u03f6",
        bernou: "\u212c",
        Bernoullis: "\u212c",
        Beta: "\u0392",
        beta: "\u03b2",
        beth: "\u2136",
        between: "\u226c",
        Bfr: "\ud835\udd05",
        bfr: "\ud835\udd1f",
        bigcap: "\u22c2",
        bigcirc: "\u25ef",
        bigcup: "\u22c3",
        bigodot: "\u2a00",
        bigoplus: "\u2a01",
        bigotimes: "\u2a02",
        bigsqcup: "\u2a06",
        bigstar: "\u2605",
        bigtriangledown: "\u25bd",
        bigtriangleup: "\u25b3",
        biguplus: "\u2a04",
        bigvee: "\u22c1",
        bigwedge: "\u22c0",
        bkarow: "\u290d",
        blacklozenge: "\u29eb",
        blacksquare: "\u25aa",
        blacktriangle: "\u25b4",
        blacktriangledown: "\u25be",
        blacktriangleleft: "\u25c2",
        blacktriangleright: "\u25b8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20e5",
        bnequiv: "\u2261\u20e5",
        bNot: "\u2aed",
        bnot: "\u2310",
        Bopf: "\ud835\udd39",
        bopf: "\ud835\udd53",
        bot: "\u22a5",
        bottom: "\u22a5",
        bowtie: "\u22c8",
        boxbox: "\u29c9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250c",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252c",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229f",
        boxplus: "\u229e",
        boxtimes: "\u22a0",
        boxUL: "\u255d",
        boxUl: "\u255c",
        boxuL: "\u255b",
        boxul: "\u2518",
        boxUR: "\u255a",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256c",
        boxVh: "\u256b",
        boxvH: "\u256a",
        boxvh: "\u253c",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255f",
        boxvR: "\u255e",
        boxvr: "\u251c",
        bprime: "\u2035",
        Breve: "\u02d8",
        breve: "\u02d8",
        brvbar: "\xa6",
        Bscr: "\u212c",
        bscr: "\ud835\udcb7",
        bsemi: "\u204f",
        bsim: "\u223d",
        bsime: "\u22cd",
        bsol: "\\",
        bsolb: "\u29c5",
        bsolhsub: "\u27c8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224e",
        bumpE: "\u2aae",
        bumpe: "\u224f",
        Bumpeq: "\u224e",
        bumpeq: "\u224f",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22d2",
        cap: "\u2229",
        capand: "\u2a44",
        capbrcup: "\u2a49",
        capcap: "\u2a4b",
        capcup: "\u2a47",
        capdot: "\u2a40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\ufe00",
        caret: "\u2041",
        caron: "\u02c7",
        Cayleys: "\u212d",
        ccaps: "\u2a4d",
        Ccaron: "\u010c",
        ccaron: "\u010d",
        Ccedil: "\xc7",
        ccedil: "\xe7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2a4c",
        ccupssm: "\u2a50",
        Cdot: "\u010a",
        cdot: "\u010b",
        cedil: "\xb8",
        Cedilla: "\xb8",
        cemptyv: "\u29b2",
        cent: "\xa2",
        CenterDot: "\xb7",
        centerdot: "\xb7",
        Cfr: "\u212d",
        cfr: "\ud835\udd20",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03a7",
        chi: "\u03c7",
        cir: "\u25cb",
        circ: "\u02c6",
        circeq: "\u2257",
        circlearrowleft: "\u21ba",
        circlearrowright: "\u21bb",
        circledast: "\u229b",
        circledcirc: "\u229a",
        circleddash: "\u229d",
        CircleDot: "\u2299",
        circledR: "\xae",
        circledS: "\u24c8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29c3",
        cire: "\u2257",
        cirfnint: "\u2a10",
        cirmid: "\u2aef",
        cirscir: "\u29c2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201d",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2a74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2a6d",
        Congruent: "\u2261",
        Conint: "\u222f",
        conint: "\u222e",
        ContourIntegral: "\u222e",
        Copf: "\u2102",
        copf: "\ud835\udd54",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xa9",
        copy: "\xa9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21b5",
        Cross: "\u2a2f",
        cross: "\u2717",
        Cscr: "\ud835\udc9e",
        cscr: "\ud835\udcb8",
        csub: "\u2acf",
        csube: "\u2ad1",
        csup: "\u2ad0",
        csupe: "\u2ad2",
        ctdot: "\u22ef",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22de",
        cuesc: "\u22df",
        cularr: "\u21b6",
        cularrp: "\u293d",
        Cup: "\u22d3",
        cup: "\u222a",
        cupbrcap: "\u2a48",
        CupCap: "\u224d",
        cupcap: "\u2a46",
        cupcup: "\u2a4a",
        cupdot: "\u228d",
        cupor: "\u2a45",
        cups: "\u222a\ufe00",
        curarr: "\u21b7",
        curarrm: "\u293c",
        curlyeqprec: "\u22de",
        curlyeqsucc: "\u22df",
        curlyvee: "\u22ce",
        curlywedge: "\u22cf",
        curren: "\xa4",
        curvearrowleft: "\u21b6",
        curvearrowright: "\u21b7",
        cuvee: "\u22ce",
        cuwed: "\u22cf",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232d",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21a1",
        dArr: "\u21d3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2ae4",
        dashv: "\u22a3",
        dbkarow: "\u290f",
        dblac: "\u02dd",
        Dcaron: "\u010e",
        dcaron: "\u010f",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21ca",
        DDotrahd: "\u2911",
        ddotseq: "\u2a77",
        deg: "\xb0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03b4",
        demptyv: "\u29b1",
        dfisht: "\u297f",
        Dfr: "\ud835\udd07",
        dfr: "\ud835\udd21",
        dHar: "\u2965",
        dharl: "\u21c3",
        dharr: "\u21c2",
        DiacriticalAcute: "\xb4",
        DiacriticalDot: "\u02d9",
        DiacriticalDoubleAcute: "\u02dd",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02dc",
        diam: "\u22c4",
        Diamond: "\u22c4",
        diamond: "\u22c4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xa8",
        DifferentialD: "\u2146",
        digamma: "\u03dd",
        disin: "\u22f2",
        div: "\xf7",
        divide: "\xf7",
        divideontimes: "\u22c7",
        divonx: "\u22c7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231e",
        dlcrop: "\u230d",
        dollar: "$",
        Dopf: "\ud835\udd3b",
        dopf: "\ud835\udd55",
        Dot: "\xa8",
        dot: "\u02d9",
        DotDot: "\u20dc",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22a1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222f",
        DoubleDot: "\xa8",
        DoubleDownArrow: "\u21d3",
        DoubleLeftArrow: "\u21d0",
        DoubleLeftRightArrow: "\u21d4",
        DoubleLeftTee: "\u2ae4",
        DoubleLongLeftArrow: "\u27f8",
        DoubleLongLeftRightArrow: "\u27fa",
        DoubleLongRightArrow: "\u27f9",
        DoubleRightArrow: "\u21d2",
        DoubleRightTee: "\u22a8",
        DoubleUpArrow: "\u21d1",
        DoubleUpDownArrow: "\u21d5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21d3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21f5",
        DownBreve: "\u0311",
        downdownarrows: "\u21ca",
        downharpoonleft: "\u21c3",
        downharpoonright: "\u21c2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295e",
        DownLeftVector: "\u21bd",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295f",
        DownRightVector: "\u21c1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22a4",
        DownTeeArrow: "\u21a7",
        drbkarow: "\u2910",
        drcorn: "\u231f",
        drcrop: "\u230c",
        Dscr: "\ud835\udc9f",
        dscr: "\ud835\udcb9",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29f6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22f1",
        dtri: "\u25bf",
        dtrif: "\u25be",
        duarr: "\u21f5",
        duhar: "\u296f",
        dwangle: "\u29a6",
        DZcy: "\u040f",
        dzcy: "\u045f",
        dzigrarr: "\u27ff",
        Eacute: "\xc9",
        eacute: "\xe9",
        easter: "\u2a6e",
        Ecaron: "\u011a",
        ecaron: "\u011b",
        ecir: "\u2256",
        Ecirc: "\xca",
        ecirc: "\xea",
        ecolon: "\u2255",
        Ecy: "\u042d",
        ecy: "\u044d",
        eDDot: "\u2a77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\ud835\udd08",
        efr: "\ud835\udd22",
        eg: "\u2a9a",
        Egrave: "\xc8",
        egrave: "\xe8",
        egs: "\u2a96",
        egsdot: "\u2a98",
        el: "\u2a99",
        Element: "\u2208",
        elinters: "\u23e7",
        ell: "\u2113",
        els: "\u2a95",
        elsdot: "\u2a97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25fb",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25ab",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014a",
        eng: "\u014b",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\ud835\udd3c",
        eopf: "\ud835\udd56",
        epar: "\u22d5",
        eparsl: "\u29e3",
        eplus: "\u2a71",
        epsi: "\u03b5",
        Epsilon: "\u0395",
        epsilon: "\u03b5",
        epsiv: "\u03f5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2a96",
        eqslantless: "\u2a95",
        Equal: "\u2a75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225f",
        Equilibrium: "\u21cc",
        equiv: "\u2261",
        equivDD: "\u2a78",
        eqvparsl: "\u29e5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212f",
        esdot: "\u2250",
        Esim: "\u2a73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03b7",
        ETH: "\xd0",
        eth: "\xf0",
        Euml: "\xcb",
        euml: "\xeb",
        euro: "\u20ac",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\ufb03",
        fflig: "\ufb00",
        ffllig: "\ufb04",
        Ffr: "\ud835\udd09",
        ffr: "\ud835\udd23",
        filig: "\ufb01",
        FilledSmallSquare: "\u25fc",
        FilledVerySmallSquare: "\u25aa",
        fjlig: "fj",
        flat: "\u266d",
        fllig: "\ufb02",
        fltns: "\u25b1",
        fnof: "\u0192",
        Fopf: "\ud835\udd3d",
        fopf: "\ud835\udd57",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22d4",
        forkv: "\u2ad9",
        Fouriertrf: "\u2131",
        fpartint: "\u2a0d",
        frac12: "\xbd",
        frac13: "\u2153",
        frac14: "\xbc",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215b",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xbe",
        frac35: "\u2157",
        frac38: "\u215c",
        frac45: "\u2158",
        frac56: "\u215a",
        frac58: "\u215d",
        frac78: "\u215e",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\ud835\udcbb",
        gacute: "\u01f5",
        Gamma: "\u0393",
        gamma: "\u03b3",
        Gammad: "\u03dc",
        gammad: "\u03dd",
        gap: "\u2a86",
        Gbreve: "\u011e",
        gbreve: "\u011f",
        Gcedil: "\u0122",
        Gcirc: "\u011c",
        gcirc: "\u011d",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2a8c",
        gel: "\u22db",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2a7e",
        ges: "\u2a7e",
        gescc: "\u2aa9",
        gesdot: "\u2a80",
        gesdoto: "\u2a82",
        gesdotol: "\u2a84",
        gesl: "\u22db\ufe00",
        gesles: "\u2a94",
        Gfr: "\ud835\udd0a",
        gfr: "\ud835\udd24",
        Gg: "\u22d9",
        gg: "\u226b",
        ggg: "\u22d9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2aa5",
        glE: "\u2a92",
        glj: "\u2aa4",
        gnap: "\u2a8a",
        gnapprox: "\u2a8a",
        gnE: "\u2269",
        gne: "\u2a88",
        gneq: "\u2a88",
        gneqq: "\u2269",
        gnsim: "\u22e7",
        Gopf: "\ud835\udd3e",
        gopf: "\ud835\udd58",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22db",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2aa2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2a7e",
        GreaterTilde: "\u2273",
        Gscr: "\ud835\udca2",
        gscr: "\u210a",
        gsim: "\u2273",
        gsime: "\u2a8e",
        gsiml: "\u2a90",
        GT: ">",
        Gt: "\u226b",
        gt: ">",
        gtcc: "\u2aa7",
        gtcir: "\u2a7a",
        gtdot: "\u22d7",
        gtlPar: "\u2995",
        gtquest: "\u2a7c",
        gtrapprox: "\u2a86",
        gtrarr: "\u2978",
        gtrdot: "\u22d7",
        gtreqless: "\u22db",
        gtreqqless: "\u2a8c",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\ufe00",
        gvnE: "\u2269\ufe00",
        Hacek: "\u02c7",
        hairsp: "\u200a",
        half: "\xbd",
        hamilt: "\u210b",
        HARDcy: "\u042a",
        hardcy: "\u044a",
        hArr: "\u21d4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21ad",
        Hat: "^",
        hbar: "\u210f",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22b9",
        Hfr: "\u210c",
        hfr: "\ud835\udd25",
        HilbertSpace: "\u210b",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21ff",
        homtht: "\u223b",
        hookleftarrow: "\u21a9",
        hookrightarrow: "\u21aa",
        Hopf: "\u210d",
        hopf: "\ud835\udd59",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210b",
        hscr: "\ud835\udcbd",
        hslash: "\u210f",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224e",
        HumpEqual: "\u224f",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xcd",
        iacute: "\xed",
        ic: "\u2063",
        Icirc: "\xce",
        icirc: "\xee",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xa1",
        iff: "\u21d4",
        Ifr: "\u2111",
        ifr: "\ud835\udd26",
        Igrave: "\xcc",
        igrave: "\xec",
        ii: "\u2148",
        iiiint: "\u2a0c",
        iiint: "\u222d",
        iinfin: "\u29dc",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012a",
        imacr: "\u012b",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22b7",
        imped: "\u01b5",
        Implies: "\u21d2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221e",
        infintie: "\u29dd",
        inodot: "\u0131",
        Int: "\u222c",
        int: "\u222b",
        intcal: "\u22ba",
        integers: "\u2124",
        Integral: "\u222b",
        intercal: "\u22ba",
        Intersection: "\u22c2",
        intlarhk: "\u2a17",
        intprod: "\u2a3c",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012e",
        iogon: "\u012f",
        Iopf: "\ud835\udd40",
        iopf: "\ud835\udd5a",
        Iota: "\u0399",
        iota: "\u03b9",
        iprod: "\u2a3c",
        iquest: "\xbf",
        Iscr: "\u2110",
        iscr: "\ud835\udcbe",
        isin: "\u2208",
        isindot: "\u22f5",
        isinE: "\u22f9",
        isins: "\u22f4",
        isinsv: "\u22f3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xcf",
        iuml: "\xef",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\ud835\udd0d",
        jfr: "\ud835\udd27",
        jmath: "\u0237",
        Jopf: "\ud835\udd41",
        jopf: "\ud835\udd5b",
        Jscr: "\ud835\udca5",
        jscr: "\ud835\udcbf",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039a",
        kappa: "\u03ba",
        kappav: "\u03f0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041a",
        kcy: "\u043a",
        Kfr: "\ud835\udd0e",
        kfr: "\ud835\udd28",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040c",
        kjcy: "\u045c",
        Kopf: "\ud835\udd42",
        kopf: "\ud835\udd5c",
        Kscr: "\ud835\udca6",
        kscr: "\ud835\udcc0",
        lAarr: "\u21da",
        Lacute: "\u0139",
        lacute: "\u013a",
        laemptyv: "\u29b4",
        lagran: "\u2112",
        Lambda: "\u039b",
        lambda: "\u03bb",
        Lang: "\u27ea",
        lang: "\u27e8",
        langd: "\u2991",
        langle: "\u27e8",
        lap: "\u2a85",
        Laplacetrf: "\u2112",
        laquo: "\xab",
        Larr: "\u219e",
        lArr: "\u21d0",
        larr: "\u2190",
        larrb: "\u21e4",
        larrbfs: "\u291f",
        larrfs: "\u291d",
        larrhk: "\u21a9",
        larrlp: "\u21ab",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21a2",
        lat: "\u2aab",
        lAtail: "\u291b",
        latail: "\u2919",
        late: "\u2aad",
        lates: "\u2aad\ufe00",
        lBarr: "\u290e",
        lbarr: "\u290c",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298b",
        lbrksld: "\u298f",
        lbrkslu: "\u298d",
        Lcaron: "\u013d",
        lcaron: "\u013e",
        Lcedil: "\u013b",
        lcedil: "\u013c",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041b",
        lcy: "\u043b",
        ldca: "\u2936",
        ldquo: "\u201c",
        ldquor: "\u201e",
        ldrdhar: "\u2967",
        ldrushar: "\u294b",
        ldsh: "\u21b2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27e8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21d0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21e4",
        LeftArrowRightArrow: "\u21c6",
        leftarrowtail: "\u21a2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27e6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21c3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230a",
        leftharpoondown: "\u21bd",
        leftharpoonup: "\u21bc",
        leftleftarrows: "\u21c7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21d4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21c6",
        leftrightharpoons: "\u21cb",
        leftrightsquigarrow: "\u21ad",
        LeftRightVector: "\u294e",
        LeftTee: "\u22a3",
        LeftTeeArrow: "\u21a4",
        LeftTeeVector: "\u295a",
        leftthreetimes: "\u22cb",
        LeftTriangle: "\u22b2",
        LeftTriangleBar: "\u29cf",
        LeftTriangleEqual: "\u22b4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21bf",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21bc",
        LeftVectorBar: "\u2952",
        lEg: "\u2a8b",
        leg: "\u22da",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2a7d",
        les: "\u2a7d",
        lescc: "\u2aa8",
        lesdot: "\u2a7f",
        lesdoto: "\u2a81",
        lesdotor: "\u2a83",
        lesg: "\u22da\ufe00",
        lesges: "\u2a93",
        lessapprox: "\u2a85",
        lessdot: "\u22d6",
        lesseqgtr: "\u22da",
        lesseqqgtr: "\u2a8b",
        LessEqualGreater: "\u22da",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2aa1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2a7d",
        LessTilde: "\u2272",
        lfisht: "\u297c",
        lfloor: "\u230a",
        Lfr: "\ud835\udd0f",
        lfr: "\ud835\udd29",
        lg: "\u2276",
        lgE: "\u2a91",
        lHar: "\u2962",
        lhard: "\u21bd",
        lharu: "\u21bc",
        lharul: "\u296a",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22d8",
        ll: "\u226a",
        llarr: "\u21c7",
        llcorner: "\u231e",
        Lleftarrow: "\u21da",
        llhard: "\u296b",
        lltri: "\u25fa",
        Lmidot: "\u013f",
        lmidot: "\u0140",
        lmoust: "\u23b0",
        lmoustache: "\u23b0",
        lnap: "\u2a89",
        lnapprox: "\u2a89",
        lnE: "\u2268",
        lne: "\u2a87",
        lneq: "\u2a87",
        lneqq: "\u2268",
        lnsim: "\u22e6",
        loang: "\u27ec",
        loarr: "\u21fd",
        lobrk: "\u27e6",
        LongLeftArrow: "\u27f5",
        Longleftarrow: "\u27f8",
        longleftarrow: "\u27f5",
        LongLeftRightArrow: "\u27f7",
        Longleftrightarrow: "\u27fa",
        longleftrightarrow: "\u27f7",
        longmapsto: "\u27fc",
        LongRightArrow: "\u27f6",
        Longrightarrow: "\u27f9",
        longrightarrow: "\u27f6",
        looparrowleft: "\u21ab",
        looparrowright: "\u21ac",
        lopar: "\u2985",
        Lopf: "\ud835\udd43",
        lopf: "\ud835\udd5d",
        loplus: "\u2a2d",
        lotimes: "\u2a34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25ca",
        lozenge: "\u25ca",
        lozf: "\u29eb",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21c6",
        lrcorner: "\u231f",
        lrhar: "\u21cb",
        lrhard: "\u296d",
        lrm: "\u200e",
        lrtri: "\u22bf",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\ud835\udcc1",
        Lsh: "\u21b0",
        lsh: "\u21b0",
        lsim: "\u2272",
        lsime: "\u2a8d",
        lsimg: "\u2a8f",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201a",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        LT: "<",
        Lt: "\u226a",
        lt: "<",
        ltcc: "\u2aa6",
        ltcir: "\u2a79",
        ltdot: "\u22d6",
        lthree: "\u22cb",
        ltimes: "\u22c9",
        ltlarr: "\u2976",
        ltquest: "\u2a7b",
        ltri: "\u25c3",
        ltrie: "\u22b4",
        ltrif: "\u25c2",
        ltrPar: "\u2996",
        lurdshar: "\u294a",
        luruhar: "\u2966",
        lvertneqq: "\u2268\ufe00",
        lvnE: "\u2268\ufe00",
        macr: "\xaf",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21a6",
        mapsto: "\u21a6",
        mapstodown: "\u21a7",
        mapstoleft: "\u21a4",
        mapstoup: "\u21a5",
        marker: "\u25ae",
        mcomma: "\u2a29",
        Mcy: "\u041c",
        mcy: "\u043c",
        mdash: "\u2014",
        mDDot: "\u223a",
        measuredangle: "\u2221",
        MediumSpace: "\u205f",
        Mellintrf: "\u2133",
        Mfr: "\ud835\udd10",
        mfr: "\ud835\udd2a",
        mho: "\u2127",
        micro: "\xb5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2af0",
        middot: "\xb7",
        minus: "\u2212",
        minusb: "\u229f",
        minusd: "\u2238",
        minusdu: "\u2a2a",
        MinusPlus: "\u2213",
        mlcp: "\u2adb",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22a7",
        Mopf: "\ud835\udd44",
        mopf: "\ud835\udd5e",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\ud835\udcc2",
        mstpos: "\u223e",
        Mu: "\u039c",
        mu: "\u03bc",
        multimap: "\u22b8",
        mumap: "\u22b8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20d2",
        nap: "\u2249",
        napE: "\u2a70\u0338",
        napid: "\u224b\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266e",
        natural: "\u266e",
        naturals: "\u2115",
        nbsp: "\xa0",
        nbump: "\u224e\u0338",
        nbumpe: "\u224f\u0338",
        ncap: "\u2a43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2a6d\u0338",
        ncup: "\u2a42",
        Ncy: "\u041d",
        ncy: "\u043d",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21d7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200b",
        NegativeThickSpace: "\u200b",
        NegativeThinSpace: "\u200b",
        NegativeVeryThinSpace: "\u200b",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226b",
        NestedLessLess: "\u226a",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\ud835\udd11",
        nfr: "\ud835\udd2b",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2a7e\u0338",
        nges: "\u2a7e\u0338",
        nGg: "\u22d9\u0338",
        ngsim: "\u2275",
        nGt: "\u226b\u20d2",
        ngt: "\u226f",
        ngtr: "\u226f",
        nGtv: "\u226b\u0338",
        nhArr: "\u21ce",
        nharr: "\u21ae",
        nhpar: "\u2af2",
        ni: "\u220b",
        nis: "\u22fc",
        nisd: "\u22fa",
        niv: "\u220b",
        NJcy: "\u040a",
        njcy: "\u045a",
        nlArr: "\u21cd",
        nlarr: "\u219a",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21cd",
        nleftarrow: "\u219a",
        nLeftrightarrow: "\u21ce",
        nleftrightarrow: "\u21ae",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2a7d\u0338",
        nles: "\u2a7d\u0338",
        nless: "\u226e",
        nLl: "\u22d8\u0338",
        nlsim: "\u2274",
        nLt: "\u226a\u20d2",
        nlt: "\u226e",
        nltri: "\u22ea",
        nltrie: "\u22ec",
        nLtv: "\u226a\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xa0",
        Nopf: "\u2115",
        nopf: "\ud835\udd5f",
        Not: "\u2aec",
        not: "\xac",
        NotCongruent: "\u2262",
        NotCupCap: "\u226d",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226f",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226b\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2a7e\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224e\u0338",
        NotHumpEqual: "\u224f\u0338",
        notin: "\u2209",
        notindot: "\u22f5\u0338",
        notinE: "\u22f9\u0338",
        notinva: "\u2209",
        notinvb: "\u22f7",
        notinvc: "\u22f6",
        NotLeftTriangle: "\u22ea",
        NotLeftTriangleBar: "\u29cf\u0338",
        NotLeftTriangleEqual: "\u22ec",
        NotLess: "\u226e",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226a\u0338",
        NotLessSlantEqual: "\u2a7d\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2aa2\u0338",
        NotNestedLessLess: "\u2aa1\u0338",
        notni: "\u220c",
        notniva: "\u220c",
        notnivb: "\u22fe",
        notnivc: "\u22fd",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2aaf\u0338",
        NotPrecedesSlantEqual: "\u22e0",
        NotReverseElement: "\u220c",
        NotRightTriangle: "\u22eb",
        NotRightTriangleBar: "\u29d0\u0338",
        NotRightTriangleEqual: "\u22ed",
        NotSquareSubset: "\u228f\u0338",
        NotSquareSubsetEqual: "\u22e2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22e3",
        NotSubset: "\u2282\u20d2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2ab0\u0338",
        NotSucceedsSlantEqual: "\u22e1",
        NotSucceedsTilde: "\u227f\u0338",
        NotSuperset: "\u2283\u20d2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2afd\u20e5",
        npart: "\u2202\u0338",
        npolint: "\u2a14",
        npr: "\u2280",
        nprcue: "\u22e0",
        npre: "\u2aaf\u0338",
        nprec: "\u2280",
        npreceq: "\u2aaf\u0338",
        nrArr: "\u21cf",
        nrarr: "\u219b",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219d\u0338",
        nRightarrow: "\u21cf",
        nrightarrow: "\u219b",
        nrtri: "\u22eb",
        nrtrie: "\u22ed",
        nsc: "\u2281",
        nsccue: "\u22e1",
        nsce: "\u2ab0\u0338",
        Nscr: "\ud835\udca9",
        nscr: "\ud835\udcc3",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22e2",
        nsqsupe: "\u22e3",
        nsub: "\u2284",
        nsubE: "\u2ac5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20d2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2ac5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2ab0\u0338",
        nsup: "\u2285",
        nsupE: "\u2ac6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20d2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2ac6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xd1",
        ntilde: "\xf1",
        ntlg: "\u2278",
        ntriangleleft: "\u22ea",
        ntrianglelefteq: "\u22ec",
        ntriangleright: "\u22eb",
        ntrianglerighteq: "\u22ed",
        Nu: "\u039d",
        nu: "\u03bd",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224d\u20d2",
        nVDash: "\u22af",
        nVdash: "\u22ae",
        nvDash: "\u22ad",
        nvdash: "\u22ac",
        nvge: "\u2265\u20d2",
        nvgt: ">\u20d2",
        nvHarr: "\u2904",
        nvinfin: "\u29de",
        nvlArr: "\u2902",
        nvle: "\u2264\u20d2",
        nvlt: "<\u20d2",
        nvltrie: "\u22b4\u20d2",
        nvrArr: "\u2903",
        nvrtrie: "\u22b5\u20d2",
        nvsim: "\u223c\u20d2",
        nwarhk: "\u2923",
        nwArr: "\u21d6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xd3",
        oacute: "\xf3",
        oast: "\u229b",
        ocir: "\u229a",
        Ocirc: "\xd4",
        ocirc: "\xf4",
        Ocy: "\u041e",
        ocy: "\u043e",
        odash: "\u229d",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2a38",
        odot: "\u2299",
        odsold: "\u29bc",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29bf",
        Ofr: "\ud835\udd12",
        ofr: "\ud835\udd2c",
        ogon: "\u02db",
        Ograve: "\xd2",
        ograve: "\xf2",
        ogt: "\u29c1",
        ohbar: "\u29b5",
        ohm: "\u03a9",
        oint: "\u222e",
        olarr: "\u21ba",
        olcir: "\u29be",
        olcross: "\u29bb",
        oline: "\u203e",
        olt: "\u29c0",
        Omacr: "\u014c",
        omacr: "\u014d",
        Omega: "\u03a9",
        omega: "\u03c9",
        Omicron: "\u039f",
        omicron: "\u03bf",
        omid: "\u29b6",
        ominus: "\u2296",
        Oopf: "\ud835\udd46",
        oopf: "\ud835\udd60",
        opar: "\u29b7",
        OpenCurlyDoubleQuote: "\u201c",
        OpenCurlyQuote: "\u2018",
        operp: "\u29b9",
        oplus: "\u2295",
        Or: "\u2a54",
        or: "\u2228",
        orarr: "\u21bb",
        ord: "\u2a5d",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xaa",
        ordm: "\xba",
        origof: "\u22b6",
        oror: "\u2a56",
        orslope: "\u2a57",
        orv: "\u2a5b",
        oS: "\u24c8",
        Oscr: "\ud835\udcaa",
        oscr: "\u2134",
        Oslash: "\xd8",
        oslash: "\xf8",
        osol: "\u2298",
        Otilde: "\xd5",
        otilde: "\xf5",
        Otimes: "\u2a37",
        otimes: "\u2297",
        otimesas: "\u2a36",
        Ouml: "\xd6",
        ouml: "\xf6",
        ovbar: "\u233d",
        OverBar: "\u203e",
        OverBrace: "\u23de",
        OverBracket: "\u23b4",
        OverParenthesis: "\u23dc",
        par: "\u2225",
        para: "\xb6",
        parallel: "\u2225",
        parsim: "\u2af3",
        parsl: "\u2afd",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041f",
        pcy: "\u043f",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22a5",
        pertenk: "\u2031",
        Pfr: "\ud835\udd13",
        pfr: "\ud835\udd2d",
        Phi: "\u03a6",
        phi: "\u03c6",
        phiv: "\u03d5",
        phmmat: "\u2133",
        phone: "\u260e",
        Pi: "\u03a0",
        pi: "\u03c0",
        pitchfork: "\u22d4",
        piv: "\u03d6",
        planck: "\u210f",
        planckh: "\u210e",
        plankv: "\u210f",
        plus: "+",
        plusacir: "\u2a23",
        plusb: "\u229e",
        pluscir: "\u2a22",
        plusdo: "\u2214",
        plusdu: "\u2a25",
        pluse: "\u2a72",
        PlusMinus: "\xb1",
        plusmn: "\xb1",
        plussim: "\u2a26",
        plustwo: "\u2a27",
        pm: "\xb1",
        Poincareplane: "\u210c",
        pointint: "\u2a15",
        Popf: "\u2119",
        popf: "\ud835\udd61",
        pound: "\xa3",
        Pr: "\u2abb",
        pr: "\u227a",
        prap: "\u2ab7",
        prcue: "\u227c",
        prE: "\u2ab3",
        pre: "\u2aaf",
        prec: "\u227a",
        precapprox: "\u2ab7",
        preccurlyeq: "\u227c",
        Precedes: "\u227a",
        PrecedesEqual: "\u2aaf",
        PrecedesSlantEqual: "\u227c",
        PrecedesTilde: "\u227e",
        preceq: "\u2aaf",
        precnapprox: "\u2ab9",
        precneqq: "\u2ab5",
        precnsim: "\u22e8",
        precsim: "\u227e",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2ab9",
        prnE: "\u2ab5",
        prnsim: "\u22e8",
        prod: "\u220f",
        Product: "\u220f",
        profalar: "\u232e",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221d",
        Proportion: "\u2237",
        Proportional: "\u221d",
        propto: "\u221d",
        prsim: "\u227e",
        prurel: "\u22b0",
        Pscr: "\ud835\udcab",
        pscr: "\ud835\udcc5",
        Psi: "\u03a8",
        psi: "\u03c8",
        puncsp: "\u2008",
        Qfr: "\ud835\udd14",
        qfr: "\ud835\udd2e",
        qint: "\u2a0c",
        Qopf: "\u211a",
        qopf: "\ud835\udd62",
        qprime: "\u2057",
        Qscr: "\ud835\udcac",
        qscr: "\ud835\udcc6",
        quaternions: "\u210d",
        quatint: "\u2a16",
        quest: "?",
        questeq: "\u225f",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21db",
        race: "\u223d\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221a",
        raemptyv: "\u29b3",
        Rang: "\u27eb",
        rang: "\u27e9",
        rangd: "\u2992",
        range: "\u29a5",
        rangle: "\u27e9",
        raquo: "\xbb",
        Rarr: "\u21a0",
        rArr: "\u21d2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21e5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291e",
        rarrhk: "\u21aa",
        rarrlp: "\u21ac",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21a3",
        rarrw: "\u219d",
        rAtail: "\u291c",
        ratail: "\u291a",
        ratio: "\u2236",
        rationals: "\u211a",
        RBarr: "\u2910",
        rBarr: "\u290f",
        rbarr: "\u290d",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298c",
        rbrksld: "\u298e",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201d",
        rdquor: "\u201d",
        rdsh: "\u21b3",
        Re: "\u211c",
        real: "\u211c",
        realine: "\u211b",
        realpart: "\u211c",
        reals: "\u211d",
        rect: "\u25ad",
        REG: "\xae",
        reg: "\xae",
        ReverseElement: "\u220b",
        ReverseEquilibrium: "\u21cb",
        ReverseUpEquilibrium: "\u296f",
        rfisht: "\u297d",
        rfloor: "\u230b",
        Rfr: "\u211c",
        rfr: "\ud835\udd2f",
        rHar: "\u2964",
        rhard: "\u21c1",
        rharu: "\u21c0",
        rharul: "\u296c",
        Rho: "\u03a1",
        rho: "\u03c1",
        rhov: "\u03f1",
        RightAngleBracket: "\u27e9",
        RightArrow: "\u2192",
        Rightarrow: "\u21d2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21e5",
        RightArrowLeftArrow: "\u21c4",
        rightarrowtail: "\u21a3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27e7",
        RightDownTeeVector: "\u295d",
        RightDownVector: "\u21c2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230b",
        rightharpoondown: "\u21c1",
        rightharpoonup: "\u21c0",
        rightleftarrows: "\u21c4",
        rightleftharpoons: "\u21cc",
        rightrightarrows: "\u21c9",
        rightsquigarrow: "\u219d",
        RightTee: "\u22a2",
        RightTeeArrow: "\u21a6",
        RightTeeVector: "\u295b",
        rightthreetimes: "\u22cc",
        RightTriangle: "\u22b3",
        RightTriangleBar: "\u29d0",
        RightTriangleEqual: "\u22b5",
        RightUpDownVector: "\u294f",
        RightUpTeeVector: "\u295c",
        RightUpVector: "\u21be",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21c0",
        RightVectorBar: "\u2953",
        ring: "\u02da",
        risingdotseq: "\u2253",
        rlarr: "\u21c4",
        rlhar: "\u21cc",
        rlm: "\u200f",
        rmoust: "\u23b1",
        rmoustache: "\u23b1",
        rnmid: "\u2aee",
        roang: "\u27ed",
        roarr: "\u21fe",
        robrk: "\u27e7",
        ropar: "\u2986",
        Ropf: "\u211d",
        ropf: "\ud835\udd63",
        roplus: "\u2a2e",
        rotimes: "\u2a35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2a12",
        rrarr: "\u21c9",
        Rrightarrow: "\u21db",
        rsaquo: "\u203a",
        Rscr: "\u211b",
        rscr: "\ud835\udcc7",
        Rsh: "\u21b1",
        rsh: "\u21b1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22cc",
        rtimes: "\u22ca",
        rtri: "\u25b9",
        rtrie: "\u22b5",
        rtrif: "\u25b8",
        rtriltri: "\u29ce",
        RuleDelayed: "\u29f4",
        ruluhar: "\u2968",
        rx: "\u211e",
        Sacute: "\u015a",
        sacute: "\u015b",
        sbquo: "\u201a",
        Sc: "\u2abc",
        sc: "\u227b",
        scap: "\u2ab8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227d",
        scE: "\u2ab4",
        sce: "\u2ab0",
        Scedil: "\u015e",
        scedil: "\u015f",
        Scirc: "\u015c",
        scirc: "\u015d",
        scnap: "\u2aba",
        scnE: "\u2ab6",
        scnsim: "\u22e9",
        scpolint: "\u2a13",
        scsim: "\u227f",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22c5",
        sdotb: "\u22a1",
        sdote: "\u2a66",
        searhk: "\u2925",
        seArr: "\u21d8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xa7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\ud835\udd16",
        sfr: "\ud835\udd30",
        sfrown: "\u2322",
        sharp: "\u266f",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xad",
        Sigma: "\u03a3",
        sigma: "\u03c3",
        sigmaf: "\u03c2",
        sigmav: "\u03c2",
        sim: "\u223c",
        simdot: "\u2a6a",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2a9e",
        simgE: "\u2aa0",
        siml: "\u2a9d",
        simlE: "\u2a9f",
        simne: "\u2246",
        simplus: "\u2a24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2a33",
        smeparsl: "\u29e4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2aaa",
        smte: "\u2aac",
        smtes: "\u2aac\ufe00",
        SOFTcy: "\u042c",
        softcy: "\u044c",
        sol: "/",
        solb: "\u29c4",
        solbar: "\u233f",
        Sopf: "\ud835\udd4a",
        sopf: "\ud835\udd64",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\ufe00",
        sqcup: "\u2294",
        sqcups: "\u2294\ufe00",
        Sqrt: "\u221a",
        sqsub: "\u228f",
        sqsube: "\u2291",
        sqsubset: "\u228f",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25a1",
        Square: "\u25a1",
        square: "\u25a1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228f",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25aa",
        squf: "\u25aa",
        srarr: "\u2192",
        Sscr: "\ud835\udcae",
        sscr: "\ud835\udcc8",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22c6",
        Star: "\u22c6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03f5",
        straightphi: "\u03d5",
        strns: "\xaf",
        Sub: "\u22d0",
        sub: "\u2282",
        subdot: "\u2abd",
        subE: "\u2ac5",
        sube: "\u2286",
        subedot: "\u2ac3",
        submult: "\u2ac1",
        subnE: "\u2acb",
        subne: "\u228a",
        subplus: "\u2abf",
        subrarr: "\u2979",
        Subset: "\u22d0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2ac5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228a",
        subsetneqq: "\u2acb",
        subsim: "\u2ac7",
        subsub: "\u2ad5",
        subsup: "\u2ad3",
        succ: "\u227b",
        succapprox: "\u2ab8",
        succcurlyeq: "\u227d",
        Succeeds: "\u227b",
        SucceedsEqual: "\u2ab0",
        SucceedsSlantEqual: "\u227d",
        SucceedsTilde: "\u227f",
        succeq: "\u2ab0",
        succnapprox: "\u2aba",
        succneqq: "\u2ab6",
        succnsim: "\u22e9",
        succsim: "\u227f",
        SuchThat: "\u220b",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266a",
        Sup: "\u22d1",
        sup: "\u2283",
        sup1: "\xb9",
        sup2: "\xb2",
        sup3: "\xb3",
        supdot: "\u2abe",
        supdsub: "\u2ad8",
        supE: "\u2ac6",
        supe: "\u2287",
        supedot: "\u2ac4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27c9",
        suphsub: "\u2ad7",
        suplarr: "\u297b",
        supmult: "\u2ac2",
        supnE: "\u2acc",
        supne: "\u228b",
        supplus: "\u2ac0",
        Supset: "\u22d1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2ac6",
        supsetneq: "\u228b",
        supsetneqq: "\u2acc",
        supsim: "\u2ac8",
        supsub: "\u2ad4",
        supsup: "\u2ad6",
        swarhk: "\u2926",
        swArr: "\u21d9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292a",
        szlig: "\xdf",
        Tab: "\t",
        target: "\u2316",
        Tau: "\u03a4",
        tau: "\u03c4",
        tbrk: "\u23b4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20db",
        telrec: "\u2315",
        Tfr: "\ud835\udd17",
        tfr: "\ud835\udd31",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03b8",
        thetasym: "\u03d1",
        thetav: "\u03d1",
        thickapprox: "\u2248",
        thicksim: "\u223c",
        ThickSpace: "\u205f\u200a",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223c",
        THORN: "\xde",
        thorn: "\xfe",
        Tilde: "\u223c",
        tilde: "\u02dc",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xd7",
        timesb: "\u22a0",
        timesbar: "\u2a31",
        timesd: "\u2a30",
        tint: "\u222d",
        toea: "\u2928",
        top: "\u22a4",
        topbot: "\u2336",
        topcir: "\u2af1",
        Topf: "\ud835\udd4b",
        topf: "\ud835\udd65",
        topfork: "\u2ada",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25b5",
        triangledown: "\u25bf",
        triangleleft: "\u25c3",
        trianglelefteq: "\u22b4",
        triangleq: "\u225c",
        triangleright: "\u25b9",
        trianglerighteq: "\u22b5",
        tridot: "\u25ec",
        trie: "\u225c",
        triminus: "\u2a3a",
        TripleDot: "\u20db",
        triplus: "\u2a39",
        trisb: "\u29cd",
        tritime: "\u2a3b",
        trpezium: "\u23e2",
        Tscr: "\ud835\udcaf",
        tscr: "\ud835\udcc9",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040b",
        tshcy: "\u045b",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226c",
        twoheadleftarrow: "\u219e",
        twoheadrightarrow: "\u21a0",
        Uacute: "\xda",
        uacute: "\xfa",
        Uarr: "\u219f",
        uArr: "\u21d1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040e",
        ubrcy: "\u045e",
        Ubreve: "\u016c",
        ubreve: "\u016d",
        Ucirc: "\xdb",
        ucirc: "\xfb",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21c5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296e",
        ufisht: "\u297e",
        Ufr: "\ud835\udd18",
        ufr: "\ud835\udd32",
        Ugrave: "\xd9",
        ugrave: "\xf9",
        uHar: "\u2963",
        uharl: "\u21bf",
        uharr: "\u21be",
        uhblk: "\u2580",
        ulcorn: "\u231c",
        ulcorner: "\u231c",
        ulcrop: "\u230f",
        ultri: "\u25f8",
        Umacr: "\u016a",
        umacr: "\u016b",
        uml: "\xa8",
        UnderBar: "_",
        UnderBrace: "\u23df",
        UnderBracket: "\u23b5",
        UnderParenthesis: "\u23dd",
        Union: "\u22c3",
        UnionPlus: "\u228e",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\ud835\udd4c",
        uopf: "\ud835\udd66",
        UpArrow: "\u2191",
        Uparrow: "\u21d1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21c5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21d5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296e",
        upharpoonleft: "\u21bf",
        upharpoonright: "\u21be",
        uplus: "\u228e",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03d2",
        upsi: "\u03c5",
        upsih: "\u03d2",
        Upsilon: "\u03a5",
        upsilon: "\u03c5",
        UpTee: "\u22a5",
        UpTeeArrow: "\u21a5",
        upuparrows: "\u21c8",
        urcorn: "\u231d",
        urcorner: "\u231d",
        urcrop: "\u230e",
        Uring: "\u016e",
        uring: "\u016f",
        urtri: "\u25f9",
        Uscr: "\ud835\udcb0",
        uscr: "\ud835\udcca",
        utdot: "\u22f0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25b5",
        utrif: "\u25b4",
        uuarr: "\u21c8",
        Uuml: "\xdc",
        uuml: "\xfc",
        uwangle: "\u29a7",
        vangrt: "\u299c",
        varepsilon: "\u03f5",
        varkappa: "\u03f0",
        varnothing: "\u2205",
        varphi: "\u03d5",
        varpi: "\u03d6",
        varpropto: "\u221d",
        vArr: "\u21d5",
        varr: "\u2195",
        varrho: "\u03f1",
        varsigma: "\u03c2",
        varsubsetneq: "\u228a\ufe00",
        varsubsetneqq: "\u2acb\ufe00",
        varsupsetneq: "\u228b\ufe00",
        varsupsetneqq: "\u2acc\ufe00",
        vartheta: "\u03d1",
        vartriangleleft: "\u22b2",
        vartriangleright: "\u22b3",
        Vbar: "\u2aeb",
        vBar: "\u2ae8",
        vBarv: "\u2ae9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22ab",
        Vdash: "\u22a9",
        vDash: "\u22a8",
        vdash: "\u22a2",
        Vdashl: "\u2ae6",
        Vee: "\u22c1",
        vee: "\u2228",
        veebar: "\u22bb",
        veeeq: "\u225a",
        vellip: "\u22ee",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200a",
        Vfr: "\ud835\udd19",
        vfr: "\ud835\udd33",
        vltri: "\u22b2",
        vnsub: "\u2282\u20d2",
        vnsup: "\u2283\u20d2",
        Vopf: "\ud835\udd4d",
        vopf: "\ud835\udd67",
        vprop: "\u221d",
        vrtri: "\u22b3",
        Vscr: "\ud835\udcb1",
        vscr: "\ud835\udccb",
        vsubnE: "\u2acb\ufe00",
        vsubne: "\u228a\ufe00",
        vsupnE: "\u2acc\ufe00",
        vsupne: "\u228b\ufe00",
        Vvdash: "\u22aa",
        vzigzag: "\u299a",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2a5f",
        Wedge: "\u22c0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\ud835\udd1a",
        wfr: "\ud835\udd34",
        Wopf: "\ud835\udd4e",
        wopf: "\ud835\udd68",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\ud835\udcb2",
        wscr: "\ud835\udccc",
        xcap: "\u22c2",
        xcirc: "\u25ef",
        xcup: "\u22c3",
        xdtri: "\u25bd",
        Xfr: "\ud835\udd1b",
        xfr: "\ud835\udd35",
        xhArr: "\u27fa",
        xharr: "\u27f7",
        Xi: "\u039e",
        xi: "\u03be",
        xlArr: "\u27f8",
        xlarr: "\u27f5",
        xmap: "\u27fc",
        xnis: "\u22fb",
        xodot: "\u2a00",
        Xopf: "\ud835\udd4f",
        xopf: "\ud835\udd69",
        xoplus: "\u2a01",
        xotime: "\u2a02",
        xrArr: "\u27f9",
        xrarr: "\u27f6",
        Xscr: "\ud835\udcb3",
        xscr: "\ud835\udccd",
        xsqcup: "\u2a06",
        xuplus: "\u2a04",
        xutri: "\u25b3",
        xvee: "\u22c1",
        xwedge: "\u22c0",
        Yacute: "\xdd",
        yacute: "\xfd",
        YAcy: "\u042f",
        yacy: "\u044f",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042b",
        ycy: "\u044b",
        yen: "\xa5",
        Yfr: "\ud835\udd1c",
        yfr: "\ud835\udd36",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\ud835\udd50",
        yopf: "\ud835\udd6a",
        Yscr: "\ud835\udcb4",
        yscr: "\ud835\udcce",
        YUcy: "\u042e",
        yucy: "\u044e",
        Yuml: "\u0178",
        yuml: "\xff",
        Zacute: "\u0179",
        zacute: "\u017a",
        Zcaron: "\u017d",
        zcaron: "\u017e",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017b",
        zdot: "\u017c",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200b",
        Zeta: "\u0396",
        zeta: "\u03b6",
        Zfr: "\u2128",
        zfr: "\ud835\udd37",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21dd",
        Zopf: "\u2124",
        zopf: "\ud835\udd6b",
        Zscr: "\ud835\udcb5",
        zscr: "\ud835\udccf",
        zwj: "\u200d",
        zwnj: "\u200c"
    }, t4.NGSP_UNICODE = "\ue500", t4.NAMED_ENTITIES.ngsp = t4.NGSP_UNICODE;
}), hn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    class n5 {
        constructor({ closedByChildren: e7 , implicitNamespacePrefix: t5 , contentType: n6 = Dn.TagContentType.PARSABLE_DATA , closedByParent: r4 = !1 , isVoid: s4 = !1 , ignoreFirstLf: i4 = !1  } = {
        }){
            this.closedByChildren = {
            }, this.closedByParent = !1, this.canSelfClose = !1, e7 && e7.length > 0 && e7.forEach((e8)=>this.closedByChildren[e8] = !0
            ), this.isVoid = s4, this.closedByParent = r4 || s4, this.implicitNamespacePrefix = t5 || null, this.contentType = n6, this.ignoreFirstLf = i4;
        }
        isClosedByChild(e) {
            return this.isVoid || e.toLowerCase() in this.closedByChildren;
        }
    }
    let r5, s5;
    t4.HtmlTagDefinition = n5, t4.getHtmlTagDefinition = function(e8) {
        return s5 || (r5 = new n5, s5 = {
            base: new n5({
                isVoid: !0
            }),
            meta: new n5({
                isVoid: !0
            }),
            area: new n5({
                isVoid: !0
            }),
            embed: new n5({
                isVoid: !0
            }),
            link: new n5({
                isVoid: !0
            }),
            img: new n5({
                isVoid: !0
            }),
            input: new n5({
                isVoid: !0
            }),
            param: new n5({
                isVoid: !0
            }),
            hr: new n5({
                isVoid: !0
            }),
            br: new n5({
                isVoid: !0
            }),
            source: new n5({
                isVoid: !0
            }),
            track: new n5({
                isVoid: !0
            }),
            wbr: new n5({
                isVoid: !0
            }),
            p: new n5({
                closedByChildren: [
                    "address",
                    "article",
                    "aside",
                    "blockquote",
                    "div",
                    "dl",
                    "fieldset",
                    "footer",
                    "form",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                    "header",
                    "hgroup",
                    "hr",
                    "main",
                    "nav",
                    "ol",
                    "p",
                    "pre",
                    "section",
                    "table",
                    "ul"
                ],
                closedByParent: !0
            }),
            thead: new n5({
                closedByChildren: [
                    "tbody",
                    "tfoot"
                ]
            }),
            tbody: new n5({
                closedByChildren: [
                    "tbody",
                    "tfoot"
                ],
                closedByParent: !0
            }),
            tfoot: new n5({
                closedByChildren: [
                    "tbody"
                ],
                closedByParent: !0
            }),
            tr: new n5({
                closedByChildren: [
                    "tr"
                ],
                closedByParent: !0
            }),
            td: new n5({
                closedByChildren: [
                    "td",
                    "th"
                ],
                closedByParent: !0
            }),
            th: new n5({
                closedByChildren: [
                    "td",
                    "th"
                ],
                closedByParent: !0
            }),
            col: new n5({
                isVoid: !0
            }),
            svg: new n5({
                implicitNamespacePrefix: "svg"
            }),
            math: new n5({
                implicitNamespacePrefix: "math"
            }),
            li: new n5({
                closedByChildren: [
                    "li"
                ],
                closedByParent: !0
            }),
            dt: new n5({
                closedByChildren: [
                    "dt",
                    "dd"
                ]
            }),
            dd: new n5({
                closedByChildren: [
                    "dt",
                    "dd"
                ],
                closedByParent: !0
            }),
            rb: new n5({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rt: new n5({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rtc: new n5({
                closedByChildren: [
                    "rb",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rp: new n5({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            optgroup: new n5({
                closedByChildren: [
                    "optgroup"
                ],
                closedByParent: !0
            }),
            option: new n5({
                closedByChildren: [
                    "option",
                    "optgroup"
                ],
                closedByParent: !0
            }),
            pre: new n5({
                ignoreFirstLf: !0
            }),
            listing: new n5({
                ignoreFirstLf: !0
            }),
            style: new n5({
                contentType: Dn.TagContentType.RAW_TEXT
            }),
            script: new n5({
                contentType: Dn.TagContentType.RAW_TEXT
            }),
            title: new n5({
                contentType: Dn.TagContentType.ESCAPABLE_RAW_TEXT
            }),
            textarea: new n5({
                contentType: Dn.TagContentType.ESCAPABLE_RAW_TEXT,
                ignoreFirstLf: !0
            })
        }), s5[e8] || r5;
    };
}), dn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    t4.AstPath = class {
        constructor(e7, t5 = -1){
            this.path = e7, this.position = t5;
        }
        get empty() {
            return !this.path || !this.path.length;
        }
        get head() {
            return this.path[0];
        }
        get tail() {
            return this.path[this.path.length - 1];
        }
        parentOf(e) {
            return e && this.path[this.path.indexOf(e) - 1];
        }
        childOf(e) {
            return this.path[this.path.indexOf(e) + 1];
        }
        first(e) {
            for(let t7 = this.path.length - 1; t7 >= 0; t7--){
                let n5 = this.path[t7];
                if (n5 instanceof e) return n5;
            }
        }
        push(e) {
            this.path.push(e);
        }
        pop() {
            return this.path.pop();
        }
    };
}), fn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    t4.Text = class {
        constructor(e7, t5, n5){
            this.value = e7, this.sourceSpan = t5, this.i18n = n5;
        }
        visit(e, t) {
            return e.visitText(this, t);
        }
    };
    t4.CDATA = class {
        constructor(e8, t7){
            this.value = e8, this.sourceSpan = t7;
        }
        visit(e, t) {
            return e.visitCdata(this, t);
        }
    };
    t4.Expansion = class {
        constructor(e9, t8, n6, r4, s4, i4){
            this.switchValue = e9, this.type = t8, this.cases = n6, this.sourceSpan = r4, this.switchValueSourceSpan = s4, this.i18n = i4;
        }
        visit(e, t) {
            return e.visitExpansion(this, t);
        }
    };
    t4.ExpansionCase = class {
        constructor(e10, t9, n7, r5, s5){
            this.value = e10, this.expression = t9, this.sourceSpan = n7, this.valueSourceSpan = r5, this.expSourceSpan = s5;
        }
        visit(e, t) {
            return e.visitExpansionCase(this, t);
        }
    };
    t4.Attribute = class {
        constructor(e13, t10, n8, r6 = null, s6 = null, i5 = null){
            this.name = e13, this.value = t10, this.sourceSpan = n8, this.valueSpan = r6, this.nameSpan = s6, this.i18n = i5;
        }
        visit(e, t) {
            return e.visitAttribute(this, t);
        }
    };
    class n9 {
        constructor(e14, t11, n10, r7, s7 = null, i6 = null, o5 = null, a4 = null){
            this.name = e14, this.attrs = t11, this.children = n10, this.sourceSpan = r7, this.startSourceSpan = s7, this.endSourceSpan = i6, this.nameSpan = o5, this.i18n = a4;
        }
        visit(e, t) {
            return e.visitElement(this, t);
        }
    }
    t4.Element = n9;
    t4.Comment = class {
        constructor(e15, t12){
            this.value = e15, this.sourceSpan = t12;
        }
        visit(e, t) {
            return e.visitComment(this, t);
        }
    };
    function r8(e16, t13, n11 = null) {
        const r9 = [], s8 = e16.visit ? (t14)=>e16.visit(t14, n11) || t14.visit(e16, n11)
         : (t14)=>t14.visit(e16, n11)
        ;
        return (t13.forEach((e17)=>{
            const t14 = s8(e17);
            t14 && r9.push(t14);
        }), r9);
    }
    t4.DocType = class {
        constructor(e16, t13){
            this.value = e16, this.sourceSpan = t13;
        }
        visit(e, t) {
            return e.visitDocType(this, t);
        }
    }, t4.visitAll = r8;
    class s8 {
        constructor(){
        }
        visitElement(e, t) {
            this.visitChildren(t, (t14)=>{
                t14(e.attrs), t14(e.children);
            });
        }
        visitAttribute(e, t) {
        }
        visitText(e, t) {
        }
        visitCdata(e, t) {
        }
        visitComment(e, t) {
        }
        visitDocType(e, t) {
        }
        visitExpansion(e, t) {
            return this.visitChildren(t, (t14)=>{
                t14(e.cases);
            });
        }
        visitExpansionCase(e, t) {
        }
        visitChildren(e, t) {
            let n11 = [], s9 = this;
            return t(function(t14) {
                t14 && n11.push(r8(s9, t14, e));
            }), Array.prototype.concat.apply([], n11);
        }
    }
    function i7(e17) {
        const t14 = e17.sourceSpan.start.offset;
        let r9 = e17.sourceSpan.end.offset;
        return (e17 instanceof n9 && (e17.endSourceSpan ? r9 = e17.endSourceSpan.end.offset : e17.children && e17.children.length && (r9 = i7(e17.children[e17.children.length - 1]).end)), {
            start: t14,
            end: r9
        });
    }
    t4.RecursiveVisitor = s8, t4.findNode = function(e17, t14) {
        const n11 = [];
        return r8(new class extends s8 {
            visit(e, r) {
                const s9 = i7(e);
                if (!(s9.start <= t14 && t14 < s9.end)) return !0;
                n11.push(e);
            }
        }, e17), new dn.AstPath(n11, t14);
    };
}), mn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    }), t4.assertArrayOfStrings = function(e7, t5) {
        if (null != t5) {
            if (!Array.isArray(t5)) throw new Error("Expected '".concat(e7, "' to be an array of strings."));
            for(let n5 = 0; n5 < t5.length; n5 += 1)if ("string" != typeof t5[n5]) throw new Error("Expected '".concat(e7, "' to be an array of strings."));
        }
    };
    const n5 = [
        /^\s*$/,
        /[<>]/,
        /^[{}]$/,
        /&(#|[a-z])/i,
        /^\/\//
    ];
    t4.assertInterpolationSymbols = function(e7, t5) {
        if (!(null == t5 || Array.isArray(t5) && 2 == t5.length)) throw new Error("Expected '".concat(e7, "' to be an array, [start, end]."));
        if (null != t5) {
            const e8 = t5[0], r4 = t5[1];
            n5.forEach((t7)=>{
                if (t7.test(e8) || t7.test(r4)) throw new Error("['".concat(e8, "', '").concat(r4, "'] contains unusable interpolation symbol."));
            });
        }
    };
}), gn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    class n5 {
        constructor(e7, t5){
            this.start = e7, this.end = t5;
        }
        static fromArray(e) {
            return e ? (mn.assertInterpolationSymbols("interpolation", e), new n5(e[0], e[1])) : t4.DEFAULT_INTERPOLATION_CONFIG;
        }
    }
    t4.InterpolationConfig = n5, t4.DEFAULT_INTERPOLATION_CONFIG = new n5("{{", "}}");
}), En = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    const r4 = n4;
    var s4;
    !(function(e7) {
        e7[e7.TAG_OPEN_START = 0] = "TAG_OPEN_START", e7[e7.TAG_OPEN_END = 1] = "TAG_OPEN_END", e7[e7.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e7[e7.TAG_CLOSE = 3] = "TAG_CLOSE", e7[e7.TEXT = 4] = "TEXT", e7[e7.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e7[e7.RAW_TEXT = 6] = "RAW_TEXT", e7[e7.COMMENT_START = 7] = "COMMENT_START", e7[e7.COMMENT_END = 8] = "COMMENT_END", e7[e7.CDATA_START = 9] = "CDATA_START", e7[e7.CDATA_END = 10] = "CDATA_END", e7[e7.ATTR_NAME = 11] = "ATTR_NAME", e7[e7.ATTR_QUOTE = 12] = "ATTR_QUOTE", e7[e7.ATTR_VALUE = 13] = "ATTR_VALUE", e7[e7.DOC_TYPE_START = 14] = "DOC_TYPE_START", e7[e7.DOC_TYPE_END = 15] = "DOC_TYPE_END", e7[e7.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e7[e7.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e7[e7.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e7[e7.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e7[e7.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e7[e7.EOF = 21] = "EOF";
    })(s4 = t4.TokenType || (t4.TokenType = {
    }));
    class i4 {
        constructor(e7, t5, n5){
            this.type = e7, this.parts = t5, this.sourceSpan = n5;
        }
    }
    t4.Token = i4;
    class a4 extends o4.ParseError {
        constructor(e8, t7, n6){
            super(n6, e8), this.tokenType = t7;
        }
    }
    t4.TokenError = a4;
    class u4 {
        constructor(e9, t8){
            this.tokens = e9, this.errors = t8;
        }
    }
    t4.TokenizeResult = u4, t4.tokenize = function(e10, t9, n7, r5 = {
    }) {
        return new h4(new o4.ParseSourceFile(e10, t9), n7, r5).tokenize();
    };
    const c4 = /\r\n?/g;
    function l4(e10) {
        const t9 = e10 === n4.$EOF ? "EOF" : String.fromCharCode(e10);
        return 'Unexpected character "'.concat(t9, '"');
    }
    function p4(e10) {
        return 'Unknown entity "'.concat(e10, '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax');
    }
    class D4 {
        constructor(e10){
            this.error = e10;
        }
    }
    class h4 {
        constructor(e13, t9, n7){
            this._getTagContentType = t9, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = n7.tokenizeExpansionForms || !1, this._interpolationConfig = n7.interpolationConfig || gn.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = n7.leadingTriviaChars && n7.leadingTriviaChars.map((e14)=>e14.codePointAt(0) || 0
            ), this._canSelfClose = n7.canSelfClose || !1, this._allowHtmComponentClosingTags = n7.allowHtmComponentClosingTags || !1;
            const r5 = n7.range || {
                endPos: e13.content.length,
                startPos: 0,
                startLine: 0,
                startCol: 0
            };
            this._cursor = n7.escapedString ? new T3(e13, r5) : new C3(e13, r5);
            try {
                this._cursor.init();
            } catch (e) {
                this.handleError(e);
            }
        }
        _processCarriageReturns(e) {
            return e.replace(c4, "\n");
        }
        tokenize() {
            for(; this._cursor.peek() !== n4.$EOF;){
                const e14 = this._cursor.clone();
                try {
                    if (this._attemptCharCode(n4.$LT)) {
                        if (this._attemptCharCode(n4.$BANG)) this._attemptStr("[CDATA[") ? this._consumeCdata(e14) : this._attemptStr("--") ? this._consumeComment(e14) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e14) : this._consumeBogusComment(e14);
                        else if (this._attemptCharCode(n4.$SLASH)) this._consumeTagClose(e14);
                        else {
                            const t10 = this._cursor.clone();
                            this._attemptCharCode(n4.$QUESTION) ? (this._cursor = t10, this._consumeBogusComment(e14)) : this._consumeTagOpen(e14);
                        }
                    } else this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
                } catch (e) {
                    this.handleError(e);
                }
            }
            return this._beginToken(s4.EOF), this._endToken([]), new u4(function(e14) {
                const t10 = [];
                let n8 = void 0;
                for(let r6 = 0; r6 < e14.length; r6++){
                    const i5 = e14[r6];
                    n8 && n8.type == s4.TEXT && i5.type == s4.TEXT ? (n8.parts[0] += i5.parts[0], n8.sourceSpan.end = i5.sourceSpan.end) : (n8 = i5, t10.push(n8));
                }
                return t10;
            }(this.tokens), this.errors);
        }
        _tokenizeExpansionForm() {
            if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
            if (((e14 = this._cursor.peek()) === n4.$EQ || n4.isAsciiLetter(e14) || n4.isDigit(e14)) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), !0;
            var e14;
            if (this._cursor.peek() === n4.$RBRACE) {
                if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
                if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
            }
            return !1;
        }
        _beginToken(e, t = this._cursor.clone()) {
            this._currentTokenStart = t, this._currentTokenType = e;
        }
        _endToken(e, t = this._cursor.clone()) {
            if (null === this._currentTokenStart) throw new a4("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t));
            if (null === this._currentTokenType) throw new a4("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
            const n8 = new i4(this._currentTokenType, e, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
            return this.tokens.push(n8), this._currentTokenStart = null, this._currentTokenType = null, n8;
        }
        _createError(e, t) {
            this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
            const n8 = new a4(e, this._currentTokenType, t);
            return this._currentTokenStart = null, this._currentTokenType = null, new D4(n8);
        }
        handleError(e) {
            if (e instanceof y4 && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof D4)) throw e;
            this.errors.push(e.error);
        }
        _attemptCharCode(e) {
            return this._cursor.peek() === e && (this._cursor.advance(), !0);
        }
        _attemptCharCodeCaseInsensitive(e) {
            return t10 = this._cursor.peek(), n8 = e, E4(t10) == E4(n8) && (this._cursor.advance(), !0);
            var t10, n8;
        }
        _requireCharCode(e) {
            const t10 = this._cursor.clone();
            if (!this._attemptCharCode(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t10));
        }
        _attemptStr(e) {
            const t10 = e.length;
            if (this._cursor.charsLeft() < t10) return !1;
            const n8 = this._cursor.clone();
            for(let r6 = 0; r6 < t10; r6++)if (!this._attemptCharCode(e.charCodeAt(r6))) return this._cursor = n8, !1;
            return !0;
        }
        _attemptStrCaseInsensitive(e) {
            for(let t10 = 0; t10 < e.length; t10++)if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t10))) return !1;
            return !0;
        }
        _requireStr(e) {
            const t10 = this._cursor.clone();
            if (!this._attemptStr(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t10));
        }
        _requireStrCaseInsensitive(e) {
            const t10 = this._cursor.clone();
            if (!this._attemptStrCaseInsensitive(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t10));
        }
        _attemptCharCodeUntilFn(e) {
            for(; !e(this._cursor.peek());)this._cursor.advance();
        }
        _requireCharCodeUntilFn(e, t) {
            const n8 = this._cursor.clone();
            this._attemptCharCodeUntilFn(e);
            if (this._cursor.clone().diff(n8) < t) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(n8));
        }
        _attemptUntilChar(e) {
            for(; this._cursor.peek() !== e;)this._cursor.advance();
        }
        _readChar(e) {
            if (e && this._cursor.peek() === n4.$AMPERSAND) return this._decodeEntity();
            {
                const e14 = String.fromCodePoint(this._cursor.peek());
                return this._cursor.advance(), e14;
            }
        }
        _decodeEntity() {
            const e14 = this._cursor.clone();
            if (this._cursor.advance(), !this._attemptCharCode(n4.$HASH)) {
                const t10 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(g3), this._cursor.peek() != n4.$SEMICOLON) return this._cursor = t10, "&";
                const n8 = this._cursor.getChars(t10);
                this._cursor.advance();
                const s5 = Dn.NAMED_ENTITIES[n8];
                if (!s5) throw this._createError(p4(n8), this._cursor.getSpan(e14));
                return s5;
            }
            {
                const t10 = this._attemptCharCode(n4.$x) || this._attemptCharCode(n4.$X), n8 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(m4), this._cursor.peek() != n4.$SEMICOLON) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan());
                const s5 = this._cursor.getChars(n8);
                this._cursor.advance();
                try {
                    const e15 = parseInt(s5, t10 ? 16 : 10);
                    return String.fromCharCode(e15);
                } catch (t) {
                    throw this._createError(p4(this._cursor.getChars(e14)), this._cursor.getSpan());
                }
            }
        }
        _consumeRawText(e, t) {
            this._beginToken(e ? s4.ESCAPABLE_RAW_TEXT : s4.RAW_TEXT);
            const n8 = [];
            for(;;){
                const r6 = this._cursor.clone(), s5 = t();
                if (this._cursor = r6, s5) break;
                n8.push(this._readChar(e));
            }
            return this._endToken([
                this._processCarriageReturns(n8.join(""))
            ]);
        }
        _consumeComment(e) {
            this._beginToken(s4.COMMENT_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._attemptStr("--\x3e")
            ), this._beginToken(s4.COMMENT_END), this._requireStr("--\x3e"), this._endToken([]);
        }
        _consumeBogusComment(e) {
            this._beginToken(s4.COMMENT_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._cursor.peek() === n4.$GT
            ), this._beginToken(s4.COMMENT_END), this._cursor.advance(), this._endToken([]);
        }
        _consumeCdata(e) {
            this._beginToken(s4.CDATA_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._attemptStr("]]>")
            ), this._beginToken(s4.CDATA_END), this._requireStr("]]>"), this._endToken([]);
        }
        _consumeDocType(e) {
            this._beginToken(s4.DOC_TYPE_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._cursor.peek() === n4.$GT
            ), this._beginToken(s4.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
        }
        _consumePrefixAndName() {
            const e14 = this._cursor.clone();
            let t10 = "";
            for(; this._cursor.peek() !== n4.$COLON && !(((n8 = this._cursor.peek()) < n4.$a || n4.$z < n8) && (n8 < n4.$A || n4.$Z < n8) && (n8 < n4.$0 || n8 > n4.$9));)this._cursor.advance();
            var n8;
            let s5;
            this._cursor.peek() === n4.$COLON ? (t10 = this._cursor.getChars(e14), this._cursor.advance(), s5 = this._cursor.clone()) : s5 = e14, this._requireCharCodeUntilFn(f4, "" === t10 ? 0 : 1);
            return [
                t10,
                this._cursor.getChars(s5)
            ];
        }
        _consumeTagOpen(e) {
            let t10, n8, i5, o5 = this.tokens.length;
            const a5 = this._cursor.clone(), u5 = [];
            try {
                if (!n4.isAsciiLetter(this._cursor.peek())) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(e));
                for(i5 = this._consumeTagOpenStart(e), n8 = i5.parts[0], t10 = i5.parts[1], this._attemptCharCodeUntilFn(d4); this._cursor.peek() !== n4.$SLASH && this._cursor.peek() !== n4.$GT;){
                    const [e14, t11] = this._consumeAttributeName();
                    if (this._attemptCharCodeUntilFn(d4), this._attemptCharCode(n4.$EQ)) {
                        this._attemptCharCodeUntilFn(d4);
                        const n9 = this._consumeAttributeValue();
                        u5.push({
                            prefix: e14,
                            name: t11,
                            value: n9
                        });
                    } else u5.push({
                        prefix: e14,
                        name: t11
                    });
                    this._attemptCharCodeUntilFn(d4);
                }
                this._consumeTagOpenEnd();
            } catch (t) {
                if (t instanceof D4) return this._cursor = a5, i5 && (this.tokens.length = o5), this._beginToken(s4.TEXT, e), void this._endToken([
                    "<"
                ]);
                throw t;
            }
            if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === s4.TAG_OPEN_END_VOID) return;
            const c5 = this._getTagContentType(t10, n8, this._fullNameStack.length > 0, u5);
            this._handleFullNameStackForTagOpen(n8, t10), c5 === Dn.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(n8, t10, !1) : c5 === Dn.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n8, t10, !0);
        }
        _consumeRawTextWithTagClose(e, t, n) {
            this._consumeRawText(n, ()=>!!this._attemptCharCode(n4.$LT) && (!!this._attemptCharCode(n4.$SLASH) && (this._attemptCharCodeUntilFn(d4), !!this._attemptStrCaseInsensitive(e ? "".concat(e, ":").concat(t) : t) && (this._attemptCharCodeUntilFn(d4), this._attemptCharCode(n4.$GT))))
            );
            this._beginToken(s4.TAG_CLOSE), this._requireCharCodeUntilFn((e14)=>e14 === n4.$GT
            , 3), this._cursor.advance(), this._endToken([
                e,
                t
            ]), this._handleFullNameStackForTagClose(e, t);
        }
        _consumeTagOpenStart(e) {
            this._beginToken(s4.TAG_OPEN_START, e);
            const t10 = this._consumePrefixAndName();
            return this._endToken(t10);
        }
        _consumeAttributeName() {
            const e14 = this._cursor.peek();
            if (e14 === n4.$SQ || e14 === n4.$DQ) throw this._createError(l4(e14), this._cursor.getSpan());
            this._beginToken(s4.ATTR_NAME);
            const t10 = this._consumePrefixAndName();
            return this._endToken(t10), t10;
        }
        _consumeAttributeValue() {
            let e14;
            if (this._cursor.peek() === n4.$SQ || this._cursor.peek() === n4.$DQ) {
                this._beginToken(s4.ATTR_QUOTE);
                const t10 = this._cursor.peek();
                this._cursor.advance(), this._endToken([
                    String.fromCodePoint(t10)
                ]), this._beginToken(s4.ATTR_VALUE);
                const n8 = [];
                for(; this._cursor.peek() !== t10;)n8.push(this._readChar(!0));
                e14 = this._processCarriageReturns(n8.join("")), this._endToken([
                    e14
                ]), this._beginToken(s4.ATTR_QUOTE), this._cursor.advance(), this._endToken([
                    String.fromCodePoint(t10)
                ]);
            } else {
                this._beginToken(s4.ATTR_VALUE);
                const t10 = this._cursor.clone();
                this._requireCharCodeUntilFn(f4, 1), e14 = this._processCarriageReturns(this._cursor.getChars(t10)), this._endToken([
                    e14
                ]);
            }
            return e14;
        }
        _consumeTagOpenEnd() {
            const e14 = this._attemptCharCode(n4.$SLASH) ? s4.TAG_OPEN_END_VOID : s4.TAG_OPEN_END;
            this._beginToken(e14), this._requireCharCode(n4.$GT), this._endToken([]);
        }
        _consumeTagClose(e) {
            if (this._beginToken(s4.TAG_CLOSE, e), this._attemptCharCodeUntilFn(d4), this._allowHtmComponentClosingTags && this._attemptCharCode(n4.$SLASH)) this._attemptCharCodeUntilFn(d4), this._requireCharCode(n4.$GT), this._endToken([]);
            else {
                const [e14, t10] = this._consumePrefixAndName();
                this._attemptCharCodeUntilFn(d4), this._requireCharCode(n4.$GT), this._endToken([
                    e14,
                    t10
                ]), this._handleFullNameStackForTagClose(e14, t10);
            }
        }
        _consumeExpansionFormStart() {
            this._beginToken(s4.EXPANSION_FORM_START), this._requireCharCode(n4.$LBRACE), this._endToken([]), this._expansionCaseStack.push(s4.EXPANSION_FORM_START), this._beginToken(s4.RAW_TEXT);
            const e14 = this._readUntil(n4.$COMMA);
            this._endToken([
                e14
            ]), this._requireCharCode(n4.$COMMA), this._attemptCharCodeUntilFn(d4), this._beginToken(s4.RAW_TEXT);
            const t10 = this._readUntil(n4.$COMMA);
            this._endToken([
                t10
            ]), this._requireCharCode(n4.$COMMA), this._attemptCharCodeUntilFn(d4);
        }
        _consumeExpansionCaseStart() {
            this._beginToken(s4.EXPANSION_CASE_VALUE);
            const e14 = this._readUntil(n4.$LBRACE).trim();
            this._endToken([
                e14
            ]), this._attemptCharCodeUntilFn(d4), this._beginToken(s4.EXPANSION_CASE_EXP_START), this._requireCharCode(n4.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(d4), this._expansionCaseStack.push(s4.EXPANSION_CASE_EXP_START);
        }
        _consumeExpansionCaseEnd() {
            this._beginToken(s4.EXPANSION_CASE_EXP_END), this._requireCharCode(n4.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(d4), this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
            this._beginToken(s4.EXPANSION_FORM_END), this._requireCharCode(n4.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
        }
        _consumeText() {
            const e14 = this._cursor.clone();
            this._beginToken(s4.TEXT, e14);
            const t10 = [];
            do {
                this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t10.push(this._interpolationConfig.start), this._inInterpolation = !0) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t10.push(this._interpolationConfig.end), this._inInterpolation = !1) : t10.push(this._readChar(!0));
            }while (!this._isTextEnd())
            this._endToken([
                this._processCarriageReturns(t10.join(""))
            ]);
        }
        _isTextEnd() {
            if (this._cursor.peek() === n4.$LT || this._cursor.peek() === n4.$EOF) return !0;
            if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart()) return !0;
                if (this._cursor.peek() === n4.$RBRACE && this._isInExpansionCase()) return !0;
            }
            return !1;
        }
        _readUntil(e) {
            const t10 = this._cursor.clone();
            return this._attemptUntilChar(e), this._cursor.getChars(t10);
        }
        _isInExpansionCase() {
            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s4.EXPANSION_CASE_EXP_START;
        }
        _isInExpansionForm() {
            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s4.EXPANSION_FORM_START;
        }
        isExpansionFormStart() {
            if (this._cursor.peek() !== n4.$LBRACE) return !1;
            if (this._interpolationConfig) {
                const e14 = this._cursor.clone(), t10 = this._attemptStr(this._interpolationConfig.start);
                return this._cursor = e14, !t10;
            }
            return !0;
        }
        _handleFullNameStackForTagOpen(e, t) {
            const n8 = Dn.mergeNsAndName(e, t);
            0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] !== n8 || this._fullNameStack.push(n8);
        }
        _handleFullNameStackForTagClose(e, t) {
            const n8 = Dn.mergeNsAndName(e, t);
            0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] === n8 && this._fullNameStack.pop();
        }
    }
    function d4(e14) {
        return !n4.isWhitespace(e14) || e14 === n4.$EOF;
    }
    function f4(e14) {
        return n4.isWhitespace(e14) || e14 === n4.$GT || e14 === n4.$SLASH || e14 === n4.$SQ || e14 === n4.$DQ || e14 === n4.$EQ;
    }
    function m4(e14) {
        return e14 == n4.$SEMICOLON || e14 == n4.$EOF || !n4.isAsciiHexDigit(e14);
    }
    function g3(e14) {
        return e14 == n4.$SEMICOLON || e14 == n4.$EOF || !n4.isAsciiLetter(e14);
    }
    function E4(e14) {
        return e14 >= n4.$a && e14 <= n4.$z ? e14 - n4.$a + n4.$A : e14;
    }
    class C3 {
        constructor(e14, t10){
            if (e14 instanceof C3) this.file = e14.file, this.input = e14.input, this.end = e14.end, this.state = Object.assign({
            }, e14.state);
            else {
                if (!t10) throw new Error("Programming error: the range argument must be provided with a file argument.");
                this.file = e14, this.input = e14.content, this.end = t10.endPos, this.state = {
                    peek: -1,
                    offset: t10.startPos,
                    line: t10.startLine,
                    column: t10.startCol
                };
            }
        }
        clone() {
            return new C3(this);
        }
        peek() {
            return this.state.peek;
        }
        charsLeft() {
            return this.end - this.state.offset;
        }
        diff(e) {
            return this.state.offset - e.state.offset;
        }
        advance() {
            this.advanceState(this.state);
        }
        init() {
            this.updatePeek(this.state);
        }
        getSpan(e, t) {
            if (e = e || this, t) for(e = e.clone(); this.diff(e) > 0 && -1 !== t.indexOf(e.peek());)e.advance();
            return new o4.ParseSourceSpan(new o4.ParseLocation(e.file, e.state.offset, e.state.line, e.state.column), new o4.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
        }
        getChars(e) {
            return this.input.substring(e.state.offset, this.state.offset);
        }
        charAt(e) {
            return this.input.charCodeAt(e);
        }
        advanceState(e) {
            if (e.offset >= this.end) throw this.state = e, new y4('Unexpected character "EOF"', this);
            const t11 = this.charAt(e.offset);
            t11 === n4.$LF ? (e.line++, e.column = 0) : n4.isNewLine(t11) || e.column++, e.offset++, this.updatePeek(e);
        }
        updatePeek(e) {
            e.peek = e.offset >= this.end ? n4.$EOF : this.charAt(e.offset);
        }
    }
    class T3 extends C3 {
        constructor(e15, t11){
            e15 instanceof T3 ? (super(e15), this.internalState = Object.assign({
            }, e15.internalState)) : (super(e15, t11), this.internalState = this.state);
        }
        advance() {
            this.state = this.internalState, super.advance(), this.processEscapeSequence();
        }
        init() {
            super.init(), this.processEscapeSequence();
        }
        clone() {
            return new T3(this);
        }
        getChars(e) {
            const t12 = e.clone();
            let n8 = "";
            for(; t12.internalState.offset < this.internalState.offset;)n8 += String.fromCodePoint(t12.peek()), t12.advance();
            return n8;
        }
        processEscapeSequence() {
            const e16 = ()=>this.internalState.peek
            ;
            if (e16() === n4.$BACKSLASH) {
                if (this.internalState = Object.assign({
                }, this.state), this.advanceState(this.internalState), e16() === n4.$n) this.state.peek = n4.$LF;
                else if (e16() === n4.$r) this.state.peek = n4.$CR;
                else if (e16() === n4.$v) this.state.peek = n4.$VTAB;
                else if (e16() === n4.$t) this.state.peek = n4.$TAB;
                else if (e16() === n4.$b) this.state.peek = n4.$BSPACE;
                else if (e16() === n4.$f) this.state.peek = n4.$FF;
                else if (e16() === n4.$u) {
                    if (this.advanceState(this.internalState), e16() === n4.$LBRACE) {
                        this.advanceState(this.internalState);
                        const t12 = this.clone();
                        let n8 = 0;
                        for(; e16() !== n4.$RBRACE;)this.advanceState(this.internalState), n8++;
                        this.state.peek = this.decodeHexDigits(t12, n8);
                    } else {
                        const e17 = this.clone();
                        this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e17, 4);
                    }
                } else if (e16() === n4.$x) {
                    this.advanceState(this.internalState);
                    const e17 = this.clone();
                    this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e17, 2);
                } else if (n4.isOctalDigit(e16())) {
                    let t12 = "", n8 = 0, s5 = this.clone();
                    for(; n4.isOctalDigit(e16()) && n8 < 3;)s5 = this.clone(), t12 += String.fromCodePoint(e16()), this.advanceState(this.internalState), n8++;
                    this.state.peek = parseInt(t12, 8), this.internalState = s5.internalState;
                } else n4.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
            }
        }
        decodeHexDigits(e, t) {
            const n8 = this.input.substr(e.internalState.offset, t), r6 = parseInt(n8, 16);
            if (isNaN(r6)) throw e.state = e.internalState, new y4("Invalid hexadecimal escape sequence", e);
            return r6;
        }
    }
    class y4 {
        constructor(e16, t12){
            this.msg = e16, this.cursor = t12;
        }
    }
    t4.CursorError = y4;
}), Cn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    class n5 extends o4.ParseError {
        constructor(e7, t5, n6){
            super(t5, n6), this.elementName = e7;
        }
        static create(e, t, r) {
            return new n5(e, t, r);
        }
    }
    t4.TreeError = n5;
    class r4 {
        constructor(e8, t7){
            this.rootNodes = e8, this.errors = t7;
        }
    }
    t4.ParseTreeResult = r4;
    t4.Parser = class {
        constructor(e9){
            this.getTagDefinition = e9;
        }
        parse(e, t, n, i = !1, o) {
            const a4 = (e10)=>(t8, ...n7)=>e10(t8.toLowerCase(), ...n7)
            , u4 = i ? this.getTagDefinition : a4(this.getTagDefinition), c4 = (e10)=>u4(e10).contentType
            , l4 = i ? o : a4(o), p4 = o ? (e10, t8, n7, r5)=>{
                const s4 = l4(e10, t8, n7, r5);
                return (void 0) !== s4 ? s4 : c4(e10);
            } : c4, D4 = En.tokenize(e, t, p4, n), h4 = n && n.canSelfClose || !1, d4 = n && n.allowHtmComponentClosingTags || !1, f4 = new s4(D4.tokens, u4, h4, d4, i).build();
            return new r4(f4.rootNodes, D4.errors.concat(f4.errors));
        }
    };
    class s4 {
        constructor(e10, t8, n7, r5, s5){
            this.tokens = e10, this.getTagDefinition = t8, this.canSelfClose = n7, this.allowHtmComponentClosingTags = r5, this.isTagNameCaseSensitive = s5, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
        }
        build() {
            for(; this._peek.type !== En.TokenType.EOF;)this._peek.type === En.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === En.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === En.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === En.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === En.TokenType.TEXT || this._peek.type === En.TokenType.RAW_TEXT || this._peek.type === En.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === En.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === En.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
            return new r4(this._rootNodes, this._errors);
        }
        _advance() {
            const e13 = this._peek;
            return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e13;
        }
        _advanceIf(e) {
            return this._peek.type === e ? this._advance() : null;
        }
        _consumeCdata(e) {
            const t9 = this._advance(), n8 = this._getText(t9), r6 = this._advanceIf(En.TokenType.CDATA_END);
            this._addToParent(new fn.CDATA(n8, new o4.ParseSourceSpan(e.sourceSpan.start, (r6 || t9).sourceSpan.end)));
        }
        _consumeComment(e) {
            const t9 = this._advanceIf(En.TokenType.RAW_TEXT), n8 = this._advanceIf(En.TokenType.COMMENT_END), r6 = null != t9 ? t9.parts[0].trim() : null, s6 = new o4.ParseSourceSpan(e.sourceSpan.start, (n8 || t9 || e).sourceSpan.end);
            this._addToParent(new fn.Comment(r6, s6));
        }
        _consumeDocType(e) {
            const t9 = this._advanceIf(En.TokenType.RAW_TEXT), n8 = this._advanceIf(En.TokenType.DOC_TYPE_END), r6 = null != t9 ? t9.parts[0].trim() : null, s6 = new o4.ParseSourceSpan(e.sourceSpan.start, (n8 || t9 || e).sourceSpan.end);
            this._addToParent(new fn.DocType(r6, s6));
        }
        _consumeExpansion(e) {
            const t9 = this._advance(), r6 = this._advance(), s6 = [];
            for(; this._peek.type === En.TokenType.EXPANSION_CASE_VALUE;){
                const e13 = this._parseExpansionCase();
                if (!e13) return;
                s6.push(e13);
            }
            if (this._peek.type !== En.TokenType.EXPANSION_FORM_END) return void this._errors.push(n5.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
            const i4 = new o4.ParseSourceSpan(e.sourceSpan.start, this._peek.sourceSpan.end);
            this._addToParent(new fn.Expansion(t9.parts[0], r6.parts[0], s6, i4, t9.sourceSpan)), this._advance();
        }
        _parseExpansionCase() {
            const e13 = this._advance();
            if (this._peek.type !== En.TokenType.EXPANSION_CASE_EXP_START) return this._errors.push(n5.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
            const t9 = this._advance(), r6 = this._collectExpansionExpTokens(t9);
            if (!r6) return null;
            const i4 = this._advance();
            r6.push(new En.Token(En.TokenType.EOF, [], i4.sourceSpan));
            const a4 = new s4(r6, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
            if (a4.errors.length > 0) return this._errors = this._errors.concat(a4.errors), null;
            const u4 = new o4.ParseSourceSpan(e13.sourceSpan.start, i4.sourceSpan.end), c4 = new o4.ParseSourceSpan(t9.sourceSpan.start, i4.sourceSpan.end);
            return new fn.ExpansionCase(e13.parts[0], a4.rootNodes, u4, e13.sourceSpan, c4);
        }
        _collectExpansionExpTokens(e) {
            const t9 = [], r6 = [
                En.TokenType.EXPANSION_CASE_EXP_START
            ];
            for(;;){
                if (this._peek.type !== En.TokenType.EXPANSION_FORM_START && this._peek.type !== En.TokenType.EXPANSION_CASE_EXP_START || r6.push(this._peek.type), this._peek.type === En.TokenType.EXPANSION_CASE_EXP_END) {
                    if (!i4(r6, En.TokenType.EXPANSION_CASE_EXP_START)) return this._errors.push(n5.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                    if (r6.pop(), 0 == r6.length) return t9;
                }
                if (this._peek.type === En.TokenType.EXPANSION_FORM_END) {
                    if (!i4(r6, En.TokenType.EXPANSION_FORM_START)) return this._errors.push(n5.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                    r6.pop();
                }
                if (this._peek.type === En.TokenType.EOF) return this._errors.push(n5.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                t9.push(this._advance());
            }
        }
        _getText(e) {
            let t9 = e.parts[0];
            if (t9.length > 0 && "\n" == t9[0]) {
                const e13 = this._getParentElement();
                null != e13 && 0 == e13.children.length && this.getTagDefinition(e13.name).ignoreFirstLf && (t9 = t9.substring(1));
            }
            return t9;
        }
        _consumeText(e) {
            const t9 = this._getText(e);
            t9.length > 0 && this._addToParent(new fn.Text(t9, e.sourceSpan));
        }
        _closeVoidElement() {
            const e13 = this._getParentElement();
            e13 && this.getTagDefinition(e13.name).isVoid && this._elementStack.pop();
        }
        _consumeStartTag(e) {
            const t9 = e.parts[0], r6 = e.parts[1], s6 = [];
            for(; this._peek.type === En.TokenType.ATTR_NAME;)s6.push(this._consumeAttr(this._advance()));
            const i4 = this._getElementFullName(t9, r6, this._getParentElement());
            let a4 = !1;
            if (this._peek.type === En.TokenType.TAG_OPEN_END_VOID) {
                this._advance(), a4 = !0;
                const t10 = this.getTagDefinition(i4);
                this.canSelfClose || t10.canSelfClose || null !== Dn.getNsPrefix(i4) || t10.isVoid || this._errors.push(n5.create(i4, e.sourceSpan, 'Only void and foreign elements can be self closed "'.concat(e.parts[1], '"')));
            } else this._peek.type === En.TokenType.TAG_OPEN_END && (this._advance(), a4 = !1);
            const u4 = this._peek.sourceSpan.start, c4 = new o4.ParseSourceSpan(e.sourceSpan.start, u4), l4 = new o4.ParseSourceSpan(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), p4 = new fn.Element(i4, s6, [], c4, c4, void 0, l4);
            this._pushElement(p4), a4 && (this._popElement(i4), p4.endSourceSpan = c4);
        }
        _pushElement(e) {
            const t9 = this._getParentElement();
            t9 && this.getTagDefinition(t9.name).isClosedByChild(e.name) && this._elementStack.pop(), this._addToParent(e), this._elementStack.push(e);
        }
        _consumeEndTag(e) {
            const t9 = this.allowHtmComponentClosingTags && 0 === e.parts.length ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getParentElement());
            if (this._getParentElement() && (this._getParentElement().endSourceSpan = e.sourceSpan), t9 && this.getTagDefinition(t9).isVoid) this._errors.push(n5.create(t9, e.sourceSpan, 'Void elements do not have end tags "'.concat(e.parts[1], '"')));
            else if (!this._popElement(t9)) {
                const r6 = 'Unexpected closing tag "'.concat(t9, '". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags');
                this._errors.push(n5.create(t9, e.sourceSpan, r6));
            }
        }
        _popElement(e) {
            for(let t9 = this._elementStack.length - 1; t9 >= 0; t9--){
                const n8 = this._elementStack[t9];
                if (!e || (Dn.getNsPrefix(n8.name) ? n8.name == e : n8.name.toLowerCase() == e.toLowerCase())) return this._elementStack.splice(t9, this._elementStack.length - t9), !0;
                if (!this.getTagDefinition(n8.name).closedByParent) return !1;
            }
            return !1;
        }
        _consumeAttr(e) {
            const t9 = Dn.mergeNsAndName(e.parts[0], e.parts[1]);
            let n8 = e.sourceSpan.end, r6 = "", s6 = void 0, i4 = void 0;
            if (this._peek.type === En.TokenType.ATTR_QUOTE) {
                i4 = this._advance().sourceSpan.start;
            }
            if (this._peek.type === En.TokenType.ATTR_VALUE) {
                const e13 = this._advance();
                r6 = e13.parts[0], n8 = e13.sourceSpan.end, s6 = e13.sourceSpan;
            }
            if (this._peek.type === En.TokenType.ATTR_QUOTE) {
                n8 = this._advance().sourceSpan.end, s6 = new o4.ParseSourceSpan(i4, n8);
            }
            return new fn.Attribute(t9, r6, new o4.ParseSourceSpan(e.sourceSpan.start, n8), s6, e.sourceSpan);
        }
        _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        _getParentElementSkippingContainers() {
            let e13 = null;
            for(let t9 = this._elementStack.length - 1; t9 >= 0; t9--){
                if (!Dn.isNgContainer(this._elementStack[t9].name)) return {
                    parent: this._elementStack[t9],
                    container: e13
                };
                e13 = this._elementStack[t9];
            }
            return {
                parent: null,
                container: e13
            };
        }
        _addToParent(e) {
            const t9 = this._getParentElement();
            null != t9 ? t9.children.push(e) : this._rootNodes.push(e);
        }
        _insertBeforeContainer(e, t, n) {
            if (t) {
                if (e) {
                    const r6 = e.children.indexOf(t);
                    e.children[r6] = n;
                } else this._rootNodes.push(n);
                n.children.push(t), this._elementStack.splice(this._elementStack.indexOf(t), 0, n);
            } else this._addToParent(n), this._elementStack.push(n);
        }
        _getElementFullName(e, t, n) {
            return "" === e && "" === (e = this.getTagDefinition(t).implicitNamespacePrefix || "") && null != n && (e = Dn.getNsPrefix(n.name)), Dn.mergeNsAndName(e, t);
        }
    }
    function i4(e13, t9) {
        return e13.length > 0 && e13[e13.length - 1] === t9;
    }
}), Tn1 = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    });
    var n5 = Cn;
    t4.ParseTreeResult = n5.ParseTreeResult, t4.TreeError = n5.TreeError;
    class r4 extends Cn.Parser {
        constructor(){
            super(hn.getHtmlTagDefinition);
        }
        parse(e, t, n, r = !1, s) {
            return super.parse(e, t, n, r, s);
        }
    }
    t4.HtmlParser = r4;
}), yn = t3(function(e6, t4) {
    Object.defineProperty(t4, "__esModule", {
        value: !0
    }), t4.TagContentType = Dn.TagContentType;
    let n5 = null;
    t4.parse = function(e7, t5 = {
    }) {
        const { canSelfClose: r4 = !1 , allowHtmComponentClosingTags: s4 = !1 , isTagNameCaseSensitive: i4 = !1 , getTagContentType: o5  } = t5;
        return (n5 || (n5 = new Tn1.HtmlParser), n5).parse(e7, "angular-html-parser", {
            tokenizeExpansionForms: !1,
            interpolationConfig: void 0,
            canSelfClose: r4,
            allowHtmComponentClosingTags: s4
        }, i4, o5);
    };
});
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
        }
        var test2 = {
        };
        for(var i4 = 0; i4 < 10; i4++){
            test2["_" + String.fromCharCode(i4)] = i4;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n5) {
            return test2[n5];
        });
        if (order2.join("") !== "0123456789") {
            return false;
        }
        var test3 = {
        };
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({
        }, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s4 = 1; s4 < arguments.length; s4++){
        from = Object(arguments[s4]);
        for(var key in from){
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i4 = 0; i4 < symbols.length; i4++){
                if (propIsEnumerable.call(from, symbols[i4])) {
                    to[symbols[i4]] = from[symbols[i4]];
                }
            }
        }
    }
    return to;
};
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var e6 = "-ms-";
var r4 = "-moz-";
var a4 = "-webkit-";
var c4 = "comm";
var n5 = "rule";
var t4 = "decl";
var i4 = "@import";
var p4 = "@keyframes";
var k3 = Math.abs;
var d4 = String.fromCharCode;
function g3(e21) {
    return e21.trim();
}
function x1(e21, r21) {
    return (e21 = r21.exec(e21)) ? e21[0] : e21;
}
function y4(e21, r21, a21) {
    return e21.replace(r21, a21);
}
function j2(e21, r21) {
    return e21.indexOf(r21);
}
function z2(e21, r21) {
    return e21.charCodeAt(r21) | 0;
}
function C3(e21, r21, a21) {
    return e21.slice(r21, a21);
}
function A3(e21) {
    return e21.length;
}
function M2(e21) {
    return e21.length;
}
function O2(e21, r21) {
    return r21.push(e21), e21;
}
function S2(e21, r21) {
    return e21.map(r21).join("");
}
var q3 = 1;
var B2 = 1;
var D4 = 0;
var E4 = 0;
var F3 = 0;
var G2 = "";
function H2(e21, r21, a21, c21, n21, t21, s21) {
    return {
        value: e21,
        root: r21,
        parent: a21,
        type: c21,
        props: n21,
        children: t21,
        line: q3,
        column: B2,
        length: s21,
        return: ""
    };
}
function I2(e21, r21, a21) {
    return H2(e21, r21.root, r21.parent, a21, r21.props, r21.children, 0);
}
function J() {
    return F3;
}
function K2() {
    F3 = E4 < D4 ? z2(G2, E4++) : 0;
    if (B2++, F3 === 10) B2 = 1, q3++;
    return F3;
}
function L() {
    return z2(G2, E4);
}
function N3() {
    return E4;
}
function P2(e21, r21) {
    return C3(G2, e21, r21);
}
function Q1(e21) {
    switch(e21){
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1;
    }
    return 0;
}
function R3(e21) {
    return q3 = B2 = 1, D4 = A3(G2 = e21), E4 = 0, [];
}
function T3(e21) {
    return G2 = "", e21;
}
function W1(e21) {
    while(F3 = L())if (F3 < 33) K2();
    else break;
    return Q1(e21) > 2 || Q1(F3) > 3 ? "" : " ";
}
function Y1(e21) {
    while(K2())switch(F3){
        case e21:
            return E4;
        case 34:
        case 39:
            return Y1(e21 === 34 || e21 === 39 ? e21 : F3);
        case 40:
            if (e21 === 41) Y1(e21);
            break;
        case 92:
            K2();
            break;
    }
    return E4;
}
function Z2(e21, r21) {
    while(K2())if (e21 + F3 === 47 + 10) break;
    else if (e21 + F3 === 42 + 42 && L() === 47) break;
    return "/*" + P2(r21, E4 - 1) + "*" + d4(e21 === 47 ? e21 : K2());
}
function _3(e21) {
    while(!Q1(L()))K2();
    return P2(e21, E4);
}
function ae1(e21, r21, a21, c21, t21, s21, u21, i21, f21, o21, l21) {
    var v21 = t21 - 1;
    var h21 = t21 === 0 ? s21 : [
        ""
    ];
    var p21 = M2(h21);
    for(var w21 = 0, b21 = 0, $2 = 0; w21 < c21; ++w21)for(var d21 = 0, m21 = C3(e21, v21 + 1, v21 = k3(b21 = u21[w21])), x2 = e21; d21 < p21; ++d21)if (x2 = g3(b21 > 0 ? h21[d21] + " " + m21 : y4(m21, /&\f/g, h21[d21]))) f21[$2++] = x2;
    return H2(e21, r21, a21, t21 === 0 ? n5 : i21, f21, o21, l21);
}
function ce2(e21, r21, a21) {
    return H2(e21, r21, a21, c4, d4(J()), C3(e21, 2, -2), 0);
}
function ne1(e21, r21, a21, c21) {
    return H2(e21, r21, a21, t4, C3(e21, 0, c21), C3(e21, c21 + 1, -1), c21);
}
function se1(e21, r21) {
    var a21 = "";
    var c21 = M2(e21);
    for(var n21 = 0; n21 < c21; n21++)a21 += r21(e21[n21], n21, e21, r21) || "";
    return a21;
}
function ue1(e21, r21, a21, s21) {
    switch(e21.type){
        case i4:
        case t4:
            return e21.return = e21.return || e21.value;
        case c4:
            return "";
        case n5:
            e21.value = e21.props.join(",");
    }
    return A3(a21 = se1(e21.children, s21)) ? e21.return = e21.value + "{" + a21 + "}" : "";
}
function ie1(e21) {
    var r21 = M2(e21);
    return function(a21, c21, n21, t21) {
        var s21 = "";
        for(var u21 = 0; u21 < r21; u21++)s21 += e21[u21](a21, c21, n21, t21) || "";
        return s21;
    };
}
function fe3(e21) {
    return function(r21) {
        if (!r21.root) {
            if (r21 = r21.return) e21(r21);
        }
    };
}
var fixedElements = new WeakMap();
var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
            element["return"] = "";
            element.value = "";
        }
    }
};
var weakMemoize = function weakMemoize2(func) {
    var cache = new WeakMap();
    return function(arg) {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
    };
};
function commonjsRequire1() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var b3 = typeof Symbol === "function" && Symbol.for, c5 = b3 ? Symbol.for("react.element") : 60103, d5 = b3 ? Symbol.for("react.portal") : 60106, e7 = b3 ? Symbol.for("react.fragment") : 60107, f4 = b3 ? Symbol.for("react.strict_mode") : 60108, g4 = b3 ? Symbol.for("react.profiler") : 60114, h4 = b3 ? Symbol.for("react.provider") : 60109, k4 = b3 ? Symbol.for("react.context") : 60110, l4 = b3 ? Symbol.for("react.async_mode") : 60111, m4 = b3 ? Symbol.for("react.concurrent_mode") : 60111, n6 = b3 ? Symbol.for("react.forward_ref") : 60112, p5 = b3 ? Symbol.for("react.suspense") : 60113, q4 = b3 ? Symbol.for("react.suspense_list") : 60120, r5 = b3 ? Symbol.for("react.memo") : 60115, t5 = b3 ? Symbol.for("react.lazy") : 60116, v3 = b3 ? Symbol.for("react.block") : 60121, w3 = b3 ? Symbol.for("react.fundamental") : 60117, x2 = b3 ? Symbol.for("react.responder") : 60118, y5 = b3 ? Symbol.for("react.scope") : 60119;
function z3(a5) {
    if (typeof a5 === "object" && a5 !== null) {
        var u4 = a5.$$typeof;
        switch(u4){
            case c5:
                switch(a5 = a5.type, a5){
                    case l4:
                    case m4:
                    case e7:
                    case g4:
                    case f4:
                    case p5:
                        return a5;
                    default:
                        switch(a5 = a5 && a5.$$typeof, a5){
                            case k4:
                            case n6:
                            case t5:
                            case r5:
                            case h4:
                                return a5;
                            default:
                                return u4;
                        }
                }
            case d5:
                return u4;
        }
    }
}
function A4(a5) {
    return z3(a5) === m4;
}
var AsyncMode = l4;
var ConcurrentMode = m4;
var ContextConsumer = k4;
var ContextProvider = h4;
var Element1 = c5;
var ForwardRef = n6;
var Fragment = e7;
var Lazy = t5;
var Memo = r5;
var Portal = d5;
var Profiler = g4;
var StrictMode = f4;
var Suspense = p5;
var isAsyncMode = function(a5) {
    return A4(a5) || z3(a5) === l4;
};
var isConcurrentMode = A4;
var isContextConsumer = function(a5) {
    return z3(a5) === k4;
};
var isContextProvider = function(a5) {
    return z3(a5) === h4;
};
var isElement = function(a5) {
    return typeof a5 === "object" && a5 !== null && a5.$$typeof === c5;
};
var isForwardRef = function(a5) {
    return z3(a5) === n6;
};
var isFragment = function(a5) {
    return z3(a5) === e7;
};
var isLazy = function(a5) {
    return z3(a5) === t5;
};
var isMemo = function(a5) {
    return z3(a5) === r5;
};
var isPortal = function(a5) {
    return z3(a5) === d5;
};
var isProfiler = function(a5) {
    return z3(a5) === g4;
};
var isStrictMode = function(a5) {
    return z3(a5) === f4;
};
var isSuspense = function(a5) {
    return z3(a5) === p5;
};
var isValidElementType = function(a5) {
    return typeof a5 === "string" || typeof a5 === "function" || a5 === e7 || a5 === m4 || a5 === g4 || a5 === f4 || a5 === p5 || a5 === q4 || typeof a5 === "object" && a5 !== null && (a5.$$typeof === t5 || a5.$$typeof === r5 || a5.$$typeof === h4 || a5.$$typeof === k4 || a5.$$typeof === n6 || a5.$$typeof === w3 || a5.$$typeof === x2 || a5.$$typeof === y5 || a5.$$typeof === v3);
};
var typeOf = z3;
var reactIs_production_min = {
    AsyncMode,
    ConcurrentMode,
    ContextConsumer,
    ContextProvider,
    Element: Element1,
    ForwardRef,
    Fragment,
    Lazy,
    Memo,
    Portal,
    Profiler,
    StrictMode,
    Suspense,
    isAsyncMode,
    isConcurrentMode,
    isContextConsumer,
    isContextProvider,
    isElement,
    isForwardRef,
    isFragment,
    isLazy,
    isMemo,
    isPortal,
    isProfiler,
    isStrictMode,
    isSuspense,
    isValidElementType,
    typeOf
};
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var TYPE_STATICS = {
};
TYPE_STATICS[reactIs1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs1.Memo] = MEMO_STATICS;
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols1 = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
            registeredStyles.push(registered[className] + ";");
        } else {
            rawClassName += className + " ";
        }
    });
    return rawClassName;
}
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if ((isStringTag === false || isBrowser === false) && cache.registered[className] === void 0) {
        cache.registered[className] = serialized.styles;
    }
    if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
            var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
            current = current.next;
        }while (current !== void 0)
    }
};
function murmur2(str) {
    var h5 = 0;
    var k5, i5 = 0, len = str.length;
    for(; len >= 4; ++i5, len -= 4){
        k5 = str.charCodeAt(i5) & 255 | (str.charCodeAt(++i5) & 255) << 8 | (str.charCodeAt(++i5) & 255) << 16 | (str.charCodeAt(++i5) & 255) << 24;
        k5 = (k5 & 65535) * 1540483477 + ((k5 >>> 16) * 59797 << 16);
        k5 ^= k5 >>> 24;
        h5 = (k5 & 65535) * 1540483477 + ((k5 >>> 16) * 59797 << 16) ^ (h5 & 65535) * 1540483477 + ((h5 >>> 16) * 59797 << 16);
    }
    switch(len){
        case 3:
            h5 ^= (str.charCodeAt(i5 + 2) & 255) << 16;
        case 2:
            h5 ^= (str.charCodeAt(i5 + 1) & 255) << 8;
        case 1:
            h5 ^= str.charCodeAt(i5) & 255;
            h5 = (h5 & 65535) * 1540483477 + ((h5 >>> 16) * 59797 << 16);
    }
    h5 ^= h5 >>> 13;
    h5 = (h5 & 65535) * 1540483477 + ((h5 >>> 16) * 59797 << 16);
    return ((h5 ^ h5 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
};
function memoize(fn1) {
    var cache = Object.create(null);
    return function(arg) {
        if (cache[arg] === void 0) cache[arg] = fn1(arg);
        return cache[arg];
    };
}
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
var cursor;
function sheetForTag(tag) {
    if (tag.sheet) {
        return tag.sheet;
    }
    for(var i5 = 0; i5 < document.styleSheets.length; i5++){
        if (document.styleSheets[i5].ownerNode === tag) {
            return document.styleSheets[i5];
        }
    }
}
function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
}
var StyleSheet1 = function() {
    function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
            var before;
            if (_this.tags.length === 0) {
                before = _this.prepend ? _this.container.firstChild : _this.before;
            } else {
                before = _this.tags[_this.tags.length - 1].nextSibling;
            }
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
            this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
                sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e) {
            }
        } else {
            tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
    };
    _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
            return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
    };
    return StyleSheet2;
}();
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i5 = 1; i5 < arguments.length; i5++){
            var source = arguments[i5];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var hasOwnProperty1 = Object.prototype.hasOwnProperty;
var getTheme = function getTheme2(outerTheme, theme) {
    if (typeof theme === "function") {
        var mergedTheme = theme(outerTheme);
        return mergedTheme;
    }
    return _extends({
    }, outerTheme, {
    }, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
    return weakMemoize(function(theme) {
        return getTheme(outerTheme, theme);
    });
});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {
    };
    for(var key in props){
        if (hasOwnProperty1.call(props, key)) {
            newProps[key] = props[key];
        }
    }
    newProps[typePropName] = type;
    return newProps;
};
function commonjsRequire2() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var classnames = function classnames2(args) {
    var len = args.length;
    var i5 = 0;
    var cls = "";
    for(; i5 < len; i5++){
        var arg = args[i5];
        if (arg == null) continue;
        var toAdd = void 0;
        switch(typeof arg){
            case "boolean": break;
            case "object":
                {
                    if (Array.isArray(arg)) {
                        toAdd = classnames2(arg);
                    } else {
                        toAdd = "";
                        for(var k5 in arg){
                            if (arg[k5] && k5) {
                                toAdd && (toAdd += " ");
                                toAdd += k5;
                            }
                        }
                    }
                    break;
                }
            default:
                {
                    toAdd = arg;
                }
        }
        if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
        }
    }
    return cls;
};
function merge(registered, css2, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
        return className;
    }
    return rawClassName + css2(registeredStyles);
}
const __default1 = async ({ ReactDOM , jsx , onShare  })=>{
    const { css  } = await import("https://cdn.skypack.dev/@emotion/react@11.1.4");
    const DraggableWindow = ({ onShare: onShare1  })=>jsx("div", {
            css: css`\n        background: red;\n        border: 4px solid red;\n        border-radius: 8px;\n      `
        }, jsx("div", {
            css: css`\n  display: block;\n  width: 100%;\n  text-align: right;\n  background: linear-gradient(0deg, darkred, red);\n`
        }, jsx("button", {
            css: css`\n          background: darkred;\n          margin-top: -4px;\n          margin-right: -4px;\n          color: white;\n          cursor: pointer;\n          font-weight: bold;\n          font-family: Roboto;\n          padding: 8px 16px;\n          outline: none;\n          border: none;\n          border-radius: 0px 8px 0px 0px;\n        `,
            onClick: ()=>onShare1()
        }, "🌎 SHARE")), jsx("div", {
            css: css`\n  min-width: 200px;\n  padding: 30px;\n  max-width: 600px;\n  background: white;\n  max-height: 800px;\n  border-radius: 0px 0px 8px 8px;\n  overflow-y: overlay;\n`,
            id: "zbody"
        }))
    ;
    ReactDOM.render(jsx(DraggableWindow, {
        onShare
    }), window.document.getElementById("dragabbleWindow"));
};
const starter = `import { useState } from "react";\nimport { css, Global } from "@emotion/react";\n\nconst Slider = () => {\n  const steps = 128;\n  const [sliderValue, setSlider] = useState(steps / 2);\n  return <>\n    <input max={steps}\n      css={\`\n        appearance: none;\n        width: 100%;\n        height: 40px; \n        background: rgb(\${255 / steps * sliderValue} \${255 / steps * (steps - sliderValue)} 0); \n        outline: none; \n    \`} type="range"\n      aria-label="font size changer"\n      value={sliderValue}\n      step="1"\n      onChangeCapture={(e) => setSlider(Number(e.currentTarget.value))}>\n    </input>\n    <p\n      css={css\`\n        font-size: \${72 / steps * sliderValue}px\n        \`}>\n      Example when the text gets bigger...\n    </p>\n    <p css={css\`\n        font-size: \${72 / steps * (steps - sliderValue)}px\n        \`}>\n      ...or smaller\n    </p>\n  </>\n}\n\nexport default () => <>\n  <Global styles={css\`\n      body{\n          margin: 0;\n          overflow: overlay;\n        }  \n    \`} />\n  <Slider />\n</>\n`;
let transform;
let node = null;
let ipfsNode;
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
    }
    return getRandomValues(rnds8);
}
const __default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
    return typeof uuid === 'string' && __default2.test(uuid);
}
var byteToHex = [];
for(var i5 = 0; i5 < 256; ++i5){
    byteToHex.push((i5 + 256).toString(16).substr(1));
}
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
function v41(options, buf, offset) {
    options = options || {
    };
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
        offset = offset || 0;
        for(var i6 = 0; i6 < 16; ++i6){
            buf[offset + i6] = rnds[i6];
        }
        return buf;
    }
    return stringify(rnds);
}
let ipfsWorker;
function createJsBlob(code) {
    const blob = new Blob([
        code
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
function getSession() {
    const session = {
        hydrated: false,
        preRendered: false,
        lastErrors: 0,
        HTML: "",
        ipfs: 0,
        transpiled: "",
        code: ""
    };
    return session;
}
const instanceOfAny = (object, constructors)=>constructors.some((c6)=>object instanceof c6
    )
;
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
        IDBDatabase,
        IDBObjectStore,
        IDBIndex,
        IDBCursor,
        IDBTransaction, 
    ]);
}
function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
        IDBCursor.prototype.advance,
        IDBCursor.prototype.continue,
        IDBCursor.prototype.continuePrimaryKey, 
    ]);
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx)) return;
    const done = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = ()=>{
            resolve();
            unlisten();
        };
        const error = ()=>{
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    transactionDoneMap.set(tx, done);
}
const unwrap = (value)=>reverseTransformCache.get(value)
;
const readMethods = [
    'get',
    'getKey',
    'getAll',
    'getAllKeys',
    'count'
];
const writeMethods = [
    'put',
    'add',
    'delete',
    'clear'
];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop)) return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function(storeName, ...args) {
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target1 = tx.store;
        if (useIndex) target1 = target1.index(args.shift());
        const returnVal = await target1[targetFuncName](...args);
        if (isWrite) await tx.done;
        return returnVal;
    };
    cachedMethods.set(prop, method);
    return method;
}
(function(d6, w4) {
    typeof exports == "object" && typeof module != "undefined" ? w4(exports) : typeof define == "function" && define.amd ? define([
        "exports"
    ], w4) : (d6 = d6 || self, w4(d6.Diff = {
    }));
})(this, function(d6) {
    "use strict";
    function w4() {
    }
    w4.prototype = {
        diff: function(n7, t7) {
            var r6 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            }, f5 = r6.callback;
            typeof r6 == "function" && (f5 = r6, r6 = {
            }), this.options = r6;
            var i6 = this;
            function l5(c6) {
                return f5 ? (setTimeout(function() {
                    f5(void 0, c6);
                }, 0), !0) : c6;
            }
            n7 = this.castInput(n7), t7 = this.castInput(t7), n7 = this.removeEmpty(this.tokenize(n7)), t7 = this.removeEmpty(this.tokenize(t7));
            var s4 = t7.length, o5 = n7.length, u4 = 1, p6 = s4 + o5, v5 = [
                {
                    newPos: -1,
                    components: []
                }
            ], a5 = this.extractCommon(v5[0], t7, n7, 0);
            if (v5[0].newPos + 1 >= s4 && a5 + 1 >= o5) return l5([
                {
                    value: this.join(t7),
                    count: t7.length
                }
            ]);
            function h5() {
                for(var c6 = -1 * u4; c6 <= u4; c6 += 2){
                    var L1 = void 0, x3 = v5[c6 - 1], m5 = v5[c6 + 1], F4 = (m5 ? m5.newPos : 0) - c6;
                    x3 && (v5[c6 - 1] = void 0);
                    var y6 = x3 && x3.newPos + 1 < s4, E5 = m5 && 0 <= F4 && F4 < o5;
                    if (!y6 && !E5) {
                        v5[c6] = void 0;
                        continue;
                    }
                    if (!y6 || E5 && x3.newPos < m5.newPos ? (L1 = I4(m5), i6.pushComponent(L1.components, void 0, !0)) : (L1 = x3, L1.newPos++, i6.pushComponent(L1.components, !0, void 0)), F4 = i6.extractCommon(L1, t7, n7, c6), L1.newPos + 1 >= s4 && F4 + 1 >= o5) return l5(H4(i6, L1.components, t7, n7, i6.useLongestToken));
                    v5[c6] = L1;
                }
                u4++;
            }
            if (f5) (function c6() {
                setTimeout(function() {
                    if (u4 > p6) return f5();
                    h5() || c6();
                }, 0);
            })();
            else for(; u4 <= p6;){
                var g5 = h5();
                if (g5) return g5;
            }
        },
        pushComponent: function(n7, t7, r6) {
            var f5 = n7[n7.length - 1];
            f5 && f5.added === t7 && f5.removed === r6 ? n7[n7.length - 1] = {
                count: f5.count + 1,
                added: t7,
                removed: r6
            } : n7.push({
                count: 1,
                added: t7,
                removed: r6
            });
        },
        extractCommon: function(n7, t7, r6, f5) {
            for(var i6 = t7.length, l5 = r6.length, s4 = n7.newPos, o5 = s4 - f5, u4 = 0; s4 + 1 < i6 && o5 + 1 < l5 && this.equals(t7[s4 + 1], r6[o5 + 1]);)s4++, o5++, u4++;
            return u4 && n7.components.push({
                count: u4
            }), n7.newPos = s4, o5;
        },
        equals: function(n7, t7) {
            return this.options.comparator ? this.options.comparator(n7, t7) : n7 === t7 || this.options.ignoreCase && n7.toLowerCase() === t7.toLowerCase();
        },
        removeEmpty: function(n7) {
            for(var t7 = [], r6 = 0; r6 < n7.length; r6++)n7[r6] && t7.push(n7[r6]);
            return t7;
        },
        castInput: function(n7) {
            return n7;
        },
        tokenize: function(n7) {
            return n7.split("");
        },
        join: function(n7) {
            return n7.join("");
        }
    };
    function H4(e8, n7, t7, r6, f5) {
        for(var i6 = 0, l5 = n7.length, s4 = 0, o5 = 0; i6 < l5; i6++){
            var u4 = n7[i6];
            if (u4.removed) {
                if ((u4.value = e8.join(r6.slice(o5, o5 + u4.count)), o5 += u4.count, i6 && n7[i6 - 1].added)) {
                    var v5 = n7[i6 - 1];
                    n7[i6 - 1] = n7[i6], n7[i6] = v5;
                }
            } else {
                if (!u4.added && f5) {
                    var p6 = t7.slice(s4, s4 + u4.count);
                    p6 = p6.map(function(h5, g5) {
                        var c6 = r6[o5 + g5];
                        return c6.length > h5.length ? c6 : h5;
                    }), u4.value = e8.join(p6);
                } else u4.value = e8.join(t7.slice(s4, s4 + u4.count));
                s4 += u4.count, u4.added || (o5 += u4.count);
            }
        }
        var a5 = n7[l5 - 1];
        return (l5 > 1 && typeof a5.value == "string" && (a5.added || a5.removed) && e8.equals("", a5.value) && (n7[l5 - 2].value += a5.value, n7.pop()), n7);
    }
    function I4(e8) {
        return {
            newPos: e8.newPos,
            components: e8.components.slice(0)
        };
    }
    var S3 = new w4;
    function W2(e8, n7, t7) {
        return S3.diff(e8, n7, t7);
    }
    function $2(e8, n7) {
        if (typeof e8 == "function") n7.callback = e8;
        else if (e8) for(var t7 in e8)e8.hasOwnProperty(t7) && (n7[t7] = e8[t7]);
        return n7;
    }
    var P3 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, fe4 = /\S/, U3 = new w4;
    U3.equals = function(e8, n7) {
        return this.options.ignoreCase && (e8 = e8.toLowerCase(), n7 = n7.toLowerCase()), e8 === n7 || this.options.ignoreWhitespace && !fe4.test(e8) && !fe4.test(n7);
    }, U3.tokenize = function(e8) {
        for(var n7 = e8.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), t7 = 0; t7 < n7.length - 1; t7++)!n7[t7 + 1] && n7[t7 + 2] && P3.test(n7[t7]) && P3.test(n7[t7 + 2]) && (n7[t7] += n7[t7 + 2], n7.splice(t7 + 1, 2), t7--);
        return n7;
    };
    function me3(e8, n7, t7) {
        return (t7 = $2(t7, {
            ignoreWhitespace: !0
        }), U3.diff(e8, n7, t7));
    }
    function xe2(e8, n7, t7) {
        return U3.diff(e8, n7, t7);
    }
    var V3 = new w4;
    V3.tokenize = function(e8) {
        var n7 = [], t7 = e8.split(/(\n|\r\n)/);
        t7[t7.length - 1] || t7.pop();
        for(var r6 = 0; r6 < t7.length; r6++){
            var f5 = t7[r6];
            r6 % 2 && !this.options.newlineIsToken ? n7[n7.length - 1] += f5 : (this.options.ignoreWhitespace && (f5 = f5.trim()), n7.push(f5));
        }
        return n7;
    };
    function le2(e8, n7, t7) {
        return V3.diff(e8, n7, t7);
    }
    function Fe2(e8, n7, t7) {
        var r6 = $2(t7, {
            ignoreWhitespace: !0
        });
        return V3.diff(e8, n7, r6);
    }
    var se2 = new w4;
    se2.tokenize = function(e8) {
        return e8.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function Ne3(e8, n7, t7) {
        return se2.diff(e8, n7, t7);
    }
    var oe1 = new w4;
    oe1.tokenize = function(e8) {
        return e8.split(/([{}:;,]|\s+)/);
    };
    function Se1(e8, n7, t7) {
        return oe1.diff(e8, n7, t7);
    }
    function X2(e8) {
        return (typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? X2 = function(n7) {
            return typeof n7;
        } : X2 = function(n7) {
            return n7 && typeof Symbol == "function" && n7.constructor === Symbol && n7 !== Symbol.prototype ? "symbol" : typeof n7;
        }, X2(e8));
    }
    function b4(e8) {
        return He(e8) || Ie3(e8) || be3(e8) || Ee3();
    }
    function He(e8) {
        if (Array.isArray(e8)) return j4(e8);
    }
    function Ie3(e8) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e8)) return Array.from(e8);
    }
    function be3(e8, n7) {
        if (!e8) return;
        if (typeof e8 == "string") return j4(e8, n7);
        var t7 = Object.prototype.toString.call(e8).slice(8, -1);
        if ((t7 === "Object" && e8.constructor && (t7 = e8.constructor.name), t7 === "Map" || t7 === "Set")) return Array.from(e8);
        if (t7 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t7)) return j4(e8, n7);
    }
    function j4(e8, n7) {
        (n7 == null || n7 > e8.length) && (n7 = e8.length);
        for(var t7 = 0, r6 = new Array(n7); t7 < n7; t7++)r6[t7] = e8[t7];
        return r6;
    }
    function Ee3() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Ae2 = Object.prototype.toString, J1 = new w4;
    J1.useLongestToken = !0, J1.tokenize = V3.tokenize, J1.castInput = function(e8) {
        var n7 = this.options, t7 = n7.undefinedReplacement, r6 = n7.stringifyReplacer, f5 = r6 === void 0 ? function(i6, l5) {
            return typeof l5 == "undefined" ? t7 : l5;
        } : r6;
        return typeof e8 == "string" ? e8 : JSON.stringify(Z4(e8, null, null, f5), f5, "  ");
    }, J1.equals = function(e8, n7) {
        return w4.prototype.equals.call(J1, e8.replace(/,([\r\n])/g, "$1"), n7.replace(/,([\r\n])/g, "$1"));
    };
    function Te2(e8, n7, t7) {
        return J1.diff(e8, n7, t7);
    }
    function Z4(e8, n7, t7, r6, f5) {
        n7 = n7 || [], t7 = t7 || [], r6 && (e8 = r6(f5, e8));
        var i6;
        for(i6 = 0; i6 < n7.length; i6 += 1)if (n7[i6] === e8) return t7[i6];
        var l5;
        if (Ae2.call(e8) === "[object Array]") {
            for((n7.push(e8), l5 = new Array(e8.length), t7.push(l5), i6 = 0); i6 < e8.length; i6 += 1)l5[i6] = Z4(e8[i6], n7, t7, r6, f5);
            return (n7.pop(), t7.pop(), l5);
        }
        if ((e8 && e8.toJSON && (e8 = e8.toJSON()), X2(e8) === "object" && e8 !== null)) {
            n7.push(e8), l5 = {
            }, t7.push(l5);
            var s4 = [], o5;
            for(o5 in e8)e8.hasOwnProperty(o5) && s4.push(o5);
            for((s4.sort(), i6 = 0); i6 < s4.length; i6 += 1)o5 = s4[i6], l5[o5] = Z4(e8[o5], n7, t7, r6, o5);
            n7.pop(), t7.pop();
        } else l5 = e8;
        return l5;
    }
    var B3 = new w4;
    B3.tokenize = function(e8) {
        return e8.slice();
    }, B3.join = B3.removeEmpty = function(e8) {
        return e8;
    };
    function Oe2(e8, n7, t7) {
        return B3.diff(e8, n7, t7);
    }
    function G3(e8) {
        var n7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        }, t7 = e8.split(/\r\n|[\n\v\f\r\x85]/), r6 = e8.match(/\r\n|[\n\v\f\r\x85]/g) || [], f5 = [], i6 = 0;
        function l5() {
            var u4 = {
            };
            for(f5.push(u4); i6 < t7.length;){
                var p6 = t7[i6];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(p6)) break;
                var v5 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(p6);
                v5 && (u4.index = v5[1]), i6++;
            }
            for((s4(u4), s4(u4), u4.hunks = []); i6 < t7.length;){
                var a5 = t7[i6];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(a5)) break;
                if (/^@@/.test(a5)) u4.hunks.push(o5());
                else {
                    if (a5 && n7.strict) throw new Error("Unknown line " + (i6 + 1) + " " + JSON.stringify(a5));
                    i6++;
                }
            }
        }
        function s4(u4) {
            var p6 = /^(---|\+\+\+)\s+(.*)$/.exec(t7[i6]);
            if (p6) {
                var v5 = p6[1] === "---" ? "old" : "new", a5 = p6[2].split("	", 2), h5 = a5[0].replace(/\\\\/g, "\\");
                /^".*"$/.test(h5) && (h5 = h5.substr(1, h5.length - 2)), u4[v5 + "FileName"] = h5, u4[v5 + "Header"] = (a5[1] || "").trim(), i6++;
            }
        }
        function o5() {
            var u4 = i6, p6 = t7[i6++], v5 = p6.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), a5 = {
                oldStart: +v5[1],
                oldLines: typeof v5[2] == "undefined" ? 1 : +v5[2],
                newStart: +v5[3],
                newLines: typeof v5[4] == "undefined" ? 1 : +v5[4],
                lines: [],
                linedelimiters: []
            };
            a5.oldLines === 0 && (a5.oldStart += 1), a5.newLines === 0 && (a5.newStart += 1);
            for(var h5 = 0, g5 = 0; i6 < t7.length && !(t7[i6].indexOf("--- ") === 0 && i6 + 2 < t7.length && t7[i6 + 1].indexOf("+++ ") === 0 && t7[i6 + 2].indexOf("@@") === 0); i6++){
                var c6 = t7[i6].length == 0 && i6 != t7.length - 1 ? " " : t7[i6][0];
                if (c6 === "+" || c6 === "-" || c6 === " " || c6 === "\\") a5.lines.push(t7[i6]), a5.linedelimiters.push(r6[i6] || `\n`), c6 === "+" ? h5++ : c6 === "-" ? g5++ : c6 === " " && (h5++, g5++);
                else break;
            }
            if ((!h5 && a5.newLines === 1 && (a5.newLines = 0), !g5 && a5.oldLines === 1 && (a5.oldLines = 0), n7.strict)) {
                if (h5 !== a5.newLines) throw new Error("Added line count did not match for hunk at line " + (u4 + 1));
                if (g5 !== a5.oldLines) throw new Error("Removed line count did not match for hunk at line " + (u4 + 1));
            }
            return a5;
        }
        for(; i6 < t7.length;)l5();
        return f5;
    }
    function ze1(e8, n7, t7) {
        var r6 = !0, f5 = !1, i6 = !1, l5 = 1;
        return function s4() {
            if (r6 && !i6) {
                if ((f5 ? l5++ : r6 = !1, e8 + l5 <= t7)) return l5;
                i6 = !0;
            }
            if (!f5) return (i6 || (r6 = !0), n7 <= e8 - l5 ? -l5++ : (f5 = !0, s4()));
        };
    }
    function ue2(e8, n7) {
        var t7 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        };
        if ((typeof n7 == "string" && (n7 = G3(n7)), Array.isArray(n7))) {
            if (n7.length > 1) throw new Error("applyPatch only works with a single input.");
            n7 = n7[0];
        }
        var r6 = e8.split(/\r\n|[\n\v\f\r\x85]/), f5 = e8.match(/\r\n|[\n\v\f\r\x85]/g) || [], i6 = n7.hunks, l5 = t7.compareLine || function(re1, D5, K3, C4) {
            return D5 === C4;
        }, s4 = 0, o5 = t7.fuzzFactor || 0, u4 = 0, p6 = 0, v5, a5;
        function h5(re1, D5) {
            for(var K3 = 0; K3 < re1.lines.length; K3++){
                var C4 = re1.lines[K3], ie2 = C4.length > 0 ? C4[0] : " ", Ze = C4.length > 0 ? C4.substr(1) : C4;
                if (ie2 === " " || ie2 === "-") {
                    if (!l5(D5 + 1, r6[D5], ie2, Ze) && (s4++, s4 > o5)) return !1;
                    D5++;
                }
            }
            return !0;
        }
        for(var g5 = 0; g5 < i6.length; g5++){
            for(var c6 = i6[g5], L1 = r6.length - c6.oldLines, x3 = 0, m5 = p6 + c6.oldStart - 1, F4 = ze1(m5, u4, L1); x3 !== void 0; x3 = F4())if (h5(c6, m5 + x3)) {
                c6.offset = p6 += x3;
                break;
            }
            if (x3 === void 0) return !1;
            u4 = c6.offset + c6.oldStart + c6.oldLines;
        }
        for(var y6 = 0, E5 = 0; E5 < i6.length; E5++){
            var N4 = i6[E5], A5 = N4.oldStart + N4.offset + y6 - 1;
            y6 += N4.newLines - N4.oldLines;
            for(var T4 = 0; T4 < N4.lines.length; T4++){
                var O3 = N4.lines[T4], z4 = O3.length > 0 ? O3[0] : " ", Y2 = O3.length > 0 ? O3.substr(1) : O3, te1 = N4.linedelimiters[T4];
                if (z4 === " ") A5++;
                else if (z4 === "-") r6.splice(A5, 1), f5.splice(A5, 1);
                else if (z4 === "+") r6.splice(A5, 0, Y2), f5.splice(A5, 0, te1), A5++;
                else if (z4 === "\\") {
                    var R4 = N4.lines[T4 - 1] ? N4.lines[T4 - 1][0] : null;
                    R4 === "+" ? v5 = !0 : R4 === "-" && (a5 = !0);
                }
            }
        }
        if (v5) for(; !r6[r6.length - 1];)r6.pop(), f5.pop();
        else a5 && (r6.push(""), f5.push(`\n`));
        for(var q5 = 0; q5 < r6.length - 1; q5++)r6[q5] = r6[q5] + f5[q5];
        return r6.join("");
    }
    function We(e8, n7) {
        typeof e8 == "string" && (e8 = G3(e8));
        var t7 = 0;
        function r6() {
            var f5 = e8[t7++];
            if (!f5) return n7.complete();
            n7.loadFile(f5, function(i6, l5) {
                if (i6) return n7.complete(i6);
                var s4 = ue2(l5, f5, n7);
                n7.patched(f5, s4, function(o5) {
                    if (o5) return n7.complete(o5);
                    r6();
                });
            });
        }
        r6();
    }
    function _4(e8, n7, t7, r6, f5, i6, l5) {
        l5 || (l5 = {
        }), typeof l5.context == "undefined" && (l5.context = 4);
        var s4 = le2(t7, r6, l5);
        s4.push({
            value: "",
            lines: []
        });
        function o5(x3) {
            return x3.map(function(m5) {
                return " " + m5;
            });
        }
        for(var u4 = [], p6 = 0, v5 = 0, a5 = [], h5 = 1, g5 = 1, c6 = function(m5) {
            var F4 = s4[m5], y6 = F4.lines || F4.value.replace(/\n$/, "").split(`\n`);
            if ((F4.lines = y6, F4.added || F4.removed)) {
                var E5;
                if (!p6) {
                    var N4 = s4[m5 - 1];
                    p6 = h5, v5 = g5, N4 && (a5 = l5.context > 0 ? o5(N4.lines.slice(-l5.context)) : [], p6 -= a5.length, v5 -= a5.length);
                }
                (E5 = a5).push.apply(E5, b4(y6.map(function(q5) {
                    return (F4.added ? "+" : "-") + q5;
                }))), F4.added ? g5 += y6.length : h5 += y6.length;
            } else {
                if (p6) {
                    if (y6.length <= l5.context * 2 && m5 < s4.length - 2) {
                        var A5;
                        (A5 = a5).push.apply(A5, b4(o5(y6)));
                    } else {
                        var T4, O3 = Math.min(y6.length, l5.context);
                        (T4 = a5).push.apply(T4, b4(o5(y6.slice(0, O3))));
                        var z4 = {
                            oldStart: p6,
                            oldLines: h5 - p6 + O3,
                            newStart: v5,
                            newLines: g5 - v5 + O3,
                            lines: a5
                        };
                        if (m5 >= s4.length - 2 && y6.length <= l5.context) {
                            var Y2 = /\n$/.test(t7), te1 = /\n$/.test(r6), R4 = y6.length == 0 && a5.length > z4.oldLines;
                            !Y2 && R4 && t7.length > 0 && a5.splice(z4.oldLines, 0, "\\ No newline at end of file"), (!Y2 && !R4 || !te1) && a5.push("\\ No newline at end of file");
                        }
                        u4.push(z4), p6 = 0, v5 = 0, a5 = [];
                    }
                }
                h5 += y6.length, g5 += y6.length;
            }
        }, L1 = 0; L1 < s4.length; L1++)c6(L1);
        return {
            oldFileName: e8,
            newFileName: n7,
            oldHeader: f5,
            newHeader: i6,
            hunks: u4
        };
    }
    function Me3(e8) {
        var n7 = [];
        e8.oldFileName == e8.newFileName && n7.push("Index: " + e8.oldFileName), n7.push("==================================================================="), n7.push("--- " + e8.oldFileName + (typeof e8.oldHeader == "undefined" ? "" : "	" + e8.oldHeader)), n7.push("+++ " + e8.newFileName + (typeof e8.newHeader == "undefined" ? "" : "	" + e8.newHeader));
        for(var t7 = 0; t7 < e8.hunks.length; t7++){
            var r6 = e8.hunks[t7];
            r6.oldLines === 0 && (r6.oldStart -= 1), r6.newLines === 0 && (r6.newStart -= 1), n7.push("@@ -" + r6.oldStart + "," + r6.oldLines + " +" + r6.newStart + "," + r6.newLines + " @@"), n7.push.apply(n7, r6.lines);
        }
        return n7.join(`\n`) + `\n`;
    }
    function ae2(e8, n7, t7, r6, f5, i6, l5) {
        return Me3(_4(e8, n7, t7, r6, f5, i6, l5));
    }
    function qe3(e8, n7, t7, r6, f5, i6) {
        return ae2(e8, e8, n7, t7, r6, f5, i6);
    }
    function Ce1(e8, n7) {
        return e8.length !== n7.length ? !1 : k6(e8, n7);
    }
    function k6(e8, n7) {
        if (n7.length > e8.length) return !1;
        for(var t7 = 0; t7 < n7.length; t7++)if (n7[t7] !== e8[t7]) return !1;
        return !0;
    }
    function Je(e8) {
        var n7 = ne3(e8.lines), t7 = n7.oldLines, r6 = n7.newLines;
        t7 !== void 0 ? e8.oldLines = t7 : delete e8.oldLines, r6 !== void 0 ? e8.newLines = r6 : delete e8.newLines;
    }
    function $e2(e8, n7, t7) {
        e8 = de4(e8, t7), n7 = de4(n7, t7);
        var r6 = {
        };
        (e8.index || n7.index) && (r6.index = e8.index || n7.index), (e8.newFileName || n7.newFileName) && (ce4(e8) ? ce4(n7) ? (r6.oldFileName = Q3(r6, e8.oldFileName, n7.oldFileName), r6.newFileName = Q3(r6, e8.newFileName, n7.newFileName), r6.oldHeader = Q3(r6, e8.oldHeader, n7.oldHeader), r6.newHeader = Q3(r6, e8.newHeader, n7.newHeader)) : (r6.oldFileName = e8.oldFileName, r6.newFileName = e8.newFileName, r6.oldHeader = e8.oldHeader, r6.newHeader = e8.newHeader) : (r6.oldFileName = n7.oldFileName || e8.oldFileName, r6.newFileName = n7.newFileName || e8.newFileName, r6.oldHeader = n7.oldHeader || e8.oldHeader, r6.newHeader = n7.newHeader || e8.newHeader)), r6.hunks = [];
        for(var f5 = 0, i6 = 0, l5 = 0, s4 = 0; f5 < e8.hunks.length || i6 < n7.hunks.length;){
            var o5 = e8.hunks[f5] || {
                oldStart: Infinity
            }, u4 = n7.hunks[i6] || {
                oldStart: Infinity
            };
            if (pe3(o5, u4)) r6.hunks.push(ve4(o5, l5)), f5++, s4 += o5.newLines - o5.oldLines;
            else if (pe3(u4, o5)) r6.hunks.push(ve4(u4, s4)), i6++, l5 += u4.newLines - u4.oldLines;
            else {
                var p6 = {
                    oldStart: Math.min(o5.oldStart, u4.oldStart),
                    oldLines: 0,
                    newStart: Math.min(o5.newStart + l5, u4.oldStart + s4),
                    newLines: 0,
                    lines: []
                };
                Re3(p6, o5.oldStart, o5.lines, u4.oldStart, u4.lines), i6++, f5++, r6.hunks.push(p6);
            }
        }
        return r6;
    }
    function de4(e8, n7) {
        if (typeof e8 == "string") {
            if (/^@@/m.test(e8) || /^Index:/m.test(e8)) return G3(e8)[0];
            if (!n7) throw new Error("Must provide a base reference or pass in a patch");
            return _4(void 0, void 0, n7, e8);
        }
        return e8;
    }
    function ce4(e8) {
        return e8.newFileName && e8.newFileName !== e8.oldFileName;
    }
    function Q3(e8, n7, t7) {
        return n7 === t7 ? n7 : (e8.conflict = !0, {
            mine: n7,
            theirs: t7
        });
    }
    function pe3(e8, n7) {
        return e8.oldStart < n7.oldStart && e8.oldStart + e8.oldLines < n7.oldStart;
    }
    function ve4(e8, n7) {
        return {
            oldStart: e8.oldStart,
            oldLines: e8.oldLines,
            newStart: e8.newStart + n7,
            newLines: e8.newLines,
            lines: e8.lines
        };
    }
    function Re3(e8, n7, t7, r6, f5) {
        var i6 = {
            offset: n7,
            lines: t7,
            index: 0
        }, l5 = {
            offset: r6,
            lines: f5,
            index: 0
        };
        for((we4(e8, i6, l5), we4(e8, l5, i6)); i6.index < i6.lines.length && l5.index < l5.lines.length;){
            var s4 = i6.lines[i6.index], o5 = l5.lines[l5.index];
            if ((s4[0] === "-" || s4[0] === "+") && (o5[0] === "-" || o5[0] === "+")) De3(e8, i6, l5);
            else if (s4[0] === "+" && o5[0] === " ") {
                var u4;
                (u4 = e8.lines).push.apply(u4, b4(M4(i6)));
            } else if (o5[0] === "+" && s4[0] === " ") {
                var p6;
                (p6 = e8.lines).push.apply(p6, b4(M4(l5)));
            } else s4[0] === "-" && o5[0] === " " ? he4(e8, i6, l5) : o5[0] === "-" && s4[0] === " " ? he4(e8, l5, i6, !0) : s4 === o5 ? (e8.lines.push(s4), i6.index++, l5.index++) : ee3(e8, M4(i6), M4(l5));
        }
        ge4(e8, i6), ge4(e8, l5), Je(e8);
    }
    function De3(e8, n7, t7) {
        var r6 = M4(n7), f5 = M4(t7);
        if (ye3(r6) && ye3(f5)) {
            if (k6(r6, f5) && Le4(t7, r6, r6.length - f5.length)) {
                var i6;
                (i6 = e8.lines).push.apply(i6, b4(r6));
                return;
            } else if (k6(f5, r6) && Le4(n7, f5, f5.length - r6.length)) {
                var l5;
                (l5 = e8.lines).push.apply(l5, b4(f5));
                return;
            }
        } else if (Ce1(r6, f5)) {
            var s4;
            (s4 = e8.lines).push.apply(s4, b4(r6));
            return;
        }
        ee3(e8, r6, f5);
    }
    function he4(e8, n7, t7, r6) {
        var f5 = M4(n7), i6 = Pe4(t7, f5);
        if (i6.merged) {
            var l5;
            (l5 = e8.lines).push.apply(l5, b4(i6.merged));
        } else ee3(e8, r6 ? i6 : f5, r6 ? f5 : i6);
    }
    function ee3(e8, n7, t7) {
        e8.conflict = !0, e8.lines.push({
            conflict: !0,
            mine: n7,
            theirs: t7
        });
    }
    function we4(e8, n7, t7) {
        for(; n7.offset < t7.offset && n7.index < n7.lines.length;){
            var r6 = n7.lines[n7.index++];
            e8.lines.push(r6), n7.offset++;
        }
    }
    function ge4(e8, n7) {
        for(; n7.index < n7.lines.length;){
            var t7 = n7.lines[n7.index++];
            e8.lines.push(t7);
        }
    }
    function M4(e8) {
        for(var n7 = [], t7 = e8.lines[e8.index][0]; e8.index < e8.lines.length;){
            var r6 = e8.lines[e8.index];
            if ((t7 === "-" && r6[0] === "+" && (t7 = "+"), t7 === r6[0])) n7.push(r6), e8.index++;
            else break;
        }
        return n7;
    }
    function Pe4(e8, n7) {
        for(var t7 = [], r6 = [], f5 = 0, i6 = !1, l5 = !1; f5 < n7.length && e8.index < e8.lines.length;){
            var s4 = e8.lines[e8.index], o5 = n7[f5];
            if (o5[0] === "+") break;
            if ((i6 = i6 || s4[0] !== " ", r6.push(o5), f5++, s4[0] === "+")) for(l5 = !0; s4[0] === "+";)t7.push(s4), s4 = e8.lines[++e8.index];
            o5.substr(1) === s4.substr(1) ? (t7.push(s4), e8.index++) : l5 = !0;
        }
        if (((n7[f5] || "")[0] === "+" && i6 && (l5 = !0), l5)) return t7;
        for(; f5 < n7.length;)r6.push(n7[f5++]);
        return {
            merged: r6,
            changes: t7
        };
    }
    function ye3(e8) {
        return e8.reduce(function(n7, t7) {
            return n7 && t7[0] === "-";
        }, !0);
    }
    function Le4(e8, n7, t7) {
        for(var r6 = 0; r6 < t7; r6++){
            var f5 = n7[n7.length - t7 + r6].substr(1);
            if (e8.lines[e8.index + r6] !== " " + f5) return !1;
        }
        return (e8.index += t7, !0);
    }
    function ne3(e8) {
        var n7 = 0, t7 = 0;
        return (e8.forEach(function(r6) {
            if (typeof r6 != "string") {
                var f5 = ne3(r6.mine), i6 = ne3(r6.theirs);
                n7 !== void 0 && (f5.oldLines === i6.oldLines ? n7 += f5.oldLines : n7 = void 0), t7 !== void 0 && (f5.newLines === i6.newLines ? t7 += f5.newLines : t7 = void 0);
            } else t7 !== void 0 && (r6[0] === "+" || r6[0] === " ") && t7++, n7 !== void 0 && (r6[0] === "-" || r6[0] === " ") && n7++;
        }), {
            oldLines: n7,
            newLines: t7
        });
    }
    function Ue2(e8) {
        for(var n7 = [], t7, r6, f5 = 0; f5 < e8.length; f5++)t7 = e8[f5], t7.added ? r6 = 1 : t7.removed ? r6 = -1 : r6 = 0, n7.push([
            r6,
            t7.value
        ]);
        return n7;
    }
    function Ve2(e8) {
        for(var n7 = [], t7 = 0; t7 < e8.length; t7++){
            var r6 = e8[t7];
            r6.added ? n7.push("<ins>") : r6.removed && n7.push("<del>"), n7.push(Xe(r6.value)), r6.added ? n7.push("</ins>") : r6.removed && n7.push("</del>");
        }
        return n7.join("");
    }
    function Xe(e8) {
        var n7 = e8;
        return (n7 = n7.replace(/&/g, "&amp;"), n7 = n7.replace(/</g, "&lt;"), n7 = n7.replace(/>/g, "&gt;"), n7 = n7.replace(/"/g, "&quot;"), n7);
    }
    d6.Diff = w4, d6.applyPatch = ue2, d6.applyPatches = We, d6.canonicalize = Z4, d6.convertChangesToDMP = Ue2, d6.convertChangesToXML = Ve2, d6.createPatch = qe3, d6.createTwoFilesPatch = ae2, d6.diffArrays = Oe2, d6.diffChars = W2, d6.diffCss = Se1, d6.diffJson = Te2, d6.diffLines = le2, d6.diffSentences = Ne3, d6.diffTrimmedLines = Fe2, d6.diffWords = me3, d6.diffWordsWithSpace = xe2, d6.merge = $e2, d6.parsePatch = G3, d6.structuredPatch = _4, Object.defineProperty(d6, "__esModule", {
        value: !0
    });
});
const Be3 = async (d6)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof d6 == "string" ? new TextEncoder().encode(d6) : d6)).slice(0, 4)).map((w4)=>("00" + w4.toString(16)).slice(-2)
    ).join("")
;
const diff1 = async (d6, w4)=>{
    const H4 = Be3(d6), I4 = Diff.diffChars(d6, w4);
    return {
        b: await H4,
        c: I4.map((S3)=>S3.added ? S3.value : S3.removed ? -S3.count : S3.count
        )
    };
}, isDiff = (d6)=>{
    if (d6.length < 10) return !1;
    const w4 = [
        ...d6.slice(0, 8)
    ].filter((I4)=>I4 < "0" || I4 > "f"
    ).length === 0, H4 = d6.slice(8);
    if (w4 && H4[0] === "[" && H4[H4.length - 1] === "]") try {
        return JSON.parse(H4).length > 1;
    } catch  {
        return !1;
    }
    return !1;
}, assemble = (d6, w4)=>{
    const H4 = JSON.parse(w4);
    let I4 = d6.slice(), S3 = "";
    return H4.forEach((W2)=>{
        if (Number(W2) === W2) {
            const $2 = Math.abs(W2), P3 = I4.slice(0, $2);
            I4 = I4.slice($2), W2 > 0 && (S3 += String(P3));
        } else S3 += String(W2);
    }), S3;
};
const getDbObj = (dbPromise, isIdb = false)=>{
    const sha256 = async (x3)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof x3 === "string" ? new TextEncoder().encode(x3) : x3)).slice(0, 4)).map((b4)=>("00" + b4.toString(16)).slice(-2)
        ).join("")
    ;
    const dbObj = {
        async get (key, format = "string") {
            let data;
            try {
                if (isIdb) {
                    data = await (await dbPromise).get("codeStore", key);
                } else {
                    data = await dbPromise.get(key);
                }
                if (!data) {
                    return null;
                }
            } catch (_) {
                return null;
            }
            if (format === "json") {
                return JSON.parse(data);
            }
            if (format === "string") {
                const allData = await data;
                if (typeof allData === "string" && format === "string") {
                    const text = allData;
                    if (isDiff(allData)) {
                        const keyOfDiff = allData.slice(0, 8);
                        const instructions = allData.slice(8);
                        const oldValue = await dbObj.get(keyOfDiff);
                        return assemble(oldValue, instructions);
                    }
                    return allData;
                }
                return new TextDecoder().decode(allData);
            }
            return data;
        },
        async put (key, val) {
            let prev;
            try {
                const oldKey = await dbObj.get(key);
                if (typeof oldKey === "string" && typeof val === "string" && oldKey.length === 8 && oldKey !== val) {
                    const actualValue = await dbObj.get(val);
                    const prevValue = await dbObj.get(oldKey);
                    if (typeof prevValue === "string") {
                        const prevSha = await sha256(prevValue);
                        if (prevSha === oldKey) {
                            const diffObj = await diff1(actualValue, prevValue);
                            const diffAsStr = diffObj.b + JSON.stringify(diffObj.c);
                            dbObj.put(prevSha, diffAsStr);
                        }
                    }
                }
            } catch  {
                prev = "";
            }
            if (prev !== "" && val === prev) {
                return val;
            }
            let str;
            if (typeof val !== "string") {
                str = new TextDecoder().decode(val);
            } else {
                str = val;
            }
            if (isIdb) {
                return (await dbPromise).put("codeStore", str, key);
            } else {
                return await dbPromise.put(key, str);
            }
        },
        async delete (key) {
            return (await dbPromise).delete("codeStore", key);
        },
        async clear () {
            return (await dbPromise).clear("codeStore");
        },
        async keys () {
            return (await dbPromise).getAllKeys("codeStore");
        }
    };
    return dbObj;
};
let db1;
const cache1 = {
};
const importScript = (src, res = [])=>{
    const prefix = src.slice(0, 8);
    if (prefix === "https://") {
        return window.document.head.querySelector(`script[src="${src}"]`) || new Promise(function(resolve, reject) {
            const s4 = window.document.createElement("script");
            s4.src = src;
            s4.onload = ()=>{
                if (res.length === 0) {
                    resolve(window);
                }
                const ret = {
                };
                res.forEach((x3)=>Object.assign(ret, window[x3])
                );
                resolve(ret);
            };
            s4.onerror = reject;
            window.document.head.appendChild(s4);
        });
    } else if (prefix === "@zedvisi") {
        if (!cache1[src]) cache1[src] = import(`https://unpkg.com/${src}`);
        return cache1[src];
    }
};
const sha256 = async (x3)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof x3 === "string" ? new TextEncoder().encode(x3) : x3)).slice(0, 4)).map((b4)=>("00" + b4.toString(16)).slice(-2)
    ).join("")
;
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val)=>typeof val === "object" && val !== null || typeof val === "function"
;
const throwTransferHandler = {
    canHandle: (value)=>isObject(value) && throwMarker in value
    ,
    serialize ({ value  }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack
                }
            };
        } else {
            serialized = {
                isError: false,
                value
            };
        }
        return [
            serialized,
            []
        ];
    },
    deserialize (serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    }
};
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint)) endpoint.close();
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, {
        [proxyMarker]: true
    });
}
function generateUUID() {
    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)
    ).join("-");
}
function g5(e8) {
    return (function(e9) {
        if (Array.isArray(e9)) return D3(e9);
    })(e8) || (function(e9) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e9)) return Array.from(e9);
    })(e8) || (function(e9, t7) {
        if (!e9) return;
        if ("string" == typeof e9) return D3(e9, t7);
        var n7 = Object.prototype.toString.call(e9).slice(8, -1);
        "Object" === n7 && e9.constructor && (n7 = e9.constructor.name);
        if ("Map" === n7 || "Set" === n7) return Array.from(e9);
        if ("Arguments" === n7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n7)) return D3(e9, t7);
    })(e8) || (function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    })();
}
function x3(e8, t7, n7, r6, o5, u4, i6) {
    i6 || (i6 = {
    }), (void 0) === i6.context && (i6.context = 4);
    var a5 = d1(n7, r6, i6);
    function s4(e9) {
        return e9.map(function(e10) {
            return " " + e10;
        });
    }
    a5.push({
        value: "",
        lines: []
    });
    for(var l5 = [], c6 = 0, p6 = 0, f5 = [], h5 = 1, m5 = 1, D5 = function(e9) {
        var t8 = a5[e9], o6 = t8.lines || t8.value.replace(/\n$/, "").split("\n");
        if ((t8.lines = o6, t8.added || t8.removed)) {
            var u5;
            if (!c6) {
                var d6 = a5[e9 - 1];
                c6 = h5, p6 = m5, d6 && (f5 = i6.context > 0 ? s4(d6.lines.slice(-i6.context)) : [], c6 -= f5.length, p6 -= f5.length);
            }
            (u5 = f5).push.apply(u5, g5(o6.map(function(e10) {
                return (t8.added ? "+" : "-") + e10;
            }))), t8.added ? m5 += o6.length : h5 += o6.length;
        } else {
            if (c6) {
                if (o6.length <= 2 * i6.context && e9 < a5.length - 2) {
                    var D6;
                    (D5 = f5).push.apply(D5, g5(s4(o6)));
                } else {
                    var y6, E5 = Math.min(o6.length, i6.context);
                    (y6 = f5).push.apply(y6, g5(s4(o6.slice(0, E5))));
                    var C4 = {
                        oldStart: c6,
                        oldLines: h5 - c6 + E5,
                        newStart: p6,
                        newLines: m5 - p6 + E5,
                        lines: f5
                    };
                    if (e9 >= a5.length - 2 && o6.length <= i6.context) {
                        var b4 = /\n$/.test(n7), v5 = /\n$/.test(r6), A5 = 0 == o6.length && f5.length > C4.oldLines;
                        !b4 && A5 && n7.length > 0 && f5.splice(C4.oldLines, 0, "\\ No newline at end of file"), (b4 || A5) && v5 || f5.push("\\ No newline at end of file");
                    }
                    l5.push(C4), c6 = 0, p6 = 0, f5 = [];
                }
            }
            h5 += o6.length, m5 += o6.length;
        }
    }, y6 = 0; y6 < a5.length; y6++)D5(y6);
    return {
        oldFileName: e8,
        newFileName: t7,
        oldHeader: o5,
        newHeader: u4,
        hunks: l5
    };
}
function S3(e8, t7, n7, r6, o5, u4, i6) {
    return (function(e9) {
        var t8 = [];
        e9.oldFileName == e9.newFileName && t8.push("Index: " + e9.oldFileName), t8.push("==================================================================="), t8.push("--- " + e9.oldFileName + ((void 0) === e9.oldHeader ? "" : "\t" + e9.oldHeader)), t8.push("+++ " + e9.newFileName + ((void 0) === e9.newHeader ? "" : "\t" + e9.newHeader));
        for(var n8 = 0; n8 < e9.hunks.length; n8++){
            var r7 = e9.hunks[n8];
            0 === r7.oldLines && (r7.oldStart -= 1), 0 === r7.newLines && (r7.newStart -= 1), t8.push("@@ -" + r7.oldStart + "," + r7.oldLines + " +" + r7.newStart + "," + r7.newLines + " @@"), t8.push.apply(t8, r7.lines);
        }
        return t8.join("\n") + "\n";
    })(x3(e8, t7, n7, r6, o5, u4, i6));
}
function T4(e8) {
    var t7 = W(e8.lines), n7 = t7.oldLines, r6 = t7.newLines;
    (void 0) !== n7 ? e8.oldLines = n7 : delete e8.oldLines, (void 0) !== r6 ? e8.newLines = r6 : delete e8.newLines;
}
function B3(e8, t7) {
    if ("string" == typeof e8) {
        if (/^@@/m.test(e8) || /^Index:/m.test(e8)) return v(e8)[0];
        if (!t7) throw new Error("Must provide a base reference or pass in a patch");
        return x3(void 0, void 0, t7, e8);
    }
    return e8;
}
function L1(e8, t7, n7) {
    var r6 = V(t7), o5 = V(n7);
    if ($(r6) && $(o5)) {
        var u4, i6;
        if (w(r6, o5) && q(n7, r6, r6.length - o5.length)) return void (u4 = e8.lines).push.apply(u4, g5(r6));
        if (w(o5, r6) && q(t7, o5, o5.length - r6.length)) return void (i6 = e8.lines).push.apply(i6, g5(o5));
    } else if ((function(e9, t8) {
        return e9.length === t8.length && w(e9, t8);
    })(r6, o5)) {
        var a5;
        return void (a5 = e8.lines).push.apply(a5, g5(r6));
    }
    j3(e8, r6, o5);
}
function M4(e8, t7, n7, r6) {
    var o5, u4 = V(t7), i6 = function(e9, t8) {
        var n8 = [], r7 = [], o6 = 0, u5 = !1, i6 = !1;
        for(; o6 < t8.length && e9.index < e9.lines.length;){
            var a5 = e9.lines[e9.index], s4 = t8[o6];
            if ("+" === s4[0]) break;
            if (u5 = u5 || " " !== a5[0], r7.push(s4), o6++, "+" === a5[0]) for(i6 = !0; "+" === a5[0];)n8.push(a5), a5 = e9.lines[++e9.index];
            s4.substr(1) === a5.substr(1) ? (n8.push(a5), e9.index++) : i6 = !0;
        }
        "+" === (t8[o6] || "")[0] && u5 && (i6 = !0);
        if (i6) return n8;
        for(; o6 < t8.length;)r7.push(t8[o6++]);
        return {
            merged: r7,
            changes: n8
        };
    }(n7, u4);
    i6.merged ? (o5 = e8.lines).push.apply(o5, g5(i6.merged)) : j3(e8, r6 ? i6 : u4, r6 ? u4 : i6);
}
function _t1(e8, t7) {
    return Vt(e8, {
        type: "indent"
    }, t7);
}
function Rt1(e8, t7, n7) {
    if (t7 === -1 / 0) return e8.root || {
        value: "",
        length: 0,
        queue: []
    };
    if (t7 < 0) return Vt(e8, {
        type: "dedent"
    }, n7);
    if (!t7) return e8;
    if ("root" === t7.type) return Object.assign({
    }, e8, {
        root: e8
    });
    return Vt(e8, {
        type: "string" == typeof t7 ? "stringAlign" : "numberAlign",
        n: t7
    }, n7);
}
function Vn(e8, t7, n7, r6) {
    return sr(ir(t7, e8.length - n7), e8, n7, r6);
}
function $n(e8, t7, n7, r6) {
    return sr(function(e9) {
        for(var t8 = [], n8 = 0; n8 < e9.length; ++n8)t8.push(255 & e9.charCodeAt(n8));
        return t8;
    }(t7), e8, n7, r6);
}
function qn(e8, t7, n7, r6) {
    return $n(e8, t7, n7, r6);
}
function Un(e8, t7, n7, r6) {
    return sr(function(e9, t8) {
        for(var n8, r7, o5, u4 = [], i6 = 0; i6 < e9.length && !((t8 -= 2) < 0); ++i6)r7 = (n8 = e9.charCodeAt(i6)) >> 8, o5 = n8 % 256, u4.push(o5), u4.push(r7);
        return u4;
    }(t7, e8.length - n7), e8, n7, r6);
}
function Xn(e8, t7, n7) {
    var r6 = e8.length;
    (!t7 || t7 < 0) && (t7 = 0), (!n7 || n7 < 0 || n7 > r6) && (n7 = r6);
    for(var o5 = "", u4 = t7; u4 < n7; ++u4)o5 += ur(e8[u4]);
    return o5;
}
function Ea(e8, t7) {
    const n7 = Ca(e8.stack, t7);
    return -1 === n7 ? null : e8.stack[n7];
}
var ba = class {
    constructor(e8){
        this.stack = [
            e8
        ];
    }
    getName() {
        const { stack: e9  } = this, { length: t7  } = e9;
        return t7 > 1 ? e9[t7 - 2] : null;
    }
    getValue() {
        return se(this.stack);
    }
    getNode(e = 0) {
        return Ea(this, e);
    }
    getParentNode(e = 0) {
        return Ea(this, e + 1);
    }
    call(e, ...t) {
        const { stack: n7  } = this, { length: r6  } = n7;
        let o5 = se(n7);
        for (const e9 of t)o5 = o5[e9], n7.push(e9, o5);
        const u4 = e(this);
        return n7.length = r6, u4;
    }
    callParent(e, t = 0) {
        const n7 = Ca(this.stack, t + 1), r6 = this.stack.splice(n7 + 1), o5 = e(this);
        return this.stack.push(...r6), o5;
    }
    each(e, ...t) {
        const { stack: n7  } = this, { length: r6  } = n7;
        let o5 = se(n7);
        for (const e9 of t)o5 = o5[e9], n7.push(e9, o5);
        for(let t7 = 0; t7 < o5.length; ++t7)n7.push(t7, o5[t7]), e(this, t7), n7.length -= 2;
        n7.length = r6;
    }
    map(e, ...t) {
        const n7 = [];
        return this.each((t7, r6)=>{
            n7[r6] = e(t7, r6);
        }, ...t), n7;
    }
    match(...e) {
        let t7 = this.stack.length - 1, n7 = null, r6 = this.stack[t7--];
        for (const o5 of e){
            if ((void 0) === r6) return !1;
            let e9 = null;
            if ("number" == typeof n7 && (e9 = n7, n7 = this.stack[t7--], r6 = this.stack[t7--]), o5 && !o5(r6, n7, e9)) return !1;
            n7 = this.stack[t7--], r6 = this.stack[t7--];
        }
        return !0;
    }
};
function ol(e9) {
    return Us(e9) && (rl.test(sl(e9)) || !/\n/.test(sl(e9)));
}
function Xv(e9) {
    return Yv(e9, [
        "TextNode"
    ]) && !/\S/.test(e9.chars);
}
var tA = {
    getNextNode: Zv,
    getPreviousNode: Qv,
    hasPrettierIgnore: function(e9) {
        const t7 = e9.getValue(), n7 = Qv(e9, 2);
        return eA(t7) || eA(n7);
    },
    isNextNodeOfSomeType: function(e9, t7) {
        return Yv(Zv(e9), t7);
    },
    isNodeOfSomeType: Yv,
    isParentOfSomeType: function(e9, t7) {
        return Yv(e9.getParentNode(0), t7);
    },
    isPreviousNodeOfSomeType: function(e9, t7) {
        return Yv(Qv(e9), t7);
    },
    isVoid: function(e9) {
        return function(e10) {
            return Yv(e10, [
                "ElementNode"
            ]) && "string" == typeof e10.tag && ((function(e13) {
                return e13.toUpperCase() === e13;
            })(e10.tag[0]) || e10.tag.includes("."));
        }(e9) && e9.children.every((e10)=>Xv(e10)
        ) || Hv.has(e9.tag);
    },
    isWhitespaceNode: Xv
};
function mS(e9) {
    return "element" === e9.type && ("script" === e9.fullName || "style" === e9.fullName || "svg:style" === e9.fullName || SS(e9) && ("script" === e9.name || "style" === e9.name));
}
function ES(e9) {
    return CS(e9) && bS(e9);
}
function BS(e9, t7) {
    return NS(e9, t7) && !TS.has(e9.fullName);
}
function kS(e9, t7) {
    return NS(e9, t7) && (BS(e9, t7) || e9.attrMap.lang && "html" !== e9.attrMap.lang);
}
function aT(e9) {
    return e9.firstChild && dT(e9.firstChild) ? "" : CT(e9);
}
function Be4(t7) {
    return De1(t7) && (we1.test(ve1(t7)) || !/\n/.test(ve1(t7)));
}
function Je(e9, t7) {
    return Ke(e9, {
        type: "indent"
    }, t7);
}
function Ze(e9, t7, n7) {
    if (t7 === -1 / 0) return e9.root || {
        value: "",
        length: 0,
        queue: []
    };
    if (t7 < 0) return Ke(e9, {
        type: "dedent"
    }, n7);
    if (!t7) return e9;
    if ("root" === t7.type) return Object.assign({
    }, e9, {
        root: e9
    });
    return Ke(e9, {
        type: "string" == typeof t7 ? "stringAlign" : "numberAlign",
        n: t7
    }, n7);
}
function It(e9) {
    return "element" === e9.type && ("script" === e9.fullName || "style" === e9.fullName || "svg:style" === e9.fullName || Wt(e9) && ("script" === e9.name || "style" === e9.name));
}
function Ut1(e9) {
    return Gt2(e9) && Vt1(e9);
}
function Jt2(e9, t7) {
    return Zt1(e9, t7) && !Yt2.has(e9.fullName);
}
function Kt2(e9, t7) {
    return Zt1(e9, t7) && (Jt2(e9, t7) || e9.attrMap.lang && "html" !== e9.attrMap.lang);
}
class rn {
    constructor(e9 = {
    }){
        for (const t7 of Object.keys(e9)){
            const n7 = e9[t7];
            t7 in nn1 ? this._setNodes(t7, n7) : this[t7] = n7;
        }
    }
    _setNodes(e, t) {
        t !== this[e] && (this[e] = (function(e10, t8) {
            const n7 = e10.map((e13)=>e13 instanceof rn ? e13.clone() : new rn(e13)
            );
            let r6 = null, s4 = n7[0], i6 = n7[1] || null;
            for(let e13 = 0; e13 < n7.length; e13++)on1(s4, {
                index: e13,
                siblings: n7,
                prev: r6,
                next: i6,
                parent: t8
            }), r6 = s4, s4 = i6, i6 = n7[e13 + 2] || null;
            return n7;
        })(t, this), "attrs" === e && on1(this, {
            attrMap: this[e].reduce((e10, t8)=>(e10[t8.fullName] = t8.value, e10)
            , Object.create(null))
        }));
    }
    map(e) {
        let t8 = null;
        for(const n7 in nn1){
            const r6 = this[n7];
            if (r6) {
                const s4 = sn1(r6, (t9)=>t9.map(e)
                );
                t8 !== r6 && (t8 || (t8 = new rn), t8._setNodes(n7, s4));
            }
        }
        if (t8) {
            for(const e10 in this)e10 in nn1 || (t8[e10] = this[e10]);
            const { index: e13 , siblings: n8 , prev: r6 , next: s4 , parent: i6  } = this;
            on1(t8, {
                index: e13,
                siblings: n8,
                prev: r6,
                next: s4,
                parent: i6
            });
        }
        return e(t8 || this);
    }
    clone(e) {
        return new rn(e ? Object.assign({
        }, this, e) : this);
    }
    get firstChild() {
        return this.children && 0 !== this.children.length ? this.children[0] : null;
    }
    get lastChild() {
        return this.children && 0 !== this.children.length ? this.children[this.children.length - 1] : null;
    }
    get rawName() {
        return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
        return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
}
var an1 = {
    Node: rn
};
function createCommonjsModule(fn1, basedir, module) {
    return module = {
        path: basedir,
        exports: {
        },
        require: function(path, base) {
            return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn1(module, module.exports), module.exports;
}
var react_production_min = createCommonjsModule(function(module, exports) {
    var n7 = 60103, p6 = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var q5 = 60109, r6 = 60110, t8 = 60112;
    exports.Suspense = 60113;
    var u4 = 60115, v5 = 60116;
    if (typeof Symbol === "function" && Symbol.for) {
        var w4 = Symbol.for;
        n7 = w4("react.element");
        p6 = w4("react.portal");
        exports.Fragment = w4("react.fragment");
        exports.StrictMode = w4("react.strict_mode");
        exports.Profiler = w4("react.profiler");
        q5 = w4("react.provider");
        r6 = w4("react.context");
        t8 = w4("react.forward_ref");
        exports.Suspense = w4("react.suspense");
        u4 = w4("react.memo");
        v5 = w4("react.lazy");
    }
    var x4 = typeof Symbol === "function" && Symbol.iterator;
    function y6(a5) {
        if (a5 === null || typeof a5 !== "object") return null;
        a5 = x4 && a5[x4] || a5["@@iterator"];
        return typeof a5 === "function" ? a5 : null;
    }
    function z4(a5) {
        for(var b4 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a5, c6 = 1; c6 < arguments.length; c6++)b4 += "&args[]=" + encodeURIComponent(arguments[c6]);
        return "Minified React error #" + a5 + "; visit " + b4 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A5 = {
        isMounted: function() {
            return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
    }, B4 = {
    };
    function C4(a5, b4, c6) {
        this.props = a5;
        this.context = b4;
        this.refs = B4;
        this.updater = c6 || A5;
    }
    C4.prototype.isReactComponent = {
    };
    C4.prototype.setState = function(a5, b4) {
        if (typeof a5 !== "object" && typeof a5 !== "function" && a5 != null) throw Error(z4(85));
        this.updater.enqueueSetState(this, a5, b4, "setState");
    };
    C4.prototype.forceUpdate = function(a5) {
        this.updater.enqueueForceUpdate(this, a5, "forceUpdate");
    };
    function D5() {
    }
    D5.prototype = C4.prototype;
    function E5(a5, b4, c6) {
        this.props = a5;
        this.context = b4;
        this.refs = B4;
        this.updater = c6 || A5;
    }
    var F4 = E5.prototype = new D5();
    F4.constructor = E5;
    objectAssign(F4, C4.prototype);
    F4.isPureReactComponent = true;
    var G3 = {
        current: null
    }, H4 = Object.prototype.hasOwnProperty, I4 = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    function J1(a5, b4, c6) {
        var e10, d6 = {
        }, k6 = null, h5 = null;
        if (b4 != null) for(e10 in (b4.ref !== void 0 && (h5 = b4.ref), b4.key !== void 0 && (k6 = "" + b4.key), b4))H4.call(b4, e10) && !I4.hasOwnProperty(e10) && (d6[e10] = b4[e10]);
        var g6 = arguments.length - 2;
        if (g6 === 1) d6.children = c6;
        else if (1 < g6) {
            for(var f5 = Array(g6), m5 = 0; m5 < g6; m5++)f5[m5] = arguments[m5 + 2];
            d6.children = f5;
        }
        if (a5 && a5.defaultProps) for(e10 in (g6 = a5.defaultProps, g6))d6[e10] === void 0 && (d6[e10] = g6[e10]);
        return {
            $$typeof: n7,
            type: a5,
            key: k6,
            ref: h5,
            props: d6,
            _owner: G3.current
        };
    }
    function K3(a5, b4) {
        return {
            $$typeof: n7,
            type: a5.type,
            key: b4,
            ref: a5.ref,
            props: a5.props,
            _owner: a5._owner
        };
    }
    function L2(a5) {
        return typeof a5 === "object" && a5 !== null && a5.$$typeof === n7;
    }
    function escape(a5) {
        var b4 = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + a5.replace(/[=:]/g, function(a21) {
            return b4[a21];
        });
    }
    var M5 = /\/+/g;
    function N4(a5, b4) {
        return typeof a5 === "object" && a5 !== null && a5.key != null ? escape("" + a5.key) : b4.toString(36);
    }
    function O3(a5, b4, c6, e10, d6) {
        var k6 = typeof a5;
        if (k6 === "undefined" || k6 === "boolean") a5 = null;
        var h5 = false;
        if (a5 === null) h5 = true;
        else switch(k6){
            case "string":
            case "number":
                h5 = true;
                break;
            case "object":
                switch(a5.$$typeof){
                    case n7:
                    case p6:
                        h5 = true;
                }
        }
        if (h5) return (h5 = a5, d6 = d6(h5), a5 = e10 === "" ? "." + N4(h5, 0) : e10, Array.isArray(d6) ? (c6 = "", a5 != null && (c6 = a5.replace(M5, "$&/") + "/"), O3(d6, b4, c6, "", function(a21) {
            return a21;
        })) : d6 != null && (L2(d6) && (d6 = K3(d6, c6 + (!d6.key || h5 && h5.key === d6.key ? "" : ("" + d6.key).replace(M5, "$&/") + "/") + a5)), b4.push(d6)), 1);
        h5 = 0;
        e10 = e10 === "" ? "." : e10 + ":";
        if (Array.isArray(a5)) for(var g6 = 0; g6 < a5.length; g6++){
            k6 = a5[g6];
            var f5 = e10 + N4(k6, g6);
            h5 += O3(k6, b4, c6, f5, d6);
        }
        else if ((f = y6(a5), typeof f === "function")) for((a5 = f.call(a5), g6 = 0); !(k6 = a5.next()).done;)k6 = k6.value, f = e10 + N4(k6, g6++), h5 += O3(k6, b4, c6, f, d6);
        else if (k6 === "object") throw (b4 = "" + a5, Error(z4(31, b4 === "[object Object]" ? "object with keys {" + Object.keys(a5).join(", ") + "}" : b4)));
        return h5;
    }
    function P3(a5, b4, c6) {
        if (a5 == null) return a5;
        var e10 = [], d6 = 0;
        O3(a5, e10, "", "", function(a21) {
            return b4.call(c6, a21, d6++);
        });
        return e10;
    }
    function Q3(a5) {
        if (a5._status === -1) {
            var b4 = a5._result;
            b4 = b4();
            a5._status = 0;
            a5._result = b4;
            b4.then(function(b21) {
                a5._status === 0 && (b21 = b21.default, a5._status = 1, a5._result = b21);
            }, function(b21) {
                a5._status === 0 && (a5._status = 2, a5._result = b21);
            });
        }
        if (a5._status === 1) return a5._result;
        throw a5._result;
    }
    var R4 = {
        current: null
    };
    function S4() {
        var a5 = R4.current;
        if (a5 === null) throw Error(z4(321));
        return a5;
    }
    var T5 = {
        ReactCurrentDispatcher: R4,
        ReactCurrentBatchConfig: {
            transition: 0
        },
        ReactCurrentOwner: G3,
        IsSomeRendererActing: {
            current: false
        },
        assign: objectAssign
    };
    exports.Children = {
        map: P3,
        forEach: function(a5, b4, c6) {
            P3(a5, function() {
                b4.apply(this, arguments);
            }, c6);
        },
        count: function(a5) {
            var b4 = 0;
            P3(a5, function() {
                b4++;
            });
            return b4;
        },
        toArray: function(a5) {
            return P3(a5, function(a21) {
                return a21;
            }) || [];
        },
        only: function(a5) {
            if (!L2(a5)) throw Error(z4(143));
            return a5;
        }
    };
    exports.Component = C4;
    exports.PureComponent = E5;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T5;
    exports.cloneElement = function(a5, b4, c6) {
        if (a5 === null || a5 === void 0) throw Error(z4(267, a5));
        var e10 = objectAssign({
        }, a5.props), d6 = a5.key, k6 = a5.ref, h5 = a5._owner;
        if (b4 != null) {
            b4.ref !== void 0 && (k6 = b4.ref, h5 = G3.current);
            b4.key !== void 0 && (d6 = "" + b4.key);
            if (a5.type && a5.type.defaultProps) var g6 = a5.type.defaultProps;
            for(f5 in b4)H4.call(b4, f5) && !I4.hasOwnProperty(f5) && (e10[f5] = b4[f5] === void 0 && g6 !== void 0 ? g6[f5] : b4[f5]);
        }
        var f5 = arguments.length - 2;
        if (f5 === 1) e10.children = c6;
        else if (1 < f5) {
            g = Array(f5);
            for(var m5 = 0; m5 < f5; m5++)g[m5] = arguments[m5 + 2];
            e10.children = g;
        }
        return {
            $$typeof: n7,
            type: a5.type,
            key: d6,
            ref: k6,
            props: e10,
            _owner: h5
        };
    };
    exports.createContext = function(a5, b4) {
        b4 === void 0 && (b4 = null);
        a5 = {
            $$typeof: r6,
            _calculateChangedBits: b4,
            _currentValue: a5,
            _currentValue2: a5,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        };
        a5.Provider = {
            $$typeof: q5,
            _context: a5
        };
        return a5.Consumer = a5;
    };
    exports.createElement = J1;
    exports.createFactory = function(a5) {
        var b4 = J1.bind(null, a5);
        b4.type = a5;
        return b4;
    };
    exports.createRef = function() {
        return {
            current: null
        };
    };
    exports.forwardRef = function(a5) {
        return {
            $$typeof: t8,
            render: a5
        };
    };
    exports.isValidElement = L2;
    exports.lazy = function(a5) {
        return {
            $$typeof: v5,
            _payload: {
                _status: -1,
                _result: a5
            },
            _init: Q3
        };
    };
    exports.memo = function(a5, b4) {
        return {
            $$typeof: u4,
            type: a5,
            compare: b4 === void 0 ? null : b4
        };
    };
    exports.useCallback = function(a5, b4) {
        return S4().useCallback(a5, b4);
    };
    exports.useContext = function(a5, b4) {
        return S4().useContext(a5, b4);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a5, b4) {
        return S4().useEffect(a5, b4);
    };
    exports.useImperativeHandle = function(a5, b4, c6) {
        return S4().useImperativeHandle(a5, b4, c6);
    };
    exports.useLayoutEffect = function(a5, b4) {
        return S4().useLayoutEffect(a5, b4);
    };
    exports.useMemo = function(a5, b4) {
        return S4().useMemo(a5, b4);
    };
    exports.useReducer = function(a5, b4, c6) {
        return S4().useReducer(a5, b4, c6);
    };
    exports.useRef = function(a5) {
        return S4().useRef(a5);
    };
    exports.useState = function(a5) {
        return S4().useState(a5);
    };
    exports.version = "17.0.1";
});
var react = createCommonjsModule(function(module) {
    {
        module.exports = react_production_min;
    }
});
var createContext = react.createContext;
var createElement = react.createElement;
var forwardRef = react.forwardRef;
var useContext = react.useContext;
var useLayoutEffect = react.useLayoutEffect;
var useRef = react.useRef;
function U3(e21) {
    return g3(P2(E4 - 1, Y1(e21 === 91 ? e21 + 2 : e21 === 40 ? e21 + 1 : e21)));
}
function X2(e21) {
    while(K2())switch(Q1(F3)){
        case 0:
            O2(_3(E4 - 1), e21);
            break;
        case 2:
            O2(U3(F3), e21);
            break;
        default:
            O2(d4(F3), e21);
    }
    return e21;
}
function re1(e21, r21, a21, c21, n21, t21, s21, u21, i21) {
    var f21 = 0;
    var o21 = 0;
    var l21 = s21;
    var v21 = 0;
    var h21 = 0;
    var p21 = 0;
    var w21 = 1;
    var b21 = 1;
    var $2 = 1;
    var k21 = 0;
    var m21 = "";
    var g21 = n21;
    var x21 = t21;
    var j21 = c21;
    var z21 = m21;
    while(b21)switch(p21 = k21, k21 = K2()){
        case 34:
        case 39:
        case 91:
        case 40:
            z21 += U3(k21);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            z21 += W1(p21);
            break;
        case 47:
            switch(L()){
                case 42:
                case 47:
                    O2(ce2(Z2(K2(), N3()), r21, a21), i21);
                    break;
                default:
                    z21 += "/";
            }
            break;
        case 123 * w21:
            u21[f21++] = A3(z21) * $2;
        case 125 * w21:
        case 59:
        case 0:
            switch(k21){
                case 0:
                case 125:
                    b21 = 0;
                case 59 + o21:
                    if (h21 > 0) O2(h21 > 32 ? ne1(z21 + ";", c21, a21, l21 - 1) : ne1(y4(z21, " ", "") + ";", c21, a21, l21 - 2), i21);
                    break;
                case 59:
                    z21 += ";";
                default:
                    O2(j21 = ae1(z21, r21, a21, f21, o21, n21, u21, m21, g21 = [], x21 = [], l21), t21);
                    if (k21 === 123) {
                        if (o21 === 0) re1(z21, r21, j21, j21, g21, t21, l21, u21, x21);
                        else switch(v21){
                            case 100:
                            case 109:
                            case 115:
                                re1(e21, j21, j21, c21 && O2(ae1(e21, j21, j21, 0, 0, n21, u21, m21, n21, g21 = [], l21), x21), n21, x21, l21, u21, c21 ? g21 : x21);
                                break;
                            default:
                                re1(z21, j21, j21, j21, [
                                    ""
                                ], x21, l21, u21, x21);
                        }
                    }
            }
            f21 = o21 = h21 = 0, w21 = $2 = 1, m21 = z21 = "", l21 = s21;
            break;
        case 58:
            l21 = 1 + A3(z21), h21 = p21;
        default:
            switch(z21 += d4(k21), k21 * w21){
                case 38:
                    $2 = o21 > 0 ? 1 : (z21 += "\f", -1);
                    break;
                case 44:
                    u21[f21++] = (A3(z21) - 1) * $2, $2 = 1;
                    break;
                case 64:
                    if (L() === 45) z21 += U3(K2());
                    v21 = L(), o21 = A3(m21 = z21 += _3(N3())), k21++;
                    break;
                case 45:
                    if (p21 === 45 && A3(z21) == 2) w21 = 0;
            }
    }
    return t21;
}
function te1(c21, n21) {
    switch(m(c21, n21)){
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return a4 + c21 + c21;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return a4 + c21 + r4 + c21 + e6 + c21 + c21;
        case 6828:
        case 4268:
            return a4 + c21 + e6 + c21 + c21;
        case 6165:
            return a4 + c21 + e6 + "flex-" + c21 + c21;
        case 5187:
            return a4 + c21 + y4(c21, /(\w+).+(:[^]+)/, a4 + "box-$1$2" + e6 + "flex-$1$2") + c21;
        case 5443:
            return a4 + c21 + e6 + "flex-item-" + y4(c21, /flex-|-self/, "") + c21;
        case 4675:
            return a4 + c21 + e6 + "flex-line-pack" + y4(c21, /align-content|flex-|-self/, "") + c21;
        case 5548:
            return a4 + c21 + e6 + y4(c21, "shrink", "negative") + c21;
        case 5292:
            return a4 + c21 + e6 + y4(c21, "basis", "preferred-size") + c21;
        case 6060:
            return a4 + "box-" + y4(c21, "-grow", "") + a4 + c21 + e6 + y4(c21, "grow", "positive") + c21;
        case 4554:
            return a4 + y4(c21, /([^-])(transform)/g, "$1" + a4 + "$2") + c21;
        case 6187:
            return y4(y4(y4(c21, /(zoom-|grab)/, a4 + "$1"), /(image-set)/, a4 + "$1"), c21, "") + c21;
        case 5495:
        case 3959:
            return y4(c21, /(image-set\([^]*)/, a4 + "$1$`$1");
        case 4968:
            return y4(y4(c21, /(.+:)(flex-)?(.*)/, a4 + "box-pack:$3" + e6 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + a4 + c21 + c21;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return y4(c21, /(.+)-inline(.+)/, a4 + "$1$2") + c21;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (A3(c21) - 1 - n21 > 6) switch(z2(c21, n21 + 1)){
                case 102:
                    n21 = z2(c21, n21 + 3);
                case 109:
                    return y4(c21, /(.+:)(.+)-([^]+)/, "$1" + a4 + "$2-$3$1" + r4 + (n21 == 108 ? "$3" : "$2-$3")) + c21;
                case 115:
                    return ~j2(c21, "stretch") ? te1(y4(c21, "stretch", "fill-available"), n21) + c21 : c21;
            }
            break;
        case 4949:
            if (z2(c21, n21 + 1) !== 115) break;
        case 6444:
            switch(z2(c21, A3(c21) - 3 - (~j2(c21, "!important") && 10))){
                case 107:
                case 111:
                    return y4(c21, c21, a4 + c21) + c21;
                case 101:
                    return y4(c21, /(.+:)([^;!]+)(;|!.+)?/, "$1" + a4 + (z2(c21, 14) === 45 ? "inline-" : "") + "box$3$1" + a4 + "$2$3$1" + e6 + "$2box$3") + c21;
            }
            break;
        case 5936:
            switch(z2(c21, n21 + 11)){
                case 114:
                    return a4 + c21 + e6 + y4(c21, /[svh]\w+-[tblr]{2}/, "tb") + c21;
                case 108:
                    return a4 + c21 + e6 + y4(c21, /[svh]\w+-[tblr]{2}/, "tb-rl") + c21;
                case 45:
                    return a4 + c21 + e6 + y4(c21, /[svh]\w+-[tblr]{2}/, "lr") + c21;
            }
            return a4 + c21 + e6 + c21 + c21;
    }
    return c21;
}
function oe1(c21, s21, u21, i21) {
    if (!c21.return) switch(c21.type){
        case t4:
            c21.return = te1(c21.value, c21.length);
            break;
        case p4:
            return se1([
                I2(y4(c21.value, "@", "@" + a4), c21, "")
            ], i21);
        case n5:
            if (c21.length) return S2(c21.props, function(n21) {
                switch(x1(n21, /(::plac\w+|:read-\w+)/)){
                    case ":read-only":
                    case ":read-write":
                        return se1([
                            I2(y4(n21, /:(read-\w+)/, ":" + r4 + "$1"), c21, "")
                        ], i21);
                    case "::placeholder":
                        return se1([
                            I2(y4(n21, /:(plac\w+)/, ":" + a4 + "input-$1"), c21, ""),
                            I2(y4(n21, /:(plac\w+)/, ":" + r4 + "$1"), c21, ""),
                            I2(y4(n21, /:(plac\w+)/, e6 + "input-$1"), c21, "")
                        ], i21);
                }
                return "";
            });
    }
}
var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character = 44;
    do {
        switch(Q1(character)){
            case 0:
                if (character === 38 && L() === 12) {
                    points[index] = 1;
                }
                parsed[index] += _3(E4 - 1);
                break;
            case 2:
                parsed[index] += U3(character);
                break;
            case 4:
                if (character === 44) {
                    parsed[++index] = L() === 58 ? "&\f" : "";
                    points[index] = parsed[index].length;
                    break;
                }
            default:
                parsed[index] += d4(character);
        }
    }while (character = K2())
    return parsed;
};
var getRules = function getRules2(value, points) {
    return T3(toRules(R3(value), points));
};
var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || !element.length) {
        return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while(parent.type !== "rule"){
        parent = parent.parent;
        if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
    }
    if (isImplicitRule) {
        return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for(var i6 = 0, k6 = 0; i6 < rules.length; i6++){
        for(var j4 = 0; j4 < parentRules.length; (j4++, k6++)){
            element.props[k6] = points[i6] ? rules[i6].replace(/&\f/g, parentRules[j4]) : parentRules[j4] + " " + rules[i6];
        }
    }
};
var defaultStylisPlugins = [
    oe1
];
function createCommonjsModule1(fn1, basedir, module) {
    return module = {
        path: basedir,
        exports: {
        },
        require: function(path, base) {
            return commonjsRequire1(path, base === void 0 || base === null ? module.path : base);
        }
    }, fn1(module, module.exports), module.exports;
}
var reactIs = createCommonjsModule1(function(module) {
    {
        module.exports = reactIs_production_min;
    }
});
const reactIs1 = reactIs;
function getStatics(component) {
    if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols1) {
            keys = keys.concat(getOwnPropertySymbols1(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for(var i6 = 0; i6 < keys.length; ++i6){
            var key = keys[i6];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {
                }
            }
        }
    }
    return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
var hoistNonReactStatics1 = function(targetComponent, sourceComponent) {
    return hoistNonReactStatics_cjs(targetComponent, sourceComponent);
};
var ThemeContext = createContext({
});
function requestResponseMessage(ep1, msg, transfers) {
    return new Promise((resolve)=>{
        const id = generateUUID();
        ep1.addEventListener("message", function l5(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep1.removeEventListener("message", l5);
            resolve(ev.data);
        });
        if (ep1.start) {
            ep1.start();
        }
        ep1.postMessage(Object.assign({
            id
        }, msg), transfers);
    });
}
function I4(e10, t8, n7, r6, o5) {
    var u4 = {
        offset: t8,
        lines: n7,
        index: 0
    }, i6 = {
        offset: r6,
        lines: o5,
        index: 0
    };
    for(_(e10, u4, i6), _(e10, i6, u4); u4.index < u4.lines.length && i6.index < i6.lines.length;){
        var a5 = u4.lines[u4.index], s4 = i6.lines[i6.index];
        if ("-" !== a5[0] && "+" !== a5[0] || "-" !== s4[0] && "+" !== s4[0]) {
            if ("+" === a5[0] && " " === s4[0]) {
                var l5;
                (l5 = e10.lines).push.apply(l5, g5(V(u4)));
            } else if ("+" === s4[0] && " " === a5[0]) {
                var c6;
                (c6 = e10.lines).push.apply(c6, g5(V(i6)));
            } else "-" === a5[0] && " " === s4[0] ? M4(e10, u4, i6) : "-" === s4[0] && " " === a5[0] ? M4(e10, i6, u4, !0) : a5 === s4 ? (e10.lines.push(a5), u4.index++, i6.index++) : j3(e10, V(u4), V(i6));
        } else L1(e10, u4, i6);
    }
    R(e10, u4), R(e10, i6), T4(e10);
}
var J1 = Object.freeze({
    __proto__: null,
    Diff: r1,
    applyPatch: F,
    applyPatches: function(e10, t8) {
        "string" == typeof e10 && (e10 = v(e10));
        var n7 = 0;
        !(function r6() {
            var o5 = e10[n7++];
            if (!o5) return t8.complete();
            t8.loadFile(o5, function(e13, n8) {
                if (e13) return t8.complete(e13);
                var u4 = F(n8, o5, t8);
                t8.patched(o5, u4, function(e14) {
                    if (e14) return t8.complete(e14);
                    r6();
                });
            });
        })();
    },
    canonicalize: C1,
    convertChangesToDMP: function(e10) {
        for(var t8, n7, r6 = [], o5 = 0; o5 < e10.length; o5++)n7 = (t8 = e10[o5]).added ? 1 : t8.removed ? -1 : 0, r6.push([
            n7,
            t8.value
        ]);
        return r6;
    },
    convertChangesToXML: function(e10) {
        for(var t8 = [], n7 = 0; n7 < e10.length; n7++){
            var r6 = e10[n7];
            r6.added ? t8.push("<ins>") : r6.removed && t8.push("<del>"), t8.push(U(r6.value)), r6.added ? t8.push("</ins>") : r6.removed && t8.push("</del>");
        }
        return t8.join("");
    },
    createPatch: function(e10, t8, n7, r6, o5, u4) {
        return S3(e10, e10, t8, n7, r6, o5, u4);
    },
    createTwoFilesPatch: S3,
    diffArrays: function(e10, t8, n7) {
        return b.diff(e10, t8, n7);
    },
    diffChars: function(e10, t8, n7) {
        return i1.diff(e10, t8, n7);
    },
    diffCss: function(e10, t8, n7) {
        return h3.diff(e10, t8, n7);
    },
    diffJson: function(e10, t8, n7) {
        return E2.diff(e10, t8, n7);
    },
    diffLines: d1,
    diffSentences: function(e10, t8, n7) {
        return f2.diff(e10, t8, n7);
    },
    diffTrimmedLines: function(e10, t8, n7) {
        var r6 = a1(n7, {
            ignoreWhitespace: !0
        });
        return p1.diff(e10, t8, r6);
    },
    diffWords: function(e10, t8, n7) {
        return (n7 = a1(n7, {
            ignoreWhitespace: !0
        }), c1.diff(e10, t8, n7));
    },
    diffWordsWithSpace: function(e10, t8, n7) {
        return c1.diff(e10, t8, n7);
    },
    merge: function(e10, t8, n7) {
        e10 = B3(e10, n7), t8 = B3(t8, n7);
        var r6 = {
        };
        (e10.index || t8.index) && (r6.index = e10.index || t8.index), (e10.newFileName || t8.newFileName) && (N(e10) ? N(t8) ? (r6.oldFileName = k5(r6, e10.oldFileName, t8.oldFileName), r6.newFileName = k5(r6, e10.newFileName, t8.newFileName), r6.oldHeader = k5(r6, e10.oldHeader, t8.oldHeader), r6.newHeader = k5(r6, e10.newHeader, t8.newHeader)) : (r6.oldFileName = e10.oldFileName, r6.newFileName = e10.newFileName, r6.oldHeader = e10.oldHeader, r6.newHeader = e10.newHeader) : (r6.oldFileName = t8.oldFileName || e10.oldFileName, r6.newFileName = t8.newFileName || e10.newFileName, r6.oldHeader = t8.oldHeader || e10.oldHeader, r6.newHeader = t8.newHeader || e10.newHeader)), r6.hunks = [];
        for(var o5 = 0, u4 = 0, i6 = 0, a5 = 0; o5 < e10.hunks.length || u4 < t8.hunks.length;){
            var s4 = e10.hunks[o5] || {
                oldStart: 1 / 0
            }, l5 = t8.hunks[u4] || {
                oldStart: 1 / 0
            };
            if (P3(s4, l5)) r6.hunks.push(O(s4, i6)), o5++, a5 += s4.newLines - s4.oldLines;
            else if (P3(l5, s4)) r6.hunks.push(O(l5, a5)), u4++, i6 += l5.newLines - l5.oldLines;
            else {
                var c6 = {
                    oldStart: Math.min(s4.oldStart, l5.oldStart),
                    oldLines: 0,
                    newStart: Math.min(s4.newStart + i6, l5.oldStart + a5),
                    newLines: 0,
                    lines: []
                };
                I4(c6, s4.oldStart, s4.lines, l5.oldStart, l5.lines), u4++, o5++, r6.hunks.push(c6);
            }
        }
        return r6;
    },
    parsePatch: v,
    structuredPatch: x3
});
function yS(e10) {
    return vS(e10) || "element" === e10.type && "br" === e10.fullName || ES(e10);
}
function Mt(e10) {
    return jt1(e10) || "element" === e10.type && "br" === e10.fullName || Ut1(e10);
}
function V3(e21) {
    return T3(X2(R3(e21)));
}
function ee3(e21) {
    return T3(re1("", null, null, null, [
        ""
    ], e21 = R3(e21), 0, [
        0
    ], e21));
}
var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node1) {
            document.head.appendChild(node1);
            node1.setAttribute("data-s", "");
        });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {
    };
    var container;
    var nodesToHydrate = [];
    {
        container = options.container || document.head;
        Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion]"), function(node1) {
            var attrib = node1.getAttribute("data-emotion").split(" ");
            if (attrib[0] !== key) {
                return;
            }
            for(var i6 = 1; i6 < attrib.length; i6++){
                inserted[attrib[i6]] = true;
            }
            nodesToHydrate.push(node1);
        });
    }
    var _insert;
    var omnipresentPlugins = [
        compat,
        removeLabel
    ];
    {
        var currentSheet;
        var finalizingPlugins = [
            ue1,
            fe3(function(rule) {
                currentSheet.insert(rule);
            })
        ];
        var serializer = ie1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis2 = function stylis3(styles) {
            return se1(ee3(styles), serializer);
        };
        _insert = function insert(selector, serialized, sheet2, shouldCache) {
            currentSheet = sheet2;
            stylis2(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
            if (shouldCache) {
                cache2.inserted[serialized.name] = true;
            }
        };
    }
    var cache2 = {
        key,
        sheet: new StyleSheet1({
            key,
            container,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend
        }),
        nonce: options.nonce,
        inserted,
        registered: {
        },
        insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
};
var EmotionCacheContext = createContext(typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
}) : null);
var withEmotionCache = function withEmotionCache2(func) {
    return forwardRef(function(props, ref) {
        var cache2 = useContext(EmotionCacheContext);
        return func(props, cache2, ref);
    });
};
function Ee3() {
    De2 && me && (De2 = !1, me.length ? ge3 = me.concat(ge3) : ye2 = -1, ge3.length && Ce2());
}
function Ce2() {
    if (!De2) {
        var e10 = he3(Ee3);
        De2 = !0;
        for(var t8 = ge3.length; t8;){
            for(me = ge3, ge3 = []; (++ye2) < t8;)me && me[ye2].run();
            ye2 = -1, t8 = ge3.length;
        }
        me = null, De2 = !1, (function(e13) {
            if (fe === clearTimeout) return clearTimeout(e13);
            if ((fe === pe2 || !fe) && clearTimeout) return fe = clearTimeout, clearTimeout(e13);
            try {
                fe(e13);
            } catch (t) {
                try {
                    return fe.call(null, e13);
                } catch (t) {
                    return fe.call(this, e13);
                }
            }
        })(e10);
    }
}
var Oe2 = {
    nextTick: function(e10) {
        var t8 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n7 = 1; n7 < arguments.length; n7++)t8[n7 - 1] = arguments[n7];
        ge3.push(new be2(e10, t8)), 1 !== ge3.length || De2 || he3(Ce2);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: Ae,
    addListener: Fe,
    once: xe,
    off: Se,
    removeListener: we3,
    removeAllListeners: Te,
    emit: Be1,
    binding: function(e10) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(e10) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(e10) {
        var t8 = 0.001 * ke.call(Ne), n7 = Math.floor(t8), r6 = Math.floor(t8 % 1 * 1000000000);
        return (e10 && (n7 -= e10[0], (r6 -= e10[1]) < 0 && (n7--, r6 += 1000000000)), [
            n7,
            r6
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - Pe3) / 1000;
    }
};
var Ie3 = "object" == typeof Oe2 && Oe2.env && Oe2.env.NODE_DEBUG && /\bsemver\b/i.test(Oe2.env.NODE_DEBUG) ? (...e10)=>console.error("SEMVER", ...e10)
 : ()=>{
};
var Re3 = je(function(e10, t8) {
    const { MAX_SAFE_COMPONENT_LENGTH: n7  } = Le3, r6 = (t8 = e10.exports = {
    }).re = [], o5 = t8.src = [], u4 = t8.t = {
    };
    let i6 = 0;
    const a5 = (e13, t9, n8)=>{
        const a6 = i6++;
        Ie3(a6, t9), u4[e13] = a6, o5[a6] = t9, r6[a6] = new RegExp(t9, n8 ? "g" : void 0);
    };
    a5("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a5("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a5("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a5("MAINVERSION", "(".concat(o5[u4.NUMERICIDENTIFIER], ")\\.") + "(".concat(o5[u4.NUMERICIDENTIFIER], ")\\.") + "(".concat(o5[u4.NUMERICIDENTIFIER], ")")), a5("MAINVERSIONLOOSE", "(".concat(o5[u4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o5[u4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o5[u4.NUMERICIDENTIFIERLOOSE], ")")), a5("PRERELEASEIDENTIFIER", "(?:".concat(o5[u4.NUMERICIDENTIFIER], "|").concat(o5[u4.NONNUMERICIDENTIFIER], ")")), a5("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(o5[u4.NUMERICIDENTIFIERLOOSE], "|").concat(o5[u4.NONNUMERICIDENTIFIER], ")")), a5("PRERELEASE", "(?:-(".concat(o5[u4.PRERELEASEIDENTIFIER], "(?:\\.").concat(o5[u4.PRERELEASEIDENTIFIER], ")*))")), a5("PRERELEASELOOSE", "(?:-?(".concat(o5[u4.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(o5[u4.PRERELEASEIDENTIFIERLOOSE], ")*))")), a5("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a5("BUILD", "(?:\\+(".concat(o5[u4.BUILDIDENTIFIER], "(?:\\.").concat(o5[u4.BUILDIDENTIFIER], ")*))")), a5("FULLPLAIN", "v?".concat(o5[u4.MAINVERSION]).concat(o5[u4.PRERELEASE], "?").concat(o5[u4.BUILD], "?")), a5("FULL", "^".concat(o5[u4.FULLPLAIN], "$")), a5("LOOSEPLAIN", "[v=\\s]*".concat(o5[u4.MAINVERSIONLOOSE]).concat(o5[u4.PRERELEASELOOSE], "?").concat(o5[u4.BUILD], "?")), a5("LOOSE", "^".concat(o5[u4.LOOSEPLAIN], "$")), a5("GTLT", "((?:<|>)?=?)"), a5("XRANGEIDENTIFIERLOOSE", "".concat(o5[u4.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a5("XRANGEIDENTIFIER", "".concat(o5[u4.NUMERICIDENTIFIER], "|x|X|\\*")), a5("XRANGEPLAIN", "[v=\\s]*(".concat(o5[u4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o5[u4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o5[u4.XRANGEIDENTIFIER], ")") + "(?:".concat(o5[u4.PRERELEASE], ")?").concat(o5[u4.BUILD], "?") + ")?)?"), a5("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(o5[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o5[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o5[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(o5[u4.PRERELEASELOOSE], ")?").concat(o5[u4.BUILD], "?") + ")?)?"), a5("XRANGE", "^".concat(o5[u4.GTLT], "\\s*").concat(o5[u4.XRANGEPLAIN], "$")), a5("XRANGELOOSE", "^".concat(o5[u4.GTLT], "\\s*").concat(o5[u4.XRANGEPLAINLOOSE], "$")), a5("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n7, "})") + "(?:\\.(\\d{1,".concat(n7, "}))?") + "(?:\\.(\\d{1,".concat(n7, "}))?") + "(?:$|[^\\d])"), a5("COERCERTL", o5[u4.COERCE], !0), a5("LONETILDE", "(?:~>?)"), a5("TILDETRIM", "(\\s*)".concat(o5[u4.LONETILDE], "\\s+"), !0), t8.tildeTrimReplace = "$1~", a5("TILDE", "^".concat(o5[u4.LONETILDE]).concat(o5[u4.XRANGEPLAIN], "$")), a5("TILDELOOSE", "^".concat(o5[u4.LONETILDE]).concat(o5[u4.XRANGEPLAINLOOSE], "$")), a5("LONECARET", "(?:\\^)"), a5("CARETTRIM", "(\\s*)".concat(o5[u4.LONECARET], "\\s+"), !0), t8.caretTrimReplace = "$1^", a5("CARET", "^".concat(o5[u4.LONECARET]).concat(o5[u4.XRANGEPLAIN], "$")), a5("CARETLOOSE", "^".concat(o5[u4.LONECARET]).concat(o5[u4.XRANGEPLAINLOOSE], "$")), a5("COMPARATORLOOSE", "^".concat(o5[u4.GTLT], "\\s*(").concat(o5[u4.LOOSEPLAIN], ")$|^$")), a5("COMPARATOR", "^".concat(o5[u4.GTLT], "\\s*(").concat(o5[u4.FULLPLAIN], ")$|^$")), a5("COMPARATORTRIM", "(\\s*)".concat(o5[u4.GTLT], "\\s*(").concat(o5[u4.LOOSEPLAIN], "|").concat(o5[u4.XRANGEPLAIN], ")"), !0), t8.comparatorTrimReplace = "$1$2$3", a5("HYPHENRANGE", "^\\s*(".concat(o5[u4.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(o5[u4.XRANGEPLAIN], ")") + "\\s*$"), a5("HYPHENRANGELOOSE", "^\\s*(".concat(o5[u4.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(o5[u4.XRANGEPLAINLOOSE], ")") + "\\s*$"), a5("STAR", "(<|>)?=?\\s*\\*"), a5("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a5("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: We , MAX_SAFE_INTEGER: Ue2  } = Le3, { re: Je1 , t: ze1  } = Re3, { compareIdentifiers: Ge1  } = qe;
class He {
    constructor(e10, t8){
        if (t8 && "object" == typeof t8 || (t8 = {
            loose: !!t8,
            includePrerelease: !1
        }), e10 instanceof He) {
            if (e10.loose === !!t8.loose && e10.includePrerelease === !!t8.includePrerelease) return e10;
            e10 = e10.version;
        } else if ("string" != typeof e10) throw new TypeError("Invalid Version: ".concat(e10));
        if (e10.length > We) throw new TypeError("version is longer than ".concat(We, " characters"));
        Ie3("SemVer", e10, t8), this.options = t8, this.loose = !!t8.loose, this.includePrerelease = !!t8.includePrerelease;
        const n7 = e10.trim().match(t8.loose ? Je1[ze1.LOOSE] : Je1[ze1.FULL]);
        if (!n7) throw new TypeError("Invalid Version: ".concat(e10));
        if (this.raw = e10, this.major = +n7[1], this.minor = +n7[2], this.patch = +n7[3], this.major > Ue2 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > Ue2 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > Ue2 || this.patch < 0) throw new TypeError("Invalid patch version");
        n7[4] ? this.prerelease = n7[4].split(".").map((e13)=>{
            if (/^[0-9]+$/.test(e13)) {
                const t9 = +e13;
                if (t9 >= 0 && t9 < Ue2) return t9;
            }
            return e13;
        }) : this.prerelease = [], this.build = n7[5] ? n7[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(e) {
        if (Ie3("SemVer.compare", this.version, this.options, e), !(e instanceof He)) {
            if ("string" == typeof e && e === this.version) return 0;
            e = new He(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
        return e instanceof He || (e = new He(e, this.options)), Ge1(this.major, e.major) || Ge1(this.minor, e.minor) || Ge1(this.patch, e.patch);
    }
    comparePre(e) {
        if (e instanceof He || (e = new He(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t9 = 0;
        do {
            const n8 = this.prerelease[t9], r6 = e.prerelease[t9];
            if (Ie3("prerelease compare", t9, n8, r6), (void 0) === n8 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === n8) return -1;
            if (n8 !== r6) return Ge1(n8, r6);
        }while (++t9)
    }
    compareBuild(e) {
        e instanceof He || (e = new He(e, this.options));
        let t9 = 0;
        do {
            const n8 = this.build[t9], r6 = e.build[t9];
            if (Ie3("prerelease compare", t9, n8, r6), (void 0) === n8 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === n8) return -1;
            if (n8 !== r6) return Ge1(n8, r6);
        }while (++t9)
    }
    inc(e, t) {
        switch(e){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let e13 = this.prerelease.length;
                    for(; (--e13) >= 0;)"number" == typeof this.prerelease[e13] && (this.prerelease[e13]++, e13 = -2);
                    -1 === e13 && this.prerelease.push(0);
                }
                t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    t,
                    0
                ]) : this.prerelease = [
                    t,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(e));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var Xe = He;
var Ye1 = (e13, t9, n8)=>new Xe(e13, n8).compare(new Xe(t9, n8))
;
var Ke1 = (e13, t9, n8)=>Ye1(e13, t9, n8) < 0
;
var Qe = (e13, t9, n8)=>Ye1(e13, t9, n8) >= 0
, Ze1 = je(function(e13, t9) {
    function n8() {
        for(var e14 = [], t10 = 0; t10 < arguments.length; t10++)e14[t10] = arguments[t10];
    }
    function r6() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: n8,
            delete: n8,
            get: n8,
            set: n8,
            has: function(e14) {
                return !1;
            }
        };
    }
    Object.defineProperty(t9, "__esModule", {
        value: !0
    });
    var o5 = Object.prototype.hasOwnProperty, u4 = function(e14, t10) {
        return o5.call(e14, t10);
    };
    function i6(e14, t10) {
        for(var n9 in t10)u4(t10, n9) && (e14[n9] = t10[n9]);
        return e14;
    }
    var a5 = /^[ \t]*(?:\r\n|\r|\n)/, s4 = /(?:\r\n|\r|\n)[ \t]*$/, l5 = /^(?:[\r\n]|$)/, c6 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p6 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function d6(e14, t10, n9) {
        var r7 = 0, o6 = e14[0].match(c6);
        o6 && (r7 = o6[1].length);
        var u5 = new RegExp("(\\r\\n|\\r|\\n).{0," + r7 + "}", "g");
        t10 && (e14 = e14.slice(1));
        var i7 = n9.newline, l6 = n9.trimLeadingNewline, p7 = n9.trimTrailingNewline, d6 = "string" == typeof i7, f5 = e14.length;
        return e14.map(function(e15, t11) {
            return (e15 = e15.replace(u5, "$1"), 0 === t11 && l6 && (e15 = e15.replace(a5, "")), t11 === f5 - 1 && p7 && (e15 = e15.replace(s4, "")), d6 && (e15 = e15.replace(/\r\n|\n|\r/g, function(e16) {
                return i7;
            })), e15);
        });
    }
    function f5(e14, t10) {
        for(var n9 = "", r7 = 0, o6 = e14.length; r7 < o6; r7++)n9 += e14[r7], r7 < o6 - 1 && (n9 += t10[r7]);
        return n9;
    }
    function h5(e14) {
        return u4(e14, "raw") && u4(e14, "length");
    }
    var m5 = function e13(t10) {
        var n9 = r6(), o6 = r6();
        return i6(function r7(u5) {
            for(var a6 = [], s5 = 1; s5 < arguments.length; s5++)a6[s5 - 1] = arguments[s5];
            if (h5(u5)) {
                var c7 = u5, g6 = (a6[0] === r7 || a6[0] === m5) && p6.test(c7[0]) && l5.test(c7[1]), D5 = g6 ? o6 : n9, y6 = D5.get(c7);
                if ((y6 || (y6 = d6(c7, g6, t10), D5.set(c7, y6)), 0 === a6.length)) return y6[0];
                var E5 = f5(y6, g6 ? a6.slice(1) : a6);
                return E5;
            }
            return e13(i6(i6({
            }, t10), u5 || {
            }));
        }, {
            string: function(e14) {
                return d6([
                    e14
                ], !1, t10)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    t9.outdent = m5, t9.default = m5;
    try {
        e13.exports = m5, Object.defineProperty(m5, "__esModule", {
            value: !0
        }), m5.default = m5, m5.outdent = m5;
    } catch (e) {
    }
});
const { outdent: it2  } = Ze1, at2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: it2(ut()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: it2(ot())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (e13)=>"string" == typeof e13 || "function" == typeof e13
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (e13)=>"string" == typeof e13 || "object" == typeof e13
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: it2(rt()),
        exception: (e13)=>"string" == typeof e13 || "object" == typeof e13
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: it2(nt()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: it2(tt()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: it2(et()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const st2 = {
    compare: Ye1,
    lt: Ke1,
    gte: Qe
}, lt1 = n1.version, ct1 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: at2
}.options;
var pt1 = {
    getSupportInfo: function({ plugins: t9 = [] , showUnreleased: n8 = !1 , showDeprecated: r6 = !1 , showInternal: o5 = !1  } = {
    }) {
        const u4 = lt1.split("-", 1)[0], i6 = t9.reduce((e13, t10)=>e13.concat(t10.languages || [])
        , []).filter(s4), a5 = ((e13, t10)=>Object.entries(e13).map(([e14, n9])=>Object.assign({
                    [t10]: e14
                }, n9)
            )
        )(Object.assign({
        }, ...t9.map(({ options: e13  })=>e13
        ), ct1), "name").filter((e13)=>s4(e13) && l5(e13)
        ).sort((e13, t10)=>e13.name === t10.name ? 0 : e13.name < t10.name ? -1 : 1
        ).map(function(t10) {
            if (o5) return t10;
            return e1(t10, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((e13)=>{
            e13 = Object.assign({
            }, e13), Array.isArray(e13.default) && (e13.default = 1 === e13.default.length ? e13.default[0].value : e13.default.filter(s4).sort((e14, t10)=>st2.compare(t10.since, e14.since)
            )[0].value), Array.isArray(e13.choices) && (e13.choices = e13.choices.filter((e14)=>s4(e14) && l5(e14)
            ), "parser" === e13.name && (function(e14, t10, n9) {
                const r7 = new Set(e14.choices.map((e15)=>e15.value
                ));
                for (const o6 of t10)if (o6.parsers) for (const t11 of o6.parsers)if (!r7.has(t11)) {
                    r7.add(t11);
                    const u5 = n9.find((e15)=>e15.parsers && e15.parsers[t11]
                    );
                    let i7 = o6.name;
                    u5 && u5.name && (i7 += " (plugin: ".concat(u5.name, ")")), e14.choices.push({
                        value: t11,
                        description: i7
                    });
                }
            })(e13, i6, t9));
            const n9 = t9.filter((t10)=>t10.defaultOptions && (void 0) !== t10.defaultOptions[e13.name]
            ).reduce((t10, n10)=>(t10[n10.name] = n10.defaultOptions[e13.name], t10)
            , {
            });
            return Object.assign({
            }, e13, {
                pluginDefaults: n9
            });
        });
        return {
            languages: i6,
            options: a5
        };
        function s4(e13) {
            return n8 || !("since" in e13) || e13.since && st2.gte(u4, e13.since);
        }
        function l5(e13) {
            return r6 || !("deprecated" in e13) || e13.deprecated && st2.lt(u4, e13.deprecated);
        }
    }
};
const { getSupportInfo: dt1  } = pt1, ft2 = /[^\x20-\x7F]/;
var Nt1 = {
    inferParserByLanguage: function(e13, t9) {
        const { languages: n8  } = dt1({
            plugins: t9.plugins
        }), r6 = n8.find(({ name: t10  })=>t10.toLowerCase() === e13
        ) || n8.find(({ aliases: t10  })=>Array.isArray(t10) && t10.includes(e13)
        ) || n8.find(({ extensions: t10  })=>Array.isArray(t10) && t10.includes(".".concat(e13))
        );
        return r6 && r6.parsers[0];
    },
    replaceEndOfLineWith: function(e13, t9) {
        const n8 = [];
        for (const r6 of e13.split("\n"))0 !== n8.length && n8.push(t9), n8.push(r6);
        return n8;
    },
    getStringWidth: function(e13) {
        return e13 ? ft2.test(e13) ? ue(e13) : e13.length : 0;
    },
    getMaxContinuousCount: function(e13, t9) {
        const n8 = e13.match(new RegExp("(".concat(ae(t9), ")+"), "g"));
        return null === n8 ? 0 : n8.reduce((e14, n9)=>Math.max(e14, n9.length / t9.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(e13, t9) {
        const n8 = e13.match(new RegExp("(".concat(ae(t9), ")+"), "g"));
        if (null === n8) return 0;
        const r6 = new Map;
        let o5 = 0;
        for (const e14 of n8){
            const n9 = e14.length / t9.length;
            r6.set(n9, !0), n9 > o5 && (o5 = n9);
        }
        for(let e15 = 1; e15 < o5; e15++)if (!r6.get(e15)) return e15;
        return o5 + 1;
    },
    getPenultimate: (e13)=>e13[e13.length - 2]
    ,
    getLast: se,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ft,
    getNextNonSpaceNonCommentCharacterIndex: xt,
    getNextNonSpaceNonCommentCharacter: function(e13, t9, n8) {
        return e13.charAt(xt(e13, t9, n8));
    },
    skip: ht,
    skipWhitespace: mt,
    skipSpaces: gt,
    skipToLineEnd: Dt,
    skipEverythingButNewLine: yt,
    skipInlineComment: Et,
    skipTrailingComment: Ct,
    skipNewline: bt,
    isNextLineEmptyAfterIndex: At,
    isNextLineEmpty: function(e13, t9, n8) {
        return At(e13, n8(t9));
    },
    isPreviousLineEmpty: function(e13, t9, n8) {
        let r6 = n8(t9) - 1;
        return (r6 = gt(e13, r6, {
            backwards: !0
        }), r6 = bt(e13, r6, {
            backwards: !0
        }), r6 = gt(e13, r6, {
            backwards: !0
        }), r6 !== bt(e13, r6, {
            backwards: !0
        }));
    },
    hasNewline: vt,
    hasNewlineInRange: function(e13, t9, n8) {
        for(let r6 = t9; r6 < n8; ++r6)if ("\n" === e13.charAt(r6)) return !0;
        return !1;
    },
    hasSpaces: function(e13, t9, n8) {
        return gt(e13, (n8 = n8 || {
        }).backwards ? t9 - 1 : t9, n8) !== t9;
    },
    getAlignmentSize: St2,
    getIndentSize: function(e13, t9) {
        const n8 = e13.lastIndexOf("\n");
        return -1 === n8 ? 0 : St2(e13.slice(n8 + 1).match(/^[\t ]*/)[0], t9);
    },
    getPreferredQuote: wt,
    printString: function(e13, t9, n8) {
        const r6 = e13.slice(1, -1), o5 = !r6.includes('"') && !r6.includes("'"), u4 = "json" === t9.parser ? '"' : t9.__isInHtmlAttribute ? "'" : wt(e13, t9.singleQuote ? "'" : '"');
        return n8 ? o5 ? u4 + r6 + u4 : e13 : Tt(r6, u4, !("css" === t9.parser || "less" === t9.parser || "scss" === t9.parser || t9.embeddedInHtml));
    },
    printNumber: function(e13) {
        return e13.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(e13) {
        return "prettier-ignore" === e13.value.trim();
    },
    makeString: Tt,
    addLeadingComment: function(e13, t9) {
        t9.leading = !0, t9.trailing = !1, Bt(e13, t9);
    },
    addDanglingComment: function(e13, t9, n8) {
        t9.leading = !1, t9.trailing = !1, n8 && (t9.marker = n8), Bt(e13, t9);
    },
    addTrailingComment: function(e13, t9) {
        t9.leading = !1, t9.trailing = !0, Bt(e13, t9);
    },
    isFrontMatterNode: function(e13) {
        return e13 && "front-matter" === e13.type;
    },
    getShebang: function(e13) {
        if (!e13.startsWith("#!")) return "";
        const t9 = e13.indexOf("\n");
        return -1 === t9 ? e13 : e13.slice(0, t9);
    }
};
const { getStringWidth: Pt1  } = Nt1, { convertEndOfLineToChars: Ot  } = kt, { concat: It1 , fill: Lt2 , cursor: Mt1  } = Z3;
function qt2(e13, t9, n8, r6, o5) {
    let u4 = t9.length;
    const i6 = [
        e13
    ], a5 = [];
    for(; n8 >= 0;){
        if (0 === i6.length) {
            if (0 === u4) return !0;
            i6.push(t9[u4 - 1]), u4--;
            continue;
        }
        const [e14, s4, l5] = i6.pop();
        if ("string" == typeof l5) a5.push(l5), n8 -= Pt1(l5);
        else switch(l5.type){
            case "concat":
                for(let t10 = l5.parts.length - 1; t10 >= 0; t10--)i6.push([
                    e14,
                    s4,
                    l5.parts[t10]
                ]);
                break;
            case "indent":
                i6.push([
                    _t1(e14, r6),
                    s4,
                    l5.contents
                ]);
                break;
            case "align":
                i6.push([
                    Rt1(e14, l5.n, r6),
                    s4,
                    l5.contents
                ]);
                break;
            case "trim":
                n8 += $t(a5);
                break;
            case "group":
                if (o5 && l5.break) return !1;
                i6.push([
                    e14,
                    l5.break ? 1 : s4,
                    l5.contents
                ]), l5.id && (jt[l5.id] = i6[i6.length - 1][1]);
                break;
            case "fill":
                for(let t11 = l5.parts.length - 1; t11 >= 0; t11--)i6.push([
                    e14,
                    s4,
                    l5.parts[t11]
                ]);
                break;
            case "if-break":
                {
                    const t12 = l5.groupId ? jt[l5.groupId] : s4;
                    1 === t12 && l5.breakContents && i6.push([
                        e14,
                        s4,
                        l5.breakContents
                    ]), 2 === t12 && l5.flatContents && i6.push([
                        e14,
                        s4,
                        l5.flatContents
                    ]);
                    break;
                }
            case "line":
                switch(s4){
                    case 2:
                        if (!l5.hard) {
                            l5.soft || (a5.push(" "), n8 -= 1);
                            break;
                        }
                        return !0;
                    case 1:
                        return !0;
                }
        }
    }
    return !1;
}
var Wt1 = {
    printDocToString: function(e13, t9) {
        jt = {
        };
        const n8 = t9.printWidth, r6 = Ot(t9.endOfLine);
        let o5 = 0;
        const u4 = [
            [
                {
                    value: "",
                    length: 0,
                    queue: []
                },
                1,
                e13
            ]
        ], i6 = [];
        let a5 = !1, s4 = [];
        for(; 0 !== u4.length;){
            const [e14, l5, c6] = u4.pop();
            if ("string" == typeof c6) {
                const e15 = "\n" !== r6 && c6.includes("\n") ? c6.replace(/\n/g, r6) : c6;
                i6.push(e15), o5 += Pt1(e15);
            } else switch(c6.type){
                case "cursor":
                    i6.push(Mt1.placeholder);
                    break;
                case "concat":
                    for(let t10 = c6.parts.length - 1; t10 >= 0; t10--)u4.push([
                        e14,
                        l5,
                        c6.parts[t10]
                    ]);
                    break;
                case "indent":
                    u4.push([
                        _t1(e14, t9),
                        l5,
                        c6.contents
                    ]);
                    break;
                case "align":
                    u4.push([
                        Rt1(e14, c6.n, t9),
                        l5,
                        c6.contents
                    ]);
                    break;
                case "trim":
                    o5 -= $t(i6);
                    break;
                case "group":
                    switch(l5){
                        case 2:
                            if (!a5) {
                                u4.push([
                                    e14,
                                    c6.break ? 1 : 2,
                                    c6.contents
                                ]);
                                break;
                            }
                        case 1:
                            {
                                a5 = !1;
                                const r7 = [
                                    e14,
                                    2,
                                    c6.contents
                                ], i7 = n8 - o5;
                                if (!c6.break && qt2(r7, u4, i7, t9)) u4.push(r7);
                                else if (c6.expandedStates) {
                                    const n9 = c6.expandedStates[c6.expandedStates.length - 1];
                                    if (c6.break) {
                                        u4.push([
                                            e14,
                                            1,
                                            n9
                                        ]);
                                        break;
                                    }
                                    for(let r8 = 1; r8 < c6.expandedStates.length + 1; r8++){
                                        if (r8 >= c6.expandedStates.length) {
                                            u4.push([
                                                e14,
                                                1,
                                                n9
                                            ]);
                                            break;
                                        }
                                        {
                                            const n10 = [
                                                e14,
                                                2,
                                                c6.expandedStates[r8]
                                            ];
                                            if (qt2(n10, u4, i7, t9)) {
                                                u4.push(n10);
                                                break;
                                            }
                                        }
                                    }
                                } else u4.push([
                                    e14,
                                    1,
                                    c6.contents
                                ]);
                                break;
                            }
                    }
                    c6.id && (jt[c6.id] = u4[u4.length - 1][1]);
                    break;
                case "fill":
                    {
                        const r7 = n8 - o5, { parts: i7  } = c6;
                        if (0 === i7.length) break;
                        const [a6, s5] = i7, p6 = [
                            e14,
                            2,
                            a6
                        ], d6 = [
                            e14,
                            1,
                            a6
                        ], f5 = qt2(p6, [], r7, t9, !0);
                        if (1 === i7.length) {
                            f5 ? u4.push(p6) : u4.push(d6);
                            break;
                        }
                        const h5 = [
                            e14,
                            2,
                            s5
                        ], m5 = [
                            e14,
                            1,
                            s5
                        ];
                        if (2 === i7.length) {
                            f5 ? (u4.push(h5), u4.push(p6)) : (u4.push(m5), u4.push(d6));
                            break;
                        }
                        i7.splice(0, 2);
                        const g6 = [
                            e14,
                            l5,
                            Lt2(i7)
                        ], D5 = i7[0];
                        qt2([
                            e14,
                            2,
                            It1([
                                a6,
                                s5,
                                D5
                            ])
                        ], [], r7, t9, !0) ? (u4.push(g6), u4.push(h5), u4.push(p6)) : f5 ? (u4.push(g6), u4.push(m5), u4.push(p6)) : (u4.push(g6), u4.push(m5), u4.push(d6));
                        break;
                    }
                case "if-break":
                    {
                        const t11 = c6.groupId ? jt[c6.groupId] : l5;
                        1 === t11 && c6.breakContents && u4.push([
                            e14,
                            l5,
                            c6.breakContents
                        ]), 2 === t11 && c6.flatContents && u4.push([
                            e14,
                            l5,
                            c6.flatContents
                        ]);
                        break;
                    }
                case "line-suffix":
                    s4.push([
                        e14,
                        l5,
                        c6.contents
                    ]);
                    break;
                case "line-suffix-boundary":
                    s4.length > 0 && u4.push([
                        e14,
                        l5,
                        {
                            type: "line",
                            hard: !0
                        }
                    ]);
                    break;
                case "line":
                    switch(l5){
                        case 2:
                            if (!c6.hard) {
                                c6.soft || (i6.push(" "), o5 += 1);
                                break;
                            }
                            a5 = !0;
                        case 1:
                            if (s4.length) {
                                u4.push([
                                    e14,
                                    l5,
                                    c6
                                ]), u4.push(...s4.reverse()), s4 = [];
                                break;
                            }
                            c6.literal ? e14.root ? (i6.push(r6, e14.root.value), o5 = e14.root.length) : (i6.push(r6), o5 = 0) : (o5 -= $t(i6), i6.push(r6 + e14.value), o5 = e14.length);
                    }
            }
            0 === u4.length && s4.length && (u4.push(...s4.reverse()), s4 = []);
        }
        const l5 = i6.indexOf(Mt1.placeholder);
        if (-1 !== l5) {
            const e14 = i6.indexOf(Mt1.placeholder, l5 + 1), t10 = i6.slice(0, l5).join(""), n9 = i6.slice(l5 + 1, e14).join("");
            return {
                formatted: t10 + n9 + i6.slice(e14 + 1).join(""),
                cursorNodeStart: t10.length,
                cursorNodeText: n9
            };
        }
        return {
            formatted: i6.join("")
        };
    }
};
var rn1 = {
    builders: Z3,
    printer: Wt1,
    utils: {
        isEmpty: function(e13) {
            return "string" == typeof e13 && 0 === e13.length;
        },
        willBreak: function(e13) {
            return Xt(e13, Kt, !1);
        },
        isLineNext: function(e13) {
            return Xt(e13, Yt, !1);
        },
        traverseDoc: Gt,
        findInDoc: Xt,
        mapDoc: Ht,
        propagateBreaks: function(e13) {
            const t9 = new Set, n8 = [];
            Gt(e13, function(e14) {
                if (("break-parent" === e14.type && Qt2(n8), "group" === e14.type)) {
                    if ((n8.push(e14), t9.has(e14))) return !1;
                    t9.add(e14);
                }
            }, function(e14) {
                if ("group" === e14.type) {
                    n8.pop().break && Qt2(n8);
                }
            }, !0);
        },
        removeLines: function(e13) {
            return Ht(e13, Zt);
        },
        stripTrailingHardline: function e13(t9, n8 = !1) {
            if ("concat" === t9.type && 0 !== t9.parts.length) {
                const r6 = n8 ? function(e14) {
                    let t10, { parts: n9  } = e14;
                    for(let r7 = e14.parts.length; r7 > 0 && !t10; r7--)t10 = n9[r7 - 1];
                    return "group" === t10.type && (n9 = t10.contents.parts), n9;
                }(t9) : t9.parts, o5 = r6[r6.length - 1];
                if ("concat" === o5.type) return 2 === o5.parts.length && o5.parts[0].hard && "break-parent" === o5.parts[1].type ? {
                    type: "concat",
                    parts: r6.slice(0, -1)
                } : {
                    type: "concat",
                    parts: t9.parts.slice(0, -1).concat(e13(o5))
                };
            }
            return t9;
        },
        normalizeParts: en,
        normalizeDoc: function(e14) {
            return Ht(e14, (e15)=>e15.parts ? Object.assign({
                }, e15, {
                    parts: en(e15.parts)
                }) : e15
            );
        },
        replaceNewlinesWithLiterallines: function(e14) {
            return Ht(e14, (e15)=>"string" == typeof e15 && e15.includes("\n") ? Jt(e15.split(/(\n)/g).map((e16, t9)=>t9 % 2 == 0 ? e16 : Ut
                )) : e15
            );
        }
    },
    debug: {
        printDocToDebug: (e13)=>nn(tn(e13))
    }
};
var pn1 = {
    resolve: function() {
        for(var e13, t9 = "", n8 = !1, r6 = arguments.length - 1; r6 >= -1 && !n8; r6--){
            var o5;
            r6 >= 0 ? o5 = arguments[r6] : ((void 0) === e13 && (e13 = Oe2.cwd()), o5 = e13), ln(o5), 0 !== o5.length && (t9 = o5 + "/" + t9, n8 = 47 === o5.charCodeAt(0));
        }
        return (t9 = cn(t9, !n8), n8 ? t9.length > 0 ? "/" + t9 : "/" : t9.length > 0 ? t9 : ".");
    },
    normalize: function(e13) {
        if ((ln(e13), 0 === e13.length)) return ".";
        var t9 = 47 === e13.charCodeAt(0), n8 = 47 === e13.charCodeAt(e13.length - 1);
        return (0 !== (e13 = cn(e13, !t9)).length || t9 || (e13 = "."), e13.length > 0 && n8 && (e13 += "/"), t9 ? "/" + e13 : e13);
    },
    isAbsolute: function(e13) {
        return (ln(e13), e13.length > 0 && 47 === e13.charCodeAt(0));
    },
    join: function() {
        if (0 === arguments.length) return ".";
        for(var e13, t9 = 0; t9 < arguments.length; ++t9){
            var n8 = arguments[t9];
            ln(n8), n8.length > 0 && ((void 0) === e13 ? e13 = n8 : e13 += "/" + n8);
        }
        return (void 0) === e13 ? "." : pn1.normalize(e13);
    },
    relative: function(e13, t9) {
        if ((ln(e13), ln(t9), e13 === t9)) return "";
        if ((e13 = pn1.resolve(e13)) === (t9 = pn1.resolve(t9))) return "";
        for(var n8 = 1; n8 < e13.length && 47 === e13.charCodeAt(n8); ++n8);
        for(var r6 = e13.length, o5 = r6 - n8, u4 = 1; u4 < t9.length && 47 === t9.charCodeAt(u4); ++u4);
        for(var i6 = t9.length - u4, a5 = o5 < i6 ? o5 : i6, s4 = -1, l5 = 0; l5 <= a5; ++l5){
            if (l5 === a5) {
                if (i6 > a5) {
                    if (47 === t9.charCodeAt(u4 + l5)) return t9.slice(u4 + l5 + 1);
                    if (0 === l5) return t9.slice(u4 + l5);
                } else o5 > a5 && (47 === e13.charCodeAt(n8 + l5) ? s4 = l5 : 0 === l5 && (s4 = 0));
                break;
            }
            var c6 = e13.charCodeAt(n8 + l5);
            if (c6 !== t9.charCodeAt(u4 + l5)) break;
            47 === c6 && (s4 = l5);
        }
        var p6 = "";
        for(l5 = n8 + s4 + 1; l5 <= r6; ++l5)l5 !== r6 && 47 !== e13.charCodeAt(l5) || (0 === p6.length ? p6 += ".." : p6 += "/..");
        return p6.length > 0 ? p6 + t9.slice(u4 + s4) : (u4 += s4, 47 === t9.charCodeAt(u4) && ++u4, t9.slice(u4));
    },
    _makeLong: function(e13) {
        return e13;
    },
    dirname: function(e13) {
        if ((ln(e13), 0 === e13.length)) return ".";
        for(var t9 = e13.charCodeAt(0), n8 = 47 === t9, r6 = -1, o5 = !0, u4 = e13.length - 1; u4 >= 1; --u4)if (47 === (t9 = e13.charCodeAt(u4))) {
            if (!o5) {
                r6 = u4;
                break;
            }
        } else o5 = !1;
        return -1 === r6 ? n8 ? "/" : "." : n8 && 1 === r6 ? "//" : e13.slice(0, r6);
    },
    basename: function(e13, t9) {
        if ((void 0) !== t9 && "string" != typeof t9) throw new TypeError('"ext" argument must be a string');
        ln(e13);
        var n8, r6 = 0, o5 = -1, u4 = !0;
        if ((void 0) !== t9 && t9.length > 0 && t9.length <= e13.length) {
            if (t9.length === e13.length && t9 === e13) return "";
            var i6 = t9.length - 1, a5 = -1;
            for(n8 = e13.length - 1; n8 >= 0; --n8){
                var s4 = e13.charCodeAt(n8);
                if (47 === s4) {
                    if (!u4) {
                        r6 = n8 + 1;
                        break;
                    }
                } else -1 === a5 && (u4 = !1, a5 = n8 + 1), i6 >= 0 && (s4 === t9.charCodeAt(i6) ? -1 == --i6 && (o5 = n8) : (i6 = -1, o5 = a5));
            }
            return (r6 === o5 ? o5 = a5 : -1 === o5 && (o5 = e13.length), e13.slice(r6, o5));
        }
        for(n8 = e13.length - 1; n8 >= 0; --n8)if (47 === e13.charCodeAt(n8)) {
            if (!u4) {
                r6 = n8 + 1;
                break;
            }
        } else -1 === o5 && (u4 = !1, o5 = n8 + 1);
        return -1 === o5 ? "" : e13.slice(r6, o5);
    },
    extname: function(e13) {
        ln(e13);
        for(var t9 = -1, n8 = 0, r6 = -1, o5 = !0, u4 = 0, i6 = e13.length - 1; i6 >= 0; --i6){
            var a5 = e13.charCodeAt(i6);
            if (47 !== a5) -1 === r6 && (o5 = !1, r6 = i6 + 1), 46 === a5 ? -1 === t9 ? t9 = i6 : 1 !== u4 && (u4 = 1) : -1 !== t9 && (u4 = -1);
            else if (!o5) {
                n8 = i6 + 1;
                break;
            }
        }
        return -1 === t9 || -1 === r6 || 0 === u4 || 1 === u4 && t9 === r6 - 1 && t9 === n8 + 1 ? "" : e13.slice(t9, r6);
    },
    format: function(e13) {
        if (null === e13 || "object" != typeof e13) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e13);
        return function(e14, t9) {
            var n8 = t9.dir || t9.root, r6 = t9.base || (t9.name || "") + (t9.ext || "");
            return n8 ? n8 === t9.root ? n8 + r6 : n8 + e14 + r6 : r6;
        }("/", e13);
    },
    parse: function(e13) {
        ln(e13);
        var t9 = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (0 === e13.length) return t9;
        var n8, r6 = e13.charCodeAt(0), o5 = 47 === r6;
        o5 ? (t9.root = "/", n8 = 1) : n8 = 0;
        for(var u4 = -1, i6 = 0, a5 = -1, s4 = !0, l5 = e13.length - 1, c6 = 0; l5 >= n8; --l5)if (47 !== (r6 = e13.charCodeAt(l5))) -1 === a5 && (s4 = !1, a5 = l5 + 1), 46 === r6 ? -1 === u4 ? u4 = l5 : 1 !== c6 && (c6 = 1) : -1 !== u4 && (c6 = -1);
        else if (!s4) {
            i6 = l5 + 1;
            break;
        }
        return (-1 === u4 || -1 === a5 || 0 === c6 || 1 === c6 && u4 === a5 - 1 && u4 === i6 + 1 ? -1 !== a5 && (t9.base = t9.name = 0 === i6 && o5 ? e13.slice(1, a5) : e13.slice(i6, a5)) : (0 === i6 && o5 ? (t9.name = e13.slice(1, u4), t9.base = e13.slice(1, a5)) : (t9.name = e13.slice(i6, u4), t9.base = e13.slice(i6, a5)), t9.ext = e13.slice(u4, a5)), i6 > 0 ? t9.dir = e13.slice(0, i6 - 1) : o5 && (t9.dir = "/"), t9);
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
pn1.posix = pn1;
var dn1 = pn1, fn1 = Object.freeze(Object.assign(Object.create(null), dn1, {
    default: dn1,
    __moduleExports: dn1
})), hn1 = [], mn1 = [], gn1 = "undefined" != typeof Uint8Array ? Uint8Array : Array, Dn1 = !1;
function yn1() {
    Dn1 = !0;
    for(var e13 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t9 = 0, n8 = e13.length; t9 < n8; ++t9)hn1[t9] = e13[t9], mn1[e13.charCodeAt(t9)] = t9;
    mn1["-".charCodeAt(0)] = 62, mn1["_".charCodeAt(0)] = 63;
}
function En1(e13, t9, n8) {
    for(var r6, o5, u4 = [], i6 = t9; i6 < n8; i6 += 3)r6 = (e13[i6] << 16) + (e13[i6 + 1] << 8) + e13[i6 + 2], u4.push(hn1[(o5 = r6) >> 18 & 63] + hn1[o5 >> 12 & 63] + hn1[o5 >> 6 & 63] + hn1[63 & o5]);
    return u4.join("");
}
function Cn1(e13) {
    var t9;
    Dn1 || yn1();
    for(var n8 = e13.length, r6 = n8 % 3, o5 = "", u4 = [], i6 = 16383, a5 = 0, s4 = n8 - r6; a5 < s4; a5 += i6)u4.push(En1(e13, a5, a5 + i6 > s4 ? s4 : a5 + i6));
    return 1 === r6 ? (t9 = e13[n8 - 1], o5 += hn1[t9 >> 2], o5 += hn1[t9 << 4 & 63], o5 += "==") : 2 === r6 && (t9 = (e13[n8 - 2] << 8) + e13[n8 - 1], o5 += hn1[t9 >> 10], o5 += hn1[t9 >> 4 & 63], o5 += hn1[t9 << 2 & 63], o5 += "="), u4.push(o5), u4.join("");
}
function xn() {
    return wn.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Sn(e13, t9) {
    if (xn() < t9) throw new RangeError("Invalid typed array length");
    return wn.TYPED_ARRAY_SUPPORT ? (e13 = new Uint8Array(t9)).__proto__ = wn.prototype : (null === e13 && (e13 = new wn(t9)), e13.length = t9), e13;
}
function wn(e13, t9, n8) {
    if (!(wn.TYPED_ARRAY_SUPPORT || this instanceof wn)) return new wn(e13, t9, n8);
    if ("number" == typeof e13) {
        if ("string" == typeof t9) throw new Error("If encoding is specified then the first argument must be a string");
        return Nn(this, e13);
    }
    return Tn2(this, e13, t9, n8);
}
function Tn2(e13, t9, n8, r6) {
    if ("number" == typeof t9) throw new TypeError('"value" argument must not be a number');
    return "undefined" != typeof ArrayBuffer && t9 instanceof ArrayBuffer ? (function(e14, t10, n9, r7) {
        if (t10.byteLength, n9 < 0 || t10.byteLength < n9) throw new RangeError("'offset' is out of bounds");
        if (t10.byteLength < n9 + (r7 || 0)) throw new RangeError("'length' is out of bounds");
        t10 = (void 0) === n9 && (void 0) === r7 ? new Uint8Array(t10) : (void 0) === r7 ? new Uint8Array(t10, n9) : new Uint8Array(t10, n9, r7);
        wn.TYPED_ARRAY_SUPPORT ? (e14 = t10).__proto__ = wn.prototype : e14 = kn(e14, t10);
        return e14;
    })(e13, t9, n8, r6) : "string" == typeof t9 ? (function(e14, t10, n9) {
        "string" == typeof n9 && "" !== n9 || (n9 = "utf8");
        if (!wn.isEncoding(n9)) throw new TypeError('"encoding" must be a valid string encoding');
        var r7 = 0 | In(t10, n9), o5 = (e14 = Sn(e14, r7)).write(t10, n9);
        o5 !== r7 && (e14 = e14.slice(0, o5));
        return e14;
    })(e13, t9, n8) : (function(e14, t10) {
        if (On(t10)) {
            var n9 = 0 | Pn(t10.length);
            return 0 === (e14 = Sn(e14, n9)).length || t10.copy(e14, 0, 0, n9), e14;
        }
        if (t10) {
            if ("undefined" != typeof ArrayBuffer && t10.buffer instanceof ArrayBuffer || "length" in t10) return "number" != typeof t10.length || (r7 = t10.length) != r7 ? Sn(e14, 0) : kn(e14, t10);
            if ("Buffer" === t10.type && Fn(t10.data)) return kn(e14, t10.data);
        }
        var r7;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    })(e13, t9);
}
function Nn(e13, t9) {
    if (Bn(t9), e13 = Sn(e13, t9 < 0 ? 0 : 0 | Pn(t9)), !wn.TYPED_ARRAY_SUPPORT) for(var n8 = 0; n8 < t9; ++n8)e13[n8] = 0;
    return e13;
}
function kn(e13, t9) {
    var n8 = t9.length < 0 ? 0 : 0 | Pn(t9.length);
    e13 = Sn(e13, n8);
    for(var r6 = 0; r6 < n8; r6 += 1)e13[r6] = 255 & t9[r6];
    return e13;
}
function Pn(e13) {
    if (e13 >= xn()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + xn().toString(16) + " bytes");
    return 0 | e13;
}
function In(e13, t9) {
    if (On(e13)) return e13.length;
    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e13) || e13 instanceof ArrayBuffer)) return e13.byteLength;
    "string" != typeof e13 && (e13 = "" + e13);
    var n8 = e13.length;
    if (0 === n8) return 0;
    for(var r6 = !1;;)switch(t9){
        case "ascii":
        case "latin1":
        case "binary":
            return n8;
        case "utf8":
        case "utf-8":
        case void 0:
            return ir(e13).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return 2 * n8;
        case "hex":
            return n8 >>> 1;
        case "base64":
            return ar(e13).length;
        default:
            if (r6) return ir(e13).length;
            t9 = ("" + t9).toLowerCase(), r6 = !0;
    }
}
function Ln(e13, t9, n8) {
    var r6 = !1;
    if (((void 0) === t9 || t9 < 0) && (t9 = 0), t9 > this.length) return "";
    if (((void 0) === n8 || n8 > this.length) && (n8 = this.length), n8 <= 0) return "";
    if ((n8 >>>= 0) <= (t9 >>>= 0)) return "";
    for(e13 || (e13 = "utf8");;)switch(e13){
        case "hex":
            return Xn(this, t9, n8);
        case "utf8":
        case "utf-8":
            return zn(this, t9, n8);
        case "ascii":
            return Gn(this, t9, n8);
        case "latin1":
        case "binary":
            return Hn(this, t9, n8);
        case "base64":
            return Jn(this, t9, n8);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return Yn(this, t9, n8);
        default:
            if (r6) throw new TypeError("Unknown encoding: " + e13);
            e13 = (e13 + "").toLowerCase(), r6 = !0;
    }
}
function jn(e13, t9, n8, r6, o5) {
    if (0 === e13.length) return -1;
    if ("string" == typeof n8 ? (r6 = n8, n8 = 0) : n8 > 2147483647 ? n8 = 2147483647 : n8 < -2147483648 && (n8 = -2147483648), n8 = +n8, isNaN(n8) && (n8 = o5 ? 0 : e13.length - 1), n8 < 0 && (n8 = e13.length + n8), n8 >= e13.length) {
        if (o5) return -1;
        n8 = e13.length - 1;
    } else if (n8 < 0) {
        if (!o5) return -1;
        n8 = 0;
    }
    if ("string" == typeof t9 && (t9 = wn.from(t9, r6)), On(t9)) return 0 === t9.length ? -1 : _n(e13, t9, n8, r6, o5);
    if ("number" == typeof t9) return t9 &= 255, wn.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o5 ? Uint8Array.prototype.indexOf.call(e13, t9, n8) : Uint8Array.prototype.lastIndexOf.call(e13, t9, n8) : _n(e13, [
        t9
    ], n8, r6, o5);
    throw new TypeError("val must be string, number or Buffer");
}
function Wn(e13, t9, n8, r6) {
    return sr(ar(t9), e13, n8, r6);
}
function Jn(e13, t9, n8) {
    return 0 === t9 && n8 === e13.length ? Cn1(e13) : Cn1(e13.slice(t9, n8));
}
wn.TYPED_ARRAY_SUPPORT = (void 0) === le.TYPED_ARRAY_SUPPORT || le.TYPED_ARRAY_SUPPORT, wn.poolSize = 8192, wn._augment = function(e13) {
    return e13.__proto__ = wn.prototype, e13;
}, wn.from = function(e13, t9, n8) {
    return Tn2(null, e13, t9, n8);
}, wn.TYPED_ARRAY_SUPPORT && (wn.prototype.__proto__ = Uint8Array.prototype, wn.__proto__ = Uint8Array), wn.alloc = function(e13, t9, n8) {
    return (function(e14, t10, n9, r6) {
        return Bn(t10), t10 <= 0 ? Sn(e14, t10) : (void 0) !== n9 ? "string" == typeof r6 ? Sn(e14, t10).fill(n9, r6) : Sn(e14, t10).fill(n9) : Sn(e14, t10);
    })(null, e13, t9, n8);
}, wn.allocUnsafe = function(e13) {
    return Nn(null, e13);
}, wn.allocUnsafeSlow = function(e13) {
    return Nn(null, e13);
}, wn.isBuffer = function(e13) {
    return null != e13 && (!!e13._isBuffer || lr(e13) || (function(e14) {
        return "function" == typeof e14.readFloatLE && "function" == typeof e14.slice && lr(e14.slice(0, 0));
    })(e13));
}, wn.compare = function(e13, t9) {
    if (!On(e13) || !On(t9)) throw new TypeError("Arguments must be Buffers");
    if (e13 === t9) return 0;
    for(var n8 = e13.length, r6 = t9.length, o5 = 0, u4 = Math.min(n8, r6); o5 < u4; ++o5)if (e13[o5] !== t9[o5]) {
        n8 = e13[o5], r6 = t9[o5];
        break;
    }
    return n8 < r6 ? -1 : r6 < n8 ? 1 : 0;
}, wn.isEncoding = function(e13) {
    switch(String(e13).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1;
    }
}, wn.concat = function(e13, t9) {
    if (!Fn(e13)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e13.length) return wn.alloc(0);
    var n8;
    if ((void 0) === t9) for(t9 = 0, n8 = 0; n8 < e13.length; ++n8)t9 += e13[n8].length;
    var r6 = wn.allocUnsafe(t9), o5 = 0;
    for(n8 = 0; n8 < e13.length; ++n8){
        var u4 = e13[n8];
        if (!On(u4)) throw new TypeError('"list" argument must be an Array of Buffers');
        u4.copy(r6, o5), o5 += u4.length;
    }
    return r6;
}, wn.byteLength = In, wn.prototype._isBuffer = !0, wn.prototype.swap16 = function() {
    var e13 = this.length;
    if (e13 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var t9 = 0; t9 < e13; t9 += 2)Mn(this, t9, t9 + 1);
    return this;
}, wn.prototype.swap32 = function() {
    var e13 = this.length;
    if (e13 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var t9 = 0; t9 < e13; t9 += 4)Mn(this, t9, t9 + 3), Mn(this, t9 + 1, t9 + 2);
    return this;
}, wn.prototype.swap64 = function() {
    var e13 = this.length;
    if (e13 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var t9 = 0; t9 < e13; t9 += 8)Mn(this, t9, t9 + 7), Mn(this, t9 + 1, t9 + 6), Mn(this, t9 + 2, t9 + 5), Mn(this, t9 + 3, t9 + 4);
    return this;
}, wn.prototype.toString = function() {
    var e13 = 0 | this.length;
    return 0 === e13 ? "" : 0 === arguments.length ? zn(this, 0, e13) : Ln.apply(this, arguments);
}, wn.prototype.equals = function(e13) {
    if (!On(e13)) throw new TypeError("Argument must be a Buffer");
    return this === e13 || 0 === wn.compare(this, e13);
}, wn.prototype.inspect = function() {
    var e13 = "";
    return this.length > 0 && (e13 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e13 += " ... ")), "<Buffer " + e13 + ">";
}, wn.prototype.compare = function(e13, t9, n8, r6, o5) {
    if (!On(e13)) throw new TypeError("Argument must be a Buffer");
    if ((void 0) === t9 && (t9 = 0), (void 0) === n8 && (n8 = e13 ? e13.length : 0), (void 0) === r6 && (r6 = 0), (void 0) === o5 && (o5 = this.length), t9 < 0 || n8 > e13.length || r6 < 0 || o5 > this.length) throw new RangeError("out of range index");
    if (r6 >= o5 && t9 >= n8) return 0;
    if (r6 >= o5) return -1;
    if (t9 >= n8) return 1;
    if (this === e13) return 0;
    for(var u4 = (o5 >>>= 0) - (r6 >>>= 0), i6 = (n8 >>>= 0) - (t9 >>>= 0), a5 = Math.min(u4, i6), s4 = this.slice(r6, o5), l5 = e13.slice(t9, n8), c6 = 0; c6 < a5; ++c6)if (s4[c6] !== l5[c6]) {
        u4 = s4[c6], i6 = l5[c6];
        break;
    }
    return u4 < i6 ? -1 : i6 < u4 ? 1 : 0;
}, wn.prototype.includes = function(e13, t9, n8) {
    return -1 !== this.indexOf(e13, t9, n8);
}, wn.prototype.indexOf = function(e13, t9, n8) {
    return jn(this, e13, t9, n8, !0);
}, wn.prototype.lastIndexOf = function(e13, t9, n8) {
    return jn(this, e13, t9, n8, !1);
}, wn.prototype.write = function(e13, t9, n8, r6) {
    if ((void 0) === t9) r6 = "utf8", n8 = this.length, t9 = 0;
    else if ((void 0) === n8 && "string" == typeof t9) r6 = t9, n8 = this.length, t9 = 0;
    else {
        if (!isFinite(t9)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t9 |= 0, isFinite(n8) ? (n8 |= 0, (void 0) === r6 && (r6 = "utf8")) : (r6 = n8, n8 = void 0);
    }
    var o5 = this.length - t9;
    if (((void 0) === n8 || n8 > o5) && (n8 = o5), e13.length > 0 && (n8 < 0 || t9 < 0) || t9 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    r6 || (r6 = "utf8");
    for(var u4 = !1;;)switch(r6){
        case "hex":
            return Rn(this, e13, t9, n8);
        case "utf8":
        case "utf-8":
            return Vn(this, e13, t9, n8);
        case "ascii":
            return $n(this, e13, t9, n8);
        case "latin1":
        case "binary":
            return qn(this, e13, t9, n8);
        case "base64":
            return Wn(this, e13, t9, n8);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return Un(this, e13, t9, n8);
        default:
            if (u4) throw new TypeError("Unknown encoding: " + r6);
            r6 = ("" + r6).toLowerCase(), u4 = !0;
    }
}, wn.prototype.toJSON = function() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
wn.prototype.slice = function(e13, t9) {
    var n8, r6 = this.length;
    if ((e13 = ~~e13) < 0 ? (e13 += r6) < 0 && (e13 = 0) : e13 > r6 && (e13 = r6), (t9 = (void 0) === t9 ? r6 : ~~t9) < 0 ? (t9 += r6) < 0 && (t9 = 0) : t9 > r6 && (t9 = r6), t9 < e13 && (t9 = e13), wn.TYPED_ARRAY_SUPPORT) (n8 = this.subarray(e13, t9)).__proto__ = wn.prototype;
    else {
        var o5 = t9 - e13;
        n8 = new wn(o5, void 0);
        for(var u4 = 0; u4 < o5; ++u4)n8[u4] = this[u4 + e13];
    }
    return n8;
}, wn.prototype.readUIntLE = function(e13, t9, n8) {
    e13 |= 0, t9 |= 0, n8 || Kn(e13, t9, this.length);
    for(var r6 = this[e13], o5 = 1, u4 = 0; (++u4) < t9 && (o5 *= 256);)r6 += this[e13 + u4] * o5;
    return r6;
}, wn.prototype.readUIntBE = function(e13, t9, n8) {
    e13 |= 0, t9 |= 0, n8 || Kn(e13, t9, this.length);
    for(var r6 = this[e13 + --t9], o5 = 1; t9 > 0 && (o5 *= 256);)r6 += this[e13 + --t9] * o5;
    return r6;
}, wn.prototype.readUInt8 = function(e13, t9) {
    return t9 || Kn(e13, 1, this.length), this[e13];
}, wn.prototype.readUInt16LE = function(e13, t9) {
    return t9 || Kn(e13, 2, this.length), this[e13] | this[e13 + 1] << 8;
}, wn.prototype.readUInt16BE = function(e13, t9) {
    return t9 || Kn(e13, 2, this.length), this[e13] << 8 | this[e13 + 1];
}, wn.prototype.readUInt32LE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), (this[e13] | this[e13 + 1] << 8 | this[e13 + 2] << 16) + 16777216 * this[e13 + 3];
}, wn.prototype.readUInt32BE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), 16777216 * this[e13] + (this[e13 + 1] << 16 | this[e13 + 2] << 8 | this[e13 + 3]);
}, wn.prototype.readIntLE = function(e13, t9, n8) {
    e13 |= 0, t9 |= 0, n8 || Kn(e13, t9, this.length);
    for(var r6 = this[e13], o5 = 1, u4 = 0; (++u4) < t9 && (o5 *= 256);)r6 += this[e13 + u4] * o5;
    return r6 >= (o5 *= 128) && (r6 -= Math.pow(2, 8 * t9)), r6;
}, wn.prototype.readIntBE = function(e13, t9, n8) {
    e13 |= 0, t9 |= 0, n8 || Kn(e13, t9, this.length);
    for(var r6 = t9, o5 = 1, u4 = this[e13 + --r6]; r6 > 0 && (o5 *= 256);)u4 += this[e13 + --r6] * o5;
    return u4 >= (o5 *= 128) && (u4 -= Math.pow(2, 8 * t9)), u4;
}, wn.prototype.readInt8 = function(e13, t9) {
    return t9 || Kn(e13, 1, this.length), 128 & this[e13] ? -1 * (255 - this[e13] + 1) : this[e13];
}, wn.prototype.readInt16LE = function(e13, t9) {
    t9 || Kn(e13, 2, this.length);
    var n8 = this[e13] | this[e13 + 1] << 8;
    return 32768 & n8 ? 4294901760 | n8 : n8;
}, wn.prototype.readInt16BE = function(e13, t9) {
    t9 || Kn(e13, 2, this.length);
    var n8 = this[e13 + 1] | this[e13] << 8;
    return 32768 & n8 ? 4294901760 | n8 : n8;
}, wn.prototype.readInt32LE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), this[e13] | this[e13 + 1] << 8 | this[e13 + 2] << 16 | this[e13 + 3] << 24;
}, wn.prototype.readInt32BE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), this[e13] << 24 | this[e13 + 1] << 16 | this[e13 + 2] << 8 | this[e13 + 3];
}, wn.prototype.readFloatLE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), bn(this, e13, !0, 23, 4);
}, wn.prototype.readFloatBE = function(e13, t9) {
    return t9 || Kn(e13, 4, this.length), bn(this, e13, !1, 23, 4);
}, wn.prototype.readDoubleLE = function(e13, t9) {
    return t9 || Kn(e13, 8, this.length), bn(this, e13, !0, 52, 8);
}, wn.prototype.readDoubleBE = function(e13, t9) {
    return t9 || Kn(e13, 8, this.length), bn(this, e13, !1, 52, 8);
}, wn.prototype.writeUIntLE = function(e13, t9, n8, r6) {
    (e13 = +e13, t9 |= 0, n8 |= 0, r6) || Qn(this, e13, t9, n8, Math.pow(2, 8 * n8) - 1, 0);
    var o5 = 1, u4 = 0;
    for(this[t9] = 255 & e13; (++u4) < n8 && (o5 *= 256);)this[t9 + u4] = e13 / o5 & 255;
    return t9 + n8;
}, wn.prototype.writeUIntBE = function(e13, t9, n8, r6) {
    (e13 = +e13, t9 |= 0, n8 |= 0, r6) || Qn(this, e13, t9, n8, Math.pow(2, 8 * n8) - 1, 0);
    var o5 = n8 - 1, u4 = 1;
    for(this[t9 + o5] = 255 & e13; (--o5) >= 0 && (u4 *= 256);)this[t9 + o5] = e13 / u4 & 255;
    return t9 + n8;
}, wn.prototype.writeUInt8 = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 1, 255, 0), wn.TYPED_ARRAY_SUPPORT || (e13 = Math.floor(e13)), this[t9] = 255 & e13, t9 + 1;
}, wn.prototype.writeUInt16LE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 2, 65535, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = 255 & e13, this[t9 + 1] = e13 >>> 8) : Zn(this, e13, t9, !0), t9 + 2;
}, wn.prototype.writeUInt16BE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 2, 65535, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = e13 >>> 8, this[t9 + 1] = 255 & e13) : Zn(this, e13, t9, !1), t9 + 2;
}, wn.prototype.writeUInt32LE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 4, 4294967295, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t9 + 3] = e13 >>> 24, this[t9 + 2] = e13 >>> 16, this[t9 + 1] = e13 >>> 8, this[t9] = 255 & e13) : er(this, e13, t9, !0), t9 + 4;
}, wn.prototype.writeUInt32BE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 4, 4294967295, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = e13 >>> 24, this[t9 + 1] = e13 >>> 16, this[t9 + 2] = e13 >>> 8, this[t9 + 3] = 255 & e13) : er(this, e13, t9, !1), t9 + 4;
}, wn.prototype.writeIntLE = function(e13, t9, n8, r6) {
    if (e13 = +e13, t9 |= 0, !r6) {
        var o5 = Math.pow(2, 8 * n8 - 1);
        Qn(this, e13, t9, n8, o5 - 1, -o5);
    }
    var u4 = 0, i6 = 1, a5 = 0;
    for(this[t9] = 255 & e13; (++u4) < n8 && (i6 *= 256);)e13 < 0 && 0 === a5 && 0 !== this[t9 + u4 - 1] && (a5 = 1), this[t9 + u4] = (e13 / i6 >> 0) - a5 & 255;
    return t9 + n8;
}, wn.prototype.writeIntBE = function(e13, t9, n8, r6) {
    if (e13 = +e13, t9 |= 0, !r6) {
        var o5 = Math.pow(2, 8 * n8 - 1);
        Qn(this, e13, t9, n8, o5 - 1, -o5);
    }
    var u4 = n8 - 1, i6 = 1, a5 = 0;
    for(this[t9 + u4] = 255 & e13; (--u4) >= 0 && (i6 *= 256);)e13 < 0 && 0 === a5 && 0 !== this[t9 + u4 + 1] && (a5 = 1), this[t9 + u4] = (e13 / i6 >> 0) - a5 & 255;
    return t9 + n8;
}, wn.prototype.writeInt8 = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 1, 127, -128), wn.TYPED_ARRAY_SUPPORT || (e13 = Math.floor(e13)), e13 < 0 && (e13 = 255 + e13 + 1), this[t9] = 255 & e13, t9 + 1;
}, wn.prototype.writeInt16LE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 2, 32767, -32768), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = 255 & e13, this[t9 + 1] = e13 >>> 8) : Zn(this, e13, t9, !0), t9 + 2;
}, wn.prototype.writeInt16BE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 2, 32767, -32768), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = e13 >>> 8, this[t9 + 1] = 255 & e13) : Zn(this, e13, t9, !1), t9 + 2;
}, wn.prototype.writeInt32LE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 4, 2147483647, -2147483648), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = 255 & e13, this[t9 + 1] = e13 >>> 8, this[t9 + 2] = e13 >>> 16, this[t9 + 3] = e13 >>> 24) : er(this, e13, t9, !0), t9 + 4;
}, wn.prototype.writeInt32BE = function(e13, t9, n8) {
    return e13 = +e13, t9 |= 0, n8 || Qn(this, e13, t9, 4, 2147483647, -2147483648), e13 < 0 && (e13 = 4294967295 + e13 + 1), wn.TYPED_ARRAY_SUPPORT ? (this[t9] = e13 >>> 24, this[t9 + 1] = e13 >>> 16, this[t9 + 2] = e13 >>> 8, this[t9 + 3] = 255 & e13) : er(this, e13, t9, !1), t9 + 4;
}, wn.prototype.writeFloatLE = function(e13, t9, n8) {
    return nr(this, e13, t9, !0, n8);
}, wn.prototype.writeFloatBE = function(e13, t9, n8) {
    return nr(this, e13, t9, !1, n8);
}, wn.prototype.writeDoubleLE = function(e13, t9, n8) {
    return rr(this, e13, t9, !0, n8);
}, wn.prototype.writeDoubleBE = function(e13, t9, n8) {
    return rr(this, e13, t9, !1, n8);
}, wn.prototype.copy = function(e13, t9, n8, r6) {
    if (n8 || (n8 = 0), r6 || 0 === r6 || (r6 = this.length), t9 >= e13.length && (t9 = e13.length), t9 || (t9 = 0), r6 > 0 && r6 < n8 && (r6 = n8), r6 === n8) return 0;
    if (0 === e13.length || 0 === this.length) return 0;
    if (t9 < 0) throw new RangeError("targetStart out of bounds");
    if (n8 < 0 || n8 >= this.length) throw new RangeError("sourceStart out of bounds");
    if (r6 < 0) throw new RangeError("sourceEnd out of bounds");
    r6 > this.length && (r6 = this.length), e13.length - t9 < r6 - n8 && (r6 = e13.length - t9 + n8);
    var o5, u4 = r6 - n8;
    if (this === e13 && n8 < t9 && t9 < r6) for(o5 = u4 - 1; o5 >= 0; --o5)e13[o5 + t9] = this[o5 + n8];
    else if (u4 < 1000 || !wn.TYPED_ARRAY_SUPPORT) for(o5 = 0; o5 < u4; ++o5)e13[o5 + t9] = this[o5 + n8];
    else Uint8Array.prototype.set.call(e13, this.subarray(n8, n8 + u4), t9);
    return u4;
}, wn.prototype.fill = function(e13, t9, n8, r6) {
    if ("string" == typeof e13) {
        if ("string" == typeof t9 ? (r6 = t9, t9 = 0, n8 = this.length) : "string" == typeof n8 && (r6 = n8, n8 = this.length), 1 === e13.length) {
            var o5 = e13.charCodeAt(0);
            o5 < 256 && (e13 = o5);
        }
        if ((void 0) !== r6 && "string" != typeof r6) throw new TypeError("encoding must be a string");
        if ("string" == typeof r6 && !wn.isEncoding(r6)) throw new TypeError("Unknown encoding: " + r6);
    } else "number" == typeof e13 && (e13 &= 255);
    if (t9 < 0 || this.length < t9 || this.length < n8) throw new RangeError("Out of range index");
    if (n8 <= t9) return this;
    var u4;
    if (t9 >>>= 0, n8 = (void 0) === n8 ? this.length : n8 >>> 0, e13 || (e13 = 0), "number" == typeof e13) for(u4 = t9; u4 < n8; ++u4)this[u4] = e13;
    else {
        var i6 = On(e13) ? e13 : ir(new wn(e13, r6).toString()), a5 = i6.length;
        for(u4 = 0; u4 < n8 - t9; ++u4)this[u4 + t9] = i6[u4 % a5];
    }
    return this;
};
function ar(e13) {
    return (function(e14) {
        var t9, n8, r6, o5, u4, i6;
        Dn1 || yn1();
        var a5 = e14.length;
        if (a5 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        u4 = "=" === e14[a5 - 2] ? 2 : "=" === e14[a5 - 1] ? 1 : 0, i6 = new gn1(3 * a5 / 4 - u4), r6 = u4 > 0 ? a5 - 4 : a5;
        var s4 = 0;
        for(t9 = 0, n8 = 0; t9 < r6; t9 += 4, n8 += 3)o5 = mn1[e14.charCodeAt(t9)] << 18 | mn1[e14.charCodeAt(t9 + 1)] << 12 | mn1[e14.charCodeAt(t9 + 2)] << 6 | mn1[e14.charCodeAt(t9 + 3)], i6[s4++] = o5 >> 16 & 255, i6[s4++] = o5 >> 8 & 255, i6[s4++] = 255 & o5;
        return 2 === u4 ? (o5 = mn1[e14.charCodeAt(t9)] << 2 | mn1[e14.charCodeAt(t9 + 1)] >> 4, i6[s4++] = 255 & o5) : 1 === u4 && (o5 = mn1[e14.charCodeAt(t9)] << 10 | mn1[e14.charCodeAt(t9 + 1)] << 4 | mn1[e14.charCodeAt(t9 + 2)] >> 2, i6[s4++] = o5 >> 8 & 255, i6[s4++] = 255 & o5), i6;
    })(function(e14) {
        if ((e14 = (function(e15) {
            return e15.trim ? e15.trim() : e15.replace(/^\s+|\s+$/g, "");
        })(e14).replace(or, "")).length < 2) return "";
        for(; e14.length % 4 != 0;)e14 += "=";
        return e14;
    }(e13));
}
var pr = class {
    constructor(e13, t9){
        (t9 = t9 || {
        }).readChunk || (t9.readChunk = 1024), t9.newLineCharacter ? t9.newLineCharacter = t9.newLineCharacter.charCodeAt(0) : t9.newLineCharacter = 10, this.fd = "number" == typeof e13 ? e13 : cr.openSync(e13, "r"), this.options = t9, this.newLineCharacter = t9.newLineCharacter, this.reset();
    }
    _searchInBuffer(e, t) {
        let n8 = -1;
        for(let r6 = 0; r6 <= e.length; r6++){
            if (e[r6] === t) {
                n8 = r6;
                break;
            }
        }
        return n8;
    }
    reset() {
        this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
    }
    close() {
        cr.closeSync(this.fd), this.fd = null;
    }
    _extractLines(e) {
        let t10;
        const n8 = [];
        let r6 = 0, o5 = 0;
        for(;;){
            let u4 = e[r6++];
            if (u4 === this.newLineCharacter) t10 = e.slice(o5, r6), n8.push(t10), o5 = r6;
            else if ((void 0) === u4) break;
        }
        let u4 = e.slice(o5, r6);
        return u4.length && n8.push(u4), n8;
    }
    _readChunk(e) {
        let t10, n8 = 0;
        const r6 = [];
        do {
            const e14 = new wn(this.options.readChunk);
            t10 = cr.readSync(this.fd, e14, 0, this.options.readChunk, this.fdPosition), n8 += t10, this.fdPosition = this.fdPosition + t10, r6.push(e14);
        }while (t10 && -1 === this._searchInBuffer(r6[r6.length - 1], this.options.newLineCharacter))
        let o5 = wn.concat(r6);
        return t10 < this.options.readChunk && (this.eofReached = !0, o5 = o5.slice(0, n8)), n8 && (this.linesCache = this._extractLines(o5), e && (this.linesCache[0] = wn.concat([
            e,
            this.linesCache[0]
        ]))), n8;
    }
    next() {
        if (!this.fd) return !1;
        let e14, t10 = !1;
        if (this.eofReached && 0 === this.linesCache.length) return t10;
        if (this.linesCache.length || (e14 = this._readChunk()), this.linesCache.length) {
            t10 = this.linesCache.shift();
            t10[t10.length - 1] !== this.newLineCharacter && (e14 = this._readChunk(t10), e14 && (t10 = this.linesCache.shift()));
        }
        return this.eofReached && 0 === this.linesCache.length && this.close(), t10 && t10[t10.length - 1] === this.newLineCharacter && (t10 = t10.slice(0, t10.length - 1)), t10;
    }
};
var Or = Pr, Ir = je(function(e14) {
    const t10 = (e15, t11)=>function() {
            const n8 = e15.apply(Or, arguments);
            return "\x1b[".concat(n8 + t11, "m");
        }
    , n8 = (e15, t11)=>function() {
            const n9 = e15.apply(Or, arguments);
            return "\x1b[".concat(38 + t11, ";5;").concat(n9, "m");
        }
    , r6 = (e15, t11)=>function() {
            const n9 = e15.apply(Or, arguments);
            return "\x1b[".concat(38 + t11, ";2;").concat(n9[0], ";").concat(n9[1], ";").concat(n9[2], "m");
        }
    ;
    Object.defineProperty(e14, "exports", {
        enumerable: !0,
        get: function() {
            const e15 = new Map, o5 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    gray: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            o5.color.grey = o5.color.gray;
            for (const t11 of Object.keys(o5)){
                const n9 = o5[t11];
                for (const t12 of Object.keys(n9)){
                    const r7 = n9[t12];
                    o5[t12] = {
                        open: "\x1b[".concat(r7[0], "m"),
                        close: "\x1b[".concat(r7[1], "m")
                    }, n9[t12] = o5[t12], e15.set(r7[0], r7[1]);
                }
                Object.defineProperty(o5, t11, {
                    value: n9,
                    enumerable: !1
                }), Object.defineProperty(o5, "codes", {
                    value: e15,
                    enumerable: !1
                });
            }
            const u4 = (e16)=>e16
            , i6 = (e16, t12, n9)=>[
                    e16,
                    t12,
                    n9
                ]
            ;
            o5.color.close = "\x1b[39m", o5.bgColor.close = "\x1b[49m", o5.color.ansi = {
                ansi: t10(u4, 0)
            }, o5.color.ansi256 = {
                ansi256: n8(u4, 0)
            }, o5.color.ansi16m = {
                rgb: r6(i6, 0)
            }, o5.bgColor.ansi = {
                ansi: t10(u4, 10)
            }, o5.bgColor.ansi256 = {
                ansi256: n8(u4, 10)
            }, o5.bgColor.ansi16m = {
                rgb: r6(i6, 10)
            };
            for (let e16 of Object.keys(Or)){
                if ("object" != typeof Or[e16]) continue;
                const u5 = Or[e16];
                "ansi16" === e16 && (e16 = "ansi"), "ansi16" in u5 && (o5.color.ansi[e16] = t10(u5.ansi16, 0), o5.bgColor.ansi[e16] = t10(u5.ansi16, 10)), "ansi256" in u5 && (o5.color.ansi256[e16] = n8(u5.ansi256, 0), o5.bgColor.ansi256[e16] = n8(u5.ansi256, 10)), "rgb" in u5 && (o5.color.ansi16m[e16] = r6(u5.rgb, 0), o5.bgColor.ansi16m[e16] = r6(u5.rgb, 10));
            }
            return o5;
        }
    });
}), Lr = (e14, t10)=>{
    t10 = t10 || Oe2.argv;
    const n8 = e14.startsWith("-") ? "" : 1 === e14.length ? "-" : "--", r6 = t10.indexOf(n8 + e14), o5 = t10.indexOf("--");
    return -1 !== r6 && (-1 === o5 || r6 < o5);
}, Mr = _e(Object.freeze({
    __proto__: null,
    default: {
        EOL: "\n",
        platform: ()=>"browser"
        ,
        cpus: ()=>[
                {
                    model: "Prettier"
                }
            ]
    }
}));
const jr = Oe2.env;
function Rr(e14) {
    return (function(e15) {
        return 0 !== e15 && {
            level: e15,
            hasBasic: !0,
            has256: e15 >= 2,
            has16m: e15 >= 3
        };
    })(function(e15) {
        if (!1 === _r) return 0;
        if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor")) return 3;
        if (Lr("color=256")) return 2;
        if (e15 && !e15.isTTY && !0 !== _r) return 0;
        const t10 = _r ? 1 : 0;
        if ("win32" === Oe2.platform) {
            const e16 = Mr.release().split(".");
            return Number(Oe2.versions.node.split(".")[0]) >= 8 && Number(e16[0]) >= 10 && Number(e16[2]) >= 10586 ? Number(e16[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in jr) return [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI"
        ].some((e16)=>e16 in jr
        ) || "codeship" === jr.CI_NAME ? 1 : t10;
        if ("TEAMCITY_VERSION" in jr) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(jr.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === jr.COLORTERM) return 3;
        if ("TERM_PROGRAM" in jr) {
            const e16 = parseInt((jr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch(jr.TERM_PROGRAM){
                case "iTerm.app":
                    return e16 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test(jr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(jr.TERM) || "COLORTERM" in jr ? 1 : (jr.TERM, t10);
    }(e14));
}
Lr("no-color") || Lr("no-colors") || Lr("color=false") ? _r = !1 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && (_r = !0), "FORCE_COLOR" in jr && (_r = 0 === jr.FORCE_COLOR.length || 0 !== parseInt(jr.FORCE_COLOR, 10));
var Vr = {
    supportsColor: Rr,
    stdout: Rr(Oe2.stdout),
    stderr: Rr(Oe2.stderr)
};
var Yr = (e14, t10)=>{
    const n8 = [], r6 = [];
    let o5 = [];
    if (t10.replace($r, (t11, u4, i6, a5, s4, l5)=>{
        if (u4) o5.push(zr(u4));
        else if (a5) {
            const t12 = o5.join("");
            o5 = [], r6.push(0 === n8.length ? t12 : Xr(e14, n8)(t12)), n8.push({
                inverse: i6,
                styles: Hr(a5)
            });
        } else if (s4) {
            if (0 === n8.length) throw new Error("Found extraneous } in Chalk template literal");
            r6.push(Xr(e14, n8)(o5.join(""))), o5 = [], n8.pop();
        } else o5.push(l5);
    }), r6.push(o5.join("")), n8.length > 0) {
        const e15 = "Chalk template literal is missing ".concat(n8.length, " closing bracket").concat(1 === n8.length ? "" : "s", " (`}`)");
        throw new Error(e15);
    }
    return r6.join("");
}, Kr = je(function(e14) {
    const t10 = Vr.stdout, n8 = "win32" === Oe2.platform && !(Oe2.env.TERM || "").toLowerCase().startsWith("xterm"), r6 = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
    ], o5 = new Set([
        "gray"
    ]), u4 = Object.create(null);
    function i6(e15, n9) {
        n9 = n9 || {
        };
        const r7 = t10 ? t10.level : 0;
        e15.level = (void 0) === n9.level ? r7 : n9.level, e15.enabled = "enabled" in n9 ? n9.enabled : e15.level > 0;
    }
    function a5(e15) {
        if (!this || !(this instanceof a5) || this.template) {
            const t11 = {
            };
            return (i6(t11, e15), t11.template = function() {
                const e16 = [].slice.call(arguments);
                return p6.apply(null, [
                    t11.template
                ].concat(e16));
            }, Object.setPrototypeOf(t11, a5.prototype), Object.setPrototypeOf(t11.template, t11), t11.template.constructor = a5, t11.template);
        }
        i6(this, e15);
    }
    n8 && (Ir.blue.open = "\x1b[94m");
    for (const e15 of Object.keys(Ir))Ir[e15].closeRe = new RegExp(Sr(Ir[e15].close), "g"), u4[e15] = {
        get () {
            const t11 = Ir[e15];
            return l5.call(this, this._styles ? this._styles.concat(t11) : [
                t11
            ], this._empty, e15);
        }
    };
    u4.visible = {
        get () {
            return l5.call(this, this._styles || [], !0, "visible");
        }
    }, Ir.color.closeRe = new RegExp(Sr(Ir.color.close), "g");
    for (const e16 of Object.keys(Ir.color.ansi))o5.has(e16) || (u4[e16] = {
        get () {
            const t11 = this.level;
            return function() {
                const n9 = Ir.color[r6[t11]][e16].apply(null, arguments), o6 = {
                    open: n9,
                    close: Ir.color.close,
                    closeRe: Ir.color.closeRe
                };
                return l5.call(this, this._styles ? this._styles.concat(o6) : [
                    o6
                ], this._empty, e16);
            };
        }
    });
    Ir.bgColor.closeRe = new RegExp(Sr(Ir.bgColor.close), "g");
    for (const e17 of Object.keys(Ir.bgColor.ansi)){
        if (o5.has(e17)) continue;
        u4["bg" + e17[0].toUpperCase() + e17.slice(1)] = {
            get () {
                const t11 = this.level;
                return function() {
                    const n9 = Ir.bgColor[r6[t11]][e17].apply(null, arguments), o6 = {
                        open: n9,
                        close: Ir.bgColor.close,
                        closeRe: Ir.bgColor.closeRe
                    };
                    return l5.call(this, this._styles ? this._styles.concat(o6) : [
                        o6
                    ], this._empty, e17);
                };
            }
        };
    }
    const s4 = Object.defineProperties(()=>{
    }, u4);
    function l5(e18, t11, n9) {
        const r7 = function() {
            return c6.apply(r7, arguments);
        };
        r7._styles = e18, r7._empty = t11;
        const o6 = this;
        return (Object.defineProperty(r7, "level", {
            enumerable: !0,
            get: ()=>o6.level
            ,
            set (e) {
                o6.level = e;
            }
        }), Object.defineProperty(r7, "enabled", {
            enumerable: !0,
            get: ()=>o6.enabled
            ,
            set (e) {
                o6.enabled = e;
            }
        }), r7.hasGrey = this.hasGrey || "gray" === n9 || "grey" === n9, r7.__proto__ = s4, r7);
    }
    function c6() {
        const e18 = arguments, t11 = e18.length;
        let r7 = String(arguments[0]);
        if (0 === t11) return "";
        if (t11 > 1) for(let n9 = 1; n9 < t11; n9++)r7 += " " + arguments[n9];
        if (!this.enabled || this.level <= 0 || !r7) return this._empty ? "" : r7;
        const o6 = Ir.dim.open;
        n8 && this.hasGrey && (Ir.dim.open = "");
        for (const e19 of this._styles.slice().reverse())r7 = e19.open + r7.replace(e19.closeRe, e19.open) + e19.close, r7 = r7.replace(/\r?\n/g, "".concat(e19.close, "$&").concat(e19.open));
        return (Ir.dim.open = o6, r7);
    }
    function p6(e18, t11) {
        if (!Array.isArray(t11)) return [].slice.call(arguments, 1).join(" ");
        const n9 = [].slice.call(arguments, 2), r7 = [
            t11.raw[0]
        ];
        for(let e19 = 1; e19 < t11.length; e19++)r7.push(String(n9[e19 - 1]).replace(/[{}\\]/g, "\\$&")), r7.push(String(t11.raw[e19]));
        return Yr(e18, r7.join(""));
    }
    Object.defineProperties(a5.prototype, u4), e14.exports = a5(), e14.exports.supportsColor = t10, e14.exports.default = e14.exports;
}), Qr = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.commonDeprecatedHandler = (e15, t11, { descriptor: n8  })=>{
        const r6 = [
            "".concat(Kr.default.yellow("string" == typeof e15 ? n8.key(e15) : n8.pair(e15)), " is deprecated")
        ];
        return t11 && r6.push("we now treat it as ".concat(Kr.default.blue("string" == typeof t11 ? n8.key(t11) : n8.pair(t11)))), r6.join("; ") + ".";
    };
}), Zr = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(Qr, t10);
}), eo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.commonInvalidHandler = (e15, t11, n8)=>[
            "Invalid ".concat(Kr.default.red(n8.descriptor.key(e15)), " value."),
            "Expected ".concat(Kr.default.blue(n8.schemas[e15].expected(n8)), ","),
            "but received ".concat(Kr.default.red(n8.descriptor.value(t11)), ".")
        ].join(" ")
    ;
}), to = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(eo, t10);
}), no = [], ro = [], oo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.levenUnknownHandler = (e15, t11, { descriptor: n8 , logger: r6 , schemas: o5  })=>{
        const u4 = [
            "Ignored unknown option ".concat(Kr.default.yellow(n8.pair({
                key: e15,
                value: t11
            })), ".")
        ], i6 = Object.keys(o5).sort().find((t12)=>(function(e16, t13) {
                if (e16 === t13) return 0;
                var n9 = e16;
                e16.length > t13.length && (e16 = t13, t13 = n9);
                var r7 = e16.length, o6 = t13.length;
                if (0 === r7) return o6;
                if (0 === o6) return r7;
                for(; r7 > 0 && e16.charCodeAt(~-r7) === t13.charCodeAt(~-o6);)r7--, o6--;
                if (0 === r7) return o6;
                for(var u5, i6, a5, s4, l5 = 0; l5 < r7 && e16.charCodeAt(l5) === t13.charCodeAt(l5);)l5++;
                if (o6 -= l5, 0 == (r7 -= l5)) return o6;
                for(var c6 = 0, p6 = 0; c6 < r7;)ro[l5 + c6] = e16.charCodeAt(l5 + c6), no[c6] = ++c6;
                for(; p6 < o6;)for(u5 = t13.charCodeAt(l5 + p6), a5 = p6++, i6 = p6, c6 = 0; c6 < r7; c6++)s4 = u5 === ro[l5 + c6] ? a5 : a5 + 1, a5 = no[c6], i6 = no[c6] = a5 > i6 ? s4 > i6 ? i6 + 1 : s4 : s4 > a5 ? a5 + 1 : s4;
                return i6;
            })(e15, t12) < 3
        );
        i6 && u4.push("Did you mean ".concat(Kr.default.blue(n8.key(i6)), "?")), r6.warn(u4.join(" "));
    };
}), uo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(oo, t10);
}), io = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(Zr, t10), vr.__exportStar(to, t10), vr.__exportStar(uo, t10);
}), ao = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    const n8 = [
        "default",
        "expected",
        "validate",
        "deprecated",
        "forward",
        "redirect",
        "overlap",
        "preprocess",
        "postprocess"
    ];
    function r6(e15, t11) {
        const r7 = new e15(t11), i6 = Object.create(r7);
        for (const e16 of n8)e16 in t11 && (i6[e16] = u4(t11[e16], r7, o5.prototype[e16].length));
        return i6;
    }
    t10.createSchema = r6;
    class o5 {
        constructor(e15){
            this.name = e15.name;
        }
        static create(e) {
            return r6(this, e);
        }
        default(e) {
        }
        expected(e) {
            return "nothing";
        }
        validate(e, t) {
            return !1;
        }
        deprecated(e, t) {
            return !1;
        }
        forward(e, t) {
        }
        redirect(e, t) {
        }
        overlap(e, t, n) {
            return e;
        }
        preprocess(e, t) {
            return e;
        }
        postprocess(e, t) {
            return e;
        }
    }
    function u4(e16, t11, n9) {
        return "function" == typeof e16 ? (...r7)=>e16(...r7.slice(0, n9 - 1), t11, ...r7.slice(n9 - 1))
         : ()=>e16
        ;
    }
    t10.Schema = o5;
}), so = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        constructor(e15){
            super(e15), this._sourceName = e15.sourceName;
        }
        expected(e) {
            return e.schemas[this._sourceName].expected(e);
        }
        validate(e, t) {
            return t.schemas[this._sourceName].validate(e, t);
        }
        redirect(e, t) {
            return this._sourceName;
        }
    }
    t10.AliasSchema = n8;
}), lo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        expected() {
            return "anything";
        }
        validate() {
            return !0;
        }
    }
    t10.AnySchema = n8;
}), co = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        constructor(e15){
            var { valueSchema: t11 , name: n9 = t11.name  } = e15, r6 = vr.__rest(e15, [
                "valueSchema",
                "name"
            ]);
            super(Object.assign({
            }, r6, {
                name: n9
            })), this._valueSchema = t11;
        }
        expected(e) {
            return "an array of ".concat(this._valueSchema.expected(e));
        }
        validate(e, t) {
            if (!Array.isArray(e)) return !1;
            const n10 = [];
            for (const r7 of e){
                const e16 = t.normalizeValidateResult(this._valueSchema.validate(r7, t), r7);
                !0 !== e16 && n10.push(e16.value);
            }
            return 0 === n10.length || {
                value: n10
            };
        }
        deprecated(e, t) {
            const n10 = [];
            for (const r7 of e){
                const e16 = t.normalizeDeprecatedResult(this._valueSchema.deprecated(r7, t), r7);
                !1 !== e16 && n10.push(...e16.map(({ value: e17  })=>({
                        value: [
                            e17
                        ]
                    })
                ));
            }
            return n10;
        }
        forward(e, t) {
            const n10 = [];
            for (const o5 of e){
                const e16 = t.normalizeForwardResult(this._valueSchema.forward(o5, t), o5);
                n10.push(...e16.map(r7));
            }
            return n10;
        }
        redirect(e, t) {
            const n10 = [], o5 = [];
            for (const u4 of e){
                const e16 = t.normalizeRedirectResult(this._valueSchema.redirect(u4, t), u4);
                "remain" in e16 && n10.push(e16.remain), o5.push(...e16.redirect.map(r7));
            }
            return 0 === n10.length ? {
                redirect: o5
            } : {
                redirect: o5,
                remain: n10
            };
        }
        overlap(e, t) {
            return e.concat(t);
        }
    }
    function r7({ from: e16 , to: t12  }) {
        return {
            from: [
                e16
            ],
            to: t12
        };
    }
    t10.ArraySchema = n8;
}), po = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        expected() {
            return "true or false";
        }
        validate(e) {
            return "boolean" == typeof e;
        }
    }
    t10.BooleanSchema = n8;
}), fo = je(function(e14, t10) {
    function n8(e15, t11) {
        return "string" == typeof e15 || "key" in e15 ? {
            from: t11,
            to: e15
        } : "from" in e15 ? {
            from: e15.from,
            to: e15.to
        } : {
            from: t11,
            to: e15.to
        };
    }
    function r6(e15, t11) {
        return (void 0) === e15 ? [] : Array.isArray(e15) ? e15.map((e16)=>n8(e16, t11)
        ) : [
            n8(e15, t11)
        ];
    }
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.recordFromArray = function(e15, t11) {
        const n9 = Object.create(null);
        for (const r7 of e15){
            const e16 = r7[t11];
            if (n9[e16]) throw new Error("Duplicate ".concat(t11, " ").concat(JSON.stringify(e16)));
            n9[e16] = r7;
        }
        return n9;
    }, t10.mapFromArray = function(e15, t11) {
        const n9 = new Map;
        for (const r7 of e15){
            const e16 = r7[t11];
            if (n9.has(e16)) throw new Error("Duplicate ".concat(t11, " ").concat(JSON.stringify(e16)));
            n9.set(e16, r7);
        }
        return n9;
    }, t10.createAutoChecklist = function() {
        const e15 = Object.create(null);
        return (t11)=>{
            const n9 = JSON.stringify(t11);
            return !!e15[n9] || (e15[n9] = !0, !1);
        };
    }, t10.partition = function(e15, t11) {
        const n9 = [], r7 = [];
        for (const o5 of e15)t11(o5) ? n9.push(o5) : r7.push(o5);
        return [
            n9,
            r7
        ];
    }, t10.isInt = function(e15) {
        return e15 === Math.floor(e15);
    }, t10.comparePrimitive = function(e15, t11) {
        if (e15 === t11) return 0;
        const n9 = typeof e15, r7 = typeof t11, o5 = [
            "undefined",
            "object",
            "boolean",
            "number",
            "string"
        ];
        return n9 !== r7 ? o5.indexOf(n9) - o5.indexOf(r7) : "string" !== n9 ? Number(e15) - Number(t11) : e15.localeCompare(t11);
    }, t10.normalizeDefaultResult = function(e15) {
        return (void 0) === e15 ? {
        } : e15;
    }, t10.normalizeValidateResult = function(e15, t11) {
        return !0 === e15 || (!1 === e15 ? {
            value: t11
        } : e15);
    }, t10.normalizeDeprecatedResult = function(e15, t11, n9 = !1) {
        return !1 !== e15 && (!0 === e15 ? !!n9 || [
            {
                value: t11
            }
        ] : "value" in e15 ? [
            e15
        ] : 0 !== e15.length && e15);
    }, t10.normalizeTransferResult = n8, t10.normalizeForwardResult = r6, t10.normalizeRedirectResult = function(e15, t11) {
        const n9 = r6("object" == typeof e15 && "redirect" in e15 ? e15.redirect : e15, t11);
        return 0 === n9.length ? {
            remain: t11,
            redirect: n9
        } : "object" == typeof e15 && "remain" in e15 ? {
            remain: e15.remain,
            redirect: n9
        } : {
            redirect: n9
        };
    };
}), ho = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        constructor(e15){
            super(e15), this._choices = fo.mapFromArray(e15.choices.map((e16)=>e16 && "object" == typeof e16 ? e16 : {
                    value: e16
                }
            ), "value");
        }
        expected({ descriptor: e  }) {
            const t11 = Array.from(this._choices.keys()).map((e16)=>this._choices.get(e16)
            ).filter((e16)=>!e16.deprecated
            ).map((e16)=>e16.value
            ).sort(fo.comparePrimitive).map(e.value), n9 = t11.slice(0, -2), r6 = t11.slice(-2);
            return n9.concat(r6.join(" or ")).join(", ");
        }
        validate(e) {
            return this._choices.has(e);
        }
        deprecated(e) {
            const t11 = this._choices.get(e);
            return !(!t11 || !t11.deprecated) && {
                value: e
            };
        }
        forward(e) {
            const t11 = this._choices.get(e);
            return t11 ? t11.forward : void 0;
        }
        redirect(e) {
            const t11 = this._choices.get(e);
            return t11 ? t11.redirect : void 0;
        }
    }
    t10.ChoiceSchema = n8;
}), mo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        expected() {
            return "a number";
        }
        validate(e, t) {
            return "number" == typeof e;
        }
    }
    t10.NumberSchema = n8;
}), go = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends mo.NumberSchema {
        expected() {
            return "an integer";
        }
        validate(e, t) {
            return !0 === t.normalizeValidateResult(super.validate(e, t), e) && fo.isInt(e);
        }
    }
    t10.IntegerSchema = n8;
}), Do = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    });
    class n8 extends ao.Schema {
        expected() {
            return "a string";
        }
        validate(e) {
            return "string" == typeof e;
        }
    }
    t10.StringSchema = n8;
}), yo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(so, t10), vr.__exportStar(lo, t10), vr.__exportStar(co, t10), vr.__exportStar(po, t10), vr.__exportStar(ho, t10), vr.__exportStar(go, t10), vr.__exportStar(mo, t10), vr.__exportStar(Do, t10);
}), Eo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.defaultDescriptor = Ar.apiDescriptor, t10.defaultUnknownHandler = oo.levenUnknownHandler, t10.defaultInvalidHandler = to.commonInvalidHandler, t10.defaultDeprecatedHandler = Qr.commonDeprecatedHandler;
}), Co = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), t10.normalize = (e15, t11, r6)=>new n8(t11, r6).normalize(e15)
    ;
    class n8 {
        constructor(e15, t11){
            const { logger: n9 = console , descriptor: r6 = Eo.defaultDescriptor , unknown: o5 = Eo.defaultUnknownHandler , invalid: u4 = Eo.defaultInvalidHandler , deprecated: i6 = Eo.defaultDeprecatedHandler  } = t11 || {
            };
            this._utils = {
                descriptor: r6,
                logger: n9 || {
                    warn: ()=>{
                    }
                },
                schemas: fo.recordFromArray(e15, "name"),
                normalizeDefaultResult: fo.normalizeDefaultResult,
                normalizeDeprecatedResult: fo.normalizeDeprecatedResult,
                normalizeForwardResult: fo.normalizeForwardResult,
                normalizeRedirectResult: fo.normalizeRedirectResult,
                normalizeValidateResult: fo.normalizeValidateResult
            }, this._unknownHandler = o5, this._invalidHandler = u4, this._deprecatedHandler = i6, this.cleanHistory();
        }
        cleanHistory() {
            this._hasDeprecationWarned = fo.createAutoChecklist();
        }
        normalize(e) {
            const t12 = {
            }, n10 = [
                e
            ], r7 = ()=>{
                for(; 0 !== n10.length;){
                    const e16 = n10.shift(), r8 = this._applyNormalization(e16, t12);
                    n10.push(...r8);
                }
            };
            r7();
            for (const e16 of Object.keys(this._utils.schemas)){
                const r8 = this._utils.schemas[e16];
                if (!(e16 in t12)) {
                    const t13 = fo.normalizeDefaultResult(r8.default(this._utils));
                    "value" in t13 && n10.push({
                        [e16]: t13.value
                    });
                }
            }
            r7();
            for (const e17 of Object.keys(this._utils.schemas)){
                const n11 = this._utils.schemas[e17];
                e17 in t12 && (t12[e17] = n11.postprocess(t12[e17], this._utils));
            }
            return t12;
        }
        _applyNormalization(e, t) {
            const n10 = [], [r7, o6] = fo.partition(Object.keys(e), (e16)=>e16 in this._utils.schemas
            );
            for (const o7 of r7){
                const r8 = this._utils.schemas[o7], u5 = r8.preprocess(e[o7], this._utils), i7 = fo.normalizeValidateResult(r8.validate(u5, this._utils), u5);
                if (!0 !== i7) {
                    const { value: e16  } = i7, t12 = this._invalidHandler(o7, e16, this._utils);
                    throw "string" == typeof t12 ? new Error(t12) : t12;
                }
                const a5 = ({ from: e16 , to: t12  })=>{
                    n10.push("string" == typeof t12 ? {
                        [t12]: e16
                    } : {
                        [t12.key]: t12.value
                    });
                }, s4 = ({ value: e16 , redirectTo: t12  })=>{
                    const n11 = fo.normalizeDeprecatedResult(r8.deprecated(e16, this._utils), u5, !0);
                    if (!1 !== n11) {
                        if (!0 === n11) this._hasDeprecationWarned(o7) || this._utils.logger.warn(this._deprecatedHandler(o7, t12, this._utils));
                        else for (const { value: e17  } of n11){
                            const n12 = {
                                key: o7,
                                value: e17
                            };
                            if (!this._hasDeprecationWarned(n12)) {
                                const r9 = "string" == typeof t12 ? {
                                    key: t12,
                                    value: e17
                                } : t12;
                                this._utils.logger.warn(this._deprecatedHandler(n12, r9, this._utils));
                            }
                        }
                    }
                };
                fo.normalizeForwardResult(r8.forward(u5, this._utils), u5).forEach(a5);
                const l5 = fo.normalizeRedirectResult(r8.redirect(u5, this._utils), u5);
                if (l5.redirect.forEach(a5), "remain" in l5) {
                    const e16 = l5.remain;
                    t[o7] = o7 in t ? r8.overlap(t[o7], e16, this._utils) : e16, s4({
                        value: e16
                    });
                }
                for (const { from: e16 , to: t12  } of l5.redirect)s4({
                    value: e16,
                    redirectTo: t12
                });
            }
            for (const r8 of o6){
                const o8 = e[r8], u5 = this._unknownHandler(r8, o8, this._utils);
                if (u5) for (const e16 of Object.keys(u5)){
                    const r9 = {
                        [e16]: u5[e16]
                    };
                    e16 in this._utils.schemas ? n10.push(r9) : Object.assign(t, r9);
                }
            }
            return n10;
        }
    }
    t10.Normalizer = n8;
}), bo = je(function(e14, t10) {
    Object.defineProperty(t10, "__esModule", {
        value: !0
    }), vr.__exportStar(Fr, t10), vr.__exportStar(io, t10), vr.__exportStar(yo, t10), vr.__exportStar(Co, t10), vr.__exportStar(ao, t10);
});
const { env: Vo  } = Oe2;
function Wo(e14, t10) {
    if (0 === $o) return 0;
    if (_o("color=16m") || _o("color=full") || _o("color=truecolor")) return 3;
    if (_o("color=256")) return 2;
    if (e14 && !t10 && (void 0) === $o) return 0;
    const n8 = $o || 0;
    if ("dumb" === Vo.TERM) return n8;
    if ("win32" === Oe2.platform) {
        const e15 = Mr.release().split(".");
        return Number(e15[0]) >= 10 && Number(e15[2]) >= 10586 ? Number(e15[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Vo) return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI"
    ].some((e15)=>e15 in Vo
    ) || "codeship" === Vo.CI_NAME ? 1 : n8;
    if ("TEAMCITY_VERSION" in Vo) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Vo.TEAMCITY_VERSION) ? 1 : 0;
    if ("GITHUB_ACTIONS" in Vo) return 1;
    if ("truecolor" === Vo.COLORTERM) return 3;
    if ("TERM_PROGRAM" in Vo) {
        const e15 = parseInt((Vo.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch(Vo.TERM_PROGRAM){
            case "iTerm.app":
                return e15 >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    return /-256(color)?$/i.test(Vo.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Vo.TERM) || "COLORTERM" in Vo ? 1 : n8;
}
_o("no-color") || _o("no-colors") || _o("color=false") || _o("color=never") ? $o = 0 : (_o("color") || _o("colors") || _o("color=true") || _o("color=always")) && ($o = 1), "FORCE_COLOR" in Vo && ($o = "true" === Vo.FORCE_COLOR ? 1 : "false" === Vo.FORCE_COLOR ? 0 : 0 === Vo.FORCE_COLOR.length ? 1 : Math.min(parseInt(Vo.FORCE_COLOR, 10), 3));
var Uo = {
    supportsColor: function(e14) {
        return qo(Wo(e14, e14 && e14.isTTY));
    },
    stdout: qo(Wo(!0, Ro.isatty(1))),
    stderr: qo(Wo(!0, Ro.isatty(2)))
};
const { stdout: nu , stderr: ru  } = Uo, { stringReplaceAll: ou , stringEncaseCRLFWithFirstIndex: uu  } = Jo, { isArray: iu  } = Array, au = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
], su = Object.create(null);
const cu = (e14)=>{
    const t10 = {
    };
    return ((e15, t11 = {
    })=>{
        if (t11.level && !(Number.isInteger(t11.level) && t11.level >= 0 && t11.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
        const n8 = nu ? nu.level : 0;
        e15.level = (void 0) === t11.level ? n8 : t11.level;
    })(t10, e14), t10.template = (...e15)=>yu(t10.template, ...e15)
    , Object.setPrototypeOf(t10, pu.prototype), Object.setPrototypeOf(t10.template, t10), t10.template.constructor = ()=>{
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t10.template.Instance = lu, t10.template;
};
function pu(e14) {
    return cu(e14);
}
for (const [e14, t10] of Object.entries(Mo))su[e14] = {
    get () {
        const n8 = mu(this, hu(t10.open, t10.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, e14, {
            value: n8
        }), n8;
    }
};
su.visible = {
    get () {
        const e15 = mu(this, this._styler, !0);
        return Object.defineProperty(this, "visible", {
            value: e15
        }), e15;
    }
};
for (const e15 of du)su[e15] = {
    get () {
        const { level: t11  } = this;
        return function(...n8) {
            const r6 = hu(Mo.color[au[t11]][e15](...n8), Mo.color.close, this._styler);
            return mu(this, r6, this._isEmpty);
        };
    }
};
for (const e16 of du){
    su["bg" + e16[0].toUpperCase() + e16.slice(1)] = {
        get () {
            const { level: t11  } = this;
            return function(...n8) {
                const r6 = hu(Mo.bgColor[au[t11]][e16](...n8), Mo.bgColor.close, this._styler);
                return mu(this, r6, this._isEmpty);
            };
        }
    };
}
const fu = Object.defineProperties(()=>{
}, Object.assign({
}, su, {
    level: {
        enumerable: !0,
        get () {
            return this._generator.level;
        },
        set (e) {
            this._generator.level = e;
        }
    }
})), hu = (e17, t11, n8)=>{
    let r6, o5;
    return (void 0) === n8 ? (r6 = e17, o5 = t11) : (r6 = n8.openAll + e17, o5 = t11 + n8.closeAll), {
        open: e17,
        close: t11,
        openAll: r6,
        closeAll: o5,
        parent: n8
    };
}, mu = (e17, t11, n8)=>{
    const r6 = (...e18)=>iu(e18[0]) && iu(e18[0].raw) ? gu(r6, yu(r6, ...e18)) : gu(r6, 1 === e18.length ? "" + e18[0] : e18.join(" "))
    ;
    return Object.setPrototypeOf(r6, fu), r6._generator = e17, r6._styler = t11, r6._isEmpty = n8, r6;
}, gu = (e17, t11)=>{
    if (e17.level <= 0 || !t11) return e17._isEmpty ? "" : t11;
    let n8 = e17._styler;
    if ((void 0) === n8) return t11;
    const { openAll: r6 , closeAll: o5  } = n8;
    if (-1 !== t11.indexOf("\x1b")) for(; (void 0) !== n8;)t11 = ou(t11, n8.close, n8.open), n8 = n8.parent;
    const u4 = t11.indexOf("\n");
    return -1 !== u4 && (t11 = uu(t11, o5, r6, u4)), r6 + t11 + o5;
};
const yu = (e17, ...t11)=>{
    const [n8] = t11;
    if (!iu(n8) || !iu(n8.raw)) return t11.join(" ");
    const r6 = t11.slice(1), o5 = [
        n8.raw[0]
    ];
    for(let e18 = 1; e18 < n8.length; e18++)o5.push(String(r6[e18 - 1]).replace(/[{}\\]/g, "\\$&"), String(n8.raw[e18]));
    return (void 0) === Du && (Du = tu), Du(e17, o5.join(""));
};
Object.defineProperties(pu.prototype, su);
const Eu = pu();
Eu.supportsColor = nu, Eu.stderr = pu({
    level: ru ? ru.level : 0
}), Eu.stderr.supportsColor = ru;
var Cu = Eu;
const Ju = {
    key: (e17)=>1 === e17.length ? "-".concat(e17) : "--".concat(e17)
    ,
    value: (e17)=>bo.apiDescriptor.value(e17)
    ,
    pair: ({ key: e17 , value: t11  })=>!1 === t11 ? "--no-".concat(e17) : !0 === t11 ? Ju.key(e17) : "" === t11 ? "".concat(Ju.key(e17), " without an argument") : "".concat(Ju.key(e17), "=").concat(t11)
};
class zu extends bo.ChoiceSchema {
    constructor({ name: e17 , flags: t11  }){
        super({
            name: e17,
            choices: t11
        }), this._flags = t11.slice().sort();
    }
    preprocess(e, t) {
        if ("string" == typeof e && 0 !== e.length && !this._flags.includes(e)) {
            const n8 = this._flags.find((t12)=>xo(t12, e) < 3
            );
            if (n8) return t.logger.warn([
                "Unknown flag ".concat(Cu.yellow(t.descriptor.value(e)), ","),
                "did you mean ".concat(Cu.blue(t.descriptor.value(n8)), "?")
            ].join(" ")), n8;
        }
        return e;
    }
    expected() {
        return "a flag";
    }
}
function Hu(t12, n8, { logger: r6 , isCLI: o5 = !1 , passThrough: u4 = !1  } = {
}) {
    const i6 = u4 ? Array.isArray(u4) ? (e18, t13)=>u4.includes(e18) ? {
            [e18]: t13
        } : void 0
     : (e18, t13)=>({
            [e18]: t13
        })
     : (t13, n9, r7)=>{
        const o6 = e1(r7.schemas, [
            "_"
        ]);
        return bo.levenUnknownHandler(t13, n9, Object.assign({
        }, r7, {
            schemas: o6
        }));
    }, a5 = o5 ? Ju : bo.apiDescriptor, s4 = function(e18, { isCLI: t13  }) {
        const n9 = [];
        t13 && n9.push(bo.AnySchema.create({
            name: "_"
        }));
        for (const r7 of e18)n9.push(Xu(r7, {
            isCLI: t13,
            optionInfos: e18
        })), r7.alias && t13 && n9.push(bo.AliasSchema.create({
            name: r7.alias,
            sourceName: r7.name
        }));
        return n9;
    }(n8, {
        isCLI: o5
    }), l5 = new bo.Normalizer(s4, {
        logger: r6,
        unknown: i6,
        descriptor: a5
    }), c6 = !1 !== r6;
    c6 && Gu && (l5._hasDeprecationWarned = Gu);
    const p6 = l5.normalize(t12);
    return c6 && (Gu = l5._hasDeprecationWarned), p6;
}
function Xu(e18, { isCLI: t12 , optionInfos: n8  }) {
    let r6;
    const o5 = {
        name: e18.name
    }, u4 = {
    };
    switch(e18.type){
        case "int":
            r6 = bo.IntegerSchema, t12 && (o5.preprocess = (e19)=>Number(e19)
            );
            break;
        case "string":
            r6 = bo.StringSchema;
            break;
        case "choice":
            r6 = bo.ChoiceSchema, o5.choices = e18.choices.map((t13)=>"object" == typeof t13 && t13.redirect ? Object.assign({
                }, t13, {
                    redirect: {
                        to: {
                            key: e18.name,
                            value: t13.redirect
                        }
                    }
                }) : t13
            );
            break;
        case "boolean":
            r6 = bo.BooleanSchema;
            break;
        case "flag":
            r6 = zu, o5.flags = Uu(n8.map((e19)=>[
                    e19.alias,
                    e19.description && e19.name,
                    e19.oppositeDescription && "no-".concat(e19.name)
                ].filter(Boolean)
            ));
            break;
        case "path":
            r6 = bo.StringSchema;
            break;
        default:
            throw new Error("Unexpected type ".concat(e18.type));
    }
    if (e18.exception ? o5.validate = (t13, n9, r7)=>e18.exception(t13) || n9.validate(t13, r7)
     : o5.validate = (e19, t13, n9)=>(void 0) === e19 || t13.validate(e19, n9)
    , e18.redirect && (u4.redirect = (t13)=>t13 ? {
            to: {
                key: e18.redirect.option,
                value: e18.redirect.value
            }
        } : void 0
    ), e18.deprecated && (u4.deprecated = !0), t12 && !e18.array) {
        const e19 = o5.preprocess || ((e20)=>e20
        );
        o5.preprocess = (t13, n9, r7)=>n9.preprocess(e19(Array.isArray(t13) ? t13[t13.length - 1] : t13), r7)
        ;
    }
    return e18.array ? bo.ArraySchema.create(Object.assign({
    }, t12 ? {
        preprocess: (e19)=>[].concat(e19)
    } : {
    }, u4, {
        valueSchema: r6.create(o5)
    })) : r6.create(Object.assign({
    }, o5, u4));
}
var Yu = {
    normalizeApiOptions: function(e18, t12, n8) {
        return Hu(e18, t12, n8);
    },
    normalizeCliOptions: function(e18, t12, n8) {
        return Hu(e18, t12, Object.assign({
            isCLI: !0
        }, n8));
    }
};
const mi = Oe2.env;
function Di(e18) {
    return (function(e19) {
        return 0 !== e19 && {
            level: e19,
            hasBasic: !0,
            has256: e19 >= 2,
            has16m: e19 >= 3
        };
    })(function(e19) {
        if (!1 === gi) return 0;
        if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor")) return 3;
        if (Lr("color=256")) return 2;
        if (e19 && !e19.isTTY && !0 !== gi) return 0;
        const t12 = gi ? 1 : 0;
        if ("win32" === Oe2.platform) {
            const e20 = Mr.release().split(".");
            return Number(Oe2.versions.node.split(".")[0]) >= 8 && Number(e20[0]) >= 10 && Number(e20[2]) >= 10586 ? Number(e20[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in mi) return [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI"
        ].some((e20)=>e20 in mi
        ) || "codeship" === mi.CI_NAME ? 1 : t12;
        if ("TEAMCITY_VERSION" in mi) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(mi.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === mi.COLORTERM) return 3;
        if ("TERM_PROGRAM" in mi) {
            const e20 = parseInt((mi.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch(mi.TERM_PROGRAM){
                case "iTerm.app":
                    return e20 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test(mi.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(mi.TERM) || "COLORTERM" in mi ? 1 : (mi.TERM, t12);
    }(e18));
}
Lr("no-color") || Lr("no-colors") || Lr("color=false") ? gi = !1 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && (gi = !0), "FORCE_COLOR" in mi && (gi = 0 === mi.FORCE_COLOR.length || 0 !== parseInt(mi.FORCE_COLOR, 10));
var yi = {
    supportsColor: Di,
    stdout: Di(Oe2.stdout),
    stderr: Di(Oe2.stderr)
};
var Ti = (e18, t12)=>{
    const n8 = [], r6 = [];
    let o5 = [];
    if (t12.replace(Ei, (t13, u4, i6, a5, s4, l5)=>{
        if (u4) o5.push(Fi(u4));
        else if (a5) {
            const t14 = o5.join("");
            o5 = [], r6.push(0 === n8.length ? t14 : wi(e18, n8)(t14)), n8.push({
                inverse: i6,
                styles: Si(a5)
            });
        } else if (s4) {
            if (0 === n8.length) throw new Error("Found extraneous } in Chalk template literal");
            r6.push(wi(e18, n8)(o5.join(""))), o5 = [], n8.pop();
        } else o5.push(l5);
    }), r6.push(o5.join("")), n8.length > 0) {
        const e19 = "Chalk template literal is missing ".concat(n8.length, " closing bracket").concat(1 === n8.length ? "" : "s", " (`}`)");
        throw new Error(e19);
    }
    return r6.join("");
}, Bi = je(function(e18) {
    const t12 = yi.stdout, n8 = "win32" === Oe2.platform && !(Oe2.env.TERM || "").toLowerCase().startsWith("xterm"), r6 = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
    ], o5 = new Set([
        "gray"
    ]), u4 = Object.create(null);
    function i6(e19, n9) {
        n9 = n9 || {
        };
        const r7 = t12 ? t12.level : 0;
        e19.level = (void 0) === n9.level ? r7 : n9.level, e19.enabled = "enabled" in n9 ? n9.enabled : e19.level > 0;
    }
    function a5(e19) {
        if (!this || !(this instanceof a5) || this.template) {
            const t13 = {
            };
            return (i6(t13, e19), t13.template = function() {
                const e20 = [].slice.call(arguments);
                return p6.apply(null, [
                    t13.template
                ].concat(e20));
            }, Object.setPrototypeOf(t13, a5.prototype), Object.setPrototypeOf(t13.template, t13), t13.template.constructor = a5, t13.template);
        }
        i6(this, e19);
    }
    n8 && (hi.blue.open = "\x1b[94m");
    for (const e19 of Object.keys(hi))hi[e19].closeRe = new RegExp(ii(hi[e19].close), "g"), u4[e19] = {
        get () {
            const t13 = hi[e19];
            return l5.call(this, this._styles ? this._styles.concat(t13) : [
                t13
            ], this._empty, e19);
        }
    };
    u4.visible = {
        get () {
            return l5.call(this, this._styles || [], !0, "visible");
        }
    }, hi.color.closeRe = new RegExp(ii(hi.color.close), "g");
    for (const e20 of Object.keys(hi.color.ansi))o5.has(e20) || (u4[e20] = {
        get () {
            const t13 = this.level;
            return function() {
                const n9 = hi.color[r6[t13]][e20].apply(null, arguments), o6 = {
                    open: n9,
                    close: hi.color.close,
                    closeRe: hi.color.closeRe
                };
                return l5.call(this, this._styles ? this._styles.concat(o6) : [
                    o6
                ], this._empty, e20);
            };
        }
    });
    hi.bgColor.closeRe = new RegExp(ii(hi.bgColor.close), "g");
    for (const e21 of Object.keys(hi.bgColor.ansi)){
        if (o5.has(e21)) continue;
        u4["bg" + e21[0].toUpperCase() + e21.slice(1)] = {
            get () {
                const t13 = this.level;
                return function() {
                    const n9 = hi.bgColor[r6[t13]][e21].apply(null, arguments), o6 = {
                        open: n9,
                        close: hi.bgColor.close,
                        closeRe: hi.bgColor.closeRe
                    };
                    return l5.call(this, this._styles ? this._styles.concat(o6) : [
                        o6
                    ], this._empty, e21);
                };
            }
        };
    }
    const s4 = Object.defineProperties(()=>{
    }, u4);
    function l5(e22, t13, n9) {
        const r7 = function() {
            return c6.apply(r7, arguments);
        };
        r7._styles = e22, r7._empty = t13;
        const o6 = this;
        return (Object.defineProperty(r7, "level", {
            enumerable: !0,
            get: ()=>o6.level
            ,
            set (e) {
                o6.level = e;
            }
        }), Object.defineProperty(r7, "enabled", {
            enumerable: !0,
            get: ()=>o6.enabled
            ,
            set (e) {
                o6.enabled = e;
            }
        }), r7.hasGrey = this.hasGrey || "gray" === n9 || "grey" === n9, r7.__proto__ = s4, r7);
    }
    function c6() {
        const e22 = arguments, t13 = e22.length;
        let r7 = String(arguments[0]);
        if (0 === t13) return "";
        if (t13 > 1) for(let n9 = 1; n9 < t13; n9++)r7 += " " + arguments[n9];
        if (!this.enabled || this.level <= 0 || !r7) return this._empty ? "" : r7;
        const o6 = hi.dim.open;
        n8 && this.hasGrey && (hi.dim.open = "");
        for (const e23 of this._styles.slice().reverse())r7 = e23.open + r7.replace(e23.closeRe, e23.open) + e23.close, r7 = r7.replace(/\r?\n/g, "".concat(e23.close, "$&").concat(e23.open));
        return (hi.dim.open = o6, r7);
    }
    function p6(e22, t13) {
        if (!Array.isArray(t13)) return [].slice.call(arguments, 1).join(" ");
        const n9 = [].slice.call(arguments, 2), r7 = [
            t13.raw[0]
        ];
        for(let e23 = 1; e23 < t13.length; e23++)r7.push(String(n9[e23 - 1]).replace(/[{}\\]/g, "\\$&")), r7.push(String(t13.raw[e23]));
        return Ti(e22, r7.join(""));
    }
    Object.defineProperties(a5.prototype, u4), e18.exports = a5(), e18.exports.supportsColor = t12, e18.exports.default = e18.exports;
}), Ni = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    }), t12.shouldHighlight = l5, t12.getChalk = c6, t12.default = function(e19, t13 = {
    }) {
        if (l5(t13)) {
            const n8 = c6(t13);
            return (function(e20, t14) {
                return t14.replace(r6.default, function(...t15) {
                    const n9 = function(e21) {
                        const [t16, n10] = e21.slice(-2), o5 = r6.matchToToken(e21);
                        if ("name" === o5.type) {
                            if (oi.isKeyword(o5.value) || oi.isReservedWord(o5.value)) return "keyword";
                            if (a5.test(o5.value) && ("<" === n10[t16 - 1] || "</" == n10.substr(t16 - 2, 2))) return "jsx_tag";
                            if (o5.value[0] !== o5.value[0].toLowerCase()) return "capitalized";
                        }
                        if ("punctuator" === o5.type && s4.test(o5.value)) return "bracket";
                        if ("invalid" === o5.type && ("@" === o5.value || "#" === o5.value)) return "punctuator";
                        return o5.type;
                    }(t15), o5 = e20[n9];
                    return o5 ? t15[0].split(i6).map((e21)=>o5(e21)
                    ).join("\n") : t15[0];
                });
            })(function(e20) {
                return {
                    keyword: e20.cyan,
                    capitalized: e20.yellow,
                    jsx_tag: e20.yellow,
                    punctuator: e20.yellow,
                    number: e20.magenta,
                    string: e20.green,
                    regex: e20.magenta,
                    comment: e20.grey,
                    invalid: e20.white.bgRed.bold
                };
            }(n8), e19);
        }
        return e19;
    };
    var n8, r6 = function(e19) {
        if (e19 && e19.__esModule) return e19;
        if (null === e19 || "object" != typeof e19 && "function" != typeof e19) return {
            default: e19
        };
        var t13 = u4();
        if (t13 && t13.has(e19)) return t13.get(e19);
        var n9 = {
        }, r6 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var o5 in e19)if (Object.prototype.hasOwnProperty.call(e19, o5)) {
            var i6 = r6 ? Object.getOwnPropertyDescriptor(e19, o5) : null;
            i6 && (i6.get || i6.set) ? Object.defineProperty(n9, o5, i6) : n9[o5] = e19[o5];
        }
        n9.default = e19, t13 && t13.set(e19, n9);
        return n9;
    }(ti), o5 = (n8 = Bi) && n8.__esModule ? n8 : {
        default: n8
    };
    function u4() {
        if ("function" != typeof WeakMap) return null;
        var e19 = new WeakMap;
        return (u4 = function() {
            return e19;
        }, e19);
    }
    const i6 = /\r\n|[\n\r\u2028\u2029]/, a5 = /^[a-z][\w-]*$/i, s4 = /^[()[\]{}]$/;
    function l5(e19) {
        return o5.default.supportsColor || e19.forceColor;
    }
    function c6(e19) {
        let t13 = o5.default;
        return (e19.forceColor && (t13 = new o5.default.constructor({
            enabled: !0,
            level: 1
        })), t13);
    }
}), ki = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    }), t12.codeFrameColumns = i6, t12.default = function(e19, t13, n8, r6 = {
    }) {
        if (!o5) {
            o5 = !0;
            const e20 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (Oe2.emitWarning) Oe2.emitWarning(e20, "DeprecationWarning");
            else {
                new Error(e20).name = "DeprecationWarning", console.warn(new Error(e20));
            }
        }
        n8 = Math.max(n8, 0);
        return i6(e19, {
            start: {
                column: n8,
                line: t13
            }
        }, r6);
    };
    var n8 = function(e19) {
        if (e19 && e19.__esModule) return e19;
        if (null === e19 || "object" != typeof e19 && "function" != typeof e19) return {
            default: e19
        };
        var t13 = r6();
        if (t13 && t13.has(e19)) return t13.get(e19);
        var n8 = {
        }, o5 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var u4 in e19)if (Object.prototype.hasOwnProperty.call(e19, u4)) {
            var i6 = o5 ? Object.getOwnPropertyDescriptor(e19, u4) : null;
            i6 && (i6.get || i6.set) ? Object.defineProperty(n8, u4, i6) : n8[u4] = e19[u4];
        }
        n8.default = e19, t13 && t13.set(e19, n8);
        return n8;
    }(Ni);
    function r6() {
        if ("function" != typeof WeakMap) return null;
        var e19 = new WeakMap;
        return (r6 = function() {
            return e19;
        }, e19);
    }
    let o5 = !1;
    const u4 = /\r\n|[\n\r\u2028\u2029]/;
    function i6(e19, t13, r7 = {
    }) {
        const o6 = (r7.highlightCode || r7.forceColor) && n8.shouldHighlight(r7), i7 = n8.getChalk(r7), a5 = function(e20) {
            return {
                gutter: e20.grey,
                marker: e20.red.bold,
                message: e20.red.bold
            };
        }(i7), s4 = (e20, t14)=>o6 ? e20(t14) : t14
        , l5 = e19.split(u4), { start: c6 , end: p6 , markerLines: d6  } = function(e20, t14, n9) {
            const r8 = Object.assign({
                column: 0,
                line: -1
            }, e20.start), o7 = Object.assign({
            }, r8, e20.end), { linesAbove: u5 = 2 , linesBelow: i8 = 3  } = n9 || {
            }, a6 = r8.line, s5 = r8.column, l6 = o7.line, c7 = o7.column;
            let p7 = Math.max(a6 - (u5 + 1), 0), d7 = Math.min(t14.length, l6 + i8);
            -1 === a6 && (p7 = 0), -1 === l6 && (d7 = t14.length);
            const f5 = l6 - a6, h5 = {
            };
            if (f5) for(let e21 = 0; e21 <= f5; e21++){
                const n10 = e21 + a6;
                if (s5) {
                    if (0 === e21) {
                        const e22 = t14[n10 - 1].length;
                        h5[n10] = [
                            s5,
                            e22 - s5 + 1
                        ];
                    } else if (e21 === f5) h5[n10] = [
                        0,
                        c7
                    ];
                    else {
                        const r9 = t14[n10 - e21].length;
                        h5[n10] = [
                            0,
                            r9
                        ];
                    }
                } else h5[n10] = !0;
            }
            else h5[a6] = s5 === c7 ? !s5 || [
                s5,
                0
            ] : [
                s5,
                c7 - s5
            ];
            return {
                start: p7,
                end: d7,
                markerLines: h5
            };
        }(t13, l5, r7), f5 = t13.start && "number" == typeof t13.start.column, h5 = String(p6).length;
        let m5 = (o6 ? n8.default(e19, r7) : e19).split(u4).slice(c6, p6).map((e20, t14)=>{
            const n9 = c6 + 1 + t14, o7 = " ".concat(n9).slice(-h5), u5 = " ".concat(o7, " | "), i8 = d6[n9], l6 = !d6[n9 + 1];
            if (i8) {
                let t15 = "";
                if (Array.isArray(i8)) {
                    const n10 = e20.slice(0, Math.max(i8[0] - 1, 0)).replace(/[^\t]/g, " "), o8 = i8[1] || 1;
                    t15 = [
                        "\n ",
                        s4(a5.gutter, u5.replace(/\d/g, " ")),
                        n10,
                        s4(a5.marker, "^").repeat(o8)
                    ].join(""), l6 && r7.message && (t15 += " " + s4(a5.message, r7.message));
                }
                return [
                    s4(a5.marker, ">"),
                    s4(a5.gutter, u5),
                    e20,
                    t15
                ].join("");
            }
            return " ".concat(s4(a5.gutter, u5)).concat(e20);
        }).join("\n");
        return (r7.message && !f5 && (m5 = "".concat(" ".repeat(h5 + 1)).concat(r7.message, "\n").concat(m5)), o6 ? i7.reset(m5) : m5);
    }
}), Pi = _e(fn1);
var Vi = {
    parse: function(e18, t12) {
        const n8 = _i(t12), r6 = Object.keys(n8).reduce((e19, t13)=>Object.defineProperty(e19, t13, {
                enumerable: !0,
                get: ()=>n8[t13].parse
            })
        , {
        }), o5 = Ri(t12, n8);
        try {
            return (o5.preprocess && (e18 = o5.preprocess(e18, t12)), {
                text: e18,
                ast: o5.parse(e18, r6, t12)
            });
        } catch (t) {
            const { loc: n9  } = t;
            if (n9) {
                const { codeFrameColumns: r7  } = ki;
                throw (t.codeFrame = r7(e18, n9, {
                    highlightCode: !0
                }), t.message += "\n" + t.codeFrame, t);
            }
            throw t.stack;
        }
    },
    resolveParser: Ri
};
const { getSupportInfo: qi  } = pt1, { resolveParser: Wi  } = Vi, Ui = {
    astFormat: "estree",
    printer: {
    },
    originalText: void 0,
    locStart: null,
    locEnd: null
};
function Ji(e18, t12) {
    const n8 = Pi.basename(e18).toLowerCase(), r6 = qi({
        plugins: t12
    }).languages.filter((e19)=>null !== e19.since
    );
    let o5 = r6.find((e19)=>e19.extensions && e19.extensions.some((e20)=>n8.endsWith(e20)
        ) || e19.filenames && e19.filenames.some((e20)=>e20.toLowerCase() === n8
        )
    );
    if (!o5 && !n8.includes(".")) {
        const t13 = function(e19) {
            if ("string" != typeof e19) return "";
            let t14;
            try {
                t14 = cr.openSync(e19, "r");
            } catch (e) {
                return "";
            }
            try {
                const e20 = new pr(t14).next().toString("utf8"), n9 = e20.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
                if (n9) return n9[1];
                const r7 = e20.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
                return r7 ? r7[1] : "";
            } catch (e) {
                return "";
            } finally{
                try {
                    cr.closeSync(t14);
                } catch (e) {
                }
            }
        }(e18);
        o5 = r6.find((e19)=>e19.interpreters && e19.interpreters.includes(t13)
        );
    }
    return o5 && o5.parsers[0];
}
var zi = {
    normalize: function(e18, t12) {
        t12 = t12 || {
        };
        const n8 = Object.assign({
        }, e18), r6 = qi({
            plugins: e18.plugins,
            showUnreleased: !0,
            showDeprecated: !0
        }).options, o5 = Object.assign({
        }, Ui, dr(r6.filter((e19)=>(void 0) !== e19.default
        ).map((e19)=>[
                e19.name,
                e19.default
            ]
        )));
        if (!n8.parser) {
            if (n8.filepath) {
                if ((n8.parser = Ji(n8.filepath, n8.plugins), !n8.parser)) throw new $i("No parser could be inferred for file: ".concat(n8.filepath));
            } else {
                (t12.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n8.parser = "babel";
            }
        }
        const u4 = Wi(Yu.normalizeApiOptions(n8, [
            r6.find((e19)=>"parser" === e19.name
            )
        ], {
            passThrough: !0,
            logger: !1
        }));
        n8.astFormat = u4.astFormat, n8.locEnd = u4.locEnd, n8.locStart = u4.locStart;
        const i6 = function(e19) {
            const { astFormat: t13  } = e19;
            if (!t13) throw new Error("getPlugin() requires astFormat to be set");
            const n9 = e19.plugins.find((e20)=>e20.printers && e20.printers[t13]
            );
            if (!n9) throw new Error("Couldn't find plugin for AST format \"".concat(t13, '"'));
            return n9;
        }(n8);
        n8.printer = i6.printers[n8.astFormat];
        const a5 = r6.filter((e19)=>e19.pluginDefaults && (void 0) !== e19.pluginDefaults[i6.name]
        ).reduce((e19, t13)=>Object.assign(e19, {
                [t13.name]: t13.pluginDefaults[i6.name]
            })
        , {
        }), s4 = Object.assign({
        }, o5, a5);
        return (Object.keys(s4).forEach((e19)=>{
            null == n8[e19] && (n8[e19] = s4[e19]);
        }), "json" === n8.parser && (n8.trailingComma = "none"), Yu.normalizeApiOptions(n8, r6, Object.assign({
            passThrough: Object.keys(Ui)
        }, t12)));
    },
    hiddenDefaults: Ui,
    inferParser: Ji
};
const { builders: { concat: Yi , line: Ki , hardline: Qi , breakParent: Zi , indent: ea , lineSuffix: ta , join: na , cursor: ra  }  } = rn1, { hasNewline: oa , skipNewline: ua , skipSpaces: ia , isPreviousLineEmpty: aa , addLeadingComment: sa , addDanglingComment: la , addTrailingComment: ca  } = Nt1, pa = Symbol("child-nodes");
function da(e18, t12, n8) {
    if (!e18) return;
    const { printer: r6 , locStart: o5 , locEnd: u4  } = t12;
    if (n8) {
        if (r6.canAttachComment && r6.canAttachComment(e18)) {
            let t13;
            for(t13 = n8.length - 1; t13 >= 0 && !(o5(n8[t13]) <= o5(e18) && u4(n8[t13]) <= u4(e18)); --t13);
            return void n8.splice(t13 + 1, 0, e18);
        }
    } else if (e18[pa]) return e18[pa];
    const i6 = r6.getCommentChildNodes && r6.getCommentChildNodes(e18, t12) || "object" == typeof e18 && Object.keys(e18).filter((e19)=>"enclosingNode" !== e19 && "precedingNode" !== e19 && "followingNode" !== e19 && "tokens" !== e19 && "comments" !== e19
    ).map((t13)=>e18[t13]
    );
    return i6 ? (n8 || Object.defineProperty(e18, pa, {
        value: n8 = [],
        enumerable: !1
    }), i6.forEach((e19)=>{
        da(e19, t12, n8);
    }), n8) : void 0;
}
function fa(e18, t12, n8) {
    const { locStart: r6 , locEnd: o5  } = n8, u4 = r6(t12), i6 = o5(t12), a5 = da(e18, n8);
    let s4, l5, c6 = 0, p6 = a5.length;
    for(; c6 < p6;){
        const e19 = c6 + p6 >> 1, d6 = a5[e19], f5 = r6(d6), h5 = o5(d6);
        if (f5 <= u4 && i6 <= h5) return t12.enclosingNode = d6, void fa(d6, t12, n8);
        if (f5 <= u4) s4 = d6, c6 = e19 + 1;
        else {
            if (!(i6 <= f5)) throw new Error("Comment location overlaps with node location");
            l5 = d6, p6 = e19;
        }
    }
    if (t12.enclosingNode && "TemplateLiteral" === t12.enclosingNode.type) {
        const { quasis: e19  } = t12.enclosingNode, r7 = ga(e19, t12, n8);
        s4 && ga(e19, s4, n8) !== r7 && (s4 = null), l5 && ga(e19, l5, n8) !== r7 && (l5 = null);
    }
    s4 && (t12.precedingNode = s4), l5 && (t12.followingNode = l5);
}
function ha(e18, t12, n8) {
    const r6 = e18.length;
    if (0 === r6) return;
    const { precedingNode: o5 , followingNode: u4 , enclosingNode: i6  } = e18[0], a5 = n8.printer.getGapRegex && n8.printer.getGapRegex(i6) || /^[\s(]*$/;
    let s4, l5 = n8.locStart(u4);
    for(s4 = r6; s4 > 0; --s4){
        const r7 = e18[s4 - 1];
        Xi.strictEqual(r7.precedingNode, o5), Xi.strictEqual(r7.followingNode, u4);
        const i7 = t12.slice(n8.locEnd(r7), l5);
        if (!a5.test(i7)) break;
        l5 = n8.locStart(r7);
    }
    e18.forEach((e19, t13)=>{
        t13 < s4 ? ca(o5, e19) : sa(u4, e19);
    });
    for (const e19 of [
        o5,
        u4
    ])e19.comments && e19.comments.length > 1 && e19.comments.sort((e20, t13)=>n8.locStart(e20) - n8.locStart(t13)
    );
    e18.length = 0;
}
function Da(e18, t12, n8) {
    return e18.getNode() === t12.cursorNode && e18.getValue() ? Yi([
        ra,
        n8,
        ra
    ]) : n8;
}
var ya = {
    attach: function(e18, t12, n8, r6) {
        if (!Array.isArray(e18)) return;
        const o5 = [], { locStart: u4 , locEnd: i6  } = r6;
        e18.forEach((a5, s4)=>{
            if ("json" === r6.parser || "json5" === r6.parser || "__js_expression" === r6.parser || "__vue_expression" === r6.parser) {
                if (u4(a5) - u4(t12) <= 0) return void sa(t12, a5);
                if (i6(a5) - i6(t12) >= 0) return void ca(t12, a5);
            }
            fa(t12, a5, r6);
            const { precedingNode: l5 , enclosingNode: c6 , followingNode: p6  } = a5, d6 = r6.printer.handleComments && r6.printer.handleComments.ownLine ? r6.printer.handleComments.ownLine : ()=>!1
            , f5 = r6.printer.handleComments && r6.printer.handleComments.endOfLine ? r6.printer.handleComments.endOfLine : ()=>!1
            , h5 = r6.printer.handleComments && r6.printer.handleComments.remaining ? r6.printer.handleComments.remaining : ()=>!1
            , m5 = e18.length - 1 === s4;
            if (oa(n8, u4(a5), {
                backwards: !0
            })) d6(a5, n8, r6, t12, m5) || (p6 ? sa(p6, a5) : l5 ? ca(l5, a5) : la(c6 || t12, a5));
            else if (oa(n8, i6(a5))) f5(a5, n8, r6, t12, m5) || (l5 ? ca(l5, a5) : p6 ? sa(p6, a5) : la(c6 || t12, a5));
            else if (h5(a5, n8, r6, t12, m5)) ;
            else if (l5 && p6) {
                const e19 = o5.length;
                if (e19 > 0) {
                    o5[e19 - 1].followingNode !== a5.followingNode && ha(o5, n8, r6);
                }
                o5.push(a5);
            } else l5 ? ca(l5, a5) : p6 ? sa(p6, a5) : la(c6 || t12, a5);
        }), ha(o5, n8, r6), e18.forEach((e19)=>{
            delete e19.precedingNode, delete e19.enclosingNode, delete e19.followingNode;
        });
    },
    printComments: function(e18, t12, n8, r6) {
        const o5 = e18.getValue(), u4 = t12(e18), i6 = o5 && o5.comments;
        if (!i6 || 0 === i6.length) return Da(e18, n8, u4);
        const a5 = [], s4 = [
            r6 ? ";" : "",
            u4
        ];
        return (e18.each((e19)=>{
            const t13 = e19.getValue(), { leading: r7 , trailing: o6  } = t13;
            if (r7) {
                const r8 = function(e20, t14) {
                    const n9 = e20.getValue(), r9 = ma(e20, t14);
                    if (!r9) return "";
                    if (t14.printer.isBlockComment && t14.printer.isBlockComment(n9)) {
                        const e21 = oa(t14.originalText, t14.locEnd(n9)) ? oa(t14.originalText, t14.locStart(n9), {
                            backwards: !0
                        }) ? Qi : Ki : " ";
                        return Yi([
                            r9,
                            e21
                        ]);
                    }
                    return Yi([
                        r9,
                        Qi
                    ]);
                }(e19, n8);
                if (!r8) return;
                a5.push(r8);
                const o7 = n8.originalText, u5 = ua(o7, ia(o7, n8.locEnd(t13)));
                !1 !== u5 && oa(o7, u5) && a5.push(Qi);
            } else o6 && s4.push(function(e20, t14) {
                const n9 = e20.getValue(), r8 = ma(e20, t14);
                if (!r8) return "";
                const { printer: o7 , originalText: u5 , locStart: i7  } = t14, a6 = o7.isBlockComment && o7.isBlockComment(n9);
                if (oa(u5, i7(n9), {
                    backwards: !0
                })) {
                    const e21 = aa(u5, n9, i7);
                    return ta(Yi([
                        Qi,
                        e21 ? Qi : "",
                        r8
                    ]));
                }
                let s5 = Yi([
                    " ",
                    r8
                ]);
                return a6 || (s5 = Yi([
                    ta(s5),
                    Zi
                ])), s5;
            }(e19, n8));
        }, "comments"), Da(e18, n8, Yi(a5.concat(s4))));
    },
    printDanglingComments: function(e18, t12, n8, r6) {
        const o5 = [], u4 = e18.getValue();
        return u4 && u4.comments ? (e18.each((e19)=>{
            const n9 = e19.getValue();
            !n9 || n9.leading || n9.trailing || r6 && !r6(n9) || o5.push(ma(e19, t12));
        }, "comments"), 0 === o5.length ? "" : n8 ? na(Qi, o5) : ea(Yi([
            Qi,
            na(Qi, o5)
        ]))) : "";
    },
    getSortedChildNodes: da,
    ensureAllCommentsPrinted: function(e18) {
        e18 && e18.forEach((e19)=>{
            if (!e19.printed) throw new Error('Comment "' + e19.value.trim() + '" was not printed. Please report this error!');
            delete e19.printed;
        });
    }
};
const { utils: { stripTrailingHardline: va  }  } = rn1, { normalize: Aa  } = zi;
var Fa = {
    printSubtree: function(e18, t12, n8, r6) {
        if (n8.printer.embed && "auto" === n8.embeddedLanguageFormatting) return n8.printer.embed(e18, t12, (e19, t13, o5)=>(function(e20, t14, n9, r7, { stripTrailingHardline: o6 = !1  } = {
            }) {
                const u4 = Aa(Object.assign({
                }, n9, t14, {
                    parentParser: n9.parser,
                    embeddedInHtml: !(!n9.embeddedInHtml && "html" !== n9.parser && "vue" !== n9.parser && "angular" !== n9.parser && "lwc" !== n9.parser),
                    originalText: e20
                }), {
                    passThrough: !0
                }), i6 = Vi.parse(e20, u4), { ast: a5  } = i6;
                e20 = i6.text;
                const s4 = a5.comments;
                delete a5.comments, ya.attach(s4, a5, e20, u4), u4[Symbol.for("comments")] = s4 || [], u4[Symbol.for("tokens")] = a5.tokens || [];
                const l5 = r7(a5, u4);
                if (ya.ensureAllCommentsPrinted(s4), o6) return "string" == typeof l5 ? l5.replace(/(?:\r?\n)*$/, "") : va(l5, !0);
                return l5;
            })(e19, t13, n8, r6, o5)
        , n8);
    }
};
const xa = rn1, Sa = xa.builders, { concat: wa , hardline: Ta , addAlignmentToDoc: Ba  } = Sa, Na = xa.utils;
function ka(e18, t12, n8 = 0) {
    const { printer: r6  } = t12;
    r6.preprocess && (e18 = r6.preprocess(e18, t12));
    const o5 = new Map;
    let u4 = function e18(n9, u5) {
        const i6 = n9.getValue(), a5 = i6 && "object" == typeof i6 && (void 0) === u5;
        if (a5 && o5.has(i6)) return o5.get(i6);
        let s4;
        return s4 = r6.willPrintOwnComments && r6.willPrintOwnComments(n9, t12) ? Pa(n9, t12, e18, u5) : ya.printComments(n9, (n10)=>Pa(n10, t12, e18, u5)
        , t12, u5 && u5.needsSemi), a5 && o5.set(i6, s4), s4;
    }(new ba(e18));
    return n8 > 0 && (u4 = Ba(wa([
        Ta,
        u4
    ]), n8, t12.tabWidth)), Na.propagateBreaks(u4), u4;
}
function Pa(e18, t12, n8, r6) {
    Xi.ok(e18 instanceof ba);
    const o5 = e18.getValue(), { printer: u4  } = t12;
    if (u4.hasPrettierIgnore && u4.hasPrettierIgnore(e18)) return (function(e19, t13) {
        const { originalText: n9 , [Symbol.for("comments")]: r7 , locStart: o6 , locEnd: u5  } = t13, i6 = o6(e19), a5 = u5(e19);
        for (const e20 of r7)o6(e20) >= i6 && u5(e20) <= a5 && (e20.printed = !0);
        return n9.slice(i6, a5);
    })(o5, t12);
    if (o5) try {
        const r7 = Fa.printSubtree(e18, n8, t12, ka);
        if (r7) return r7;
    } catch (e) {
        if (Me.PRETTIER_DEBUG) throw e;
    }
    return u4.print(e18, t12, n8, r6);
}
var Oa = ka;
function Ia(e18, t12, n8, r6, o5 = []) {
    if (!(t12 < n8.locStart(e18) || t12 > n8.locEnd(e18))) {
        for (const u4 of ya.getSortedChildNodes(e18, n8)){
            const i6 = Ia(u4, t12, n8, r6, [
                e18,
                ...o5
            ]);
            if (i6) return i6;
        }
        return !r6 || r6(e18) ? {
            node: e18,
            parentNodes: o5
        } : void 0;
    }
}
var _a = {
    calculateRange: function(e18, t12, n8) {
        const r6 = e18.slice(t12.rangeStart, t12.rangeEnd), o5 = Math.max(t12.rangeStart + r6.search(/\S/), t12.rangeStart);
        let u4;
        for(u4 = t12.rangeEnd; u4 > t12.rangeStart && !/\S/.test(e18[u4 - 1]); --u4);
        const i6 = Ia(n8, o5, t12, (e19)=>ja(t12, e19)
        ), a5 = Ia(n8, u4, t12, (e19)=>ja(t12, e19)
        );
        if (!i6 || !a5) return {
            rangeStart: 0,
            rangeEnd: 0
        };
        const { startNode: s4 , endNode: l5  } = function(e19, t13, n9) {
            let r7 = e19.node, o6 = t13.node;
            if (r7 === o6) return {
                startNode: r7,
                endNode: o6
            };
            for (const r8 of t13.parentNodes){
                if (!("Program" !== r8.type && "File" !== r8.type && n9.locStart(r8) >= n9.locStart(e19.node))) break;
                o6 = r8;
            }
            for (const o7 of e19.parentNodes){
                if (!("Program" !== o7.type && "File" !== o7.type && n9.locEnd(o7) <= n9.locEnd(t13.node))) break;
                r7 = o7;
            }
            return {
                startNode: r7,
                endNode: o6
            };
        }(i6, a5, t12);
        return {
            rangeStart: Math.min(t12.locStart(s4), t12.locStart(l5)),
            rangeEnd: Math.max(t12.locEnd(s4), t12.locEnd(l5))
        };
    },
    findNodeAtOffset: Ia
};
const { printer: { printDocToString: Ra  } , debug: { printDocToDebug: Va  }  } = rn1, { getAlignmentSize: $a  } = Nt1, { guessEndOfLine: qa , convertEndOfLineToChars: Wa , countEndOfLineChars: Ua , normalizeEndOfLine: Ja  } = kt, za = zi.normalize, Ga = Symbol("cursor");
function Ha(e18, t12, n8) {
    const r6 = t12.comments;
    return r6 && (delete t12.comments, ya.attach(r6, t12, e18, n8)), n8[Symbol.for("comments")] = r6 || [], n8[Symbol.for("tokens")] = t12.tokens || [], n8.originalText = e18, r6;
}
function Xa(e18, t12, n8) {
    if (!e18 || !e18.trim().length) return {
        formatted: "",
        cursorOffset: -1
    };
    n8 = n8 || 0;
    const { ast: r6 , text: o5  } = Vi.parse(e18, t12);
    if (t12.cursorOffset >= 0) {
        const e19 = _a.findNodeAtOffset(r6, t12.cursorOffset, t12);
        e19 && e19.node && (t12.cursorNode = e19.node);
    }
    const u4 = Ha(o5, r6, t12), i6 = Oa(r6, t12, n8), a5 = Ra(i6, t12);
    if (ya.ensureAllCommentsPrinted(u4), n8 > 0) {
        const e19 = a5.formatted.trim();
        (void 0) !== a5.cursorNodeStart && (a5.cursorNodeStart -= a5.formatted.indexOf(e19)), a5.formatted = e19 + Wa(t12.endOfLine);
    }
    if (t12.cursorOffset >= 0) {
        let e19, n9, r7, u5, i7;
        if (t12.cursorNode && a5.cursorNodeText ? (e19 = t12.locStart(t12.cursorNode), n9 = o5.slice(e19, t12.locEnd(t12.cursorNode)), r7 = t12.cursorOffset - e19, u5 = a5.cursorNodeStart, i7 = a5.cursorNodeText) : (e19 = 0, n9 = o5, r7 = t12.cursorOffset, u5 = 0, i7 = a5.formatted), n9 === i7) return {
            formatted: a5.formatted,
            cursorOffset: u5 + r7
        };
        const s4 = n9.split("");
        s4.splice(r7, 0, Ga);
        const l5 = i7.split(""), c6 = J1.diffArrays(s4, l5);
        let p6 = u5;
        for (const e20 of c6)if (e20.removed) {
            if (e20.value.includes(Ga)) break;
        } else p6 += e20.count;
        return {
            formatted: a5.formatted,
            cursorOffset: p6
        };
    }
    return {
        formatted: a5.formatted,
        cursorOffset: -1
    };
}
function Qa(e18, t12) {
    let { cursorOffset: n8 , rangeStart: r6 , rangeEnd: o5 , endOfLine: u4  } = Ka(e18, t12);
    const i6 = "\ufeff" === e18.charAt(0);
    if (i6 && (e18 = e18.slice(1), n8--, r6--, o5--), "auto" === u4 && (u4 = qa(e18)), e18.includes("\r")) {
        const t13 = (t14)=>Ua(e18.slice(0, Math.max(t14, 0)), "\r\n")
        ;
        n8 -= t13(n8), r6 -= t13(r6), o5 -= t13(o5), e18 = Ja(e18);
    }
    return {
        hasBOM: i6,
        text: e18,
        options: Ka(e18, Object.assign({
        }, t12, {
            cursorOffset: n8,
            rangeStart: r6,
            rangeEnd: o5,
            endOfLine: u4
        }))
    };
}
function Za(e18, t12) {
    let { hasBOM: n8 , text: r6 , options: o5  } = Qa(e18, za(t12));
    const u4 = Vi.resolveParser(o5), i6 = !u4.hasPragma || u4.hasPragma(r6);
    if (o5.requirePragma && !i6) return {
        formatted: e18,
        cursorOffset: t12.cursorOffset
    };
    let a5;
    return o5.rangeStart > 0 || o5.rangeEnd < r6.length ? a5 = (function(e19, t13) {
        const { ast: n9 , text: r7  } = Vi.parse(e19, t13), { rangeStart: o6 , rangeEnd: u5  } = _a.calculateRange(r7, t13, n9), i7 = r7.slice(o6, u5), a6 = Math.min(o6, r7.lastIndexOf("\n", o6) + 1), s4 = r7.slice(a6, o6).match(/^\s*/)[0], l5 = $a(s4, t13.tabWidth), c6 = Xa(i7, Object.assign({
        }, t13, {
            rangeStart: 0,
            rangeEnd: 1 / 0,
            cursorOffset: t13.cursorOffset > o6 && t13.cursorOffset < u5 ? t13.cursorOffset - o6 : -1,
            endOfLine: "lf"
        }), l5), p6 = c6.formatted.trimEnd();
        let { cursorOffset: d6  } = t13;
        d6 >= u5 ? d6 = t13.cursorOffset + (p6.length - i7.length) : c6.cursorOffset >= 0 && (d6 = c6.cursorOffset + o6);
        let f5 = r7.slice(0, o6) + p6 + r7.slice(u5);
        if ("lf" !== t13.endOfLine) {
            const e20 = Wa(t13.endOfLine);
            d6 >= 0 && "\r\n" === e20 && (d6 += Ua(f5.slice(0, d6), "\n")), f5 = f5.replace(/\n/g, e20);
        }
        return {
            formatted: f5,
            cursorOffset: d6
        };
    })(r6, o5) : (!i6 && o5.insertPragma && o5.printer.insertPragma && (r6 = o5.printer.insertPragma(r6)), a5 = Xa(r6, o5)), n8 && (a5.formatted = "\ufeff" + a5.formatted, a5.cursorOffset >= 0 && a5.cursorOffset++), a5;
}
var es = {
    formatWithCursor: Za,
    parse (e, t, n) {
        const { text: r6 , options: o5  } = Qa(e, za(t)), u4 = Vi.parse(r6, o5);
        return (n && (u4.ast = Gi(u4.ast, o5)), u4);
    },
    formatAST (e, t) {
        t = za(t);
        const n8 = Oa(e, t);
        return Ra(n8, t);
    },
    formatDoc: (e18, t12)=>Za(Va(e18), Object.assign({
        }, t12, {
            parser: "babel"
        })).formatted
    ,
    printToDoc (e, t) {
        t = za(t);
        const { ast: n8 , text: r6  } = Vi.parse(e, t);
        return (Ha(r6, n8, t), Oa(n8, t));
    },
    printDocToString: (e18, t12)=>Ra(e18, za(t12))
};
const { getMaxContinuousCount: ts , getStringWidth: ns , getAlignmentSize: rs , getIndentSize: os , skip: us , skipWhitespace: is , skipSpaces: as , skipNewline: ss , skipToLineEnd: ls , skipEverythingButNewLine: cs , skipInlineComment: ps , skipTrailingComment: ds , hasNewline: fs , hasNewlineInRange: hs , hasSpaces: ms , isNextLineEmpty: gs , isNextLineEmptyAfterIndex: Ds , isPreviousLineEmpty: ys , getNextNonSpaceNonCommentCharacterIndex: Es , makeString: Cs , addLeadingComment: bs , addDanglingComment: vs1 , addTrailingComment: As  } = Nt1;
var Fs = {
    getMaxContinuousCount: ts,
    getStringWidth: ns,
    getAlignmentSize: rs,
    getIndentSize: os,
    skip: us,
    skipWhitespace: is,
    skipSpaces: as,
    skipNewline: ss,
    skipToLineEnd: ls,
    skipEverythingButNewLine: cs,
    skipInlineComment: ps,
    skipTrailingComment: ds,
    hasNewline: fs,
    hasNewlineInRange: hs,
    hasSpaces: ms,
    isNextLineEmpty: gs,
    isNextLineEmptyAfterIndex: Ds,
    isPreviousLineEmpty: ys,
    getNextNonSpaceNonCommentCharacterIndex: Es,
    makeString: Cs,
    addLeadingComment: bs,
    addDanglingComment: vs1,
    addTrailingComment: As
}, xs1 = function(t12, n8) {
    const { languageId: r6  } = t12, o5 = e1(t12, [
        "languageId"
    ]);
    return Object.assign({
        linguistLanguageId: r6
    }, o5, n8(t12));
}, Ss = je(function(e18) {
    !(function() {
        function t12(e19) {
            if (null == e19) return !1;
            switch(e19.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                    return !0;
            }
            return !1;
        }
        function n8(e19) {
            switch(e19.type){
                case "IfStatement":
                    return null != e19.alternate ? e19.alternate : e19.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                    return e19.body;
            }
            return null;
        }
        e18.exports = {
            isExpression: function(e19) {
                if (null == e19) return !1;
                switch(e19.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                        return !0;
                }
                return !1;
            },
            isStatement: t12,
            isIterationStatement: function(e19) {
                if (null == e19) return !1;
                switch(e19.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                        return !0;
                }
                return !1;
            },
            isSourceElement: function(e19) {
                return t12(e19) || null != e19 && "FunctionDeclaration" === e19.type;
            },
            isProblematicIfStatement: function(e19) {
                var t13;
                if ("IfStatement" !== e19.type) return !1;
                if (null == e19.alternate) return !1;
                t13 = e19.consequent;
                do {
                    if ("IfStatement" === t13.type && null == t13.alternate) return !0;
                    t13 = n8(t13);
                }while (t13)
                return !1;
            },
            trailingStatement: n8
        };
    })();
}), ws = je(function(e18) {
    !(function() {
        var t12, n8, r6, o5, u4, i6;
        function a5(e19) {
            return e19 <= 65535 ? String.fromCharCode(e19) : String.fromCharCode(Math.floor((e19 - 65536) / 1024) + 55296) + String.fromCharCode((e19 - 65536) % 1024 + 56320);
        }
        for(n8 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        }, t12 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        }, r6 = [
            5760,
            8192,
            8193,
            8194,
            8195,
            8196,
            8197,
            8198,
            8199,
            8200,
            8201,
            8202,
            8239,
            8287,
            12288,
            65279
        ], o5 = new Array(128), i6 = 0; i6 < 128; ++i6)o5[i6] = i6 >= 97 && i6 <= 122 || i6 >= 65 && i6 <= 90 || 36 === i6 || 95 === i6;
        for(u4 = new Array(128), i6 = 0; i6 < 128; ++i6)u4[i6] = i6 >= 97 && i6 <= 122 || i6 >= 65 && i6 <= 90 || i6 >= 48 && i6 <= 57 || 36 === i6 || 95 === i6;
        e18.exports = {
            isDecimalDigit: function(e19) {
                return 48 <= e19 && e19 <= 57;
            },
            isHexDigit: function(e19) {
                return 48 <= e19 && e19 <= 57 || 97 <= e19 && e19 <= 102 || 65 <= e19 && e19 <= 70;
            },
            isOctalDigit: function(e19) {
                return e19 >= 48 && e19 <= 55;
            },
            isWhiteSpace: function(e19) {
                return 32 === e19 || 9 === e19 || 11 === e19 || 12 === e19 || 160 === e19 || e19 >= 5760 && r6.indexOf(e19) >= 0;
            },
            isLineTerminator: function(e19) {
                return 10 === e19 || 13 === e19 || 8232 === e19 || 8233 === e19;
            },
            isIdentifierStartES5: function(e19) {
                return e19 < 128 ? o5[e19] : n8.NonAsciiIdentifierStart.test(a5(e19));
            },
            isIdentifierPartES5: function(e19) {
                return e19 < 128 ? u4[e19] : n8.NonAsciiIdentifierPart.test(a5(e19));
            },
            isIdentifierStartES6: function(e19) {
                return e19 < 128 ? o5[e19] : t12.NonAsciiIdentifierStart.test(a5(e19));
            },
            isIdentifierPartES6: function(e19) {
                return e19 < 128 ? u4[e19] : t12.NonAsciiIdentifierPart.test(a5(e19));
            }
        };
    })();
}), Ts = je(function(e18) {
    !(function() {
        var t12 = ws;
        function n8(e19, t13) {
            return !(!t13 && "yield" === e19) && r6(e19, t13);
        }
        function r6(e19, t13) {
            if (t13 && (function(e20) {
                switch(e20){
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                        return !0;
                    default:
                        return !1;
                }
            })(e19)) return !0;
            switch(e19.length){
                case 2:
                    return "if" === e19 || "in" === e19 || "do" === e19;
                case 3:
                    return "var" === e19 || "for" === e19 || "new" === e19 || "try" === e19;
                case 4:
                    return "this" === e19 || "else" === e19 || "case" === e19 || "void" === e19 || "with" === e19 || "enum" === e19;
                case 5:
                    return "while" === e19 || "break" === e19 || "catch" === e19 || "throw" === e19 || "const" === e19 || "yield" === e19 || "class" === e19 || "super" === e19;
                case 6:
                    return "return" === e19 || "typeof" === e19 || "delete" === e19 || "switch" === e19 || "export" === e19 || "import" === e19;
                case 7:
                    return "default" === e19 || "finally" === e19 || "extends" === e19;
                case 8:
                    return "function" === e19 || "continue" === e19 || "debugger" === e19;
                case 10:
                    return "instanceof" === e19;
                default:
                    return !1;
            }
        }
        function o5(e19, t13) {
            return "null" === e19 || "true" === e19 || "false" === e19 || n8(e19, t13);
        }
        function u4(e19, t13) {
            return "null" === e19 || "true" === e19 || "false" === e19 || r6(e19, t13);
        }
        function i6(e19) {
            var n9, r7, o6;
            if (0 === e19.length) return !1;
            if (o6 = e19.charCodeAt(0), !t12.isIdentifierStartES5(o6)) return !1;
            for(n9 = 1, r7 = e19.length; n9 < r7; ++n9)if (o6 = e19.charCodeAt(n9), !t12.isIdentifierPartES5(o6)) return !1;
            return !0;
        }
        function a5(e19) {
            var n9, r7, o6, u5, i7;
            if (0 === e19.length) return !1;
            for(i7 = t12.isIdentifierStartES6, n9 = 0, r7 = e19.length; n9 < r7; ++n9){
                if (55296 <= (o6 = e19.charCodeAt(n9)) && o6 <= 56319) {
                    if ((++n9) >= r7) return !1;
                    if (!(56320 <= (u5 = e19.charCodeAt(n9)) && u5 <= 57343)) return !1;
                    o6 = 1024 * (o6 - 55296) + (u5 - 56320) + 65536;
                }
                if (!i7(o6)) return !1;
                i7 = t12.isIdentifierPartES6;
            }
            return !0;
        }
        e18.exports = {
            isKeywordES5: n8,
            isKeywordES6: r6,
            isReservedWordES5: o5,
            isReservedWordES6: u4,
            isRestrictedWord: function(e19) {
                return "eval" === e19 || "arguments" === e19;
            },
            isIdentifierNameES5: i6,
            isIdentifierNameES6: a5,
            isIdentifierES5: function(e19, t13) {
                return i6(e19) && !o5(e19, t13);
            },
            isIdentifierES6: function(e19, t13) {
                return a5(e19) && !u4(e19, t13);
            }
        };
    })();
});
const Bs = je(function(e18, t12) {
    t12.ast = Ss, t12.code = ws, t12.keyword = Ts;
}).keyword.isIdentifierNameES5, { getLast: Ns , hasNewline: ks1 , hasNewlineInRange: Ps , skipWhitespace: Os  } = Nt1, { locStart: Is1 , locEnd: Ls , hasSameLocStart: Ms  } = ei, js = new RegExp("^".concat("(?:(?=.)\\s)", "*:")), _s = new RegExp("^".concat("(?:(?=.)\\s)", "*::"));
function Ks1(e18) {
    return Ys(e18) || Ms(e18, e18.value);
}
function ul(e18, t12) {
    if (Xs(t12)) return yl(t12);
    return t12.comments && t12.comments.some((t13)=>t13.leading && ks1(e18, Ls(t13))
    );
}
var Cl = {
    classChildNeedsASIProtection: function(e18) {
        if (e18) {
            if (e18.static || e18.accessibility) return !1;
            if (!e18.computed) {
                const t12 = e18.key && e18.key.name;
                if ("in" === t12 || "instanceof" === t12) return !0;
            }
            switch(e18.type){
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                    return e18.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    {
                        const t12 = e18.value ? e18.value.async : e18.async, n8 = e18.value ? e18.value.generator : e18.generator;
                        return !t12 && "get" !== e18.kind && "set" !== e18.kind && !(!e18.computed && !n8);
                    }
                case "TSIndexSignature":
                    return !0;
                default:
                    return !1;
            }
        }
    },
    classPropMayCauseASIProblems: function(e18) {
        const t12 = e18.getNode();
        if ("ClassProperty" !== t12.type && "FieldDefinition" !== t12.type) return !1;
        const n8 = t12.key && t12.key.name;
        return !("static" !== n8 && "get" !== n8 && "set" !== n8 || t12.value || t12.typeAnnotation) || void 0;
    },
    getFunctionParameters: ml,
    iterateFunctionParametersPath: function(e18, t12) {
        const n8 = e18.getValue();
        let r6 = 0;
        const o5 = (e19)=>t12(e19, r6++)
        ;
        n8.this && e18.call(o5, "this"), Array.isArray(n8.parameters) ? e18.each(o5, "parameters") : Array.isArray(n8.params) && e18.each(o5, "params"), n8.rest && e18.call(o5, "rest");
    },
    getCallArguments: function(e18) {
        if (gl.has(e18)) return gl.get(e18);
        const t12 = "ImportExpression" === e18.type ? [
            e18.source
        ] : e18.arguments;
        return (gl.set(e18, t12), t12);
    },
    iterateCallArgumentsPath: function(e18, t12) {
        "ImportExpression" === e18.getValue().type ? e18.call((e19)=>t12(e19, 0)
        , "source") : e18.each(t12, "arguments");
    },
    hasRestParameter: function(e18) {
        if (e18.rest) return !0;
        const t12 = ml(e18);
        return t12.length > 0 && "RestElement" === Ns(t12).type;
    },
    getLeftSidePathName: function(e18, t12) {
        if (t12.expressions) return [
            "expressions",
            0
        ];
        if (t12.left) return [
            "left"
        ];
        if (t12.test) return [
            "test"
        ];
        if (t12.object) return [
            "object"
        ];
        if (t12.callee) return [
            "callee"
        ];
        if (t12.tag) return [
            "tag"
        ];
        if (t12.argument) return [
            "argument"
        ];
        if (t12.expression) return [
            "expression"
        ];
        throw new Error("Unexpected node has no left side.");
    },
    getParentExportDeclaration: function(e18) {
        const t12 = e18.getParentNode();
        return "declaration" === e18.getName() && Ws1(t12) ? t12 : null;
    },
    getTypeScriptMappedTypeModifier: function(e18, t12) {
        return "+" === e18 ? "+" + t12 : "-" === e18 ? "-" + t12 : t12;
    },
    hasDanglingComments: function(e18) {
        return e18.comments && e18.comments.some((e19)=>!e19.leading && !e19.trailing
        );
    },
    hasFlowAnnotationComment: function(e18) {
        return e18 && $s(e18[0]) && _s.test(e18[0].value);
    },
    hasFlowShorthandAnnotationComment: function(e18) {
        return e18.extra && e18.extra.parenthesized && e18.trailingComments && $s(e18.trailingComments[0]) && js.test(e18.trailingComments[0].value);
    },
    hasLeadingComment: function(e18) {
        return e18.comments && e18.comments.some((e19)=>e19.leading
        );
    },
    hasLeadingOwnLineComment: ul,
    hasNakedLeftSide: Vs,
    hasNewlineBetweenOrAfterDecorators: function(e18, t12) {
        return Ps(t12.originalText, Is1(e18.decorators[0]), Ls(Ns(e18.decorators))) || ks1(t12.originalText, Ls(Ns(e18.decorators)));
    },
    hasNgSideEffect: function(e18) {
        return Rs(e18.getValue(), (e19)=>{
            switch(e19.type){
                case void 0:
                    return !1;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                    return !0;
            }
        });
    },
    hasNode: Rs,
    hasPrettierIgnore: function(e18) {
        return El(e18) || function(e19) {
            const t12 = e19.getValue(), n8 = e19.getParentNode();
            if (!(n8 && t12 && Xs(t12) && Xs(n8))) return !1;
            let r6 = null;
            for(let e20 = n8.children.indexOf(t12); e20 > 0; e20--){
                const t13 = n8.children[e20 - 1];
                if ("JSXText" !== t13.type || ol(t13)) {
                    r6 = t13;
                    break;
                }
            }
            return r6 && "JSXExpressionContainer" === r6.type && "JSXEmptyExpression" === r6.expression.type && r6.expression.comments && r6.expression.comments.some((e21)=>Dl(e21)
            );
        }(e18);
    },
    hasTrailingComment: function(e18) {
        return e18.comments && e18.comments.some((e19)=>e19.trailing
        );
    },
    hasTrailingLineComment: function(e18) {
        return e18.comments && e18.comments.some((e19)=>e19.trailing && !$s(e19)
        );
    },
    hasIgnoreComment: El,
    hasNodeIgnoreComment: yl,
    identity: function(e18) {
        return e18;
    },
    isBinaryish: function(e18) {
        return Qs.has(e18.type);
    },
    isBlockComment: $s,
    isLineComment: function(e18) {
        return "Line" === e18.type || "CommentLine" === e18.type || "SingleLine" === e18.type || "HashbangComment" === e18.type || "HTMLOpen" === e18.type || "HTMLClose" === e18.type;
    },
    isPrettierIgnoreComment: Dl,
    isCallOrOptionalCallExpression: tl,
    isEmptyJSXElement: function(e18) {
        if (0 === e18.children.length) return !0;
        if (e18.children.length > 1) return !1;
        const t12 = e18.children[0];
        return Us(t12) && !ol(t12);
    },
    isExportDeclaration: Ws1,
    isFlowAnnotationComment: function(e18, t12) {
        const n8 = Is1(t12), r6 = Os(e18, Ls(t12));
        return !1 !== r6 && "/*" === e18.slice(n8, n8 + 2) && "*/" === e18.slice(r6, r6 + 2);
    },
    isFunctionCompositionArgs: function(e18) {
        if (e18.length <= 1) return !1;
        let t12 = 0;
        for (const n8 of e18)if (Gs(n8)) {
            if ((t12 += 1, t12 > 1)) return !0;
        } else if (tl(n8)) for (const e19 of n8.arguments)if (Gs(e19)) return !0;
        return !1;
    },
    isFunctionNotation: Ks1,
    isFunctionOrArrowExpression: Gs,
    isGetterOrSetter: Ys,
    isJestEachTemplateLiteral: function(e18, t12) {
        const n8 = /^[fx]?(describe|it|test)$/;
        return "TaggedTemplateExpression" === t12.type && t12.quasi === e18 && "MemberExpression" === t12.tag.type && "Identifier" === t12.tag.property.type && "each" === t12.tag.property.name && ("Identifier" === t12.tag.object.type && n8.test(t12.tag.object.name) || "MemberExpression" === t12.tag.object.type && "Identifier" === t12.tag.object.property.type && ("only" === t12.tag.object.property.name || "skip" === t12.tag.object.property.name) && "Identifier" === t12.tag.object.object.type && n8.test(t12.tag.object.object.name));
    },
    isJSXNode: Xs,
    isJSXWhitespaceExpression: function(e18) {
        return "JSXExpressionContainer" === e18.type && Us(e18.expression) && " " === e18.expression.value && !e18.expression.comments;
    },
    isLastStatement: function(e18) {
        const t12 = e18.getParentNode();
        if (!t12) return !0;
        const n8 = e18.getValue(), r6 = (t12.body || t12.consequent).filter((e19)=>"EmptyStatement" !== e19.type
        );
        return r6[r6.length - 1] === n8;
    },
    isLiteral: Us,
    isLongCurriedCallExpression: function(e18) {
        const t12 = e18.getValue(), n8 = e18.getParentNode();
        return tl(t12) && tl(n8) && n8.callee === t12 && t12.arguments.length > n8.arguments.length && n8.arguments.length > 0;
    },
    isSimpleCallArgument: function e18(t12, n8) {
        if (n8 >= 2) return !1;
        const r6 = (t13)=>e18(t13, n8 + 1)
        , o5 = "Literal" === t12.type && "regex" in t12 && t12.regex.pattern || "RegExpLiteral" === t12.type && t12.pattern;
        return !(o5 && o5.length > 5) && ("Literal" === t12.type || "BigIntLiteral" === t12.type || "DecimalLiteral" === t12.type || "BooleanLiteral" === t12.type || "NullLiteral" === t12.type || "NumericLiteral" === t12.type || "RegExpLiteral" === t12.type || "StringLiteral" === t12.type || "Identifier" === t12.type || "ThisExpression" === t12.type || "Super" === t12.type || "PrivateName" === t12.type || "ArgumentPlaceholder" === t12.type || "Import" === t12.type || ("TemplateLiteral" === t12.type ? t12.expressions.every(r6) : "ObjectExpression" === t12.type ? t12.properties.every((e19)=>!e19.computed && (e19.shorthand || e19.value && r6(e19.value))
        ) : "ArrayExpression" === t12.type ? t12.elements.every((e19)=>null === e19 || r6(e19)
        ) : "ImportExpression" === t12.type ? r6(t12.source) : "CallExpression" === t12.type || "OptionalCallExpression" === t12.type || "NewExpression" === t12.type ? e18(t12.callee, n8) && t12.arguments.every(r6) : "MemberExpression" === t12.type || "OptionalMemberExpression" === t12.type ? e18(t12.object, n8) && e18(t12.property, n8) : "UnaryExpression" !== t12.type || "!" !== t12.operator && "-" !== t12.operator ? "TSNonNullExpression" === t12.type && e18(t12.expression, n8) : e18(t12.argument, n8)));
    },
    isMeaningfulJSXText: ol,
    isMemberExpressionChain: function e18(t12) {
        return ("MemberExpression" === t12.type || "OptionalMemberExpression" === t12.type) && ("Identifier" === t12.object.type || e18(t12.object));
    },
    isMemberish: function(e19) {
        return "MemberExpression" === e19.type || "OptionalMemberExpression" === e19.type || "BindExpression" === e19.type && Boolean(e19.object);
    },
    isNgForOf: function(e19, t12, n8) {
        return "NGMicrosyntaxKeyedExpression" === e19.type && "of" === e19.key.name && 1 === t12 && "NGMicrosyntaxLet" === n8.body[0].type && null === n8.body[0].value;
    },
    isNumericLiteral: Js,
    isObjectType: function(e19) {
        return "ObjectTypeAnnotation" === e19.type || "TSTypeLiteral" === e19.type;
    },
    isObjectTypePropertyAFunction: function(e19) {
        return !("ObjectTypeProperty" !== e19.type && "ObjectTypeInternalSlot" !== e19.type || "FunctionTypeAnnotation" !== e19.value.type || e19.static || Ks1(e19));
    },
    isSimpleType: function(e19) {
        return !!e19 && (!("GenericTypeAnnotation" !== e19.type && "TSTypeReference" !== e19.type || e19.typeParameters) || !!Zs.has(e19.type));
    },
    isSimpleNumber: il,
    isSimpleTemplateLiteral: function(e19) {
        let t12 = "expressions";
        "TSTemplateLiteralType" === e19.type && (t12 = "types");
        const n8 = e19[t12];
        return 0 !== n8.length && n8.every((e20)=>{
            if (e20.comments) return !1;
            if ("Identifier" === e20.type || "ThisExpression" === e20.type) return !0;
            if ("MemberExpression" === e20.type || "OptionalMemberExpression" === e20.type) {
                let t13 = e20;
                for(; "MemberExpression" === t13.type || "OptionalMemberExpression" === t13.type;){
                    if ("Identifier" !== t13.property.type && "Literal" !== t13.property.type && "StringLiteral" !== t13.property.type && "NumericLiteral" !== t13.property.type) return !1;
                    if (t13 = t13.object, t13.comments) return !1;
                }
                return "Identifier" === t13.type || "ThisExpression" === t13.type;
            }
            return !1;
        });
    },
    isStringLiteral: zs,
    isStringPropSafeToUnquote: function(e19, t12) {
        return "json" !== t12.parser && zs(e19.key) && sl(e19.key).slice(1, -1) === e19.key.value && (Bs(e19.key.value) && !(("typescript" === t12.parser || "babel-ts" === t12.parser) && "ClassProperty" === e19.type) || il(e19.key.value) && String(Number(e19.key.value)) === e19.key.value && ("babel" === t12.parser || "espree" === t12.parser || "meriyah" === t12.parser));
    },
    isTemplateOnItsOwnLine: function(e19, t12) {
        return ("TemplateLiteral" === e19.type && al(e19) || "TaggedTemplateExpression" === e19.type && al(e19.quasi)) && !ks1(t12, Is1(e19), {
            backwards: !0
        });
    },
    isTestCall: function e18(t12, n8) {
        if ("CallExpression" !== t12.type) return !1;
        if (1 === t12.arguments.length) {
            if (Hs(t12) && n8 && e18(n8)) return Gs(t12.arguments[0]);
            if ("Identifier" === (r6 = t12).callee.type && /^(before|after)(Each|All)$/.test(r6.callee.name) && 1 === r6.arguments.length) return Hs(t12.arguments[0]);
        } else if ((2 === t12.arguments.length || 3 === t12.arguments.length) && ("Identifier" === t12.callee.type && el.test(t12.callee.name) || function(e19) {
            return ("MemberExpression" === e19.callee.type || "OptionalMemberExpression" === e19.callee.type) && "Identifier" === e19.callee.object.type && "Identifier" === e19.callee.property.type && el.test(e19.callee.object.name) && ("only" === e19.callee.property.name || "skip" === e19.callee.property.name);
        }(t12)) && (function(e19) {
            return "TemplateLiteral" === e19.type;
        }(t12.arguments[0]) || zs(t12.arguments[0]))) return !(t12.arguments[2] && !Js(t12.arguments[2])) && ((2 === t12.arguments.length ? Gs(t12.arguments[1]) : function(e19) {
            return "FunctionExpression" === e19.type || "ArrowFunctionExpression" === e19.type && "BlockStatement" === e19.body.type;
        }(t12.arguments[1]) && ml(t12.arguments[1]).length <= 1) || Hs(t12.arguments[1]));
        var r6;
        return !1;
    },
    isTheOnlyJSXElementInMarkdown: function(e19, t12) {
        if ("markdown" !== e19.parentParser && "mdx" !== e19.parentParser) return !1;
        const n8 = t12.getNode();
        if (!n8.expression || !Xs(n8.expression)) return !1;
        const r6 = t12.getParentNode();
        return "Program" === r6.type && 1 === r6.body.length;
    },
    isTSXFile: function(e19) {
        return e19.filepath && /\.tsx$/i.test(e19.filepath);
    },
    isTypeAnnotationAFunction: function(e19) {
        return !("TypeAnnotation" !== e19.type && "TSTypeAnnotation" !== e19.type || "FunctionTypeAnnotation" !== e19.typeAnnotation.type || e19.static || Ms(e19, e19.typeAnnotation));
    },
    matchJsxWhitespaceRegex: nl,
    needsHardlineAfterDanglingComment: function(e19) {
        if (!e19.comments) return !1;
        const t12 = Ns(e19.comments.filter((e20)=>!e20.leading && !e20.trailing
        ));
        return t12 && !$s(t12);
    },
    rawText: sl,
    returnArgumentHasLeadingComment: function(e19, t12) {
        if (ul(e19.originalText, t12)) return !0;
        if (Vs(t12)) {
            let r6, o5 = t12;
            for(; r6 = (n8 = o5).expressions ? n8.expressions[0] : n8.left || n8.test || n8.callee || n8.object || n8.tag || n8.argument || n8.expression;)if ((o5 = r6, ul(e19.originalText, o5))) return !0;
        }
        var n8;
        return !1;
    },
    shouldPrintComma: function(e19, t12 = "es5") {
        return "es5" === e19.trailingComma && "es5" === t12 || "all" === e19.trailingComma && ("all" === t12 || "es5" === t12);
    },
    isBitwiseOperator: function(e19) {
        return !!pl[e19] || "|" === e19 || "^" === e19 || "&" === e19;
    },
    shouldFlatten: function(e19, t12) {
        return fl(t12) === fl(e19) && ("**" !== e19 && ((!ll[e19] || !ll[t12]) && (!("%" === t12 && cl[e19] || "%" === e19 && cl[t12]) && ((t12 === e19 || !cl[t12] || !cl[e19]) && (!pl[e19] || !pl[t12])))));
    },
    startsWithNoLookaheadToken: function e18(t12, n8) {
        switch((t12 = function(e19) {
            for(; e19.left;)e19 = e19.left;
            return e19;
        }(t12)).type){
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
                return n8;
            case "ObjectExpression":
                return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
                return e18(t12.object, n8);
            case "TaggedTemplateExpression":
                return "FunctionExpression" !== t12.tag.type && e18(t12.tag, n8);
            case "CallExpression":
            case "OptionalCallExpression":
                return "FunctionExpression" !== t12.callee.type && e18(t12.callee, n8);
            case "ConditionalExpression":
                return e18(t12.test, n8);
            case "UpdateExpression":
                return !t12.prefix && e18(t12.argument, n8);
            case "BindExpression":
                return t12.object && e18(t12.object, n8);
            case "SequenceExpression":
                return e18(t12.expressions[0], n8);
            case "TSAsExpression":
                return e18(t12.expression, n8);
            default:
                return !1;
        }
    },
    getPrecedence: fl
};
const { getLast: bl , hasNewline: vl , getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Al , getNextNonSpaceNonCommentCharacter: Fl , hasNewlineInRange: xl , addLeadingComment: Sl , addTrailingComment: wl , addDanglingComment: Tl , getNextNonSpaceNonCommentCharacterIndex: Bl  } = Nt1, { isBlockComment: Nl , getFunctionParameters: kl , isPrettierIgnoreComment: Pl , isJSXNode: Ol , hasFlowShorthandAnnotationComment: Il , hasFlowAnnotationComment: Ll , hasIgnoreComment: Ml  } = Cl, { locStart: jl , locEnd: _l  } = ei;
function Rl(e18, t12) {
    const n8 = (e18.body || e18.properties).find(({ type: e19  })=>"EmptyStatement" !== e19
    );
    n8 ? Sl(n8, t12) : Tl(e18, t12);
}
function Vl(e18, t12) {
    "BlockStatement" === e18.type ? Rl(e18, t12) : Sl(e18, t12);
}
function $l(e18, t12) {
    const { precedingNode: n8 , enclosingNode: r6 , followingNode: o5  } = e18;
    if (!r6 || "IfStatement" !== r6.type || !o5) return !1;
    return ")" === Fl(t12, e18, _l) ? (wl(n8, e18), !0) : n8 === r6.consequent && o5 === r6.alternate ? ("BlockStatement" === n8.type ? wl(n8, e18) : Tl(r6, e18), !0) : "BlockStatement" === o5.type ? (Rl(o5, e18), !0) : "IfStatement" === o5.type ? (Vl(o5.consequent, e18), !0) : r6.consequent === o5 && (Sl(o5, e18), !0);
}
function ql(e18, t12) {
    const { precedingNode: n8 , enclosingNode: r6 , followingNode: o5  } = e18;
    if (!r6 || "WhileStatement" !== r6.type || !o5) return !1;
    return ")" === Fl(t12, e18, _l) ? (wl(n8, e18), !0) : "BlockStatement" === o5.type ? (Rl(o5, e18), !0) : r6.body === o5 && (Sl(o5, e18), !0);
}
function Wl(e18) {
    const { precedingNode: t12 , enclosingNode: n8 , followingNode: r6  } = e18;
    return !(!n8 || "TryStatement" !== n8.type && "CatchClause" !== n8.type || !r6) && ("CatchClause" === n8.type && t12 ? (wl(t12, e18), !0) : "BlockStatement" === r6.type ? (Rl(r6, e18), !0) : "TryStatement" === r6.type ? (Vl(r6.finalizer, e18), !0) : "CatchClause" === r6.type && (Vl(r6.body, e18), !0));
}
function Ul(e18) {
    const { precedingNode: t12 , enclosingNode: n8 , followingNode: r6  } = e18;
    if (n8 && ("ClassDeclaration" === n8.type || "ClassExpression" === n8.type || "DeclareClass" === n8.type || "DeclareInterface" === n8.type || "InterfaceDeclaration" === n8.type || "TSInterfaceDeclaration" === n8.type)) {
        if (n8.decorators && n8.decorators.length > 0 && (!r6 || "Decorator" !== r6.type)) return wl(n8.decorators[n8.decorators.length - 1], e18), !0;
        if (n8.body && r6 === n8.body) return Rl(n8.body, e18), !0;
        if (r6) for (const o5 of [
            "implements",
            "extends",
            "mixins"
        ])if (n8[o5] && r6 === n8[o5][0]) return !t12 || t12 !== n8.id && t12 !== n8.typeParameters && t12 !== n8.superClass ? Tl(n8, e18, o5) : wl(t12, e18), !0;
    }
    return !1;
}
function Jl(e18, t12) {
    const { precedingNode: n8 , enclosingNode: r6  } = e18;
    return (r6 && n8 && ("Property" === r6.type || "TSDeclareMethod" === r6.type || "TSAbstractMethodDefinition" === r6.type) && "Identifier" === n8.type && r6.key === n8 && ":" !== Fl(t12, n8, _l) || !(!n8 || !r6 || "Decorator" !== n8.type || "ClassMethod" !== r6.type && "ClassProperty" !== r6.type && "FieldDefinition" !== r6.type && "TSAbstractClassProperty" !== r6.type && "TSAbstractMethodDefinition" !== r6.type && "TSDeclareMethod" !== r6.type && "MethodDefinition" !== r6.type)) && (wl(n8, e18), !0);
}
function zl(e18, t12) {
    const { precedingNode: n8 , enclosingNode: r6 , followingNode: o5  } = e18;
    if (n8 && "FunctionTypeParam" === n8.type && r6 && "FunctionTypeAnnotation" === r6.type && o5 && "FunctionTypeParam" !== o5.type) return wl(n8, e18), !0;
    if (n8 && ("Identifier" === n8.type || "AssignmentPattern" === n8.type) && r6 && Kl(r6) && ")" === Fl(t12, e18, _l)) return wl(n8, e18), !0;
    if (r6 && "FunctionDeclaration" === r6.type && o5 && "BlockStatement" === o5.type) {
        const n9 = (()=>{
            const e19 = kl(r6);
            if (0 !== e19.length) return Al(t12, _l(bl(e19)));
            const n10 = Al(t12, _l(r6.id));
            return !1 !== n10 && Al(t12, n10 + 1);
        })();
        if (jl(e18) > n9) return Rl(o5, e18), !0;
    }
    return !1;
}
function Gl(e18) {
    const { enclosingNode: t12  } = e18;
    return !(!t12 || "ImportSpecifier" !== t12.type) && (Sl(t12, e18), !0);
}
function Hl(e18) {
    const { enclosingNode: t12  } = e18;
    return !(!t12 || "LabeledStatement" !== t12.type) && (Sl(t12, e18), !0);
}
function Xl(e18, t12, n8) {
    const { enclosingNode: r6  } = e18;
    return t12 && t12.body && 0 === t12.body.length ? (n8 ? Tl(t12, e18) : Sl(t12, e18), !0) : !(!r6 || "Program" !== r6.type || 0 !== r6.body.length || !r6.directives || 0 !== r6.directives.length) && (n8 ? Tl(r6, e18) : Sl(r6, e18), !0);
}
function Yl(e18) {
    const { enclosingNode: t12 , followingNode: n8  } = e18;
    if (Pl(e18) && t12 && "TSMappedType" === t12.type && n8 && "TSTypeParameter" === n8.type && n8.constraint) return t12.prettierIgnore = !0, e18.unignore = !0, !0;
}
function Ql(e18) {
    return Nl(e18) && "*" === e18.value[0] && /@type\b/.test(e18.value);
}
var Zl = {
    handleOwnLineComment: function(e18, t12, n8, r6, o5) {
        return Yl(e18) || zl(e18, t12) || function(e19) {
            const { enclosingNode: t13 , followingNode: n9  } = e19;
            if (t13 && ("MemberExpression" === t13.type || "OptionalMemberExpression" === t13.type) && n9 && "Identifier" === n9.type) return Sl(t13, e19), !0;
            return !1;
        }(e18) || $l(e18, t12) || ql(e18, t12) || Wl(e18) || Ul(e18) || Gl(e18) || function(e19) {
            const { enclosingNode: t13  } = e19;
            if (t13 && ("ForInStatement" === t13.type || "ForOfStatement" === t13.type)) return Sl(t13, e19), !0;
            return !1;
        }(e18) || function(e19) {
            const { precedingNode: t13 , enclosingNode: n9 , followingNode: r7  } = e19;
            if (n9 && ("UnionTypeAnnotation" === n9.type || "TSUnionType" === n9.type)) return Pl(e19) && (r7.prettierIgnore = !0, e19.unignore = !0), !!t13 && (wl(t13, e19), !0);
            r7 && ("UnionTypeAnnotation" === r7.type || "TSUnionType" === r7.type) && Pl(e19) && (r7.types[0].prettierIgnore = !0, e19.unignore = !0);
            return !1;
        }(e18) || Xl(e18, r6, o5) || function(e19, t13) {
            const { precedingNode: n9 , enclosingNode: r7  } = e19;
            if (n9 && "ImportSpecifier" === n9.type && r7 && "ImportDeclaration" === r7.type && vl(t13, _l(e19))) return wl(n9, e19), !0;
            return !1;
        }(e18, t12) || function(e19) {
            const { enclosingNode: t13  } = e19;
            if (t13 && "AssignmentPattern" === t13.type) return Sl(t13, e19), !0;
            return !1;
        }(e18) || Jl(e18, t12) || Hl(e18);
    },
    handleEndOfLineComment: function(e18, t12, n8, r6, o5) {
        return function(e19) {
            const { followingNode: t13  } = e19;
            if (t13 && Ql(e19)) return Sl(t13, e19), !0;
            return !1;
        }(e18) || zl(e18, t12) || function(e19, t13) {
            const { precedingNode: n9 , enclosingNode: r7 , followingNode: o6  } = e19, u4 = n9 && !xl(t13, _l(n9), jl(e19));
            if ((!n9 || !u4) && r7 && ("ConditionalExpression" === r7.type || "TSConditionalType" === r7.type) && o6) return Sl(o6, e19), !0;
            return !1;
        }(e18, t12) || Gl(e18) || $l(e18, t12) || ql(e18, t12) || Wl(e18) || Ul(e18) || Hl(e18) || function(e19) {
            const { precedingNode: t13 , enclosingNode: n9  } = e19;
            if (n9 && ("CallExpression" === n9.type || "OptionalCallExpression" === n9.type) && t13 && n9.callee === t13 && n9.arguments.length > 0) return Sl(n9.arguments[0], e19), !0;
            return !1;
        }(e18) || function(e19) {
            const { enclosingNode: t13  } = e19;
            if (t13 && ("Property" === t13.type || "ObjectProperty" === t13.type)) return Sl(t13, e19), !0;
            return !1;
        }(e18) || Xl(e18, r6, o5) || function(e19) {
            const { enclosingNode: t13  } = e19;
            if (t13 && "TypeAlias" === t13.type) return Sl(t13, e19), !0;
            return !1;
        }(e18) || function(e19) {
            const { enclosingNode: t13 , followingNode: n9  } = e19;
            if (t13 && ("VariableDeclarator" === t13.type || "AssignmentExpression" === t13.type) && n9 && ("ObjectExpression" === n9.type || "ArrayExpression" === n9.type || "TemplateLiteral" === n9.type || "TaggedTemplateExpression" === n9.type || Nl(e19))) return Sl(n9, e19), !0;
            return !1;
        }(e18);
    },
    handleRemainingComment: function(e18, t12, n8, r6, o5) {
        return !!(Yl(e18) || $l(e18, t12) || ql(e18, t12) || function(e19) {
            const { precedingNode: t13 , enclosingNode: n9  } = e19;
            if (n9 && ("ObjectProperty" === n9.type || "Property" === n9.type) && n9.shorthand && n9.key === t13 && "AssignmentPattern" === n9.value.type) return wl(n9.value.left, e19), !0;
            return !1;
        }(e18) || function(e19, t13) {
            if (")" !== Fl(t13, e19, _l)) return !1;
            const { enclosingNode: n9  } = e19;
            if (n9 && (Kl(n9) && 0 === kl(n9).length || ("CallExpression" === n9.type || "OptionalCallExpression" === n9.type || "NewExpression" === n9.type) && 0 === n9.arguments.length)) return Tl(n9, e19), !0;
            if (n9 && "MethodDefinition" === n9.type && 0 === kl(n9.value).length) return Tl(n9.value, e19), !0;
            return !1;
        }(e18, t12) || Jl(e18, t12) || Xl(e18, r6, o5) || function(e19, t13) {
            const { enclosingNode: n9  } = e19;
            if (!n9 || "ArrowFunctionExpression" !== n9.type) return !1;
            const r7 = Bl(t13, e19, _l);
            if (!1 !== r7 && "=>" === t13.slice(r7, r7 + 2)) return Tl(n9, e19), !0;
            return !1;
        }(e18, t12) || function(e19, t13) {
            if ("(" !== Fl(t13, e19, _l)) return !1;
            const { precedingNode: n9 , enclosingNode: r7  } = e19;
            if (n9 && r7 && ("FunctionDeclaration" === r7.type || "FunctionExpression" === r7.type || "ClassMethod" === r7.type || "MethodDefinition" === r7.type || "ObjectMethod" === r7.type)) return wl(n9, e19), !0;
            return !1;
        }(e18, t12) || function(e19) {
            const { precedingNode: t13 , enclosingNode: n9 , followingNode: r7  } = e19;
            if (!n9 || "TSMappedType" !== n9.type) return !1;
            if (r7 && "TSTypeParameter" === r7.type && r7.name) return Sl(r7.name, e19), !0;
            if (t13 && "TSTypeParameter" === t13.type && t13.constraint) return wl(t13.constraint, e19), !0;
            return !1;
        }(e18) || function(e19) {
            const { enclosingNode: t13  } = e19;
            if (t13 && ("ContinueStatement" === t13.type || "BreakStatement" === t13.type) && !t13.label) return wl(t13, e19), !0;
            return !1;
        }(e18) || function(e19, t13) {
            const { enclosingNode: n9 , followingNode: r7  } = e19;
            if (!r7 && n9 && ("TSMethodSignature" === n9.type || "TSDeclareFunction" === n9.type || "TSAbstractMethodDefinition" === n9.type) && ";" === Fl(t13, e19, _l)) return wl(n9, e19), !0;
            return !1;
        }(e18, t12));
    },
    hasLeadingComment: function(e18, t12 = ()=>!0
    ) {
        return e18.leadingComments ? e18.leadingComments.some(t12) : !!e18.comments && e18.comments.some((e19)=>e19.leading && t12(e19)
        );
    },
    isTypeCastComment: Ql,
    getGapRegex: function(e18) {
        if (e18 && "BinaryExpression" !== e18.type && "LogicalExpression" !== e18.type) return /^[\s&(|]*$/;
    },
    getCommentChildNodes: function(e18, t12) {
        if (("typescript" === t12.parser || "flow" === t12.parser || "espree" === t12.parser || "meriyah" === t12.parser) && "MethodDefinition" === e18.type && e18.value && "FunctionExpression" === e18.value.type && 0 === kl(e18.value).length && !e18.value.returnType && (!e18.value.typeParameters || 0 === e18.value.typeParameters.length) && e18.value.body) return [
            ...e18.decorators || [],
            e18.key,
            e18.value.body
        ];
    },
    willPrintOwnComments: function(e18) {
        const t12 = e18.getValue(), n8 = e18.getParentNode();
        return (t12 && (Ol(t12) || Il(t12) || n8 && ("CallExpression" === n8.type || "OptionalCallExpression" === n8.type) && (Ll(t12.leadingComments) || Ll(t12.trailingComments))) || n8 && ("JSXSpreadAttribute" === n8.type || "JSXSpreadChild" === n8.type || "UnionTypeAnnotation" === n8.type || "TSUnionType" === n8.type || ("ClassDeclaration" === n8.type || "ClassExpression" === n8.type) && n8.superClass === t12)) && (!Ml(e18) || "UnionTypeAnnotation" === n8.type || "TSUnionType" === n8.type);
    }
};
const { getStringWidth: ec , getIndentSize: tc  } = Nt1, { builders: { concat: nc , join: rc , hardline: oc , softline: uc , group: ic , indent: ac , align: sc , lineSuffixBoundary: lc , addAlignmentToDoc: cc  } , printer: { printDocToString: pc  } , utils: { mapDoc: dc  }  } = rn1, { isBinaryish: fc , isJestEachTemplateLiteral: hc , isSimpleTemplateLiteral: mc  } = Cl;
var Dc = {
    printTemplateLiteral: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if ("TemplateLiteral" === r6.type && hc(r6, e18.getParentNode())) {
            const r7 = function(e19, t13, n9) {
                const r8 = e19.getNode(), o5 = r8.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                if (o5.length > 1 || o5.some((e20)=>0 !== e20.length
                )) {
                    t13.__inJestEach = !0;
                    const u4 = e19.map(n9, "expressions");
                    t13.__inJestEach = !1;
                    const i6 = [], a5 = u4.map((e20)=>"${" + pc(e20, Object.assign({
                        }, t13, {
                            printWidth: 1 / 0,
                            endOfLine: "lf"
                        })).formatted + "}"
                    ), s4 = [
                        {
                            hasLineBreak: !1,
                            cells: []
                        }
                    ];
                    for(let e20 = 1; e20 < r8.quasis.length; e20++){
                        const t14 = s4[s4.length - 1], n10 = a5[e20 - 1];
                        t14.cells.push(n10), n10.includes("\n") && (t14.hasLineBreak = !0), r8.quasis[e20].value.raw.includes("\n") && s4.push({
                            hasLineBreak: !1,
                            cells: []
                        });
                    }
                    const l5 = Math.max(o5.length, ...s4.map((e21)=>e21.cells.length
                    )), c6 = Array.from({
                        length: l5
                    }).fill(0), p6 = [
                        {
                            cells: o5
                        },
                        ...s4.filter((e21)=>0 !== e21.cells.length
                        )
                    ];
                    for (const { cells: e21  } of p6.filter((e22)=>!e22.hasLineBreak
                    ))e21.forEach((e22, t14)=>{
                        c6[t14] = Math.max(c6[t14], ec(e22));
                    });
                    return i6.push(lc, "`", ac(nc([
                        oc,
                        rc(oc, p6.map((e22)=>rc(" | ", e22.cells.map((t14, n10)=>e22.hasLineBreak ? t14 : t14 + " ".repeat(c6[n10] - ec(t14))
                            ))
                        ))
                    ])), oc, "`"), nc(i6);
                }
            }(e18, n8, t12);
            if (r7) return r7;
        }
        let o5 = "expressions";
        "TSTemplateLiteralType" === r6.type && (o5 = "types");
        const u4 = [];
        let i6 = e18.map(t12, o5);
        const a5 = mc(r6);
        return (a5 && (i6 = i6.map((e19)=>pc(e19, Object.assign({
            }, n8, {
                printWidth: 1 / 0
            })).formatted
        )), u4.push(lc, "`"), e18.each((e19)=>{
            const s4 = e19.getName();
            if (u4.push(t12(e19)), s4 < i6.length) {
                const { tabWidth: t13  } = n8, l5 = e19.getValue(), c6 = tc(l5.value.raw, t13);
                let p6 = i6[s4];
                if (!a5) {
                    const e20 = r6[o5][s4];
                    (e20.comments && e20.comments.length || "MemberExpression" === e20.type || "OptionalMemberExpression" === e20.type || "ConditionalExpression" === e20.type || "SequenceExpression" === e20.type || "TSAsExpression" === e20.type || fc(e20)) && (p6 = nc([
                        ac(nc([
                            uc,
                            p6
                        ])),
                        uc
                    ]));
                }
                const d6 = 0 === c6 && l5.value.raw.endsWith("\n") ? sc(-1 / 0, p6) : cc(p6, c6, t13);
                u4.push(ic(nc([
                    "${",
                    d6,
                    lc,
                    "}"
                ])));
            }
        }, "quasis"), u4.push("`"), nc(u4));
    },
    printTemplateExpressions: function(e18, t12) {
        return e18.map((e19)=>(function(e20, t13) {
                const n8 = e20.getValue();
                let r6 = t13(e20);
                return n8.comments && n8.comments.length && (r6 = ic(nc([
                    ac(nc([
                        uc,
                        r6
                    ])),
                    uc
                ]))), nc([
                    "${",
                    r6,
                    lc,
                    "}"
                ]);
            })(e19, t12)
        , "expressions");
    },
    escapeTemplateCharacters: function(e18, t12) {
        return dc(e18, (e19)=>{
            if (!e19.parts) return e19;
            const n8 = e19.parts.map((e20)=>"string" == typeof e20 ? t12 ? e20.replace(/(\\*)`/g, "$1$1\\`") : gc(e20) : e20
            );
            return Object.assign({
            }, e19, {
                parts: n8
            });
        });
    },
    uncookTemplateElementValue: gc
};
const { builders: { indent: yc , softline: Ec , literalline: Cc , concat: bc , dedentToRoot: vc  }  } = rn1, { escapeTemplateCharacters: Ac  } = Dc;
var Fc = function(e18, t12, n8) {
    let r6 = e18.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e19, t13)=>"\\".repeat(t13.length / 2) + "`"
    );
    const o5 = function(e19) {
        const t13 = e19.match(/^([^\S\n]*)\S/m);
        return null === t13 ? "" : t13[1];
    }(r6), u4 = "" !== o5;
    u4 && (r6 = r6.replace(new RegExp("^".concat(o5), "gm"), ""));
    const i6 = Ac(n8(r6, {
        parser: "markdown",
        __inJsTemplate: !0
    }, {
        stripTrailingHardline: !0
    }), !0);
    return bc([
        "`",
        u4 ? yc(bc([
            Ec,
            i6
        ])) : bc([
            Cc,
            vc(i6)
        ]),
        Ec,
        "`"
    ]);
};
const { builders: { indent: xc , hardline: Sc , softline: wc , concat: Tc  } , utils: { mapDoc: Bc , replaceNewlinesWithLiterallines: Nc  }  } = rn1, { printTemplateExpressions: kc  } = Dc;
var Pc = function(e18, t12, n8) {
    const r6 = e18.getValue(), o5 = r6.quasis.map((e19)=>e19.value.raw
    );
    let u4 = 0;
    return function(e19, t13, n9) {
        if (1 === t13.quasis.length && !t13.quasis[0].value.raw.trim()) return "``";
        const r7 = function(e20, t14) {
            if (!t14 || !t14.length) return e20;
            let n10 = 0;
            const r8 = Bc(e20, (e21)=>{
                if (!e21 || !e21.parts || !e21.parts.length) return e21;
                let { parts: r9  } = e21;
                const o6 = r9.indexOf("@"), u5 = o6 + 1;
                if (o6 > -1 && "string" == typeof r9[u5] && r9[u5].startsWith("prettier-placeholder")) {
                    const e22 = r9[o6], t15 = r9[u5], n11 = r9.slice(u5 + 1);
                    r9 = r9.slice(0, o6).concat([
                        e22 + t15
                    ]).concat(n11);
                }
                const i6 = [];
                return r9.forEach((e22)=>{
                    "string" == typeof e22 && e22.includes("@prettier-placeholder") ? e22.split(/@prettier-placeholder-(\d+)-id/).forEach((e23, r10)=>{
                        r10 % 2 != 0 ? (i6.push(t14[e23]), n10++) : i6.push(Nc(e23));
                    }) : i6.push(e22);
                }), Object.assign({
                }, e21, {
                    parts: i6
                });
            });
            return t14.length === n10 ? r8 : null;
        }(e19, n9);
        if (!r7) throw new Error("Couldn't insert all the expressions");
        return Tc([
            "`",
            xc(Tc([
                Sc,
                r7
            ])),
            wc,
            "`"
        ]);
    }(n8(o5.reduce((e19, t13, n9)=>0 === n9 ? t13 : e19 + "@prettier-placeholder-" + u4++ + "-id" + t13
    , ""), {
        parser: "scss"
    }, {
        stripTrailingHardline: !0
    }), r6, kc(e18, t12));
};
const { builders: { indent: Oc , join: Ic , hardline: Lc , concat: Mc  }  } = rn1, { escapeTemplateCharacters: jc , printTemplateExpressions: _c  } = Dc;
function Rc(e18) {
    const t12 = [];
    let n8 = !1;
    return e18.map((e19)=>e19.trim()
    ).forEach((e19, r6, o5)=>{
        "" !== e19 && ("" === o5[r6 - 1] && n8 ? t12.push(Mc([
            Lc,
            e19
        ])) : t12.push(e19), n8 = !0);
    }), 0 === t12.length ? null : Ic(Lc, t12);
}
var Vc = function(e18, t12, n8) {
    const r6 = e18.getValue(), o5 = r6.quasis.length;
    if (1 === o5 && "" === r6.quasis[0].value.raw.trim()) return "``";
    const u4 = _c(e18, t12), i6 = [];
    for(let e19 = 0; e19 < o5; e19++){
        const t13 = 0 === e19, a5 = e19 === o5 - 1, s4 = r6.quasis[e19].value.cooked, l5 = s4.split("\n"), c6 = l5.length, p6 = u4[e19], d6 = c6 > 2 && "" === l5[0].trim() && "" === l5[1].trim(), f5 = c6 > 2 && "" === l5[c6 - 1].trim() && "" === l5[c6 - 2].trim(), h5 = l5.every((e20)=>/^\s*(?:#[^\n\r]*)?$/.test(e20)
        );
        if (!a5 && /#[^\n\r]*$/.test(l5[c6 - 1])) return null;
        let m5 = null;
        m5 = h5 ? Rc(l5) : n8(s4, {
            parser: "graphql"
        }, {
            stripTrailingHardline: !0
        }), m5 ? (m5 = jc(m5, !1), !t13 && d6 && i6.push(""), i6.push(m5), !a5 && f5 && i6.push("")) : t13 || a5 || !d6 || i6.push(""), p6 && i6.push(p6);
    }
    return Mc([
        "`",
        Oc(Mc([
            Lc,
            Ic(Lc, i6)
        ])),
        Lc,
        "`"
    ]);
};
const { builders: { indent: $c , line: qc , hardline: Wc , concat: Uc , group: Jc  } , utils: { mapDoc: zc  }  } = rn1, { printTemplateExpressions: Gc , uncookTemplateElementValue: Hc  } = Dc;
var Yc = function(e18, t12, n8, r6, { parser: o5  }) {
    const u4 = e18.getValue(), i6 = Xc;
    Xc = Xc + 1 >>> 0;
    const a5 = (e19)=>"PRETTIER_HTML_PLACEHOLDER_".concat(e19, "_").concat(Xc, "_IN_JS")
    , s4 = u4.quasis.map((e19, t13, n9)=>t13 === n9.length - 1 ? e19.value.cooked : e19.value.cooked + a5(t13)
    ).join(""), l5 = Gc(e18, t12);
    if (0 === l5.length && 0 === s4.trim().length) return "``";
    const c6 = new RegExp(a5("(\\d+)"), "g");
    let p6 = 0;
    const d6 = n8(s4, {
        parser: o5,
        __onHtmlRoot (e) {
            p6 = e.children.length;
        }
    }, {
        stripTrailingHardline: !0
    }), f5 = zc(d6, (e19)=>{
        if ("string" != typeof e19) return e19;
        const t13 = [], n9 = e19.split(c6);
        for(let e20 = 0; e20 < n9.length; e20++){
            let o6 = n9[e20];
            if (e20 % 2 == 0) {
                o6 && (o6 = Hc(o6), r6.embeddedInHtml && (o6 = o6.replace(/<\/(script)\b/gi, "<\\/$1")), t13.push(o6));
                continue;
            }
            const u5 = +o6;
            t13.push(l5[u5]);
        }
        return Uc(t13);
    }), h5 = /^\s/.test(s4) ? " " : "", m5 = /\s$/.test(s4) ? " " : "", g6 = "ignore" === r6.htmlWhitespaceSensitivity ? Wc : h5 && m5 ? qc : null;
    return Jc(Uc(g6 ? [
        "`",
        $c(Uc([
            g6,
            Jc(f5)
        ])),
        g6,
        "`"
    ] : [
        "`",
        h5,
        p6 > 1 ? $c(Jc(f5)) : Jc(f5),
        m5,
        "`"
    ]));
};
const { isBlockComment: Kc  } = Cl, { hasLeadingComment: Qc  } = Zl;
function Zc(e18) {
    return (function(e19) {
        const t12 = e19.getValue(), n8 = e19.getParentNode(), r6 = e19.getParentNode(1);
        return r6 && t12.quasis && "JSXExpressionContainer" === n8.type && "JSXElement" === r6.type && "style" === r6.openingElement.name.name && r6.openingElement.attributes.some((e20)=>"jsx" === e20.name.name
        ) || n8 && "TaggedTemplateExpression" === n8.type && "Identifier" === n8.tag.type && "css" === n8.tag.name || n8 && "TaggedTemplateExpression" === n8.type && "MemberExpression" === n8.tag.type && "css" === n8.tag.object.name && ("global" === n8.tag.property.name || "resolve" === n8.tag.property.name);
    })(e18) || (function(e19) {
        const t12 = e19.getParentNode();
        if (!t12 || "TaggedTemplateExpression" !== t12.type) return !1;
        const { tag: n8  } = t12;
        switch(n8.type){
            case "MemberExpression":
                return tp(n8.object) || np(n8);
            case "CallExpression":
                return tp(n8.callee) || "MemberExpression" === n8.callee.type && ("MemberExpression" === n8.callee.object.type && (tp(n8.callee.object.object) || np(n8.callee.object)) || "CallExpression" === n8.callee.object.type && tp(n8.callee.object.callee));
            case "Identifier":
                return "css" === n8.name;
            default:
                return !1;
        }
    })(e18) || (function(e19) {
        const t12 = e19.getParentNode(), n8 = e19.getParentNode(1);
        return n8 && "JSXExpressionContainer" === t12.type && "JSXAttribute" === n8.type && "JSXIdentifier" === n8.name.type && "css" === n8.name.name;
    })(e18) || (function(e19) {
        return e19.match((e20)=>"TemplateLiteral" === e20.type
        , (e20, t12)=>"ArrayExpression" === e20.type && "elements" === t12
        , (e20, t12)=>("Property" === e20.type || "ObjectProperty" === e20.type) && "Identifier" === e20.key.type && "styles" === e20.key.name && "value" === t12
        , ...ep);
    })(e18) ? "css" : (function(e19) {
        const t12 = e19.getValue(), n8 = e19.getParentNode();
        return rp(t12, "GraphQL") || n8 && ("TaggedTemplateExpression" === n8.type && ("MemberExpression" === n8.tag.type && "graphql" === n8.tag.object.name && "experimental" === n8.tag.property.name || "Identifier" === n8.tag.type && ("gql" === n8.tag.name || "graphql" === n8.tag.name)) || "CallExpression" === n8.type && "Identifier" === n8.callee.type && "graphql" === n8.callee.name);
    })(e18) ? "graphql" : (function(e19) {
        return rp(e19.getValue(), "HTML") || e19.match((e20)=>"TemplateLiteral" === e20.type
        , (e20, t12)=>"TaggedTemplateExpression" === e20.type && "Identifier" === e20.tag.type && "html" === e20.tag.name && "quasi" === t12
        );
    })(e18) ? "html" : (function(e19) {
        return e19.match((e20)=>"TemplateLiteral" === e20.type
        , (e20, t12)=>("Property" === e20.type || "ObjectProperty" === e20.type) && "Identifier" === e20.key.type && "template" === e20.key.name && "value" === t12
        , ...ep);
    })(e18) ? "angular" : (function(e19) {
        const t12 = e19.getValue(), n8 = e19.getParentNode();
        return n8 && "TaggedTemplateExpression" === n8.type && 1 === t12.quasis.length && "Identifier" === n8.tag.type && ("md" === n8.tag.name || "markdown" === n8.tag.name);
    })(e18) ? "markdown" : void 0;
}
function rp(e18, t12) {
    return Qc(e18, (e19)=>Kc(e19) && e19.value === " ".concat(t12, " ")
    );
}
var op = function(e18, t12, n8, r6) {
    const o5 = e18.getValue();
    if ("TemplateLiteral" !== o5.type || function({ quasis: e19  }) {
        return e19.some(({ value: { cooked: e20  }  })=>null === e20
        );
    }(o5)) return;
    const u4 = Zc(e18);
    return u4 ? "markdown" === u4 ? Fc(e18, t12, n8) : "css" === u4 ? Pc(e18, t12, n8) : "graphql" === u4 ? Vc(e18, t12, n8) : "html" === u4 || "angular" === u4 ? Yc(e18, t12, n8, r6, {
        parser: u4
    }) : void 0 : void 0;
};
const { isBlockComment: up  } = Cl, ip = new Set([
    "range",
    "raw",
    "comments",
    "leadingComments",
    "trailingComments",
    "innerComments",
    "extra",
    "start",
    "end",
    "loc",
    "flags",
    "errors",
    "tokens"
]);
function ap(e18, t12, n8) {
    if ("Program" === e18.type && delete t12.sourceType, "BigIntLiteral" !== e18.type && "BigIntLiteralTypeAnnotation" !== e18.type || t12.value && (t12.value = t12.value.toLowerCase()), "BigIntLiteral" !== e18.type && "Literal" !== e18.type || t12.bigint && (t12.bigint = t12.bigint.toLowerCase()), "DecimalLiteral" === e18.type && (t12.value = Number(t12.value)), "EmptyStatement" === e18.type) return null;
    if ("JSXText" === e18.type) return null;
    if ("JSXExpressionContainer" === e18.type && ("Literal" === e18.expression.type || "StringLiteral" === e18.expression.type) && " " === e18.expression.value) return null;
    if ("Property" !== e18.type && "ObjectProperty" !== e18.type && "MethodDefinition" !== e18.type && "ClassProperty" !== e18.type && "ClassMethod" !== e18.type && "FieldDefinition" !== e18.type && "TSDeclareMethod" !== e18.type && "TSPropertySignature" !== e18.type && "ObjectTypeProperty" !== e18.type || "object" != typeof e18.key || !e18.key || "Literal" !== e18.key.type && "NumericLiteral" !== e18.key.type && "StringLiteral" !== e18.key.type && "Identifier" !== e18.key.type || delete t12.key, "OptionalMemberExpression" === e18.type && !1 === e18.optional && (t12.type = "MemberExpression", delete t12.optional), "JSXElement" === e18.type && "style" === e18.openingElement.name.name && e18.openingElement.attributes.some((e19)=>"jsx" === e19.name.name
    )) {
        t12.children.filter((e19)=>"JSXExpressionContainer" === e19.type && "TemplateLiteral" === e19.expression.type
        ).map((e19)=>e19.expression
        ).reduce((e19, t13)=>e19.concat(t13.quasis)
        , []).forEach((e19)=>delete e19.value
        );
    }
    "JSXAttribute" === e18.type && "css" === e18.name.name && "JSXExpressionContainer" === e18.value.type && "TemplateLiteral" === e18.value.expression.type && t12.value.expression.quasis.forEach((e19)=>delete e19.value
    ), "JSXAttribute" === e18.type && e18.value && "Literal" === e18.value.type && /["']|&quot;|&apos;/.test(e18.value.value) && (t12.value.value = t12.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    const r6 = e18.expression || e18.callee;
    if ("Decorator" === e18.type && "CallExpression" === r6.type && "Component" === r6.callee.name && 1 === r6.arguments.length) {
        const n9 = e18.expression.arguments[0].properties;
        t12.expression.arguments[0].properties.forEach((e19, t13)=>{
            let r7 = null;
            switch(n9[t13].key.name){
                case "styles":
                    "ArrayExpression" === e19.value.type && (r7 = e19.value.elements[0]);
                    break;
                case "template":
                    "TemplateLiteral" === e19.value.type && (r7 = e19.value);
            }
            r7 && r7.quasis.forEach((e20)=>delete e20.value
            );
        });
    }
    if ("TaggedTemplateExpression" !== e18.type || "MemberExpression" !== e18.tag.type && ("Identifier" !== e18.tag.type || "gql" !== e18.tag.name && "graphql" !== e18.tag.name && "css" !== e18.tag.name && "md" !== e18.tag.name && "markdown" !== e18.tag.name && "html" !== e18.tag.name) && "CallExpression" !== e18.tag.type || t12.quasi.quasis.forEach((e19)=>delete e19.value
    ), "TemplateLiteral" === e18.type) {
        (e18.leadingComments && e18.leadingComments.some((e19)=>up(e19) && [
                "GraphQL",
                "HTML"
            ].some((t13)=>e19.value === " ".concat(t13, " ")
            )
        ) || "CallExpression" === n8.type && "graphql" === n8.callee.name) && t12.quasis.forEach((e19)=>delete e19.value
        ), e18.leadingComments || t12.quasis.forEach((e19)=>{
            e19.value && delete e19.value.cooked;
        });
    }
    "InterpreterDirective" === e18.type && (t12.value = t12.value.trimEnd());
}
ap.ignoredProperties = ip;
var sp = ap;
var pp = je(function(e18, t12) {
    function n8() {
        const e19 = Mr;
        return (n8 = function() {
            return Mr;
        }, Mr);
    }
    function r6() {
        const e19 = (t13 = cp) && t13.__esModule ? t13 : {
            default: t13
        };
        var t13;
        return (r6 = function() {
            return e19;
        }, e19);
    }
    Object.defineProperty(t12, "__esModule", {
        value: !0
    }), t12.extract = function(e19) {
        const t13 = e19.match(i6);
        return t13 ? t13[0].trimLeft() : "";
    }, t12.strip = function(e19) {
        const t13 = e19.match(i6);
        return t13 && t13[0] ? e19.substring(t13[0].length) : e19;
    }, t12.parse = function(e19) {
        return f5(e19).pragmas;
    }, t12.parseWithComments = f5, t12.print = function({ comments: e19 = "" , pragmas: t13 = {
    }  }) {
        const o5 = r6().default(e19) || n8().EOL, u4 = " *", i6 = Object.keys(t13), a5 = i6.map((e20)=>h5(e20, t13[e20])
        ).reduce((e20, t14)=>e20.concat(t14)
        , []).map((e20)=>" * " + e20 + o5
        ).join("");
        if (!e19) {
            if (0 === i6.length) return "";
            if (1 === i6.length && !Array.isArray(t13[i6[0]])) {
                const e20 = t13[i6[0]];
                return "".concat("/**", " ").concat(h5(i6[0], e20)[0]).concat(" */");
            }
        }
        const s4 = e19.split(o5).map((e20)=>"".concat(u4, " ").concat(e20)
        ).join(o5) + o5;
        return "/**" + o5 + (e19 ? s4 : "") + (e19 && i6.length ? u4 + o5 : "") + a5 + " */";
    };
    const o5 = /\*\/$/, u4 = /^\/\*\*/, i6 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a5 = /(^|\s+)\/\/([^\r\n]*)/g, s4 = /^(\r?\n)+/, l5 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c6 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p6 = /(\r?\n|^) *\* ?/g, d6 = [];
    function f5(e19) {
        const t13 = r6().default(e19) || n8().EOL;
        e19 = e19.replace(u4, "").replace(o5, "").replace(p6, "$1");
        let i7 = "";
        for(; i7 !== e19;)i7 = e19, e19 = e19.replace(l5, "".concat(t13, "$1 $2").concat(t13));
        e19 = e19.replace(s4, "").trimRight();
        const f6 = Object.create(null), h5 = e19.replace(c6, "").replace(s4, "").trimRight();
        let m5;
        for(; m5 = c6.exec(e19);){
            const e20 = m5[2].replace(a5, "");
            "string" == typeof f6[m5[1]] || Array.isArray(f6[m5[1]]) ? f6[m5[1]] = d6.concat(f6[m5[1]], e20) : f6[m5[1]] = e20;
        }
        return {
            comments: h5,
            pragmas: f6
        };
    }
    function h5(e19, t13) {
        return d6.concat(t13).map((t14)=>"@".concat(e19, " ").concat(t14).trim()
        );
    }
});
const { parseWithComments: dp , strip: fp , extract: hp , print: mp  } = pp, { getShebang: gp  } = Nt1, { normalizeEndOfLine: Dp  } = kt;
function yp(e18) {
    const t12 = gp(e18);
    t12 && (e18 = e18.slice(t12.length + 1));
    const n8 = hp(e18), { pragmas: r6 , comments: o5  } = dp(n8);
    return {
        shebang: t12,
        text: e18,
        pragmas: r6,
        comments: o5
    };
}
var Ep = {
    hasPragma: function(e18) {
        const t12 = Object.keys(yp(e18).pragmas);
        return t12.includes("prettier") || t12.includes("format");
    },
    insertPragma: function(e18) {
        const { shebang: t12 , text: n8 , pragmas: r6 , comments: o5  } = yp(e18), u4 = fp(n8), i6 = mp({
            pragmas: Object.assign({
                format: ""
            }, r6),
            comments: o5.trimStart()
        });
        return (t12 ? "".concat(t12, "\n") : "") + Dp(i6) + (u4.startsWith("\n") ? "\n" : "\n\n") + u4;
    }
};
const { getFunctionParameters: Cp , getLeftSidePathName: bp , hasFlowShorthandAnnotationComment: vp , hasNakedLeftSide: Ap , hasNode: Fp , isBitwiseOperator: xp , startsWithNoLookaheadToken: Sp , shouldFlatten: wp , getPrecedence: Tp  } = Cl;
function Bp(e18, t12) {
    const n8 = e18.getParentNode();
    if (!n8) return !1;
    const r6 = e18.getName(), o5 = e18.getNode();
    if (t12.__isInHtmlInterpolation && !t12.bracketSpacing && (function(e19) {
        switch(e19.type){
            case "ObjectExpression":
                return !0;
            default:
                return !1;
        }
    })(o5) && Np(e18)) return !0;
    if ((function(e19) {
        return "BlockStatement" === e19.type || "BreakStatement" === e19.type || "ClassBody" === e19.type || "ClassDeclaration" === e19.type || "ClassMethod" === e19.type || "ClassProperty" === e19.type || "FieldDefinition" === e19.type || "ClassPrivateProperty" === e19.type || "ContinueStatement" === e19.type || "DebuggerStatement" === e19.type || "DeclareClass" === e19.type || "DeclareExportAllDeclaration" === e19.type || "DeclareExportDeclaration" === e19.type || "DeclareFunction" === e19.type || "DeclareInterface" === e19.type || "DeclareModule" === e19.type || "DeclareModuleExports" === e19.type || "DeclareVariable" === e19.type || "DoWhileStatement" === e19.type || "EnumDeclaration" === e19.type || "ExportAllDeclaration" === e19.type || "ExportDefaultDeclaration" === e19.type || "ExportNamedDeclaration" === e19.type || "ExpressionStatement" === e19.type || "ForInStatement" === e19.type || "ForOfStatement" === e19.type || "ForStatement" === e19.type || "FunctionDeclaration" === e19.type || "IfStatement" === e19.type || "ImportDeclaration" === e19.type || "InterfaceDeclaration" === e19.type || "LabeledStatement" === e19.type || "MethodDefinition" === e19.type || "ReturnStatement" === e19.type || "SwitchStatement" === e19.type || "ThrowStatement" === e19.type || "TryStatement" === e19.type || "TSDeclareFunction" === e19.type || "TSEnumDeclaration" === e19.type || "TSImportEqualsDeclaration" === e19.type || "TSInterfaceDeclaration" === e19.type || "TSModuleDeclaration" === e19.type || "TSNamespaceExportDeclaration" === e19.type || "TypeAlias" === e19.type || "VariableDeclaration" === e19.type || "WhileStatement" === e19.type || "WithStatement" === e19.type;
    })(o5)) return !1;
    if ("flow" !== t12.parser && vp(e18.getValue())) return !0;
    if ("Identifier" === o5.type) return !!(o5.extra && o5.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o5.name));
    switch(n8.type){
        case "ParenthesizedExpression":
            return !1;
        case "ClassDeclaration":
        case "ClassExpression":
            if ("superClass" === r6 && ("ArrowFunctionExpression" === o5.type || "AssignmentExpression" === o5.type || "AwaitExpression" === o5.type || "BinaryExpression" === o5.type || "ConditionalExpression" === o5.type || "LogicalExpression" === o5.type || "NewExpression" === o5.type || "ObjectExpression" === o5.type || "ParenthesizedExpression" === o5.type || "SequenceExpression" === o5.type || "TaggedTemplateExpression" === o5.type || "UnaryExpression" === o5.type || "UpdateExpression" === o5.type || "YieldExpression" === o5.type)) return !0;
            break;
        case "ExportDefaultDeclaration":
            return kp(e18, t12) || "SequenceExpression" === o5.type;
        case "Decorator":
            if ("expression" === r6) {
                let e19 = !1, t13 = !1, n9 = o5;
                for(; n9;)switch(n9.type){
                    case "MemberExpression":
                        t13 = !0, n9 = n9.object;
                        break;
                    case "CallExpression":
                        if (t13 || e19) return !0;
                        e19 = !0, n9 = n9.callee;
                        break;
                    case "Identifier":
                        return !1;
                    default:
                        return !0;
                }
                return !0;
            }
            break;
        case "ExpressionStatement":
            if (Sp(o5, !0)) return !0;
            break;
        case "ArrowFunctionExpression":
            if ("body" === r6 && "SequenceExpression" !== o5.type && Sp(o5, !1)) return !0;
    }
    switch(o5.type){
        case "SpreadElement":
        case "SpreadProperty":
            return "object" === r6 && "MemberExpression" === n8.type;
        case "UpdateExpression":
            if ("UnaryExpression" === n8.type) return o5.prefix && ("++" === o5.operator && "+" === n8.operator || "--" === o5.operator && "-" === n8.operator);
        case "UnaryExpression":
            switch(n8.type){
                case "UnaryExpression":
                    return o5.operator === n8.operator && ("+" === o5.operator || "-" === o5.operator);
                case "BindExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r6;
                case "TaggedTemplateExpression":
                    return !0;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "BinaryExpression":
                    return "left" === r6 && "**" === n8.operator;
                case "TSNonNullExpression":
                    return !0;
                default:
                    return !1;
            }
        case "BinaryExpression":
            if ("UpdateExpression" === n8.type || "PipelineTopicExpression" === n8.type && "|>" === o5.operator) return !0;
            if ("in" === o5.operator && (function(e19) {
                let t13 = 0, n9 = e19.getValue();
                for(; n9;){
                    const r7 = e19.getParentNode(t13++);
                    if (r7 && "ForStatement" === r7.type && r7.init === n9) return !0;
                    n9 = r7;
                }
                return !1;
            })(e18)) return !0;
            if ("|>" === o5.operator && o5.extra && o5.extra.parenthesized) {
                const t13 = e18.getParentNode(1);
                if ("BinaryExpression" === t13.type && "|>" === t13.operator) return !0;
            }
        case "TSTypeAssertion":
        case "TSAsExpression":
        case "LogicalExpression":
            switch(n8.type){
                case "ConditionalExpression":
                    return "TSAsExpression" === o5.type;
                case "CallExpression":
                case "NewExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "ClassExpression":
                case "ClassDeclaration":
                    return "superClass" === r6;
                case "TSTypeAssertion":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "JSXSpreadAttribute":
                case "SpreadElement":
                case "SpreadProperty":
                case "BindExpression":
                case "AwaitExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "UpdateExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r6;
                case "AssignmentExpression":
                    return "left" === r6 && ("TSTypeAssertion" === o5.type || "TSAsExpression" === o5.type);
                case "LogicalExpression":
                    if ("LogicalExpression" === o5.type) return n8.operator !== o5.operator;
                case "BinaryExpression":
                    {
                        const { operator: e19 , type: t13  } = o5;
                        if (!e19 && "TSTypeAssertion" !== t13) return !0;
                        const u4 = Tp(e19), i6 = n8.operator, a5 = Tp(i6);
                        return a5 > u4 || ("right" === r6 && a5 === u4 || (a5 === u4 && !wp(i6, e19) || (a5 < u4 && "%" === e19 ? "+" === i6 || "-" === i6 : !!xp(i6))));
                    }
                default:
                    return !1;
            }
        case "SequenceExpression":
            switch(n8.type){
                case "ReturnStatement":
                case "ForStatement":
                    return !1;
                case "ExpressionStatement":
                    return "expression" !== r6;
                case "ArrowFunctionExpression":
                    return "body" !== r6;
                default:
                    return !0;
            }
        case "YieldExpression":
            if ("UnaryExpression" === n8.type || "AwaitExpression" === n8.type || "TSAsExpression" === n8.type || "TSNonNullExpression" === n8.type) return !0;
        case "AwaitExpression":
            switch(n8.type){
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "BindExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r6;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "ConditionalExpression":
                    return "test" === r6;
                case "BinaryExpression":
                    return !(!o5.argument && "|>" === n8.operator);
                default:
                    return !1;
            }
        case "TSJSDocFunctionType":
        case "TSConditionalType":
            if ("extendsType" === r6 && "TSConditionalType" === n8.type) return !0;
        case "TSFunctionType":
        case "TSConstructorType":
            if ("checkType" === r6 && "TSConditionalType" === n8.type) return !0;
        case "TSUnionType":
        case "TSIntersectionType":
            if ("TSUnionType" === n8.type || "TSIntersectionType" === n8.type) return !0;
        case "TSInferType":
            if ("TSInferType" === o5.type && "TSRestType" === n8.type) return !1;
        case "TSTypeOperator":
            return "TSArrayType" === n8.type || "TSOptionalType" === n8.type || "TSRestType" === n8.type || "objectType" === r6 && "TSIndexedAccessType" === n8.type || "TSTypeOperator" === n8.type || "TSTypeAnnotation" === n8.type && /^TSJSDoc/.test(e18.getParentNode(1).type);
        case "ArrayTypeAnnotation":
            return "NullableTypeAnnotation" === n8.type;
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
            return "ArrayTypeAnnotation" === n8.type || "NullableTypeAnnotation" === n8.type || "IntersectionTypeAnnotation" === n8.type || "UnionTypeAnnotation" === n8.type;
        case "NullableTypeAnnotation":
            return "ArrayTypeAnnotation" === n8.type;
        case "FunctionTypeAnnotation":
            {
                const t13 = "NullableTypeAnnotation" === n8.type ? e18.getParentNode(1) : n8;
                return "UnionTypeAnnotation" === t13.type || "IntersectionTypeAnnotation" === t13.type || "ArrayTypeAnnotation" === t13.type || "NullableTypeAnnotation" === t13.type || "FunctionTypeParam" === n8.type && null === n8.name && Cp(o5).some((e19)=>e19.typeAnnotation && "NullableTypeAnnotation" === e19.typeAnnotation.type
                );
            }
        case "StringLiteral":
        case "NumericLiteral":
        case "Literal":
            if ("string" == typeof o5.value && "ExpressionStatement" === n8.type && !n8.directive) {
                const t13 = e18.getParentNode(1);
                return "Program" === t13.type || "BlockStatement" === t13.type;
            }
            return "object" === r6 && "MemberExpression" === n8.type && "number" == typeof o5.value;
        case "AssignmentExpression":
            {
                const t13 = e18.getParentNode(1);
                return "body" === r6 && "ArrowFunctionExpression" === n8.type || ("key" !== r6 || "ClassProperty" !== n8.type && "FieldDefinition" !== n8.type || !n8.computed) && (("init" !== r6 && "update" !== r6 || "ForStatement" !== n8.type) && ("ExpressionStatement" === n8.type ? "ObjectPattern" === o5.left.type : ("key" !== r6 || "TSPropertySignature" !== n8.type) && ("AssignmentExpression" !== n8.type && (("SequenceExpression" !== n8.type || !t13 || "ForStatement" !== t13.type || t13.init !== n8 && t13.update !== n8) && (("value" !== r6 || "Property" !== n8.type || !t13 || "ObjectPattern" !== t13.type || !t13.properties.includes(n8)) && "NGChainedExpression" !== n8.type)))));
            }
        case "ConditionalExpression":
            switch(n8.type){
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                case "NGPipeExpression":
                case "ExportDefaultDeclaration":
                case "AwaitExpression":
                case "JSXSpreadAttribute":
                case "TSTypeAssertion":
                case "TypeCastExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                    return !0;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "ConditionalExpression":
                    return "test" === r6;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r6;
                default:
                    return !1;
            }
        case "FunctionExpression":
            switch(n8.type){
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "TaggedTemplateExpression":
                    return !0;
                default:
                    return !1;
            }
        case "ArrowFunctionExpression":
            switch(n8.type){
                case "PipelineTopicExpression":
                    return !(!o5.extra || !o5.extra.parenthesized);
                case "BinaryExpression":
                    return "|>" !== n8.operator || o5.extra && o5.extra.parenthesized;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r6;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r6;
                case "TSAsExpression":
                case "BindExpression":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "AwaitExpression":
                case "TSTypeAssertion":
                    return !0;
                case "ConditionalExpression":
                    return "test" === r6;
                default:
                    return !1;
            }
        case "ClassExpression":
            switch(n8.type){
                case "NewExpression":
                    return "callee" === r6;
                default:
                    return !1;
            }
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
            {
                const t13 = e18.getParentNode(1);
                if ("object" === r6 && "MemberExpression" === n8.type || "callee" === r6 && ("CallExpression" === n8.type || "NewExpression" === n8.type) || "TSNonNullExpression" === n8.type && "MemberExpression" === t13.type && t13.object === n8) return !0;
            }
        case "CallExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "TSNonNullExpression":
            if ("callee" === r6 && ("BindExpression" === n8.type || "NewExpression" === n8.type)) {
                let e19 = o5;
                for(; e19;)switch(e19.type){
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "BindExpression":
                        e19 = e19.object;
                        break;
                    case "TaggedTemplateExpression":
                        e19 = e19.tag;
                        break;
                    case "TSNonNullExpression":
                        e19 = e19.expression;
                        break;
                    default:
                        return !1;
                }
            }
            return !1;
        case "BindExpression":
            return "callee" === r6 && ("BindExpression" === n8.type || "NewExpression" === n8.type) || "object" === r6 && ("MemberExpression" === n8.type || "OptionalMemberExpression" === n8.type);
        case "NGPipeExpression":
            return !("NGRoot" === n8.type || "NGMicrosyntaxExpression" === n8.type || !("ObjectProperty" !== n8.type || o5.extra && o5.extra.parenthesized) || "ArrayExpression" === n8.type || ("CallExpression" === n8.type || "OptionalCallExpression" === n8.type) && n8.arguments[r6] === o5 || "right" === r6 && "NGPipeExpression" === n8.type || "property" === r6 && "MemberExpression" === n8.type || "AssignmentExpression" === n8.type);
        case "JSXFragment":
        case "JSXElement":
            return "callee" === r6 || "left" === r6 && "BinaryExpression" === n8.type && "<" === n8.operator || "ArrayExpression" !== n8.type && "ArrowFunctionExpression" !== n8.type && "AssignmentExpression" !== n8.type && "AssignmentPattern" !== n8.type && "BinaryExpression" !== n8.type && "CallExpression" !== n8.type && "NewExpression" !== n8.type && "ConditionalExpression" !== n8.type && "ExpressionStatement" !== n8.type && "JsExpressionRoot" !== n8.type && "JSXAttribute" !== n8.type && "JSXElement" !== n8.type && "JSXExpressionContainer" !== n8.type && "JSXFragment" !== n8.type && "LogicalExpression" !== n8.type && "ObjectProperty" !== n8.type && "OptionalCallExpression" !== n8.type && "Property" !== n8.type && "ReturnStatement" !== n8.type && "ThrowStatement" !== n8.type && "TypeCastExpression" !== n8.type && "VariableDeclarator" !== n8.type && "YieldExpression" !== n8.type;
        case "TypeAnnotation":
            return "returnType" === r6 && "ArrowFunctionExpression" === n8.type && (function(e19) {
                return Fp(e19, (e20)=>"ObjectTypeAnnotation" === e20.type && Fp(e20, (e21)=>"FunctionTypeAnnotation" === e21.type || void 0
                    ) || void 0
                );
            })(o5);
    }
    return !1;
}
function kp(e18, t12) {
    const n8 = e18.getValue(), r6 = e18.getParentNode();
    return "FunctionExpression" === n8.type || "ClassExpression" === n8.type ? "ExportDefaultDeclaration" === r6.type || !Bp(e18, t12) : !(!Ap(n8) || "ExportDefaultDeclaration" !== r6.type && Bp(e18, t12)) && e18.call((e19)=>kp(e19, t12)
    , ...bp(e18, n8));
}
var Pp = Bp;
const { builders: { concat: Op , join: Ip , line: Lp , group: Mp , softline: jp , indent: _p  }  } = rn1;
var Rp = {
    isVueEventBindingExpression: function e18(t12) {
        switch(t12.type){
            case "MemberExpression":
                switch(t12.property.type){
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                        return e18(t12.object);
                }
                return !1;
            case "Identifier":
                return !0;
            default:
                return !1;
        }
    },
    printHtmlBinding: function(e19, t12, n8) {
        const r6 = e19.getValue();
        if ((t12.__onHtmlBindingRoot && null === e19.getName() && t12.__onHtmlBindingRoot(r6, t12), "File" === r6.type)) return t12.__isVueForBindingLeft ? e19.call((e20)=>{
            const t13 = Ip(Op([
                ",",
                Lp
            ]), e20.map(n8, "params")), { params: r7  } = e20.getValue();
            return 1 === r7.length ? t13 : Op([
                "(",
                _p(Op([
                    jp,
                    Mp(t13)
                ])),
                jp,
                ")"
            ]);
        }, "program", "body", 0) : t12.__isVueBindings ? e19.call((e20)=>Ip(Op([
                ",",
                Lp
            ]), e20.map(n8, "params"))
        , "program", "body", 0) : void 0;
    }
};
const { builders: { concat: $p , group: qp , indent: Wp , join: Up , line: Jp , hardline: zp  }  } = rn1, { hasNewlineBetweenOrAfterDecorators: Gp , getParentExportDeclaration: Hp  } = Cl;
var Xp = {
    printOptionalToken: function(e18) {
        const t12 = e18.getValue();
        return !t12.optional || "Identifier" === t12.type && t12 === e18.getParentNode().key ? "" : "OptionalCallExpression" === t12.type || "OptionalMemberExpression" === t12.type && t12.computed ? "?." : "?";
    },
    printFunctionTypeParameters: function(e18, t12, n8) {
        const r6 = e18.getValue();
        return r6.typeArguments ? e18.call(n8, "typeArguments") : r6.typeParameters ? e18.call(n8, "typeParameters") : "";
    },
    printBindExpressionCallee: function(e18, t12, n8) {
        return $p([
            "::",
            e18.call(n8, "callee")
        ]);
    },
    printTypeScriptModifiers: function(e18, t12, n8) {
        const r6 = e18.getValue();
        return r6.modifiers && r6.modifiers.length ? $p([
            Up(" ", e18.map(n8, "modifiers")),
            " "
        ]) : "";
    },
    printDecorators: function(e18, t12, n8) {
        const r6 = e18.getValue();
        return qp($p([
            Up(Jp, e18.map(n8, "decorators")),
            Gp(r6, t12) ? zp : Jp
        ]));
    },
    printFlowDeclaration: function(e18, t12) {
        const n8 = Hp(e18);
        return n8 ? (Xi.strictEqual(n8.type, "DeclareExportDeclaration"), t12) : $p([
            "declare ",
            t12
        ]);
    },
    adjustClause: function(e18, t12, n8) {
        return "EmptyStatement" === e18.type ? ";" : "BlockStatement" === e18.type || n8 ? $p([
            " ",
            t12
        ]) : Wp($p([
            Jp,
            t12
        ]));
    }
};
const { builders: { concat: Yp , softline: Kp , group: Qp , indent: Zp , join: ed , line: td , ifBreak: nd , hardline: rd  }  } = rn1, { printDanglingComments: od  } = ya, { hasDanglingComments: ud , shouldPrintComma: id , needsHardlineAfterDanglingComment: ad  } = Cl, { locStart: sd , hasSameLoc: ld  } = ei;
function cd(e18, t12, n8) {
    const r6 = e18.getValue();
    if (!r6.source) return "";
    const o5 = [];
    return dd(r6, t12) || o5.push(" from"), o5.push(" ", e18.call(n8, "source")), Yp(o5);
}
function pd(e18, t12, n8) {
    const r6 = e18.getValue();
    if (dd(r6, t12)) return "";
    const o5 = [
        " "
    ];
    if (r6.specifiers && r6.specifiers.length > 0) {
        const u4 = [], i6 = [];
        if (e18.each((t13)=>{
            const r7 = e18.getValue().type;
            if ("ExportNamespaceSpecifier" === r7 || "ExportDefaultSpecifier" === r7 || "ImportNamespaceSpecifier" === r7 || "ImportDefaultSpecifier" === r7) u4.push(n8(t13));
            else {
                if ("ExportSpecifier" !== r7 && "ImportSpecifier" !== r7) throw new Error("Unknown specifier type ".concat(JSON.stringify(r7)));
                i6.push(n8(t13));
            }
        }, "specifiers"), o5.push(ed(", ", u4)), 0 !== i6.length) {
            0 !== u4.length && o5.push(", ");
            i6.length > 1 || u4.length > 0 || r6.specifiers.some((e19)=>e19.comments
            ) ? o5.push(Qp(Yp([
                "{",
                Zp(Yp([
                    t12.bracketSpacing ? td : Kp,
                    ed(Yp([
                        ",",
                        td
                    ]), i6)
                ])),
                nd(id(t12) ? "," : ""),
                t12.bracketSpacing ? td : Kp,
                "}"
            ]))) : o5.push(Yp([
                "{",
                t12.bracketSpacing ? " " : "",
                Yp(i6),
                t12.bracketSpacing ? " " : "",
                "}"
            ]));
        }
    } else o5.push("{}");
    return Yp(o5);
}
function dd(e18, t12) {
    const { type: n8 , importKind: r6 , source: o5 , specifiers: u4  } = e18;
    return !("ImportDeclaration" !== n8 || Array.isArray(u4) && u4.length > 0 || "type" === r6) && !/{\s*}/.test(t12.originalText.slice(sd(e18), sd(o5)));
}
function fd(e18, t12, n8) {
    const r6 = e18.getNode();
    return Array.isArray(r6.assertions) && 0 !== r6.assertions.length ? Yp([
        " assert {",
        t12.bracketSpacing ? " " : "",
        ed(", ", e18.map(n8, "assertions")),
        t12.bracketSpacing ? " " : "",
        "}"
    ]) : "";
}
var hd = {
    printImportDeclaration: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = t12.semi ? ";" : "", u4 = [], { importKind: i6  } = r6;
        return (u4.push("import"), i6 && "value" !== i6 && u4.push(" ", i6), u4.push(pd(e18, t12, n8), cd(e18, t12, n8), fd(e18, t12, n8)), u4.push(o5), Yp(u4));
    },
    printExportDeclaration: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [], { type: u4 , exportKind: i6 , declaration: a5  } = r6;
        return ("DeclareExportDeclaration" === u4 && o5.push("declare "), o5.push("export"), (r6.default || "ExportDefaultDeclaration" === u4) && o5.push(" default"), ud(r6) && (o5.push(" ", od(e18, t12, !0)), ad(r6) && o5.push(rd)), a5 ? o5.push(" ", e18.call(n8, "declaration")) : o5.push("type" === i6 ? " type" : "", pd(e18, t12, n8), cd(e18, t12, n8), fd(e18, t12, n8)), function(e19, t13) {
            if (!t13.semi) return !1;
            const { type: n9 , declaration: r7  } = e19, o6 = e19.default || "ExportDefaultDeclaration" === n9;
            if (!r7) return !0;
            const { type: u5  } = r7;
            if (o6 && "ClassDeclaration" !== u5 && "FunctionDeclaration" !== u5 && "TSInterfaceDeclaration" !== u5 && "DeclareClass" !== u5 && "DeclareFunction" !== u5 && "TSDeclareFunction" !== u5 && "EnumDeclaration" !== u5) return !0;
            return !1;
        }(r6, t12) && o5.push(";"), Yp(o5));
    },
    printExportAllDeclaration: function(e18, t12, n8) {
        const r6 = e18.getValue();
        let o5 = t12.semi ? ";" : "";
        const u4 = [], { type: i6 , exportKind: a5 , exported: s4  } = r6;
        return ("DeclareExportAllDeclaration" === i6 && (u4.push("declare "), o5 = ""), u4.push("export"), "type" === a5 && u4.push(" type"), u4.push(" *"), s4 && u4.push(" as ", e18.call(n8, "exported")), u4.push(cd(e18, t12, n8), fd(e18, t12, n8), o5), Yp(u4));
    },
    printModuleSpecifier: function(e18, t12, n8) {
        const r6 = e18.getNode(), { type: o5 , importKind: u4  } = r6, i6 = [];
        "ImportSpecifier" === o5 && u4 && i6.push(u4, " ");
        const a5 = o5.startsWith("Import"), s4 = a5 ? "imported" : "local", l5 = a5 ? "local" : "exported";
        let c6 = "", p6 = "";
        return ("ExportNamespaceSpecifier" === o5 || "ImportNamespaceSpecifier" === o5 ? c6 = "*" : r6[s4] && (c6 = e18.call(n8, s4)), !r6[l5] || r6[s4] && ld(r6[s4], r6[l5]) || (p6 = e18.call(n8, l5)), i6.push(c6, c6 && p6 ? " as " : "", p6), Yp(i6));
    }
};
const { hasNewlineInRange: md  } = Nt1, { isJSXNode: gd , isBlockComment: Dd  } = Cl, { locStart: yd , locEnd: Ed  } = ei, { builders: { concat: Cd , line: bd , softline: vd , group: Ad , indent: Fd , align: xd , ifBreak: Sd , dedent: wd , breakParent: Td  }  } = rn1;
var Bd = function(e18, t12, n8, r6) {
    const o5 = e18.getValue(), u4 = o5[r6.consequentNodePropertyName], i6 = o5[r6.alternateNodePropertyName], a5 = [];
    let s4 = !1;
    const l5 = e18.getParentNode(), c6 = l5.type === r6.conditionalNodeType && r6.testNodePropertyNames.some((e19)=>l5[e19] === o5
    );
    let p6, d6, f5 = l5.type === r6.conditionalNodeType && !c6, h5 = 0;
    do {
        d6 = p6 || o5, p6 = e18.getParentNode(h5), h5++;
    }while (p6 && p6.type === r6.conditionalNodeType && r6.testNodePropertyNames.every((e19)=>p6[e19] !== d6
    ))
    const m5 = p6 || l5, g6 = d6;
    if (r6.shouldCheckJsx && (gd(o5[r6.testNodePropertyNames[0]]) || gd(u4) || gd(i6) || function(e19) {
        return (function(e20) {
            const t13 = [];
            return (function e20(n9) {
                "ConditionalExpression" === n9.type ? (e20(n9.test), e20(n9.consequent), e20(n9.alternate)) : t13.push(n9);
            })(e20), t13;
        })(e19).some(gd);
    }(d6))) {
        s4 = !0, f5 = !0;
        const t13 = (e19)=>Cd([
                Sd("(", ""),
                Fd(Cd([
                    vd,
                    e19
                ])),
                vd,
                Sd(")", "")
            ])
        , o6 = (e19)=>"NullLiteral" === e19.type || "Literal" === e19.type && null === e19.value || "Identifier" === e19.type && "undefined" === e19.name
        ;
        a5.push(" ? ", o6(u4) ? e18.call(n8, r6.consequentNodePropertyName) : t13(e18.call(n8, r6.consequentNodePropertyName)), " : ", i6.type === r6.conditionalNodeType || o6(i6) ? e18.call(n8, r6.alternateNodePropertyName) : t13(e18.call(n8, r6.alternateNodePropertyName)));
    } else {
        const s5 = Cd([
            bd,
            "? ",
            u4.type === r6.conditionalNodeType ? Sd("", "(") : "",
            xd(2, e18.call(n8, r6.consequentNodePropertyName)),
            u4.type === r6.conditionalNodeType ? Sd("", ")") : "",
            bd,
            ": ",
            i6.type === r6.conditionalNodeType ? e18.call(n8, r6.alternateNodePropertyName) : xd(2, e18.call(n8, r6.alternateNodePropertyName))
        ]);
        a5.push(l5.type !== r6.conditionalNodeType || l5[r6.alternateNodePropertyName] === o5 || c6 ? s5 : t12.useTabs ? wd(Fd(s5)) : xd(Math.max(0, t12.tabWidth - 2), s5));
    }
    const D5 = Uu([
        ...r6.testNodePropertyNames.map((e19)=>o5[e19].comments
        ),
        u4.comments,
        i6.comments
    ]).filter(Boolean).some((e19)=>Dd(e19) && md(t12.originalText, yd(e19), Ed(e19))
    ), y6 = !s4 && ("MemberExpression" === l5.type || "OptionalMemberExpression" === l5.type || "NGPipeExpression" === l5.type && l5.left === o5) && !l5.computed, E5 = ((e19)=>l5 === m5 ? Ad(e19, {
            shouldBreak: D5
        }) : D5 ? Cd([
            e19,
            Td
        ]) : e19
    )(Cd([].concat((C4 = Cd(r6.beforeParts()), l5.type === r6.conditionalNodeType && l5[r6.alternateNodePropertyName] === o5 ? xd(2, C4) : C4), f5 ? Cd(a5) : Fd(Cd(a5)), r6.afterParts(y6))));
    var C4;
    return c6 ? Ad(Cd([
        Fd(Cd([
            vd,
            E5
        ])),
        vd
    ])) : E5;
};
const { getNextNonSpaceNonCommentCharacter: Nd , isNextLineEmpty: kd  } = Nt1, { printDanglingComments: Pd  } = ya, { builders: { concat: Od , line: Id , hardline: Ld , softline: Md , group: jd , indent: _d , ifBreak: Rd  } , utils: { removeLines: Vd  }  } = rn1, { getFunctionParameters: $d , iterateFunctionParametersPath: qd , isSimpleType: Wd , isTestCall: Ud , isTypeAnnotationAFunction: Jd , isObjectType: zd , isObjectTypePropertyAFunction: Gd , hasRestParameter: Hd , shouldPrintComma: Xd  } = Cl, { locEnd: Yd  } = ei, { printFunctionTypeParameters: Kd  } = Xp;
function Qd(e18) {
    if (!e18) return !1;
    const t12 = $d(e18);
    if (1 !== t12.length) return !1;
    const [n8] = t12;
    return !n8.comments && ("ObjectPattern" === n8.type || "ArrayPattern" === n8.type || "Identifier" === n8.type && n8.typeAnnotation && ("TypeAnnotation" === n8.typeAnnotation.type || "TSTypeAnnotation" === n8.typeAnnotation.type) && zd(n8.typeAnnotation.typeAnnotation) || "FunctionTypeParam" === n8.type && zd(n8.typeAnnotation) || "AssignmentPattern" === n8.type && ("ObjectPattern" === n8.left.type || "ArrayPattern" === n8.left.type) && ("Identifier" === n8.right.type || "ObjectExpression" === n8.right.type && 0 === n8.right.properties.length || "ArrayExpression" === n8.right.type && 0 === n8.right.elements.length));
}
var Zd = {
    printFunctionParameters: function(e18, t12, n8, r6, o5) {
        const u4 = e18.getValue(), i6 = $d(u4), a5 = o5 ? Kd(e18, n8, t12) : "";
        if (0 === i6.length) return Od([
            a5,
            "(",
            Pd(e18, n8, !0, (e19)=>")" === Nd(n8.originalText, e19, Yd)
            ),
            ")"
        ]);
        const s4 = e18.getParentNode(), l5 = Ud(s4), c6 = Qd(u4), p6 = r6 && !i6.some((e19)=>e19.comments
        ), d6 = [];
        if ((qd(e18, (e19, r7)=>{
            const o6 = r7 === i6.length - 1;
            o6 && u4.rest && d6.push("..."), d6.push(e19.call(t12)), o6 || (d6.push(","), l5 || c6 || p6 ? d6.push(" ") : kd(n8.originalText, i6[r7], Yd) ? d6.push(Ld, Ld) : d6.push(Id));
        }), p6)) return jd(Od([
            Vd(a5),
            "(",
            Od(d6.map(Vd)),
            ")"
        ]));
        const f5 = i6.every((e19)=>!e19.decorators
        );
        return c6 && f5 || l5 ? Od([
            a5,
            "(",
            Od(d6),
            ")"
        ]) : (Gd(s4) || Jd(s4) || "TypeAlias" === s4.type || "UnionTypeAnnotation" === s4.type || "TSUnionType" === s4.type || "IntersectionTypeAnnotation" === s4.type || "FunctionTypeAnnotation" === s4.type && s4.returnType === u4) && 1 === i6.length && null === i6[0].name && u4.this !== i6[0] && i6[0].typeAnnotation && null === u4.typeParameters && Wd(i6[0].typeAnnotation) && !u4.rest ? "always" === n8.arrowParens ? Od([
            "(",
            Od(d6),
            ")"
        ]) : Od(d6) : Od([
            a5,
            "(",
            _d(Od([
                Md,
                Od(d6)
            ])),
            Rd(!Hd(u4) && Xd(n8, "all") ? "," : ""),
            Md,
            ")"
        ]);
    },
    shouldHugFunctionParameters: Qd
};
const { builders: { concat: ef  }  } = rn1, { isFlowAnnotationComment: tf , isSimpleType: nf , isObjectType: rf  } = Cl;
var of = {
    printTypeAnnotation: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if (!r6.typeAnnotation) return "";
        const o5 = e18.getParentNode(), u4 = r6.definite || o5 && "VariableDeclarator" === o5.type && o5.definite, i6 = "DeclareFunction" === o5.type && o5.id === r6;
        return tf(t12.originalText, r6.typeAnnotation) ? ef([
            " /*: ",
            e18.call(n8, "typeAnnotation"),
            " */"
        ]) : ef([
            i6 ? "" : u4 ? "!: " : ": ",
            e18.call(n8, "typeAnnotation")
        ]);
    },
    shouldHugType: function(e18) {
        if (nf(e18) || rf(e18)) return !0;
        if ("UnionTypeAnnotation" === e18.type || "TSUnionType" === e18.type) {
            const t12 = e18.types.filter((e19)=>"VoidTypeAnnotation" === e19.type || "TSVoidKeyword" === e19.type || "NullLiteralTypeAnnotation" === e19.type || "TSNullKeyword" === e19.type
            ).length, n8 = e18.types.some((e19)=>"ObjectTypeAnnotation" === e19.type || "TSTypeLiteral" === e19.type || "GenericTypeAnnotation" === e19.type || "TSTypeReference" === e19.type
            );
            if (e18.types.length - 1 === t12 && n8) return !0;
        }
        return !1;
    }
};
const { printDanglingComments: uf  } = ya, { builders: { concat: af , line: sf , softline: lf , group: cf , indent: pf , ifBreak: df  }  } = rn1, { getLast: ff , isNextLineEmpty: hf  } = Nt1, { hasDanglingComments: mf , shouldPrintComma: gf  } = Cl, { locEnd: Df  } = ei, { printOptionalToken: yf  } = Xp, { printTypeAnnotation: Ef  } = of;
function Cf(e18, t12, n8, r6) {
    const o5 = [];
    let u4 = [];
    return e18.each((e19)=>{
        o5.push(af(u4)), o5.push(cf(r6(e19))), u4 = [
            ",",
            sf
        ], e19.getValue() && hf(t12.originalText, e19.getValue(), Df) && u4.push(lf);
    }, n8), af(o5);
}
var bf = {
    printArray: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [], u4 = "TupleExpression" === r6.type ? "#[" : "[";
        if (0 === r6.elements.length) mf(r6) ? o5.push(cf(af([
            u4,
            uf(e18, t12),
            lf,
            "]"
        ]))) : o5.push(u4, "]");
        else {
            const i6 = ff(r6.elements), a5 = !(i6 && "RestElement" === i6.type), s4 = a5 && null === i6, l5 = !t12.__inJestEach && r6.elements.length > 1 && r6.elements.every((e19, t13, n9)=>{
                const r7 = e19 && e19.type;
                if ("ArrayExpression" !== r7 && "ObjectExpression" !== r7) return !1;
                const o6 = n9[t13 + 1];
                if (o6 && r7 !== o6.type) return !1;
                const u5 = "ArrayExpression" === r7 ? "elements" : "properties";
                return e19[u5] && e19[u5].length > 1;
            });
            o5.push(cf(af([
                u4,
                pf(af([
                    lf,
                    Cf(e18, t12, "elements", n8)
                ])),
                s4 ? "," : "",
                df(a5 && !s4 && gf(t12) ? "," : ""),
                uf(e18, t12, !0),
                lf,
                "]"
            ]), {
                shouldBreak: l5
            }));
        }
        return (o5.push(yf(e18), Ef(e18, t12, n8)), af(o5));
    },
    printArrayItems: Cf
};
const { printDanglingComments: vf  } = ya, { builders: { concat: Af , line: Ff , softline: xf , group: Sf , indent: wf , ifBreak: Tf , hardline: Bf  }  } = rn1, { getLast: Nf , isNextLineEmpty: kf , hasNewlineInRange: Pf , hasNewline: Of  } = Nt1, { hasDanglingComments: If , shouldPrintComma: Lf , hasNodeIgnoreComment: Mf , isBlockComment: jf  } = Cl, { locStart: _f , locEnd: Rf  } = ei, { printOptionalToken: Vf  } = Xp, { shouldHugFunctionParameters: $f  } = Zd, { printTypeAnnotation: qf , shouldHugType: Wf  } = of;
var Uf = {
    printObject: function(e18, t12, n8) {
        const r6 = t12.semi ? ";" : "", o5 = e18.getValue();
        let u4;
        u4 = "TSTypeLiteral" === o5.type ? "members" : "TSInterfaceBody" === o5.type ? "body" : "properties";
        const i6 = "ObjectTypeAnnotation" === o5.type, a5 = [];
        i6 && a5.push("indexers", "callProperties", "internalSlots"), a5.push(u4);
        const s4 = a5.map((e19)=>o5[e19][0]
        ).sort((e19, t13)=>_f(e19) - _f(t13)
        )[0], l5 = e18.getParentNode(0), c6 = i6 && l5 && ("InterfaceDeclaration" === l5.type || "DeclareInterface" === l5.type || "DeclareClass" === l5.type) && "body" === e18.getName(), p6 = "TSInterfaceBody" === o5.type || c6 || "ObjectPattern" === o5.type && "FunctionDeclaration" !== l5.type && "FunctionExpression" !== l5.type && "ArrowFunctionExpression" !== l5.type && "ObjectMethod" !== l5.type && "ClassMethod" !== l5.type && "ClassPrivateMethod" !== l5.type && "AssignmentPattern" !== l5.type && "CatchClause" !== l5.type && o5.properties.some((e19)=>e19.value && ("ObjectPattern" === e19.value.type || "ArrayPattern" === e19.value.type)
        ) || "ObjectPattern" !== o5.type && s4 && Pf(t12.originalText, _f(o5), _f(s4)), d6 = c6 ? ";" : "TSInterfaceBody" === o5.type || "TSTypeLiteral" === o5.type ? Tf(r6, ";") : ",", f5 = "RecordExpression" === o5.type ? "#{" : o5.exact ? "{|" : "{", h5 = o5.exact ? "|}" : "}", m5 = [];
        a5.forEach((t13)=>{
            e18.each((e19)=>{
                const t14 = e19.getValue();
                m5.push({
                    node: t14,
                    printed: n8(e19),
                    loc: _f(t14)
                });
            }, t13);
        });
        let g6 = [];
        const D5 = m5.sort((e19, t13)=>e19.loc - t13.loc
        ).map((e19)=>{
            const n9 = Af(g6.concat(Sf(e19.printed)));
            return g6 = [
                d6,
                Ff
            ], "TSPropertySignature" !== e19.node.type && "TSMethodSignature" !== e19.node.type && "TSConstructSignatureDeclaration" !== e19.node.type || !Mf(e19.node) || g6.shift(), kf(t12.originalText, e19.node, Rf) && g6.push(Bf), n9;
        });
        if (o5.inexact) {
            let n9;
            if (If(o5)) {
                const r7 = !o5.comments.every((e19)=>jf(e19)
                ), u5 = vf(e18, t12, !0);
                n9 = Af([
                    u5,
                    r7 || Of(t12.originalText, Rf(o5.comments[o5.comments.length - 1])) ? Bf : Ff,
                    "..."
                ]);
            } else n9 = "...";
            D5.push(Af(g6.concat(n9)));
        }
        const y6 = Nf(o5[u4]), E5 = !(o5.inexact || y6 && "RestElement" === y6.type || y6 && ("TSPropertySignature" === y6.type || "TSCallSignatureDeclaration" === y6.type || "TSMethodSignature" === y6.type || "TSConstructSignatureDeclaration" === y6.type) && Mf(y6));
        let C4;
        if (0 === D5.length) {
            if (!If(o5)) return Af([
                f5,
                h5,
                qf(e18, t12, n8)
            ]);
            C4 = Sf(Af([
                f5,
                vf(e18, t12),
                xf,
                h5,
                Vf(e18),
                qf(e18, t12, n8)
            ]));
        } else C4 = Af([
            f5,
            wf(Af([
                t12.bracketSpacing ? Ff : xf,
                Af(D5)
            ])),
            Tf(E5 && ("," !== d6 || Lf(t12)) ? d6 : ""),
            Af([
                t12.bracketSpacing ? Ff : xf,
                h5
            ]),
            Vf(e18),
            qf(e18, t12, n8)
        ]);
        return e18.match((e19)=>"ObjectPattern" === e19.type && !e19.decorators
        , (e19, t13, n9)=>$f(e19) && ("params" === t13 || "parameters" === t13 || "this" === t13 || "rest" === t13) && 0 === n9
        ) || e18.match(Wf, (e19, t13)=>"typeAnnotation" === t13
        , (e19, t13)=>"typeAnnotation" === t13
        , (e19, t13, n9)=>$f(e19) && ("params" === t13 || "parameters" === t13 || "this" === t13 || "rest" === t13) && 0 === n9
        ) ? C4 : Sf(C4, {
            shouldBreak: p6
        });
    }
};
const { printComments: Jf , printDanglingComments: zf  } = ya, { builders: { concat: Gf , line: Hf , hardline: Xf , softline: Yf , group: Kf , indent: Qf , conditionalGroup: Zf , fill: eh , ifBreak: th , lineSuffixBoundary: nh  } , utils: { willBreak: rh , isLineNext: oh , isEmpty: uh  }  } = rn1, { getLast: ih , getPreferredQuote: ah  } = Nt1, { hasTrailingComment: sh , isEmptyJSXElement: lh , isJSXWhitespaceExpression: ch , isJSXNode: ph , isMeaningfulJSXText: dh , matchJsxWhitespaceRegex: fh , rawText: hh , isLiteral: mh , isCallOrOptionalCallExpression: gh , isStringLiteral: Dh , isBinaryish: yh , isBlockComment: Eh  } = Cl, { willPrintOwnComments: Ch  } = Zl;
function bh(e18, t12, n8) {
    const r6 = e18.getValue();
    if ("JSXElement" === r6.type && lh(r6)) return Gf([
        e18.call(n8, "openingElement"),
        e18.call(n8, "closingElement")
    ]);
    const o5 = "JSXElement" === r6.type ? e18.call(n8, "openingElement") : e18.call(n8, "openingFragment"), u4 = "JSXElement" === r6.type ? e18.call(n8, "closingElement") : e18.call(n8, "closingFragment");
    if (1 === r6.children.length && "JSXExpressionContainer" === r6.children[0].type && ("TemplateLiteral" === r6.children[0].expression.type || "TaggedTemplateExpression" === r6.children[0].expression.type)) return Gf([
        o5,
        Gf(e18.map(n8, "children")),
        u4
    ]);
    r6.children = r6.children.map((e19)=>ch(e19) ? {
            type: "JSXText",
            value: " ",
            raw: " "
        } : e19
    );
    const i6 = r6.children.filter(ph).length > 0, a5 = r6.children.filter((e19)=>"JSXExpressionContainer" === e19.type
    ).length > 1, s4 = "JSXElement" === r6.type && r6.openingElement.attributes.length > 1;
    let l5 = rh(o5) || i6 || s4 || a5;
    const c6 = "mdx" === e18.getParentNode().rootMarker, p6 = t12.singleQuote ? "{' '}" : '{" "}', d6 = c6 ? Gf([
        " "
    ]) : th(Gf([
        p6,
        Yf
    ]), " "), f5 = r6.openingElement && r6.openingElement.name && "fbt" === r6.openingElement.name.name, h5 = function(e19, t13, n9, r7, o6) {
        const u5 = e19.getValue(), i7 = [];
        return e19.each((e20, t14)=>{
            const a6 = e20.getValue();
            if (mh(a6)) {
                const e21 = hh(a6);
                if (dh(a6)) {
                    const n10 = e21.split(fh);
                    if ("" === n10[0]) {
                        if (i7.push(""), n10.shift(), /\n/.test(n10[0])) {
                            const e22 = u5.children[t14 + 1];
                            i7.push(Ah(o6, n10[1], a6, e22));
                        } else i7.push(r7);
                        n10.shift();
                    }
                    let s5;
                    if ("" === ih(n10) && (n10.pop(), s5 = n10.pop()), 0 === n10.length) return;
                    if (n10.forEach((e22, t15)=>{
                        t15 % 2 == 1 ? i7.push(Hf) : i7.push(e22);
                    }), (void 0) !== s5) {
                        if (/\n/.test(s5)) {
                            const e22 = u5.children[t14 + 1];
                            i7.push(Ah(o6, ih(i7), a6, e22));
                        } else i7.push(r7);
                    } else {
                        const e22 = u5.children[t14 + 1];
                        i7.push(vh(o6, ih(i7), a6, e22));
                    }
                } else /\n/.test(e21) ? e21.match(/\n/g).length > 1 && (i7.push(""), i7.push(Xf)) : (i7.push(""), i7.push(r7));
            } else {
                const r8 = n9(e20);
                i7.push(r8);
                const s5 = u5.children[t14 + 1];
                if (s5 && dh(s5)) {
                    const e21 = hh(s5).trim().split(fh)[0];
                    i7.push(vh(o6, e21, a6, s5));
                } else i7.push(Xf);
            }
        }, "children"), i7;
    }(e18, 0, n8, d6, f5), m5 = r6.children.some((e19)=>dh(e19)
    );
    for(let e19 = h5.length - 2; e19 >= 0; e19--){
        const t13 = "" === h5[e19] && "" === h5[e19 + 1], n9 = h5[e19] === Xf && "" === h5[e19 + 1] && h5[e19 + 2] === Xf, r7 = (h5[e19] === Yf || h5[e19] === Xf) && "" === h5[e19 + 1] && h5[e19 + 2] === d6, o6 = h5[e19] === d6 && "" === h5[e19 + 1] && (h5[e19 + 2] === Yf || h5[e19 + 2] === Xf), u5 = h5[e19] === d6 && "" === h5[e19 + 1] && h5[e19 + 2] === d6, i7 = h5[e19] === Yf && "" === h5[e19 + 1] && h5[e19 + 2] === Xf || h5[e19] === Xf && "" === h5[e19 + 1] && h5[e19 + 2] === Yf;
        n9 && m5 || t13 || r7 || u5 || i7 ? h5.splice(e19, 2) : o6 && h5.splice(e19 + 1, 2);
    }
    for(; h5.length && (oh(ih(h5)) || uh(ih(h5)));)h5.pop();
    for(; h5.length && (oh(h5[0]) || uh(h5[0])) && (oh(h5[1]) || uh(h5[1]));)h5.shift(), h5.shift();
    const g6 = [];
    h5.forEach((e20, t13)=>{
        if (e20 === d6) {
            if (1 === t13 && "" === h5[t13 - 1]) return 2 === h5.length ? void g6.push(p6) : void g6.push(Gf([
                p6,
                Xf
            ]));
            if (t13 === h5.length - 1) return void g6.push(p6);
            if ("" === h5[t13 - 1] && h5[t13 - 2] === Xf) return void g6.push(p6);
        }
        g6.push(e20), rh(e20) && (l5 = !0);
    });
    const D5 = m5 ? eh(g6) : Kf(Gf(g6), {
        shouldBreak: !0
    });
    if (c6) return D5;
    const y6 = Kf(Gf([
        o5,
        Qf(Gf([
            Xf,
            D5
        ])),
        Xf,
        u4
    ]));
    return l5 ? y6 : Zf([
        Kf(Gf([
            o5,
            Gf(h5),
            u4
        ])),
        y6
    ]);
}
function vh(e18, t12, n8, r6) {
    return e18 ? "" : "JSXElement" === n8.type && !n8.closingElement || r6 && "JSXElement" === r6.type && !r6.closingElement ? 1 === t12.length ? Yf : Xf : Yf;
}
function Ah(e18, t12, n8, r6) {
    return e18 ? Xf : 1 === t12.length ? "JSXElement" === n8.type && !n8.closingElement || r6 && "JSXElement" === r6.type && !r6.closingElement ? Xf : Yf : Xf;
}
function Fh(e18, t12, n8) {
    const r6 = e18.getValue();
    return Gf([
        "{",
        e18.call((e19)=>{
            const r7 = Gf([
                "...",
                n8(e19)
            ]), o5 = e19.getValue();
            return o5.comments && o5.comments.length && Ch(e19) ? Gf([
                Qf(Gf([
                    Yf,
                    Jf(e19, ()=>r7
                    , t12)
                ])),
                Yf
            ]) : r7;
        }, "JSXSpreadAttribute" === r6.type ? "argument" : "expression"),
        "}"
    ]);
}
var xh = {
    printJsxElement: function(e18, t12, n8) {
        const r6 = Jf(e18, ()=>bh(e18, t12, n8)
        , t12);
        return function(e19, t13, n9) {
            const r7 = e19.getParentNode();
            if (!r7) return t13;
            if (({
                ArrayExpression: !0,
                JSXAttribute: !0,
                JSXElement: !0,
                JSXExpressionContainer: !0,
                JSXFragment: !0,
                ExpressionStatement: !0,
                CallExpression: !0,
                OptionalCallExpression: !0,
                ConditionalExpression: !0,
                JsExpressionRoot: !0
            })[r7.type]) return t13;
            const o5 = e19.match(void 0, (e20)=>"ArrowFunctionExpression" === e20.type
            , gh, (e20)=>"JSXExpressionContainer" === e20.type
            ), u4 = Pp(e19, n9);
            return Kf(Gf([
                u4 ? "" : th("("),
                Qf(Gf([
                    Yf,
                    t13
                ])),
                Yf,
                u4 ? "" : th(")")
            ]), {
                shouldBreak: o5
            });
        }(e18, r6, t12);
    },
    printJsxAttribute: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [];
        if ((o5.push(e18.call(n8, "name")), r6.value)) {
            let u4;
            if (Dh(r6.value)) {
                let e19 = hh(r6.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                const n9 = ah(e19, t12.jsxSingleQuote ? "'" : '"'), o6 = "'" === n9 ? "&apos;" : "&quot;";
                e19 = e19.slice(1, -1).replace(new RegExp(n9, "g"), o6), u4 = Gf([
                    n9,
                    e19,
                    n9
                ]);
            } else u4 = e18.call(n8, "value");
            o5.push("=", u4);
        }
        return Gf(o5);
    },
    printJsxOpeningElement: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = r6.name && r6.name.comments && r6.name.comments.length > 0 || r6.typeParameters && r6.typeParameters.comments && r6.typeParameters.comments.length > 0;
        if (r6.selfClosing && !r6.attributes.length && !o5) return Gf([
            "<",
            e18.call(n8, "name"),
            e18.call(n8, "typeParameters"),
            " />"
        ]);
        if (r6.attributes && 1 === r6.attributes.length && r6.attributes[0].value && Dh(r6.attributes[0].value) && !r6.attributes[0].value.value.includes("\n") && !o5 && (!r6.attributes[0].comments || !r6.attributes[0].comments.length)) return Kf(Gf([
            "<",
            e18.call(n8, "name"),
            e18.call(n8, "typeParameters"),
            " ",
            Gf(e18.map(n8, "attributes")),
            r6.selfClosing ? " />" : ">"
        ]));
        const u4 = r6.attributes.length && sh(ih(r6.attributes)), i6 = !r6.attributes.length && !o5 || t12.jsxBracketSameLine && (!o5 || r6.attributes.length) && !u4, a5 = r6.attributes && r6.attributes.some((e19)=>e19.value && Dh(e19.value) && e19.value.value.includes("\n")
        );
        return Kf(Gf([
            "<",
            e18.call(n8, "name"),
            e18.call(n8, "typeParameters"),
            Gf([
                Qf(Gf(e18.map((e19)=>Gf([
                        Hf,
                        n8(e19)
                    ])
                , "attributes"))),
                r6.selfClosing ? Hf : i6 ? ">" : Yf
            ]),
            r6.selfClosing ? "/>" : i6 ? "" : ">"
        ]), {
            shouldBreak: a5
        });
    },
    printJsxClosingElement: function(e18, t12, n8) {
        return Gf([
            "</",
            e18.call(n8, "name"),
            ">"
        ]);
    },
    printJsxOpeningClosingFragment: function(e18, t12) {
        const n8 = e18.getValue(), r6 = n8.comments && n8.comments.length, o5 = r6 && !n8.comments.every((e19)=>Eh(e19)
        ), u4 = "JSXOpeningFragment" === n8.type;
        return Gf([
            u4 ? "<" : "</",
            Qf(Gf([
                o5 ? Xf : r6 && !u4 ? " " : "",
                zf(e18, t12, !0)
            ])),
            o5 ? Xf : "",
            ">"
        ]);
    },
    printJsxExpressionContainer: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = e18.getParentNode(0), u4 = r6.expression.comments && r6.expression.comments.length > 0, i6 = "JSXEmptyExpression" === r6.expression.type || !u4 && ("ArrayExpression" === r6.expression.type || "ObjectExpression" === r6.expression.type || "ArrowFunctionExpression" === r6.expression.type || "CallExpression" === r6.expression.type || "OptionalCallExpression" === r6.expression.type || "FunctionExpression" === r6.expression.type || "TemplateLiteral" === r6.expression.type || "TaggedTemplateExpression" === r6.expression.type || "DoExpression" === r6.expression.type || ph(o5) && ("ConditionalExpression" === r6.expression.type || yh(r6.expression)));
        return Kf(Gf(i6 ? [
            "{",
            e18.call(n8, "expression"),
            nh,
            "}"
        ] : [
            "{",
            Qf(Gf([
                Yf,
                e18.call(n8, "expression")
            ])),
            Yf,
            nh,
            "}"
        ]));
    },
    printJsxEmptyExpression: function(e18, t12) {
        const n8 = e18.getValue(), r6 = n8.comments && !n8.comments.every((e19)=>Eh(e19)
        );
        return Gf([
            zf(e18, t12, !r6),
            r6 ? Xf : ""
        ]);
    },
    printJsxSpreadAttribute: Fh,
    printJsxSpreadChild: Fh
};
const { printDanglingComments: Sh  } = ya, { builders: { concat: wh , join: Th , line: Bh , hardline: Nh , softline: kh , group: Ph , indent: Oh , ifBreak: Ih  }  } = rn1, { hasDanglingComments: Lh , isTestCall: Mh , isBlockComment: jh , shouldPrintComma: _h  } = Cl, { shouldHugType: Rh  } = of, Vh = new WeakMap;
function $h(e18) {
    return Vh.has(e18) || Vh.set(e18, Symbol("typeParameters")), Vh.get(e18);
}
function qh(e18, t12) {
    const n8 = e18.getValue();
    if (!Lh(n8)) return "";
    const r6 = n8.comments.every((e19)=>jh(e19)
    ), o5 = Sh(e18, t12, r6);
    return r6 ? o5 : wh([
        o5,
        Nh
    ]);
}
var Wh = {
    printTypeParameters: function(e18, t12, n8, r6) {
        const o5 = e18.getValue();
        if (!o5[r6]) return "";
        if (!Array.isArray(o5[r6])) return e18.call(n8, r6);
        const u4 = e18.getNode(2);
        return null != u4 && Mh(u4) || 0 === o5[r6].length || 1 === o5[r6].length && (Rh(o5[r6][0]) || "GenericTypeAnnotation" === o5[r6][0].type && Rh(o5[r6][0].id) || "TSTypeReference" === o5[r6][0].type && Rh(o5[r6][0].typeName) || "NullableTypeAnnotation" === o5[r6][0].type) ? wh([
            "<",
            Th(", ", e18.map(n8, r6)),
            qh(e18, t12),
            ">"
        ]) : Ph(wh([
            "<",
            Oh(wh([
                kh,
                Th(wh([
                    ",",
                    Bh
                ]), e18.map(n8, r6))
            ])),
            Ih("typescript" !== t12.parser && "babel-ts" !== t12.parser && _h(t12, "all") ? "," : ""),
            kh,
            ">"
        ]), {
            id: $h(o5)
        });
    },
    getTypeParametersGroupId: $h
};
const { printComments: Uh  } = ya, { printString: Jh , printNumber: zh  } = Nt1, { builders: { concat: Gh  }  } = rn1, { isNumericLiteral: Hh , isSimpleNumber: Xh , isStringLiteral: Yh , isStringPropSafeToUnquote: Kh , rawText: Qh  } = Cl, Zh = new WeakMap;
var em = {
    printPropertyKey: function(e18, t12, n8) {
        const r6 = e18.getNode();
        if (r6.computed) return Gh([
            "[",
            e18.call(n8, "key"),
            "]"
        ]);
        const o5 = e18.getParentNode(), { key: u4  } = r6;
        if ("ClassPrivateProperty" === r6.type && "Identifier" === u4.type) return Gh([
            "#",
            e18.call(n8, "key")
        ]);
        if ("consistent" === t12.quoteProps && !Zh.has(o5)) {
            const e19 = (o5.properties || o5.body || o5.members).some((e20)=>!e20.computed && e20.key && Yh(e20.key) && !Kh(e20, t12)
            );
            Zh.set(o5, e19);
        }
        if (("Identifier" === u4.type || Hh(u4) && Xh(zh(Qh(u4))) && String(u4.value) === zh(Qh(u4)) && "typescript" !== t12.parser && "babel-ts" !== t12.parser) && ("json" === t12.parser || "consistent" === t12.quoteProps && Zh.get(o5))) {
            const n9 = Jh(JSON.stringify("Identifier" === u4.type ? u4.name : u4.value.toString()), t12);
            return e18.call((e19)=>Uh(e19, ()=>n9
                , t12)
            , "key");
        }
        return Kh(r6, t12) && ("as-needed" === t12.quoteProps || "consistent" === t12.quoteProps && !Zh.get(o5)) ? e18.call((e19)=>Uh(e19, ()=>/^\d/.test(u4.value) ? zh(u4.value) : u4.value
            , t12)
        , "key") : e18.call(n8, "key");
    }
};
const { printDanglingComments: tm  } = ya, { getNextNonSpaceNonCommentCharacterIndex: nm  } = Nt1, { builders: { concat: rm , line: om , softline: um , group: im , indent: am , ifBreak: sm , hardline: lm  }  } = rn1, { getFunctionParameters: cm , hasDanglingComments: pm , hasLeadingOwnLineComment: dm , isFlowAnnotationComment: fm , isJSXNode: hm , isTemplateOnItsOwnLine: mm , shouldPrintComma: gm , startsWithNoLookaheadToken: Dm , returnArgumentHasLeadingComment: ym , isBinaryish: Em , isLineComment: Cm  } = Cl, { locEnd: bm  } = ei, { printFunctionParameters: vm  } = Zd, { printPropertyKey: Am  } = em, { printFunctionTypeParameters: Fm  } = Xp;
function xm(e18, t12, n8) {
    const r6 = [
        Fm(e18, t12, n8),
        im(rm([
            vm(e18, n8, t12),
            wm(e18, n8, t12)
        ]))
    ];
    return e18.getNode().body ? r6.push(" ", e18.call(n8, "body")) : r6.push(t12.semi ? ";" : ""), rm(r6);
}
function Sm(e18, t12) {
    if ("always" === t12.arrowParens) return !1;
    if ("avoid" === t12.arrowParens) {
        return (function(e19) {
            const t13 = cm(e19);
            return !(1 !== t13.length || e19.typeParameters || pm(e19) || "Identifier" !== t13[0].type || t13[0].typeAnnotation || t13[0].comments || t13[0].optional || e19.predicate || e19.returnType);
        })(e18.getValue());
    }
    return !1;
}
function wm(e18, t12, n8) {
    const r6 = e18.getValue(), o5 = e18.call(t12, "returnType");
    if (r6.returnType && fm(n8.originalText, r6.returnType)) return rm([
        " /*: ",
        o5,
        " */"
    ]);
    const u4 = [
        o5
    ];
    return r6.returnType && r6.returnType.typeAnnotation && u4.unshift(": "), r6.predicate && u4.push(r6.returnType ? " " : ": ", e18.call(t12, "predicate")), rm(u4);
}
var Tm = {
    printFunctionDeclaration: function(e18, t12, n8, r6) {
        const o5 = e18.getValue(), u4 = [];
        return (o5.async && u4.push("async "), o5.generator ? u4.push("function* ") : u4.push("function "), o5.id && u4.push(e18.call(t12, "id")), u4.push(Fm(e18, n8, t12), im(rm([
            vm(e18, t12, n8, r6),
            wm(e18, t12, n8)
        ])), o5.body ? " " : "", e18.call(t12, "body")), rm(u4));
    },
    printArrowFunctionExpression: function(e18, t12, n8, r6) {
        const o5 = e18.getValue(), u4 = [];
        o5.async && u4.push("async "), Sm(e18, t12) ? u4.push(e18.call(n8, "params", 0)) : u4.push(im(rm([
            vm(e18, n8, t12, r6 && (r6.expandLastArg || r6.expandFirstArg), !0),
            wm(e18, n8, t12)
        ])));
        const i6 = tm(e18, t12, !0, (e19)=>{
            const n9 = nm(t12.originalText, e19, bm);
            return !1 !== n9 && "=>" === t12.originalText.slice(n9, n9 + 2);
        });
        i6 && u4.push(" ", i6), u4.push(" =>");
        const a5 = e18.call((e19)=>n8(e19, r6)
        , "body");
        if (!dm(t12.originalText, o5.body) && ("ArrayExpression" === o5.body.type || "ObjectExpression" === o5.body.type || "BlockStatement" === o5.body.type || hm(o5.body) || mm(o5.body, t12.originalText) || "ArrowFunctionExpression" === o5.body.type || "DoExpression" === o5.body.type)) return im(rm([
            rm(u4),
            " ",
            a5
        ]));
        if ("SequenceExpression" === o5.body.type) return im(rm([
            rm(u4),
            im(rm([
                " (",
                am(rm([
                    um,
                    a5
                ])),
                um,
                ")"
            ]))
        ]));
        const s4 = (r6 && r6.expandLastArg || "JSXExpressionContainer" === e18.getParentNode().type) && !(o5.comments && o5.comments.length), l5 = r6 && r6.expandLastArg && gm(t12, "all"), c6 = "ConditionalExpression" === o5.body.type && !Dm(o5.body, !1);
        return im(rm([
            rm(u4),
            im(rm([
                am(rm([
                    om,
                    c6 ? sm("", "(") : "",
                    a5,
                    c6 ? sm("", ")") : ""
                ])),
                s4 ? rm([
                    sm(l5 ? "," : ""),
                    um
                ]) : ""
            ]))
        ]));
    },
    printMethod: function(e18, t12, n8) {
        const r6 = e18.getNode(), { kind: o5  } = r6, u4 = r6.value || r6, i6 = [];
        return (o5 && "init" !== o5 && "method" !== o5 && "constructor" !== o5 ? (Xi.ok("get" === o5 || "set" === o5), i6.push(o5, " ")) : u4.async && i6.push("async "), u4.generator && i6.push("*"), i6.push(Am(e18, t12, n8), r6.optional || r6.key.optional ? "?" : "", r6 === u4 ? xm(e18, t12, n8) : e18.call((e19)=>xm(e19, t12, n8)
        , "value")), rm(i6));
    },
    printReturnAndThrowArgument: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = t12.semi ? ";" : "", u4 = [];
        r6.argument && (ym(t12, r6.argument) ? u4.push(rm([
            " (",
            am(rm([
                lm,
                e18.call(n8, "argument")
            ])),
            lm,
            ")"
        ])) : Em(r6.argument) || "SequenceExpression" === r6.argument.type ? u4.push(im(rm([
            sm(" (", " "),
            am(rm([
                um,
                e18.call(n8, "argument")
            ])),
            um,
            sm(")")
        ]))) : u4.push(" ", e18.call(n8, "argument")));
        const i6 = Array.isArray(r6.comments) && r6.comments[r6.comments.length - 1], a5 = i6 && Cm(i6);
        return (a5 && u4.push(o5), pm(r6) && u4.push(" ", tm(e18, t12, !0)), a5 || u4.push(o5), rm(u4));
    },
    shouldPrintParamsWithoutParens: Sm
};
const { printComments: Bm , printDanglingComments: Nm  } = ya, { builders: { concat: km , join: Pm , line: Om , hardline: Im , softline: Lm , group: Mm , indent: jm , ifBreak: _m  }  } = rn1, { hasTrailingComment: Rm , hasTrailingLineComment: Vm  } = Cl, { getTypeParametersGroupId: $m  } = Wh, { printMethod: qm  } = Tm, { printDecorators: Wm  } = Xp;
function Um(e18) {
    return e18.typeParameters && !Vm(e18.typeParameters) && !(function(e19) {
        return [
            "superClass",
            "extends",
            "mixins",
            "implements"
        ].filter((t12)=>!!e19[t12]
        ).length > 1;
    })(e18);
}
function Jm(e18, t12, n8, r6) {
    const o5 = e18.getValue();
    if (!o5[r6] || 0 === o5[r6].length) return "";
    const u4 = Nm(e18, t12, !0, ({ marker: e19  })=>e19 === r6
    );
    return km([
        Um(o5) ? _m(" ", Om, {
            groupId: $m(o5.typeParameters)
        }) : Om,
        u4,
        u4 && Im,
        r6,
        Mm(jm(km([
            Om,
            Pm(km([
                ",",
                Om
            ]), e18.map(n8, r6))
        ])))
    ]);
}
function zm(e18, t12, n8) {
    const r6 = e18.call(n8, "superClass");
    return "AssignmentExpression" === e18.getParentNode().type ? Mm(_m(km([
        "(",
        jm(km([
            Lm,
            r6
        ])),
        Lm,
        ")"
    ]), r6)) : r6;
}
var Gm = {
    printClass: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [];
        r6.abstract && o5.push("abstract "), o5.push("class");
        const u4 = r6.id && Rm(r6.id) || r6.superClass && r6.superClass.comments && 0 !== r6.superClass.comments.length || r6.extends && 0 !== r6.extends.length || r6.mixins && 0 !== r6.mixins.length || r6.implements && 0 !== r6.implements.length, i6 = [], a5 = [];
        if ((r6.id && i6.push(" ", e18.call(n8, "id")), i6.push(e18.call(n8, "typeParameters")), r6.superClass)) {
            const r7 = km([
                "extends ",
                zm(e18, t12, n8),
                e18.call(n8, "superTypeParameters")
            ]), o6 = e18.call((e19)=>Bm(e19, ()=>r7
                , t12)
            , "superClass");
            u4 ? a5.push(Om, Mm(o6)) : a5.push(" ", o6);
        } else a5.push(Jm(e18, t12, n8, "extends"));
        if ((a5.push(Jm(e18, t12, n8, "mixins")), a5.push(Jm(e18, t12, n8, "implements")), u4)) {
            const e19 = km(a5);
            Um(r6) ? o5.push(Mm(km(i6.concat(_m(jm(e19), e19))))) : o5.push(Mm(jm(km(i6.concat(e19)))));
        } else o5.push(...i6, ...a5);
        return (o5.push(" ", e18.call(n8, "body")), km(o5));
    },
    printClassMethod: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [];
        return (r6.decorators && 0 !== r6.decorators.length && o5.push(Wm(e18, t12, n8)), r6.accessibility && o5.push(r6.accessibility + " "), r6.static && o5.push("static "), ("TSAbstractMethodDefinition" === r6.type || r6.abstract) && o5.push("abstract "), o5.push(qm(e18, t12, n8)), km(o5));
    }
};
const { getLast: Hm , getPenultimate: Xm , isNextLineEmpty: Ym  } = Nt1, { getFunctionParameters: Km , iterateFunctionParametersPath: Qm , hasLeadingComment: Zm , hasTrailingComment: eg , isFunctionCompositionArgs: tg , isJSXNode: ng , isLongCurriedCallExpression: rg , shouldPrintComma: og , getCallArguments: ug , iterateCallArgumentsPath: ig  } = Cl, { locEnd: ag  } = ei, { builders: { concat: sg , line: lg , hardline: cg , softline: pg , group: dg , indent: fg , conditionalGroup: hg , ifBreak: mg , breakParent: gg  } , utils: { willBreak: Dg  }  } = rn1;
function yg(e18) {
    return "ObjectExpression" === e18.type && (e18.properties.length > 0 || e18.comments) || "ArrayExpression" === e18.type && (e18.elements.length > 0 || e18.comments) || "TSTypeAssertion" === e18.type && yg(e18.expression) || "TSAsExpression" === e18.type && yg(e18.expression) || "FunctionExpression" === e18.type || "ArrowFunctionExpression" === e18.type && (!e18.returnType || !e18.returnType.typeAnnotation || "TSTypeReference" !== e18.returnType.typeAnnotation.type) && ("BlockStatement" === e18.body.type || "ArrowFunctionExpression" === e18.body.type || "ObjectExpression" === e18.body.type || "ArrayExpression" === e18.body.type || "CallExpression" === e18.body.type || "OptionalCallExpression" === e18.body.type || "ConditionalExpression" === e18.body.type || ng(e18.body));
}
var Eg = function(e18, t12, n8) {
    const r6 = e18.getValue(), o5 = "ImportExpression" === r6.type, u4 = ug(r6);
    if (0 === u4.length) return sg([
        "(",
        ya.printDanglingComments(e18, t12, !0),
        ")"
    ]);
    if (2 === u4.length && "ArrowFunctionExpression" === u4[0].type && 0 === Km(u4[0]).length && "BlockStatement" === u4[0].body.type && "ArrayExpression" === u4[1].type && !u4.some((e19)=>e19.comments
    )) return sg([
        "(",
        e18.call(n8, "arguments", 0),
        ", ",
        e18.call(n8, "arguments", 1),
        ")"
    ]);
    let i6 = !1, a5 = !1, s4 = !1;
    const l5 = u4.length - 1, c6 = [];
    ig(e18, (e19, r7)=>{
        const o6 = e19.getNode(), u5 = [
            n8(e19)
        ];
        r7 === l5 || (Ym(t12.originalText, o6, ag) ? (0 === r7 && (s4 = !0), i6 = !0, u5.push(",", cg, cg)) : u5.push(",", lg)), a5 = (function(e20, t13) {
            if (!e20 || "ArrowFunctionExpression" !== e20.type || !e20.body || "BlockStatement" !== e20.body.type || 0 === Km(e20).length) return !1;
            let r8 = !1;
            return Qm(t13, (e21)=>{
                r8 = r8 || Dg(sg([
                    n8(e21)
                ]));
            }), r8;
        })(o6, e19), c6.push(sg(u5));
    });
    const p6 = o5 || r6.callee && "Import" === r6.callee.type || !og(t12, "all") ? "" : ",";
    function d6() {
        return dg(sg([
            "(",
            fg(sg([
                lg,
                sg(c6)
            ])),
            p6,
            lg,
            ")"
        ]), {
            shouldBreak: !0
        });
    }
    if ("Decorator" !== e18.getParentNode().type && tg(u4)) return d6();
    const f5 = function(e19) {
        if (2 !== e19.length) return !1;
        const [t13, n9] = e19;
        return !(t13.comments && t13.comments.length || "FunctionExpression" !== t13.type && ("ArrowFunctionExpression" !== t13.type || "BlockStatement" !== t13.body.type) || "FunctionExpression" === n9.type || "ArrowFunctionExpression" === n9.type || "ConditionalExpression" === n9.type || yg(n9));
    }(u4), h5 = function(e19) {
        const t13 = Hm(e19), n9 = Xm(e19);
        return !Zm(t13) && !eg(t13) && yg(t13) && (!n9 || n9.type !== t13.type);
    }(u4);
    if (f5 || h5) {
        const t13 = (f5 ? c6.slice(1).some(Dg) : c6.slice(0, -1).some(Dg)) || i6 || a5;
        let o6 = [];
        ig(e18, (e19, t14)=>{
            f5 && 0 === t14 && (o6 = [
                sg([
                    e19.call((e20)=>n8(e20, {
                            expandFirstArg: !0
                        })
                    ),
                    c6.length > 1 ? "," : "",
                    s4 ? cg : lg,
                    s4 ? cg : ""
                ])
            ].concat(c6.slice(1))), h5 && t14 === u4.length - 1 && (o6 = c6.slice(0, -1).concat(e19.call((e20)=>n8(e20, {
                    expandLastArg: !0
                })
            )));
        });
        const l6 = c6.some(Dg), p7 = sg([
            "(",
            sg(o6),
            ")"
        ]);
        return sg([
            l6 ? gg : "",
            hg([
                l6 || r6.typeArguments || r6.typeParameters ? mg(d6(), p7) : p7,
                sg(f5 ? [
                    "(",
                    dg(o6[0], {
                        shouldBreak: !0
                    }),
                    sg(o6.slice(1)),
                    ")"
                ] : [
                    "(",
                    sg(c6.slice(0, -1)),
                    dg(Hm(o6), {
                        shouldBreak: !0
                    }),
                    ")"
                ]),
                d6()
            ], {
                shouldBreak: t13
            })
        ]);
    }
    const m5 = sg([
        "(",
        fg(sg([
            pg,
            sg(c6)
        ])),
        mg(p6),
        pg,
        ")"
    ]);
    return rg(e18) ? m5 : dg(m5, {
        shouldBreak: c6.some(Dg) || i6
    });
};
const { builders: { concat: Cg , softline: bg , group: vg , indent: Ag  }  } = rn1, { isNumericLiteral: Fg  } = Cl, { printOptionalToken: xg  } = Xp;
function Sg(e18, t12, n8) {
    const r6 = e18.call(n8, "property"), o5 = e18.getValue(), u4 = xg(e18);
    return o5.computed ? !o5.property || Fg(o5.property) ? Cg([
        u4,
        "[",
        r6,
        "]"
    ]) : vg(Cg([
        u4,
        "[",
        Ag(Cg([
            bg,
            r6
        ])),
        bg,
        "]"
    ])) : Cg([
        u4,
        ".",
        r6
    ]);
}
var wg = {
    printMemberExpression: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = e18.getParentNode();
        let u4, i6 = 0;
        do {
            u4 = e18.getParentNode(i6), i6++;
        }while (u4 && ("MemberExpression" === u4.type || "OptionalMemberExpression" === u4.type || "TSNonNullExpression" === u4.type))
        const a5 = u4 && ("NewExpression" === u4.type || "BindExpression" === u4.type || "VariableDeclarator" === u4.type && "Identifier" !== u4.id.type || "AssignmentExpression" === u4.type && "Identifier" !== u4.left.type) || r6.computed || "Identifier" === r6.object.type && "Identifier" === r6.property.type && "MemberExpression" !== o5.type && "OptionalMemberExpression" !== o5.type;
        return Cg([
            e18.call(n8, "object"),
            a5 ? Sg(e18, t12, n8) : vg(Ag(Cg([
                bg,
                Sg(e18, t12, n8)
            ])))
        ]);
    },
    printMemberLookup: Sg
};
const { getLast: Tg , isNextLineEmpty: Bg , isNextLineEmptyAfterIndex: Ng , getNextNonSpaceNonCommentCharacterIndex: kg  } = Nt1, { hasLeadingComment: Pg , hasTrailingComment: Og , isCallOrOptionalCallExpression: Ig , isFunctionOrArrowExpression: Lg , isLongCurriedCallExpression: Mg , isMemberish: jg , isNumericLiteral: _g , isSimpleCallArgument: Rg  } = Cl, { locEnd: Vg  } = ei, { builders: { concat: $g , join: qg , hardline: Wg , group: Ug , indent: Jg , conditionalGroup: zg , breakParent: Gg  } , utils: { willBreak: Hg  }  } = rn1, { printMemberLookup: Xg  } = wg, { printOptionalToken: Yg , printFunctionTypeParameters: Kg , printBindExpressionCallee: Qg  } = Xp;
var Zg = function(e18, t12, n8) {
    const r6 = e18.getParentNode(), o5 = !r6 || "ExpressionStatement" === r6.type, u4 = [];
    function i6(e19) {
        const { originalText: n9  } = t12, r7 = kg(n9, e19, Vg);
        return ")" === n9.charAt(r7) ? !1 !== r7 && Ng(n9, r7 + 1) : Bg(n9, e19, Vg);
    }
    function a5(e19) {
        const r7 = e19.getValue();
        Ig(r7) && (jg(r7.callee) || Ig(r7.callee)) ? (u4.unshift({
            node: r7,
            printed: $g([
                ya.printComments(e19, ()=>$g([
                        Yg(e19),
                        Kg(e19, t12, n8),
                        Eg(e19, t12, n8)
                    ])
                , t12),
                i6(r7) ? Wg : ""
            ])
        }), e19.call((e20)=>a5(e20)
        , "callee")) : jg(r7) ? (u4.unshift({
            node: r7,
            needsParens: Pp(e19, t12),
            printed: ya.printComments(e19, ()=>"OptionalMemberExpression" === r7.type || "MemberExpression" === r7.type ? Xg(e19, t12, n8) : Qg(e19, t12, n8)
            , t12)
        }), e19.call((e20)=>a5(e20)
        , "object")) : "TSNonNullExpression" === r7.type ? (u4.unshift({
            node: r7,
            printed: ya.printComments(e19, ()=>"!"
            , t12)
        }), e19.call((e20)=>a5(e20)
        , "expression")) : u4.unshift({
            node: r7,
            printed: e19.call(n8)
        });
    }
    const s4 = e18.getValue();
    u4.unshift({
        node: s4,
        printed: $g([
            Yg(e18),
            Kg(e18, t12, n8),
            Eg(e18, t12, n8)
        ])
    }), s4.callee && e18.call((e19)=>a5(e19)
    , "callee");
    const l5 = [];
    let c6 = [
        u4[0]
    ], p6 = 1;
    for(; p6 < u4.length && ("TSNonNullExpression" === u4[p6].node.type || Ig(u4[p6].node) || ("MemberExpression" === u4[p6].node.type || "OptionalMemberExpression" === u4[p6].node.type) && u4[p6].node.computed && _g(u4[p6].node.property)); ++p6)c6.push(u4[p6]);
    if (!Ig(u4[0].node)) for(; p6 + 1 < u4.length && (jg(u4[p6].node) && jg(u4[p6 + 1].node)); ++p6)c6.push(u4[p6]);
    l5.push(c6), c6 = [];
    let d6 = !1;
    for(; p6 < u4.length; ++p6){
        if (d6 && jg(u4[p6].node)) {
            if (u4[p6].node.computed && _g(u4[p6].node.property)) {
                c6.push(u4[p6]);
                continue;
            }
            l5.push(c6), c6 = [], d6 = !1;
        }
        (Ig(u4[p6].node) || "ImportExpression" === u4[p6].node.type) && (d6 = !0), c6.push(u4[p6]), u4[p6].node.comments && u4[p6].node.comments.some((e19)=>e19.trailing
        ) && (l5.push(c6), c6 = [], d6 = !1);
    }
    function f5(e19) {
        return /^[A-Z]|^[$_]+$/.test(e19);
    }
    c6.length > 0 && l5.push(c6);
    const h5 = l5.length >= 2 && !l5[1][0].node.comments && function(e19) {
        const n9 = e19[1].length && e19[1][0].node.computed;
        if (1 === e19[0].length) {
            const r7 = e19[0][0].node;
            return "ThisExpression" === r7.type || "Identifier" === r7.type && (f5(r7.name) || o5 && (function(e20) {
                return e20.length <= t12.tabWidth;
            })(r7.name) || n9);
        }
        const r7 = Tg(e19[0]).node;
        return ("MemberExpression" === r7.type || "OptionalMemberExpression" === r7.type) && "Identifier" === r7.property.type && (f5(r7.property.name) || n9);
    }(l5);
    function m5(e19) {
        const t13 = e19.map((e20)=>e20.printed
        );
        return e19.length > 0 && e19[e19.length - 1].needsParens ? $g([
            "(",
            ...t13,
            ")"
        ]) : $g(t13);
    }
    const g6 = l5.map(m5), D5 = $g(g6), y6 = h5 ? 3 : 2, E5 = Uu(l5), C4 = E5.slice(1, -1).some((e19)=>Pg(e19.node)
    ) || E5.slice(0, -1).some((e19)=>Og(e19.node)
    ) || l5[y6] && Pg(l5[y6][0].node);
    if (l5.length <= y6 && !C4) return Mg(e18) ? D5 : Ug(D5);
    const b4 = Tg(l5[h5 ? 1 : 0]).node, v5 = !Ig(b4) && i6(b4), A5 = $g([
        m5(l5[0]),
        h5 ? $g(l5.slice(1, 2).map(m5)) : "",
        v5 ? Wg : "",
        function(e19) {
            return 0 === e19.length ? "" : Jg(Ug($g([
                Wg,
                qg(Wg, e19.map(m5))
            ])));
        }(l5.slice(h5 ? 2 : 1))
    ]), F4 = u4.map(({ node: e19  })=>e19
    ).filter(Ig);
    return C4 || F4.length > 2 && F4.some((e19)=>!e19.arguments.every((e20)=>Rg(e20, 0)
        )
    ) || g6.slice(0, -1).some(Hg) || function() {
        const e19 = Tg(Tg(l5)).node, t13 = Tg(g6);
        return Ig(e19) && Hg(t13) && F4.slice(0, -1).some((e20)=>e20.arguments.some(Lg)
        );
    }() ? Ug(A5) : $g([
        Hg(D5) || v5 ? Gg : "",
        zg([
            D5,
            A5
        ])
    ]);
};
const { builders: { concat: eD , join: tD , group: nD  }  } = rn1, { getCallArguments: rD , hasFlowAnnotationComment: oD , isCallOrOptionalCallExpression: uD , isMemberish: iD , isTemplateOnItsOwnLine: aD , isTestCall: sD , iterateCallArgumentsPath: lD  } = Cl, { printOptionalToken: cD , printFunctionTypeParameters: pD  } = Xp;
var dD = {
    printCallExpression: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = "NewExpression" === r6.type, u4 = "ImportExpression" === r6.type, i6 = cD(e18), a5 = rD(r6);
        if (a5.length > 0 && (!u4 && !o5 && "Identifier" === r6.callee.type && ("require" === r6.callee.name || "define" === r6.callee.name) || 1 === a5.length && aD(a5[0], t12.originalText) || !o5 && sD(r6, e18.getParentNode()))) {
            const r7 = [];
            return (lD(e18, (e19)=>{
                r7.push(n8(e19));
            }), eD([
                o5 ? "new " : "",
                e18.call(n8, "callee"),
                i6,
                pD(e18, t12, n8),
                eD([
                    "(",
                    tD(", ", r7),
                    ")"
                ])
            ]));
        }
        const s4 = ("babel" === t12.parser || "babel-flow" === t12.parser) && r6.callee && "Identifier" === r6.callee.type && oD(r6.callee.trailingComments);
        if ((s4 && (r6.callee.trailingComments[0].printed = !0), !u4 && !o5 && iD(r6.callee) && !e18.call((e19)=>Pp(e19, t12)
        , "callee"))) return Zg(e18, t12, n8);
        const l5 = eD([
            o5 ? "new " : "",
            u4 ? "import" : e18.call(n8, "callee"),
            i6,
            s4 ? "/*:: ".concat(r6.callee.trailingComments[0].value.slice(2).trim(), " */") : "",
            pD(e18, t12, n8),
            Eg(e18, t12, n8)
        ]);
        return u4 || uD(r6.callee) ? nD(l5) : l5;
    }
};
const { builders: { concat: fD , join: hD , line: mD , group: gD , indent: DD , ifBreak: yD  }  } = rn1, { hasTrailingComment: ED , hasTrailingLineComment: CD , identity: bD  } = Cl, { getTypeParametersGroupId: vD  } = Wh, { printTypeScriptModifiers: AD  } = Xp;
var FD = {
    printInterface: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [];
        ("DeclareInterface" === r6.type || r6.declare) && o5.push("declare "), "TSInterfaceDeclaration" === r6.type && o5.push(r6.abstract ? "abstract " : "", AD(e18, t12, n8)), o5.push("interface");
        const u4 = [], i6 = [];
        "InterfaceTypeAnnotation" !== r6.type && u4.push(" ", e18.call(n8, "id"), e18.call(n8, "typeParameters"));
        const a5 = r6.typeParameters && !CD(r6.typeParameters);
        if ((r6.extends && 0 !== r6.extends.length && i6.push(a5 ? yD(" ", mD, {
            groupId: vD(r6.typeParameters)
        }) : mD, "extends ", (1 === r6.extends.length ? bD : DD)(hD(fD([
            ",",
            mD
        ]), e18.map(n8, "extends")))), r6.id && ED(r6.id) || r6.extends && 0 !== r6.extends.length)) {
            const e19 = fD(i6);
            a5 ? o5.push(gD(fD(u4.concat(yD(DD(e19), e19))))) : o5.push(gD(DD(fD(u4.concat(e19)))));
        } else o5.push(...u4, ...i6);
        return (o5.push(" ", e18.call(n8, "body")), gD(fD(o5)));
    }
};
const { printComments: xD  } = ya, { getLast: SD  } = Nt1, { builders: { concat: wD , join: TD , line: BD , softline: ND , group: kD , indent: PD , align: OD , ifBreak: ID  } , utils: { normalizeParts: LD  }  } = rn1, { hasLeadingOwnLineComment: MD , hasTrailingLineComment: jD , isBinaryish: _D , isJSXNode: RD , shouldFlatten: VD  } = Cl;
function qD(e18, t12, n8, r6, o5) {
    let u4 = [];
    const i6 = e18.getValue();
    if (_D(i6)) {
        VD(i6.operator, i6.left.operator) ? u4 = u4.concat(e18.call((e19)=>qD(e19, t12, n8, !0, o5)
        , "left")) : u4.push(kD(e18.call(t12, "left")));
        const a5 = WD(i6), s4 = ("|>" === i6.operator || "NGPipeExpression" === i6.type || "|" === i6.operator && "__vue_expression" === n8.parser) && !MD(n8.originalText, i6.right), l5 = "NGPipeExpression" === i6.type ? "|" : i6.operator, c6 = "NGPipeExpression" === i6.type && 0 !== i6.arguments.length ? kD(PD(wD([
            ND,
            ": ",
            TD(wD([
                ND,
                ":",
                ID(" ")
            ]), e18.map(t12, "arguments").map((e19)=>OD(2, kD(e19))
            ))
        ]))) : "", p6 = wD(a5 ? [
            l5,
            " ",
            e18.call(t12, "right"),
            c6
        ] : [
            s4 ? BD : "",
            l5,
            s4 ? " " : BD,
            e18.call(t12, "right"),
            c6
        ]), d6 = e18.getParentNode(), f5 = jD(i6.left), h5 = f5 || !(o5 && "LogicalExpression" === i6.type) && d6.type !== i6.type && i6.left.type !== i6.type && i6.right.type !== i6.type;
        u4.push(s4 ? "" : " ", h5 ? kD(p6, {
            shouldBreak: f5
        }) : p6), r6 && i6.comments && (u4 = LD(xD(e18, ()=>wD(u4)
        , n8).parts));
    } else u4.push(kD(e18.call(t12)));
    return u4;
}
function WD(e18) {
    return "LogicalExpression" === e18.type && ("ObjectExpression" === e18.right.type && 0 !== e18.right.properties.length || ("ArrayExpression" === e18.right.type && 0 !== e18.right.elements.length || !!RD(e18.right)));
}
var UD = {
    printBinaryishExpression: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = e18.getParentNode(), u4 = e18.getParentNode(1), i6 = r6 !== o5.body && ("IfStatement" === o5.type || "WhileStatement" === o5.type || "SwitchStatement" === o5.type || "DoWhileStatement" === o5.type), a5 = qD(e18, n8, t12, !1, i6);
        if (i6) return wD(a5);
        if (("CallExpression" === o5.type || "OptionalCallExpression" === o5.type) && o5.callee === r6 || "UnaryExpression" === o5.type || ("MemberExpression" === o5.type || "OptionalMemberExpression" === o5.type) && !o5.computed) return kD(wD([
            PD(wD([
                ND,
                wD(a5)
            ])),
            ND
        ]));
        const s4 = "ReturnStatement" === o5.type || "ThrowStatement" === o5.type || "JSXExpressionContainer" === o5.type && "JSXAttribute" === u4.type || "|" !== r6.operator && "JsExpressionRoot" === o5.type || "NGPipeExpression" !== r6.type && ("NGRoot" === o5.type && "__ng_binding" === t12.parser || "NGMicrosyntaxExpression" === o5.type && "NGMicrosyntax" === u4.type && 1 === u4.body.length) || r6 === o5.body && "ArrowFunctionExpression" === o5.type || r6 !== o5.body && "ForStatement" === o5.type || "ConditionalExpression" === o5.type && "ReturnStatement" !== u4.type && "ThrowStatement" !== u4.type && "CallExpression" !== u4.type && "OptionalCallExpression" !== u4.type || "TemplateLiteral" === o5.type, l5 = "AssignmentExpression" === o5.type || "VariableDeclarator" === o5.type || "ClassProperty" === o5.type || "FieldDefinition" === o5.type || "TSAbstractClassProperty" === o5.type || "ClassPrivateProperty" === o5.type || "ObjectProperty" === o5.type || "Property" === o5.type, c6 = _D(r6.left) && VD(r6.operator, r6.left.operator);
        if (s4 || WD(r6) && !c6 || !WD(r6) && l5) return kD(wD(a5));
        if (0 === a5.length) return "";
        const p6 = RD(r6.right), d6 = a5.findIndex((e19)=>"string" != typeof e19 && "group" === e19.type
        ), f5 = a5.slice(0, -1 === d6 ? 1 : d6 + 1), h5 = wD(a5.slice(f5.length, p6 ? -1 : void 0)), m5 = Symbol("logicalChain-" + ++$D), g6 = kD(wD([
            ...f5,
            PD(h5)
        ]), {
            id: m5
        });
        if (!p6) return g6;
        const D5 = SD(a5);
        return kD(wD([
            g6,
            ID(PD(D5), D5, {
                groupId: m5
            })
        ]));
    },
    shouldInlineLogicalExpression: WD
};
const { builders: { concat: JD , line: zD , group: GD , indent: HD  }  } = rn1, { hasLeadingOwnLineComment: XD , isBinaryish: YD , isMemberExpressionChain: KD , isStringLiteral: QD  } = Cl, { shouldInlineLogicalExpression: ZD  } = UD;
function ey(e18, t12, n8, r6, o5, u4) {
    if (!r6) return t12;
    const i6 = ty(e18, r6, o5, u4);
    return GD(JD([
        t12,
        n8,
        i6
    ]));
}
function ty(e18, t12, n8, r6) {
    if (XD(r6.originalText, t12)) return HD(JD([
        zD,
        n8
    ]));
    return YD(t12) && !ZD(t12) || "ConditionalExpression" === t12.type && YD(t12.test) && !ZD(t12.test) || "StringLiteralTypeAnnotation" === t12.type || "ClassExpression" === t12.type && t12.decorators && t12.decorators.length || ("Identifier" === e18.type || QD(e18) || "MemberExpression" === e18.type) && (QD(t12) || KD(t12)) && "json" !== r6.parser && "json5" !== r6.parser || "SequenceExpression" === t12.type ? GD(HD(JD([
        zD,
        n8
    ]))) : JD([
        " ",
        n8
    ]);
}
var ny = {
    printVariableDeclarator: function(e18, t12, n8) {
        const r6 = e18.getValue();
        return ey(r6.id, e18.call(n8, "id"), " =", r6.init, r6.init && e18.call(n8, "init"), t12);
    },
    printAssignmentExpression: function(e18, t12, n8) {
        const r6 = e18.getValue();
        return ey(r6.left, e18.call(n8, "left"), JD([
            " ",
            r6.operator
        ]), r6.right, e18.call(n8, "right"), t12);
    },
    printAssignment: ey,
    printAssignmentRight: ty
};
const { isNextLineEmpty: ry  } = Nt1, { builders: { concat: oy , join: uy , hardline: iy  }  } = rn1, { classChildNeedsASIProtection: ay , classPropMayCauseASIProblems: sy , getLeftSidePathName: ly , hasNakedLeftSide: cy , isJSXNode: py , isLastStatement: dy , isTheOnlyJSXElementInMarkdown: fy  } = Cl, { locEnd: hy  } = ei, { shouldPrintParamsWithoutParens: my  } = Tm;
function gy({ path: e18 , index: t12 , bodyNode: n8 , isClass: r6  }, o5, u4) {
    const i6 = e18.getValue();
    if (!i6) return;
    if ("EmptyStatement" === i6.type) return;
    const a5 = u4(e18), s4 = o5.originalText, l5 = [];
    if (o5.semi || r6 || fy(o5, e18) || !(function(e19, t13) {
        if ("ExpressionStatement" !== e19.getNode().type) return !1;
        return e19.call((e20)=>Dy(e20, t13)
        , "expression");
    })(e18, o5) ? l5.push(a5) : i6.comments && i6.comments.some((e19)=>e19.leading
    ) ? l5.push(u4(e18, {
        needsSemi: !0
    })) : l5.push(";", a5), !o5.semi && r6) {
        if (sy(e18)) l5.push(";");
        else if ("ClassProperty" === i6.type || "FieldDefinition" === i6.type) {
            const e19 = n8.body[t12 + 1];
            ay(e19) && l5.push(";");
        }
    }
    return ry(s4, i6, hy) && !dy(e18) && l5.push(iy), oy(l5);
}
function Dy(e18, t12) {
    const n8 = e18.getValue();
    return !!(Pp(e18, t12) || "ParenthesizedExpression" === n8.type || "TypeCastExpression" === n8.type || "ArrowFunctionExpression" === n8.type && !my(e18, t12) || "ArrayExpression" === n8.type || "ArrayPattern" === n8.type || "UnaryExpression" === n8.type && n8.prefix && ("+" === n8.operator || "-" === n8.operator) || "TemplateLiteral" === n8.type || "TemplateElement" === n8.type || py(n8) || "BindExpression" === n8.type && !n8.object || "RegExpLiteral" === n8.type || "Literal" === n8.type && n8.pattern || "Literal" === n8.type && n8.regex) || !!cy(n8) && e18.call((e19)=>Dy(e19, t12)
    , ...ly(e18, n8));
}
var yy = {
    printStatementSequence: function(e18, t12, n8) {
        const r6 = e18.getNode(), o5 = "ClassBody" === r6.type, u4 = e18.map((u5, i6)=>gy({
                path: e18,
                index: i6,
                bodyNode: r6,
                isClass: o5
            }, t12, n8)
        ).filter(Boolean);
        return uy(iy, u4);
    }
};
const { printDanglingComments: Ey  } = ya, { isNextLineEmpty: Cy  } = Nt1, { builders: { concat: by , hardline: vy , indent: Ay  }  } = rn1, { hasDanglingComments: Fy  } = Cl, { locEnd: xy  } = ei, { printStatementSequence: Sy  } = yy;
var wy = {
    printBlock: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = [], u4 = t12.semi ? ";" : "", i6 = e18.call((e19)=>Sy(e19, t12, n8)
        , "body");
        "StaticBlock" === r6.type && o5.push("static ");
        const a5 = r6.body.some((e19)=>"EmptyStatement" !== e19.type
        ), s4 = r6.directives && r6.directives.length > 0, l5 = e18.getParentNode(), c6 = e18.getParentNode(1);
        return a5 || s4 || Fy(r6) || "ArrowFunctionExpression" !== l5.type && "FunctionExpression" !== l5.type && "FunctionDeclaration" !== l5.type && "ObjectMethod" !== l5.type && "ClassMethod" !== l5.type && "ClassPrivateMethod" !== l5.type && "ForStatement" !== l5.type && "WhileStatement" !== l5.type && "DoWhileStatement" !== l5.type && "DoExpression" !== l5.type && ("CatchClause" !== l5.type || c6.finalizer) && "TSModuleDeclaration" !== l5.type && "TSDeclareFunction" !== l5.type && "StaticBlock" !== r6.type ? (o5.push("{"), s4 && e18.each((e19)=>{
            o5.push(Ay(by([
                vy,
                n8(e19),
                u4
            ]))), Cy(t12.originalText, e19.getValue(), xy) && o5.push(vy);
        }, "directives"), a5 && o5.push(Ay(by([
            vy,
            i6
        ]))), o5.push(Ey(e18, t12)), o5.push(vy, "}"), by(o5)) : by([
            ...o5,
            "{}"
        ]);
    }
};
const { hasNewline: Ty  } = Nt1, { builders: { concat: By , join: Ny , hardline: ky  }  } = rn1, { isLineComment: Py , isBlockComment: Oy  } = Cl, { locStart: Iy , locEnd: Ly  } = ei;
var My = {
    printComment: function(e18, t12) {
        const n8 = e18.getValue();
        if (Py(n8)) return t12.originalText.slice(Iy(n8), Ly(n8)).trimEnd();
        if (Oy(n8)) {
            if (function(e19) {
                const t13 = "*".concat(e19.value, "*").split("\n");
                return t13.length > 1 && t13.every((e20)=>"*" === e20.trim()[0]
                );
            }(n8)) {
                const e19 = function(e20) {
                    const t13 = e20.value.split("\n");
                    return By([
                        "/*",
                        Ny(ky, t13.map((e21, n9)=>0 === n9 ? e21.trimEnd() : " " + (n9 < t13.length - 1 ? e21.trim() : e21.trimStart())
                        )),
                        "*/"
                    ]);
                }(n8);
                return n8.trailing && !Ty(t12.originalText, Iy(n8), {
                    backwards: !0
                }) ? By([
                    ky,
                    e19
                ]) : e19;
            }
            const e19 = Ly(n8), r6 = "*-/" === t12.originalText.slice(e19 - 3, e19);
            return "/*" + n8.value + (r6 ? "*-/" : "*/");
        }
        throw new Error("Not a comment: " + JSON.stringify(n8));
    }
};
const { hasNewline: jy , hasNewlineInRange: _y , getLast: Ry , printString: Vy , printNumber: $y , isNextLineEmpty: qy  } = Nt1, { builders: { concat: Wy , join: Uy , line: Jy , hardline: zy , softline: Gy , literalline: Hy , group: Xy , indent: Yy , align: Ky , conditionalGroup: Qy , ifBreak: Zy  } , utils: { isEmpty: eE  }  } = rn1, { insertPragma: tE  } = Ep, { printHtmlBinding: nE , isVueEventBindingExpression: rE  } = Rp, { getFunctionParameters: oE , getCallArguments: uE , getParentExportDeclaration: iE , getTypeScriptMappedTypeModifier: aE , hasDanglingComments: sE , hasFlowShorthandAnnotationComment: lE , hasLeadingOwnLineComment: cE , hasNewlineBetweenOrAfterDecorators: pE , hasNgSideEffect: dE , hasPrettierIgnore: fE , hasTrailingComment: hE , isExportDeclaration: mE , isFunctionNotation: gE , isGetterOrSetter: DE , isLiteral: yE , isNgForOf: EE , isObjectType: CE , isObjectTypePropertyAFunction: bE , isTheOnlyJSXElementInMarkdown: vE , isTSXFile: AE , isBlockComment: FE , needsHardlineAfterDanglingComment: xE , rawText: SE , shouldPrintComma: wE  } = Cl, { locStart: TE , locEnd: BE  } = ei, { printOptionalToken: NE , printBindExpressionCallee: kE , printTypeScriptModifiers: PE , printDecorators: OE , printFlowDeclaration: IE , adjustClause: LE  } = Xp, { printImportDeclaration: ME , printExportDeclaration: jE , printExportAllDeclaration: _E , printModuleSpecifier: RE  } = hd, { printFunctionParameters: VE  } = Zd, { printTemplateLiteral: $E  } = Dc, { printArray: qE , printArrayItems: WE  } = bf, { printObject: UE  } = Uf, { printTypeAnnotation: JE , shouldHugType: zE  } = of, { printJsxElement: GE , printJsxAttribute: HE , printJsxOpeningElement: XE , printJsxClosingElement: YE , printJsxOpeningClosingFragment: KE , printJsxExpressionContainer: QE , printJsxEmptyExpression: ZE , printJsxSpreadAttribute: eC , printJsxSpreadChild: tC  } = xh, { printClass: nC , printClassMethod: rC  } = Gm, { printTypeParameters: oC  } = Wh, { printPropertyKey: uC  } = em, { printFunctionDeclaration: iC , printArrowFunctionExpression: aC , printMethod: sC , printReturnAndThrowArgument: lC  } = Tm, { printCallExpression: cC  } = dD, { printInterface: pC  } = FD, { printVariableDeclarator: dC , printAssignmentExpression: fC , printAssignment: hC , printAssignmentRight: mC  } = ny, { printBinaryishExpression: gC  } = UD, { printStatementSequence: DC  } = yy, { printMemberExpression: yC  } = wg, { printBlock: EC  } = wy, { printComment: CC  } = My;
function bC(e18, t12, n8) {
    const r6 = SE(e18), o5 = n8 || "DirectiveLiteral" === e18.type;
    return Vy(r6, t12, o5);
}
var AC = {
    preprocess: Vp,
    print: function(e18, t12, n8, r6) {
        const o5 = e18.getValue();
        let u4 = !1;
        const i6 = function(e19, t13, n9, r7) {
            const o6 = e19.getValue(), u5 = t13.semi ? ";" : "";
            if (!o6) return "";
            if ("string" == typeof o6) return o6;
            const i7 = nE(e19, t13, n9);
            if (i7) return i7;
            let a5 = [];
            switch(o6.type){
                case "JsExpressionRoot":
                    return e19.call(n9, "node");
                case "JsonRoot":
                    return Wy([
                        e19.call(n9, "node"),
                        zy
                    ]);
                case "File":
                    return o6.program && o6.program.interpreter && a5.push(e19.call((e20)=>e20.call(n9, "interpreter")
                    , "program")), a5.push(e19.call(n9, "program")), Wy(a5);
                case "Program":
                    {
                        const r8 = !o6.body.every(({ type: e20  })=>"EmptyStatement" === e20
                        ) || o6.comments;
                        if (o6.directives) {
                            const i8 = o6.directives.length;
                            e19.each((e20, o7)=>{
                                a5.push(n9(e20), u5, zy), (o7 < i8 - 1 || r8) && qy(t13.originalText, e20.getValue(), BE) && a5.push(zy);
                            }, "directives");
                        }
                        return a5.push(e19.call((e20)=>DC(e20, t13, n9)
                        , "body")), a5.push(ya.printDanglingComments(e19, t13, !0)), r8 && a5.push(zy), Wy(a5);
                    }
                case "EmptyStatement":
                    return "";
                case "ExpressionStatement":
                    if (o6.directive) return Wy([
                        bC(o6.expression, t13, !0),
                        u5
                    ]);
                    if ("__vue_event_binding" === t13.parser) {
                        const t14 = e19.getParentNode();
                        if ("Program" === t14.type && 1 === t14.body.length && t14.body[0] === o6) return Wy([
                            e19.call(n9, "expression"),
                            rE(o6.expression) ? ";" : ""
                        ]);
                    }
                    return Wy([
                        e19.call(n9, "expression"),
                        vE(t13, e19) ? "" : u5
                    ]);
                case "ParenthesizedExpression":
                    return !o6.expression.comments ? Wy([
                        "(",
                        e19.call(n9, "expression"),
                        ")"
                    ]) : Xy(Wy([
                        "(",
                        Yy(Wy([
                            Gy,
                            e19.call(n9, "expression")
                        ])),
                        Gy,
                        ")"
                    ]));
                case "AssignmentExpression":
                    return fC(e19, t13, n9);
                case "VariableDeclarator":
                    return dC(e19, t13, n9);
                case "BinaryExpression":
                case "LogicalExpression":
                case "NGPipeExpression":
                    return gC(e19, t13, n9);
                case "AssignmentPattern":
                    return Wy([
                        e19.call(n9, "left"),
                        " = ",
                        e19.call(n9, "right")
                    ]);
                case "TSTypeAssertion":
                    {
                        const t14 = !("ArrayExpression" === o6.expression.type || "ObjectExpression" === o6.expression.type), r8 = Xy(Wy([
                            "<",
                            Yy(Wy([
                                Gy,
                                e19.call(n9, "typeAnnotation")
                            ])),
                            Gy,
                            ">"
                        ])), u6 = Wy([
                            Zy("("),
                            Yy(Wy([
                                Gy,
                                e19.call(n9, "expression")
                            ])),
                            Gy,
                            Zy(")")
                        ]);
                        return t14 ? Qy([
                            Wy([
                                r8,
                                e19.call(n9, "expression")
                            ]),
                            Wy([
                                r8,
                                Xy(u6, {
                                    shouldBreak: !0
                                })
                            ]),
                            Wy([
                                r8,
                                e19.call(n9, "expression")
                            ])
                        ]) : Xy(Wy([
                            r8,
                            e19.call(n9, "expression")
                        ]));
                    }
                case "OptionalMemberExpression":
                case "MemberExpression":
                    return yC(e19, t13, n9);
                case "MetaProperty":
                    return Wy([
                        e19.call(n9, "meta"),
                        ".",
                        e19.call(n9, "property")
                    ]);
                case "BindExpression":
                    return o6.object && a5.push(e19.call(n9, "object")), a5.push(Xy(Yy(Wy([
                        Gy,
                        kE(e19, t13, n9)
                    ])))), Wy(a5);
                case "Identifier":
                    return Wy([
                        o6.name,
                        NE(e19),
                        JE(e19, t13, n9)
                    ]);
                case "V8IntrinsicIdentifier":
                    return Wy([
                        "%",
                        o6.name
                    ]);
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                case "ObjectTypeSpreadProperty":
                    return Wy([
                        "...",
                        e19.call(n9, "argument"),
                        JE(e19, t13, n9)
                    ]);
                case "FunctionDeclaration":
                case "FunctionExpression":
                    return a5.push(iC(e19, n9, t13, r7 && r7.expandLastArg && uE(e19.getParentNode()).length > 1)), o6.body || a5.push(u5), Wy(a5);
                case "ArrowFunctionExpression":
                    return aC(e19, t13, n9, r7);
                case "YieldExpression":
                    return a5.push("yield"), o6.delegate && a5.push("*"), o6.argument && a5.push(" ", e19.call(n9, "argument")), Wy(a5);
                case "AwaitExpression":
                    {
                        a5.push("await"), o6.argument && a5.push(" ", e19.call(n9, "argument"));
                        const t14 = e19.getParentNode();
                        return ("CallExpression" === t14.type || "OptionalCallExpression" === t14.type) && t14.callee === o6 || ("MemberExpression" === t14.type || "OptionalMemberExpression" === t14.type) && t14.object === o6 ? Xy(Wy([
                            Yy(Wy([
                                Gy,
                                Wy(a5)
                            ])),
                            Gy
                        ])) : Wy(a5);
                    }
                case "TSExportAssignment":
                    return Wy([
                        "export = ",
                        e19.call(n9, "expression"),
                        u5
                    ]);
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "DeclareExportDeclaration":
                    return jE(e19, t13, n9);
                case "ExportAllDeclaration":
                case "DeclareExportAllDeclaration":
                    return _E(e19, t13, n9);
                case "ImportDeclaration":
                    return ME(e19, t13, n9);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                    return RE(e19, t13, n9);
                case "ImportAttribute":
                    return Wy([
                        e19.call(n9, "key"),
                        ": ",
                        e19.call(n9, "value")
                    ]);
                case "Import":
                    return "import";
                case "TSModuleBlock":
                case "BlockStatement":
                case "StaticBlock":
                    return EC(e19, t13, n9);
                case "ThrowStatement":
                case "ReturnStatement":
                    return Wy([
                        "ReturnStatement" === o6.type ? "return" : "throw",
                        lC(e19, t13, n9)
                    ]);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                    return cC(e19, t13, n9);
                case "ObjectTypeInternalSlot":
                    return Wy([
                        o6.static ? "static " : "",
                        "[[",
                        e19.call(n9, "id"),
                        "]]",
                        NE(e19),
                        o6.method ? "" : ": ",
                        e19.call(n9, "value")
                    ]);
                case "ObjectExpression":
                case "ObjectPattern":
                case "ObjectTypeAnnotation":
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                case "RecordExpression":
                    return UE(e19, t13, n9);
                case "ObjectProperty":
                case "Property":
                    return o6.method || "get" === o6.kind || "set" === o6.kind ? sC(e19, t13, n9) : (o6.shorthand ? a5.push(e19.call(n9, "value")) : a5.push(hC(o6.key, uC(e19, t13, n9), ":", o6.value, e19.call(n9, "value"), t13)), Wy(a5));
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                    return rC(e19, t13, n9);
                case "ObjectMethod":
                    return sC(e19, t13, n9);
                case "Decorator":
                    return Wy([
                        "@",
                        e19.call(n9, "expression"),
                        e19.call(n9, "callee")
                    ]);
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                    return qE(e19, t13, n9);
                case "SequenceExpression":
                    {
                        const t14 = e19.getParentNode(0);
                        if ("ExpressionStatement" === t14.type || "ForStatement" === t14.type) {
                            const t15 = [];
                            return e19.each((e20)=>{
                                0 === e20.getName() ? t15.push(n9(e20)) : t15.push(",", Yy(Wy([
                                    Jy,
                                    n9(e20)
                                ])));
                            }, "expressions"), Xy(Wy(t15));
                        }
                        return Xy(Wy([
                            Uy(Wy([
                                ",",
                                Jy
                            ]), e19.map(n9, "expressions"))
                        ]));
                    }
                case "ThisExpression":
                    return "this";
                case "Super":
                    return "super";
                case "NullLiteral":
                    return "null";
                case "RegExpLiteral":
                    return vC(o6);
                case "NumericLiteral":
                    return $y(o6.extra.raw);
                case "DecimalLiteral":
                    return $y(o6.value) + "m";
                case "BigIntLiteral":
                    return (o6.bigint || o6.extra.raw).toLowerCase();
                case "BooleanLiteral":
                case "StringLiteral":
                case "Literal":
                    return o6.regex ? vC(o6.regex) : o6.bigint ? o6.raw.toLowerCase() : "number" == typeof o6.value ? $y(o6.raw) : "string" != typeof o6.value ? "" + o6.value : bC(o6, t13);
                case "Directive":
                    return e19.call(n9, "value");
                case "DirectiveLiteral":
                    return bC(o6, t13);
                case "UnaryExpression":
                    return a5.push(o6.operator), /[a-z]$/.test(o6.operator) && a5.push(" "), o6.argument.comments && o6.argument.comments.length > 0 ? a5.push(Xy(Wy([
                        "(",
                        Yy(Wy([
                            Gy,
                            e19.call(n9, "argument")
                        ])),
                        Gy,
                        ")"
                    ]))) : a5.push(e19.call(n9, "argument")), Wy(a5);
                case "UpdateExpression":
                    return a5.push(e19.call(n9, "argument"), o6.operator), o6.prefix && a5.reverse(), Wy(a5);
                case "ConditionalExpression":
                    return Bd(e19, t13, n9, {
                        beforeParts: ()=>[
                                e19.call(n9, "test")
                            ]
                        ,
                        afterParts: (e20)=>[
                                e20 ? Gy : ""
                            ]
                        ,
                        shouldCheckJsx: !0,
                        conditionalNodeType: "ConditionalExpression",
                        consequentNodePropertyName: "consequent",
                        alternateNodePropertyName: "alternate",
                        testNodePropertyNames: [
                            "test"
                        ]
                    });
                case "VariableDeclaration":
                    {
                        const t14 = e19.map((e20)=>n9(e20)
                        , "declarations"), r8 = e19.getParentNode(), i8 = "ForStatement" === r8.type || "ForInStatement" === r8.type || "ForOfStatement" === r8.type, s4 = o6.declarations.some((e20)=>e20.init
                        );
                        let l5;
                        return 1 !== t14.length || o6.declarations[0].comments ? t14.length > 0 && (l5 = Yy(t14[0])) : l5 = t14[0], a5 = [
                            o6.declare ? "declare " : "",
                            o6.kind,
                            l5 ? Wy([
                                " ",
                                l5
                            ]) : "",
                            Yy(Wy(t14.slice(1).map((e20)=>Wy([
                                    ",",
                                    s4 && !i8 ? zy : Jy,
                                    e20
                                ])
                            )))
                        ], i8 && r8.body !== o6 || a5.push(u5), Xy(Wy(a5));
                    }
                case "TSTypeAliasDeclaration":
                    {
                        o6.declare && a5.push("declare ");
                        const r8 = mC(o6.id, o6.typeAnnotation, o6.typeAnnotation && e19.call(n9, "typeAnnotation"), t13);
                        return a5.push("type ", e19.call(n9, "id"), e19.call(n9, "typeParameters"), " =", r8, u5), Xy(Wy(a5));
                    }
                case "WithStatement":
                    return Xy(Wy([
                        "with (",
                        e19.call(n9, "object"),
                        ")",
                        LE(o6.body, e19.call(n9, "body"))
                    ]));
                case "IfStatement":
                    {
                        const r8 = LE(o6.consequent, e19.call(n9, "consequent")), u6 = Xy(Wy([
                            "if (",
                            Xy(Wy([
                                Yy(Wy([
                                    Gy,
                                    e19.call(n9, "test")
                                ])),
                                Gy
                            ])),
                            ")",
                            r8
                        ]));
                        if (a5.push(u6), o6.alternate) {
                            const r9 = hE(o6.consequent) && o6.consequent.comments.some((e20)=>e20.trailing && !FE(e20)
                            ) || xE(o6), u7 = "BlockStatement" === o6.consequent.type && !r9;
                            a5.push(u7 ? " " : zy), sE(o6) && a5.push(ya.printDanglingComments(e19, t13, !0), r9 ? zy : " "), a5.push("else", Xy(LE(o6.alternate, e19.call(n9, "alternate"), "IfStatement" === o6.alternate.type)));
                        }
                        return Wy(a5);
                    }
                case "ForStatement":
                    {
                        const r8 = LE(o6.body, e19.call(n9, "body")), u6 = ya.printDanglingComments(e19, t13, !0), i8 = u6 ? Wy([
                            u6,
                            Gy
                        ]) : "";
                        return o6.init || o6.test || o6.update ? Wy([
                            i8,
                            Xy(Wy([
                                "for (",
                                Xy(Wy([
                                    Yy(Wy([
                                        Gy,
                                        e19.call(n9, "init"),
                                        ";",
                                        Jy,
                                        e19.call(n9, "test"),
                                        ";",
                                        Jy,
                                        e19.call(n9, "update")
                                    ])),
                                    Gy
                                ])),
                                ")",
                                r8
                            ]))
                        ]) : Wy([
                            i8,
                            Xy(Wy([
                                "for (;;)",
                                r8
                            ]))
                        ]);
                    }
                case "WhileStatement":
                    return Xy(Wy([
                        "while (",
                        Xy(Wy([
                            Yy(Wy([
                                Gy,
                                e19.call(n9, "test")
                            ])),
                            Gy
                        ])),
                        ")",
                        LE(o6.body, e19.call(n9, "body"))
                    ]));
                case "ForInStatement":
                    return Xy(Wy([
                        "for (",
                        e19.call(n9, "left"),
                        " in ",
                        e19.call(n9, "right"),
                        ")",
                        LE(o6.body, e19.call(n9, "body"))
                    ]));
                case "ForOfStatement":
                    return Xy(Wy([
                        "for",
                        o6.await ? " await" : "",
                        " (",
                        e19.call(n9, "left"),
                        " of ",
                        e19.call(n9, "right"),
                        ")",
                        LE(o6.body, e19.call(n9, "body"))
                    ]));
                case "DoWhileStatement":
                    {
                        const t14 = LE(o6.body, e19.call(n9, "body")), r8 = Xy(Wy([
                            "do",
                            t14
                        ]));
                        return a5 = [
                            r8
                        ], "BlockStatement" === o6.body.type ? a5.push(" ") : a5.push(zy), a5.push("while ("), a5.push(Xy(Wy([
                            Yy(Wy([
                                Gy,
                                e19.call(n9, "test")
                            ])),
                            Gy
                        ])), ")", u5), Wy(a5);
                    }
                case "DoExpression":
                    return Wy([
                        "do ",
                        e19.call(n9, "body")
                    ]);
                case "BreakStatement":
                    return a5.push("break"), o6.label && a5.push(" ", e19.call(n9, "label")), a5.push(u5), Wy(a5);
                case "ContinueStatement":
                    return a5.push("continue"), o6.label && a5.push(" ", e19.call(n9, "label")), a5.push(u5), Wy(a5);
                case "LabeledStatement":
                    return "EmptyStatement" === o6.body.type ? Wy([
                        e19.call(n9, "label"),
                        ":;"
                    ]) : Wy([
                        e19.call(n9, "label"),
                        ": ",
                        e19.call(n9, "body")
                    ]);
                case "TryStatement":
                    return Wy([
                        "try ",
                        e19.call(n9, "block"),
                        o6.handler ? Wy([
                            " ",
                            e19.call(n9, "handler")
                        ]) : "",
                        o6.finalizer ? Wy([
                            " finally ",
                            e19.call(n9, "finalizer")
                        ]) : ""
                    ]);
                case "CatchClause":
                    if (o6.param) {
                        const r8 = o6.param.comments && o6.param.comments.some((e20)=>!FE(e20) || e20.leading && jy(t13.originalText, BE(e20)) || e20.trailing && jy(t13.originalText, TE(e20), {
                                backwards: !0
                            })
                        ), u6 = e19.call(n9, "param");
                        return Wy([
                            "catch ",
                            Wy(r8 ? [
                                "(",
                                Yy(Wy([
                                    Gy,
                                    u6
                                ])),
                                Gy,
                                ") "
                            ] : [
                                "(",
                                u6,
                                ") "
                            ]),
                            e19.call(n9, "body")
                        ]);
                    }
                    return Wy([
                        "catch ",
                        e19.call(n9, "body")
                    ]);
                case "SwitchStatement":
                    return Wy([
                        Xy(Wy([
                            "switch (",
                            Yy(Wy([
                                Gy,
                                e19.call(n9, "discriminant")
                            ])),
                            Gy,
                            ")"
                        ])),
                        " {",
                        o6.cases.length > 0 ? Yy(Wy([
                            zy,
                            Uy(zy, e19.map((e20)=>{
                                const r8 = e20.getValue();
                                return Wy([
                                    e20.call(n9),
                                    o6.cases.indexOf(r8) !== o6.cases.length - 1 && qy(t13.originalText, r8, BE) ? zy : ""
                                ]);
                            }, "cases"))
                        ])) : "",
                        zy,
                        "}"
                    ]);
                case "SwitchCase":
                    {
                        o6.test ? a5.push("case ", e19.call(n9, "test"), ":") : a5.push("default:");
                        const r8 = o6.consequent.filter((e20)=>"EmptyStatement" !== e20.type
                        );
                        if (r8.length > 0) {
                            const o7 = e19.call((e20)=>DC(e20, t13, n9)
                            , "consequent");
                            a5.push(1 === r8.length && "BlockStatement" === r8[0].type ? Wy([
                                " ",
                                o7
                            ]) : Yy(Wy([
                                zy,
                                o7
                            ])));
                        }
                        return Wy(a5);
                    }
                case "DebuggerStatement":
                    return Wy([
                        "debugger",
                        u5
                    ]);
                case "JSXAttribute":
                    return HE(e19, t13, n9);
                case "JSXIdentifier":
                    return "" + o6.name;
                case "JSXNamespacedName":
                    return Uy(":", [
                        e19.call(n9, "namespace"),
                        e19.call(n9, "name")
                    ]);
                case "JSXMemberExpression":
                    return Uy(".", [
                        e19.call(n9, "object"),
                        e19.call(n9, "property")
                    ]);
                case "TSQualifiedName":
                    return Uy(".", [
                        e19.call(n9, "left"),
                        e19.call(n9, "right")
                    ]);
                case "JSXSpreadAttribute":
                    return eC(e19, t13, n9);
                case "JSXSpreadChild":
                    return tC(e19, t13, n9);
                case "JSXExpressionContainer":
                    return QE(e19, t13, n9);
                case "JSXFragment":
                case "JSXElement":
                    return GE(e19, t13, n9);
                case "JSXOpeningElement":
                    return XE(e19, t13, n9);
                case "JSXClosingElement":
                    return YE(e19, t13, n9);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                    return KE(e19, t13);
                case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                case "JSXEmptyExpression":
                    return ZE(e19, t13);
                case "ClassBody":
                    return o6.comments || 0 !== o6.body.length ? Wy([
                        "{",
                        o6.body.length > 0 ? Yy(Wy([
                            zy,
                            e19.call((e20)=>DC(e20, t13, n9)
                            , "body")
                        ])) : ya.printDanglingComments(e19, t13),
                        zy,
                        "}"
                    ]) : "{}";
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                case "ClassPrivateProperty":
                    return o6.decorators && 0 !== o6.decorators.length && a5.push(OE(e19, t13, n9)), o6.accessibility && a5.push(o6.accessibility + " "), o6.declare && a5.push("declare "), o6.static && a5.push("static "), ("TSAbstractClassProperty" === o6.type || o6.abstract) && a5.push("abstract "), o6.readonly && a5.push("readonly "), o6.variance && a5.push(e19.call(n9, "variance")), a5.push(uC(e19, t13, n9), NE(e19), JE(e19, t13, n9)), o6.value && a5.push(" =", mC(o6.key, o6.value, e19.call(n9, "value"), t13)), a5.push(u5), Xy(Wy(a5));
                case "ClassDeclaration":
                case "ClassExpression":
                    return o6.declare && a5.push("declare "), a5.push(nC(e19, t13, n9)), Wy(a5);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                    return a5.push(e19.call(n9, "expression")), o6.typeParameters && a5.push(e19.call(n9, "typeParameters")), Wy(a5);
                case "TemplateElement":
                    return Uy(Hy, o6.value.raw.split(/\r?\n/g));
                case "TSTemplateLiteralType":
                case "TemplateLiteral":
                    return $E(e19, n9, t13);
                case "TaggedTemplateExpression":
                    return Wy([
                        e19.call(n9, "tag"),
                        e19.call(n9, "typeParameters"),
                        e19.call(n9, "quasi")
                    ]);
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                    throw new Error("unprintable type: " + JSON.stringify(o6.type));
                case "TypeAnnotation":
                case "TSTypeAnnotation":
                    return o6.typeAnnotation ? e19.call(n9, "typeAnnotation") : "";
                case "TSNamedTupleMember":
                    return Wy([
                        e19.call(n9, "label"),
                        o6.optional ? "?" : "",
                        ": ",
                        e19.call(n9, "elementType")
                    ]);
                case "TSTupleType":
                case "TupleTypeAnnotation":
                    {
                        const r8 = "TSTupleType" === o6.type ? "elementTypes" : "types", u6 = o6[r8].length > 0 && "TSRestType" === Ry(o6[r8]).type;
                        return Xy(Wy([
                            "[",
                            Yy(Wy([
                                Gy,
                                WE(e19, t13, r8, n9)
                            ])),
                            Zy(wE(t13, "all") && !u6 ? "," : ""),
                            ya.printDanglingComments(e19, t13, !0),
                            Gy,
                            "]"
                        ]));
                    }
                case "ExistsTypeAnnotation":
                    return "*";
                case "EmptyTypeAnnotation":
                    return "empty";
                case "MixedTypeAnnotation":
                    return "mixed";
                case "ArrayTypeAnnotation":
                    return Wy([
                        e19.call(n9, "elementType"),
                        "[]"
                    ]);
                case "BooleanLiteralTypeAnnotation":
                    return "" + o6.value;
                case "DeclareClass":
                    return IE(e19, nC(e19, t13, n9));
                case "TSDeclareFunction":
                    return Wy([
                        o6.declare ? "declare " : "",
                        iC(e19, n9, t13),
                        u5
                    ]);
                case "DeclareFunction":
                    return IE(e19, Wy([
                        "function ",
                        e19.call(n9, "id"),
                        o6.predicate ? " " : "",
                        e19.call(n9, "predicate"),
                        u5
                    ]));
                case "DeclareModule":
                    return IE(e19, Wy([
                        "module ",
                        e19.call(n9, "id"),
                        " ",
                        e19.call(n9, "body")
                    ]));
                case "DeclareModuleExports":
                    return IE(e19, Wy([
                        "module.exports",
                        ": ",
                        e19.call(n9, "typeAnnotation"),
                        u5
                    ]));
                case "DeclareVariable":
                    return IE(e19, Wy([
                        "var ",
                        e19.call(n9, "id"),
                        u5
                    ]));
                case "DeclareOpaqueType":
                case "OpaqueType":
                    return a5.push("opaque type ", e19.call(n9, "id"), e19.call(n9, "typeParameters")), o6.supertype && a5.push(": ", e19.call(n9, "supertype")), o6.impltype && a5.push(" = ", e19.call(n9, "impltype")), a5.push(u5), "DeclareOpaqueType" === o6.type ? IE(e19, Wy(a5)) : Wy(a5);
                case "EnumDeclaration":
                    return Wy([
                        "enum ",
                        e19.call(n9, "id"),
                        " ",
                        e19.call(n9, "body")
                    ]);
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody":
                    if ("EnumSymbolBody" === o6.type || o6.explicitType) {
                        let e20 = null;
                        switch(o6.type){
                            case "EnumBooleanBody":
                                e20 = "boolean";
                                break;
                            case "EnumNumberBody":
                                e20 = "number";
                                break;
                            case "EnumStringBody":
                                e20 = "string";
                                break;
                            case "EnumSymbolBody":
                                e20 = "symbol";
                        }
                        a5.push("of ", e20, " ");
                    }
                    if (0 !== o6.members.length || o6.hasUnknownMembers) {
                        const r8 = o6.members.length ? [
                            zy,
                            WE(e19, t13, "members", n9),
                            o6.hasUnknownMembers || wE(t13) ? "," : ""
                        ] : [];
                        a5.push(Xy(Wy([
                            "{",
                            Yy(Wy([
                                ...r8,
                                ...o6.hasUnknownMembers ? [
                                    zy,
                                    "..."
                                ] : []
                            ])),
                            ya.printDanglingComments(e19, t13, !0),
                            zy,
                            "}"
                        ])));
                    } else a5.push(Xy(Wy([
                        "{",
                        ya.printDanglingComments(e19, t13),
                        Gy,
                        "}"
                    ])));
                    return Wy(a5);
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                    return Wy([
                        e19.call(n9, "id"),
                        " = ",
                        "object" == typeof o6.init ? e19.call(n9, "init") : String(o6.init)
                    ]);
                case "EnumDefaultedMember":
                    return e19.call(n9, "id");
                case "FunctionTypeAnnotation":
                case "TSFunctionType":
                    {
                        const r8 = e19.getParentNode(0), u6 = e19.getParentNode(1), i8 = e19.getParentNode(2);
                        let s4 = "TSFunctionType" === o6.type || !(("ObjectTypeProperty" === r8.type || "ObjectTypeInternalSlot" === r8.type) && !r8.variance && !r8.optional && TE(r8) === TE(o6) || "ObjectTypeCallProperty" === r8.type || i8 && "DeclareFunction" === i8.type), l5 = s4 && ("TypeAnnotation" === r8.type || "TSTypeAnnotation" === r8.type);
                        const c6 = l5 && s4 && ("TypeAnnotation" === r8.type || "TSTypeAnnotation" === r8.type) && "ArrowFunctionExpression" === u6.type;
                        return bE(r8) && (s4 = !0, l5 = !0), c6 && a5.push("("), a5.push(VE(e19, n9, t13, !1, !0)), (o6.returnType || o6.predicate || o6.typeAnnotation) && a5.push(s4 ? " => " : ": ", e19.call(n9, "returnType"), e19.call(n9, "predicate"), e19.call(n9, "typeAnnotation")), c6 && a5.push(")"), Xy(Wy(a5));
                    }
                case "TSRestType":
                    return Wy([
                        "...",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "TSOptionalType":
                    return Wy([
                        e19.call(n9, "typeAnnotation"),
                        "?"
                    ]);
                case "FunctionTypeParam":
                    {
                        const t14 = o6.name ? e19.call(n9, "name") : e19.getParentNode().this === o6 ? "this" : "";
                        return Wy([
                            t14,
                            NE(e19),
                            t14 ? ": " : "",
                            e19.call(n9, "typeAnnotation")
                        ]);
                    }
                case "DeclareInterface":
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                case "TSInterfaceDeclaration":
                    return pC(e19, t13, n9);
                case "ClassImplements":
                case "InterfaceExtends":
                    return Wy([
                        e19.call(n9, "id"),
                        e19.call(n9, "typeParameters")
                    ]);
                case "TSClassImplements":
                    return Wy([
                        e19.call(n9, "expression"),
                        e19.call(n9, "typeParameters")
                    ]);
                case "TSIntersectionType":
                case "IntersectionTypeAnnotation":
                    {
                        const t14 = e19.map(n9, "types"), r8 = [];
                        let u6 = !1;
                        for(let e20 = 0; e20 < t14.length; ++e20)0 === e20 ? r8.push(t14[e20]) : CE(o6.types[e20 - 1]) && CE(o6.types[e20]) ? r8.push(Wy([
                            " & ",
                            u6 ? Yy(t14[e20]) : t14[e20]
                        ])) : CE(o6.types[e20 - 1]) || CE(o6.types[e20]) ? (e20 > 1 && (u6 = !0), r8.push(" & ", e20 > 1 ? Yy(t14[e20]) : t14[e20])) : r8.push(Yy(Wy([
                            " &",
                            Jy,
                            t14[e20]
                        ])));
                        return Xy(Wy(r8));
                    }
                case "TSUnionType":
                case "UnionTypeAnnotation":
                    {
                        const r8 = e19.getParentNode(), u6 = !("TypeParameterInstantiation" === r8.type || "TSTypeParameterInstantiation" === r8.type || "GenericTypeAnnotation" === r8.type || "TSTypeReference" === r8.type || "TSTypeAssertion" === r8.type || "TupleTypeAnnotation" === r8.type || "TSTupleType" === r8.type || "FunctionTypeParam" === r8.type && !r8.name && e19.getParentNode(1).this !== r8 || ("TypeAlias" === r8.type || "VariableDeclarator" === r8.type || "TSTypeAliasDeclaration" === r8.type) && cE(t13.originalText, o6)), i8 = zE(o6), a6 = e19.map((e20)=>{
                            let r9 = e20.call(n9);
                            return i8 || (r9 = Ky(2, r9)), ya.printComments(e20, ()=>r9
                            , t13);
                        }, "types");
                        if (i8) return Uy(" | ", a6);
                        const s4 = u6 && !cE(t13.originalText, o6), l5 = Wy([
                            Zy(Wy([
                                s4 ? Jy : "",
                                "| "
                            ])),
                            Uy(Wy([
                                Jy,
                                "| "
                            ]), a6)
                        ]);
                        return Pp(e19, t13) ? Xy(Wy([
                            Yy(l5),
                            Gy
                        ])) : "TupleTypeAnnotation" === r8.type && r8.types.length > 1 || "TSTupleType" === r8.type && r8.elementTypes.length > 1 ? Xy(Wy([
                            Yy(Wy([
                                Zy(Wy([
                                    "(",
                                    Gy
                                ])),
                                l5
                            ])),
                            Gy,
                            Zy(")")
                        ])) : Xy(u6 ? Yy(l5) : l5);
                    }
                case "NullableTypeAnnotation":
                    return Wy([
                        "?",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "Variance":
                    {
                        const { kind: e20  } = o6;
                        return Xi.ok("plus" === e20 || "minus" === e20), "plus" === e20 ? "+" : "-";
                    }
                case "ObjectTypeCallProperty":
                    return o6.static && a5.push("static "), a5.push(e19.call(n9, "value")), Wy(a5);
                case "ObjectTypeIndexer":
                    return Wy([
                        o6.variance ? e19.call(n9, "variance") : "",
                        "[",
                        e19.call(n9, "id"),
                        o6.id ? ": " : "",
                        e19.call(n9, "key"),
                        "]: ",
                        e19.call(n9, "value")
                    ]);
                case "ObjectTypeProperty":
                    {
                        let r8 = "";
                        return o6.proto ? r8 = "proto " : o6.static && (r8 = "static "), Wy([
                            r8,
                            DE(o6) ? o6.kind + " " : "",
                            o6.variance ? e19.call(n9, "variance") : "",
                            uC(e19, t13, n9),
                            NE(e19),
                            gE(o6) ? "" : ": ",
                            e19.call(n9, "value")
                        ]);
                    }
                case "QualifiedTypeIdentifier":
                    return Wy([
                        e19.call(n9, "qualification"),
                        ".",
                        e19.call(n9, "id")
                    ]);
                case "StringLiteralTypeAnnotation":
                    return bC(o6, t13);
                case "NumberLiteralTypeAnnotation":
                    Xi.strictEqual(typeof o6.value, "number");
                case "BigIntLiteralTypeAnnotation":
                    return null != o6.extra ? $y(o6.extra.raw) : $y(o6.raw);
                case "DeclareTypeAlias":
                case "TypeAlias":
                    {
                        ("DeclareTypeAlias" === o6.type || o6.declare) && a5.push("declare ");
                        const r8 = mC(o6.id, o6.right, e19.call(n9, "right"), t13);
                        return a5.push("type ", e19.call(n9, "id"), e19.call(n9, "typeParameters"), " =", r8, u5), Xy(Wy(a5));
                    }
                case "TypeCastExpression":
                    return Wy([
                        "(",
                        e19.call(n9, "expression"),
                        JE(e19, t13, n9),
                        ")"
                    ]);
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation":
                    {
                        const r8 = oC(e19, t13, n9, "params");
                        if ("flow" === t13.parser) {
                            const e20 = TE(o6), n10 = BE(o6), u6 = t13.originalText.lastIndexOf("/*", e20), i8 = t13.originalText.indexOf("*/", n10);
                            if (-1 !== u6 && -1 !== i8) {
                                const e21 = t13.originalText.slice(u6 + 2, i8).trim();
                                if (e21.startsWith("::") && !e21.includes("/*") && !e21.includes("*/")) return Wy([
                                    "/*:: ",
                                    r8,
                                    " */"
                                ]);
                            }
                        }
                        return r8;
                    }
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                    return oC(e19, t13, n9, "params");
                case "TSTypeParameter":
                case "TypeParameter":
                    {
                        const r8 = e19.getParentNode();
                        if ("TSMappedType" === r8.type) return a5.push("[", e19.call(n9, "name")), o6.constraint && a5.push(" in ", e19.call(n9, "constraint")), r8.nameType && a5.push(" as ", e19.callParent((e20)=>e20.call(n9, "nameType")
                        )), a5.push("]"), Wy(a5);
                        o6.variance && a5.push(e19.call(n9, "variance")), a5.push(e19.call(n9, "name")), o6.bound && (a5.push(": "), a5.push(e19.call(n9, "bound"))), o6.constraint && a5.push(" extends ", e19.call(n9, "constraint")), o6.default && a5.push(" = ", e19.call(n9, "default"));
                        const u6 = e19.getNode(2);
                        return 1 === oE(r8).length && AE(t13) && !o6.constraint && "ArrowFunctionExpression" === u6.type && a5.push(","), Wy(a5);
                    }
                case "TypeofTypeAnnotation":
                    return Wy([
                        "typeof ",
                        e19.call(n9, "argument")
                    ]);
                case "InferredPredicate":
                    return "%checks";
                case "DeclaredPredicate":
                    return Wy([
                        "%checks(",
                        e19.call(n9, "value"),
                        ")"
                    ]);
                case "TSAbstractKeyword":
                    return "abstract";
                case "AnyTypeAnnotation":
                case "TSAnyKeyword":
                    return "any";
                case "TSAsyncKeyword":
                    return "async";
                case "BooleanTypeAnnotation":
                case "TSBooleanKeyword":
                    return "boolean";
                case "BigIntTypeAnnotation":
                case "TSBigIntKeyword":
                    return "bigint";
                case "TSConstKeyword":
                    return "const";
                case "TSDeclareKeyword":
                    return "declare";
                case "TSExportKeyword":
                    return "export";
                case "NullLiteralTypeAnnotation":
                case "TSNullKeyword":
                    return "null";
                case "TSNeverKeyword":
                    return "never";
                case "NumberTypeAnnotation":
                case "TSNumberKeyword":
                    return "number";
                case "TSObjectKeyword":
                    return "object";
                case "TSProtectedKeyword":
                    return "protected";
                case "TSPrivateKeyword":
                    return "private";
                case "TSPublicKeyword":
                    return "public";
                case "TSReadonlyKeyword":
                    return "readonly";
                case "SymbolTypeAnnotation":
                case "TSSymbolKeyword":
                    return "symbol";
                case "TSStaticKeyword":
                    return "static";
                case "StringTypeAnnotation":
                case "TSStringKeyword":
                    return "string";
                case "TSUndefinedKeyword":
                    return "undefined";
                case "TSUnknownKeyword":
                    return "unknown";
                case "VoidTypeAnnotation":
                case "TSVoidKeyword":
                    return "void";
                case "TSAsExpression":
                    return Wy([
                        e19.call(n9, "expression"),
                        " as ",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "TSArrayType":
                    return Wy([
                        e19.call(n9, "elementType"),
                        "[]"
                    ]);
                case "TSPropertySignature":
                    return o6.export && a5.push("export "), o6.accessibility && a5.push(o6.accessibility + " "), o6.static && a5.push("static "), o6.readonly && a5.push("readonly "), a5.push(uC(e19, t13, n9), NE(e19)), o6.typeAnnotation && (a5.push(": "), a5.push(e19.call(n9, "typeAnnotation"))), o6.initializer && a5.push(" = ", e19.call(n9, "initializer")), Wy(a5);
                case "TSParameterProperty":
                    return o6.accessibility && a5.push(o6.accessibility + " "), o6.export && a5.push("export "), o6.static && a5.push("static "), o6.readonly && a5.push("readonly "), a5.push(e19.call(n9, "parameter")), Wy(a5);
                case "GenericTypeAnnotation":
                case "TSTypeReference":
                    return Wy([
                        e19.call(n9, "TSTypeReference" === o6.type ? "typeName" : "id"),
                        oC(e19, t13, n9, "typeParameters")
                    ]);
                case "TSTypeQuery":
                    return Wy([
                        "typeof ",
                        e19.call(n9, "exprName")
                    ]);
                case "TSIndexSignature":
                    {
                        const r8 = e19.getParentNode(), i8 = o6.parameters.length > 1 ? Zy(wE(t13) ? "," : "") : "", a6 = Xy(Wy([
                            Yy(Wy([
                                Gy,
                                Uy(Wy([
                                    ", ",
                                    Gy
                                ]), e19.map(n9, "parameters"))
                            ])),
                            i8,
                            Gy
                        ]));
                        return Wy([
                            o6.export ? "export " : "",
                            o6.accessibility ? Wy([
                                o6.accessibility,
                                " "
                            ]) : "",
                            o6.static ? "static " : "",
                            o6.readonly ? "readonly " : "",
                            o6.declare ? "declare " : "",
                            "[",
                            o6.parameters ? a6 : "",
                            o6.typeAnnotation ? "]: " : "]",
                            o6.typeAnnotation ? e19.call(n9, "typeAnnotation") : "",
                            "ClassBody" === r8.type ? u5 : ""
                        ]);
                    }
                case "TSTypePredicate":
                    return Wy([
                        o6.asserts ? "asserts " : "",
                        e19.call(n9, "parameterName"),
                        o6.typeAnnotation ? Wy([
                            " is ",
                            e19.call(n9, "typeAnnotation")
                        ]) : ""
                    ]);
                case "TSNonNullExpression":
                    return Wy([
                        e19.call(n9, "expression"),
                        "!"
                    ]);
                case "ThisTypeAnnotation":
                case "TSThisType":
                    return "this";
                case "TSImportType":
                    return Wy([
                        o6.isTypeOf ? "typeof " : "",
                        "import(",
                        e19.call(n9, o6.parameter ? "parameter" : "argument"),
                        ")",
                        o6.qualifier ? Wy([
                            ".",
                            e19.call(n9, "qualifier")
                        ]) : "",
                        oC(e19, t13, n9, "typeParameters")
                    ]);
                case "TSLiteralType":
                    return e19.call(n9, "literal");
                case "TSIndexedAccessType":
                    return Wy([
                        e19.call(n9, "objectType"),
                        "[",
                        e19.call(n9, "indexType"),
                        "]"
                    ]);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType":
                    if ("TSCallSignatureDeclaration" !== o6.type && a5.push("new "), a5.push(Xy(VE(e19, n9, t13, !1, !0))), o6.returnType || o6.typeAnnotation) {
                        const t14 = "TSConstructorType" === o6.type;
                        a5.push(t14 ? " => " : ": ", e19.call(n9, "returnType"), e19.call(n9, "typeAnnotation"));
                    }
                    return Wy(a5);
                case "TSTypeOperator":
                    return Wy([
                        o6.operator,
                        " ",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "TSMappedType":
                    {
                        const r8 = _y(t13.originalText, TE(o6), BE(o6));
                        return Xy(Wy([
                            "{",
                            Yy(Wy([
                                t13.bracketSpacing ? Jy : Gy,
                                o6.readonly ? Wy([
                                    aE(o6.readonly, "readonly"),
                                    " "
                                ]) : "",
                                PE(e19, t13, n9),
                                e19.call(n9, "typeParameter"),
                                o6.optional ? aE(o6.optional, "?") : "",
                                o6.typeAnnotation ? ": " : "",
                                e19.call(n9, "typeAnnotation"),
                                Zy(u5, "")
                            ])),
                            ya.printDanglingComments(e19, t13, !0),
                            t13.bracketSpacing ? Jy : Gy,
                            "}"
                        ]), {
                            shouldBreak: r8
                        });
                    }
                case "TSMethodSignature":
                    return a5.push(o6.accessibility ? Wy([
                        o6.accessibility,
                        " "
                    ]) : "", o6.export ? "export " : "", o6.static ? "static " : "", o6.readonly ? "readonly " : "", o6.computed ? "[" : "", e19.call(n9, "key"), o6.computed ? "]" : "", NE(e19), VE(e19, n9, t13, !1, !0)), (o6.returnType || o6.typeAnnotation) && a5.push(": ", e19.call(n9, "returnType"), e19.call(n9, "typeAnnotation")), Xy(Wy(a5));
                case "TSNamespaceExportDeclaration":
                    return a5.push("export as namespace ", e19.call(n9, "id")), t13.semi && a5.push(";"), Xy(Wy(a5));
                case "TSEnumDeclaration":
                    return o6.declare && a5.push("declare "), o6.modifiers && a5.push(PE(e19, t13, n9)), o6.const && a5.push("const "), a5.push("enum ", e19.call(n9, "id"), " "), 0 === o6.members.length ? a5.push(Xy(Wy([
                        "{",
                        ya.printDanglingComments(e19, t13),
                        Gy,
                        "}"
                    ]))) : a5.push(Xy(Wy([
                        "{",
                        Yy(Wy([
                            zy,
                            WE(e19, t13, "members", n9),
                            wE(t13, "es5") ? "," : ""
                        ])),
                        ya.printDanglingComments(e19, t13, !0),
                        zy,
                        "}"
                    ]))), Wy(a5);
                case "TSEnumMember":
                    return a5.push(e19.call(n9, "id")), o6.initializer && a5.push(" = ", e19.call(n9, "initializer")), Wy(a5);
                case "TSImportEqualsDeclaration":
                    return o6.isExport && a5.push("export "), a5.push("import ", e19.call(n9, "id"), " = ", e19.call(n9, "moduleReference")), t13.semi && a5.push(";"), Xy(Wy(a5));
                case "TSExternalModuleReference":
                    return Wy([
                        "require(",
                        e19.call(n9, "expression"),
                        ")"
                    ]);
                case "TSModuleDeclaration":
                    {
                        const r8 = e19.getParentNode(), i8 = yE(o6.id), s4 = "TSModuleDeclaration" === r8.type, l5 = o6.body && "TSModuleDeclaration" === o6.body.type;
                        if (s4) a5.push(".");
                        else {
                            o6.declare && a5.push("declare "), a5.push(PE(e19, t13, n9));
                            const r9 = t13.originalText.slice(TE(o6), TE(o6.id));
                            "Identifier" === o6.id.type && "global" === o6.id.name && !/namespace|module/.test(r9) || a5.push(i8 || /(^|\s)module(\s|$)/.test(r9) ? "module " : "namespace ");
                        }
                        return a5.push(e19.call(n9, "id")), l5 ? a5.push(e19.call(n9, "body")) : o6.body ? a5.push(" ", Xy(e19.call(n9, "body"))) : a5.push(u5), Wy(a5);
                    }
                case "PrivateName":
                    return Wy([
                        "#",
                        e19.call(n9, o6.id ? "id" : "name")
                    ]);
                case "TSPrivateIdentifier":
                    return o6.escapedText;
                case "TSConditionalType":
                    return Bd(e19, t13, n9, {
                        beforeParts: ()=>[
                                e19.call(n9, "checkType"),
                                " ",
                                "extends",
                                " ",
                                e19.call(n9, "extendsType")
                            ]
                        ,
                        afterParts: ()=>[]
                        ,
                        shouldCheckJsx: !1,
                        conditionalNodeType: "TSConditionalType",
                        consequentNodePropertyName: "trueType",
                        alternateNodePropertyName: "falseType",
                        testNodePropertyNames: [
                            "checkType",
                            "extendsType"
                        ]
                    });
                case "TSInferType":
                    return Wy([
                        "infer",
                        " ",
                        e19.call(n9, "typeParameter")
                    ]);
                case "InterpreterDirective":
                    return a5.push("#!", o6.value, zy), qy(t13.originalText, o6, BE) && a5.push(zy), Wy(a5);
                case "NGRoot":
                    return Wy([].concat(e19.call(n9, "node"), o6.node.comments && 0 !== o6.node.comments.length ? Wy([
                        " //",
                        o6.node.comments[0].value.trimEnd()
                    ]) : []));
                case "NGChainedExpression":
                    return Xy(Uy(Wy([
                        ";",
                        Jy
                    ]), e19.map((e20)=>dE(e20) ? n9(e20) : Wy([
                            "(",
                            n9(e20),
                            ")"
                        ])
                    , "expressions")));
                case "NGEmptyExpression":
                    return "";
                case "NGQuotedExpression":
                    return Wy([
                        o6.prefix,
                        ": ",
                        o6.value.trim()
                    ]);
                case "NGMicrosyntax":
                    return Wy(e19.map((e20, t14)=>Wy([
                            0 === t14 ? "" : EE(e20.getValue(), t14, o6) ? " " : Wy([
                                ";",
                                Jy
                            ]),
                            n9(e20)
                        ])
                    , "body"));
                case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(-[$_a-z][\w$])*$/i.test(o6.name) ? o6.name : JSON.stringify(o6.name);
                case "NGMicrosyntaxExpression":
                    return Wy([
                        e19.call(n9, "expression"),
                        null === o6.alias ? "" : Wy([
                            " as ",
                            e19.call(n9, "alias")
                        ])
                    ]);
                case "NGMicrosyntaxKeyedExpression":
                    {
                        const t14 = e19.getName(), r8 = e19.getParentNode(), u6 = EE(o6, t14, r8) || (1 === t14 && ("then" === o6.key.name || "else" === o6.key.name) || 2 === t14 && "else" === o6.key.name && "NGMicrosyntaxKeyedExpression" === r8.body[t14 - 1].type && "then" === r8.body[t14 - 1].key.name) && "NGMicrosyntaxExpression" === r8.body[0].type;
                        return Wy([
                            e19.call(n9, "key"),
                            u6 ? " " : ": ",
                            e19.call(n9, "expression")
                        ]);
                    }
                case "NGMicrosyntaxLet":
                    return Wy([
                        "let ",
                        e19.call(n9, "key"),
                        null === o6.value ? "" : Wy([
                            " = ",
                            e19.call(n9, "value")
                        ])
                    ]);
                case "NGMicrosyntaxAs":
                    return Wy([
                        e19.call(n9, "key"),
                        " as ",
                        e19.call(n9, "alias")
                    ]);
                case "PipelineBareFunction":
                    return e19.call(n9, "callee");
                case "PipelineTopicExpression":
                    return e19.call(n9, "expression");
                case "PipelinePrimaryTopicReference":
                    return a5.push("#"), Wy(a5);
                case "ArgumentPlaceholder":
                    return "?";
                case "TSJSDocAllType":
                    return "*";
                case "TSJSDocUnknownType":
                    return "?";
                case "TSJSDocNullableType":
                    return Wy([
                        "?",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "TSJSDocNonNullableType":
                    return Wy([
                        "!",
                        e19.call(n9, "typeAnnotation")
                    ]);
                case "TSJSDocFunctionType":
                    return Wy([
                        "function(",
                        "): ",
                        e19.call(n9, "typeAnnotation")
                    ]);
                default:
                    throw new Error("unknown type: " + JSON.stringify(o6.type));
            }
        }(e18, t12, n8, r6);
        if (!o5 || eE(i6)) return i6;
        const a5 = iE(e18), s4 = [];
        if ("ClassMethod" === o5.type || "ClassPrivateMethod" === o5.type || "ClassProperty" === o5.type || "FieldDefinition" === o5.type || "TSAbstractClassProperty" === o5.type || "ClassPrivateProperty" === o5.type || "MethodDefinition" === o5.type || "TSAbstractMethodDefinition" === o5.type || "TSDeclareMethod" === o5.type) ;
        else if (o5.decorators && o5.decorators.length > 0 && !(a5 && TE(a5, {
            ignoreDecorators: !0
        }) > TE(o5.decorators[0]))) {
            const r7 = "ClassExpression" === o5.type || "ClassDeclaration" === o5.type || pE(o5, t12) ? zy : Jy;
            e18.each((e19)=>{
                let t13 = e19.getValue();
                t13 = t13.expression ? t13.expression : t13.callee, s4.push(n8(e19), r7);
            }, "decorators"), a5 && s4.unshift(zy);
        } else mE(o5) && o5.declaration && o5.declaration.decorators && o5.declaration.decorators.length > 0 && TE(o5, {
            ignoreDecorators: !0
        }) > TE(o5.declaration.decorators[0]) ? e18.each((e19)=>{
            const t13 = "Decorator" === e19.getValue().type ? "" : "@";
            s4.push(t13, n8(e19), zy);
        }, "declaration", "decorators") : u4 = Pp(e18, t12);
        const l5 = [];
        if ((u4 && l5.unshift("("), l5.push(i6), u4)) {
            const t13 = e18.getValue();
            lE(t13) && (l5.push(" /*"), l5.push(t13.trailingComments[0].value.trimStart()), l5.push("*/"), t13.trailingComments[0].printed = !0), l5.push(")");
        }
        return s4.length > 0 ? Xy(Wy(s4.concat(l5))) : Wy(l5);
    },
    embed: op,
    insertPragma: tE,
    massageAstNode: sp,
    hasPrettierIgnore: fE,
    willPrintOwnComments: Zl.willPrintOwnComments,
    canAttachComment: function(e18) {
        return e18.type && "CommentBlock" !== e18.type && "CommentLine" !== e18.type && "Line" !== e18.type && "Block" !== e18.type && "EmptyStatement" !== e18.type && "TemplateElement" !== e18.type && "Import" !== e18.type;
    },
    printComment: CC,
    isBlockComment: FE,
    handleComments: {
        ownLine: Zl.handleOwnLineComment,
        endOfLine: Zl.handleEndOfLineComment,
        remaining: Zl.handleRemainingComment
    },
    getGapRegex: Zl.getGapRegex,
    getCommentChildNodes: Zl.getCommentChildNodes
};
const { builders: { concat: FC , hardline: xC , indent: SC , join: wC  }  } = rn1;
var NC = {
    preprocess: Vp,
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        switch(r6.type){
            case "JsonRoot":
                return FC([
                    e18.call(n8, "node"),
                    xC
                ]);
            case "ArrayExpression":
                return 0 === r6.elements.length ? "[]" : FC([
                    "[",
                    SC(FC([
                        xC,
                        wC(FC([
                            ",",
                            xC
                        ]), e18.map(n8, "elements"))
                    ])),
                    xC,
                    "]"
                ]);
            case "ObjectExpression":
                return 0 === r6.properties.length ? "{}" : FC([
                    "{",
                    SC(FC([
                        xC,
                        wC(FC([
                            ",",
                            xC
                        ]), e18.map(n8, "properties"))
                    ])),
                    xC,
                    "}"
                ]);
            case "ObjectProperty":
                return FC([
                    e18.call(n8, "key"),
                    ": ",
                    e18.call(n8, "value")
                ]);
            case "UnaryExpression":
                return FC([
                    "+" === r6.operator ? "" : r6.operator,
                    e18.call(n8, "argument")
                ]);
            case "NullLiteral":
                return "null";
            case "BooleanLiteral":
                return r6.value ? "true" : "false";
            case "StringLiteral":
            case "NumericLiteral":
                return JSON.stringify(r6.value);
            case "Identifier":
                return JSON.stringify(r6.name);
            default:
                throw new Error("unknown type: " + JSON.stringify(r6.type));
        }
    },
    massageAstNode: BC
};
var VC = {
    languages: [
        xs1(OC, (e18)=>({
                since: "0.0.0",
                parsers: [
                    "babel",
                    "espree",
                    "meriyah",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript"
                ],
                vscodeLanguageIds: [
                    "javascript",
                    "mongo"
                ],
                extensions: [
                    ...e18.extensions,
                    ".wxs"
                ]
            })
        ),
        xs1(OC, ()=>({
                name: "Flow",
                since: "0.0.0",
                parsers: [
                    "flow",
                    "babel-flow"
                ],
                vscodeLanguageIds: [
                    "javascript"
                ],
                aliases: [],
                filenames: [],
                extensions: [
                    ".js.flow"
                ]
            })
        ),
        xs1(IC, ()=>({
                since: "0.0.0",
                parsers: [
                    "babel",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript",
                    "espree",
                    "meriyah"
                ],
                vscodeLanguageIds: [
                    "javascriptreact"
                ]
            })
        ),
        xs1(LC, ()=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescript"
                ]
            })
        ),
        xs1(MC, ()=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescriptreact"
                ]
            })
        ),
        xs1(jC, ()=>({
                name: "JSON.stringify",
                since: "1.13.0",
                parsers: [
                    "json-stringify"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                extensions: [],
                filenames: [
                    "package.json",
                    "package-lock.json",
                    "composer.json"
                ]
            })
        ),
        xs1(jC, (e18)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                filenames: [
                    ...e18.filenames,
                    ".prettierrc"
                ],
                extensions: e18.extensions.filter((e19)=>".jsonl" !== e19
                )
            })
        ),
        xs1(_C, (e18)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "jsonc"
                ],
                filenames: [
                    ...e18.filenames,
                    ".eslintrc"
                ]
            })
        ),
        xs1(RC, ()=>({
                since: "1.13.0",
                parsers: [
                    "json5"
                ],
                vscodeLanguageIds: [
                    "json5"
                ]
            })
        )
    ],
    options: PC,
    printers: {
        estree: AC,
        "estree-json": NC
    },
    parsers: {
        get babel () {
            return {
            }.parsers.babel;
        },
        get "babel-flow" () {
            return {
            }.parsers["babel-flow"];
        },
        get "babel-ts" () {
            return {
            }.parsers["babel-ts"];
        },
        get json () {
            return {
            }.parsers.json;
        },
        get json5 () {
            return {
            }.parsers.json5;
        },
        get "json-stringify" () {
            return {
            }.parsers["json-stringify"];
        },
        get __js_expression () {
            return {
            }.parsers.__js_expression;
        },
        get __vue_expression () {
            return {
            }.parsers.__vue_expression;
        },
        get __vue_event_binding () {
            return {
            }.parsers.__vue_event_binding;
        },
        get flow () {
            return {
            }.parsers.flow;
        },
        get typescript () {
            return {
            }.parsers.typescript;
        },
        get __ng_action () {
            return {
            }.parsers.__ng_action;
        },
        get __ng_binding () {
            return {
            }.parsers.__ng_binding;
        },
        get __ng_interpolation () {
            return {
            }.parsers.__ng_interpolation;
        },
        get __ng_directive () {
            return {
            }.parsers.__ng_directive;
        },
        get espree () {
            return {
            }.parsers.espree;
        },
        get meriyah () {
            return {
            }.parsers.meriyah;
        }
    }
};
const { isFrontMatterNode: $C  } = Nt1, qC = new Set([
    "raw",
    "raws",
    "sourceIndex",
    "source",
    "before",
    "after",
    "trailingComma"
]);
function WC(e18, t12, n8) {
    if ($C(e18) && "yaml" === e18.lang && delete t12.value, "css-comment" === e18.type && "css-root" === n8.type && 0 !== n8.nodes.length) {
        if ((n8.nodes[0] === e18 || $C(n8.nodes[0]) && n8.nodes[1] === e18) && (delete t12.text, /^\*\s*@(format|prettier)\s*$/.test(e18.text))) return null;
        if ("css-root" === n8.type && se(n8.nodes) === e18) return null;
    }
    if ("value-root" === e18.type && delete t12.text, "media-query" !== e18.type && "media-query-list" !== e18.type && "media-feature-expression" !== e18.type || delete t12.value, "css-rule" === e18.type && delete t12.params, "selector-combinator" === e18.type && (t12.value = t12.value.replace(/\s+/g, " ")), "media-feature" === e18.type && (t12.value = t12.value.replace(/ /g, "")), ("value-word" === e18.type && (e18.isColor && e18.isHex || [
        "initial",
        "inherit",
        "unset",
        "revert"
    ].includes(t12.value.replace().toLowerCase())) || "media-feature" === e18.type || "selector-root-invalid" === e18.type || "selector-pseudo" === e18.type) && (t12.value = t12.value.toLowerCase()), "css-decl" === e18.type && (t12.prop = t12.prop.toLowerCase()), "css-atrule" !== e18.type && "css-import" !== e18.type || (t12.name = t12.name.toLowerCase()), "value-number" === e18.type && (t12.unit = t12.unit.toLowerCase()), "media-feature" !== e18.type && "media-keyword" !== e18.type && "media-type" !== e18.type && "media-unknown" !== e18.type && "media-url" !== e18.type && "media-value" !== e18.type && "selector-attribute" !== e18.type && "selector-string" !== e18.type && "selector-class" !== e18.type && "selector-combinator" !== e18.type && "value-string" !== e18.type || !t12.value || (t12.value = t12.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), "selector-attribute" === e18.type && (t12.attribute = t12.attribute.trim(), t12.namespace && "string" == typeof t12.namespace && (t12.namespace = t12.namespace.trim(), 0 === t12.namespace.length && (t12.namespace = !0)), t12.value && (t12.value = t12.value.trim().replace(/^["']|["']$/g, ""), delete t12.quoted)), "media-value" !== e18.type && "media-type" !== e18.type && "value-number" !== e18.type && "selector-root-invalid" !== e18.type && "selector-class" !== e18.type && "selector-combinator" !== e18.type && "selector-tag" !== e18.type || !t12.value || (t12.value = t12.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e19, t13, n9)=>{
        const r6 = Number(t13);
        return isNaN(r6) ? e19 : r6 + n9.toLowerCase();
    })), "selector-tag" === e18.type) {
        const n9 = e18.value.toLowerCase();
        [
            "from",
            "to"
        ].includes(n9) && (t12.value = n9);
    }
    "css-atrule" === e18.type && "supports" === e18.name.toLowerCase() && delete t12.value, "selector-unknown" === e18.type && delete t12.value;
}
WC.ignoredProperties = qC;
var UC = WC;
const { builders: { hardline: JC , concat: zC , markAsRoot: GC  }  } = rn1, HC = {
    "---": "yaml",
    "+++": "toml"
};
var XC = {
    parse: function(e18) {
        const t12 = Object.keys(HC).map(ae).join("|"), n8 = e18.match(new RegExp("^(".concat(t12, ")([^\\n]*)\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));
        if (null === n8) return {
            frontMatter: null,
            content: e18
        };
        const [r6, o5, u4, i6] = n8;
        let a5 = HC[o5];
        return ("toml" !== a5 && u4 && u4.trim() && (a5 = u4.trim()), {
            frontMatter: {
                type: "front-matter",
                lang: a5,
                value: i6,
                raw: r6.replace(/\n$/, "")
            },
            content: r6.replace(/[^\n]/g, " ") + e18.slice(r6.length)
        });
    },
    print: function(e18, t12) {
        if ("yaml" === e18.lang) {
            const n8 = e18.value.trim(), r6 = n8 ? t12(n8, {
                parser: "yaml"
            }, {
                stripTrailingHardline: !0
            }) : "";
            return GC(zC([
                "---",
                JC,
                r6,
                r6 ? JC : "",
                "---"
            ]));
        }
    }
};
const { builders: { hardline: YC , concat: KC  }  } = rn1, { print: QC  } = XC;
var ZC = function(e18, t12, n8) {
    const r6 = e18.getValue();
    if ("front-matter" === r6.type) {
        const e19 = QC(r6, n8);
        return e19 ? KC([
            e19,
            YC
        ]) : "";
    }
};
const { parse: eb  } = XC;
var tb = {
    hasPragma: function(e18) {
        return Ep.hasPragma(eb(e18).content);
    },
    insertPragma: function(e18) {
        const { frontMatter: t12 , content: n8  } = eb(e18);
        return (t12 ? t12.raw + "\n\n" : "") + Ep.insertPragma(n8);
    }
};
const { getLast: hb , skipEverythingButNewLine: mb  } = Nt1;
function Db(e18, t12) {
    if ("css-comment" === e18.type && e18.inline) return mb(t12, e18.source.startOffset);
    const n8 = e18.nodes && hb(e18.nodes);
    return n8 && e18.source && !e18.source.end && (e18 = n8), e18.source && e18.source.end ? fb(e18.source.end, t12) : null;
}
function yb(e18, t12, n8) {
    e18.source && (e18.source.startOffset = gb(e18, n8) + t12, e18.source.endOffset = Db(e18, n8) + t12);
    for(const r6 in e18){
        const o5 = e18[r6];
        "source" !== r6 && o5 && "object" == typeof o5 && yb(o5, t12, n8);
    }
}
var Cb = {
    locStart: function(e18) {
        return e18.source.startOffset;
    },
    locEnd: function(e18) {
        return e18.source.endOffset;
    },
    calculateLoc: function e18(t12, n8) {
        t12.source && (t12.source.startOffset = gb(t12, n8), t12.source.endOffset = Db(t12, n8));
        for(const r6 in t12){
            const o5 = t12[r6];
            "source" !== r6 && o5 && "object" == typeof o5 && ("value-root" === o5.type || "value-unknown" === o5.type ? yb(o5, Eb(t12), o5.text || o5.value) : e18(o5, n8));
        }
    },
    replaceQuotesInInlineComments: function(e19) {
        let t12, n8 = "initial", r6 = "initial", o5 = !1;
        const u4 = [];
        for(let i6 = 0; i6 < e19.length; i6++){
            const a5 = e19[i6];
            switch(n8){
                case "initial":
                    if ("'" === a5) {
                        n8 = "single-quotes";
                        continue;
                    }
                    if ('"' === a5) {
                        n8 = "double-quotes";
                        continue;
                    }
                    if (("u" === a5 || "U" === a5) && "url(" === e19.slice(i6, i6 + 4).toLowerCase()) {
                        n8 = "url", i6 += 3;
                        continue;
                    }
                    if ("*" === a5 && "/" === e19[i6 - 1]) {
                        n8 = "comment-block";
                        continue;
                    }
                    if ("/" === a5 && "/" === e19[i6 - 1]) {
                        n8 = "comment-inline", t12 = i6 - 1;
                        continue;
                    }
                    continue;
                case "single-quotes":
                    if (("'" === a5 && "\\" !== e19[i6 - 1] && (n8 = r6, r6 = "initial"), "\n" === a5 || "\r" === a5)) return e19;
                    continue;
                case "double-quotes":
                    if (('"' === a5 && "\\" !== e19[i6 - 1] && (n8 = r6, r6 = "initial"), "\n" === a5 || "\r" === a5)) return e19;
                    continue;
                case "url":
                    if ((")" === a5 && (n8 = "initial"), "\n" === a5 || "\r" === a5)) return e19;
                    if ("'" === a5) {
                        n8 = "single-quotes", r6 = "url";
                        continue;
                    }
                    if ('"' === a5) {
                        n8 = "double-quotes", r6 = "url";
                        continue;
                    }
                    continue;
                case "comment-block":
                    "/" === a5 && "*" === e19[i6 - 1] && (n8 = "initial");
                    continue;
                case "comment-inline":
                    '"' !== a5 && "'" !== a5 && "*" !== a5 || (o5 = !0), "\n" !== a5 && "\r" !== a5 || (o5 && u4.push([
                        t12,
                        i6
                    ]), n8 = "initial", o5 = !1);
                    continue;
            }
        }
        for (const [t13, n9] of u4)e19 = e19.slice(0, t13) + e19.slice(t13, n9).replace(/["'*]/g, " ") + e19.slice(n9);
        return e19;
    }
};
const { printNumber: bb , printString: vb , hasNewline: Ab , isFrontMatterNode: Fb , isNextLineEmpty: xb  } = Nt1, { builders: { concat: Sb , join: wb , line: Tb , hardline: Bb , softline: Nb , group: kb , fill: Pb , indent: Ob , dedent: Ib , ifBreak: Lb , breakParent: Mb  } , utils: { removeLines: jb  }  } = rn1, { insertPragma: _b  } = tb, { getAncestorNode: Rb , getPropOfDeclNode: Vb , maybeToLowerCase: $b , insideValueFunctionNode: qb , insideICSSRuleNode: Wb , insideAtRuleNode: Ub , insideURLFunctionInImportAtRuleNode: Jb , isKeyframeAtRuleKeywords: zb , isWideKeywords: Gb , isSCSS: Hb , isLastNode: Xb , isLessParser: Yb , isSCSSControlDirectiveNode: Kb , isDetachedRulesetDeclarationNode: Qb , isRelationalOperatorNode: Zb , isEqualityOperatorNode: ev , isMultiplicationNode: tv , isDivisionNode: nv , isAdditionNode: rv , isSubtractionNode: ov , isMathOperatorNode: uv , isEachKeywordNode: iv , isForKeywordNode: av , isURLFunctionNode: sv , isIfElseKeywordNode: lv , hasComposesNode: cv , hasParensAroundNode: pv , hasEmptyRawBefore: dv , isKeyValuePairNode: fv , isDetachedRulesetCallNode: hv , isTemplatePlaceholderNode: mv , isTemplatePropNode: gv , isPostcssSimpleVarNode: Dv , isSCSSMapItemNode: yv , isInlineValueCommentNode: Ev , isHashNode: Cv , isLeftCurlyBraceNode: bv , isRightCurlyBraceNode: vv , isWordNode: Av , isColonNode: Fv , isMediaAndSupportsKeywords: xv , isColorAdjusterFuncNode: Sv , lastLineHasInlineComment: wv , isAtWordPlaceholderNode: Tv  } = db2, { locStart: Bv , locEnd: Nv  } = Cb;
function Pv(e18, t12, n8) {
    const r6 = e18.getValue(), o5 = [];
    return e18.each((e19, u4)=>{
        const i6 = r6.nodes[u4 - 1];
        if (i6 && "css-comment" === i6.type && "prettier-ignore" === i6.text.trim()) {
            const n9 = e19.getValue();
            o5.push(t12.originalText.slice(Bv(n9), Nv(n9)));
        } else o5.push(e19.call(n8));
        u4 !== r6.nodes.length - 1 && ("css-comment" === r6.nodes[u4 + 1].type && !Ab(t12.originalText, Bv(r6.nodes[u4 + 1]), {
            backwards: !0
        }) && !Fb(r6.nodes[u4]) || "css-atrule" === r6.nodes[u4 + 1].type && "else" === r6.nodes[u4 + 1].name && "css-comment" !== r6.nodes[u4].type ? o5.push(" ") : (o5.push(t12.__isHTMLStyleAttribute ? Tb : Bb), xb(t12.originalText, e19.getValue(), Nv) && !Fb(r6.nodes[u4]) && o5.push(Bb)));
    }, "nodes"), Sb(o5);
}
function Lv(e18, t12) {
    return e18.replace(Ov, (e19)=>vb(e19, t12)
    );
}
function jv(e18) {
    return e18.replace(Iv, (e19, t12, n8, r6, o5)=>!n8 && r6 ? _v(r6) + $b(o5 || "") : e19
    );
}
function _v(e18) {
    return bb(e18).replace(/\.0(?=$|e)/, "");
}
var Rv = {
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if (!r6) return "";
        if ("string" == typeof r6) return r6;
        switch(r6.type){
            case "front-matter":
                return Sb([
                    r6.raw,
                    Bb
                ]);
            case "css-root":
                {
                    const o5 = Pv(e18, t12, n8), u4 = r6.raws.after.trim();
                    return Sb([
                        o5,
                        u4 ? " ".concat(u4) : "",
                        o5.parts.length ? Bb : ""
                    ]);
                }
            case "css-comment":
                {
                    const e19 = r6.inline || r6.raws.inline, n9 = t12.originalText.slice(Bv(r6), Nv(r6));
                    return e19 ? n9.trimEnd() : n9;
                }
            case "css-rule":
                return Sb([
                    e18.call(n8, "selector"),
                    r6.important ? " !important" : "",
                    r6.nodes ? Sb([
                        r6.selector && "selector-unknown" === r6.selector.type && wv(r6.selector.value) ? Tb : " ",
                        "{",
                        r6.nodes.length > 0 ? Ob(Sb([
                            Bb,
                            Pv(e18, t12, n8)
                        ])) : "",
                        Bb,
                        "}",
                        Qb(r6) ? ";" : ""
                    ]) : ";"
                ]);
            case "css-decl":
                {
                    const o5 = e18.getParentNode(), { between: u4  } = r6.raws, i6 = u4.trim(), a5 = ":" === i6;
                    let s4 = cv(r6) ? jb(e18.call(n8, "value")) : e18.call(n8, "value");
                    return (!a5 && wv(i6) && (s4 = Ob(Sb([
                        Bb,
                        Ib(s4)
                    ]))), Sb([
                        r6.raws.before.replace(/[\s;]/g, ""),
                        Wb(e18) ? r6.prop : $b(r6.prop),
                        i6.startsWith("//") ? " " : "",
                        i6,
                        r6.extend ? "" : " ",
                        Yb(t12) && r6.extend && r6.selector ? Sb([
                            "extend(",
                            e18.call(n8, "selector"),
                            ")"
                        ]) : "",
                        s4,
                        r6.raws.important ? r6.raws.important.replace(/\s*!\s*important/i, " !important") : r6.important ? " !important" : "",
                        r6.raws.scssDefault ? r6.raws.scssDefault.replace(/\s*!default/i, " !default") : r6.scssDefault ? " !default" : "",
                        r6.raws.scssGlobal ? r6.raws.scssGlobal.replace(/\s*!global/i, " !global") : r6.scssGlobal ? " !global" : "",
                        r6.nodes ? Sb([
                            " {",
                            Ob(Sb([
                                Nb,
                                Pv(e18, t12, n8)
                            ])),
                            Nb,
                            "}"
                        ]) : gv(r6) && !o5.raws.semicolon && ";" !== t12.originalText[Nv(r6) - 1] ? "" : t12.__isHTMLStyleAttribute && Xb(e18, r6) ? Lb(";", "") : ";"
                    ]));
                }
            case "css-atrule":
                {
                    const o5 = e18.getParentNode(), u4 = mv(r6) && !o5.raws.semicolon && ";" !== t12.originalText[Nv(r6) - 1];
                    if (Yb(t12)) {
                        if (r6.mixin) return Sb([
                            e18.call(n8, "selector"),
                            r6.important ? " !important" : "",
                            u4 ? "" : ";"
                        ]);
                        if (r6.function) return Sb([
                            r6.name,
                            Sb([
                                e18.call(n8, "params")
                            ]),
                            u4 ? "" : ";"
                        ]);
                        if (r6.variable) return Sb([
                            "@",
                            r6.name,
                            ": ",
                            r6.value ? Sb([
                                e18.call(n8, "value")
                            ]) : "",
                            r6.raws.between.trim() ? r6.raws.between.trim() + " " : "",
                            r6.nodes ? Sb([
                                "{",
                                Ob(Sb([
                                    r6.nodes.length > 0 ? Nb : "",
                                    Pv(e18, t12, n8)
                                ])),
                                Nb,
                                "}"
                            ]) : "",
                            u4 ? "" : ";"
                        ]);
                    }
                    return Sb([
                        "@",
                        hv(r6) || r6.name.endsWith(":") ? r6.name : $b(r6.name),
                        r6.params ? Sb([
                            hv(r6) ? "" : mv(r6) ? "" === r6.raws.afterName ? "" : r6.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r6.raws.afterName) ? Sb([
                                Bb,
                                Bb
                            ]) : /^\s*\n/.test(r6.raws.afterName) ? Bb : " " : " ",
                            e18.call(n8, "params")
                        ]) : "",
                        r6.selector ? Ob(Sb([
                            " ",
                            e18.call(n8, "selector")
                        ])) : "",
                        r6.value ? kb(Sb([
                            " ",
                            e18.call(n8, "value"),
                            Kb(r6) ? pv(r6) ? " " : Tb : ""
                        ])) : "else" === r6.name ? " " : "",
                        r6.nodes ? Sb([
                            Kb(r6) ? "" : r6.selector && !r6.selector.nodes && "string" == typeof r6.selector.value && wv(r6.selector.value) || !r6.selector && "string" == typeof r6.params && wv(r6.params) ? Tb : " ",
                            "{",
                            Ob(Sb([
                                r6.nodes.length > 0 ? Nb : "",
                                Pv(e18, t12, n8)
                            ])),
                            Nb,
                            "}"
                        ]) : u4 ? "" : ";"
                    ]);
                }
            case "media-query-list":
                {
                    const t13 = [];
                    return (e18.each((e19)=>{
                        const r7 = e19.getValue();
                        "media-query" === r7.type && "" === r7.value || t13.push(e19.call(n8));
                    }, "nodes"), kb(Ob(wb(Tb, t13))));
                }
            case "media-query":
                return Sb([
                    wb(" ", e18.map(n8, "nodes")),
                    Xb(e18, r6) ? "" : ","
                ]);
            case "media-type":
                return jv(Lv(r6.value, t12));
            case "media-feature-expression":
                return r6.nodes ? Sb([
                    "(",
                    Sb(e18.map(n8, "nodes")),
                    ")"
                ]) : r6.value;
            case "media-feature":
                return $b(Lv(r6.value.replace(/ +/g, " "), t12));
            case "media-colon":
                return Sb([
                    r6.value,
                    " "
                ]);
            case "media-value":
                return jv(Lv(r6.value, t12));
            case "media-keyword":
                return Lv(r6.value, t12);
            case "media-url":
                return Lv(r6.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), t12);
            case "media-unknown":
                return r6.value;
            case "selector-root":
                return kb(Sb([
                    Ub(e18, "custom-selector") ? Sb([
                        Rb(e18, "css-atrule").customSelector,
                        Tb
                    ]) : "",
                    wb(Sb([
                        ",",
                        Ub(e18, [
                            "extend",
                            "custom-selector",
                            "nest"
                        ]) ? Tb : Bb
                    ]), e18.map(n8, "nodes"))
                ]));
            case "selector-selector":
                return kb(Ob(Sb(e18.map(n8, "nodes"))));
            case "selector-comment":
                return r6.value;
            case "selector-string":
                return Lv(r6.value, t12);
            case "selector-tag":
                {
                    const t13 = e18.getParentNode(), n9 = t13 && t13.nodes.indexOf(r6), o5 = n9 && t13.nodes[n9 - 1];
                    return Sb([
                        r6.namespace ? Sb([
                            !0 === r6.namespace ? "" : r6.namespace.trim(),
                            "|"
                        ]) : "",
                        "selector-nesting" === o5.type ? r6.value : jv(zb(e18, r6.value) ? r6.value.toLowerCase() : r6.value)
                    ]);
                }
            case "selector-id":
                return Sb([
                    "#",
                    r6.value
                ]);
            case "selector-class":
                return Sb([
                    ".",
                    jv(Lv(r6.value, t12))
                ]);
            case "selector-attribute":
                return Sb([
                    "[",
                    r6.namespace ? Sb([
                        !0 === r6.namespace ? "" : r6.namespace.trim(),
                        "|"
                    ]) : "",
                    r6.attribute.trim(),
                    r6.operator ? r6.operator : "",
                    r6.value ? Mv(Lv(r6.value.trim(), t12), t12) : "",
                    r6.insensitive ? " i" : "",
                    "]"
                ]);
            case "selector-combinator":
                {
                    if ("+" === r6.value || ">" === r6.value || "~" === r6.value || ">>>" === r6.value) {
                        const t13 = e18.getParentNode(), n9 = "selector-selector" === t13.type && t13.nodes[0] === r6 ? "" : Tb;
                        return Sb([
                            n9,
                            r6.value,
                            Xb(e18, r6) ? "" : " "
                        ]);
                    }
                    const n9 = r6.value.trim().startsWith("(") ? Tb : "", o5 = jv(Lv(r6.value.trim(), t12)) || Tb;
                    return Sb([
                        n9,
                        o5
                    ]);
                }
            case "selector-universal":
                return Sb([
                    r6.namespace ? Sb([
                        !0 === r6.namespace ? "" : r6.namespace.trim(),
                        "|"
                    ]) : "",
                    r6.value
                ]);
            case "selector-pseudo":
                return Sb([
                    $b(r6.value),
                    r6.nodes && r6.nodes.length > 0 ? Sb([
                        "(",
                        wb(", ", e18.map(n8, "nodes")),
                        ")"
                    ]) : ""
                ]);
            case "selector-nesting":
                return r6.value;
            case "selector-unknown":
                {
                    const n9 = Rb(e18, "css-rule");
                    if (n9 && n9.isSCSSNesterProperty) return jv(Lv($b(r6.value), t12));
                    const o5 = e18.getParentNode();
                    if (o5.raws && o5.raws.selector) {
                        const e19 = Bv(o5), n10 = e19 + o5.raws.selector.length;
                        return t12.originalText.slice(e19, n10).trim();
                    }
                    const u4 = e18.getParentNode(1);
                    if ("value-paren_group" === o5.type && u4 && "value-func" === u4.type && "selector" === u4.value) {
                        const e19 = Bv(o5.open) + 1, n10 = Nv(o5.close) - 1, r7 = t12.originalText.slice(e19, n10).trim();
                        return wv(r7) ? Sb([
                            Mb,
                            r7
                        ]) : r7;
                    }
                    return r6.value;
                }
            case "value-value":
            case "value-root":
                return e18.call(n8, "group");
            case "value-comment":
                return t12.originalText.slice(Bv(r6), Nv(r6));
            case "value-comma_group":
                {
                    const t13 = e18.getParentNode(), o5 = e18.getParentNode(1), u4 = Vb(e18), i6 = u4 && "value-value" === t13.type && ("grid" === u4 || u4.startsWith("grid-template")), a5 = Rb(e18, "css-atrule"), s4 = a5 && Kb(a5), l5 = e18.map(n8, "groups"), c6 = [], p6 = qb(e18, "url");
                    let d6 = !1, f5 = !1;
                    for(let n9 = 0; n9 < r6.groups.length; ++n9){
                        c6.push(l5[n9]);
                        const u5 = r6.groups[n9 - 1], h5 = r6.groups[n9], m5 = r6.groups[n9 + 1], g6 = r6.groups[n9 + 2];
                        if (p6) {
                            (m5 && rv(m5) || rv(h5)) && c6.push(" ");
                            continue;
                        }
                        if (!m5) continue;
                        if ("value-word" === h5.type && h5.value.endsWith("-") && Tv(m5)) continue;
                        const D5 = "value-string" === h5.type && h5.value.startsWith("#{"), y6 = d6 && "value-string" === m5.type && m5.value.endsWith("}");
                        if (D5 || y6) {
                            d6 = !d6;
                            continue;
                        }
                        if (d6) continue;
                        if (Fv(h5) || Fv(m5)) continue;
                        if ("value-atword" === h5.type && "" === h5.value) continue;
                        if ("~" === h5.value) continue;
                        if (h5.value && h5.value.includes("\\") && m5 && "value-comment" !== m5.type) continue;
                        if (u5 && u5.value && u5.value.indexOf("\\") === u5.value.length - 1 && "value-operator" === h5.type && "/" === h5.value) continue;
                        if ("\\" === h5.value) continue;
                        if (Dv(h5, m5)) continue;
                        if (Cv(h5) || bv(h5) || vv(m5) || bv(m5) && dv(m5) || vv(h5) && dv(m5)) continue;
                        if ("--" === h5.value && Cv(m5)) continue;
                        const E5 = uv(h5), C4 = uv(m5);
                        if ((E5 && Cv(m5) || C4 && vv(h5)) && dv(m5)) continue;
                        if (qb(e18, "calc") && (rv(h5) || rv(m5) || ov(h5) || ov(m5)) && dv(m5)) continue;
                        const b4 = (rv(h5) || ov(h5)) && 0 === n9 && ("value-number" === m5.type || m5.isHex) && o5 && Sv(o5) && !dv(m5), v5 = g6 && "value-func" === g6.type || g6 && Av(g6) || "value-func" === h5.type || Av(h5), A5 = "value-func" === m5.type || Av(m5) || u5 && "value-func" === u5.type || u5 && Av(u5);
                        if (tv(m5) || tv(h5) || qb(e18, "calc") || b4 || !(nv(m5) && !v5 || nv(h5) && !A5 || rv(m5) && !v5 || rv(h5) && !A5 || ov(m5) || ov(h5)) || !(dv(m5) || E5 && (!u5 || u5 && uv(u5)))) {
                            if (Ev(h5)) {
                                if ("value-paren_group" === t13.type) {
                                    c6.push(Ib(Bb));
                                    continue;
                                }
                                c6.push(Bb);
                            } else s4 && (ev(m5) || Zb(m5) || lv(m5) || iv(h5) || av(h5)) || a5 && "namespace" === a5.name.toLowerCase() ? c6.push(" ") : i6 ? h5.source && m5.source && h5.source.start.line !== m5.source.start.line ? (c6.push(Bb), f5 = !0) : c6.push(" ") : C4 ? c6.push(" ") : m5 && "..." === m5.value || Tv(h5) && Tv(m5) && Nv(h5) === Bv(m5) || c6.push(Tb);
                        }
                    }
                    return (f5 && c6.unshift(Bb), s4 ? kb(Ob(Sb(c6))) : Jb(e18) ? kb(Pb(c6)) : kb(Ob(Pb(c6))));
                }
            case "value-paren_group":
                {
                    const o5 = e18.getParentNode();
                    if (o5 && sv(o5) && (1 === r6.groups.length || r6.groups.length > 0 && "value-comma_group" === r6.groups[0].type && r6.groups[0].groups.length > 0 && "value-word" === r6.groups[0].groups[0].type && r6.groups[0].groups[0].value.startsWith("data:"))) return Sb([
                        r6.open ? e18.call(n8, "open") : "",
                        wb(",", e18.map(n8, "groups")),
                        r6.close ? e18.call(n8, "close") : ""
                    ]);
                    if (!r6.open) {
                        const t13 = e18.map(n8, "groups"), r7 = [];
                        for(let e19 = 0; e19 < t13.length; e19++)0 !== e19 && r7.push(Sb([
                            ",",
                            Tb
                        ])), r7.push(t13[e19]);
                        return kb(Ob(Pb(r7)));
                    }
                    const u4 = yv(e18), i6 = r6.groups[r6.groups.length - 1], a5 = i6 && "value-comment" === i6.type;
                    return kb(Sb([
                        r6.open ? e18.call(n8, "open") : "",
                        Ob(Sb([
                            Nb,
                            wb(Sb([
                                ",",
                                Tb
                            ]), e18.map((e19)=>{
                                const t13 = e19.getValue(), r7 = n8(e19);
                                return fv(t13) && "value-comma_group" === t13.type && t13.groups && t13.groups[2] && "value-paren_group" === t13.groups[2].type ? (r7.contents.contents.parts[1] = kb(r7.contents.contents.parts[1]), kb(Ib(r7))) : r7;
                            }, "groups"))
                        ])),
                        Lb(!a5 && Hb(t12.parser, t12.originalText) && u4 && kv(t12) ? "," : ""),
                        Nb,
                        r6.close ? e18.call(n8, "close") : ""
                    ]), {
                        shouldBreak: u4
                    });
                }
            case "value-func":
                return Sb([
                    r6.value,
                    Ub(e18, "supports") && xv(r6) ? " " : "",
                    e18.call(n8, "group")
                ]);
            case "value-paren":
                return r6.value;
            case "value-number":
                return Sb([
                    _v(r6.value),
                    $b(r6.unit)
                ]);
            case "value-operator":
                return r6.value;
            case "value-word":
                return r6.isColor && r6.isHex || Gb(r6.value) ? r6.value.toLowerCase() : r6.value;
            case "value-colon":
                {
                    const t13 = e18.getParentNode(), n9 = t13 && t13.groups.indexOf(r6), o5 = n9 && t13.groups[n9 - 1];
                    return Sb([
                        r6.value,
                        o5 && "\\" === o5.value[o5.value.length - 1] || qb(e18, "url") ? "" : Tb
                    ]);
                }
            case "value-comma":
                return Sb([
                    r6.value,
                    " "
                ]);
            case "value-string":
                return vb(r6.raws.quote + r6.value + r6.raws.quote, t12);
            case "value-atword":
                return Sb([
                    "@",
                    r6.value
                ]);
            case "value-unicode-range":
            case "value-unknown":
                return r6.value;
            default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(r6.type)));
        }
    },
    embed: ZC,
    insertPragma: _b,
    massageAstNode: UC
}, Vv = {
    singleQuote: kC.singleQuote
}, $v = {
    name: "PostCSS",
    type: "markup",
    tmScope: "source.postcss",
    group: "CSS",
    extensions: [
        ".pcss",
        ".postcss"
    ],
    aceMode: "text",
    languageId: 262764437
}, qv = {
    name: "Less",
    type: "markup",
    color: "#1d365d",
    extensions: [
        ".less"
    ],
    tmScope: "source.css.less",
    aceMode: "less",
    codemirrorMode: "css",
    codemirrorMimeType: "text/css",
    languageId: 198
}, Wv = {
    name: "SCSS",
    type: "markup",
    color: "#c6538c",
    tmScope: "source.css.scss",
    aceMode: "scss",
    codemirrorMode: "css",
    codemirrorMimeType: "text/x-scss",
    extensions: [
        ".scss"
    ],
    languageId: 329
};
var Uv = {
    languages: [
        xs1({
            name: "CSS",
            type: "markup",
            tmScope: "source.css",
            aceMode: "css",
            codemirrorMode: "css",
            codemirrorMimeType: "text/css",
            color: "#563d7c",
            extensions: [
                ".css"
            ],
            languageId: 50
        }, (e18)=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "css"
                ],
                extensions: [
                    ...e18.extensions,
                    ".wxss"
                ]
            })
        ),
        xs1($v, ()=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "postcss"
                ]
            })
        ),
        xs1(qv, ()=>({
                since: "1.4.0",
                parsers: [
                    "less"
                ],
                vscodeLanguageIds: [
                    "less"
                ]
            })
        ),
        xs1(Wv, ()=>({
                since: "1.4.0",
                parsers: [
                    "scss"
                ],
                vscodeLanguageIds: [
                    "scss"
                ]
            })
        )
    ],
    options: Vv,
    printers: {
        postcss: Rv
    },
    parsers: {
        get css () {
            return {
            }.parsers.css;
        },
        get less () {
            return {
            }.parsers.less;
        },
        get scss () {
            return {
            }.parsers.scss;
        }
    }
};
const { builders: { concat: nA , group: rA , hardline: oA , ifBreak: uA , indent: iA , join: aA , line: sA , softline: lA  }  } = rn1, { locStart: cA , locEnd: pA  } = Jv, { getNextNode: dA , getPreviousNode: fA , hasPrettierIgnore: hA , isNextNodeOfSomeType: mA , isNodeOfSomeType: gA , isParentOfSomeType: DA , isPreviousNodeOfSomeType: yA , isVoid: EA , isWhitespaceNode: CA  } = tA;
function bA(e18, t12) {
    const n8 = e18.getValue();
    return nA([
        "<",
        n8.tag,
        vA(e18, t12),
        HA(n8),
        FA(n8)
    ]);
}
function vA(e18, t12) {
    const n8 = e18.getValue();
    return iA(nA([
        n8.attributes.length ? sA : "",
        aA(sA, e18.map(t12, "attributes")),
        n8.modifiers.length ? sA : "",
        aA(sA, e18.map(t12, "modifiers")),
        n8.comments.length ? sA : "",
        aA(sA, e18.map(t12, "comments"))
    ]));
}
function AA(e18, t12, n8) {
    return nA(e18.map((e19, r6)=>0 === r6 ? nA([
            lA,
            n8(e19, t12, n8)
        ]) : n8(e19, t12, n8)
    , "children"));
}
function FA(e18) {
    return EA(e18) ? uA(nA([
        lA,
        "/>"
    ]), nA([
        " />",
        lA
    ])) : uA(nA([
        lA,
        ">"
    ]), ">");
}
function xA(e18) {
    const t12 = !1 === e18.escaped ? "{{{" : "{{", n8 = e18.strip && e18.strip.open ? "~" : "";
    return nA([
        t12,
        n8
    ]);
}
function SA(e18) {
    const t12 = !1 === e18.escaped ? "}}}" : "}}", n8 = e18.strip && e18.strip.close ? "~" : "";
    return nA([
        n8,
        t12
    ]);
}
function wA(e18) {
    const t12 = xA(e18), n8 = e18.openStrip.open ? "~" : "";
    return nA([
        t12,
        n8,
        "#"
    ]);
}
function TA(e18) {
    const t12 = SA(e18), n8 = e18.openStrip.close ? "~" : "";
    return nA([
        n8,
        t12
    ]);
}
function BA(e18) {
    const t12 = xA(e18), n8 = e18.closeStrip.open ? "~" : "";
    return nA([
        t12,
        n8,
        "/"
    ]);
}
function NA(e18) {
    const t12 = SA(e18), n8 = e18.closeStrip.close ? "~" : "";
    return nA([
        n8,
        t12
    ]);
}
function kA(e18) {
    const t12 = xA(e18), n8 = e18.inverseStrip.open ? "~" : "";
    return nA([
        t12,
        n8
    ]);
}
function PA(e18) {
    const t12 = SA(e18), n8 = e18.inverseStrip.close ? "~" : "";
    return nA([
        n8,
        t12
    ]);
}
function OA(e18, t12) {
    const n8 = e18.getValue();
    return rA(nA([
        wA(n8),
        JA(e18, t12),
        HA(n8.program),
        lA,
        TA(n8)
    ]));
}
function IA(e18) {
    return nA([
        oA,
        kA(e18),
        "else",
        PA(e18)
    ]);
}
function LA(e18, t12) {
    const n8 = e18.getParentNode(1);
    return nA([
        kA(n8),
        "else ",
        JA(e18, t12),
        PA(n8)
    ]);
}
function MA(e18, t12) {
    const n8 = e18.getValue();
    return nA([
        jA(n8) ? lA : oA,
        BA(n8),
        e18.call(t12, "path"),
        NA(n8)
    ]);
}
function jA(e18) {
    return gA(e18, [
        "BlockStatement"
    ]) && e18.program.body.every((e19)=>CA(e19)
    );
}
function _A(e18) {
    return gA(e18, [
        "BlockStatement"
    ]) && e18.inverse;
}
function RA(e18, t12) {
    if (jA(e18.getValue())) return "";
    const n8 = e18.call(t12, "program");
    return iA(nA([
        oA,
        n8
    ]));
}
function VA(e18, t12) {
    const n8 = e18.getValue(), r6 = e18.call(t12, "inverse"), o5 = nA([
        oA,
        r6
    ]);
    return (function(e19) {
        return _A(e19) && 1 === e19.inverse.body.length && gA(e19.inverse.body[0], [
            "BlockStatement"
        ]) && "if" === e19.inverse.body[0].path.parts[0];
    })(n8) ? o5 : _A(n8) ? nA([
        IA(n8),
        iA(o5)
    ]) : "";
}
function qA(e18 = 0, t12 = 0) {
    return new Array(Math.min(e18, t12)).fill(oA);
}
function WA(e18, t12) {
    const n8 = {
        quote: '"',
        regex: /"/g
    }, r6 = {
        quote: "'",
        regex: /'/g
    }, o5 = t12.singleQuote ? r6 : n8, u4 = o5 === r6 ? n8 : r6;
    let i6 = !1;
    if (e18.includes(o5.quote) || e18.includes(u4.quote)) {
        i6 = (e18.match(o5.regex) || []).length > (e18.match(u4.regex) || []).length;
    }
    const a5 = i6 ? u4 : o5, s4 = e18.replace(a5.regex, "\\".concat(a5.quote));
    return nA([
        a5.quote,
        s4,
        a5.quote
    ]);
}
function UA(e18, t12) {
    const n8 = zA(e18, t12), r6 = GA(e18, t12);
    return r6 ? iA(nA([
        n8,
        sA,
        rA(r6)
    ])) : n8;
}
function JA(e18, t12) {
    const n8 = zA(e18, t12), r6 = GA(e18, t12);
    return r6 ? iA(rA(nA([
        n8,
        sA,
        r6
    ]))) : n8;
}
function GA(e18, t12) {
    const n8 = e18.getValue(), r6 = [];
    if (n8.params.length) {
        const n9 = e18.map(t12, "params");
        r6.push(...n9);
    }
    if (n8.hash && n8.hash.pairs.length > 0) {
        const n9 = e18.call(t12, "hash");
        r6.push(n9);
    }
    return r6.length ? aA(sA, r6) : "";
}
function HA(e18) {
    return e18 && e18.blockParams.length ? nA([
        " as |",
        e18.blockParams.join(" "),
        "|"
    ]) : "";
}
var XA = {
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if (!r6) return "";
        if (hA(e18)) return t12.originalText.slice(cA(r6), pA(r6));
        switch(r6.type){
            case "Block":
            case "Program":
            case "Template":
                return rA(nA(e18.map(n8, "body")));
            case "ElementNode":
                {
                    const o5 = mA(e18, [
                        "ElementNode"
                    ]) ? oA : "";
                    if (EA(r6)) return nA([
                        rA(bA(e18, n8)),
                        o5
                    ]);
                    const u4 = r6.children.every((e19)=>CA(e19)
                    );
                    return nA([
                        rA(bA(e18, n8)),
                        rA(nA([
                            u4 ? "" : iA(AA(e18, t12, n8)),
                            r6.children.length ? oA : "",
                            nA([
                                "</",
                                r6.tag,
                                ">"
                            ])
                        ])),
                        o5
                    ]);
                }
            case "BlockStatement":
                {
                    const t13 = e18.getParentNode(1), o5 = t13 && t13.inverse && 1 === t13.inverse.body.length && t13.inverse.body[0] === r6 && "if" === t13.inverse.body[0].path.parts[0];
                    return nA(o5 ? [
                        LA(e18, n8),
                        RA(e18, n8),
                        VA(e18, n8)
                    ] : [
                        OA(e18, n8),
                        rA(nA([
                            RA(e18, n8),
                            VA(e18, n8),
                            MA(e18, n8)
                        ]))
                    ]);
                }
            case "ElementModifierStatement":
                return rA(nA([
                    "{{",
                    JA(e18, n8),
                    lA,
                    "}}"
                ]));
            case "MustacheStatement":
                {
                    const t13 = DA(e18, [
                        "AttrNode",
                        "ConcatStatement"
                    ]), o5 = DA(e18, [
                        "ElementNode"
                    ]) && 0 === r6.hash.pairs.length && function(e19) {
                        return 0 === e19.params.length;
                    }(r6), u4 = t13 || o5;
                    return rA(nA([
                        xA(r6),
                        u4 ? iA(lA) : "",
                        JA(e18, n8),
                        lA,
                        SA(r6)
                    ]));
                }
            case "SubExpression":
                return rA(nA([
                    "(",
                    UA(e18, n8),
                    lA,
                    ")"
                ]));
            case "AttrNode":
                {
                    const o5 = "TextNode" === r6.value.type;
                    if (o5 && "" === r6.value.chars && cA(r6.value) === pA(r6.value)) return nA([
                        r6.name
                    ]);
                    const u4 = e18.call(n8, "value"), i6 = o5 ? WA(u4.parts.join(), t12) : u4;
                    return nA([
                        r6.name,
                        "=",
                        i6
                    ]);
                }
            case "ConcatStatement":
                {
                    const r7 = t12.singleQuote ? "'" : '"';
                    return nA([
                        r7,
                        ...e18.map((e19)=>n8(e19)
                        , "parts"),
                        r7
                    ]);
                }
            case "Hash":
                return nA([
                    aA(sA, e18.map(n8, "pairs"))
                ]);
            case "HashPair":
                return nA([
                    r6.key,
                    "=",
                    e18.call(n8, "value")
                ]);
            case "TextNode":
                {
                    const t13 = 2, n9 = !fA(e18), o5 = !dA(e18), u4 = !/\S/.test(r6.chars), i6 = $A(r6.chars);
                    let a5 = function(e19) {
                        return $A(((e19 = "string" == typeof e19 ? e19 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
                    }(r6.chars), s4 = function(e19) {
                        return $A(((e19 = "string" == typeof e19 ? e19 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
                    }(r6.chars);
                    if ((n9 || o5) && u4 && DA(e18, [
                        "Block",
                        "ElementNode",
                        "Template"
                    ])) return "";
                    u4 && i6 ? (a5 = Math.min(i6, 2), s4 = 0) : (mA(e18, [
                        "BlockStatement",
                        "ElementNode"
                    ]) && (s4 = Math.max(s4, 1)), yA(e18, [
                        "BlockStatement",
                        "ElementNode"
                    ]) && (a5 = Math.max(a5, 1)));
                    if (e18.stack.includes("attributes")) {
                        if (!function(e19, t14) {
                            return DA(e19, [
                                "AttrNode"
                            ]) && e19.getParentNode().name.toLowerCase() === t14 || DA(e19, [
                                "ConcatStatement"
                            ]) && e19.getParentNode(1).name.toLowerCase() === t14;
                        }(e18, "class")) return nA([
                            r6.chars
                        ]);
                        let n10 = "", o6 = "";
                        return (DA(e18, [
                            "ConcatStatement"
                        ]) && (yA(e18, [
                            "MustacheStatement"
                        ]) && (n10 = " "), mA(e18, [
                            "MustacheStatement"
                        ]) && (o6 = " ")), nA([
                            ...qA(a5, 2),
                            r6.chars.replace(/^\s+/g, n10).replace(/\s+$/, o6),
                            ...qA(s4, 2)
                        ]));
                    }
                    let l5 = "", c6 = "";
                    0 === s4 && mA(e18, [
                        "MustacheStatement"
                    ]) && (c6 = " "), 0 === a5 && yA(e18, [
                        "MustacheStatement"
                    ]) && (l5 = " "), n9 && (a5 = 0, l5 = ""), o5 && (s4 = 0, c6 = "");
                    let p6 = r6.chars;
                    return (p6.startsWith("{{") && p6.includes("}}") && (p6 = "\\" + p6), nA([
                        ...qA(a5, 2),
                        p6.replace(/^\s+/g, l5).replace(/\s+$/, c6),
                        ...qA(s4, 2)
                    ]));
                }
            case "MustacheCommentStatement":
                {
                    const e19 = r6.value.includes("}}") ? "--" : "";
                    return nA([
                        "{{!",
                        e19,
                        r6.value,
                        e19,
                        "}}"
                    ]);
                }
            case "PathExpression":
                return r6.original;
            case "BooleanLiteral":
                return String(r6.value);
            case "CommentStatement":
                return nA([
                    "\x3c!--",
                    r6.value,
                    "--\x3e"
                ]);
            case "StringLiteral":
                return WA(r6.value, t12);
            case "NumberLiteral":
                return String(r6.value);
            case "UndefinedLiteral":
                return "undefined";
            case "NullLiteral":
                return "null";
            default:
                throw new Error("unknown glimmer type: " + JSON.stringify(r6.type));
        }
    },
    massageAstNode: Gv
};
var YA = {
    languages: [
        xs1({
            name: "Handlebars",
            type: "markup",
            color: "#f7931e",
            aliases: [
                "hbs",
                "htmlbars"
            ],
            extensions: [
                ".handlebars",
                ".hbs"
            ],
            tmScope: "text.html.handlebars",
            aceMode: "handlebars",
            languageId: 155
        }, ()=>({
                since: null,
                parsers: [
                    "glimmer"
                ],
                vscodeLanguageIds: [
                    "handlebars"
                ]
            })
        )
    ],
    printers: {
        glimmer: XA
    },
    parsers: {
        get glimmer () {
            return {
            }.parsers.glimmer;
        }
    }
};
const { builders: { concat: ZA , join: eF , hardline: tF , line: nF , softline: rF , group: oF , indent: uF , ifBreak: iF  }  } = rn1, { isNextLineEmpty: aF  } = Nt1, { insertPragma: sF  } = KA, { locStart: lF , locEnd: cF  } = QA;
function pF(e18, t12, n8) {
    if (0 === n8.directives.length) return "";
    const r6 = eF(nF, e18.map(t12, "directives"));
    return "FragmentDefinition" === n8.kind || "OperationDefinition" === n8.kind ? oF(ZA([
        nF,
        r6
    ])) : ZA([
        " ",
        oF(uF(ZA([
            rF,
            r6
        ])))
    ]);
}
function dF(e18, t12, n8) {
    const r6 = e18.getValue().length;
    return e18.map((e19, o5)=>{
        const u4 = n8(e19);
        return aF(t12.originalText, e19.getValue(), cF) && o5 < r6 - 1 ? ZA([
            u4,
            tF
        ]) : u4;
    });
}
function fF(e18, t12, n8) {
    const r6 = e18.getNode(), o5 = [], { interfaces: u4  } = r6, i6 = e18.map((e19)=>n8(e19)
    , "interfaces");
    for(let e19 = 0; e19 < u4.length; e19++){
        const n9 = u4[e19];
        o5.push(i6[e19]);
        const r7 = u4[e19 + 1];
        if (r7) {
            const e20 = t12.originalText.slice(n9.loc.end, r7.loc.start), u5 = e20.includes("#"), i7 = e20.replace(/#.*/g, "").trim();
            o5.push("," === i7 ? "," : " &"), o5.push(u5 ? nF : " ");
        }
    }
    return o5;
}
var mF = {
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if (!r6) return "";
        if ("string" == typeof r6) return r6;
        switch(r6.kind){
            case "Document":
                {
                    const o5 = [];
                    return (e18.each((e19, u4)=>{
                        o5.push(ZA([
                            e19.call(n8)
                        ])), u4 !== r6.definitions.length - 1 && (o5.push(tF), aF(t12.originalText, e19.getValue(), cF) && o5.push(tF));
                    }, "definitions"), ZA([
                        ZA(o5),
                        tF
                    ]));
                }
            case "OperationDefinition":
                {
                    const o5 = "{" !== t12.originalText[lF(r6)], u4 = !!r6.name;
                    return ZA([
                        o5 ? r6.operation : "",
                        o5 && u4 ? ZA([
                            " ",
                            e18.call(n8, "name")
                        ]) : "",
                        r6.variableDefinitions && r6.variableDefinitions.length ? oF(ZA([
                            "(",
                            uF(ZA([
                                rF,
                                eF(ZA([
                                    iF("", ", "),
                                    rF
                                ]), e18.map(n8, "variableDefinitions"))
                            ])),
                            rF,
                            ")"
                        ])) : "",
                        pF(e18, n8, r6),
                        r6.selectionSet && (o5 || u4) ? " " : "",
                        e18.call(n8, "selectionSet")
                    ]);
                }
            case "FragmentDefinition":
                return ZA([
                    "fragment ",
                    e18.call(n8, "name"),
                    r6.variableDefinitions && r6.variableDefinitions.length ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e18.map(n8, "variableDefinitions"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    " on ",
                    e18.call(n8, "typeCondition"),
                    pF(e18, n8, r6),
                    " ",
                    e18.call(n8, "selectionSet")
                ]);
            case "SelectionSet":
                return ZA([
                    "{",
                    uF(ZA([
                        tF,
                        eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                        , "selections"))
                    ])),
                    tF,
                    "}"
                ]);
            case "Field":
                return oF(ZA([
                    r6.alias ? ZA([
                        e18.call(n8, "alias"),
                        ": "
                    ]) : "",
                    e18.call(n8, "name"),
                    r6.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e18.call((e19)=>dF(e19, t12, n8)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    pF(e18, n8, r6),
                    r6.selectionSet ? " " : "",
                    e18.call(n8, "selectionSet")
                ]));
            case "Name":
                return r6.value;
            case "StringValue":
                return r6.block ? ZA([
                    '"""',
                    tF,
                    eF(tF, r6.value.replace(/"""/g, "\\$&").split("\n")),
                    tF,
                    '"""'
                ]) : ZA([
                    '"',
                    r6.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"),
                    '"'
                ]);
            case "IntValue":
            case "FloatValue":
            case "EnumValue":
                return r6.value;
            case "BooleanValue":
                return r6.value ? "true" : "false";
            case "NullValue":
                return "null";
            case "Variable":
                return ZA([
                    "$",
                    e18.call(n8, "name")
                ]);
            case "ListValue":
                return oF(ZA([
                    "[",
                    uF(ZA([
                        rF,
                        eF(ZA([
                            iF("", ", "),
                            rF
                        ]), e18.map(n8, "values"))
                    ])),
                    rF,
                    "]"
                ]));
            case "ObjectValue":
                return oF(ZA([
                    "{",
                    t12.bracketSpacing && r6.fields.length > 0 ? " " : "",
                    uF(ZA([
                        rF,
                        eF(ZA([
                            iF("", ", "),
                            rF
                        ]), e18.map(n8, "fields"))
                    ])),
                    rF,
                    iF("", t12.bracketSpacing && r6.fields.length > 0 ? " " : ""),
                    "}"
                ]));
            case "ObjectField":
            case "Argument":
                return ZA([
                    e18.call(n8, "name"),
                    ": ",
                    e18.call(n8, "value")
                ]);
            case "Directive":
                return ZA([
                    "@",
                    e18.call(n8, "name"),
                    r6.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e18.call((e19)=>dF(e19, t12, n8)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : ""
                ]);
            case "NamedType":
                return e18.call(n8, "name");
            case "VariableDefinition":
                return ZA([
                    e18.call(n8, "variable"),
                    ": ",
                    e18.call(n8, "type"),
                    r6.defaultValue ? ZA([
                        " = ",
                        e18.call(n8, "defaultValue")
                    ]) : "",
                    pF(e18, n8, r6)
                ]);
            case "ObjectTypeExtension":
            case "ObjectTypeDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "ObjectTypeExtension" === r6.kind ? "extend " : "",
                    "type ",
                    e18.call(n8, "name"),
                    r6.interfaces.length > 0 ? ZA([
                        " implements ",
                        ZA(fF(e18, t12, n8))
                    ]) : "",
                    pF(e18, n8, r6),
                    r6.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "FieldDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    e18.call(n8, "name"),
                    r6.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e18.call((e19)=>dF(e19, t12, n8)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    ": ",
                    e18.call(n8, "type"),
                    pF(e18, n8, r6)
                ]);
            case "DirectiveDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "directive ",
                    "@",
                    e18.call(n8, "name"),
                    r6.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e18.call((e19)=>dF(e19, t12, n8)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    r6.repeatable ? " repeatable" : "",
                    ZA([
                        " on ",
                        eF(" | ", e18.map(n8, "locations"))
                    ])
                ]);
            case "EnumTypeExtension":
            case "EnumTypeDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "EnumTypeExtension" === r6.kind ? "extend " : "",
                    "enum ",
                    e18.call(n8, "name"),
                    pF(e18, n8, r6),
                    r6.values.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                            , "values"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "EnumValueDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    e18.call(n8, "name"),
                    pF(e18, n8, r6)
                ]);
            case "InputValueDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? r6.description.block ? tF : nF : "",
                    e18.call(n8, "name"),
                    ": ",
                    e18.call(n8, "type"),
                    r6.defaultValue ? ZA([
                        " = ",
                        e18.call(n8, "defaultValue")
                    ]) : "",
                    pF(e18, n8, r6)
                ]);
            case "InputObjectTypeExtension":
            case "InputObjectTypeDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "InputObjectTypeExtension" === r6.kind ? "extend " : "",
                    "input ",
                    e18.call(n8, "name"),
                    pF(e18, n8, r6),
                    r6.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "SchemaDefinition":
                return ZA([
                    "schema",
                    pF(e18, n8, r6),
                    " {",
                    r6.operationTypes.length > 0 ? uF(ZA([
                        tF,
                        eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                        , "operationTypes"))
                    ])) : "",
                    tF,
                    "}"
                ]);
            case "OperationTypeDefinition":
                return ZA([
                    e18.call(n8, "operation"),
                    ": ",
                    e18.call(n8, "type")
                ]);
            case "InterfaceTypeExtension":
            case "InterfaceTypeDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "InterfaceTypeExtension" === r6.kind ? "extend " : "",
                    "interface ",
                    e18.call(n8, "name"),
                    r6.interfaces.length > 0 ? ZA([
                        " implements ",
                        ZA(fF(e18, t12, n8))
                    ]) : "",
                    pF(e18, n8, r6),
                    r6.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e18.call((e19)=>dF(e19, t12, n8)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "FragmentSpread":
                return ZA([
                    "...",
                    e18.call(n8, "name"),
                    pF(e18, n8, r6)
                ]);
            case "InlineFragment":
                return ZA([
                    "...",
                    r6.typeCondition ? ZA([
                        " on ",
                        e18.call(n8, "typeCondition")
                    ]) : "",
                    pF(e18, n8, r6),
                    " ",
                    e18.call(n8, "selectionSet")
                ]);
            case "UnionTypeExtension":
            case "UnionTypeDefinition":
                return oF(ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    oF(ZA([
                        "UnionTypeExtension" === r6.kind ? "extend " : "",
                        "union ",
                        e18.call(n8, "name"),
                        pF(e18, n8, r6),
                        r6.types.length > 0 ? ZA([
                            " =",
                            iF("", " "),
                            uF(ZA([
                                iF(ZA([
                                    nF,
                                    "  "
                                ])),
                                eF(ZA([
                                    nF,
                                    "| "
                                ]), e18.map(n8, "types"))
                            ]))
                        ]) : ""
                    ]))
                ]));
            case "ScalarTypeExtension":
            case "ScalarTypeDefinition":
                return ZA([
                    e18.call(n8, "description"),
                    r6.description ? tF : "",
                    "ScalarTypeExtension" === r6.kind ? "extend " : "",
                    "scalar ",
                    e18.call(n8, "name"),
                    pF(e18, n8, r6)
                ]);
            case "NonNullType":
                return ZA([
                    e18.call(n8, "type"),
                    "!"
                ]);
            case "ListType":
                return ZA([
                    "[",
                    e18.call(n8, "type"),
                    "]"
                ]);
            default:
                throw new Error("unknown graphql type: " + JSON.stringify(r6.kind));
        }
    },
    massageAstNode: hF,
    hasPrettierIgnore: function(e18) {
        const t12 = e18.getValue();
        return t12 && Array.isArray(t12.comments) && t12.comments.some((e19)=>"prettier-ignore" === e19.value.trim()
        );
    },
    insertPragma: sF,
    printComment: function(e18) {
        const t12 = e18.getValue();
        if ("Comment" === t12.kind) return "#" + t12.value.trimEnd();
        throw new Error("Not a comment: " + JSON.stringify(t12));
    },
    canAttachComment: function(e18) {
        return e18.kind && "Comment" !== e18.kind;
    }
}, gF = {
    bracketSpacing: kC.bracketSpacing
};
var DF = {
    languages: [
        xs1({
            name: "GraphQL",
            type: "data",
            color: "#e10098",
            extensions: [
                ".graphql",
                ".gql",
                ".graphqls"
            ],
            tmScope: "source.graphql",
            aceMode: "text",
            languageId: 139
        }, ()=>({
                since: "1.5.0",
                parsers: [
                    "graphql"
                ],
                vscodeLanguageIds: [
                    "graphql"
                ]
            })
        )
    ],
    options: gF,
    printers: {
        graphql: mF
    },
    parsers: {
        get graphql () {
            return {
            }.parsers.graphql;
        }
    }
};
const { getLast: EF  } = Nt1, { locStart: CF , locEnd: bF  } = yF, { cjkPattern: vF , kPattern: AF , punctuationPattern: FF  } = {
    cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
    kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
    punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
}, xF = [
    "liquidNode",
    "inlineCode",
    "emphasis",
    "strong",
    "delete",
    "wikiLink",
    "link",
    "linkReference",
    "image",
    "imageReference",
    "footnote",
    "footnoteReference",
    "sentence",
    "whitespace",
    "word",
    "break",
    "inlineMath"
], SF = xF.concat([
    "tableCell",
    "paragraph",
    "heading"
]), wF = new RegExp(AF), TF = new RegExp(FF);
var NF = {
    mapAst: function(e18, t12) {
        return function e18(n8, r6, o5) {
            o5 = o5 || [];
            const u4 = Object.assign({
            }, t12(n8, r6, o5));
            return u4.children && (u4.children = u4.children.map((t13, n9)=>e18(t13, n9, [
                    u4
                ].concat(o5))
            )), u4;
        }(e18, null, null);
    },
    splitText: function(e18, t12) {
        const n8 = "non-cjk", r6 = "cj-letter", o5 = "cjk-punctuation", u4 = [];
        return (("preserve" === t12.proseWrap ? e18 : e18.replace(new RegExp("(".concat(vF, ")\n(").concat(vF, ")"), "g"), "$1$2")).split(/([\t\n ]+)/).forEach((e19, t13, a5)=>{
            t13 % 2 != 1 ? (0 !== t13 && t13 !== a5.length - 1 || "" !== e19) && e19.split(new RegExp("(".concat(vF, ")"))).forEach((e20, t14, u5)=>{
                (0 !== t14 && t14 !== u5.length - 1 || "" !== e20) && (t14 % 2 != 0 ? i6(TF.test(e20) ? {
                    type: "word",
                    value: e20,
                    kind: o5,
                    hasLeadingPunctuation: !0,
                    hasTrailingPunctuation: !0
                } : {
                    type: "word",
                    value: e20,
                    kind: wF.test(e20) ? "k-letter" : r6,
                    hasLeadingPunctuation: !1,
                    hasTrailingPunctuation: !1
                }) : "" !== e20 && i6({
                    type: "word",
                    value: e20,
                    kind: n8,
                    hasLeadingPunctuation: TF.test(e20[0]),
                    hasTrailingPunctuation: TF.test(EF(e20))
                }));
            }) : u4.push({
                type: "whitespace",
                value: /\n/.test(e19) ? "\n" : " "
            });
        }), u4);
        function i6(e19) {
            const t13 = EF(u4);
            var i6, a5;
            t13 && "word" === t13.type && (t13.kind === n8 && e19.kind === r6 && !t13.hasTrailingPunctuation || t13.kind === r6 && e19.kind === n8 && !e19.hasLeadingPunctuation ? u4.push({
                type: "whitespace",
                value: " "
            }) : (i6 = n8, a5 = o5, t13.kind === i6 && e19.kind === a5 || t13.kind === a5 && e19.kind === i6 || [
                t13.value,
                e19.value
            ].some((e20)=>/\u3000/.test(e20)
            ) || u4.push({
                type: "whitespace",
                value: ""
            }))), u4.push(e19);
        }
    },
    punctuationPattern: FF,
    getFencedCodeBlockValue: function(e18, t12) {
        const { value: n8  } = e18;
        return e18.position.end.offset === t12.length && n8.endsWith("\n") && t12.endsWith("\n") ? n8.slice(0, -1) : n8;
    },
    getOrderedListItemInfo: BF,
    hasGitDiffFriendlyOrderedList: function(e18, t12) {
        if (!e18.ordered) return !1;
        if (e18.children.length < 2) return !1;
        const n8 = Number(BF(e18.children[0], t12.originalText).numberText), r6 = Number(BF(e18.children[1], t12.originalText).numberText);
        if (0 === n8 && e18.children.length > 2) {
            const n9 = Number(BF(e18.children[2], t12.originalText).numberText);
            return 1 === r6 && 1 === n9;
        }
        return 1 === r6;
    },
    INLINE_NODE_TYPES: xF,
    INLINE_NODE_WRAPPER_TYPES: SF,
    isAutolink: function(e18) {
        if (!e18 || "link" !== e18.type || 1 !== e18.children.length) return !1;
        const t12 = e18.children[0];
        return t12 && CF(e18) === CF(t12) && bF(e18) === bF(t12);
    }
};
const { inferParserByLanguage: kF , getMaxContinuousCount: PF  } = Nt1, { builders: { hardline: OF , concat: IF , markAsRoot: LF  } , utils: { replaceNewlinesWithLiterallines: MF  }  } = rn1, { print: jF  } = XC, { getFencedCodeBlockValue: _F  } = NF;
var RF = function(e18, t12, n8, r6) {
    const o5 = e18.getValue();
    if ("code" === o5.type && null !== o5.lang) {
        const e19 = kF(o5.lang, r6);
        if (e19) {
            const t13 = r6.__inJsTemplate ? "~" : "`", u4 = t13.repeat(Math.max(3, PF(o5.value, t13) + 1)), i6 = n8(_F(o5, r6.originalText), {
                parser: e19
            }, {
                stripTrailingHardline: !0
            });
            return LF(IF([
                u4,
                o5.lang,
                o5.meta ? " " + o5.meta : "",
                OF,
                MF(i6),
                OF,
                u4
            ]));
        }
    }
    switch(o5.type){
        case "front-matter":
            return jF(o5, n8);
        case "importExport":
            return IF([
                n8(o5.value, {
                    parser: "babel"
                }, {
                    stripTrailingHardline: !0
                }),
                OF
            ]);
        case "jsx":
            return n8("<$>".concat(o5.value, "</$>"), {
                parser: "__js_expression",
                rootMarker: "mdx"
            }, {
                stripTrailingHardline: !0
            });
    }
    return null;
};
const { parse: VF  } = XC, $F = [
    "format",
    "prettier"
];
function qF(e18) {
    const t12 = "@(".concat($F.join("|"), ")"), n8 = new RegExp([
        "\x3c!--\\s*".concat(t12, "\\s*--\x3e"),
        "\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t12, "[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e")
    ].join("|"), "m"), r6 = e18.match(n8);
    return r6 && 0 === r6.index;
}
var WF = {
    startWithPragma: qF,
    hasPragma: (e18)=>qF(VF(e18).content.trimStart())
    ,
    insertPragma: (e18)=>{
        const t12 = VF(e18), n8 = "\x3c!-- @".concat($F[0], " --\x3e");
        return t12.frontMatter ? "".concat(t12.frontMatter.raw, "\n\n").concat(n8, "\n\n").concat(t12.content) : "".concat(n8, "\n\n").concat(t12.content);
    }
};
const { getOrderedListItemInfo: UF , mapAst: JF , splitText: zF  } = NF, GF = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;
function HF(e18, t12, n8) {
    return JF(e18, (e19)=>{
        if (!e19.children) return e19;
        const r6 = e19.children.reduce((e20, r7)=>{
            const o5 = e20[e20.length - 1];
            return o5 && t12(o5, r7) ? e20.splice(-1, 1, n8(o5, r7)) : e20.push(r7), e20;
        }, []);
        return Object.assign({
        }, e19, {
            children: r6
        });
    });
}
var XF = function(e18, t12) {
    return e18 = function(e19) {
        return HF(e19, (e20, t13)=>"importExport" === e20.type && "importExport" === t13.type
        , (e20, t13)=>({
                type: "importExport",
                value: e20.value + "\n\n" + t13.value,
                position: {
                    start: e20.position.start,
                    end: t13.position.end
                }
            })
        );
    }(e18 = function(e19) {
        return JF(e19, (e20)=>"import" !== e20.type && "export" !== e20.type ? e20 : Object.assign({
            }, e20, {
                type: "importExport"
            })
        );
    }(e18 = function(e19, t13) {
        return JF(e19, (e20, n8, [r6])=>{
            if ("text" !== e20.type) return e20;
            let { value: o5  } = e20;
            return "paragraph" === r6.type && (0 === n8 && (o5 = o5.trimStart()), n8 === r6.children.length - 1 && (o5 = o5.trimEnd())), {
                type: "sentence",
                position: e20.position,
                children: zF(o5, t13)
            };
        });
    }(e18 = function(e19, t13) {
        return JF(e19, (e20, t14, n8)=>{
            if ("list" === e20.type && 0 !== e20.children.length) {
                for(let t15 = 0; t15 < n8.length; t15++){
                    const r6 = n8[t15];
                    if ("list" === r6.type && !r6.isAligned) return e20.isAligned = !1, e20;
                }
                e20.isAligned = r6(e20);
            }
            return e20;
        });
        function n8(e20) {
            return 0 === e20.children.length ? -1 : e20.children[0].position.start.column - 1;
        }
        function r6(e20) {
            if (!e20.ordered) return !0;
            const [r7, o5] = e20.children;
            if (UF(r7, t13.originalText).leadingSpaces.length > 1) return !0;
            const u4 = n8(r7);
            if (-1 === u4) return !1;
            if (1 === e20.children.length) return u4 % t13.tabWidth == 0;
            if (u4 !== n8(o5)) return !1;
            if (u4 % t13.tabWidth == 0) return !0;
            return UF(o5, t13.originalText).leadingSpaces.length > 1;
        }
    }(e18 = function(e19, t13) {
        return JF(e19, (e20, n8, r6)=>{
            if ("code" === e20.type) {
                const n9 = /^\n?( {4,}|\t)/.test(t13.originalText.slice(e20.position.start.offset, e20.position.end.offset));
                if (e20.isIndented = n9, n9) for(let e21 = 0; e21 < r6.length; e21++){
                    const t14 = r6[e21];
                    if (t14.hasIndentedCodeblock) break;
                    "list" === t14.type && (t14.hasIndentedCodeblock = !0);
                }
            }
            return e20;
        });
    }(e18 = function(e19) {
        return JF(e19, (e20)=>"inlineCode" !== e20.type ? e20 : Object.assign({
            }, e20, {
                value: e20.value.replace(/\s+/g, " ")
            })
        );
    }(e18 = function(e19) {
        return HF(e19, (e20, t13)=>"text" === e20.type && "text" === t13.type
        , (e20, t13)=>({
                type: "text",
                value: e20.value + t13.value,
                position: {
                    start: e20.position.start,
                    end: t13.position.end
                }
            })
        );
    }(e18 = function(e19, t13) {
        return JF(e19, (e20)=>"text" === e20.type && "*" !== e20.value && "_" !== e20.value && GF.test(e20.value) && e20.position.end.offset - e20.position.start.offset !== e20.value.length ? Object.assign({
            }, e20, {
                value: t13.originalText.slice(e20.position.start.offset, e20.position.end.offset)
            }) : e20
        );
    }(e18, t12))), t12), t12), t12)));
};
const { isFrontMatterNode: YF  } = Nt1, { startWithPragma: KF  } = WF, QF = new Set([
    "position",
    "raw"
]);
function ZF(e18, t12, n8) {
    return "front-matter" !== e18.type && "code" !== e18.type && "yaml" !== e18.type && "import" !== e18.type && "export" !== e18.type && "jsx" !== e18.type || delete t12.value, "list" === e18.type && delete t12.isAligned, "list" !== e18.type && "listItem" !== e18.type || (delete t12.spread, delete t12.loose), "text" === e18.type ? null : ("inlineCode" === e18.type && (t12.value = e18.value.replace(/[\t\n ]+/g, " ")), "wikiLink" === e18.type && (t12.value = e18.value.trim().replace(/[\t\n]+/g, " ")), "definition" !== e18.type && "linkReference" !== e18.type || (t12.label = e18.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), "definition" !== e18.type && "link" !== e18.type && "image" !== e18.type || !e18.title || (t12.title = e18.title.replace(/\\(["')])/g, "$1")), n8 && "root" === n8.type && n8.children.length > 0 && (n8.children[0] === e18 || YF(n8.children[0]) && n8.children[1] === e18) && "html" === e18.type && KF(e18.value) ? null : void 0);
}
ZF.ignoredProperties = QF;
var ex = ZF;
const { getLast: tx , getMinNotPresentContinuousCount: nx , getMaxContinuousCount: rx , getStringWidth: ox  } = Nt1, { builders: { breakParent: ux , concat: ix , join: ax , line: sx , literalline: lx , markAsRoot: cx , hardline: px , softline: dx , ifBreak: fx , fill: hx , align: mx , indent: gx , group: Dx  } , utils: { normalizeDoc: yx  } , printer: { printDocToString: Ex  }  } = rn1, { replaceEndOfLineWith: Cx  } = Nt1, { insertPragma: bx  } = WF, { locStart: vx , locEnd: Ax  } = yF, { getFencedCodeBlockValue: Fx , hasGitDiffFriendlyOrderedList: xx , splitText: Sx , punctuationPattern: wx , INLINE_NODE_TYPES: Tx , INLINE_NODE_WRAPPER_TYPES: Bx , isAutolink: Nx  } = NF, kx = new Set([
    "importExport"
]), Px = [
    "heading",
    "tableCell",
    "link",
    "wikiLink"
], Ox = new Set([
    "listItem",
    "definition",
    "footnoteDefinition"
]);
function Ix(e18, t12, n8, r6) {
    const o5 = e18.getValue(), u4 = null === o5.checked ? "" : o5.checked ? "[x] " : "[ ] ";
    return ix([
        u4,
        Vx(e18, t12, n8, {
            processor: (e19, o6)=>{
                if (0 === o6 && "list" !== e19.getValue().type) return mx(" ".repeat(u4.length), e19.call(n8));
                const i6 = " ".repeat((a5 = t12.tabWidth - r6.length, l5 = 3, a5 < (s4 = 0) ? s4 : a5 > l5 ? l5 : a5));
                var a5, s4, l5;
                return ix([
                    i6,
                    mx(i6, e19.call(n8))
                ]);
            }
        })
    ]);
}
function _x(e18, t12, n8) {
    if ("preserve" === n8.proseWrap && "\n" === t12) return px;
    const r6 = "always" === n8.proseWrap && !jx(e18, Px);
    return "" !== t12 ? r6 ? sx : " " : r6 ? dx : "";
}
function Rx(e18, t12, n8) {
    const r6 = [];
    let o5 = null;
    const { children: u4  } = e18.getValue();
    return u4.forEach((e19, t13)=>{
        switch(qx(e19)){
            case "start":
                null === o5 && (o5 = {
                    index: t13,
                    offset: e19.position.end.offset
                });
                break;
            case "end":
                null !== o5 && (r6.push({
                    start: o5,
                    end: {
                        index: t13,
                        offset: e19.position.start.offset
                    }
                }), o5 = null);
        }
    }), Vx(e18, t12, n8, {
        processor: (e19, o6)=>{
            if (0 !== r6.length) {
                const e20 = r6[0];
                if (o6 === e20.start.index) return ix([
                    u4[e20.start.index].value,
                    t12.originalText.slice(e20.start.offset, e20.end.offset),
                    u4[e20.end.index].value
                ]);
                if (e20.start.index < o6 && o6 < e20.end.index) return !1;
                if (o6 === e20.end.index) return r6.shift(), !1;
            }
            return e19.call(n8);
        }
    });
}
function Vx(e18, t12, n8, r6) {
    const o5 = (r6 = r6 || {
    }).postprocessor || ix, u4 = r6.processor || ((e19)=>e19.call(n8)
    ), i6 = e18.getValue(), a5 = [];
    let s4;
    return e18.each((e19, n9)=>{
        const r7 = e19.getValue(), o6 = u4(e19, n9);
        if (!1 !== o6) {
            const e20 = {
                parts: a5,
                prevNode: s4,
                parentNode: i6,
                options: t12
            };
            (function(e21, t13) {
                const n10 = 0 === t13.parts.length, r8 = Tx.includes(e21.type), o7 = "html" === e21.type && Bx.includes(t13.parentNode.type);
                return n10 || r8 || o7;
            })(r7, e20) || (a5.push(px), s4 && kx.has(s4.type) || ((function(e21, t13) {
                const n10 = (t13.prevNode && t13.prevNode.type) === e21.type && Ox.has(e21.type), r8 = "listItem" === t13.parentNode.type && !t13.parentNode.loose, o7 = t13.prevNode && "listItem" === t13.prevNode.type && t13.prevNode.loose, u5 = "next" === qx(t13.prevNode), i7 = "html" === e21.type && t13.prevNode && "html" === t13.prevNode.type && t13.prevNode.position.end.line + 1 === e21.position.start.line, a6 = "html" === e21.type && "listItem" === t13.parentNode.type && t13.prevNode && "paragraph" === t13.prevNode.type && t13.prevNode.position.end.line + 1 === e21.position.start.line;
                return o7 || !(n10 || r8 || u5 || i7 || a6);
            })(r7, e20) || Wx(r7, e20)) && a5.push(px), Wx(r7, e20) && a5.push(px)), a5.push(o6), s4 = r7;
        }
    }, "children"), o5(a5);
}
var zx = {
    preprocess: XF,
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        if (function(e19) {
            const t13 = jx(e19, [
                "linkReference",
                "imageReference"
            ]);
            return t13 && ("linkReference" !== t13.type || "full" !== t13.referenceType);
        }(e18)) return ix(Sx(t12.originalText.slice(r6.position.start.offset, r6.position.end.offset), t12).map((n9)=>"word" === n9.type ? n9.value : "" === n9.value ? "" : _x(e18, n9.value, t12)
        ));
        switch(r6.type){
            case "front-matter":
                return t12.originalText.slice(r6.position.start.offset, r6.position.end.offset);
            case "root":
                return 0 === r6.children.length ? "" : ix([
                    yx(Rx(e18, t12, n8)),
                    kx.has($x(r6).type) ? "" : px
                ]);
            case "paragraph":
                return Vx(e18, t12, n8, {
                    postprocessor: hx
                });
            case "sentence":
                return Vx(e18, t12, n8);
            case "word":
                {
                    let t13 = r6.value.replace(/\*/g, "\\$&").replace(new RegExp([
                        "(^|".concat(wx, ")(_+)"),
                        "(_+)(".concat(wx, "|$)")
                    ].join("|"), "g"), (e19, t14, n9, r7, o5)=>(n9 ? "".concat(t14).concat(n9) : "".concat(r7).concat(o5)).replace(/_/g, "\\_")
                    );
                    const n9 = (e19, t14, n10)=>"sentence" === e19.type && 0 === n10
                    , o5 = (e19, t14, n10)=>Nx(e19.children[n10 - 1])
                    ;
                    return (t13 !== r6.value && (e18.match(void 0, n9, o5) || e18.match(void 0, n9, (e19, t14, n10)=>"emphasis" === e19.type && 0 === n10
                    , o5)) && (t13 = t13.replace(/^(\\?[*_])+/, (e19)=>e19.replace(/\\/g, "")
                    )), t13);
                }
            case "whitespace":
                {
                    const n9 = e18.getParentNode(), o5 = n9.children.indexOf(r6), u4 = n9.children[o5 + 1], i6 = u4 && /^>|^([*+-]|#{1,6}|\d+[).])$/.test(u4.value) ? "never" : t12.proseWrap;
                    return _x(e18, r6.value, {
                        proseWrap: i6
                    });
                }
            case "emphasis":
                {
                    let o5;
                    if (Nx(r6.children[0])) o5 = t12.originalText[r6.position.start.offset];
                    else {
                        const t13 = e18.getParentNode(), n9 = t13.children.indexOf(r6), u4 = t13.children[n9 - 1], i6 = t13.children[n9 + 1];
                        o5 = u4 && "sentence" === u4.type && u4.children.length > 0 && "word" === tx(u4.children).type && !tx(u4.children).hasTrailingPunctuation || i6 && "sentence" === i6.type && i6.children.length > 0 && "word" === i6.children[0].type && !i6.children[0].hasLeadingPunctuation || jx(e18, "emphasis") ? "*" : "_";
                    }
                    return ix([
                        o5,
                        Vx(e18, t12, n8),
                        o5
                    ]);
                }
            case "strong":
                return ix([
                    "**",
                    Vx(e18, t12, n8),
                    "**"
                ]);
            case "delete":
                return ix([
                    "~~",
                    Vx(e18, t12, n8),
                    "~~"
                ]);
            case "inlineCode":
                {
                    const e19 = nx(r6.value, "`"), t13 = "`".repeat(e19 || 1), n9 = e19 && !/^\s/.test(r6.value) ? " " : "";
                    return ix([
                        t13,
                        n9,
                        r6.value,
                        n9,
                        t13
                    ]);
                }
            case "wikiLink":
                {
                    let e19 = "";
                    return (e19 = "preserve" === t12.proseWrap ? r6.value : r6.value.replace(/[\t\n]+/g, " "), ix([
                        "[[",
                        e19,
                        "]]"
                    ]));
                }
            case "link":
                switch(t12.originalText[r6.position.start.offset]){
                    case "<":
                        {
                            const e19 = "mailto:", n9 = r6.url.startsWith(e19) && t12.originalText.slice(r6.position.start.offset + 1, r6.position.start.offset + 1 + e19.length) !== e19 ? r6.url.slice(e19.length) : r6.url;
                            return ix([
                                "<",
                                n9,
                                ">"
                            ]);
                        }
                    case "[":
                        return ix([
                            "[",
                            Vx(e18, t12, n8),
                            "](",
                            Ux(r6.url, ")"),
                            Jx(r6.title, t12),
                            ")"
                        ]);
                    default:
                        return t12.originalText.slice(r6.position.start.offset, r6.position.end.offset);
                }
            case "image":
                return ix([
                    "![",
                    r6.alt || "",
                    "](",
                    Ux(r6.url, ")"),
                    Jx(r6.title, t12),
                    ")"
                ]);
            case "blockquote":
                return ix([
                    "> ",
                    mx("> ", Vx(e18, t12, n8))
                ]);
            case "heading":
                return ix([
                    "#".repeat(r6.depth) + " ",
                    Vx(e18, t12, n8)
                ]);
            case "code":
                {
                    if (r6.isIndented) {
                        const e19 = " ".repeat(4);
                        return mx(e19, ix([
                            e19,
                            ix(Cx(r6.value, px))
                        ]));
                    }
                    const e19 = t12.__inJsTemplate ? "~" : "`", n9 = e19.repeat(Math.max(3, rx(r6.value, e19) + 1));
                    return ix([
                        n9,
                        r6.lang || "",
                        r6.meta ? " " + r6.meta : "",
                        px,
                        ix(Cx(Fx(r6, t12.originalText), px)),
                        px,
                        n9
                    ]);
                }
            case "html":
                {
                    const t13 = e18.getParentNode(), n9 = "root" === t13.type && tx(t13.children) === r6 ? r6.value.trimEnd() : r6.value, o5 = /^<!--[\S\s]*-->$/.test(n9);
                    return ix(Cx(n9, o5 ? px : cx(lx)));
                }
            case "list":
                {
                    const o5 = Lx(r6, e18.getParentNode()), u4 = xx(r6, t12);
                    return Vx(e18, t12, n8, {
                        processor: (e19, i6)=>{
                            const a5 = function() {
                                const e20 = r6.ordered ? (0 === i6 ? r6.start : u4 ? 1 : r6.start + i6) + (o5 % 2 == 0 ? ". " : ") ") : o5 % 2 == 0 ? "- " : "* ";
                                return r6.isAligned || r6.hasIndentedCodeblock ? (function(e21, t13) {
                                    const n9 = r7();
                                    return e21 + " ".repeat(n9 >= 4 ? 0 : n9);
                                    function r7() {
                                        const n10 = e21.length % t13.tabWidth;
                                        return 0 === n10 ? 0 : t13.tabWidth - n10;
                                    }
                                })(e20, t12) : e20;
                            }(), s4 = e19.getValue();
                            return 2 === s4.children.length && "html" === s4.children[1].type && s4.children[0].position.start.column !== s4.children[1].position.start.column ? ix([
                                a5,
                                Ix(e19, t12, n8, a5)
                            ]) : ix([
                                a5,
                                mx(" ".repeat(a5.length), Ix(e19, t12, n8, a5))
                            ]);
                        }
                    });
                }
            case "thematicBreak":
                {
                    const t13 = Mx(e18, "list");
                    if (-1 === t13) return "---";
                    return Lx(e18.getParentNode(t13), e18.getParentNode(t13 + 1)) % 2 == 0 ? "***" : "---";
                }
            case "linkReference":
                return ix([
                    "[",
                    Vx(e18, t12, n8),
                    "]",
                    "full" === r6.referenceType ? ix([
                        "[",
                        r6.identifier,
                        "]"
                    ]) : "collapsed" === r6.referenceType ? "[]" : ""
                ]);
            case "imageReference":
                switch(r6.referenceType){
                    case "full":
                        return ix([
                            "![",
                            r6.alt || "",
                            "][",
                            r6.identifier,
                            "]"
                        ]);
                    default:
                        return ix([
                            "![",
                            r6.alt,
                            "]",
                            "collapsed" === r6.referenceType ? "[]" : ""
                        ]);
                }
            case "definition":
                {
                    const e19 = "always" === t12.proseWrap ? sx : " ";
                    return Dx(ix([
                        ix([
                            "[",
                            r6.identifier,
                            "]:"
                        ]),
                        gx(ix([
                            e19,
                            Ux(r6.url),
                            null === r6.title ? "" : ix([
                                e19,
                                Jx(r6.title, t12, !1)
                            ])
                        ]))
                    ]));
                }
            case "footnote":
                return ix([
                    "[^",
                    Vx(e18, t12, n8),
                    "]"
                ]);
            case "footnoteReference":
                return ix([
                    "[^",
                    r6.identifier,
                    "]"
                ]);
            case "footnoteDefinition":
                {
                    const o5 = e18.getParentNode().children[e18.getName() + 1], u4 = 1 === r6.children.length && "paragraph" === r6.children[0].type && ("never" === t12.proseWrap || "preserve" === t12.proseWrap && r6.children[0].position.start.line === r6.children[0].position.end.line);
                    return ix([
                        "[^",
                        r6.identifier,
                        "]: ",
                        u4 ? Vx(e18, t12, n8) : Dx(ix([
                            mx(" ".repeat(4), Vx(e18, t12, n8, {
                                processor: (e19, t13)=>0 === t13 ? Dx(ix([
                                        dx,
                                        e19.call(n8)
                                    ])) : e19.call(n8)
                            })),
                            o5 && "footnoteDefinition" === o5.type ? dx : ""
                        ]))
                    ]);
                }
            case "table":
                return function(e19, t13, n9) {
                    const r7 = px.parts[0], o5 = e19.getValue(), u4 = [], i6 = e19.map((e20)=>e20.map((e21, r8)=>{
                            const o6 = Ex(e21.call(n9), t13).formatted, i7 = ox(o6);
                            return u4[r8] = Math.max(u4[r8] || 3, i7), {
                                text: o6,
                                width: i7
                            };
                        }, "children")
                    , "children"), a5 = l5(!1);
                    if ("never" !== t13.proseWrap) return ix([
                        ux,
                        a5
                    ]);
                    const s4 = l5(!0);
                    return ix([
                        ux,
                        Dx(fx(s4, a5))
                    ]);
                    function l5(e20) {
                        const t14 = [
                            p6(i6[0], e20),
                            c6(e20)
                        ];
                        return i6.length > 1 && t14.push(ax(r7, i6.slice(1).map((t15)=>p6(t15, e20)
                        ))), ax(r7, t14);
                    }
                    function c6(e20) {
                        const t14 = u4.map((t15, n10)=>{
                            const r8 = o5.align[n10], u5 = "center" === r8 || "left" === r8 ? ":" : "-", i7 = "center" === r8 || "right" === r8 ? ":" : "-", a6 = e20 ? "-" : "-".repeat(t15 - 2);
                            return "".concat(u5).concat(a6).concat(i7);
                        });
                        return "| ".concat(t14.join(" | "), " |");
                    }
                    function p6(e20, t14) {
                        const n10 = e20.map(({ text: e21 , width: n11  }, r8)=>{
                            if (t14) return e21;
                            const i7 = u4[r8] - n11, a6 = o5.align[r8];
                            let s5 = 0;
                            "right" === a6 ? s5 = i7 : "center" === a6 && (s5 = Math.floor(i7 / 2));
                            const l6 = i7 - s5;
                            return "".concat(" ".repeat(s5)).concat(e21).concat(" ".repeat(l6));
                        });
                        return "| ".concat(n10.join(" | "), " |");
                    }
                }(e18, t12, n8);
            case "tableCell":
                return Vx(e18, t12, n8);
            case "break":
                return /\s/.test(t12.originalText[r6.position.start.offset]) ? ix([
                    "  ",
                    cx(lx)
                ]) : ix([
                    "\\",
                    px
                ]);
            case "liquidNode":
                return ix(Cx(r6.value, px));
            case "importExport":
                return ix([
                    r6.value,
                    px
                ]);
            case "jsx":
                return r6.value;
            case "math":
                return ix([
                    "$$",
                    px,
                    r6.value ? ix([
                        ix(Cx(r6.value, px)),
                        px
                    ]) : "",
                    "$$"
                ]);
            case "inlineMath":
                return t12.originalText.slice(vx(r6), Ax(r6));
            case "tableRow":
            case "listItem":
            default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(r6.type)));
        }
    },
    embed: RF,
    massageAstNode: ex,
    hasPrettierIgnore: function(e18) {
        const t12 = +e18.getName();
        return 0 !== t12 && "next" === qx(e18.getParentNode().children[t12 - 1]);
    },
    insertPragma: bx
}, Gx = {
    proseWrap: kC.proseWrap,
    singleQuote: kC.singleQuote
}, Hx = {
    name: "Markdown",
    type: "prose",
    color: "#083fa1",
    aliases: [
        "pandoc"
    ],
    aceMode: "markdown",
    codemirrorMode: "gfm",
    codemirrorMimeType: "text/x-gfm",
    wrap: !0,
    extensions: [
        ".md",
        ".markdown",
        ".mdown",
        ".mdwn",
        ".mdx",
        ".mkd",
        ".mkdn",
        ".mkdown",
        ".ronn",
        ".workbook"
    ],
    filenames: [
        "contents.lr"
    ],
    tmScope: "source.gfm",
    languageId: 222
};
var Xx = {
    languages: [
        xs1(Hx, (e18)=>({
                since: "1.8.0",
                parsers: [
                    "markdown"
                ],
                vscodeLanguageIds: [
                    "markdown"
                ],
                filenames: e18.filenames.concat([
                    "README"
                ]),
                extensions: e18.extensions.filter((e19)=>".mdx" !== e19
                )
            })
        ),
        xs1(Hx, ()=>({
                name: "MDX",
                since: "1.15.0",
                parsers: [
                    "mdx"
                ],
                vscodeLanguageIds: [
                    "mdx"
                ],
                filenames: [],
                extensions: [
                    ".mdx"
                ]
            })
        )
    ],
    options: Gx,
    printers: {
        mdast: zx
    },
    parsers: {
        get remark () {
            return {
            }.parsers.remark;
        },
        get markdown () {
            return {
            }.parsers.remark;
        },
        get mdx () {
            return {
            }.parsers.mdx;
        }
    }
};
const { isFrontMatterNode: Yx  } = Nt1, Kx = new Set([
    "sourceSpan",
    "startSourceSpan",
    "endSourceSpan",
    "nameSpan",
    "valueSpan"
]);
function Qx(e18, t12) {
    return "text" === e18.type || "comment" === e18.type || Yx(e18) || "yaml" === e18.type || "toml" === e18.type ? null : ("attribute" === e18.type && delete t12.value, void ("docType" === e18.type && delete t12.value));
}
Qx.ignoredProperties = Kx;
var Zx = Qx, eS = {
    "*": [
        "accesskey",
        "autocapitalize",
        "autofocus",
        "class",
        "contenteditable",
        "dir",
        "draggable",
        "enterkeyhint",
        "hidden",
        "id",
        "inputmode",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemscope",
        "itemtype",
        "lang",
        "nonce",
        "slot",
        "spellcheck",
        "style",
        "tabindex",
        "title",
        "translate"
    ],
    a: [
        "accesskey",
        "charset",
        "coords",
        "download",
        "href",
        "hreflang",
        "name",
        "ping",
        "referrerpolicy",
        "rel",
        "rev",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    abbr: [
        "title"
    ],
    applet: [
        "align",
        "alt",
        "archive",
        "code",
        "codebase",
        "height",
        "hspace",
        "name",
        "object",
        "vspace",
        "width"
    ],
    area: [
        "accesskey",
        "alt",
        "coords",
        "download",
        "href",
        "hreflang",
        "nohref",
        "ping",
        "referrerpolicy",
        "rel",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
    ],
    base: [
        "href",
        "target"
    ],
    basefont: [
        "color",
        "face",
        "size"
    ],
    bdo: [
        "dir"
    ],
    blockquote: [
        "cite"
    ],
    body: [
        "alink",
        "background",
        "bgcolor",
        "link",
        "text",
        "vlink"
    ],
    br: [
        "clear"
    ],
    button: [
        "accesskey",
        "autofocus",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "name",
        "tabindex",
        "type",
        "value"
    ],
    canvas: [
        "height",
        "width"
    ],
    caption: [
        "align"
    ],
    col: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    colgroup: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    data: [
        "value"
    ],
    del: [
        "cite",
        "datetime"
    ],
    details: [
        "open"
    ],
    dfn: [
        "title"
    ],
    dialog: [
        "open"
    ],
    dir: [
        "compact"
    ],
    div: [
        "align"
    ],
    dl: [
        "compact"
    ],
    embed: [
        "height",
        "src",
        "type",
        "width"
    ],
    fieldset: [
        "disabled",
        "form",
        "name"
    ],
    font: [
        "color",
        "face",
        "size"
    ],
    form: [
        "accept",
        "accept-charset",
        "action",
        "autocomplete",
        "enctype",
        "method",
        "name",
        "novalidate",
        "target"
    ],
    frame: [
        "frameborder",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "noresize",
        "scrolling",
        "src"
    ],
    frameset: [
        "cols",
        "rows"
    ],
    h1: [
        "align"
    ],
    h2: [
        "align"
    ],
    h3: [
        "align"
    ],
    h4: [
        "align"
    ],
    h5: [
        "align"
    ],
    h6: [
        "align"
    ],
    head: [
        "profile"
    ],
    hr: [
        "align",
        "noshade",
        "size",
        "width"
    ],
    html: [
        "manifest",
        "version"
    ],
    iframe: [
        "align",
        "allow",
        "allowfullscreen",
        "allowpaymentrequest",
        "allowusermedia",
        "frameborder",
        "height",
        "loading",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "referrerpolicy",
        "sandbox",
        "scrolling",
        "src",
        "srcdoc",
        "width"
    ],
    img: [
        "align",
        "alt",
        "border",
        "crossorigin",
        "decoding",
        "height",
        "hspace",
        "ismap",
        "loading",
        "longdesc",
        "name",
        "referrerpolicy",
        "sizes",
        "src",
        "srcset",
        "usemap",
        "vspace",
        "width"
    ],
    input: [
        "accept",
        "accesskey",
        "align",
        "alt",
        "autocomplete",
        "autofocus",
        "checked",
        "dirname",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "height",
        "ismap",
        "list",
        "max",
        "maxlength",
        "min",
        "minlength",
        "multiple",
        "name",
        "pattern",
        "placeholder",
        "readonly",
        "required",
        "size",
        "src",
        "step",
        "tabindex",
        "title",
        "type",
        "usemap",
        "value",
        "width"
    ],
    ins: [
        "cite",
        "datetime"
    ],
    isindex: [
        "prompt"
    ],
    label: [
        "accesskey",
        "for",
        "form"
    ],
    legend: [
        "accesskey",
        "align"
    ],
    li: [
        "type",
        "value"
    ],
    link: [
        "as",
        "charset",
        "color",
        "crossorigin",
        "disabled",
        "href",
        "hreflang",
        "imagesizes",
        "imagesrcset",
        "integrity",
        "media",
        "nonce",
        "referrerpolicy",
        "rel",
        "rev",
        "sizes",
        "target",
        "title",
        "type"
    ],
    map: [
        "name"
    ],
    menu: [
        "compact"
    ],
    meta: [
        "charset",
        "content",
        "http-equiv",
        "name",
        "scheme"
    ],
    meter: [
        "high",
        "low",
        "max",
        "min",
        "optimum",
        "value"
    ],
    object: [
        "align",
        "archive",
        "border",
        "classid",
        "codebase",
        "codetype",
        "data",
        "declare",
        "form",
        "height",
        "hspace",
        "name",
        "standby",
        "tabindex",
        "type",
        "typemustmatch",
        "usemap",
        "vspace",
        "width"
    ],
    ol: [
        "compact",
        "reversed",
        "start",
        "type"
    ],
    optgroup: [
        "disabled",
        "label"
    ],
    option: [
        "disabled",
        "label",
        "selected",
        "value"
    ],
    output: [
        "for",
        "form",
        "name"
    ],
    p: [
        "align"
    ],
    param: [
        "name",
        "type",
        "value",
        "valuetype"
    ],
    pre: [
        "width"
    ],
    progress: [
        "max",
        "value"
    ],
    q: [
        "cite"
    ],
    script: [
        "async",
        "charset",
        "crossorigin",
        "defer",
        "integrity",
        "language",
        "nomodule",
        "nonce",
        "referrerpolicy",
        "src",
        "type"
    ],
    select: [
        "autocomplete",
        "autofocus",
        "disabled",
        "form",
        "multiple",
        "name",
        "required",
        "size",
        "tabindex"
    ],
    slot: [
        "name"
    ],
    source: [
        "media",
        "sizes",
        "src",
        "srcset",
        "type"
    ],
    style: [
        "media",
        "nonce",
        "title",
        "type"
    ],
    table: [
        "align",
        "bgcolor",
        "border",
        "cellpadding",
        "cellspacing",
        "frame",
        "rules",
        "summary",
        "width"
    ],
    tbody: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    td: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    textarea: [
        "accesskey",
        "autocomplete",
        "autofocus",
        "cols",
        "dirname",
        "disabled",
        "form",
        "maxlength",
        "minlength",
        "name",
        "placeholder",
        "readonly",
        "required",
        "rows",
        "tabindex",
        "wrap"
    ],
    tfoot: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    th: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    thead: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    time: [
        "datetime"
    ],
    tr: [
        "align",
        "bgcolor",
        "char",
        "charoff",
        "valign"
    ],
    track: [
        "default",
        "kind",
        "label",
        "src",
        "srclang"
    ],
    ul: [
        "compact",
        "type"
    ],
    video: [
        "autoplay",
        "controls",
        "crossorigin",
        "height",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "width"
    ]
};
const { inferParserByLanguage: tS , isFrontMatterNode: nS  } = Nt1, { CSS_DISPLAY_TAGS: rS , CSS_DISPLAY_DEFAULT: oS , CSS_WHITE_SPACE_TAGS: uS , CSS_WHITE_SPACE_DEFAULT: iS  } = {
    CSS_DISPLAY_TAGS: {
        area: "none",
        base: "none",
        basefont: "none",
        datalist: "none",
        head: "none",
        link: "none",
        meta: "none",
        noembed: "none",
        noframes: "none",
        param: "block",
        rp: "none",
        script: "block",
        source: "block",
        style: "none",
        template: "inline",
        track: "block",
        title: "none",
        html: "block",
        body: "block",
        address: "block",
        blockquote: "block",
        center: "block",
        div: "block",
        figure: "block",
        figcaption: "block",
        footer: "block",
        form: "block",
        header: "block",
        hr: "block",
        legend: "block",
        listing: "block",
        main: "block",
        p: "block",
        plaintext: "block",
        pre: "block",
        xmp: "block",
        slot: "contents",
        ruby: "ruby",
        rt: "ruby-text",
        article: "block",
        aside: "block",
        h1: "block",
        h2: "block",
        h3: "block",
        h4: "block",
        h5: "block",
        h6: "block",
        hgroup: "block",
        nav: "block",
        section: "block",
        dir: "block",
        dd: "block",
        dl: "block",
        dt: "block",
        ol: "block",
        ul: "block",
        li: "list-item",
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell",
        fieldset: "block",
        button: "inline-block",
        details: "block",
        summary: "block",
        dialog: "block",
        meter: "inline-block",
        progress: "inline-block",
        object: "inline-block",
        video: "inline-block",
        audio: "inline-block",
        select: "inline-block",
        option: "block",
        optgroup: "block"
    },
    CSS_DISPLAY_DEFAULT: "inline",
    CSS_WHITE_SPACE_TAGS: {
        listing: "pre",
        plaintext: "pre",
        pre: "pre",
        xmp: "pre",
        nobr: "nowrap",
        table: "initial",
        textarea: "pre-wrap"
    },
    CSS_WHITE_SPACE_DEFAULT: "normal"
}, aS = dS([
    "a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "command",
    "content",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "image",
    "img",
    "input",
    "ins",
    "isindex",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "math",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "multicol",
    "nav",
    "nextid",
    "nobr",
    "noembed",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "plaintext",
    "pre",
    "progress",
    "q",
    "rb",
    "rbc",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "slot",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "svg",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp"
]), sS = function(e18, t12) {
    const n8 = Object.create(null);
    for (const r6 of Object.keys(e18))n8[r6] = t12(e18[r6], r6);
    return n8;
}(eS, dS), lS = new Set([
    "\t",
    "\n",
    "\f",
    "\r",
    " "
]), cS = (e18)=>e18.replace(/[\t\n\f\r ]+$/, "")
, pS = (e18)=>e18.match(/^[\t\n\f\r ]*/)[0]
;
function fS(e18, t12) {
    return !("ieConditionalComment" !== e18.type || !e18.lastChild || e18.lastChild.isSelfClosing || e18.lastChild.endSourceSpan) || ("ieConditionalComment" === e18.type && !e18.complete || (!(!xS(e18) || !e18.children.some((e19)=>"text" !== e19.type && "interpolation" !== e19.type
    )) || !(!kS(e18, t12) || mS(e18) || "interpolation" === e18.type)));
}
function gS(e18) {
    return wS(e18).startsWith("pre");
}
function xS(e18) {
    return wS(e18).startsWith("pre");
}
function wS(e18) {
    return "element" === e18.type && (!e18.namespace || SS(e18)) && uS[e18.name] || iS;
}
var PS = {
    HTML_ELEMENT_ATTRIBUTES: sS,
    HTML_TAGS: aS,
    htmlTrim: (e18)=>((e19)=>e19.replace(/^[\t\n\f\r ]+/, "")
        )(cS(e18))
    ,
    htmlTrimPreserveIndentation: (e18)=>((e19)=>e19.replace(/^[\t\f\r ]*?\n/g, "")
        )(cS(e18))
    ,
    splitByHtmlWhitespace: (e18)=>e18.split(/[\t\n\f\r ]+/)
    ,
    hasHtmlWhitespace: (e18)=>/[\t\n\f\r ]/.test(e18)
    ,
    getLeadingAndTrailingHtmlWhitespace: (e18)=>{
        const [, t12, n8, r6] = e18.match(/^([\t\n\f\r ]*)([\S\s]*?)([\t\n\f\r ]*)$/);
        return {
            leadingWhitespace: t12,
            trailingWhitespace: r6,
            text: n8
        };
    },
    canHaveInterpolation: function(e18) {
        return e18.children && !mS(e18);
    },
    countChars: function(e18, t12) {
        let n8 = 0;
        for(let r6 = 0; r6 < e18.length; r6++)e18[r6] === t12 && n8++;
        return n8;
    },
    countParents: function(e18, t12) {
        let n8 = 0;
        for(let r6 = e18.stack.length - 1; r6 >= 0; r6--){
            const o5 = e18.stack[r6];
            o5 && "object" == typeof o5 && !Array.isArray(o5) && t12(o5) && n8++;
        }
        return n8;
    },
    dedentString: function(e18, t12 = function(e19) {
        let t13 = 1 / 0;
        for (const n8 of e19.split("\n")){
            if (0 === n8.length) continue;
            if (!lS.has(n8[0])) return 0;
            const e20 = pS(n8).length;
            n8.length !== e20 && e20 < t13 && (t13 = e20);
        }
        return t13 === 1 / 0 ? 0 : t13;
    }(e18)) {
        return 0 === t12 ? e18 : e18.split("\n").map((e19)=>e19.slice(t12)
        ).join("\n");
    },
    forceBreakChildren: DS,
    forceBreakContent: function(e18) {
        return DS(e18) || "element" === e18.type && 0 !== e18.children.length && ([
            "body",
            "script",
            "style"
        ].includes(e18.name) || e18.children.some((e19)=>(function(e20) {
                return e20.children && e20.children.some((e21)=>"text" !== e21.type
                );
            })(e19)
        )) || e18.firstChild && e18.firstChild === e18.lastChild && "text" !== e18.firstChild.type && CS(e18.firstChild) && (!e18.lastChild.isTrailingSpaceSensitive || bS(e18.lastChild));
    },
    forceNextEmptyLine: function(e18) {
        return nS(e18) || e18.next && e18.sourceSpan.end && e18.sourceSpan.end.line + 1 < e18.next.sourceSpan.start.line;
    },
    getLastDescendant: function e18(t12) {
        return t12.lastChild ? e18(t12.lastChild) : t12;
    },
    getNodeCssStyleDisplay: function(e19, t12) {
        if (e19.prev && "comment" === e19.prev.type) {
            const t13 = e19.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t13) return t13[1];
        }
        let n8 = !1;
        if ("element" === e19.type && "svg" === e19.namespace) {
            if (!function(e20, t13) {
                let n9 = e20;
                for(; n9;){
                    if (t13(n9)) return !0;
                    n9 = n9.parent;
                }
                return !1;
            }(e19, (e20)=>"svg:foreignObject" === e20.fullName
            )) return "svg" === e19.name ? "inline-block" : "block";
            n8 = !0;
        }
        switch(t12.htmlWhitespaceSensitivity){
            case "strict":
                return "inline";
            case "ignore":
                return "block";
            default:
                return "vue" === t12.parser && e19.parent && "root" === e19.parent.type ? "block" : "element" === e19.type && (!e19.namespace || n8 || SS(e19)) && rS[e19.name] || oS;
        }
    },
    getNodeCssStyleWhiteSpace: wS,
    getPrettierIgnoreAttributeCommentData: function(e19) {
        const t12 = e19.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);
        return !!t12 && (!t12[1] || t12[1].split(/\s+/));
    },
    hasPrettierIgnore: hS,
    inferScriptParser: function(e19, t12) {
        return "script" !== e19.name || e19.attrMap.src ? "style" === e19.name ? function(e20) {
            const { lang: t13  } = e20.attrMap;
            return t13 && "postcss" !== t13 && "css" !== t13 ? "scss" === t13 ? "scss" : "less" === t13 ? "less" : void 0 : "css";
        }(e19) : t12 && kS(e19, t12) ? AS(e19) || !("src" in e19.attrMap) && tS(e19.attrMap.lang, t12) : void 0 : e19.attrMap.lang || e19.attrMap.type ? AS(e19) : "babel";
    },
    isVueCustomBlock: BS,
    isVueNonHtmlBlock: kS,
    isVueSlotAttribute: function(e19) {
        const t12 = e19.fullName;
        return "#" === t12.charAt(0) || "slot-scope" === t12 || "v-slot" === t12 || t12.startsWith("v-slot:");
    },
    isVueSfcBindingsAttribute: function(e19, t12) {
        const n8 = e19.parent;
        if (!NS(n8, t12)) return !1;
        const r6 = n8.fullName, o5 = e19.fullName;
        return "script" === r6 && "setup" === o5 || "style" === r6 && "vars" === o5;
    },
    isDanglingSpaceSensitiveNode: function(e19) {
        return !(t12 = e19.cssDisplay, FS(t12) || "inline-block" === t12 || mS(e19));
        var t12;
    },
    isIndentationSensitiveNode: gS,
    isLeadingSpaceSensitiveNode: function(e19, t12) {
        const n8 = function() {
            if (nS(e19)) return !1;
            if (("text" === e19.type || "interpolation" === e19.type) && e19.prev && ("text" === e19.prev.type || "interpolation" === e19.prev.type)) return !0;
            if (!e19.parent || "none" === e19.parent.cssDisplay) return !1;
            if (xS(e19.parent)) return !0;
            if (!e19.prev && ("root" === e19.parent.type || xS(e19) && e19.parent || mS(e19.parent) || BS(e19.parent, t12) || (n8 = e19.parent.cssDisplay, FS(n8) || "inline-block" === n8))) return !1;
            var n8;
            if (e19.prev && !(function(e20) {
                return !FS(e20);
            })(e19.prev.cssDisplay)) return !1;
            return !0;
        }();
        return n8 && !e19.prev && e19.parent && e19.parent.tagDefinition && e19.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e19.type : n8;
    },
    isPreLikeNode: xS,
    isScriptLikeTag: mS,
    isTextLikeNode: function(e19) {
        return "text" === e19.type || "comment" === e19.type;
    },
    isTrailingSpaceSensitiveNode: function(e19, t12) {
        return !nS(e19) && (!("text" !== e19.type && "interpolation" !== e19.type || !e19.next || "text" !== e19.next.type && "interpolation" !== e19.next.type) || !(!e19.parent || "none" === e19.parent.cssDisplay) && (!!xS(e19.parent) || !(!e19.next && ("root" === e19.parent.type || xS(e19) && e19.parent || mS(e19.parent) || BS(e19.parent, t12) || (n8 = e19.parent.cssDisplay, FS(n8) || "inline-block" === n8))) && !(e19.next && !function(e20) {
            return !FS(e20);
        }(e19.next.cssDisplay))));
        var n8;
    },
    isWhitespaceSensitiveNode: function(e19) {
        return mS(e19) || "interpolation" === e19.type || gS(e19);
    },
    isUnknownNamespace: SS,
    preferHardlineAsLeadingSpaces: function(e19) {
        return vS(e19) || e19.prev && yS(e19.prev) || ES(e19);
    },
    preferHardlineAsTrailingSpaces: yS,
    shouldNotPrintClosingTag: function(e19, t12) {
        return !e19.isSelfClosing && !e19.endSourceSpan && (hS(e19) || fS(e19.parent, t12));
    },
    shouldPreserveContent: fS,
    unescapeQuoteEntities: function(e19) {
        return e19.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
}, OS = je(function(e18, t12) {
    function n8(e19) {
        return t12.$0 <= e19 && e19 <= t12.$9;
    }
    Object.defineProperty(t12, "__esModule", {
        value: !0
    }), t12.$EOF = 0, t12.$BSPACE = 8, t12.$TAB = 9, t12.$LF = 10, t12.$VTAB = 11, t12.$FF = 12, t12.$CR = 13, t12.$SPACE = 32, t12.$BANG = 33, t12.$DQ = 34, t12.$HASH = 35, t12.$$ = 36, t12.$PERCENT = 37, t12.$AMPERSAND = 38, t12.$SQ = 39, t12.$LPAREN = 40, t12.$RPAREN = 41, t12.$STAR = 42, t12.$PLUS = 43, t12.$COMMA = 44, t12.$MINUS = 45, t12.$PERIOD = 46, t12.$SLASH = 47, t12.$COLON = 58, t12.$SEMICOLON = 59, t12.$LT = 60, t12.$EQ = 61, t12.$GT = 62, t12.$QUESTION = 63, t12.$0 = 48, t12.$7 = 55, t12.$9 = 57, t12.$A = 65, t12.$E = 69, t12.$F = 70, t12.$X = 88, t12.$Z = 90, t12.$LBRACKET = 91, t12.$BACKSLASH = 92, t12.$RBRACKET = 93, t12.$CARET = 94, t12.$_ = 95, t12.$a = 97, t12.$b = 98, t12.$e = 101, t12.$f = 102, t12.$n = 110, t12.$r = 114, t12.$t = 116, t12.$u = 117, t12.$v = 118, t12.$x = 120, t12.$z = 122, t12.$LBRACE = 123, t12.$BAR = 124, t12.$RBRACE = 125, t12.$NBSP = 160, t12.$PIPE = 124, t12.$TILDA = 126, t12.$AT = 64, t12.$BT = 96, t12.isWhitespace = function(e19) {
        return e19 >= t12.$TAB && e19 <= t12.$SPACE || e19 == t12.$NBSP;
    }, t12.isDigit = n8, t12.isAsciiLetter = function(e19) {
        return e19 >= t12.$a && e19 <= t12.$z || e19 >= t12.$A && e19 <= t12.$Z;
    }, t12.isAsciiHexDigit = function(e19) {
        return e19 >= t12.$a && e19 <= t12.$f || e19 >= t12.$A && e19 <= t12.$F || n8(e19);
    }, t12.isNewLine = function(e19) {
        return e19 === t12.$LF || e19 === t12.$CR;
    }, t12.isOctalDigit = function(e19) {
        return t12.$0 <= e19 && e19 <= t12.$7;
    };
}), IS = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    });
    class n8 {
        constructor(e19, t13, n9){
            this.filePath = e19, this.name = t13, this.members = n9;
        }
        assertNoMembers() {
            if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
        }
    }
    t12.StaticSymbol = n8;
    t12.StaticSymbolCache = class {
        constructor(){
            this.cache = new Map;
        }
        get(e, t, r) {
            const o5 = (r = r || []).length ? ".".concat(r.join(".")) : "", u4 = '"'.concat(e, '".').concat(t).concat(o5);
            let i6 = this.cache.get(u4);
            return i6 || (i6 = new n8(e, t, r), this.cache.set(u4, i6)), i6;
        }
    };
}), LS = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    });
    const n8 = /-+([a-z0-9])/g;
    function r6(e19, t13, n9) {
        const r7 = e19.indexOf(t13);
        return -1 == r7 ? n9 : [
            e19.slice(0, r7).trim(),
            e19.slice(r7 + 1).trim()
        ];
    }
    function o5(e19, t13, n9) {
        return Array.isArray(e19) ? t13.visitArray(e19, n9) : "object" == typeof (r7 = e19) && null !== r7 && Object.getPrototypeOf(r7) === a5 ? t13.visitStringMap(e19, n9) : null == e19 || "string" == typeof e19 || "number" == typeof e19 || "boolean" == typeof e19 ? t13.visitPrimitive(e19, n9) : t13.visitOther(e19, n9);
        var r7;
    }
    t12.dashCaseToCamelCase = function(e19) {
        return e19.replace(n8, (...e20)=>e20[1].toUpperCase()
        );
    }, t12.splitAtColon = function(e19, t13) {
        return r6(e19, ":", t13);
    }, t12.splitAtPeriod = function(e19, t13) {
        return r6(e19, ".", t13);
    }, t12.visitValue = o5, t12.isDefined = function(e19) {
        return null != e19;
    }, t12.noUndefined = function(e19) {
        return (void 0) === e19 ? null : e19;
    };
    t12.ValueTransformer = class {
        visitArray(e, t) {
            return e.map((e19)=>o5(e19, this, t)
            );
        }
        visitStringMap(e, t) {
            const n9 = {
            };
            return Object.keys(e).forEach((r7)=>{
                n9[r7] = o5(e[r7], this, t);
            }), n9;
        }
        visitPrimitive(e, t) {
            return e;
        }
        visitOther(e, t) {
            return e;
        }
    }, t12.SyncAsync = {
        assertSync: (e19)=>{
            if (s4(e19)) throw new Error("Illegal state: value cannot be a promise");
            return e19;
        },
        then: (e19, t13)=>s4(e19) ? e19.then(t13) : t13(e19)
        ,
        all: (e19)=>e19.some(s4) ? Promise.all(e19) : e19
    }, t12.error = function(e19) {
        throw new Error("Internal Error: ".concat(e19));
    }, t12.syntaxError = function(e19, t13) {
        const n9 = Error(e19);
        return n9[u4] = !0, t13 && (n9[i6] = t13), n9;
    };
    const u4 = "ngSyntaxError", i6 = "ngParseErrors";
    t12.isSyntaxError = function(e19) {
        return e19[u4];
    }, t12.getParseErrors = function(e19) {
        return e19[i6] || [];
    }, t12.escapeRegExp = function(e19) {
        return e19.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const a5 = Object.getPrototypeOf({
    });
    function s4(e19) {
        return !!e19 && "function" == typeof e19.then;
    }
    t12.utf8Encode = function(e19) {
        let t13 = "";
        for(let n9 = 0; n9 < e19.length; n9++){
            let r7 = e19.charCodeAt(n9);
            if (r7 >= 55296 && r7 <= 56319 && e19.length > n9 + 1) {
                const t14 = e19.charCodeAt(n9 + 1);
                t14 >= 56320 && t14 <= 57343 && (n9++, r7 = (r7 - 55296 << 10) + t14 - 56320 + 65536);
            }
            r7 <= 127 ? t13 += String.fromCharCode(r7) : r7 <= 2047 ? t13 += String.fromCharCode(r7 >> 6 & 31 | 192, 63 & r7 | 128) : r7 <= 65535 ? t13 += String.fromCharCode(r7 >> 12 | 224, r7 >> 6 & 63 | 128, 63 & r7 | 128) : r7 <= 2097151 && (t13 += String.fromCharCode(r7 >> 18 & 7 | 240, r7 >> 12 & 63 | 128, r7 >> 6 & 63 | 128, 63 & r7 | 128));
        }
        return t13;
    }, t12.stringify = function e18(t13) {
        if ("string" == typeof t13) return t13;
        if (t13 instanceof Array) return "[" + t13.map(e18).join(", ") + "]";
        if (null == t13) return "" + t13;
        if (t13.overriddenName) return "".concat(t13.overriddenName);
        if (t13.name) return "".concat(t13.name);
        if (!t13.toString) return "object";
        const n9 = t13.toString();
        if (null == n9) return "" + n9;
        const r7 = n9.indexOf("\n");
        return -1 === r7 ? n9 : n9.substring(0, r7);
    }, t12.resolveForwardRef = function(e19) {
        return "function" == typeof e19 && e19.hasOwnProperty("__forward_ref__") ? e19() : e19;
    }, t12.isPromise = s4;
    t12.Version = class {
        constructor(e19){
            this.full = e19;
            const t13 = e19.split(".");
            this.major = t13[0], this.minor = t13[1], this.patch = t13.slice(2).join(".");
        }
    };
    const l5 = "undefined" != typeof window && window, c6 = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, p6 = (void 0) !== Me && Me || l5 || c6;
    t12.global = p6;
}), MS = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    });
    const n8 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function r6(e19) {
        return e19.replace(/\W/g, "_");
    }
    t12.sanitizeIdentifier = r6;
    let o5 = 0;
    function u4(e19) {
        if (!e19 || !e19.reference) return null;
        const t13 = e19.reference;
        if (t13 instanceof IS.StaticSymbol) return t13.name;
        if (t13.__anonymousType) return t13.__anonymousType;
        let n9 = LS.stringify(t13);
        return (n9.indexOf("(") >= 0 ? (n9 = "anonymous_".concat(o5++), t13.__anonymousType = n9) : n9 = r6(n9), n9);
    }
    var i6;
    t12.identifierName = u4, t12.identifierModuleUrl = function(e19) {
        const t13 = e19.reference;
        return t13 instanceof IS.StaticSymbol ? t13.filePath : "./".concat(LS.stringify(t13));
    }, t12.viewClassName = function(e19, t13) {
        return "View_".concat(u4({
            reference: e19
        }), "_").concat(t13);
    }, t12.rendererTypeName = function(e19) {
        return "RenderType_".concat(u4({
            reference: e19
        }));
    }, t12.hostViewClassName = function(e19) {
        return "HostView_".concat(u4({
            reference: e19
        }));
    }, t12.componentFactoryName = function(e19) {
        return "".concat(u4({
            reference: e19
        }), "NgFactory");
    }, (function(e19) {
        e19[e19.Pipe = 0] = "Pipe", e19[e19.Directive = 1] = "Directive", e19[e19.NgModule = 2] = "NgModule", e19[e19.Injectable = 3] = "Injectable";
    })(i6 = t12.CompileSummaryKind || (t12.CompileSummaryKind = {
    })), t12.tokenName = function(e19) {
        return null != e19.value ? r6(e19.value) : u4(e19.identifier);
    }, t12.tokenReference = function(e19) {
        return null != e19.identifier ? e19.identifier.reference : e19.value;
    };
    t12.CompileStylesheetMetadata = class {
        constructor({ moduleUrl: e19 , styles: t13 , styleUrls: n9  } = {
        }){
            this.moduleUrl = e19 || null, this.styles = s4(t13), this.styleUrls = s4(n9);
        }
    };
    t12.CompileTemplateMetadata = class {
        constructor({ encapsulation: e20 , template: t14 , templateUrl: n10 , htmlAst: r7 , styles: o6 , styleUrls: u5 , externalStylesheets: i7 , animations: a5 , ngContentSelectors: c6 , interpolation: p6 , isInline: d6 , preserveWhitespaces: f5  }){
            if (this.encapsulation = e20, this.template = t14, this.templateUrl = n10, this.htmlAst = r7, this.styles = s4(o6), this.styleUrls = s4(u5), this.externalStylesheets = s4(i7), this.animations = a5 ? l7(a5) : [], this.ngContentSelectors = c6 || [], p6 && 2 != p6.length) throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = p6, this.isInline = d6, this.preserveWhitespaces = f5;
        }
        toSummary() {
            return {
                ngContentSelectors: this.ngContentSelectors,
                encapsulation: this.encapsulation,
                styles: this.styles,
                animations: this.animations
            };
        }
    };
    class a6 {
        static create({ isHost: e , type: t , isComponent: r , selector: o , exportAs: u , changeDetection: i , inputs: s , outputs: l , host: c , providers: p , viewProviders: d , queries: f , guards: h , viewQueries: m , entryComponents: g , template: D , componentViewType: y , rendererType: E , componentFactory: C  }) {
            const b4 = {
            }, v5 = {
            }, A5 = {
            };
            null != c && Object.keys(c).forEach((e21)=>{
                const t15 = c[e21], r8 = e21.match(n8);
                null === r8 ? A5[e21] = t15 : null != r8[1] ? v5[r8[1]] = t15 : null != r8[2] && (b4[r8[2]] = t15);
            });
            const F4 = {
            };
            null != s && s.forEach((e21)=>{
                const t15 = LS.splitAtColon(e21, [
                    e21,
                    e21
                ]);
                F4[t15[0]] = t15[1];
            });
            const x4 = {
            };
            return null != l && l.forEach((e21)=>{
                const t15 = LS.splitAtColon(e21, [
                    e21,
                    e21
                ]);
                x4[t15[0]] = t15[1];
            }), new a6({
                isHost: e,
                type: t,
                isComponent: !!r,
                selector: o,
                exportAs: u,
                changeDetection: i,
                inputs: F4,
                outputs: x4,
                hostListeners: b4,
                hostProperties: v5,
                hostAttributes: A5,
                providers: p,
                viewProviders: d,
                queries: f,
                guards: h,
                viewQueries: m,
                entryComponents: g,
                template: D,
                componentViewType: y,
                rendererType: E,
                componentFactory: C
            });
        }
        constructor({ isHost: e21 , type: t15 , isComponent: n11 , selector: r8 , exportAs: o7 , changeDetection: u6 , inputs: i8 , outputs: a7 , hostListeners: l5 , hostProperties: c7 , hostAttributes: p7 , providers: d7 , viewProviders: f6 , queries: h5 , guards: m5 , viewQueries: g6 , entryComponents: D5 , template: y6 , componentViewType: E5 , rendererType: C4 , componentFactory: b4  }){
            this.isHost = !!e21, this.type = t15, this.isComponent = n11, this.selector = r8, this.exportAs = o7, this.changeDetection = u6, this.inputs = i8, this.outputs = a7, this.hostListeners = l5, this.hostProperties = c7, this.hostAttributes = p7, this.providers = s4(d7), this.viewProviders = s4(f6), this.queries = s4(h5), this.guards = m5, this.viewQueries = s4(g6), this.entryComponents = s4(D5), this.template = y6, this.componentViewType = E5, this.rendererType = C4, this.componentFactory = b4;
        }
        toSummary() {
            return {
                summaryKind: i6.Directive,
                type: this.type,
                isComponent: this.isComponent,
                selector: this.selector,
                exportAs: this.exportAs,
                inputs: this.inputs,
                outputs: this.outputs,
                hostListeners: this.hostListeners,
                hostProperties: this.hostProperties,
                hostAttributes: this.hostAttributes,
                providers: this.providers,
                viewProviders: this.viewProviders,
                queries: this.queries,
                guards: this.guards,
                viewQueries: this.viewQueries,
                entryComponents: this.entryComponents,
                changeDetection: this.changeDetection,
                template: this.template && this.template.toSummary(),
                componentViewType: this.componentViewType,
                rendererType: this.rendererType,
                componentFactory: this.componentFactory
            };
        }
    }
    t12.CompileDirectiveMetadata = a6;
    t12.CompilePipeMetadata = class {
        constructor({ type: e22 , name: t16 , pure: n12  }){
            this.type = e22, this.name = t16, this.pure = !!n12;
        }
        toSummary() {
            return {
                summaryKind: i6.Pipe,
                type: this.type,
                name: this.name,
                pure: this.pure
            };
        }
    };
    t12.CompileShallowModuleMetadata = class {
    };
    t12.CompileNgModuleMetadata = class {
        constructor({ type: e23 , providers: t17 , declaredDirectives: n13 , exportedDirectives: r9 , declaredPipes: o8 , exportedPipes: u7 , entryComponents: i9 , bootstrapComponents: a8 , importedModules: l6 , exportedModules: c8 , schemas: p8 , transitiveModule: d8 , id: f7  }){
            this.type = e23 || null, this.declaredDirectives = s4(n13), this.exportedDirectives = s4(r9), this.declaredPipes = s4(o8), this.exportedPipes = s4(u7), this.providers = s4(t17), this.entryComponents = s4(i9), this.bootstrapComponents = s4(a8), this.importedModules = s4(l6), this.exportedModules = s4(c8), this.schemas = s4(p8), this.id = f7 || null, this.transitiveModule = d8 || null;
        }
        toSummary() {
            const e24 = this.transitiveModule;
            return {
                summaryKind: i6.NgModule,
                type: this.type,
                entryComponents: e24.entryComponents,
                providers: e24.providers,
                modules: e24.modules,
                exportedDirectives: e24.exportedDirectives,
                exportedPipes: e24.exportedPipes
            };
        }
    };
    function s4(e24) {
        return e24 || [];
    }
    t12.TransitiveCompileNgModuleMetadata = class {
        constructor(){
            this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
        }
        addProvider(e, t) {
            this.providers.push({
                provider: e,
                module: t
            });
        }
        addDirective(e) {
            this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e));
        }
        addExportedDirective(e) {
            this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e));
        }
        addPipe(e) {
            this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e));
        }
        addExportedPipe(e) {
            this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e));
        }
        addModule(e) {
            this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e));
        }
        addEntryComponent(e) {
            this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e));
        }
    };
    function l7(e24) {
        return e24.reduce((e25, t18)=>{
            const n14 = Array.isArray(t18) ? l7(t18) : t18;
            return e25.concat(n14);
        }, []);
    }
    function c9(e24) {
        return e24.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t12.ProviderMeta = class {
        constructor(e24, { useClass: t18 , useValue: n14 , useExisting: r10 , useFactory: o9 , deps: u8 , multi: i10  }){
            this.token = e24, this.useClass = t18 || null, this.useValue = n14, this.useExisting = r10, this.useFactory = o9 || null, this.dependencies = u8 || null, this.multi = !!i10;
        }
    }, t12.flatten = l7, t12.templateSourceUrl = function(e25, t19, n15) {
        let r11;
        return r11 = n15.isInline ? t19.type.reference instanceof IS.StaticSymbol ? "".concat(t19.type.reference.filePath, ".").concat(t19.type.reference.name, ".html") : "".concat(u4(e25), "/").concat(u4(t19.type), ".html") : n15.templateUrl, t19.type.reference instanceof IS.StaticSymbol ? r11 : c9(r11);
    }, t12.sharedStylesheetJitUrl = function(e25, t19) {
        const n15 = e25.moduleUrl.split(/\/\\/g), r11 = n15[n15.length - 1];
        return c9("css/".concat(t19).concat(r11, ".ngstyle.js"));
    }, t12.ngModuleJitUrl = function(e25) {
        return c9("".concat(u4(e25.type), "/module.ngfactory.js"));
    }, t12.templateJitUrl = function(e25, t19) {
        return c9("".concat(u4(e25), "/").concat(u4(t19.type), ".ngfactory.js"));
    };
}), jS = je(function(e18, t12) {
    Object.defineProperty(t12, "__esModule", {
        value: !0
    });
    class n8 {
        constructor(e19, t13, n9, r6){
            this.file = e19, this.offset = t13, this.line = n9, this.col = r6;
        }
        toString() {
            return null != this.offset ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
        moveBy(e) {
            const t14 = this.file.content, r7 = t14.length;
            let o5 = this.offset, u4 = this.line, i6 = this.col;
            for(; o5 > 0 && e < 0;){
                o5--, e++;
                if (t14.charCodeAt(o5) == OS.$LF) {
                    u4--;
                    const e20 = t14.substr(0, o5 - 1).lastIndexOf(String.fromCharCode(OS.$LF));
                    i6 = e20 > 0 ? o5 - e20 : o5;
                } else i6--;
            }
            for(; o5 < r7 && e > 0;){
                const n10 = t14.charCodeAt(o5);
                o5++, e--, n10 == OS.$LF ? (u4++, i6 = 0) : i6++;
            }
            return new n8(this.file, o5, u4, i6);
        }
        getContext(e, t) {
            const n10 = this.file.content;
            let r7 = this.offset;
            if (null != r7) {
                r7 > n10.length - 1 && (r7 = n10.length - 1);
                let o5 = r7, u4 = 0, i6 = 0;
                for(; u4 < e && r7 > 0 && (r7--, u4++, "\n" != n10[r7] || (++i6) != t););
                for(u4 = 0, i6 = 0; u4 < e && o5 < n10.length - 1 && (o5++, u4++, "\n" != n10[o5] || (++i6) != t););
                return {
                    before: n10.substring(r7, this.offset),
                    after: n10.substring(this.offset, o5 + 1)
                };
            }
            return null;
        }
    }
    t12.ParseLocation = n8;
    class r7 {
        constructor(e20, t14){
            this.content = e20, this.url = t14;
        }
    }
    t12.ParseSourceFile = r7;
    class o5 {
        constructor(e21, t15, n10 = null){
            this.start = e21, this.end = t15, this.details = n10;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var u4;
    t12.ParseSourceSpan = o5, t12.EMPTY_PARSE_LOCATION = new n8(new r7("", ""), 0, 0, 0), t12.EMPTY_SOURCE_SPAN = new o5(t12.EMPTY_PARSE_LOCATION, t12.EMPTY_PARSE_LOCATION), (function(e22) {
        e22[e22.WARNING = 0] = "WARNING", e22[e22.ERROR = 1] = "ERROR";
    })(u4 = t12.ParseErrorLevel || (t12.ParseErrorLevel = {
    }));
    t12.ParseError = class {
        constructor(e22, t16, n11 = u4.ERROR){
            this.span = e22, this.msg = t16, this.level = n11;
        }
        contextualMessage() {
            const e23 = this.span.start.getContext(100, 3);
            return e23 ? "".concat(this.msg, ' ("').concat(e23.before, "[").concat(u4[this.level], " ->]").concat(e23.after, '")') : this.msg;
        }
        toString() {
            const e23 = this.span.details ? ", ".concat(this.span.details) : "";
            return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e23);
        }
    }, t12.typeSourceSpan = function(e23, t17) {
        const u5 = MS.identifierModuleUrl(t17), i6 = null != u5 ? "in ".concat(e23, " ").concat(MS.identifierName(t17), " in ").concat(u5) : "in ".concat(e23, " ").concat(MS.identifierName(t17)), a5 = new r7("", i6);
        return new o5(new n8(a5, -1, -1, -1), new n8(a5, -1, -1, -1));
    }, t12.r3JitTypeSourceSpan = function(e23, t17, u5) {
        const i6 = "in ".concat(e23, " ").concat(t17, " in ").concat(u5), a5 = new r7("", i6);
        return new o5(new n8(a5, -1, -1, -1), new n8(a5, -1, -1, -1));
    };
});
const { ParseSourceSpan: _S  } = jS, { htmlTrim: RS , getLeadingAndTrailingHtmlWhitespace: VS , hasHtmlWhitespace: $S , canHaveInterpolation: qS , getNodeCssStyleDisplay: WS , isDanglingSpaceSensitiveNode: US , isIndentationSensitiveNode: JS , isLeadingSpaceSensitiveNode: zS , isTrailingSpaceSensitiveNode: GS , isWhitespaceSensitiveNode: HS  } = PS, XS = [
    function(e18) {
        return e18.map((e19)=>{
            if ("element" === e19.type && e19.tagDefinition.ignoreFirstLf && 0 !== e19.children.length && "text" === e19.children[0].type && "\n" === e19.children[0].value[0]) {
                const [t12, ...n8] = e19.children;
                return e19.clone({
                    children: 1 === t12.value.length ? n8 : [
                        t12.clone({
                            value: t12.value.slice(1)
                        }),
                        ...n8
                    ]
                });
            }
            return e19;
        });
    },
    function(e18) {
        const t12 = (e19)=>"element" === e19.type && e19.prev && "ieConditionalStartComment" === e19.prev.type && e19.prev.sourceSpan.end.offset === e19.startSourceSpan.start.offset && e19.firstChild && "ieConditionalEndComment" === e19.firstChild.type && e19.firstChild.sourceSpan.start.offset === e19.startSourceSpan.end.offset
        ;
        return e18.map((e19)=>{
            if (e19.children) {
                const n8 = e19.children.map(t12);
                if (n8.some(Boolean)) {
                    const t13 = [];
                    for(let r6 = 0; r6 < e19.children.length; r6++){
                        const o5 = e19.children[r6];
                        if (!n8[r6 + 1]) {
                            if (n8[r6]) {
                                const e20 = o5.prev, n9 = o5.firstChild, r7 = new _S(e20.sourceSpan.start, n9.sourceSpan.end), u4 = new _S(r7.start, o5.sourceSpan.end);
                                t13.push(o5.clone({
                                    condition: e20.condition,
                                    sourceSpan: u4,
                                    startSourceSpan: r7,
                                    children: o5.children.slice(1)
                                }));
                            } else t13.push(o5);
                        }
                    }
                    return e19.clone({
                        children: t13
                    });
                }
            }
            return e19;
        });
    },
    function(e18) {
        return function(e19, t12, n8) {
            return e19.map((e20)=>{
                if (e20.children) {
                    const r6 = e20.children.map(t12);
                    if (r6.some(Boolean)) {
                        const t13 = [];
                        for(let o5 = 0; o5 < e20.children.length; o5++){
                            const u4 = e20.children[o5];
                            if ("text" !== u4.type && !r6[o5]) {
                                t13.push(u4);
                                continue;
                            }
                            const i6 = "text" === u4.type ? u4 : u4.clone({
                                type: "text",
                                value: n8(u4)
                            });
                            if (0 === t13.length || "text" !== t13[t13.length - 1].type) {
                                t13.push(i6);
                                continue;
                            }
                            const a5 = t13.pop();
                            t13.push(a5.clone({
                                value: a5.value + i6.value,
                                sourceSpan: new _S(a5.sourceSpan.start, i6.sourceSpan.end)
                            }));
                        }
                        return e20.clone({
                            children: t13
                        });
                    }
                }
                return e20;
            });
        }(e18, (e19)=>"cdata" === e19.type
        , (e19)=>"<![CDATA[".concat(e19.value, "]]>")
        );
    },
    function(e18, t12) {
        if ("html" === t12.parser) return e18;
        const n8 = /{{([\S\s]+?)}}/g;
        return e18.map((e19)=>{
            if (!qS(e19)) return e19;
            const t13 = [];
            for (const r6 of e19.children){
                if ("text" !== r6.type) {
                    t13.push(r6);
                    continue;
                }
                let e20 = r6.sourceSpan.start, o5 = null;
                const u4 = r6.value.split(n8);
                for(let n9 = 0; n9 < u4.length; n9++, e20 = o5){
                    const r7 = u4[n9];
                    n9 % 2 != 0 ? (o5 = e20.moveBy(r7.length + 4), t13.push({
                        type: "interpolation",
                        sourceSpan: new _S(e20, o5),
                        children: 0 === r7.length ? [] : [
                            {
                                type: "text",
                                value: r7,
                                sourceSpan: new _S(e20.moveBy(2), o5.moveBy(-2))
                            }
                        ]
                    })) : (o5 = e20.moveBy(r7.length), 0 !== r7.length && t13.push({
                        type: "text",
                        value: r7,
                        sourceSpan: new _S(e20, o5)
                    }));
                }
            }
            return e19.clone({
                children: t13
            });
        });
    },
    function(e18) {
        const t12 = "whitespace";
        return e18.map((e19)=>{
            if (!e19.children) return e19;
            if (0 === e19.children.length || 1 === e19.children.length && "text" === e19.children[0].type && 0 === RS(e19.children[0].value).length) return e19.clone({
                children: [],
                hasDanglingSpaces: 0 !== e19.children.length
            });
            const n8 = HS(e19), r6 = JS(e19);
            return e19.clone({
                isWhitespaceSensitive: n8,
                isIndentationSensitive: r6,
                children: e19.children.reduce((e20, r7)=>{
                    if ("text" !== r7.type || n8) return e20.concat(r7);
                    const o5 = [], { leadingWhitespace: u4 , text: i6 , trailingWhitespace: a5  } = VS(r7.value);
                    return u4 && o5.push({
                        type: t12
                    }), i6 && o5.push({
                        type: "text",
                        value: i6,
                        sourceSpan: new _S(r7.sourceSpan.start.moveBy(u4.length), r7.sourceSpan.end.moveBy(-a5.length))
                    }), a5 && o5.push({
                        type: t12
                    }), e20.concat(o5);
                }, []).reduce((e20, n9, r7, o5)=>{
                    if (n9.type === t12) return e20;
                    const u4 = 0 !== r7 && o5[r7 - 1].type === t12, i6 = r7 !== o5.length - 1 && o5[r7 + 1].type === t12;
                    return e20.concat(Object.assign({
                    }, n9, {
                        hasLeadingSpaces: u4,
                        hasTrailingSpaces: i6
                    }));
                }, [])
            });
        });
    },
    function(e18, t12) {
        return e18.map((e19)=>Object.assign(e19, {
                cssDisplay: WS(e19, t12)
            })
        );
    },
    function(e18) {
        return e18.map((e19)=>Object.assign(e19, {
                isSelfClosing: !e19.children || "element" === e19.type && (e19.tagDefinition.isVoid || e19.startSourceSpan === e19.endSourceSpan)
            })
        );
    },
    function(e18, t12) {
        return e18.map((e19)=>"element" !== e19.type ? e19 : Object.assign(e19, {
                hasHtmComponentClosingTag: e19.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t12.originalText.slice(e19.endSourceSpan.start.offset, e19.endSourceSpan.end.offset))
            })
        );
    },
    function(e18, t12) {
        return e18.map((e19)=>e19.children ? 0 === e19.children.length ? e19.clone({
                isDanglingSpaceSensitive: US(e19)
            }) : e19.clone({
                children: e19.children.map((e20)=>Object.assign({
                    }, e20, {
                        isLeadingSpaceSensitive: zS(e20, t12),
                        isTrailingSpaceSensitive: GS(e20, t12)
                    })
                ).map((e20, t13, n8)=>Object.assign({
                    }, e20, {
                        isLeadingSpaceSensitive: (0 === t13 || n8[t13 - 1].isTrailingSpaceSensitive) && e20.isLeadingSpaceSensitive,
                        isTrailingSpaceSensitive: (t13 === n8.length - 1 || n8[t13 + 1].isLeadingSpaceSensitive) && e20.isTrailingSpaceSensitive
                    })
                )
            }) : e19
        );
    },
    function(e18) {
        const t12 = (e19)=>"element" === e19.type && 0 === e19.attrs.length && 1 === e19.children.length && "text" === e19.firstChild.type && !$S(e19.children[0].value) && !e19.firstChild.hasLeadingSpaces && !e19.firstChild.hasTrailingSpaces && e19.isLeadingSpaceSensitive && !e19.hasLeadingSpaces && e19.isTrailingSpaceSensitive && !e19.hasTrailingSpaces && e19.prev && "text" === e19.prev.type && e19.next && "text" === e19.next.type
        ;
        return e18.map((e19)=>{
            if (e19.children) {
                const n8 = e19.children.map(t12);
                if (n8.some(Boolean)) {
                    const t13 = [];
                    for(let r6 = 0; r6 < e19.children.length; r6++){
                        const o5 = e19.children[r6];
                        if (n8[r6]) {
                            const n9 = t13.pop(), u4 = e19.children[++r6], { isTrailingSpaceSensitive: i6 , hasTrailingSpaces: a5  } = u4;
                            t13.push(n9.clone({
                                value: n9.value + "<".concat(o5.rawName, ">") + o5.firstChild.value + "</".concat(o5.rawName, ">") + u4.value,
                                sourceSpan: new _S(n9.sourceSpan.start, u4.sourceSpan.end),
                                isTrailingSpaceSensitive: i6,
                                hasTrailingSpaces: a5
                            }));
                        } else t13.push(o5);
                    }
                    return e19.clone({
                        children: t13
                    });
                }
            }
            return e19;
        });
    }
];
var YS = function(e18, t12) {
    for (const n8 of XS)e18 = n8(e18, t12);
    return e18;
};
const { builders: { concat: ZS , group: ew  }  } = rn1;
var tw = {
    isVueEventBindingExpression: function(e18) {
        const t12 = e18.trim();
        return /^([\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t12) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t12);
    },
    printVueFor: function(e18, t12) {
        const { left: n8 , operator: r6 , right: o5  } = function(e19) {
            const t13 = /([^]*?)\s+(in|of)\s+([^]*)/, n9 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r7 = /^\(|\)$/g, o6 = e19.match(t13);
            if (!o6) return;
            const u4 = {
            };
            u4.for = o6[3].trim();
            const i6 = o6[1].trim().replace(r7, ""), a5 = i6.match(n9);
            a5 ? (u4.alias = i6.replace(n9, ""), u4.iterator1 = a5[1].trim(), a5[2] && (u4.iterator2 = a5[2].trim())) : u4.alias = i6;
            return {
                left: "".concat([
                    u4.alias,
                    u4.iterator1,
                    u4.iterator2
                ].filter(Boolean).join(",")),
                operator: o6[2],
                right: u4.for
            };
        }(e18);
        return ZS([
            ew(t12("function _(".concat(n8, ") {}"), {
                parser: "babel",
                __isVueForBindingLeft: !0
            })),
            " ",
            r6,
            " ",
            t12(o5, {
                parser: "__js_expression"
            }, {
                stripTrailingHardline: !0
            })
        ]);
    },
    printVueBindings: function(e18, t12) {
        return t12("function _(".concat(e18, ") {}"), {
            parser: "babel",
            __isVueBindings: !0
        }, {
            stripTrailingHardline: !0
        });
    }
}, nw = je(function(e18) {
    !(function(t12, n8) {
        e18.exports ? e18.exports = n8() : t12.parseSrcset = n8();
    })(Me, function() {
        return function(e19, t12) {
            var n8 = t12 && t12.logger || console;
            function r6(e20) {
                return " " === e20 || "\t" === e20 || "\n" === e20 || "\f" === e20 || "\r" === e20;
            }
            function o5(t13) {
                var n9, r7 = t13.exec(e19.substring(D5));
                if (r7) return (n9 = r7[0], D5 += n9.length, n9);
            }
            for(var u4, i6, a5, s4, l5, c6 = e19.length, p6 = /^[ \t\n\r\u000c]+/, d6 = /^[, \t\n\r\u000c]+/, f5 = /^[^ \t\n\r\u000c]+/, h5 = /[,]+$/, m5 = /^\d+$/, g6 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D5 = 0, y6 = [];;){
                if ((o5(d6), D5 >= c6)) return y6;
                u4 = o5(f5), i6 = [], "," === u4.slice(-1) ? (u4 = u4.replace(h5, ""), C4()) : E5();
            }
            function E5() {
                for((o5(p6), a5 = "", s4 = "in descriptor");;){
                    if ((l5 = e19.charAt(D5), "in descriptor" === s4)) {
                        if (r6(l5)) a5 && (i6.push(a5), a5 = "", s4 = "after descriptor");
                        else {
                            if ("," === l5) return (D5 += 1, a5 && i6.push(a5), void C4());
                            if ("(" === l5) a5 += l5, s4 = "in parens";
                            else {
                                if ("" === l5) return (a5 && i6.push(a5), void C4());
                                a5 += l5;
                            }
                        }
                    } else if ("in parens" === s4) {
                        if (")" === l5) a5 += l5, s4 = "in descriptor";
                        else {
                            if ("" === l5) return (i6.push(a5), void C4());
                            a5 += l5;
                        }
                    } else if ("after descriptor" === s4) {
                        if (r6(l5)) ;
                        else {
                            if ("" === l5) return void C4();
                            s4 = "in descriptor", D5 -= 1;
                        }
                    }
                    D5 += 1;
                }
            }
            function C4() {
                var t13, r7, o6, a6, s5, l6, c7, p7, d7, f6 = !1, h6 = {
                };
                for(a6 = 0; a6 < i6.length; a6++)l6 = (s5 = i6[a6])[s5.length - 1], c7 = s5.substring(0, s5.length - 1), p7 = parseInt(c7, 10), d7 = parseFloat(c7), m5.test(c7) && "w" === l6 ? ((t13 || r7) && (f6 = !0), 0 === p7 ? f6 = !0 : t13 = p7) : g6.test(c7) && "x" === l6 ? ((t13 || r7 || o6) && (f6 = !0), d7 < 0 ? f6 = !0 : r7 = d7) : m5.test(c7) && "h" === l6 ? ((o6 || r7) && (f6 = !0), 0 === p7 ? f6 = !0 : o6 = p7) : f6 = !0;
                f6 ? n8 && n8.error && n8.error("Invalid srcset descriptor found in '" + e19 + "' at '" + s5 + "'.") : (h6.url = u4, t13 && (h6.w = t13), r7 && (h6.d = r7), o6 && (h6.h = o6), y6.push(h6));
            }
        };
    });
});
const { builders: { concat: rw , ifBreak: ow , join: uw , line: iw  }  } = rn1;
var aw = {
    printImgSrcset: function(e18) {
        const t12 = nw(e18, {
            logger: {
                error (e) {
                    throw new Error(e);
                }
            }
        }), n8 = t12.some(({ w: e19  })=>e19
        ), r6 = t12.some(({ h: e19  })=>e19
        );
        if (n8 + r6 + t12.some(({ d: e19  })=>e19
        ) > 1) throw new Error("Mixed descriptor in srcset is not supported");
        const o5 = n8 ? "w" : r6 ? "h" : "d", u4 = n8 ? "w" : r6 ? "h" : "x", i6 = (e19)=>Math.max(...e19)
        , a5 = t12.map((e19)=>e19.url
        ), s4 = i6(a5.map((e19)=>e19.length
        )), l5 = t12.map((e19)=>e19[o5]
        ).map((e19)=>e19 ? e19.toString() : ""
        ), c6 = l5.map((e19)=>{
            const t13 = e19.indexOf(".");
            return -1 === t13 ? e19.length : t13;
        }), p6 = i6(c6);
        return uw(rw([
            ",",
            iw
        ]), a5.map((e19, t13)=>{
            const n9 = [
                e19
            ], r7 = l5[t13];
            if (r7) {
                const o6 = s4 - e19.length + 1, i7 = p6 - c6[t13], a6 = " ".repeat(o6 + i7);
                n9.push(ow(a6, " "), r7 + u4);
            }
            return rw(n9);
        }));
    },
    printClassNames: function(e18) {
        return e18.trim().split(/\s+/).join(" ");
    }
};
const { builders: sw , utils: { mapDoc: lw , normalizeParts: cw  }  } = rn1, { replaceEndOfLineWith: pw  } = Nt1, { print: dw  } = XC, { breakParent: fw , dedentToRoot: hw , fill: mw , group: gw , hardline: Dw , ifBreak: yw , indent: Ew , join: Cw , line: bw , literalline: vw , softline: Aw  } = sw, { htmlTrimPreserveIndentation: Fw , splitByHtmlWhitespace: xw , countChars: Sw , countParents: ww , dedentString: Tw , forceBreakChildren: Bw , forceBreakContent: Nw , forceNextEmptyLine: kw , getLastDescendant: Pw , getPrettierIgnoreAttributeCommentData: Ow , hasPrettierIgnore: Iw , inferScriptParser: Lw , isVueCustomBlock: Mw , isVueNonHtmlBlock: jw , isVueSlotAttribute: _w , isVueSfcBindingsAttribute: Rw , isScriptLikeTag: Vw , isTextLikeNode: $w , preferHardlineAsLeadingSpaces: qw , shouldNotPrintClosingTag: Ww , shouldPreserveContent: Uw , unescapeQuoteEntities: Jw , isPreLikeNode: zw  } = PS, { insertPragma: Gw  } = KS, { locStart: Hw , locEnd: Xw  } = QS, { printVueFor: Yw , printVueBindings: Kw , isVueEventBindingExpression: Qw  } = tw, { printImgSrcset: Zw , printClassNames: eT  } = aw;
function tT(e18) {
    const t12 = cw(e18);
    return 0 === t12.length ? "" : 1 === t12.length ? t12[0] : sw.concat(t12);
}
function nT(e18, t12, n8) {
    const r6 = e18.getValue();
    if (Bw(r6)) return tT([
        fw,
        tT(e18.map((e19)=>{
            const t13 = e19.getValue(), n9 = t13.prev ? i6(t13.prev, t13) : "";
            return tT([
                n9 ? tT([
                    n9,
                    kw(t13.prev) ? Dw : ""
                ]) : "",
                u4(e19)
            ]);
        }, "children"))
    ]);
    const o5 = r6.children.map(()=>Symbol("")
    );
    return tT(e18.map((e19, t13)=>{
        const n9 = e19.getValue();
        if ($w(n9)) {
            if (n9.prev && $w(n9.prev)) {
                const t14 = i6(n9.prev, n9);
                if (t14) return kw(n9.prev) ? tT([
                    Dw,
                    Dw,
                    u4(e19)
                ]) : tT([
                    t14,
                    u4(e19)
                ]);
            }
            return u4(e19);
        }
        const r7 = [], a5 = [], s4 = [], l5 = [], c6 = n9.prev ? i6(n9.prev, n9) : "", p6 = n9.next ? i6(n9, n9.next) : "";
        return c6 && (kw(n9.prev) ? r7.push(Dw, Dw) : c6 === Dw ? r7.push(Dw) : $w(n9.prev) ? a5.push(c6) : a5.push(yw("", Aw, {
            groupId: o5[t13 - 1]
        }))), p6 && (kw(n9) ? $w(n9.next) && l5.push(Dw, Dw) : p6 === Dw ? $w(n9.next) && l5.push(Dw) : s4.push(p6)), tT([].concat(r7, gw(tT([
            tT(a5),
            gw(tT([
                u4(e19),
                tT(s4)
            ]), {
                id: o5[t13]
            })
        ])), l5));
    }, "children"));
    function u4(e19) {
        const r7 = e19.getValue();
        return Iw(r7) ? tT([].concat(gT(r7, t12), pw(t12.originalText.slice(Hw(r7) + (r7.prev && pT(r7.prev) ? ET(r7).length : 0), Xw(r7) - (r7.next && fT(r7.next) ? vT(r7, t12).length : 0)), vw), yT(r7, t12))) : n8(e19);
    }
    function i6(e19, t13) {
        return $w(e19) && $w(t13) ? e19.isTrailingSpaceSensitive ? e19.hasTrailingSpaces ? qw(t13) ? Dw : bw : "" : qw(t13) ? Dw : Aw : pT(e19) && (Iw(t13) || t13.firstChild || t13.isSelfClosing || "element" === t13.type && 0 !== t13.attrs.length) || "element" === e19.type && e19.isSelfClosing && fT(t13) ? "" : !t13.isLeadingSpaceSensitive || qw(t13) || fT(t13) && e19.lastChild && mT(e19.lastChild) && e19.lastChild.lastChild && mT(e19.lastChild.lastChild) ? Dw : t13.hasLeadingSpaces ? bw : Aw;
    }
}
function rT(e18, t12) {
    let n8 = e18.startSourceSpan.end.offset;
    e18.firstChild && dT(e18.firstChild) && (n8 -= CT(e18).length);
    let r6 = e18.endSourceSpan.start.offset;
    return e18.lastChild && mT(e18.lastChild) ? r6 += bT(e18, t12).length : hT(e18) && (r6 -= vT(e18.lastChild, t12).length), t12.originalText.slice(n8, r6);
}
function oT(e18, t12, n8) {
    const r6 = e18.getValue();
    if (!r6.attrs || 0 === r6.attrs.length) return r6.isSelfClosing ? " " : "";
    const o5 = r6.prev && "comment" === r6.prev.type && Ow(r6.prev.value), u4 = "boolean" == typeof o5 ? ()=>o5
     : Array.isArray(o5) ? (e19)=>o5.includes(e19.rawName)
     : ()=>!1
    , i6 = e18.map((e19)=>{
        const r7 = e19.getValue();
        return u4(r7) ? tT(pw(t12.originalText.slice(Hw(r7), Xw(r7)), vw)) : n8(e19);
    }, "attrs"), a5 = "element" === r6.type && "script" === r6.fullName && 1 === r6.attrs.length && "src" === r6.attrs[0].fullName && 0 === r6.children.length, s4 = [
        Ew(tT([
            a5 ? " " : bw,
            Cw(bw, i6)
        ]))
    ];
    return r6.firstChild && dT(r6.firstChild) || r6.isSelfClosing && hT(r6.parent) || a5 ? s4.push(r6.isSelfClosing ? " " : "") : s4.push(r6.isSelfClosing ? bw : Aw), tT(s4);
}
function uT(e18, t12, n8) {
    const r6 = e18.getValue();
    return tT([
        iT(r6, t12),
        oT(e18, t12, n8),
        r6.isSelfClosing ? "" : aT(r6)
    ]);
}
function iT(e18, t12) {
    return e18.prev && pT(e18.prev) ? "" : tT([
        gT(e18, t12),
        ET(e18)
    ]);
}
function sT(e18, t12) {
    return tT([
        e18.isSelfClosing ? "" : lT(e18, t12),
        cT(e18, t12)
    ]);
}
function lT(e18, t12) {
    return e18.lastChild && mT(e18.lastChild) ? "" : tT([
        DT(e18, t12),
        bT(e18, t12)
    ]);
}
function cT(e18, t12) {
    return (e18.next ? fT(e18.next) : hT(e18.parent)) ? "" : tT([
        vT(e18, t12),
        yT(e18, t12)
    ]);
}
function pT(e18) {
    return e18.next && !$w(e18.next) && $w(e18) && e18.isTrailingSpaceSensitive && !e18.hasTrailingSpaces;
}
function fT(e18) {
    return e18.prev && "docType" !== e18.prev.type && !$w(e18.prev) && e18.isLeadingSpaceSensitive && !e18.hasLeadingSpaces;
}
function hT(e18) {
    return e18.lastChild && e18.lastChild.isTrailingSpaceSensitive && !e18.lastChild.hasTrailingSpaces && !$w(Pw(e18.lastChild)) && !zw(e18);
}
function mT(e18) {
    return !e18.next && !e18.hasTrailingSpaces && e18.isTrailingSpaceSensitive && $w(Pw(e18));
}
function gT(e18, t12) {
    return dT(e18) ? CT(e18.parent) : fT(e18) ? vT(e18.prev, t12) : "";
}
function DT(e18, t12) {
    return hT(e18) ? vT(e18.lastChild, t12) : "";
}
function yT(e18, t12) {
    return mT(e18) ? bT(e18.parent, t12) : pT(e18) ? ET(e18.next) : "";
}
function bT(e18, t12) {
    if (Xi(!e18.isSelfClosing), Ww(e18, t12)) return "";
    switch(e18.type){
        case "ieConditionalComment":
            return "<!";
        case "element":
            if (e18.hasHtmComponentClosingTag) return "<//";
        default:
            return "</".concat(e18.rawName);
    }
}
function vT(e18, t12) {
    if (Ww(e18, t12)) return "";
    switch(e18.type){
        case "ieConditionalComment":
        case "ieConditionalEndComment":
            return "[endif]--\x3e";
        case "ieConditionalStartComment":
            return "]>\x3c!--\x3e";
        case "interpolation":
            return "}}";
        case "element":
            if (e18.isSelfClosing) return "/>";
        default:
            return ">";
    }
}
function AT(e18, t12 = e18.value) {
    return e18.parent.isWhitespaceSensitive ? e18.parent.isIndentationSensitive ? pw(t12, vw) : pw(Tw(Fw(t12)), Dw) : Cw(bw, xw(t12)).parts;
}
var FT = {
    preprocess: YS,
    print: function(e18, t12, n8) {
        const r6 = e18.getValue();
        switch(r6.type){
            case "front-matter":
                return tT(pw(r6.raw, vw));
            case "root":
                return (t12.__onHtmlRoot && t12.__onHtmlRoot(r6), sw.concat([
                    gw(nT(e18, t12, n8)),
                    Dw
                ]));
            case "element":
            case "ieConditionalComment":
                {
                    if (Uw(r6, t12)) return tT([].concat(gT(r6, t12), gw(uT(e18, t12, n8)), pw(rT(r6, t12), vw), sT(r6, t12), yT(r6, t12)));
                    const u4 = 1 === r6.children.length && "interpolation" === r6.firstChild.type && r6.firstChild.isLeadingSpaceSensitive && !r6.firstChild.hasLeadingSpaces && r6.lastChild.isTrailingSpaceSensitive && !r6.lastChild.hasTrailingSpaces, i6 = Symbol("element-attr-group-id");
                    return tT([
                        gw(tT([
                            gw(uT(e18, t12, n8), {
                                id: i6
                            }),
                            0 === r6.children.length ? r6.hasDanglingSpaces && r6.isDanglingSpaceSensitive ? bw : "" : tT([
                                Nw(r6) ? fw : "",
                                (o5 = tT([
                                    u4 ? yw(Aw, "", {
                                        groupId: i6
                                    }) : r6.firstChild.hasLeadingSpaces && r6.firstChild.isLeadingSpaceSensitive ? bw : "text" === r6.firstChild.type && r6.isWhitespaceSensitive && r6.isIndentationSensitive ? hw(Aw) : Aw,
                                    nT(e18, t12, n8)
                                ]), u4 ? yw(Ew(o5), o5, {
                                    groupId: i6
                                }) : !Vw(r6) && !Mw(r6, t12) || "root" !== r6.parent.type || "vue" !== t12.parser || t12.vueIndentScriptAndStyle ? Ew(o5) : o5),
                                (r6.next ? fT(r6.next) : hT(r6.parent)) ? r6.lastChild.hasTrailingSpaces && r6.lastChild.isTrailingSpaceSensitive ? " " : "" : u4 ? yw(Aw, "", {
                                    groupId: i6
                                }) : r6.lastChild.hasTrailingSpaces && r6.lastChild.isTrailingSpaceSensitive ? bw : ("comment" === r6.lastChild.type || "text" === r6.lastChild.type && r6.isWhitespaceSensitive && r6.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t12.tabWidth * ww(e18, (e19)=>e19.parent && "root" !== e19.parent.type
                                ), "}$")).test(r6.lastChild.value) ? "" : Aw
                            ])
                        ])),
                        sT(r6, t12)
                    ]);
                }
            case "ieConditionalStartComment":
            case "ieConditionalEndComment":
                return tT([
                    iT(r6),
                    cT(r6)
                ]);
            case "interpolation":
                return tT([
                    iT(r6, t12),
                    tT(e18.map(n8, "children")),
                    cT(r6, t12)
                ]);
            case "text":
                if ("interpolation" === r6.parent.type) {
                    const e19 = /\n[^\S\n]*?$/, t13 = e19.test(r6.value), n9 = t13 ? r6.value.replace(e19, "") : r6.value;
                    return tT([
                        tT(pw(n9, vw)),
                        t13 ? Dw : ""
                    ]);
                }
                return mw(cw([].concat(gT(r6, t12), AT(r6), yT(r6, t12))));
            case "docType":
                return tT([
                    gw(tT([
                        iT(r6, t12),
                        " ",
                        r6.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")
                    ])),
                    cT(r6, t12)
                ]);
            case "comment":
                return tT([
                    gT(r6, t12),
                    tT(pw(t12.originalText.slice(Hw(r6), Xw(r6)), vw)),
                    yT(r6, t12)
                ]);
            case "attribute":
                {
                    if (null === r6.value) return r6.rawName;
                    const e19 = Jw(r6.value), t13 = Sw(e19, "'") < Sw(e19, '"') ? "'" : '"';
                    return tT([
                        r6.rawName,
                        tT([
                            "=",
                            t13,
                            tT(pw('"' === t13 ? e19.replace(/"/g, "&quot;") : e19.replace(/'/g, "&apos;"), vw)),
                            t13
                        ])
                    ]);
                }
            default:
                throw new Error("Unexpected node type ".concat(r6.type));
        }
        var o5;
    },
    insertPragma: Gw,
    massageAstNode: Zx,
    embed: function(e18, t12, n8, r6) {
        const o5 = e18.getValue();
        switch(o5.type){
            case "element":
                if (Vw(o5) || "interpolation" === o5.type) return;
                if (!o5.isSelfClosing && jw(o5, r6)) {
                    const u4 = Lw(o5, r6);
                    if (!u4) return;
                    const i6 = rT(o5, r6);
                    let a5 = /^\s*$/.test(i6), s4 = "";
                    return (a5 || (s4 = n8(Fw(i6), {
                        parser: u4
                    }, {
                        stripTrailingHardline: !0
                    }), a5 = "" === s4), tT([
                        gT(o5, r6),
                        gw(uT(e18, r6, t12)),
                        a5 ? "" : Dw,
                        s4,
                        a5 ? "" : Dw,
                        sT(o5, r6),
                        yT(o5, r6)
                    ]));
                }
                break;
            case "text":
                if (Vw(o5.parent)) {
                    const e19 = Lw(o5.parent);
                    if (e19) {
                        const t13 = "markdown" === e19 ? Tw(o5.value.replace(/^[^\S\n]*?\n/, "")) : o5.value, u4 = {
                            parser: e19
                        };
                        if ("html" === r6.parser && "babel" === e19) {
                            let e20 = "script";
                            const { attrMap: t14  } = o5.parent;
                            t14 && ("module" === t14.type || "text/babel" === t14.type && "module" === t14["data-type"]) && (e20 = "module"), u4.__babelSourceType = e20;
                        }
                        return sw.concat([
                            tT([
                                fw,
                                gT(o5, r6),
                                n8(t13, u4, {
                                    stripTrailingHardline: !0
                                }),
                                yT(o5, r6)
                            ])
                        ]);
                    }
                } else if ("interpolation" === o5.parent.type) return tT([
                    Ew(tT([
                        bw,
                        n8(o5.value, Object.assign({
                            __isInHtmlInterpolation: !0
                        }, "angular" === r6.parser ? {
                            parser: "__ng_interpolation",
                            trailingComma: "none"
                        } : "vue" === r6.parser ? {
                            parser: "__vue_expression"
                        } : {
                            parser: "__js_expression"
                        }), {
                            stripTrailingHardline: !0
                        })
                    ])),
                    o5.parent.next && fT(o5.parent.next) ? " " : bw
                ]);
                break;
            case "attribute":
                {
                    if (!o5.value) break;
                    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r6.originalText.slice(o5.valueSpan.start.offset, o5.valueSpan.end.offset))) return tT([
                        o5.rawName,
                        "=",
                        o5.value
                    ]);
                    if ("lwc" === r6.parser) {
                        if (/^{[\S\s]*}$/.test(r6.originalText.slice(o5.valueSpan.start.offset, o5.valueSpan.end.offset))) return tT([
                            o5.rawName,
                            "=",
                            o5.value
                        ]);
                    }
                    const e19 = function(e20, t13, n9) {
                        const r7 = (t14)=>new RegExp(t14.join("|")).test(e20.fullName)
                        , o6 = ()=>Jw(e20.value)
                        ;
                        let u4 = !1;
                        const i6 = (e21, t14)=>{
                            const n10 = "NGRoot" === e21.type ? "NGMicrosyntax" === e21.node.type && 1 === e21.node.body.length && "NGMicrosyntaxExpression" === e21.node.body[0].type ? e21.node.body[0].expression : e21.node : "JsExpressionRoot" === e21.type ? e21.node : e21;
                            !n10 || "ObjectExpression" !== n10.type && "ArrayExpression" !== n10.type && ("__vue_expression" !== t14.parser || "TemplateLiteral" !== n10.type && "StringLiteral" !== n10.type) || (u4 = !0);
                        }, a5 = (e21)=>gw(e21)
                        , s4 = (e21, t14 = !0)=>gw(tT([
                                Ew(tT([
                                    Aw,
                                    e21
                                ])),
                                t14 ? Aw : ""
                            ]))
                        , l5 = (e21)=>u4 ? a5(e21) : s4(e21)
                        , c6 = (e21, n10)=>t13(e21, Object.assign({
                                __onHtmlBindingRoot: i6
                            }, n10), {
                                stripTrailingHardline: !0
                            })
                        ;
                        if ("srcset" === e20.fullName && ("img" === e20.parent.fullName || "source" === e20.parent.fullName)) return s4(Zw(o6()));
                        if ("class" === e20.fullName && !n9.parentParser) {
                            const e21 = o6();
                            if (!e21.includes("{{")) return eT(e21);
                        }
                        if ("style" === e20.fullName && !n9.parentParser) {
                            const e21 = o6();
                            if (!e21.includes("{{")) return s4(c6(e21, {
                                parser: "css",
                                __isHTMLStyleAttribute: !0
                            }));
                        }
                        if ("vue" === n9.parser) {
                            if ("v-for" === e20.fullName) return Yw(o6(), c6);
                            if (_w(e20) || Rw(e20, n9)) return Kw(o6(), c6);
                            const t14 = [
                                "^:",
                                "^v-bind:"
                            ], u5 = [
                                "^v-"
                            ];
                            if (r7([
                                "^@",
                                "^v-on:"
                            ])) {
                                const e21 = o6();
                                return l5(c6(e21, {
                                    parser: Qw(e21) ? "__js_expression" : "__vue_event_binding"
                                }));
                            }
                            if (r7(t14)) return l5(c6(o6(), {
                                parser: "__vue_expression"
                            }));
                            if (r7(u5)) return l5(c6(o6(), {
                                parser: "__js_expression"
                            }));
                        }
                        if ("angular" === n9.parser) {
                            const t14 = (e21, t15)=>c6(e21, Object.assign({
                                }, t15, {
                                    trailingComma: "none"
                                }))
                            , n10 = [
                                "^\\*"
                            ], u5 = [
                                "^\\[.+\\]$",
                                "^bind(on)?-",
                                "^ng-(if|show|hide|class|style)$"
                            ], i7 = [
                                "^i18n(-.+)?$"
                            ];
                            if (r7([
                                "^\\(.+\\)$",
                                "^on-"
                            ])) return l5(t14(o6(), {
                                parser: "__ng_action"
                            }));
                            if (r7(u5)) return l5(t14(o6(), {
                                parser: "__ng_binding"
                            }));
                            if (r7(i7)) {
                                const t15 = o6().trim();
                                return s4(mw(AT(e20, t15)), !t15.includes("@@"));
                            }
                            if (r7(n10)) return l5(t14(o6(), {
                                parser: "__ng_directive"
                            }));
                            const a6 = /{{([\S\s]+?)}}/g, p6 = o6();
                            if (a6.test(p6)) {
                                const e21 = [];
                                return p6.split(a6).forEach((n11, r8)=>{
                                    if (r8 % 2 == 0) e21.push(tT(pw(n11, vw)));
                                    else try {
                                        e21.push(gw(tT([
                                            "{{",
                                            Ew(tT([
                                                bw,
                                                t14(n11, {
                                                    parser: "__ng_interpolation",
                                                    __isInHtmlInterpolation: !0
                                                })
                                            ])),
                                            bw,
                                            "}}"
                                        ])));
                                    } catch (t) {
                                        e21.push("{{", tT(pw(n11, vw)), "}}");
                                    }
                                }), gw(tT(e21));
                            }
                        }
                        return null;
                    }(o5, (e20, t13)=>n8(e20, Object.assign({
                            __isInHtmlAttribute: !0
                        }, t13), {
                            stripTrailingHardline: !0
                        })
                    , r6);
                    if (e19) return tT([
                        o5.rawName,
                        '="',
                        gw(lw(e19, (e20)=>"string" == typeof e20 ? e20.replace(/"/g, "&quot;") : e20
                        )),
                        '"'
                    ]);
                    break;
                }
            case "front-matter":
                return dw(o5, n8);
        }
    }
};
var TT = {
    languages: [
        xs1(ST, ()=>({
                name: "Angular",
                since: "1.15.0",
                parsers: [
                    "angular"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [
                    ".component.html"
                ],
                filenames: []
            })
        ),
        xs1(ST, (e18)=>({
                since: "1.15.0",
                parsers: [
                    "html"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: e18.extensions.concat([
                    ".mjml"
                ])
            })
        ),
        xs1(ST, ()=>({
                name: "Lightning Web Components",
                since: "1.17.0",
                parsers: [
                    "lwc"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [],
                filenames: []
            })
        ),
        xs1(wT, ()=>({
                since: "1.10.0",
                parsers: [
                    "vue"
                ],
                vscodeLanguageIds: [
                    "vue"
                ]
            })
        )
    ],
    printers: {
        html: FT
    },
    options: xT,
    parsers: {
        get html () {
            return {
            }.parsers.html;
        },
        get vue () {
            return {
            }.parsers.vue;
        },
        get angular () {
            return {
            }.parsers.angular;
        },
        get lwc () {
            return {
            }.parsers.lwc;
        }
    }
};
const { getLast: kT  } = Nt1;
var VT = {
    getLast: kT,
    getAncestorCount: function(e18, t12) {
        let n8 = 0;
        const r6 = e18.stack.length - 1;
        for(let o5 = 0; o5 < r6; o5++){
            const r7 = e18.stack[o5];
            PT(r7) && t12(r7) && n8++;
        }
        return n8;
    },
    isNode: PT,
    isEmptyNode: function(e18) {
        return !(e18.children && 0 !== e18.children.length || function(e19) {
            return IT(e19) || LT(e19) || MT(e19) || jT(e19) || _T(e19);
        }(e18));
    },
    mapNode: function e18(t12, n8, r6) {
        return n8("children" in t12 ? Object.assign({
        }, t12, {
            children: t12.children.map((r7)=>e18(r7, n8, t12)
            )
        }) : t12, r6);
    },
    defineShortcut: function(e19, t12, n8) {
        Object.defineProperty(e19, t12, {
            get: n8,
            enumerable: !1
        });
    },
    isNextLineEmpty: function(e19, t12) {
        let n8 = 0;
        const r6 = t12.length;
        for(let o5 = e19.position.end.offset - 1; o5 < r6; o5++){
            const e20 = t12[o5];
            if (("\n" === e20 && n8++, 1 === n8 && /\S/.test(e20))) return !1;
            if (2 === n8) return !0;
        }
        return !1;
    },
    isLastDescendantNode: function(e19) {
        switch(e19.getValue().type){
            case "tag":
            case "anchor":
            case "comment":
                return !1;
        }
        const t12 = e19.stack.length;
        for(let n8 = 1; n8 < t12; n8++){
            const t13 = e19.stack[n8], r6 = e19.stack[n8 - 1];
            if (Array.isArray(r6) && "number" == typeof t13 && t13 !== r6.length - 1) return !1;
        }
        return !0;
    },
    getBlockValueLineContents: function(e19, { parentIndent: t12 , isLastDescendant: n8 , options: r6  }) {
        const o5 = e19.position.start.line === e19.position.end.line ? "" : r6.originalText.slice(e19.position.start.offset, e19.position.end.offset).match(/^[^\n]*?\n([\S\s]*)$/)[1], u4 = null === e19.indent ? (i6 = o5.match(/^( *)\S/m)) ? i6[1].length : 1 / 0 : e19.indent - 1 + t12;
        var i6;
        const a5 = o5.split("\n").map((e20)=>e20.slice(u4)
        );
        return "preserve" === r6.proseWrap || "blockLiteral" === e19.type ? s4(a5.map((e20)=>0 === e20.length ? [] : [
                e20
            ]
        )) : s4(a5.map((e20)=>0 === e20.length ? [] : RT(e20)
        ).reduce((e20, t13, n9)=>0 === n9 || 0 === a5[n9 - 1].length || 0 === t13.length || /^\s/.test(t13[0]) || /^\s|\s$/.test(kT(e20)) ? e20.concat([
                t13
            ]) : e20.concat([
                e20.pop().concat(t13)
            ])
        , []).map((e20)=>e20.reduce((e21, t13)=>0 !== e21.length && /\s$/.test(kT(e21)) ? e21.concat(e21.pop() + " " + t13) : e21.concat(t13)
            , [])
        ).map((e20)=>"never" === r6.proseWrap ? [
                e20.join(" ")
            ] : e20
        ));
        function s4(t13) {
            if ("keep" === e19.chomping) return 0 === kT(t13).length ? t13.slice(0, -1) : t13;
            let r7 = 0;
            for(let e20 = t13.length - 1; e20 >= 0 && 0 === t13[e20].length; e20--)r7++;
            return 0 === r7 ? t13 : r7 >= 2 && !n8 ? t13.slice(0, -(r7 - 1)) : t13.slice(0, -r7);
        }
    },
    getFlowScalarLineContents: function(e19, t12, n8) {
        const r6 = t12.split("\n").map((e20, t13, n9)=>0 === t13 && t13 === n9.length - 1 ? e20 : 0 !== t13 && t13 !== n9.length - 1 ? e20.trim() : 0 === t13 ? e20.trimEnd() : e20.trimStart()
        );
        return "preserve" === n8.proseWrap ? r6.map((e20)=>0 === e20.length ? [] : [
                e20
            ]
        ) : r6.map((e20)=>0 === e20.length ? [] : RT(e20)
        ).reduce((t13, n9, o5)=>0 === o5 || 0 === r6[o5 - 1].length || 0 === n9.length || "quoteDouble" === e19 && kT(kT(t13)).endsWith("\\") ? t13.concat([
                n9
            ]) : t13.concat([
                t13.pop().concat(n9)
            ])
        , []).map((e20)=>"never" === n8.proseWrap ? [
                e20.join(" ")
            ] : e20
        );
    },
    getLastDescendantNode: function e18(t12) {
        return "children" in t12 && 0 !== t12.children.length ? e18(kT(t12.children)) : t12;
    },
    hasPrettierIgnore: function(e19) {
        const t12 = e19.getValue();
        if ("documentBody" === t12.type) {
            const t13 = e19.getParentNode();
            return _T(t13.head) && OT(kT(t13.head.endComments));
        }
        return IT(t12) && OT(kT(t12.leadingComments));
    },
    hasLeadingComments: IT,
    hasMiddleComments: LT,
    hasIndicatorComment: MT,
    hasTrailingComment: jT,
    hasEndComments: _T
};
const $T = rn1.builders, { conditionalGroup: qT , breakParent: WT , concat: UT , dedent: JT , dedentToRoot: zT , fill: GT , group: HT , hardline: XT , ifBreak: YT , join: KT , line: QT , lineSuffix: ZT , literalline: eB , markAsRoot: tB , softline: nB  } = $T, { replaceEndOfLineWith: rB , isPreviousLineEmpty: oB  } = Nt1, { insertPragma: uB , isPragma: iB  } = BT, { locStart: aB  } = NT, { getAncestorCount: sB , getBlockValueLineContents: lB , getFlowScalarLineContents: cB , getLast: pB , getLastDescendantNode: dB , hasLeadingComments: fB , hasMiddleComments: hB , hasIndicatorComment: mB , hasTrailingComment: gB , hasEndComments: DB , hasPrettierIgnore: yB , isLastDescendantNode: EB , isNextLineEmpty: CB , isNode: bB , isEmptyNode: vB , defineShortcut: AB , mapNode: FB  } = VT;
function xB(e18) {
    switch(e18.type){
        case "document":
            AB(e18, "head", ()=>e18.children[0]
            ), AB(e18, "body", ()=>e18.children[1]
            );
            break;
        case "documentBody":
        case "sequenceItem":
        case "flowSequenceItem":
        case "mappingKey":
        case "mappingValue":
            AB(e18, "content", ()=>e18.children[0]
            );
            break;
        case "mappingItem":
        case "flowMappingItem":
            AB(e18, "key", ()=>e18.children[0]
            ), AB(e18, "value", ()=>e18.children[1]
            );
    }
    return e18;
}
function SB(e18, t12, n8, r6, o5) {
    switch(e18.type){
        case "root":
            return UT([
                KT(XT, n8.map((t13, r7)=>{
                    const u4 = e18.children[r7], i6 = e18.children[r7 + 1];
                    return UT([
                        o5(t13),
                        NB(u4, i6) ? UT([
                            XT,
                            "...",
                            gB(u4) ? UT([
                                " ",
                                n8.call(o5, "trailingComment")
                            ]) : ""
                        ]) : !i6 || gB(i6.head) ? "" : UT([
                            XT,
                            "---"
                        ])
                    ]);
                }, "children")),
                0 === e18.children.length || (i6 = dB(e18), bB(i6, [
                    "blockLiteral",
                    "blockFolded"
                ]) && "keep" === i6.chomping) ? "" : XT
            ]);
        case "document":
            {
                const u4 = t12.children[n8.getName() + 1];
                return KT(XT, [
                    "head" === kB(e18, u4, t12, r6) ? KT(XT, [
                        0 === e18.head.children.length && 0 === e18.head.endComments.length ? "" : n8.call(o5, "head"),
                        UT([
                            "---",
                            gB(e18.head) ? UT([
                                " ",
                                n8.call(o5, "head", "trailingComment")
                            ]) : ""
                        ])
                    ].filter(Boolean)) : "",
                    BB(e18) ? n8.call(o5, "body") : ""
                ].filter(Boolean));
            }
        case "documentHead":
            return KT(XT, [].concat(n8.map(o5, "children"), n8.map(o5, "endComments")));
        case "documentBody":
            {
                const t13 = KT(XT, n8.map(o5, "children")).parts, r7 = KT(XT, n8.map(o5, "endComments")).parts, u4 = 0 === t13.length || 0 === r7.length ? "" : ((e19)=>bB(e19, [
                        "blockFolded",
                        "blockLiteral"
                    ]) ? "keep" === e19.chomping ? "" : UT([
                        XT,
                        XT
                    ]) : XT
                )(dB(e18));
                return UT([].concat(t13, u4, r7));
            }
        case "directive":
            return UT([
                "%",
                KT(" ", [
                    e18.name
                ].concat(e18.parameters))
            ]);
        case "comment":
            return UT([
                "#",
                e18.value
            ]);
        case "alias":
            return UT([
                "*",
                e18.value
            ]);
        case "tag":
            return r6.originalText.slice(e18.position.start.offset, e18.position.end.offset);
        case "anchor":
            return UT([
                "&",
                e18.value
            ]);
        case "plain":
            return jB(e18.type, r6.originalText.slice(e18.position.start.offset, e18.position.end.offset), r6);
        case "quoteDouble":
        case "quoteSingle":
            {
                const t13 = "'", n9 = '"', o6 = r6.originalText.slice(e18.position.start.offset + 1, e18.position.end.offset - 1);
                if ("quoteSingle" === e18.type && o6.includes("\\") || "quoteDouble" === e18.type && /\\[^"]/.test(o6)) {
                    const u4 = "quoteDouble" === e18.type ? n9 : t13;
                    return UT([
                        u4,
                        jB(e18.type, o6, r6),
                        u4
                    ]);
                }
                if (o6.includes(n9)) return UT([
                    t13,
                    jB(e18.type, "quoteDouble" === e18.type ? o6.replace(/\\"/g, n9).replace(/'/g, t13.repeat(2)) : o6, r6),
                    t13
                ]);
                if (o6.includes(t13)) return UT([
                    n9,
                    jB(e18.type, "quoteSingle" === e18.type ? o6.replace(/''/g, t13) : o6, r6),
                    n9
                ]);
                const u4 = r6.singleQuote ? t13 : n9;
                return UT([
                    u4,
                    jB(e18.type, o6, r6),
                    u4
                ]);
            }
        case "blockFolded":
        case "blockLiteral":
            {
                const t13 = sB(n8, (e19)=>bB(e19, [
                        "sequence",
                        "mapping"
                    ])
                ), u4 = EB(n8);
                return UT([
                    "blockFolded" === e18.type ? ">" : "|",
                    null === e18.indent ? "" : e18.indent.toString(),
                    "clip" === e18.chomping ? "" : "keep" === e18.chomping ? "+" : "-",
                    mB(e18) ? UT([
                        " ",
                        n8.call(o5, "indicatorComment")
                    ]) : "",
                    (null === e18.indent ? JT : zT)(wB(null === e18.indent ? r6.tabWidth : e18.indent - 1 + t13, UT(lB(e18, {
                        parentIndent: t13,
                        isLastDescendant: u4,
                        options: r6
                    }).reduce((t14, n9, r7, o6)=>t14.concat(0 === r7 ? XT : "", GT(KT(QT, n9).parts), r7 !== o6.length - 1 ? 0 === n9.length ? XT : tB(eB) : "keep" === e18.chomping && u4 ? 0 === n9.length ? zT(XT) : zT(eB) : "")
                    , []))))
                ]);
            }
        case "sequence":
            return KT(XT, n8.map(o5, "children"));
        case "sequenceItem":
            return UT([
                "- ",
                wB(2, e18.content ? n8.call(o5, "content") : "")
            ]);
        case "mappingKey":
        case "mappingValue":
            return e18.content ? n8.call(o5, "content") : "";
        case "mapping":
            return KT(XT, n8.map(o5, "children"));
        case "mappingItem":
        case "flowMappingItem":
            {
                const u4 = vB(e18.key), i6 = vB(e18.value);
                if (u4 && i6) return UT([
                    ": "
                ]);
                const s4 = n8.call(o5, "key"), l5 = n8.call(o5, "value");
                if (i6) return "flowMappingItem" === e18.type && "flowMapping" === t12.type ? s4 : "mappingItem" !== e18.type || !PB(e18.key.content, r6) || gB(e18.key.content) || t12.tag && "tag:yaml.org,2002:set" === t12.tag.value ? UT([
                    "? ",
                    wB(2, s4)
                ]) : UT([
                    s4,
                    OB(e18) ? " " : "",
                    ":"
                ]);
                if (u4) return UT([
                    ": ",
                    wB(2, l5)
                ]);
                const c6 = Symbol("mappingKey");
                return fB(e18.value) || !TB(e18.key.content) ? UT([
                    "? ",
                    wB(2, s4),
                    XT,
                    KT("", n8.map(o5, "value", "leadingComments").map((e19)=>UT([
                            e19,
                            XT
                        ])
                    )),
                    ": ",
                    wB(2, l5)
                ]) : !(function(e19) {
                    if (!e19) return !0;
                    switch(e19.type){
                        case "plain":
                        case "quoteDouble":
                        case "quoteSingle":
                            return e19.position.start.line === e19.position.end.line;
                        case "alias":
                            return !0;
                        default:
                            return !1;
                    }
                })(e18.key.content) || fB(e18.key.content) || hB(e18.key.content) || gB(e18.key.content) || DB(e18.key) || fB(e18.value.content) || hB(e18.value.content) || DB(e18.value) || !PB(e18.value.content, r6) ? qT([
                    UT([
                        HT(UT([
                            YT("? "),
                            HT(wB(2, s4), {
                                id: c6
                            })
                        ])),
                        YT(UT([
                            XT,
                            ": ",
                            wB(2, l5)
                        ]), a5(UT([
                            OB(e18) ? " " : "",
                            ":",
                            fB(e18.value.content) || DB(e18.value) && e18.value.content && !bB(e18.value.content, [
                                "mapping",
                                "sequence"
                            ]) || "mapping" === t12.type && gB(e18.key.content) && TB(e18.value.content) || bB(e18.value.content, [
                                "mapping",
                                "sequence"
                            ]) && null === e18.value.content.tag && null === e18.value.content.anchor ? XT : e18.value.content ? QT : "",
                            l5
                        ])), {
                            groupId: c6
                        })
                    ])
                ]) : UT([
                    s4,
                    OB(e18) ? " " : "",
                    ": ",
                    l5
                ]);
            }
        case "flowMapping":
        case "flowSequence":
            {
                const t13 = "flowMapping" === e18.type ? "{" : "[", i6 = "flowMapping" === e18.type ? "}" : "]", s4 = "flowMapping" === e18.type && 0 !== e18.children.length && r6.bracketSpacing ? QT : nB, l5 = 0 !== e18.children.length && ("flowMappingItem" === (u4 = pB(e18.children)).type && vB(u4.key) && vB(u4.value)), c6 = "none" === r6.trailingComma ? "" : YT(",", "");
                return UT([
                    t13,
                    a5(UT([
                        s4,
                        UT(n8.map((t14, n9)=>UT([
                                o5(t14),
                                n9 === e18.children.length - 1 ? "" : UT([
                                    ",",
                                    QT,
                                    e18.children[n9].position.start.line !== e18.children[n9 + 1].position.start.line ? MB(t14, r6.originalText) : ""
                                ])
                            ])
                        , "children")),
                        c6,
                        DB(e18) ? UT([
                            XT,
                            KT(XT, n8.map(o5, "endComments"))
                        ]) : ""
                    ])),
                    l5 ? "" : s4,
                    i6
                ]);
            }
        case "flowSequenceItem":
            return n8.call(o5, "content");
        default:
            throw new Error("Unexpected node type ".concat(e18.type));
    }
    var u4, i6;
    function a5(e19) {
        return $T.align(" ".repeat(r6.tabWidth), e19);
    }
}
function wB(e18, t12) {
    return "number" == typeof e18 && e18 > 0 ? $T.align(" ".repeat(e18), t12) : $T.align(e18, t12);
}
function BB(e18) {
    return 0 !== e18.body.children.length || DB(e18.body);
}
function NB(e18, t12) {
    return gB(e18) || t12 && (0 !== t12.head.children.length || DB(t12.head));
}
function kB(e18, t12, n8, r6) {
    return n8.children[0] === e18 && /---(\s|$)/.test(r6.originalText.slice(aB(e18), aB(e18) + 4)) || 0 !== e18.head.children.length || DB(e18.head) || gB(e18.head) ? "head" : !NB(e18, t12) && (!!t12 && "root");
}
function IB(e18) {
    return DB(e18) && !bB(e18, [
        "documentHead",
        "documentBody",
        "flowMapping",
        "flowSequence"
    ]);
}
function MB(e18, t12) {
    const n8 = e18.getValue(), r6 = e18.stack[0];
    let o5;
    return LB.has(r6) ? o5 = LB.get(r6) : (o5 = new Set, LB.set(r6, o5)), o5.has(n8.position.end.line) || (o5.add(n8.position.end.line), !CB(n8, t12) || IB(e18.getParentNode())) ? "" : nB;
}
function jB(e18, t12, n8) {
    const r6 = cB(e18, t12, n8);
    return KT(XT, r6.map((e19)=>GT(KT(QT, e19).parts)
    ));
}
var _B = {
    preprocess: function(e18) {
        return FB(e18, xB);
    },
    print: function(e18, t12, n8) {
        const r6 = e18.getValue(), o5 = e18.getParentNode(), u4 = r6.tag ? e18.call(n8, "tag") : "", i6 = r6.anchor ? e18.call(n8, "anchor") : "", a5 = bB(r6, [
            "mapping",
            "sequence",
            "comment",
            "directive",
            "mappingItem",
            "sequenceItem"
        ]) && !EB(e18) ? MB(e18, t12.originalText) : "";
        return UT([
            "mappingValue" !== r6.type && fB(r6) ? UT([
                KT(XT, e18.map(n8, "leadingComments")),
                XT
            ]) : "",
            u4,
            u4 && i6 ? " " : "",
            i6,
            u4 || i6 ? bB(r6, [
                "sequence",
                "mapping"
            ]) && !hB(r6) ? XT : " " : "",
            hB(r6) ? UT([
                1 === r6.middleComments.length ? "" : XT,
                KT(XT, e18.map(n8, "middleComments")),
                XT
            ]) : "",
            yB(e18) ? UT(rB(t12.originalText.slice(r6.position.start.offset, r6.position.end.offset).trimEnd(), eB)) : HT(SB(r6, o5, e18, t12, n8)),
            gB(r6) && !bB(r6, [
                "document",
                "documentHead"
            ]) ? ZT(UT([
                "mappingValue" !== r6.type || r6.content ? " " : "",
                "mappingKey" === o5.type && "mapping" === e18.getParentNode(2).type && TB(r6) ? "" : WT,
                e18.call(n8, "trailingComment")
            ])) : "",
            IB(r6) ? wB("sequenceItem" === r6.type ? 2 : 0, UT([
                XT,
                KT(XT, e18.map((e19)=>UT([
                        oB(t12.originalText, e19.getValue(), aB) ? XT : "",
                        n8(e19)
                    ])
                , "endComments"))
            ])) : "",
            a5
        ]);
    },
    massageAstNode: function(e18, t12) {
        if (bB(t12)) switch((delete t12.position, t12.type)){
            case "comment":
                if (iB(t12.value)) return null;
                break;
            case "quoteDouble":
            case "quoteSingle":
                t12.type = "quote";
        }
    },
    insertPragma: uB
}, RB = {
    bracketSpacing: kC.bracketSpacing,
    singleQuote: kC.singleQuote,
    proseWrap: kC.proseWrap
};
var VB = [
    VC,
    Uv,
    YA,
    DF,
    Xx,
    TT,
    {
        languages: [
            xs1({
                name: "YAML",
                type: "data",
                color: "#cb171e",
                tmScope: "source.yaml",
                aliases: [
                    "yml"
                ],
                extensions: [
                    ".yml",
                    ".mir",
                    ".reek",
                    ".rviz",
                    ".sublime-syntax",
                    ".syntax",
                    ".yaml",
                    ".yaml-tmlanguage",
                    ".yaml.sed",
                    ".yml.mysql"
                ],
                filenames: [
                    ".clang-format",
                    ".clang-tidy",
                    ".gemrc",
                    "glide.lock",
                    "yarn.lock"
                ],
                aceMode: "yaml",
                codemirrorMode: "yaml",
                codemirrorMimeType: "text/x-yaml",
                languageId: 407
            }, (e18)=>({
                    since: "1.14.0",
                    parsers: [
                        "yaml"
                    ],
                    vscodeLanguageIds: [
                        "yaml",
                        "ansible",
                        "home-assistant"
                    ],
                    filenames: e18.filenames.filter((e19)=>"yarn.lock" !== e19
                    )
                })
            )
        ],
        printers: {
            yaml: _B
        },
        options: RB,
        parsers: {
            get yaml () {
                return ({
                }).parsers.yaml;
            }
        }
    }
];
const { version: $B  } = n1, { getSupportInfo: qB  } = pt1, WB = VB.map((t12)=>e1(t12, [
        "parsers"
    ])
);
function UB(e18, t12 = 1) {
    return (...n8)=>{
        const r6 = n8[t12] || {
        }, o5 = r6.plugins || [];
        return n8[t12] = Object.assign({
        }, r6, {
            plugins: [
                ...WB,
                ...Array.isArray(o5) ? o5 : Object.values(o5)
            ]
        }), e18(...n8);
    };
}
const JB = UB(es.formatWithCursor);
var zB = {
    formatWithCursor: JB,
    format: (e18, t12)=>JB(e18, t12).formatted
    ,
    check (e, t) {
        const { formatted: n8  } = JB(e, t);
        return n8 === e;
    },
    doc: rn1,
    getSupportInfo: UB(qB, 0),
    version: $B,
    util: Fs,
    __debug: {
        parse: UB(es.parse),
        formatAST: UB(es.formatAST),
        formatDoc: UB(es.formatDoc),
        printToDoc: UB(es.printToDoc),
        printDocToString: UB(es.printDocToString)
    }
};
function C4() {
    E1 && f1 && (E1 = !1, f1.length ? y1 = f1.concat(y1) : A1 = -1, y1.length && x5());
}
function x5() {
    if (!E1) {
        var t12 = m1(C4);
        E1 = !0;
        for(var e18 = y1.length; e18;){
            for(f1 = y1, y1 = []; (++A1) < e18;)f1 && f1[A1].run();
            A1 = -1, e18 = y1.length;
        }
        f1 = null, E1 = !1, (function(t13) {
            if (D1 === clearTimeout) return clearTimeout(t13);
            if ((D1 === l2 || !D1) && clearTimeout) return D1 = clearTimeout, clearTimeout(t13);
            try {
                D1(t13);
            } catch (e) {
                try {
                    return D1.call(null, t13);
                } catch (e) {
                    return D1.call(this, t13);
                }
            }
        })(t12);
    }
}
var L2 = {
    nextTick: function(t12) {
        var e18 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var s4 = 1; s4 < arguments.length; s4++)e18[s4 - 1] = arguments[s4];
        y1.push(new F1(t12, e18)), 1 !== y1.length || E1 || m1(x5);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: b1,
    addListener: P1,
    once: T1,
    off: w1,
    removeListener: B,
    removeAllListeners: S,
    emit: N1,
    binding: function(t12) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(t12) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(t12) {
        var e18 = 0.001 * v1.call(I3), s4 = Math.floor(e18), r6 = Math.floor(e18 % 1 * 1000000000);
        return (t12 && (s4 -= t12[0], (r6 -= t12[1]) < 0 && (s4--, r6 += 1000000000)), [
            s4,
            r6
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - k1) / 1000;
    }
};
var O3 = "object" == typeof L2 && L2.env && L2.env.NODE_DEBUG && /\bsemver\b/i.test(L2.env.NODE_DEBUG) ? (...t12)=>console.error("SEMVER", ...t12)
 : ()=>{
};
var j4 = R1(function(t12, e18) {
    const { MAX_SAFE_COMPONENT_LENGTH: s4  } = M3, r6 = (e18 = t12.exports = {
    }).re = [], i6 = e18.src = [], n8 = e18.t = {
    };
    let a5 = 0;
    const o5 = (t13, e19, s5)=>{
        const o6 = a5++;
        O3(o6, e19), n8[t13] = o6, i6[o6] = e19, r6[o6] = new RegExp(e19, s5 ? "g" : void 0);
    };
    o5("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o5("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o5("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o5("MAINVERSION", "(".concat(i6[n8.NUMERICIDENTIFIER], ")\\.") + "(".concat(i6[n8.NUMERICIDENTIFIER], ")\\.") + "(".concat(i6[n8.NUMERICIDENTIFIER], ")")), o5("MAINVERSIONLOOSE", "(".concat(i6[n8.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i6[n8.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i6[n8.NUMERICIDENTIFIERLOOSE], ")")), o5("PRERELEASEIDENTIFIER", "(?:".concat(i6[n8.NUMERICIDENTIFIER], "|").concat(i6[n8.NONNUMERICIDENTIFIER], ")")), o5("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i6[n8.NUMERICIDENTIFIERLOOSE], "|").concat(i6[n8.NONNUMERICIDENTIFIER], ")")), o5("PRERELEASE", "(?:-(".concat(i6[n8.PRERELEASEIDENTIFIER], "(?:\\.").concat(i6[n8.PRERELEASEIDENTIFIER], ")*))")), o5("PRERELEASELOOSE", "(?:-?(".concat(i6[n8.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i6[n8.PRERELEASEIDENTIFIERLOOSE], ")*))")), o5("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o5("BUILD", "(?:\\+(".concat(i6[n8.BUILDIDENTIFIER], "(?:\\.").concat(i6[n8.BUILDIDENTIFIER], ")*))")), o5("FULLPLAIN", "v?".concat(i6[n8.MAINVERSION]).concat(i6[n8.PRERELEASE], "?").concat(i6[n8.BUILD], "?")), o5("FULL", "^".concat(i6[n8.FULLPLAIN], "$")), o5("LOOSEPLAIN", "[v=\\s]*".concat(i6[n8.MAINVERSIONLOOSE]).concat(i6[n8.PRERELEASELOOSE], "?").concat(i6[n8.BUILD], "?")), o5("LOOSE", "^".concat(i6[n8.LOOSEPLAIN], "$")), o5("GTLT", "((?:<|>)?=?)"), o5("XRANGEIDENTIFIERLOOSE", "".concat(i6[n8.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o5("XRANGEIDENTIFIER", "".concat(i6[n8.NUMERICIDENTIFIER], "|x|X|\\*")), o5("XRANGEPLAIN", "[v=\\s]*(".concat(i6[n8.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i6[n8.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i6[n8.XRANGEIDENTIFIER], ")") + "(?:".concat(i6[n8.PRERELEASE], ")?").concat(i6[n8.BUILD], "?") + ")?)?"), o5("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i6[n8.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i6[n8.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i6[n8.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i6[n8.PRERELEASELOOSE], ")?").concat(i6[n8.BUILD], "?") + ")?)?"), o5("XRANGE", "^".concat(i6[n8.GTLT], "\\s*").concat(i6[n8.XRANGEPLAIN], "$")), o5("XRANGELOOSE", "^".concat(i6[n8.GTLT], "\\s*").concat(i6[n8.XRANGEPLAINLOOSE], "$")), o5("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(s4, "})") + "(?:\\.(\\d{1,".concat(s4, "}))?") + "(?:\\.(\\d{1,".concat(s4, "}))?") + "(?:$|[^\\d])"), o5("COERCERTL", i6[n8.COERCE], !0), o5("LONETILDE", "(?:~>?)"), o5("TILDETRIM", "(\\s*)".concat(i6[n8.LONETILDE], "\\s+"), !0), e18.tildeTrimReplace = "$1~", o5("TILDE", "^".concat(i6[n8.LONETILDE]).concat(i6[n8.XRANGEPLAIN], "$")), o5("TILDELOOSE", "^".concat(i6[n8.LONETILDE]).concat(i6[n8.XRANGEPLAINLOOSE], "$")), o5("LONECARET", "(?:\\^)"), o5("CARETTRIM", "(\\s*)".concat(i6[n8.LONECARET], "\\s+"), !0), e18.caretTrimReplace = "$1^", o5("CARET", "^".concat(i6[n8.LONECARET]).concat(i6[n8.XRANGEPLAIN], "$")), o5("CARETLOOSE", "^".concat(i6[n8.LONECARET]).concat(i6[n8.XRANGEPLAINLOOSE], "$")), o5("COMPARATORLOOSE", "^".concat(i6[n8.GTLT], "\\s*(").concat(i6[n8.LOOSEPLAIN], ")$|^$")), o5("COMPARATOR", "^".concat(i6[n8.GTLT], "\\s*(").concat(i6[n8.FULLPLAIN], ")$|^$")), o5("COMPARATORTRIM", "(\\s*)".concat(i6[n8.GTLT], "\\s*(").concat(i6[n8.LOOSEPLAIN], "|").concat(i6[n8.XRANGEPLAIN], ")"), !0), e18.comparatorTrimReplace = "$1$2$3", o5("HYPHENRANGE", "^\\s*(".concat(i6[n8.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i6[n8.XRANGEPLAIN], ")") + "\\s*$"), o5("HYPHENRANGELOOSE", "^\\s*(".concat(i6[n8.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i6[n8.XRANGEPLAINLOOSE], ")") + "\\s*$"), o5("STAR", "(<|>)?=?\\s*\\*"), o5("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o5("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: z4 , MAX_SAFE_INTEGER: H4  } = M3, { re: W2 , t: G3  } = j4, { compareIdentifiers: X3  } = V1;
class K3 {
    constructor(t12, e18){
        if (e18 && "object" == typeof e18 || (e18 = {
            loose: !!e18,
            includePrerelease: !1
        }), t12 instanceof K3) {
            if (t12.loose === !!e18.loose && t12.includePrerelease === !!e18.includePrerelease) return t12;
            t12 = t12.version;
        } else if ("string" != typeof t12) throw new TypeError("Invalid Version: ".concat(t12));
        if (t12.length > z4) throw new TypeError("version is longer than ".concat(z4, " characters"));
        O3("SemVer", t12, e18), this.options = e18, this.loose = !!e18.loose, this.includePrerelease = !!e18.includePrerelease;
        const s4 = t12.trim().match(e18.loose ? W2[G3.LOOSE] : W2[G3.FULL]);
        if (!s4) throw new TypeError("Invalid Version: ".concat(t12));
        if (this.raw = t12, this.major = +s4[1], this.minor = +s4[2], this.patch = +s4[3], this.major > H4 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > H4 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > H4 || this.patch < 0) throw new TypeError("Invalid patch version");
        s4[4] ? this.prerelease = s4[4].split(".").map((t13)=>{
            if (/^[0-9]+$/.test(t13)) {
                const e19 = +t13;
                if (e19 >= 0 && e19 < H4) return e19;
            }
            return t13;
        }) : this.prerelease = [], this.build = s4[5] ? s4[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(t) {
        if (O3("SemVer.compare", this.version, this.options, t), !(t instanceof K3)) {
            if ("string" == typeof t && t === this.version) return 0;
            t = new K3(t, this.options);
        }
        return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
    }
    compareMain(t) {
        return t instanceof K3 || (t = new K3(t, this.options)), X3(this.major, t.major) || X3(this.minor, t.minor) || X3(this.patch, t.patch);
    }
    comparePre(t) {
        if (t instanceof K3 || (t = new K3(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
        if (!this.prerelease.length && t.prerelease.length) return 1;
        if (!this.prerelease.length && !t.prerelease.length) return 0;
        let e19 = 0;
        do {
            const s5 = this.prerelease[e19], r6 = t.prerelease[e19];
            if (O3("prerelease compare", e19, s5, r6), (void 0) === s5 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === s5) return -1;
            if (s5 !== r6) return X3(s5, r6);
        }while (++e19)
    }
    compareBuild(t) {
        t instanceof K3 || (t = new K3(t, this.options));
        let e19 = 0;
        do {
            const s5 = this.build[e19], r6 = t.build[e19];
            if (O3("prerelease compare", e19, s5, r6), (void 0) === s5 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === s5) return -1;
            if (s5 !== r6) return X3(s5, r6);
        }while (++e19)
    }
    inc(t, e) {
        switch(t){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", e), this.inc("pre", e);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", e), this.inc("pre", e);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let t13 = this.prerelease.length;
                    for(; (--t13) >= 0;)"number" == typeof this.prerelease[t13] && (this.prerelease[t13]++, t13 = -2);
                    -1 === t13 && this.prerelease.push(0);
                }
                e && (this.prerelease[0] === e ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    e,
                    0
                ]) : this.prerelease = [
                    e,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(t));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var J2 = K3;
var $2 = (t13, e19, s5)=>new J2(t13, s5).compare(new J2(e19, s5))
;
var Y2 = (t13, e19, s5)=>$2(t13, e19, s5) < 0
;
var Q3 = (t13, e19, s5)=>$2(t13, e19, s5) >= 0
, Z4 = "2.2.1", tt1 = R1(function(t13, e19) {
    function s5() {
        for(var t14 = [], e20 = 0; e20 < arguments.length; e20++)t14[e20] = arguments[e20];
    }
    function r6() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: s5,
            delete: s5,
            get: s5,
            set: s5,
            has: function(t14) {
                return !1;
            }
        };
    }
    Object.defineProperty(e19, "__esModule", {
        value: !0
    });
    var i6 = Object.prototype.hasOwnProperty, n8 = function(t14, e20) {
        return i6.call(t14, e20);
    };
    function a5(t14, e20) {
        for(var s6 in e20)n8(e20, s6) && (t14[s6] = e20[s6]);
        return t14;
    }
    var o5 = /^[ \t]*(?:\r\n|\r|\n)/, u4 = /(?:\r\n|\r|\n)[ \t]*$/, h5 = /^(?:[\r\n]|$)/, c6 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p6 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function l5(t14, e20, s6) {
        var r7 = 0, i7 = t14[0].match(c6);
        i7 && (r7 = i7[1].length);
        var n9 = new RegExp("(\\r\\n|\\r|\\n).{0," + r7 + "}", "g");
        e20 && (t14 = t14.slice(1));
        var a6 = s6.newline, h6 = s6.trimLeadingNewline, p7 = s6.trimTrailingNewline, l5 = "string" == typeof a6, d6 = t14.length;
        return t14.map(function(t15, e21) {
            return (t15 = t15.replace(n9, "$1"), 0 === e21 && h6 && (t15 = t15.replace(o5, "")), e21 === d6 - 1 && p7 && (t15 = t15.replace(u4, "")), l5 && (t15 = t15.replace(/\r\n|\n|\r/g, function(t16) {
                return a6;
            })), t15);
        });
    }
    function d6(t14, e20) {
        for(var s6 = "", r7 = 0, i7 = t14.length; r7 < i7; r7++)s6 += t14[r7], r7 < i7 - 1 && (s6 += e20[r7]);
        return s6;
    }
    function D5(t14) {
        return n8(t14, "raw") && n8(t14, "length");
    }
    var m5 = function t13(e20) {
        var s6 = r6(), i7 = r6();
        return a5(function r7(n9) {
            for(var o6 = [], u5 = 1; u5 < arguments.length; u5++)o6[u5 - 1] = arguments[u5];
            if (D5(n9)) {
                var c7 = n9, f5 = (o6[0] === r7 || o6[0] === m5) && p6.test(c7[0]) && h5.test(c7[1]), y6 = f5 ? i7 : s6, E5 = y6.get(c7);
                if ((E5 || (E5 = l5(c7, f5, e20), y6.set(c7, E5)), 0 === o6.length)) return E5[0];
                var A5 = d6(E5, f5 ? o6.slice(1) : o6);
                return A5;
            }
            return t13(a5(a5({
            }, e20), n9 || {
            }));
        }, {
            string: function(t14) {
                return l5([
                    t14
                ], !1, e20)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    e19.outdent = m5, e19.default = m5;
    try {
        t13.exports = m5, Object.defineProperty(m5, "__esModule", {
            value: !0
        }), m5.default = m5, m5.outdent = m5;
    } catch (t) {
    }
});
const { outdent: ot2  } = tt1, ut2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: ot2(at()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: ot2(nt1())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (t13)=>"string" == typeof t13 || "function" == typeof t13
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (t13)=>"string" == typeof t13 || "object" == typeof t13
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: ot2(it()),
        exception: (t13)=>"string" == typeof t13 || "object" == typeof t13
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: ot2(rt1()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: ot2(st()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: ot2(et1()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const ht2 = {
    compare: $2,
    lt: Y2,
    gte: Q3
}, pt2 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: ut2
}.options;
var lt2 = {
    getSupportInfo: function({ plugins: t13 = [] , showUnreleased: e19 = !1 , showDeprecated: s5 = !1 , showInternal: r6 = !1  } = {
    }) {
        const i6 = Z4.split("-", 1)[0], n8 = t13.reduce((t14, e20)=>t14.concat(e20.languages || [])
        , []).filter(h5), a5 = (o5 = Object.assign({
        }, ...t13.map(({ options: t14  })=>t14
        ), pt2), u4 = "name", Object.entries(o5).map(([t14, e20])=>Object.assign({
                [u4]: t14
            }, e20)
        )).filter((t14)=>h5(t14) && c6(t14)
        ).sort((t14, e20)=>t14.name === e20.name ? 0 : t14.name < e20.name ? -1 : 1
        ).map(function(t14) {
            if (r6) return t14;
            return function(t15, e20) {
                if (null == t15) return {
                };
                var s6, r7, i7 = {
                }, n9 = Object.keys(t15);
                for(r7 = 0; r7 < n9.length; r7++)s6 = n9[r7], e20.indexOf(s6) >= 0 || (i7[s6] = t15[s6]);
                return i7;
            }(t14, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((e20)=>{
            e20 = Object.assign({
            }, e20), Array.isArray(e20.default) && (e20.default = 1 === e20.default.length ? e20.default[0].value : e20.default.filter(h5).sort((t14, e21)=>ht2.compare(e21.since, t14.since)
            )[0].value), Array.isArray(e20.choices) && (e20.choices = e20.choices.filter((t14)=>h5(t14) && c6(t14)
            ), "parser" === e20.name && (function(t14, e21, s6) {
                const r7 = new Set(t14.choices.map((t15)=>t15.value
                ));
                for (const i7 of e21)if (i7.parsers) for (const e22 of i7.parsers)if (!r7.has(e22)) {
                    r7.add(e22);
                    const n9 = s6.find((t15)=>t15.parsers && t15.parsers[e22]
                    );
                    let a6 = i7.name;
                    n9 && n9.name && (a6 += " (plugin: ".concat(n9.name, ")")), t14.choices.push({
                        value: e22,
                        description: a6
                    });
                }
            })(e20, n8, t13));
            const s6 = t13.filter((t14)=>t14.defaultOptions && (void 0) !== t14.defaultOptions[e20.name]
            ).reduce((t14, s7)=>(t14[s7.name] = s7.defaultOptions[e20.name], t14)
            , {
            });
            return Object.assign({
            }, e20, {
                pluginDefaults: s6
            });
        });
        var o5, u4;
        return {
            languages: n8,
            options: a5
        };
        function h5(t14) {
            return e19 || !("since" in t14) || t14.since && ht2.gte(i6, t14.since);
        }
        function c6(t14) {
            return s5 || !("deprecated" in t14) || t14.deprecated && ht2.lt(i6, t14.deprecated);
        }
    }
};
const { getSupportInfo: dt2  } = lt2, Dt2 = /[^\x20-\x7F]/;
var It2 = {
    inferParserByLanguage: function(t13, e19) {
        const { languages: s5  } = dt2({
            plugins: e19.plugins
        }), r6 = s5.find(({ name: e20  })=>e20.toLowerCase() === t13
        ) || s5.find(({ aliases: e20  })=>Array.isArray(e20) && e20.includes(t13)
        ) || s5.find(({ extensions: e20  })=>Array.isArray(e20) && e20.includes(".".concat(t13))
        );
        return r6 && r6.parsers[0];
    },
    replaceEndOfLineWith: function(t13, e19) {
        const s5 = [];
        for (const r6 of t13.split("\n"))0 !== s5.length && s5.push(e19), s5.push(r6);
        return s5;
    },
    getStringWidth: function(t13) {
        return t13 ? Dt2.test(t13) ? a2(t13) : t13.length : 0;
    },
    getMaxContinuousCount: function(t13, e19) {
        const s5 = t13.match(new RegExp("(".concat(u2(e19), ")+"), "g"));
        return null === s5 ? 0 : s5.reduce((t14, s6)=>Math.max(t14, s6.length / e19.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(t13, e19) {
        const s5 = t13.match(new RegExp("(".concat(u2(e19), ")+"), "g"));
        if (null === s5) return 0;
        const r6 = new Map;
        let i6 = 0;
        for (const t14 of s5){
            const s6 = t14.length / e19.length;
            r6.set(s6, !0), s6 > i6 && (i6 = s6);
        }
        for(let t15 = 1; t15 < i6; t15++)if (!r6.get(t15)) return t15;
        return i6 + 1;
    },
    getPenultimate: (t13)=>t13[t13.length - 2]
    ,
    getLast: (t13)=>t13[t13.length - 1]
    ,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Pt,
    getNextNonSpaceNonCommentCharacterIndex: Tt1,
    getNextNonSpaceNonCommentCharacter: function(t13, e19, s5) {
        return t13.charAt(Tt1(t13, e19, s5));
    },
    skip: mt1,
    skipWhitespace: ft,
    skipSpaces: yt1,
    skipToLineEnd: Et1,
    skipEverythingButNewLine: At1,
    skipInlineComment: Ct1,
    skipTrailingComment: xt1,
    skipNewline: Ft1,
    isNextLineEmptyAfterIndex: bt1,
    isNextLineEmpty: function(t13, e19, s5) {
        return bt1(t13, s5(e19));
    },
    isPreviousLineEmpty: function(t13, e19, s5) {
        let r6 = s5(e19) - 1;
        return (r6 = yt1(t13, r6, {
            backwards: !0
        }), r6 = Ft1(t13, r6, {
            backwards: !0
        }), r6 = yt1(t13, r6, {
            backwards: !0
        }), r6 !== Ft1(t13, r6, {
            backwards: !0
        }));
    },
    hasNewline: gt1,
    hasNewlineInRange: function(t13, e19, s5) {
        for(let r6 = e19; r6 < s5; ++r6)if ("\n" === t13.charAt(r6)) return !0;
        return !1;
    },
    hasSpaces: function(t13, e19, s5) {
        return yt1(t13, (s5 = s5 || {
        }).backwards ? e19 - 1 : e19, s5) !== e19;
    },
    getAlignmentSize: wt1,
    getIndentSize: function(t13, e19) {
        const s5 = t13.lastIndexOf("\n");
        return -1 === s5 ? 0 : wt1(t13.slice(s5 + 1).match(/^[\t ]*/)[0], e19);
    },
    getPreferredQuote: Bt1,
    printString: function(t13, e19, s5) {
        const r6 = t13.slice(1, -1), i6 = !r6.includes('"') && !r6.includes("'"), n8 = "json" === e19.parser ? '"' : e19.__isInHtmlAttribute ? "'" : Bt1(t13, e19.singleQuote ? "'" : '"');
        return s5 ? i6 ? n8 + r6 + n8 : t13 : St1(r6, n8, !("css" === e19.parser || "less" === e19.parser || "scss" === e19.parser || e19.embeddedInHtml));
    },
    printNumber: function(t13) {
        return t13.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(t13) {
        return "prettier-ignore" === t13.value.trim();
    },
    makeString: St1,
    addLeadingComment: function(t13, e19) {
        e19.leading = !0, e19.trailing = !1, Nt(t13, e19);
    },
    addDanglingComment: function(t13, e19, s5) {
        e19.leading = !1, e19.trailing = !1, s5 && (e19.marker = s5), Nt(t13, e19);
    },
    addTrailingComment: function(t13, e19) {
        e19.leading = !1, e19.trailing = !0, Nt(t13, e19);
    },
    isFrontMatterNode: function(t13) {
        return t13 && "front-matter" === t13.type;
    },
    getShebang: function(t13) {
        if (!t13.startsWith("#!")) return "";
        const e19 = t13.indexOf("\n");
        return -1 === e19 ? t13 : t13.slice(0, e19);
    }
}, vt1 = Object.freeze({
    __proto__: null,
    default: {
        EOL: "\n",
        platform: ()=>"browser"
        ,
        cpus: ()=>[
                {
                    model: "Prettier"
                }
            ]
    }
});
var Ot1 = _1(vt1), Mt2 = R1(function(t13, e19) {
    function s5() {
        const t14 = Ot1;
        return (s5 = function() {
            return Ot1;
        }, Ot1);
    }
    function r6() {
        const t14 = (e20 = Lt) && e20.__esModule ? e20 : {
            default: e20
        };
        var e20;
        return (r6 = function() {
            return t14;
        }, t14);
    }
    Object.defineProperty(e19, "__esModule", {
        value: !0
    }), e19.extract = function(t14) {
        const e20 = t14.match(a5);
        return e20 ? e20[0].trimLeft() : "";
    }, e19.strip = function(t14) {
        const e20 = t14.match(a5);
        return e20 && e20[0] ? t14.substring(e20[0].length) : t14;
    }, e19.parse = function(t14) {
        return d6(t14).pragmas;
    }, e19.parseWithComments = d6, e19.print = function({ comments: t14 = "" , pragmas: e20 = {
    }  }) {
        const i6 = r6().default(t14) || s5().EOL, n8 = " *", a5 = Object.keys(e20), o5 = a5.map((t15)=>D5(t15, e20[t15])
        ).reduce((t15, e21)=>t15.concat(e21)
        , []).map((t15)=>" * " + t15 + i6
        ).join("");
        if (!t14) {
            if (0 === a5.length) return "";
            if (1 === a5.length && !Array.isArray(e20[a5[0]])) {
                const t15 = e20[a5[0]];
                return "".concat("/**", " ").concat(D5(a5[0], t15)[0]).concat(" */");
            }
        }
        const u4 = t14.split(i6).map((t15)=>"".concat(n8, " ").concat(t15)
        ).join(i6) + i6;
        return "/**" + i6 + (t14 ? u4 : "") + (t14 && a5.length ? n8 + i6 : "") + o5 + " */";
    };
    const i6 = /\*\/$/, n8 = /^\/\*\*/, a5 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, o5 = /(^|\s+)\/\/([^\r\n]*)/g, u4 = /^(\r?\n)+/, h5 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c6 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p6 = /(\r?\n|^) *\* ?/g, l5 = [];
    function d6(t14) {
        const e20 = r6().default(t14) || s5().EOL;
        t14 = t14.replace(n8, "").replace(i6, "").replace(p6, "$1");
        let a6 = "";
        for(; a6 !== t14;)a6 = t14, t14 = t14.replace(h5, "".concat(e20, "$1 $2").concat(e20));
        t14 = t14.replace(u4, "").trimRight();
        const d7 = Object.create(null), D5 = t14.replace(c6, "").replace(u4, "").trimRight();
        let m5;
        for(; m5 = c6.exec(t14);){
            const t15 = m5[2].replace(o5, "");
            "string" == typeof d7[m5[1]] || Array.isArray(d7[m5[1]]) ? d7[m5[1]] = l5.concat(d7[m5[1]], t15) : d7[m5[1]] = t15;
        }
        return {
            comments: D5,
            pragmas: d7
        };
    }
    function D5(t14, e20) {
        return l5.concat(e20).map((e21)=>"@".concat(t14, " ").concat(e21).trim()
        );
    }
});
const { parseWithComments: _t2 , strip: jt2 , extract: Ut2 , print: qt1  } = Mt2, { getShebang: Vt2  } = It2, { normalizeEndOfLine: zt1  } = Rt;
function Ht2(t13) {
    const e19 = Vt2(t13);
    e19 && (t13 = t13.slice(e19.length + 1));
    const s5 = Ut2(t13), { pragmas: r6 , comments: i6  } = _t2(s5);
    return {
        shebang: e19,
        text: t13,
        pragmas: r6,
        comments: i6
    };
}
var Wt2 = {
    hasPragma: function(t13) {
        const e19 = Object.keys(Ht2(t13).pragmas);
        return e19.includes("prettier") || e19.includes("format");
    },
    insertPragma: function(t13) {
        const { shebang: e19 , text: s5 , pragmas: r6 , comments: i6  } = Ht2(t13), n8 = jt2(s5), a5 = qt1({
            pragmas: Object.assign({
                format: ""
            }, r6),
            comments: i6.trimStart()
        });
        return (e19 ? "".concat(e19, "\n") : "") + zt1(a5) + (n8.startsWith("\n") ? "\n" : "\n\n") + n8;
    }
};
const Zt2 = R1(function(t13, e19) {
    e19.ast = $t1, e19.code = Yt1, e19.keyword = Qt1;
}).keyword.isIdentifierNameES5, { getLast: te2 , hasNewline: ee4 , hasNewlineInRange: se2 , skipWhitespace: re2  } = It2, { locStart: ie2 , locEnd: ne3 , hasSameLocStart: ae2  } = Jt1, oe2 = new RegExp("^".concat("(?:(?=.)\\s)", "*:")), ue2 = new RegExp("^".concat("(?:(?=.)\\s)", "*::"));
function xe2(t13) {
    return Ce1(t13) || ae2(t13, t13.value);
}
function Se1(t13, e19) {
    if (Ae1(e19)) return Ve1(e19);
    return e19.comments && e19.comments.some((e20)=>e20.leading && ee4(t13, ne3(e20))
    );
}
var He1 = {
    classChildNeedsASIProtection: function(t13) {
        if (t13) {
            if (t13.static || t13.accessibility) return !1;
            if (!t13.computed) {
                const e19 = t13.key && t13.key.name;
                if ("in" === e19 || "instanceof" === e19) return !0;
            }
            switch(t13.type){
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                    return t13.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    {
                        const e19 = t13.value ? t13.value.async : t13.async, s5 = t13.value ? t13.value.generator : t13.generator;
                        return !e19 && "get" !== t13.kind && "set" !== t13.kind && !(!t13.computed && !s5);
                    }
                case "TSIndexSignature":
                    return !0;
                default:
                    return !1;
            }
        }
    },
    classPropMayCauseASIProblems: function(t13) {
        const e19 = t13.getNode();
        if ("ClassProperty" !== e19.type && "FieldDefinition" !== e19.type) return !1;
        const s5 = e19.key && e19.key.name;
        return !("static" !== s5 && "get" !== s5 && "set" !== s5 || e19.value || e19.typeAnnotation) || void 0;
    },
    getFunctionParameters: je1,
    iterateFunctionParametersPath: function(t13, e19) {
        const s5 = t13.getValue();
        let r6 = 0;
        const i6 = (t14)=>e19(t14, r6++)
        ;
        s5.this && t13.call(i6, "this"), Array.isArray(s5.parameters) ? t13.each(i6, "parameters") : Array.isArray(s5.params) && t13.each(i6, "params"), s5.rest && t13.call(i6, "rest");
    },
    getCallArguments: function(t13) {
        if (Ue.has(t13)) return Ue.get(t13);
        const e19 = "ImportExpression" === t13.type ? [
            t13.source
        ] : t13.arguments;
        return (Ue.set(t13, e19), e19);
    },
    iterateCallArgumentsPath: function(t13, e19) {
        "ImportExpression" === t13.getValue().type ? t13.call((t14)=>e19(t14, 0)
        , "source") : t13.each(e19, "arguments");
    },
    hasRestParameter: function(t13) {
        if (t13.rest) return !0;
        const e19 = je1(t13);
        return e19.length > 0 && "RestElement" === te2(e19).type;
    },
    getLeftSidePathName: function(t13, e19) {
        if (e19.expressions) return [
            "expressions",
            0
        ];
        if (e19.left) return [
            "left"
        ];
        if (e19.test) return [
            "test"
        ];
        if (e19.object) return [
            "object"
        ];
        if (e19.callee) return [
            "callee"
        ];
        if (e19.tag) return [
            "tag"
        ];
        if (e19.argument) return [
            "argument"
        ];
        if (e19.expression) return [
            "expression"
        ];
        throw new Error("Unexpected node has no left side.");
    },
    getParentExportDeclaration: function(t13) {
        const e19 = t13.getParentNode();
        return "declaration" === t13.getName() && de1(e19) ? e19 : null;
    },
    getTypeScriptMappedTypeModifier: function(t13, e19) {
        return "+" === t13 ? "+" + e19 : "-" === t13 ? "-" + e19 : e19;
    },
    hasDanglingComments: function(t13) {
        return t13.comments && t13.comments.some((t14)=>!t14.leading && !t14.trailing
        );
    },
    hasFlowAnnotationComment: function(t13) {
        return t13 && pe1(t13[0]) && ue2.test(t13[0].value);
    },
    hasFlowShorthandAnnotationComment: function(t13) {
        return t13.extra && t13.extra.parenthesized && t13.trailingComments && pe1(t13.trailingComments[0]) && oe2.test(t13.trailingComments[0].value);
    },
    hasLeadingComment: function(t13) {
        return t13.comments && t13.comments.some((t14)=>t14.leading
        );
    },
    hasLeadingOwnLineComment: Se1,
    hasNakedLeftSide: ce1,
    hasNewlineBetweenOrAfterDecorators: function(t13, e19) {
        return se2(e19.originalText, ie2(t13.decorators[0]), ne3(te2(t13.decorators))) || ee4(e19.originalText, ne3(te2(t13.decorators)));
    },
    hasNgSideEffect: function(t13) {
        return he1(t13.getValue(), (t14)=>{
            switch(t14.type){
                case void 0:
                    return !1;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                    return !0;
            }
        });
    },
    hasNode: he1,
    hasPrettierIgnore: function(t13) {
        return ze(t13) || function(t14) {
            const e19 = t14.getValue(), s5 = t14.getParentNode();
            if (!(s5 && e19 && Ae1(e19) && Ae1(s5))) return !1;
            let r6 = null;
            for(let t15 = s5.children.indexOf(e19); t15 > 0; t15--){
                const e20 = s5.children[t15 - 1];
                if ("JSXText" !== e20.type || Be4(e20)) {
                    r6 = e20;
                    break;
                }
            }
            return r6 && "JSXExpressionContainer" === r6.type && "JSXEmptyExpression" === r6.expression.type && r6.expression.comments && r6.expression.comments.some((t16)=>qe1(t16)
            );
        }(t13);
    },
    hasTrailingComment: function(t13) {
        return t13.comments && t13.comments.some((t14)=>t14.trailing
        );
    },
    hasTrailingLineComment: function(t13) {
        return t13.comments && t13.comments.some((t14)=>t14.trailing && !pe1(t14)
        );
    },
    hasIgnoreComment: ze,
    hasNodeIgnoreComment: Ve1,
    identity: function(t13) {
        return t13;
    },
    isBinaryish: function(t13) {
        return Fe1.has(t13.type);
    },
    isBlockComment: pe1,
    isLineComment: function(t13) {
        return "Line" === t13.type || "CommentLine" === t13.type || "SingleLine" === t13.type || "HashbangComment" === t13.type || "HTMLOpen" === t13.type || "HTMLClose" === t13.type;
    },
    isPrettierIgnoreComment: qe1,
    isCallOrOptionalCallExpression: Pe1,
    isEmptyJSXElement: function(t13) {
        if (0 === t13.children.length) return !0;
        if (t13.children.length > 1) return !1;
        const e19 = t13.children[0];
        return De1(e19) && !Be4(e19);
    },
    isExportDeclaration: de1,
    isFlowAnnotationComment: function(t13, e19) {
        const s5 = ie2(e19), r6 = re2(t13, ne3(e19));
        return !1 !== r6 && "/*" === t13.slice(s5, s5 + 2) && "*/" === t13.slice(r6, r6 + 2);
    },
    isFunctionCompositionArgs: function(t13) {
        if (t13.length <= 1) return !1;
        let e19 = 0;
        for (const s5 of t13)if (ye1(s5)) {
            if ((e19 += 1, e19 > 1)) return !0;
        } else if (Pe1(s5)) for (const t14 of s5.arguments)if (ye1(t14)) return !0;
        return !1;
    },
    isFunctionNotation: xe2,
    isFunctionOrArrowExpression: ye1,
    isGetterOrSetter: Ce1,
    isJestEachTemplateLiteral: function(t13, e19) {
        const s5 = /^[fx]?(describe|it|test)$/;
        return "TaggedTemplateExpression" === e19.type && e19.quasi === t13 && "MemberExpression" === e19.tag.type && "Identifier" === e19.tag.property.type && "each" === e19.tag.property.name && ("Identifier" === e19.tag.object.type && s5.test(e19.tag.object.name) || "MemberExpression" === e19.tag.object.type && "Identifier" === e19.tag.object.property.type && ("only" === e19.tag.object.property.name || "skip" === e19.tag.object.property.name) && "Identifier" === e19.tag.object.object.type && s5.test(e19.tag.object.object.name));
    },
    isJSXNode: Ae1,
    isJSXWhitespaceExpression: function(t13) {
        return "JSXExpressionContainer" === t13.type && De1(t13.expression) && " " === t13.expression.value && !t13.expression.comments;
    },
    isLastStatement: function(t13) {
        const e19 = t13.getParentNode();
        if (!e19) return !0;
        const s5 = t13.getValue(), r6 = (e19.body || e19.consequent).filter((t14)=>"EmptyStatement" !== t14.type
        );
        return r6[r6.length - 1] === s5;
    },
    isLiteral: De1,
    isLongCurriedCallExpression: function(t13) {
        const e19 = t13.getValue(), s5 = t13.getParentNode();
        return Pe1(e19) && Pe1(s5) && s5.callee === e19 && e19.arguments.length > s5.arguments.length && s5.arguments.length > 0;
    },
    isSimpleCallArgument: function t13(e19, s5) {
        if (s5 >= 2) return !1;
        const r6 = (e20)=>t13(e20, s5 + 1)
        , i6 = "Literal" === e19.type && "regex" in e19 && e19.regex.pattern || "RegExpLiteral" === e19.type && e19.pattern;
        return !(i6 && i6.length > 5) && ("Literal" === e19.type || "BigIntLiteral" === e19.type || "DecimalLiteral" === e19.type || "BooleanLiteral" === e19.type || "NullLiteral" === e19.type || "NumericLiteral" === e19.type || "RegExpLiteral" === e19.type || "StringLiteral" === e19.type || "Identifier" === e19.type || "ThisExpression" === e19.type || "Super" === e19.type || "PrivateName" === e19.type || "ArgumentPlaceholder" === e19.type || "Import" === e19.type || ("TemplateLiteral" === e19.type ? e19.expressions.every(r6) : "ObjectExpression" === e19.type ? e19.properties.every((t14)=>!t14.computed && (t14.shorthand || t14.value && r6(t14.value))
        ) : "ArrayExpression" === e19.type ? e19.elements.every((t14)=>null === t14 || r6(t14)
        ) : "ImportExpression" === e19.type ? r6(e19.source) : "CallExpression" === e19.type || "OptionalCallExpression" === e19.type || "NewExpression" === e19.type ? t13(e19.callee, s5) && e19.arguments.every(r6) : "MemberExpression" === e19.type || "OptionalMemberExpression" === e19.type ? t13(e19.object, s5) && t13(e19.property, s5) : "UnaryExpression" !== e19.type || "!" !== e19.operator && "-" !== e19.operator ? "TSNonNullExpression" === e19.type && t13(e19.expression, s5) : t13(e19.argument, s5)));
    },
    isMeaningfulJSXText: Be4,
    isMemberExpressionChain: function t13(e19) {
        return ("MemberExpression" === e19.type || "OptionalMemberExpression" === e19.type) && ("Identifier" === e19.object.type || t13(e19.object));
    },
    isMemberish: function(t14) {
        return "MemberExpression" === t14.type || "OptionalMemberExpression" === t14.type || "BindExpression" === t14.type && Boolean(t14.object);
    },
    isNgForOf: function(t14, e19, s5) {
        return "NGMicrosyntaxKeyedExpression" === t14.type && "of" === t14.key.name && 1 === e19 && "NGMicrosyntaxLet" === s5.body[0].type && null === s5.body[0].value;
    },
    isNumericLiteral: me1,
    isObjectType: function(t14) {
        return "ObjectTypeAnnotation" === t14.type || "TSTypeLiteral" === t14.type;
    },
    isObjectTypePropertyAFunction: function(t14) {
        return !("ObjectTypeProperty" !== t14.type && "ObjectTypeInternalSlot" !== t14.type || "FunctionTypeAnnotation" !== t14.value.type || t14.static || xe2(t14));
    },
    isSimpleType: function(t14) {
        return !!t14 && (!("GenericTypeAnnotation" !== t14.type && "TSTypeReference" !== t14.type || t14.typeParameters) || !!ge1.has(t14.type));
    },
    isSimpleNumber: Ne1,
    isSimpleTemplateLiteral: function(t14) {
        let e19 = "expressions";
        "TSTemplateLiteralType" === t14.type && (e19 = "types");
        const s5 = t14[e19];
        return 0 !== s5.length && s5.every((t15)=>{
            if (t15.comments) return !1;
            if ("Identifier" === t15.type || "ThisExpression" === t15.type) return !0;
            if ("MemberExpression" === t15.type || "OptionalMemberExpression" === t15.type) {
                let e20 = t15;
                for(; "MemberExpression" === e20.type || "OptionalMemberExpression" === e20.type;){
                    if ("Identifier" !== e20.property.type && "Literal" !== e20.property.type && "StringLiteral" !== e20.property.type && "NumericLiteral" !== e20.property.type) return !1;
                    if (e20 = e20.object, e20.comments) return !1;
                }
                return "Identifier" === e20.type || "ThisExpression" === e20.type;
            }
            return !1;
        });
    },
    isStringLiteral: fe1,
    isStringPropSafeToUnquote: function(t14, e19) {
        return "json" !== e19.parser && fe1(t14.key) && ve1(t14.key).slice(1, -1) === t14.key.value && (Zt2(t14.key.value) && !(("typescript" === e19.parser || "babel-ts" === e19.parser) && "ClassProperty" === t14.type) || Ne1(t14.key.value) && String(Number(t14.key.value)) === t14.key.value && ("babel" === e19.parser || "espree" === e19.parser || "meriyah" === e19.parser));
    },
    isTemplateOnItsOwnLine: function(t14, e19) {
        return ("TemplateLiteral" === t14.type && Ie2(t14) || "TaggedTemplateExpression" === t14.type && Ie2(t14.quasi)) && !ee4(e19, ie2(t14), {
            backwards: !0
        });
    },
    isTestCall: function t13(e19, s5) {
        if ("CallExpression" !== e19.type) return !1;
        if (1 === e19.arguments.length) {
            if (Ee2(e19) && s5 && t13(s5)) return ye1(e19.arguments[0]);
            if ("Identifier" === (r6 = e19).callee.type && /^(before|after)(Each|All)$/.test(r6.callee.name) && 1 === r6.arguments.length) return Ee2(e19.arguments[0]);
        } else if ((2 === e19.arguments.length || 3 === e19.arguments.length) && ("Identifier" === e19.callee.type && be1.test(e19.callee.name) || function(t14) {
            return ("MemberExpression" === t14.callee.type || "OptionalMemberExpression" === t14.callee.type) && "Identifier" === t14.callee.object.type && "Identifier" === t14.callee.property.type && be1.test(t14.callee.object.name) && ("only" === t14.callee.property.name || "skip" === t14.callee.property.name);
        }(e19)) && (function(t14) {
            return "TemplateLiteral" === t14.type;
        }(e19.arguments[0]) || fe1(e19.arguments[0]))) return !(e19.arguments[2] && !me1(e19.arguments[2])) && ((2 === e19.arguments.length ? ye1(e19.arguments[1]) : function(t14) {
            return "FunctionExpression" === t14.type || "ArrowFunctionExpression" === t14.type && "BlockStatement" === t14.body.type;
        }(e19.arguments[1]) && je1(e19.arguments[1]).length <= 1) || Ee2(e19.arguments[1]));
        var r6;
        return !1;
    },
    isTheOnlyJSXElementInMarkdown: function(t14, e19) {
        if ("markdown" !== t14.parentParser && "mdx" !== t14.parentParser) return !1;
        const s5 = e19.getNode();
        if (!s5.expression || !Ae1(s5.expression)) return !1;
        const r6 = e19.getParentNode();
        return "Program" === r6.type && 1 === r6.body.length;
    },
    isTSXFile: function(t14) {
        return t14.filepath && /\.tsx$/i.test(t14.filepath);
    },
    isTypeAnnotationAFunction: function(t14) {
        return !("TypeAnnotation" !== t14.type && "TSTypeAnnotation" !== t14.type || "FunctionTypeAnnotation" !== t14.typeAnnotation.type || t14.static || ae2(t14, t14.typeAnnotation));
    },
    matchJsxWhitespaceRegex: Te1,
    needsHardlineAfterDanglingComment: function(t14) {
        if (!t14.comments) return !1;
        const e19 = te2(t14.comments.filter((t15)=>!t15.leading && !t15.trailing
        ));
        return e19 && !pe1(e19);
    },
    rawText: ve1,
    returnArgumentHasLeadingComment: function(t14, e19) {
        if (Se1(t14.originalText, e19)) return !0;
        if (ce1(e19)) {
            let r6, i6 = e19;
            for(; r6 = (s5 = i6).expressions ? s5.expressions[0] : s5.left || s5.test || s5.callee || s5.object || s5.tag || s5.argument || s5.expression;)if ((i6 = r6, Se1(t14.originalText, i6))) return !0;
        }
        var s5;
        return !1;
    },
    shouldPrintComma: function(t14, e19 = "es5") {
        return "es5" === t14.trailingComma && "es5" === e19 || "all" === t14.trailingComma && ("all" === e19 || "es5" === e19);
    },
    isBitwiseOperator: function(t14) {
        return !!Oe[t14] || "|" === t14 || "^" === t14 || "&" === t14;
    },
    shouldFlatten: function(t14, e19) {
        return Re2(e19) === Re2(t14) && ("**" !== t14 && ((!ke1[t14] || !ke1[e19]) && (!("%" === e19 && Le1[t14] || "%" === t14 && Le1[e19]) && ((e19 === t14 || !Le1[e19] || !Le1[t14]) && (!Oe[t14] || !Oe[e19])))));
    },
    startsWithNoLookaheadToken: function t13(e19, s5) {
        switch((e19 = function(t14) {
            for(; t14.left;)t14 = t14.left;
            return t14;
        }(e19)).type){
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
                return s5;
            case "ObjectExpression":
                return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
                return t13(e19.object, s5);
            case "TaggedTemplateExpression":
                return "FunctionExpression" !== e19.tag.type && t13(e19.tag, s5);
            case "CallExpression":
            case "OptionalCallExpression":
                return "FunctionExpression" !== e19.callee.type && t13(e19.callee, s5);
            case "ConditionalExpression":
                return t13(e19.test, s5);
            case "UpdateExpression":
                return !e19.prefix && t13(e19.argument, s5);
            case "BindExpression":
                return e19.object && t13(e19.object, s5);
            case "SequenceExpression":
                return t13(e19.expressions[0], s5);
            case "TSAsExpression":
                return t13(e19.expression, s5);
            default:
                return !1;
        }
    },
    getPrecedence: Re2
};
const { getLast: We1 , hasNewline: Ge2 , getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Xe1 , getNextNonSpaceNonCommentCharacter: Ke2 , hasNewlineInRange: Je2 , addLeadingComment: $e2 , addTrailingComment: Ye2 , addDanglingComment: Qe1 , getNextNonSpaceNonCommentCharacterIndex: Ze2  } = It2, { isBlockComment: ts1 , getFunctionParameters: es1 , isPrettierIgnoreComment: ss1 , isJSXNode: rs1 , hasFlowShorthandAnnotationComment: is1 , hasFlowAnnotationComment: ns1 , hasIgnoreComment: as1  } = He1, { locStart: os1 , locEnd: us1  } = Jt1;
function hs1(t13, e19) {
    const s5 = (t13.body || t13.properties).find(({ type: t14  })=>"EmptyStatement" !== t14
    );
    s5 ? $e2(s5, e19) : Qe1(t13, e19);
}
function cs1(t13, e19) {
    "BlockStatement" === t13.type ? hs1(t13, e19) : $e2(t13, e19);
}
function ps1(t13, e19) {
    const { precedingNode: s5 , enclosingNode: r6 , followingNode: i6  } = t13;
    if (!r6 || "IfStatement" !== r6.type || !i6) return !1;
    return ")" === Ke2(e19, t13, us1) ? (Ye2(s5, t13), !0) : s5 === r6.consequent && i6 === r6.alternate ? ("BlockStatement" === s5.type ? Ye2(s5, t13) : Qe1(r6, t13), !0) : "BlockStatement" === i6.type ? (hs1(i6, t13), !0) : "IfStatement" === i6.type ? (cs1(i6.consequent, t13), !0) : r6.consequent === i6 && ($e2(i6, t13), !0);
}
function ls1(t13, e19) {
    const { precedingNode: s5 , enclosingNode: r6 , followingNode: i6  } = t13;
    if (!r6 || "WhileStatement" !== r6.type || !i6) return !1;
    return ")" === Ke2(e19, t13, us1) ? (Ye2(s5, t13), !0) : "BlockStatement" === i6.type ? (hs1(i6, t13), !0) : r6.body === i6 && ($e2(i6, t13), !0);
}
function ds1(t13) {
    const { precedingNode: e19 , enclosingNode: s5 , followingNode: r6  } = t13;
    return !(!s5 || "TryStatement" !== s5.type && "CatchClause" !== s5.type || !r6) && ("CatchClause" === s5.type && e19 ? (Ye2(e19, t13), !0) : "BlockStatement" === r6.type ? (hs1(r6, t13), !0) : "TryStatement" === r6.type ? (cs1(r6.finalizer, t13), !0) : "CatchClause" === r6.type && (cs1(r6.body, t13), !0));
}
function Ds1(t13) {
    const { precedingNode: e19 , enclosingNode: s5 , followingNode: r6  } = t13;
    if (s5 && ("ClassDeclaration" === s5.type || "ClassExpression" === s5.type || "DeclareClass" === s5.type || "DeclareInterface" === s5.type || "InterfaceDeclaration" === s5.type || "TSInterfaceDeclaration" === s5.type)) {
        if (s5.decorators && s5.decorators.length > 0 && (!r6 || "Decorator" !== r6.type)) return Ye2(s5.decorators[s5.decorators.length - 1], t13), !0;
        if (s5.body && r6 === s5.body) return hs1(s5.body, t13), !0;
        if (r6) for (const i6 of [
            "implements",
            "extends",
            "mixins"
        ])if (s5[i6] && r6 === s5[i6][0]) return !e19 || e19 !== s5.id && e19 !== s5.typeParameters && e19 !== s5.superClass ? Qe1(s5, t13, i6) : Ye2(e19, t13), !0;
    }
    return !1;
}
function ms1(t13, e19) {
    const { precedingNode: s5 , enclosingNode: r6  } = t13;
    return (r6 && s5 && ("Property" === r6.type || "TSDeclareMethod" === r6.type || "TSAbstractMethodDefinition" === r6.type) && "Identifier" === s5.type && r6.key === s5 && ":" !== Ke2(e19, s5, us1) || !(!s5 || !r6 || "Decorator" !== s5.type || "ClassMethod" !== r6.type && "ClassProperty" !== r6.type && "FieldDefinition" !== r6.type && "TSAbstractClassProperty" !== r6.type && "TSAbstractMethodDefinition" !== r6.type && "TSDeclareMethod" !== r6.type && "MethodDefinition" !== r6.type)) && (Ye2(s5, t13), !0);
}
function fs1(t13, e19) {
    const { precedingNode: s5 , enclosingNode: r6 , followingNode: i6  } = t13;
    if (s5 && "FunctionTypeParam" === s5.type && r6 && "FunctionTypeAnnotation" === r6.type && i6 && "FunctionTypeParam" !== i6.type) return Ye2(s5, t13), !0;
    if (s5 && ("Identifier" === s5.type || "AssignmentPattern" === s5.type) && r6 && xs(r6) && ")" === Ke2(e19, t13, us1)) return Ye2(s5, t13), !0;
    if (r6 && "FunctionDeclaration" === r6.type && i6 && "BlockStatement" === i6.type) {
        const s6 = (()=>{
            const t14 = es1(r6);
            if (0 !== t14.length) return Xe1(e19, us1(We1(t14)));
            const s7 = Xe1(e19, us1(r6.id));
            return !1 !== s7 && Xe1(e19, s7 + 1);
        })();
        if (os1(t13) > s6) return hs1(i6, t13), !0;
    }
    return !1;
}
function ys1(t13) {
    const { enclosingNode: e19  } = t13;
    return !(!e19 || "ImportSpecifier" !== e19.type) && ($e2(e19, t13), !0);
}
function Es1(t13) {
    const { enclosingNode: e19  } = t13;
    return !(!e19 || "LabeledStatement" !== e19.type) && ($e2(e19, t13), !0);
}
function As1(t13, e19, s5) {
    const { enclosingNode: r6  } = t13;
    return e19 && e19.body && 0 === e19.body.length ? (s5 ? Qe1(e19, t13) : $e2(e19, t13), !0) : !(!r6 || "Program" !== r6.type || 0 !== r6.body.length || !r6.directives || 0 !== r6.directives.length) && (s5 ? Qe1(r6, t13) : $e2(r6, t13), !0);
}
function Cs1(t13) {
    const { enclosingNode: e19 , followingNode: s5  } = t13;
    if (ss1(t13) && e19 && "TSMappedType" === e19.type && s5 && "TSTypeParameter" === s5.type && s5.constraint) return e19.prettierIgnore = !0, t13.unignore = !0, !0;
}
function Fs1(t13) {
    return ts1(t13) && "*" === t13.value[0] && /@type\b/.test(t13.value);
}
var gs1 = {
    handleOwnLineComment: function(t13, e19, s5, r6, i6) {
        return Cs1(t13) || fs1(t13, e19) || function(t14) {
            const { enclosingNode: e20 , followingNode: s6  } = t14;
            if (e20 && ("MemberExpression" === e20.type || "OptionalMemberExpression" === e20.type) && s6 && "Identifier" === s6.type) return $e2(e20, t14), !0;
            return !1;
        }(t13) || ps1(t13, e19) || ls1(t13, e19) || ds1(t13) || Ds1(t13) || ys1(t13) || function(t14) {
            const { enclosingNode: e20  } = t14;
            if (e20 && ("ForInStatement" === e20.type || "ForOfStatement" === e20.type)) return $e2(e20, t14), !0;
            return !1;
        }(t13) || function(t14) {
            const { precedingNode: e20 , enclosingNode: s6 , followingNode: r7  } = t14;
            if (s6 && ("UnionTypeAnnotation" === s6.type || "TSUnionType" === s6.type)) return ss1(t14) && (r7.prettierIgnore = !0, t14.unignore = !0), !!e20 && (Ye2(e20, t14), !0);
            r7 && ("UnionTypeAnnotation" === r7.type || "TSUnionType" === r7.type) && ss1(t14) && (r7.types[0].prettierIgnore = !0, t14.unignore = !0);
            return !1;
        }(t13) || As1(t13, r6, i6) || function(t14, e20) {
            const { precedingNode: s6 , enclosingNode: r7  } = t14;
            if (s6 && "ImportSpecifier" === s6.type && r7 && "ImportDeclaration" === r7.type && Ge2(e20, us1(t14))) return Ye2(s6, t14), !0;
            return !1;
        }(t13, e19) || function(t14) {
            const { enclosingNode: e20  } = t14;
            if (e20 && "AssignmentPattern" === e20.type) return $e2(e20, t14), !0;
            return !1;
        }(t13) || ms1(t13, e19) || Es1(t13);
    },
    handleEndOfLineComment: function(t13, e19, s5, r6, i6) {
        return function(t14) {
            const { followingNode: e20  } = t14;
            if (e20 && Fs1(t14)) return $e2(e20, t14), !0;
            return !1;
        }(t13) || fs1(t13, e19) || function(t14, e20) {
            const { precedingNode: s6 , enclosingNode: r7 , followingNode: i7  } = t14, n8 = s6 && !Je2(e20, us1(s6), os1(t14));
            if ((!s6 || !n8) && r7 && ("ConditionalExpression" === r7.type || "TSConditionalType" === r7.type) && i7) return $e2(i7, t14), !0;
            return !1;
        }(t13, e19) || ys1(t13) || ps1(t13, e19) || ls1(t13, e19) || ds1(t13) || Ds1(t13) || Es1(t13) || function(t14) {
            const { precedingNode: e20 , enclosingNode: s6  } = t14;
            if (s6 && ("CallExpression" === s6.type || "OptionalCallExpression" === s6.type) && e20 && s6.callee === e20 && s6.arguments.length > 0) return $e2(s6.arguments[0], t14), !0;
            return !1;
        }(t13) || function(t14) {
            const { enclosingNode: e20  } = t14;
            if (e20 && ("Property" === e20.type || "ObjectProperty" === e20.type)) return $e2(e20, t14), !0;
            return !1;
        }(t13) || As1(t13, r6, i6) || function(t14) {
            const { enclosingNode: e20  } = t14;
            if (e20 && "TypeAlias" === e20.type) return $e2(e20, t14), !0;
            return !1;
        }(t13) || function(t14) {
            const { enclosingNode: e20 , followingNode: s6  } = t14;
            if (e20 && ("VariableDeclarator" === e20.type || "AssignmentExpression" === e20.type) && s6 && ("ObjectExpression" === s6.type || "ArrayExpression" === s6.type || "TemplateLiteral" === s6.type || "TaggedTemplateExpression" === s6.type || ts1(t14))) return $e2(s6, t14), !0;
            return !1;
        }(t13);
    },
    handleRemainingComment: function(t13, e19, s5, r6, i6) {
        return !!(Cs1(t13) || ps1(t13, e19) || ls1(t13, e19) || function(t14) {
            const { precedingNode: e20 , enclosingNode: s6  } = t14;
            if (s6 && ("ObjectProperty" === s6.type || "Property" === s6.type) && s6.shorthand && s6.key === e20 && "AssignmentPattern" === s6.value.type) return Ye2(s6.value.left, t14), !0;
            return !1;
        }(t13) || function(t14, e20) {
            if (")" !== Ke2(e20, t14, us1)) return !1;
            const { enclosingNode: s6  } = t14;
            if (s6 && (xs(s6) && 0 === es1(s6).length || ("CallExpression" === s6.type || "OptionalCallExpression" === s6.type || "NewExpression" === s6.type) && 0 === s6.arguments.length)) return Qe1(s6, t14), !0;
            if (s6 && "MethodDefinition" === s6.type && 0 === es1(s6.value).length) return Qe1(s6.value, t14), !0;
            return !1;
        }(t13, e19) || ms1(t13, e19) || As1(t13, r6, i6) || function(t14, e20) {
            const { enclosingNode: s6  } = t14;
            if (!s6 || "ArrowFunctionExpression" !== s6.type) return !1;
            const r7 = Ze2(e20, t14, us1);
            if (!1 !== r7 && "=>" === e20.slice(r7, r7 + 2)) return Qe1(s6, t14), !0;
            return !1;
        }(t13, e19) || function(t14, e20) {
            if ("(" !== Ke2(e20, t14, us1)) return !1;
            const { precedingNode: s6 , enclosingNode: r7  } = t14;
            if (s6 && r7 && ("FunctionDeclaration" === r7.type || "FunctionExpression" === r7.type || "ClassMethod" === r7.type || "MethodDefinition" === r7.type || "ObjectMethod" === r7.type)) return Ye2(s6, t14), !0;
            return !1;
        }(t13, e19) || function(t14) {
            const { precedingNode: e20 , enclosingNode: s6 , followingNode: r7  } = t14;
            if (!s6 || "TSMappedType" !== s6.type) return !1;
            if (r7 && "TSTypeParameter" === r7.type && r7.name) return $e2(r7.name, t14), !0;
            if (e20 && "TSTypeParameter" === e20.type && e20.constraint) return Ye2(e20.constraint, t14), !0;
            return !1;
        }(t13) || function(t14) {
            const { enclosingNode: e20  } = t14;
            if (e20 && ("ContinueStatement" === e20.type || "BreakStatement" === e20.type) && !e20.label) return Ye2(e20, t14), !0;
            return !1;
        }(t13) || function(t14, e20) {
            const { enclosingNode: s6 , followingNode: r7  } = t14;
            if (!r7 && s6 && ("TSMethodSignature" === s6.type || "TSDeclareFunction" === s6.type || "TSAbstractMethodDefinition" === s6.type) && ";" === Ke2(e20, t14, us1)) return Ye2(s6, t14), !0;
            return !1;
        }(t13, e19));
    },
    hasLeadingComment: function(t13, e19 = ()=>!0
    ) {
        return t13.leadingComments ? t13.leadingComments.some(e19) : !!t13.comments && t13.comments.some((t14)=>t14.leading && e19(t14)
        );
    },
    isTypeCastComment: Fs1,
    getGapRegex: function(t13) {
        if (t13 && "BinaryExpression" !== t13.type && "LogicalExpression" !== t13.type) return /^[\s&(|]*$/;
    },
    getCommentChildNodes: function(t13, e19) {
        if (("typescript" === e19.parser || "flow" === e19.parser || "espree" === e19.parser || "meriyah" === e19.parser) && "MethodDefinition" === t13.type && t13.value && "FunctionExpression" === t13.value.type && 0 === es1(t13.value).length && !t13.value.returnType && (!t13.value.typeParameters || 0 === t13.value.typeParameters.length) && t13.value.body) return [
            ...t13.decorators || [],
            t13.key,
            t13.value.body
        ];
    },
    willPrintOwnComments: function(t13) {
        const e19 = t13.getValue(), s5 = t13.getParentNode();
        return (e19 && (rs1(e19) || is1(e19) || s5 && ("CallExpression" === s5.type || "OptionalCallExpression" === s5.type) && (ns1(e19.leadingComments) || ns1(e19.trailingComments))) || s5 && ("JSXSpreadAttribute" === s5.type || "JSXSpreadChild" === s5.type || "UnionTypeAnnotation" === s5.type || "TSUnionType" === s5.type || ("ClassDeclaration" === s5.type || "ClassExpression" === s5.type) && s5.superClass === e19)) && (!as1(t13) || "UnionTypeAnnotation" === s5.type || "TSUnionType" === s5.type);
    }
};
const { getLast: bs1 , getNextNonSpaceNonCommentCharacter: Ps1 , getShebang: Ts1  } = It2, { composeLoc: ws1 , locStart: Bs1 , locEnd: Ss1  } = Jt1, { isTypeCastComment: Ns1  } = gs1;
function Ls1(t13) {
    return ks(t13) ? Ls1({
        type: "LogicalExpression",
        operator: t13.operator,
        left: Ls1({
            type: "LogicalExpression",
            operator: t13.operator,
            left: t13.left,
            right: t13.right.left,
            range: ws1(t13.left, t13.right.left)
        }),
        right: t13.right.right,
        range: ws1(t13)
    }) : t13;
}
var Os1 = function(e19, s5) {
    if (("typescript" !== s5.parser && "flow" !== s5.parser && "espree" !== s5.parser || function(t13, e20) {
        const s6 = Ts1(e20.originalText);
        s6 && t13.comments.unshift({
            type: "Line",
            value: s6.slice(2),
            range: [
                0,
                s6.length
            ]
        });
    }(e19, s5), "typescript" === s5.parser && s5.originalText.includes("@"))) {
        const { esTreeNodeToTSNodeMap: r6 , tsNodeToESTreeNodeMap: i6  } = s5.tsParseResult;
        e19 = vs(e19, (e20)=>{
            const s6 = r6.get(e20);
            if (!s6) return;
            const n8 = s6.decorators;
            if (!Array.isArray(n8)) return;
            const a5 = i6.get(s6);
            if (a5 !== e20) return;
            const o5 = a5.decorators;
            if (!Array.isArray(o5) || o5.length !== n8.length || n8.some((t13)=>{
                const e21 = i6.get(t13);
                return !e21 || !o5.includes(e21);
            })) {
                const { start: e21 , end: s7  } = a5.loc;
                throw t2("Leading decorators must be attached to a class declaration", {
                    start: {
                        line: e21.line,
                        column: e21.column + 1
                    },
                    end: {
                        line: s7.line,
                        column: s7.column + 1
                    }
                });
            }
        });
    }
    if ("typescript" !== s5.parser && "flow" !== s5.parser && "espree" !== s5.parser && "meriyah" !== s5.parser) {
        const t13 = new Set;
        e19 = vs(e19, (e20)=>{
            e20.leadingComments && e20.leadingComments.some(Ns1) && t13.add(Bs1(e20));
        }), e19 = vs(e19, (e20)=>{
            if ("ParenthesizedExpression" === e20.type) {
                const { expression: s6  } = e20;
                if ("TypeCastExpression" === s6.type) return s6.range = e20.range, s6;
                const r6 = Bs1(e20);
                if (!t13.has(r6)) return s6.extra = Object.assign({
                }, s6.extra, {
                    parenthesized: !0
                }), s6;
            }
        });
    }
    return e19 = vs(e19, (t13)=>{
        switch(t13.type){
            case "ChainExpression":
                return Is(t13.expression);
            case "LogicalExpression":
                if (ks(t13)) return Ls1(t13);
                break;
            case "VariableDeclaration":
                {
                    const e20 = bs1(t13.declarations);
                    e20 && e20.init && (function(t14, e21) {
                        if (";" === s5.originalText[Ss1(e21)]) return;
                        t14.range = ws1(t14, e21);
                    })(t13, e20);
                    break;
                }
            case "TSParenthesizedType":
                return t13.typeAnnotation.range = ws1(t13), t13.typeAnnotation;
            case "TSUnionType":
            case "TSIntersectionType":
                if (1 === t13.types.length) {
                    const [e20] = t13.types;
                    return e20.range = ws1(t13), e20;
                }
                break;
            case "TSTypeParameter":
                "string" == typeof t13.name && (t13.name = {
                    type: "Identifier",
                    name: t13.name,
                    range: ws1(t13, t13.name.length)
                });
                break;
            case "SequenceExpression":
                {
                    const e20 = bs1(t13.expressions);
                    Ss1(t13) > Ss1(e20) && (t13.range = ws1(t13, e20));
                    break;
                }
            case "ClassProperty":
                t13.key && "TSPrivateIdentifier" === t13.key.type && "?" === Ps1(s5.originalText, t13.key, Ss1) && (t13.optional = !0);
        }
    });
}, Ms1 = R1(function(t13, e19) {
    Object.defineProperty(e19, "__esModule", {
        value: !0
    });
    const s5 = !0, r6 = !0, i6 = !0, n8 = !0;
    class a5 {
        constructor(t14, e20 = {
        }){
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = t14, this.keyword = e20.keyword, this.beforeExpr = !!e20.beforeExpr, this.startsExpr = !!e20.startsExpr, this.rightAssociative = !!e20.rightAssociative, this.isLoop = !!e20.isLoop, this.isAssign = !!e20.isAssign, this.prefix = !!e20.prefix, this.postfix = !!e20.postfix, this.binop = null != e20.binop ? e20.binop : null, this.updateContext = null;
        }
    }
    const o5 = new Map;
    function u4(t15, e21 = {
    }) {
        e21.keyword = t15;
        const s6 = new a5(t15, e21);
        return (o5.set(t15, s6), s6);
    }
    function h5(t15, e21) {
        return new a5(t15, {
            beforeExpr: s5,
            binop: e21
        });
    }
    const c6 = {
        num: new a5("num", {
            startsExpr: r6
        }),
        bigint: new a5("bigint", {
            startsExpr: r6
        }),
        decimal: new a5("decimal", {
            startsExpr: r6
        }),
        regexp: new a5("regexp", {
            startsExpr: r6
        }),
        string: new a5("string", {
            startsExpr: r6
        }),
        name: new a5("name", {
            startsExpr: r6
        }),
        eof: new a5("eof"),
        bracketL: new a5("[", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        bracketHashL: new a5("#[", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        bracketBarL: new a5("[|", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        bracketR: new a5("]"),
        bracketBarR: new a5("|]"),
        braceL: new a5("{", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        braceBarL: new a5("{|", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        braceHashL: new a5("#{", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        braceR: new a5("}"),
        braceBarR: new a5("|}"),
        parenL: new a5("(", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        parenR: new a5(")"),
        comma: new a5(",", {
            beforeExpr: s5
        }),
        semi: new a5(";", {
            beforeExpr: s5
        }),
        colon: new a5(":", {
            beforeExpr: s5
        }),
        doubleColon: new a5("::", {
            beforeExpr: s5
        }),
        dot: new a5("."),
        question: new a5("?", {
            beforeExpr: s5
        }),
        questionDot: new a5("?."),
        arrow: new a5("=>", {
            beforeExpr: s5
        }),
        template: new a5("template"),
        ellipsis: new a5("...", {
            beforeExpr: s5
        }),
        backQuote: new a5("`", {
            startsExpr: r6
        }),
        dollarBraceL: new a5("${", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        at: new a5("@"),
        hash: new a5("#", {
            startsExpr: r6
        }),
        interpreterDirective: new a5("#!..."),
        eq: new a5("=", {
            beforeExpr: s5,
            isAssign: true
        }),
        assign: new a5("_=", {
            beforeExpr: s5,
            isAssign: true
        }),
        incDec: new a5("++/--", {
            prefix: n8,
            postfix: !0,
            startsExpr: r6
        }),
        bang: new a5("!", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        }),
        tilde: new a5("~", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        }),
        pipeline: h5("|>", 0),
        nullishCoalescing: h5("??", 1),
        logicalOR: h5("||", 1),
        logicalAND: h5("&&", 2),
        bitwiseOR: h5("|", 3),
        bitwiseXOR: h5("^", 4),
        bitwiseAND: h5("&", 5),
        equality: h5("==/!=/===/!==", 6),
        relational: h5("</>/<=/>=", 7),
        bitShift: h5("<</>>/>>>", 8),
        plusMin: new a5("+/-", {
            beforeExpr: s5,
            binop: 9,
            prefix: n8,
            startsExpr: r6
        }),
        modulo: new a5("%", {
            beforeExpr: s5,
            binop: 10,
            startsExpr: r6
        }),
        star: new a5("*", {
            binop: 10
        }),
        slash: h5("/", 10),
        exponent: new a5("**", {
            beforeExpr: s5,
            binop: 11,
            rightAssociative: !0
        }),
        _break: u4("break"),
        _case: u4("case", {
            beforeExpr: s5
        }),
        _catch: u4("catch"),
        _continue: u4("continue"),
        _debugger: u4("debugger"),
        _default: u4("default", {
            beforeExpr: s5
        }),
        _do: u4("do", {
            isLoop: i6,
            beforeExpr: s5
        }),
        _else: u4("else", {
            beforeExpr: s5
        }),
        _finally: u4("finally"),
        _for: u4("for", {
            isLoop: i6
        }),
        _function: u4("function", {
            startsExpr: r6
        }),
        _if: u4("if"),
        _return: u4("return", {
            beforeExpr: s5
        }),
        _switch: u4("switch"),
        _throw: u4("throw", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        }),
        _try: u4("try"),
        _var: u4("var"),
        _const: u4("const"),
        _while: u4("while", {
            isLoop: i6
        }),
        _with: u4("with"),
        _new: u4("new", {
            beforeExpr: s5,
            startsExpr: r6
        }),
        _this: u4("this", {
            startsExpr: r6
        }),
        _super: u4("super", {
            startsExpr: r6
        }),
        _class: u4("class", {
            startsExpr: r6
        }),
        _extends: u4("extends", {
            beforeExpr: s5
        }),
        _export: u4("export"),
        _import: u4("import", {
            startsExpr: r6
        }),
        _null: u4("null", {
            startsExpr: r6
        }),
        _true: u4("true", {
            startsExpr: r6
        }),
        _false: u4("false", {
            startsExpr: r6
        }),
        _in: u4("in", {
            beforeExpr: s5,
            binop: 7
        }),
        _instanceof: u4("instanceof", {
            beforeExpr: s5,
            binop: 7
        }),
        _typeof: u4("typeof", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        }),
        _void: u4("void", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        }),
        _delete: u4("delete", {
            beforeExpr: s5,
            prefix: n8,
            startsExpr: r6
        })
    }, p6 = 128, l5 = 128, d6 = 1024, D5 = 64, m5 = /\r\n?|[\n\u2028\u2029]/, f5 = new RegExp(m5.source, "g");
    function y6(t15) {
        switch(t15){
            case 10:
            case 13:
            case 8232:
            case 8233:
                return !0;
            default:
                return !1;
        }
    }
    const E5 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    function A5(t15) {
        switch(t15){
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
                return !0;
            default:
                return !1;
        }
    }
    class C5 {
        constructor(t15, e21){
            this.line = void 0, this.column = void 0, this.line = t15, this.column = e21;
        }
    }
    class x6 {
        constructor(t16, e22){
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t16, this.end = e22;
        }
    }
    function F4(t17) {
        return t17[t17.length - 1];
    }
    const g6 = Object.freeze({
        AccessorIsGenerator: "A %0ter cannot be a generator",
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
        AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions",
        BadGetterArity: "getter must not have any formal parameters",
        BadSetterArity: "setter must have exactly one formal parameter",
        BadSetterRestParameter: "setter function argument must not be a rest parameter",
        ConstructorClassField: "Classes may not have a field named 'constructor'",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
        ConstructorIsAccessor: "Class constructor may not be an accessor",
        ConstructorIsAsync: "Constructor can't be an async function",
        ConstructorIsGenerator: "Constructor can't be a generator",
        DeclarationMissingInitializer: "%0 require an initialization value",
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon",
        DecoratorStaticBlock: "Decorators can't be used with a static block",
        DeletePrivateField: "Deleting a private field is not allowed",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
        DuplicateProto: "Redefinition of __proto__ property",
        DuplicateRegExpFlags: "Duplicate regular expression flag",
        DuplicateStaticBlock: "Duplicate static block in the same class",
        ElementAfterRest: "Rest element must be last element",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape",
        ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { %0 as '%1' } from 'some-module'`?",
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
        ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
        IllegalBreakContinue: "Unsyntactic %0",
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
        IllegalReturn: "'return' outside of function",
        ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
        ImportCallArity: "import() requires exactly %0",
        ImportCallNotNewExpression: "Cannot use new with import(...)",
        ImportCallSpreadArgument: "... is not allowed in import()",
        ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
        ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
        InvalidBigIntLiteral: "Invalid BigIntLiteral",
        InvalidCodePoint: "Code point out of bounds",
        InvalidDecimal: "Invalid decimal",
        InvalidDigit: "Expected number in radix %0",
        InvalidEscapeSequence: "Bad character escape sequence",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
        InvalidEscapedReservedWord: "Escape sequence in keyword %0",
        InvalidIdentifier: "Invalid identifier %0",
        InvalidLhs: "Invalid left-hand side in %0",
        InvalidLhsBinding: "Binding invalid left-hand side in %0",
        InvalidNumber: "Invalid number",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'",
        InvalidOrUnexpectedToken: "Unexpected character '%0'",
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
        InvalidPrivateFieldResolution: "Private name #%0 is not defined",
        InvalidPropertyBindingPattern: "Binding member expression",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument",
        LabelRedeclaration: "Label '%0' is already declared",
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
        MalformedRegExpFlags: "Invalid regular expression flag",
        MissingClassName: "A class name is required",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
        ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
        ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'",
        ModuleExportUndefined: "Export '%0' is not defined",
        MultipleDefaultsInSwitch: "Multiple default clauses",
        NewlineAfterThrow: "Illegal newline after throw",
        NoCatchOrFinally: "Missing catch or finally clause",
        NumberIdentifier: "Identifier directly after number",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
        ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
        ParamDupe: "Argument name clash",
        PatternHasAccessor: "Object pattern can't contain getter or setter",
        PatternHasMethod: "Object pattern can't contain methods",
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
        PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
        PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
        PrivateNameRedeclaration: "Duplicate private name #%0",
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
        RecordNoProto: "'__proto__' is not allowed in Record expressions",
        RestTrailingComma: "Unexpected trailing comma after rest element",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
        StaticPrototype: "Classes may not have static property named prototype",
        StrictDelete: "Deleting local variable in strict mode",
        StrictEvalArguments: "Assigning to '%0' in strict mode",
        StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
        StrictWith: "'with' in strict mode",
        SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super",
        TrailingDecorator: "Decorators must be attached to a class element",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
        UnexpectedKeyword: "Unexpected keyword '%0'",
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
        UnexpectedNewTarget: "new.target can only be used in functions",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
        UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
        UnexpectedReservedWord: "Unexpected reserved word '%0'",
        UnexpectedSuper: "super is only allowed in object methods and classes",
        UnexpectedToken: "Unexpected token '%0'",
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "import can only be used in import() or import.meta",
        UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
        UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
        UnterminatedComment: "Unterminated comment",
        UnterminatedRegExp: "Unterminated regular expression",
        UnterminatedString: "Unterminated string constant",
        UnterminatedTemplate: "Unterminated template",
        VarRedeclaration: "Identifier '%0' has already been declared",
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
        YieldInParameter: "Yield expression is not allowed in formal parameters",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
    });
    function b4(t17) {
        return null != t17 && "Property" === t17.type && "init" === t17.kind && !1 === t17.method;
    }
    class P3 {
        constructor(t17, e23, s6, r7){
            this.token = void 0, this.isExpr = void 0, this.preserveSpace = void 0, this.override = void 0, this.token = t17, this.isExpr = !!e23, this.preserveSpace = !!s6, this.override = r7;
        }
    }
    const T5 = {
        braceStatement: new P3("{", !1),
        braceExpression: new P3("{", !0),
        recordExpression: new P3("#{", !0),
        templateQuasi: new P3("${", !1),
        parenStatement: new P3("(", !1),
        parenExpression: new P3("(", !0),
        template: new P3("`", !0, !0, (t18)=>t18.readTmplToken()
        ),
        functionExpression: new P3("function", !0),
        functionStatement: new P3("function", !1)
    };
    c6.parenR.updateContext = c6.braceR.updateContext = function() {
        if (1 === this.state.context.length) return void (this.state.exprAllowed = !0);
        let t18 = this.state.context.pop();
        t18 === T5.braceStatement && "function" === this.curContext().token && (t18 = this.state.context.pop()), this.state.exprAllowed = !t18.isExpr;
    }, c6.name.updateContext = function(t18) {
        let e24 = !1;
        t18 !== c6.dot && ("of" !== this.state.value || this.state.exprAllowed || t18 === c6._function || t18 === c6._class || (e24 = !0)), this.state.exprAllowed = e24, this.state.isIterator && (this.state.isIterator = !1);
    }, c6.braceL.updateContext = function(t18) {
        this.state.context.push(this.braceIsBlock(t18) ? T5.braceStatement : T5.braceExpression), this.state.exprAllowed = !0;
    }, c6.dollarBraceL.updateContext = function() {
        this.state.context.push(T5.templateQuasi), this.state.exprAllowed = !0;
    }, c6.parenL.updateContext = function(t18) {
        const e24 = t18 === c6._if || t18 === c6._for || t18 === c6._with || t18 === c6._while;
        this.state.context.push(e24 ? T5.parenStatement : T5.parenExpression), this.state.exprAllowed = !0;
    }, c6.incDec.updateContext = function() {
    }, c6._function.updateContext = c6._class.updateContext = function(t18) {
        !t18.beforeExpr || t18 === c6.semi || t18 === c6._else || t18 === c6._return && this.hasPrecedingLineBreak() || (t18 === c6.colon || t18 === c6.braceL) && this.curContext() === T5.b_stat ? this.state.context.push(T5.functionStatement) : this.state.context.push(T5.functionExpression), this.state.exprAllowed = !1;
    }, c6.backQuote.updateContext = function() {
        this.curContext() === T5.template ? this.state.context.pop() : this.state.context.push(T5.template), this.state.exprAllowed = !1;
    }, c6.braceHashL.updateContext = function() {
        this.state.context.push(T5.recordExpression), this.state.exprAllowed = !0;
    };
    let w4 = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc", B4 = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    const S4 = new RegExp("[" + w4 + "]"), N4 = new RegExp("[" + w4 + B4 + "]");
    w4 = B4 = null;
    const I5 = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ], v5 = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    function k6(t18, e24) {
        let s7 = 65536;
        for(let r8 = 0, i7 = e24.length; r8 < i7; r8 += 2){
            if ((s7 += e24[r8], s7 > t18)) return !1;
            if ((s7 += e24[r8 + 1], s7 >= t18)) return !0;
        }
        return !1;
    }
    function L3(t18) {
        return t18 < 65 ? 36 === t18 : t18 <= 90 || (t18 < 97 ? 95 === t18 : t18 <= 122 || (t18 <= 65535 ? t18 >= 170 && S4.test(String.fromCharCode(t18)) : k6(t18, I5)));
    }
    function O4(t18) {
        return t18 < 48 ? 36 === t18 : t18 < 58 || !(t18 < 65) && (t18 <= 90 || (t18 < 97 ? 95 === t18 : t18 <= 122 || (t18 <= 65535 ? t18 >= 170 && N4.test(String.fromCharCode(t18)) : k6(t18, I5) || k6(t18, v5))));
    }
    const M5 = [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ], R4 = [
        "eval",
        "arguments"
    ], _4 = new Set([
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ]), j5 = new Set(M5), U4 = new Set(R4);
    function q5(t18, e24) {
        return e24 && "await" === t18 || "enum" === t18;
    }
    function V4(t18, e24) {
        return q5(t18, e24) || j5.has(t18);
    }
    function z5(t18) {
        return U4.has(t18);
    }
    function H5(t18, e24) {
        return V4(t18, e24) || z5(t18);
    }
    function W3(t18) {
        return _4.has(t18);
    }
    const G4 = /^in(stanceof)?$/;
    const X4 = new Set([
        "_",
        "any",
        "bool",
        "boolean",
        "empty",
        "extends",
        "false",
        "interface",
        "mixed",
        "null",
        "number",
        "static",
        "string",
        "true",
        "typeof",
        "void"
    ]), K4 = Object.freeze({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
        AssignReservedType: "Cannot overwrite reserved type %0",
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
        EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
        EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
        EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
        EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
        EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
        EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
        EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
        EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
        EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
        InexactVariance: "Explicit inexact syntax cannot have variance",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment",
        OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
        SpreadVariance: "Spread properties cannot have variance",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
        UnexpectedReservedType: "Unexpected reserved type %0",
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`",
        UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
        UnterminatedFlowComment: "Unterminated flow-comment"
    });
    function J3(t18) {
        return "type" === t18.importKind || "typeof" === t18.importKind;
    }
    function $3(t18) {
        return (t18.type === c6.name || !!t18.type.keyword) && "from" !== t18.value;
    }
    const Y3 = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
    };
    const Q4 = /\*?\s*@((?:no)?flow)\b/;
    const Z5 = {
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xa0",
        iexcl: "\xa1",
        cent: "\xa2",
        pound: "\xa3",
        curren: "\xa4",
        yen: "\xa5",
        brvbar: "\xa6",
        sect: "\xa7",
        uml: "\xa8",
        copy: "\xa9",
        ordf: "\xaa",
        laquo: "\xab",
        not: "\xac",
        shy: "\xad",
        reg: "\xae",
        macr: "\xaf",
        deg: "\xb0",
        plusmn: "\xb1",
        sup2: "\xb2",
        sup3: "\xb3",
        acute: "\xb4",
        micro: "\xb5",
        para: "\xb6",
        middot: "\xb7",
        cedil: "\xb8",
        sup1: "\xb9",
        ordm: "\xba",
        raquo: "\xbb",
        frac14: "\xbc",
        frac12: "\xbd",
        frac34: "\xbe",
        iquest: "\xbf",
        Agrave: "\xc0",
        Aacute: "\xc1",
        Acirc: "\xc2",
        Atilde: "\xc3",
        Auml: "\xc4",
        Aring: "\xc5",
        AElig: "\xc6",
        Ccedil: "\xc7",
        Egrave: "\xc8",
        Eacute: "\xc9",
        Ecirc: "\xca",
        Euml: "\xcb",
        Igrave: "\xcc",
        Iacute: "\xcd",
        Icirc: "\xce",
        Iuml: "\xcf",
        ETH: "\xd0",
        Ntilde: "\xd1",
        Ograve: "\xd2",
        Oacute: "\xd3",
        Ocirc: "\xd4",
        Otilde: "\xd5",
        Ouml: "\xd6",
        times: "\xd7",
        Oslash: "\xd8",
        Ugrave: "\xd9",
        Uacute: "\xda",
        Ucirc: "\xdb",
        Uuml: "\xdc",
        Yacute: "\xdd",
        THORN: "\xde",
        szlig: "\xdf",
        agrave: "\xe0",
        aacute: "\xe1",
        acirc: "\xe2",
        atilde: "\xe3",
        auml: "\xe4",
        aring: "\xe5",
        aelig: "\xe6",
        ccedil: "\xe7",
        egrave: "\xe8",
        eacute: "\xe9",
        ecirc: "\xea",
        euml: "\xeb",
        igrave: "\xec",
        iacute: "\xed",
        icirc: "\xee",
        iuml: "\xef",
        eth: "\xf0",
        ntilde: "\xf1",
        ograve: "\xf2",
        oacute: "\xf3",
        ocirc: "\xf4",
        otilde: "\xf5",
        ouml: "\xf6",
        divide: "\xf7",
        oslash: "\xf8",
        ugrave: "\xf9",
        uacute: "\xfa",
        ucirc: "\xfb",
        uuml: "\xfc",
        yacute: "\xfd",
        thorn: "\xfe",
        yuml: "\xff",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02c6",
        tilde: "\u02dc",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039a",
        Lambda: "\u039b",
        Mu: "\u039c",
        Nu: "\u039d",
        Xi: "\u039e",
        Omicron: "\u039f",
        Pi: "\u03a0",
        Rho: "\u03a1",
        Sigma: "\u03a3",
        Tau: "\u03a4",
        Upsilon: "\u03a5",
        Phi: "\u03a6",
        Chi: "\u03a7",
        Psi: "\u03a8",
        Omega: "\u03a9",
        alpha: "\u03b1",
        beta: "\u03b2",
        gamma: "\u03b3",
        delta: "\u03b4",
        epsilon: "\u03b5",
        zeta: "\u03b6",
        eta: "\u03b7",
        theta: "\u03b8",
        iota: "\u03b9",
        kappa: "\u03ba",
        lambda: "\u03bb",
        mu: "\u03bc",
        nu: "\u03bd",
        xi: "\u03be",
        omicron: "\u03bf",
        pi: "\u03c0",
        rho: "\u03c1",
        sigmaf: "\u03c2",
        sigma: "\u03c3",
        tau: "\u03c4",
        upsilon: "\u03c5",
        phi: "\u03c6",
        chi: "\u03c7",
        psi: "\u03c8",
        omega: "\u03c9",
        thetasym: "\u03d1",
        upsih: "\u03d2",
        piv: "\u03d6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200c",
        zwj: "\u200d",
        lrm: "\u200e",
        rlm: "\u200f",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201a",
        ldquo: "\u201c",
        rdquo: "\u201d",
        bdquo: "\u201e",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203a",
        oline: "\u203e",
        frasl: "\u2044",
        euro: "\u20ac",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211c",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21b5",
        lArr: "\u21d0",
        uArr: "\u21d1",
        rArr: "\u21d2",
        dArr: "\u21d3",
        hArr: "\u21d4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220b",
        prod: "\u220f",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221a",
        prop: "\u221d",
        infin: "\u221e",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222a",
        int: "\u222b",
        there4: "\u2234",
        sim: "\u223c",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22a5",
        sdot: "\u22c5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230a",
        rfloor: "\u230b",
        lang: "\u2329",
        rang: "\u232a",
        loz: "\u25ca",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
    }, tt2 = /^[\da-fA-F]+$/, et3 = /^\d+$/, st3 = Object.freeze({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
        MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
        UnterminatedJsxContent: "Unterminated JSX contents",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function rt3(t18) {
        return !!t18 && ("JSXOpeningFragment" === t18.type || "JSXClosingFragment" === t18.type);
    }
    function it3(t18) {
        if ("JSXIdentifier" === t18.type) return t18.name;
        if ("JSXNamespacedName" === t18.type) return t18.namespace.name + ":" + t18.name.name;
        if ("JSXMemberExpression" === t18.type) return it3(t18.object) + "." + it3(t18.property);
        throw new Error("Node had unexpected type: " + t18.type);
    }
    T5.j_oTag = new P3("<tag", !1), T5.j_cTag = new P3("</tag", !1), T5.j_expr = new P3("<tag>...</tag>", !0, !0), c6.jsxName = new a5("jsxName"), c6.jsxText = new a5("jsxText", {
        beforeExpr: !0
    }), c6.jsxTagStart = new a5("jsxTagStart", {
        startsExpr: !0
    }), c6.jsxTagEnd = new a5("jsxTagEnd"), c6.jsxTagStart.updateContext = function() {
        this.state.context.push(T5.j_expr), this.state.context.push(T5.j_oTag), this.state.exprAllowed = !1;
    }, c6.jsxTagEnd.updateContext = function(t18) {
        const e24 = this.state.context.pop();
        e24 === T5.j_oTag && t18 === c6.slash || e24 === T5.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === T5.j_expr) : this.state.exprAllowed = !0;
    };
    class nt2 {
        constructor(t18){
            this.flags = void 0, this.var = [], this.lexical = [], this.functions = [], this.flags = t18;
        }
    }
    class at3 {
        constructor(t19, e24){
            this.scopeStack = [], this.undefinedExports = new Map, this.undefinedPrivateNames = new Map, this.raise = t19, this.inModule = e24;
        }
        get inFunction() {
            return (2 & this.currentVarScope().flags) > 0;
        }
        get allowSuper() {
            return (16 & this.currentThisScope().flags) > 0;
        }
        get allowDirectSuper() {
            return (32 & this.currentThisScope().flags) > 0;
        }
        get inClass() {
            return (64 & this.currentThisScope().flags) > 0;
        }
        get inNonArrowFunction() {
            return (2 & this.currentThisScope().flags) > 0;
        }
        get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(t) {
            return new nt2(t);
        }
        enter(t) {
            this.scopeStack.push(this.createScope(t));
        }
        exit() {
            this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(t) {
            return !!(2 & t.flags || !this.inModule && 1 & t.flags);
        }
        declareName(t, e, s) {
            let r8 = this.currentScope();
            if (8 & e || 16 & e) this.checkRedeclarationInScope(r8, t, e, s), 16 & e ? r8.functions.push(t) : r8.lexical.push(t), 8 & e && this.maybeExportDefined(r8, t);
            else if (4 & e) for(let i7 = this.scopeStack.length - 1; i7 >= 0 && (r8 = this.scopeStack[i7], this.checkRedeclarationInScope(r8, t, e, s), r8.var.push(t), this.maybeExportDefined(r8, t), !(131 & r8.flags)); --i7);
            this.inModule && 1 & r8.flags && this.undefinedExports.delete(t);
        }
        maybeExportDefined(t, e) {
            this.inModule && 1 & t.flags && this.undefinedExports.delete(e);
        }
        checkRedeclarationInScope(t, e, s, r) {
            this.isRedeclaredInScope(t, e, s) && this.raise(r, g6.VarRedeclaration, e);
        }
        isRedeclaredInScope(t, e, s) {
            return !!(1 & s) && (8 & s ? t.lexical.indexOf(e) > -1 || t.functions.indexOf(e) > -1 || t.var.indexOf(e) > -1 : 16 & s ? t.lexical.indexOf(e) > -1 || !this.treatFunctionsAsVarInScope(t) && t.var.indexOf(e) > -1 : t.lexical.indexOf(e) > -1 && !(8 & t.flags && t.lexical[0] === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.indexOf(e) > -1);
        }
        checkLocalExport(t) {
            -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && -1 === this.scopeStack[0].functions.indexOf(t.name) && this.undefinedExports.set(t.name, t.start);
        }
        currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScope() {
            for(let t20 = this.scopeStack.length - 1;; t20--){
                const e25 = this.scopeStack[t20];
                if (131 & e25.flags) return e25;
            }
        }
        currentThisScope() {
            for(let t20 = this.scopeStack.length - 1;; t20--){
                const e25 = this.scopeStack[t20];
                if ((131 & e25.flags || 64 & e25.flags) && !(4 & e25.flags)) return e25;
            }
        }
    }
    class ot3 extends nt2 {
        constructor(...t20){
            super(...t20), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], this.exportOnlyBindings = [];
        }
    }
    class ut3 extends at3 {
        createScope(t) {
            return new ot3(t);
        }
        declareName(t, e, s) {
            const r8 = this.currentScope();
            if (e & 1024) return this.maybeExportDefined(r8, t), void r8.exportOnlyBindings.push(t);
            super.declareName(...arguments), 2 & e && (1 & e || (this.checkRedeclarationInScope(r8, t, e, s), this.maybeExportDefined(r8, t)), r8.types.push(t)), 256 & e && r8.enums.push(t), 512 & e && r8.constEnums.push(t), e & 128 && r8.classes.push(t);
        }
        isRedeclaredInScope(t, e, s) {
            if (t.enums.indexOf(e) > -1) {
                if (256 & s) {
                    return !!(512 & s) !== t.constEnums.indexOf(e) > -1;
                }
                return !0;
            }
            return s & 128 && t.classes.indexOf(e) > -1 ? t.lexical.indexOf(e) > -1 && !!(1 & s) : !!(2 & s && t.types.indexOf(e) > -1) || super.isRedeclaredInScope(...arguments);
        }
        checkLocalExport(t) {
            -1 === this.scopeStack[0].types.indexOf(t.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(t.name) && super.checkLocalExport(t);
        }
    }
    class ht3 {
        constructor(){
            this.stacks = [];
        }
        enter(t) {
            this.stacks.push(t);
        }
        exit() {
            this.stacks.pop();
        }
        currentFlags() {
            return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
            return (2 & this.currentFlags()) > 0;
        }
        get hasYield() {
            return (1 & this.currentFlags()) > 0;
        }
        get hasReturn() {
            return (4 & this.currentFlags()) > 0;
        }
        get hasIn() {
            return (8 & this.currentFlags()) > 0;
        }
    }
    function ct2(t21, e25) {
        return (t21 ? 2 : 0) | (e25 ? 1 : 0);
    }
    function pt3(t21) {
        if (null == t21) throw new Error("Unexpected ".concat(t21, " value."));
        return t21;
    }
    function lt3(t21) {
        if (!t21) throw new Error("Assert fail");
    }
    const dt3 = Object.freeze({
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateModifier: "Duplicate modifier: '%0'",
        EmptyHeritageClauseType: "'%0' list cannot be empty.",
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
        IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
    });
    c6.placeholder = new a5("%%", {
        startsExpr: !0
    });
    function Dt3(t21, e25) {
        return t21.some((t22)=>Array.isArray(t22) ? t22[0] === e25 : t22 === e25
        );
    }
    function mt2(t21, e25, s7) {
        const r8 = t21.find((t22)=>Array.isArray(t22) ? t22[0] === e25 : t22 === e25
        );
        return r8 && Array.isArray(r8) ? r8[1][s7] : null;
    }
    const ft3 = [
        "minimal",
        "smart",
        "fsharp"
    ], yt2 = [
        "hash",
        "bar"
    ];
    const Et2 = {
        estree: (t21)=>class extends t21 {
                estreeParseRegExpLiteral({ pattern: t , flags: e  }) {
                    let s7 = null;
                    try {
                        s7 = new RegExp(t, e);
                    } catch (t) {
                    }
                    const r8 = this.estreeParseLiteral(s7);
                    return r8.regex = {
                        pattern: t,
                        flags: e
                    }, r8;
                }
                estreeParseBigIntLiteral(t) {
                    const e25 = "undefined" != typeof BigInt ? BigInt(t) : null, s7 = this.estreeParseLiteral(e25);
                    return s7.bigint = String(s7.value || t), s7;
                }
                estreeParseDecimalLiteral(t) {
                    const e25 = this.estreeParseLiteral(null);
                    return e25.decimal = String(e25.value || t), e25;
                }
                estreeParseLiteral(t) {
                    return this.parseLiteral(t, "Literal");
                }
                directiveToStmt(t) {
                    const e25 = t.value, s7 = this.startNodeAt(t.start, t.loc.start), r8 = this.startNodeAt(e25.start, e25.loc.start);
                    return r8.value = e25.value, r8.raw = e25.extra.raw, s7.expression = this.finishNodeAt(r8, "Literal", e25.end, e25.loc.end), s7.directive = e25.extra.raw.slice(1, -1), this.finishNodeAt(s7, "ExpressionStatement", t.end, t.loc.end);
                }
                initFunction(t, e) {
                    super.initFunction(t, e), t.expression = !1;
                }
                checkDeclaration(t) {
                    b4(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t);
                }
                getObjectOrClassMethodParams(t) {
                    return t.value.params;
                }
                checkLVal(t, e = 64, s, r, i) {
                    switch(t.type){
                        case "ObjectPattern":
                            t.properties.forEach((t22)=>{
                                this.checkLVal("Property" === t22.type ? t22.value : t22, e, s, "object destructuring pattern", i);
                            });
                            break;
                        default:
                            super.checkLVal(t, e, s, r, i);
                    }
                }
                checkProto(t, e, s, r) {
                    t.method || super.checkProto(t, e, s, r);
                }
                isValidDirective(t) {
                    var e25;
                    return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && !(null == (e25 = t.expression.extra) ? void 0 : e25.parenthesized);
                }
                stmtToDirective(t) {
                    const e25 = super.stmtToDirective(t), s7 = t.expression.value;
                    return e25.value.value = s7, e25;
                }
                parseBlockBody(t, e, s, r) {
                    super.parseBlockBody(t, e, s, r);
                    const i7 = t.directives.map((t22)=>this.directiveToStmt(t22)
                    );
                    t.body = i7.concat(t.body), delete t.directives;
                }
                pushClassMethod(t, e, s, r, i, n) {
                    this.parseMethod(e, s, r, i, n, "ClassMethod", !0), e.typeParameters && (e.value.typeParameters = e.typeParameters, delete e.typeParameters), t.body.push(e);
                }
                parseExprAtom(t) {
                    switch(this.state.type){
                        case c6.num:
                        case c6.string:
                            return this.estreeParseLiteral(this.state.value);
                        case c6.regexp:
                            return this.estreeParseRegExpLiteral(this.state.value);
                        case c6.bigint:
                            return this.estreeParseBigIntLiteral(this.state.value);
                        case c6.decimal:
                            return this.estreeParseDecimalLiteral(this.state.value);
                        case c6._null:
                            return this.estreeParseLiteral(null);
                        case c6._true:
                            return this.estreeParseLiteral(!0);
                        case c6._false:
                            return this.estreeParseLiteral(!1);
                        default:
                            return super.parseExprAtom(t);
                    }
                }
                parseLiteral(t, e, s, r) {
                    const i7 = super.parseLiteral(t, e, s, r);
                    return i7.raw = i7.extra.raw, delete i7.extra, i7;
                }
                parseFunctionBody(t, e, s = !1) {
                    super.parseFunctionBody(t, e, s), t.expression = "BlockStatement" !== t.body.type;
                }
                parseMethod(t, e, s, r, i, n, a = !1) {
                    let o6 = this.startNode();
                    return o6.kind = t.kind, o6 = super.parseMethod(o6, e, s, r, i, n, a), o6.type = "FunctionExpression", delete o6.kind, t.value = o6, n = "ClassMethod" === n ? "MethodDefinition" : n, this.finishNode(t, n);
                }
                parseObjectMethod(t, e, s, r, i) {
                    const n9 = super.parseObjectMethod(t, e, s, r, i);
                    return n9 && (n9.type = "Property", "method" === n9.kind && (n9.kind = "init"), n9.shorthand = !1), n9;
                }
                parseObjectProperty(t, e, s, r, i) {
                    const n9 = super.parseObjectProperty(t, e, s, r, i);
                    return n9 && (n9.kind = "init", n9.type = "Property"), n9;
                }
                toAssignable(t) {
                    return b4(t) ? (this.toAssignable(t.value), t) : super.toAssignable(t);
                }
                toAssignableObjectExpressionProp(t, e) {
                    if ("get" === t.kind || "set" === t.kind) throw this.raise(t.key.start, g6.PatternHasAccessor);
                    if (t.method) throw this.raise(t.key.start, g6.PatternHasMethod);
                    super.toAssignableObjectExpressionProp(t, e);
                }
                finishCallExpression(t, e) {
                    return super.finishCallExpression(t, e), "Import" === t.callee.type && (t.type = "ImportExpression", t.source = t.arguments[0], delete t.arguments, delete t.callee), t;
                }
                toReferencedArguments(t) {
                    "ImportExpression" !== t.type && super.toReferencedArguments(t);
                }
                parseExport(t) {
                    switch(super.parseExport(t), t.type){
                        case "ExportAllDeclaration":
                            t.exported = null;
                            break;
                        case "ExportNamedDeclaration":
                            1 === t.specifiers.length && "ExportNamespaceSpecifier" === t.specifiers[0].type && (t.type = "ExportAllDeclaration", t.exported = t.specifiers[0].exported, delete t.specifiers);
                    }
                    return t;
                }
                parseSubscript(t, e, s, r, i) {
                    const n9 = super.parseSubscript(t, e, s, r, i);
                    if (i.optionalChainMember) {
                        if ("OptionalMemberExpression" !== n9.type && "OptionalCallExpression" !== n9.type || (n9.type = n9.type.substring(8)), i.stop) {
                            const t22 = this.startNodeAtNode(n9);
                            return t22.expression = n9, this.finishNode(t22, "ChainExpression");
                        }
                    } else "MemberExpression" !== n9.type && "CallExpression" !== n9.type || (n9.optional = !1);
                    return n9;
                }
            }
        ,
        jsx: (t21)=>class extends t21 {
                jsxReadToken() {
                    let t22 = "", e25 = this.state.pos;
                    for(;;){
                        if (this.state.pos >= this.length) throw this.raise(this.state.start, st3.UnterminatedJsxContent);
                        const s7 = this.input.charCodeAt(this.state.pos);
                        switch(s7){
                            case 60:
                            case 123:
                                return this.state.pos === this.state.start ? 60 === s7 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(c6.jsxTagStart)) : super.getTokenFromCode(s7) : (t22 += this.input.slice(e25, this.state.pos), this.finishToken(c6.jsxText, t22));
                            case 38:
                                t22 += this.input.slice(e25, this.state.pos), t22 += this.jsxReadEntity(), e25 = this.state.pos;
                                break;
                            default:
                                y6(s7) ? (t22 += this.input.slice(e25, this.state.pos), t22 += this.jsxReadNewLine(!0), e25 = this.state.pos) : ++this.state.pos;
                        }
                    }
                }
                jsxReadNewLine(t) {
                    const e25 = this.input.charCodeAt(this.state.pos);
                    let s7;
                    return ++this.state.pos, 13 === e25 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, s7 = t ? "\n" : "\r\n") : s7 = String.fromCharCode(e25), ++this.state.curLine, this.state.lineStart = this.state.pos, s7;
                }
                jsxReadString(t) {
                    let e25 = "", s7 = ++this.state.pos;
                    for(;;){
                        if (this.state.pos >= this.length) throw this.raise(this.state.start, g6.UnterminatedString);
                        const r8 = this.input.charCodeAt(this.state.pos);
                        if (r8 === t) break;
                        38 === r8 ? (e25 += this.input.slice(s7, this.state.pos), e25 += this.jsxReadEntity(), s7 = this.state.pos) : y6(r8) ? (e25 += this.input.slice(s7, this.state.pos), e25 += this.jsxReadNewLine(!1), s7 = this.state.pos) : ++this.state.pos;
                    }
                    return e25 += this.input.slice(s7, this.state.pos++), this.finishToken(c6.string, e25);
                }
                jsxReadEntity() {
                    let t22, e25 = "", s7 = 0, r8 = this.input[this.state.pos];
                    const i7 = ++this.state.pos;
                    for(; this.state.pos < this.length && (s7++) < 10;){
                        if (r8 = this.input[this.state.pos++], ";" === r8) {
                            "#" === e25[0] ? "x" === e25[1] ? (e25 = e25.substr(2), tt2.test(e25) && (t22 = String.fromCodePoint(parseInt(e25, 16)))) : (e25 = e25.substr(1), et3.test(e25) && (t22 = String.fromCodePoint(parseInt(e25, 10)))) : t22 = Z5[e25];
                            break;
                        }
                        e25 += r8;
                    }
                    return t22 || (this.state.pos = i7, "&");
                }
                jsxReadWord() {
                    let t22;
                    const e25 = this.state.pos;
                    do {
                        t22 = this.input.charCodeAt(++this.state.pos);
                    }while (O4(t22) || 45 === t22)
                    return this.finishToken(c6.jsxName, this.input.slice(e25, this.state.pos));
                }
                jsxParseIdentifier() {
                    const t22 = this.startNode();
                    return this.match(c6.jsxName) ? t22.name = this.state.value : this.state.type.keyword ? t22.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t22, "JSXIdentifier");
                }
                jsxParseNamespacedName() {
                    const t22 = this.state.start, e25 = this.state.startLoc, s7 = this.jsxParseIdentifier();
                    if (!this.eat(c6.colon)) return s7;
                    const r8 = this.startNodeAt(t22, e25);
                    return r8.namespace = s7, r8.name = this.jsxParseIdentifier(), this.finishNode(r8, "JSXNamespacedName");
                }
                jsxParseElementName() {
                    const t22 = this.state.start, e25 = this.state.startLoc;
                    let s7 = this.jsxParseNamespacedName();
                    if ("JSXNamespacedName" === s7.type) return s7;
                    for(; this.eat(c6.dot);){
                        const r8 = this.startNodeAt(t22, e25);
                        r8.object = s7, r8.property = this.jsxParseIdentifier(), s7 = this.finishNode(r8, "JSXMemberExpression");
                    }
                    return s7;
                }
                jsxParseAttributeValue() {
                    let t22;
                    switch(this.state.type){
                        case c6.braceL:
                            return t22 = this.startNode(), this.next(), t22 = this.jsxParseExpressionContainer(t22), "JSXEmptyExpression" === t22.expression.type && this.raise(t22.start, st3.AttributeIsEmpty), t22;
                        case c6.jsxTagStart:
                        case c6.string:
                            return this.parseExprAtom();
                        default:
                            throw this.raise(this.state.start, st3.UnsupportedJsxValue);
                    }
                }
                jsxParseEmptyExpression() {
                    const t22 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
                    return this.finishNodeAt(t22, "JSXEmptyExpression", this.state.start, this.state.startLoc);
                }
                jsxParseSpreadChild(t) {
                    return this.next(), t.expression = this.parseExpression(), this.expect(c6.braceR), this.finishNode(t, "JSXSpreadChild");
                }
                jsxParseExpressionContainer(t) {
                    return this.match(c6.braceR) ? t.expression = this.jsxParseEmptyExpression() : t.expression = this.parseExpression(), this.expect(c6.braceR), this.finishNode(t, "JSXExpressionContainer");
                }
                jsxParseAttribute() {
                    const t22 = this.startNode();
                    return this.eat(c6.braceL) ? (this.expect(c6.ellipsis), t22.argument = this.parseMaybeAssignAllowIn(), this.expect(c6.braceR), this.finishNode(t22, "JSXSpreadAttribute")) : (t22.name = this.jsxParseNamespacedName(), t22.value = this.eat(c6.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t22, "JSXAttribute"));
                }
                jsxParseOpeningElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    return this.match(c6.jsxTagEnd) ? (this.expect(c6.jsxTagEnd), this.finishNode(s7, "JSXOpeningFragment")) : (s7.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s7));
                }
                jsxParseOpeningElementAfterName(t) {
                    const e25 = [];
                    for(; !this.match(c6.slash) && !this.match(c6.jsxTagEnd);)e25.push(this.jsxParseAttribute());
                    return t.attributes = e25, t.selfClosing = this.eat(c6.slash), this.expect(c6.jsxTagEnd), this.finishNode(t, "JSXOpeningElement");
                }
                jsxParseClosingElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    return this.match(c6.jsxTagEnd) ? (this.expect(c6.jsxTagEnd), this.finishNode(s7, "JSXClosingFragment")) : (s7.name = this.jsxParseElementName(), this.expect(c6.jsxTagEnd), this.finishNode(s7, "JSXClosingElement"));
                }
                jsxParseElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e), r8 = [], i7 = this.jsxParseOpeningElementAt(t, e);
                    let n9 = null;
                    if (!i7.selfClosing) {
                        t: for(;;)switch(this.state.type){
                            case c6.jsxTagStart:
                                if (t = this.state.start, e = this.state.startLoc, this.next(), this.eat(c6.slash)) {
                                    n9 = this.jsxParseClosingElementAt(t, e);
                                    break t;
                                }
                                r8.push(this.jsxParseElementAt(t, e));
                                break;
                            case c6.jsxText:
                                r8.push(this.parseExprAtom());
                                break;
                            case c6.braceL:
                                {
                                    const t22 = this.startNode();
                                    this.next(), this.match(c6.ellipsis) ? r8.push(this.jsxParseSpreadChild(t22)) : r8.push(this.jsxParseExpressionContainer(t22));
                                    break;
                                }
                            default:
                                throw this.unexpected();
                        }
                        rt3(i7) && !rt3(n9) ? this.raise(n9.start, st3.MissingClosingTagFragment) : !rt3(i7) && rt3(n9) ? this.raise(n9.start, st3.MissingClosingTagElement, it3(i7.name)) : rt3(i7) || rt3(n9) || it3(n9.name) !== it3(i7.name) && this.raise(n9.start, st3.MissingClosingTagElement, it3(i7.name));
                    }
                    if (rt3(i7) ? (s7.openingFragment = i7, s7.closingFragment = n9) : (s7.openingElement = i7, s7.closingElement = n9), s7.children = r8, this.isRelational("<")) throw this.raise(this.state.start, st3.UnwrappedAdjacentJSXElements);
                    return rt3(i7) ? this.finishNode(s7, "JSXFragment") : this.finishNode(s7, "JSXElement");
                }
                jsxParseElement() {
                    const t22 = this.state.start, e25 = this.state.startLoc;
                    return this.next(), this.jsxParseElementAt(t22, e25);
                }
                parseExprAtom(t) {
                    return this.match(c6.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(c6.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(c6.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(t);
                }
                getTokenFromCode(t) {
                    if (this.state.inPropertyName) return super.getTokenFromCode(t);
                    const e25 = this.curContext();
                    if (e25 === T5.j_expr) return this.jsxReadToken();
                    if (e25 === T5.j_oTag || e25 === T5.j_cTag) {
                        if (L3(t)) return this.jsxReadWord();
                        if (62 === t) return ++this.state.pos, this.finishToken(c6.jsxTagEnd);
                        if ((34 === t || 39 === t) && e25 === T5.j_oTag) return this.jsxReadString(t);
                    }
                    return 60 === t && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(c6.jsxTagStart)) : super.getTokenFromCode(t);
                }
                updateContext(t) {
                    if (this.match(c6.braceL)) {
                        const e25 = this.curContext();
                        e25 === T5.j_oTag ? this.state.context.push(T5.braceExpression) : e25 === T5.j_expr ? this.state.context.push(T5.templateQuasi) : super.updateContext(t), this.state.exprAllowed = !0;
                    } else {
                        if (!this.match(c6.slash) || t !== c6.jsxTagStart) return super.updateContext(t);
                        this.state.context.length -= 2, this.state.context.push(T5.j_cTag), this.state.exprAllowed = !1;
                    }
                }
            }
        ,
        flow: (t21)=>class extends t21 {
                constructor(t22, e25){
                    super(t22, e25), this.flowPragma = void 0, this.flowPragma = void 0;
                }
                shouldParseTypes() {
                    return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
                }
                shouldParseEnums() {
                    return !!this.getPluginOption("flow", "enums");
                }
                finishToken(t, e) {
                    return t !== c6.string && t !== c6.semi && t !== c6.interpreterDirective && (void 0) === this.flowPragma && (this.flowPragma = null), super.finishToken(t, e);
                }
                addComment(t) {
                    if ((void 0) === this.flowPragma) {
                        const e26 = Q4.exec(t.value);
                        if (e26) {
                            if ("flow" === e26[1]) this.flowPragma = "flow";
                            else {
                                if ("noflow" !== e26[1]) throw new Error("Unexpected flow pragma");
                                this.flowPragma = "noflow";
                            }
                        } else ;
                    }
                    return super.addComment(t);
                }
                flowParseTypeInitialiser(t) {
                    const e26 = this.state.inType;
                    this.state.inType = !0, this.expect(t || c6.colon);
                    const s7 = this.flowParseType();
                    return this.state.inType = e26, s7;
                }
                flowParsePredicate() {
                    const t23 = this.startNode(), e26 = this.state.startLoc, s7 = this.state.start;
                    this.expect(c6.modulo);
                    const r8 = this.state.startLoc;
                    return this.expectContextual("checks"), e26.line === r8.line && e26.column === r8.column - 1 || this.raise(s7, K4.UnexpectedSpaceBetweenModuloChecks), this.eat(c6.parenL) ? (t23.value = this.parseExpression(), this.expect(c6.parenR), this.finishNode(t23, "DeclaredPredicate")) : this.finishNode(t23, "InferredPredicate");
                }
                flowParseTypeAndPredicateInitialiser() {
                    const t23 = this.state.inType;
                    this.state.inType = !0, this.expect(c6.colon);
                    let e26 = null, s7 = null;
                    return this.match(c6.modulo) ? (this.state.inType = t23, s7 = this.flowParsePredicate()) : (e26 = this.flowParseType(), this.state.inType = t23, this.match(c6.modulo) && (s7 = this.flowParsePredicate())), [
                        e26,
                        s7
                    ];
                }
                flowParseDeclareClass(t) {
                    return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, "DeclareClass");
                }
                flowParseDeclareFunction(t) {
                    this.next();
                    const e26 = t.id = this.parseIdentifier(), s7 = this.startNode(), r8 = this.startNode();
                    this.isRelational("<") ? s7.typeParameters = this.flowParseTypeParameterDeclaration() : s7.typeParameters = null, this.expect(c6.parenL);
                    const i7 = this.flowParseFunctionTypeParams();
                    return s7.params = i7.params, s7.rest = i7.rest, this.expect(c6.parenR), [s7.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), r8.typeAnnotation = this.finishNode(s7, "FunctionTypeAnnotation"), e26.typeAnnotation = this.finishNode(r8, "TypeAnnotation"), this.resetEndLocation(e26), this.semicolon(), this.finishNode(t, "DeclareFunction");
                }
                flowParseDeclare(t, e) {
                    if (this.match(c6._class)) return this.flowParseDeclareClass(t);
                    if (this.match(c6._function)) return this.flowParseDeclareFunction(t);
                    if (this.match(c6._var)) return this.flowParseDeclareVariable(t);
                    if (this.eatContextual("module")) return this.match(c6.dot) ? this.flowParseDeclareModuleExports(t) : (e && this.raise(this.state.lastTokStart, K4.NestedDeclareModule), this.flowParseDeclareModule(t));
                    if (this.isContextual("type")) return this.flowParseDeclareTypeAlias(t);
                    if (this.isContextual("opaque")) return this.flowParseDeclareOpaqueType(t);
                    if (this.isContextual("interface")) return this.flowParseDeclareInterface(t);
                    if (this.match(c6._export)) return this.flowParseDeclareExportDeclaration(t, e);
                    throw this.unexpected();
                }
                flowParseDeclareVariable(t) {
                    return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, 5, t.id.start), this.semicolon(), this.finishNode(t, "DeclareVariable");
                }
                flowParseDeclareModule(t) {
                    this.scope.enter(0), this.match(c6.string) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier();
                    const e26 = t.body = this.startNode(), s7 = e26.body = [];
                    for(this.expect(c6.braceL); !this.match(c6.braceR);){
                        let t23 = this.startNode();
                        this.match(c6._import) ? (this.next(), this.isContextual("type") || this.match(c6._typeof) || this.raise(this.state.lastTokStart, K4.InvalidNonTypeImportInDeclareModule), this.parseImport(t23)) : (this.expectContextual("declare", K4.UnsupportedStatementInDeclareModule), t23 = this.flowParseDeclare(t23, !0)), s7.push(t23);
                    }
                    this.scope.exit(), this.expect(c6.braceR), this.finishNode(e26, "BlockStatement");
                    let r8 = null, i7 = !1;
                    return s7.forEach((t23)=>{
                        !(function(t24) {
                            return "DeclareExportAllDeclaration" === t24.type || "DeclareExportDeclaration" === t24.type && (!t24.declaration || "TypeAlias" !== t24.declaration.type && "InterfaceDeclaration" !== t24.declaration.type);
                        })(t23) ? "DeclareModuleExports" === t23.type && (i7 && this.raise(t23.start, K4.DuplicateDeclareModuleExports), "ES" === r8 && this.raise(t23.start, K4.AmbiguousDeclareModuleKind), r8 = "CommonJS", i7 = !0) : ("CommonJS" === r8 && this.raise(t23.start, K4.AmbiguousDeclareModuleKind), r8 = "ES");
                    }), t.kind = r8 || "CommonJS", this.finishNode(t, "DeclareModule");
                }
                flowParseDeclareExportDeclaration(t, e) {
                    if (this.expect(c6._export), this.eat(c6._default)) return this.match(c6._function) || this.match(c6._class) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(c6._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !e) {
                        const t23 = this.state.value, e26 = Y3[t23];
                        throw this.raise(this.state.start, K4.UnsupportedDeclareExportKind, t23, e26);
                    }
                    if (this.match(c6._var) || this.match(c6._function) || this.match(c6._class) || this.isContextual("opaque")) return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(c6.star) || this.match(c6.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) return "ExportNamedDeclaration" === (t = this.parseExport(t)).type && (t.type = "ExportDeclaration", t.default = !1, delete t.exportKind), t.type = "Declare" + t.type, t;
                    throw this.unexpected();
                }
                flowParseDeclareModuleExports(t) {
                    return this.next(), this.expectContextual("exports"), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, "DeclareModuleExports");
                }
                flowParseDeclareTypeAlias(t) {
                    return this.next(), this.flowParseTypeAlias(t), t.type = "DeclareTypeAlias", t;
                }
                flowParseDeclareOpaqueType(t) {
                    return this.next(), this.flowParseOpaqueType(t, !0), t.type = "DeclareOpaqueType", t;
                }
                flowParseDeclareInterface(t) {
                    return this.next(), this.flowParseInterfaceish(t), this.finishNode(t, "DeclareInterface");
                }
                flowParseInterfaceish(t, e = !1) {
                    if (t.id = this.flowParseRestrictedIdentifier(!e, !0), this.scope.declareName(t.id.name, e ? 17 : 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], t.implements = [], t.mixins = [], this.eat(c6._extends)) do {
                        t.extends.push(this.flowParseInterfaceExtends());
                    }while (!e && this.eat(c6.comma))
                    if (this.isContextual("mixins")) {
                        this.next();
                        do {
                            t.mixins.push(this.flowParseInterfaceExtends());
                        }while (this.eat(c6.comma))
                    }
                    if (this.isContextual("implements")) {
                        this.next();
                        do {
                            t.implements.push(this.flowParseInterfaceExtends());
                        }while (this.eat(c6.comma))
                    }
                    t.body = this.flowParseObjectType({
                        allowStatic: e,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: e,
                        allowInexact: !1
                    });
                }
                flowParseInterfaceExtends() {
                    const t23 = this.startNode();
                    return t23.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? t23.typeParameters = this.flowParseTypeParameterInstantiation() : t23.typeParameters = null, this.finishNode(t23, "InterfaceExtends");
                }
                flowParseInterface(t) {
                    return this.flowParseInterfaceish(t), this.finishNode(t, "InterfaceDeclaration");
                }
                checkNotUnderscore(t) {
                    "_" === t && this.raise(this.state.start, K4.UnexpectedReservedUnderscore);
                }
                checkReservedType(t, e, s) {
                    X4.has(t) && this.raise(e, s ? K4.AssignReservedType : K4.UnexpectedReservedType, t);
                }
                flowParseRestrictedIdentifier(t, e) {
                    return this.checkReservedType(this.state.value, this.state.start, e), this.parseIdentifier(t);
                }
                flowParseTypeAlias(t) {
                    return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(c6.eq), this.semicolon(), this.finishNode(t, "TypeAlias");
                }
                flowParseOpaqueType(t, e) {
                    return this.expectContextual("type"), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(c6.colon) && (t.supertype = this.flowParseTypeInitialiser(c6.colon)), t.impltype = null, e || (t.impltype = this.flowParseTypeInitialiser(c6.eq)), this.semicolon(), this.finishNode(t, "OpaqueType");
                }
                flowParseTypeParameter(t = !1) {
                    const e26 = this.state.start, s7 = this.startNode(), r8 = this.flowParseVariance(), i7 = this.flowParseTypeAnnotatableIdentifier();
                    return s7.name = i7.name, s7.variance = r8, s7.bound = i7.typeAnnotation, this.match(c6.eq) ? (this.eat(c6.eq), s7.default = this.flowParseType()) : t && this.raise(e26, K4.MissingTypeParamDefault), this.finishNode(s7, "TypeParameter");
                }
                flowParseTypeParameterDeclaration() {
                    const t23 = this.state.inType, e26 = this.startNode();
                    e26.params = [], this.state.inType = !0, this.isRelational("<") || this.match(c6.jsxTagStart) ? this.next() : this.unexpected();
                    let s7 = !1;
                    do {
                        const t24 = this.flowParseTypeParameter(s7);
                        e26.params.push(t24), t24.default && (s7 = !0), this.isRelational(">") || this.expect(c6.comma);
                    }while (!this.isRelational(">"))
                    return this.expectRelational(">"), this.state.inType = t23, this.finishNode(e26, "TypeParameterDeclaration");
                }
                flowParseTypeParameterInstantiation() {
                    const t23 = this.startNode(), e26 = this.state.inType;
                    t23.params = [], this.state.inType = !0, this.expectRelational("<");
                    const s7 = this.state.noAnonFunctionType;
                    for(this.state.noAnonFunctionType = !1; !this.isRelational(">");)t23.params.push(this.flowParseType()), this.isRelational(">") || this.expect(c6.comma);
                    return this.state.noAnonFunctionType = s7, this.expectRelational(">"), this.state.inType = e26, this.finishNode(t23, "TypeParameterInstantiation");
                }
                flowParseTypeParameterInstantiationCallOrNew() {
                    const t23 = this.startNode(), e26 = this.state.inType;
                    for(t23.params = [], this.state.inType = !0, this.expectRelational("<"); !this.isRelational(">");)t23.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(c6.comma);
                    return this.expectRelational(">"), this.state.inType = e26, this.finishNode(t23, "TypeParameterInstantiation");
                }
                flowParseInterfaceType() {
                    const t23 = this.startNode();
                    if (this.expectContextual("interface"), t23.extends = [], this.eat(c6._extends)) do {
                        t23.extends.push(this.flowParseInterfaceExtends());
                    }while (this.eat(c6.comma))
                    return t23.body = this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: !1,
                        allowInexact: !1
                    }), this.finishNode(t23, "InterfaceTypeAnnotation");
                }
                flowParseObjectPropertyKey() {
                    return this.match(c6.num) || this.match(c6.string) ? this.parseExprAtom() : this.parseIdentifier(!0);
                }
                flowParseObjectTypeIndexer(t, e, s) {
                    return t.static = e, this.lookahead().type === c6.colon ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(c6.bracketR), t.value = this.flowParseTypeInitialiser(), t.variance = s, this.finishNode(t, "ObjectTypeIndexer");
                }
                flowParseObjectTypeInternalSlot(t, e) {
                    return t.static = e, t.id = this.flowParseObjectPropertyKey(), this.expect(c6.bracketR), this.expect(c6.bracketR), this.isRelational("<") || this.match(c6.parenL) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1, this.eat(c6.question) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, "ObjectTypeInternalSlot");
                }
                flowParseObjectTypeMethodish(t) {
                    for(t.params = [], t.rest = null, t.typeParameters = null, this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(c6.parenL); !this.match(c6.parenR) && !this.match(c6.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()), this.match(c6.parenR) || this.expect(c6.comma);
                    return this.eat(c6.ellipsis) && (t.rest = this.flowParseFunctionTypeParam()), this.expect(c6.parenR), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, "FunctionTypeAnnotation");
                }
                flowParseObjectTypeCallProperty(t, e) {
                    const s7 = this.startNode();
                    return t.static = e, t.value = this.flowParseObjectTypeMethodish(s7), this.finishNode(t, "ObjectTypeCallProperty");
                }
                flowParseObjectType({ allowStatic: t , allowExact: e , allowSpread: s , allowProto: r , allowInexact: i  }) {
                    const n9 = this.state.inType;
                    this.state.inType = !0;
                    const a6 = this.startNode();
                    let o6, u5;
                    a6.callProperties = [], a6.properties = [], a6.indexers = [], a6.internalSlots = [];
                    let h6 = !1;
                    for(e && this.match(c6.braceBarL) ? (this.expect(c6.braceBarL), o6 = c6.braceBarR, u5 = !0) : (this.expect(c6.braceL), o6 = c6.braceR, u5 = !1), a6.exact = u5; !this.match(o6);){
                        let e26 = !1, n10 = null, o7 = null;
                        const p7 = this.startNode();
                        if (r && this.isContextual("proto")) {
                            const e27 = this.lookahead();
                            e27.type !== c6.colon && e27.type !== c6.question && (this.next(), n10 = this.state.start, t = !1);
                        }
                        if (t && this.isContextual("static")) {
                            const t23 = this.lookahead();
                            t23.type !== c6.colon && t23.type !== c6.question && (this.next(), e26 = !0);
                        }
                        const l6 = this.flowParseVariance();
                        if (this.eat(c6.bracketL)) null != n10 && this.unexpected(n10), this.eat(c6.bracketL) ? (l6 && this.unexpected(l6.start), a6.internalSlots.push(this.flowParseObjectTypeInternalSlot(p7, e26))) : a6.indexers.push(this.flowParseObjectTypeIndexer(p7, e26, l6));
                        else if (this.match(c6.parenL) || this.isRelational("<")) null != n10 && this.unexpected(n10), l6 && this.unexpected(l6.start), a6.callProperties.push(this.flowParseObjectTypeCallProperty(p7, e26));
                        else {
                            let t23 = "init";
                            if (this.isContextual("get") || this.isContextual("set")) {
                                const e27 = this.lookahead();
                                e27.type !== c6.name && e27.type !== c6.string && e27.type !== c6.num || (t23 = this.state.value, this.next());
                            }
                            const r8 = this.flowParseObjectTypeProperty(p7, e26, n10, l6, t23, s, null != i ? i : !u5);
                            null === r8 ? (h6 = !0, o7 = this.state.lastTokStart) : a6.properties.push(r8);
                        }
                        this.flowObjectTypeSemicolon(), !o7 || this.match(c6.braceR) || this.match(c6.braceBarR) || this.raise(o7, K4.UnexpectedExplicitInexactInObject);
                    }
                    this.expect(o6), s && (a6.inexact = h6);
                    const p7 = this.finishNode(a6, "ObjectTypeAnnotation");
                    return this.state.inType = n9, p7;
                }
                flowParseObjectTypeProperty(t, e, s, r, i, n, a) {
                    if (this.eat(c6.ellipsis)) {
                        return this.match(c6.comma) || this.match(c6.semi) || this.match(c6.braceR) || this.match(c6.braceBarR) ? (n ? a || this.raise(this.state.lastTokStart, K4.InexactInsideExact) : this.raise(this.state.lastTokStart, K4.InexactInsideNonObject), r && this.raise(r.start, K4.InexactVariance), null) : (n || this.raise(this.state.lastTokStart, K4.UnexpectedSpreadType), null != s && this.unexpected(s), r && this.raise(r.start, K4.SpreadVariance), t.argument = this.flowParseType(), this.finishNode(t, "ObjectTypeSpreadProperty"));
                    }
                    {
                        t.key = this.flowParseObjectPropertyKey(), t.static = e, t.proto = null != s, t.kind = i;
                        let n9 = !1;
                        return this.isRelational("<") || this.match(c6.parenL) ? (t.method = !0, null != s && this.unexpected(s), r && this.unexpected(r.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)), "get" !== i && "set" !== i || this.flowCheckGetterSetterParams(t)) : ("init" !== i && this.unexpected(), t.method = !1, this.eat(c6.question) && (n9 = !0), t.value = this.flowParseTypeInitialiser(), t.variance = r), t.optional = n9, this.finishNode(t, "ObjectTypeProperty");
                    }
                }
                flowCheckGetterSetterParams(t) {
                    const e26 = "get" === t.kind ? 0 : 1, s7 = t.start;
                    t.value.params.length + (t.value.rest ? 1 : 0) !== e26 && ("get" === t.kind ? this.raise(s7, g6.BadGetterArity) : this.raise(s7, g6.BadSetterArity)), "set" === t.kind && t.value.rest && this.raise(s7, g6.BadSetterRestParameter);
                }
                flowObjectTypeSemicolon() {
                    this.eat(c6.semi) || this.eat(c6.comma) || this.match(c6.braceR) || this.match(c6.braceBarR) || this.unexpected();
                }
                flowParseQualifiedTypeIdentifier(t, e, s) {
                    t = t || this.state.start, e = e || this.state.startLoc;
                    let r8 = s || this.flowParseRestrictedIdentifier(!0);
                    for(; this.eat(c6.dot);){
                        const s7 = this.startNodeAt(t, e);
                        s7.qualification = r8, s7.id = this.flowParseRestrictedIdentifier(!0), r8 = this.finishNode(s7, "QualifiedTypeIdentifier");
                    }
                    return r8;
                }
                flowParseGenericType(t, e, s) {
                    const r8 = this.startNodeAt(t, e);
                    return r8.typeParameters = null, r8.id = this.flowParseQualifiedTypeIdentifier(t, e, s), this.isRelational("<") && (r8.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r8, "GenericTypeAnnotation");
                }
                flowParseTypeofType() {
                    const t23 = this.startNode();
                    return this.expect(c6._typeof), t23.argument = this.flowParsePrimaryType(), this.finishNode(t23, "TypeofTypeAnnotation");
                }
                flowParseTupleType() {
                    const t23 = this.startNode();
                    for(t23.types = [], this.expect(c6.bracketL); this.state.pos < this.length && !this.match(c6.bracketR) && (t23.types.push(this.flowParseType()), !this.match(c6.bracketR));)this.expect(c6.comma);
                    return this.expect(c6.bracketR), this.finishNode(t23, "TupleTypeAnnotation");
                }
                flowParseFunctionTypeParam() {
                    let t23 = null, e26 = !1, s7 = null;
                    const r8 = this.startNode(), i7 = this.lookahead();
                    return i7.type === c6.colon || i7.type === c6.question ? (t23 = this.parseIdentifier(), this.eat(c6.question) && (e26 = !0), s7 = this.flowParseTypeInitialiser()) : s7 = this.flowParseType(), r8.name = t23, r8.optional = e26, r8.typeAnnotation = s7, this.finishNode(r8, "FunctionTypeParam");
                }
                reinterpretTypeAsFunctionTypeParam(t) {
                    const e26 = this.startNodeAt(t.start, t.loc.start);
                    return e26.name = null, e26.optional = !1, e26.typeAnnotation = t, this.finishNode(e26, "FunctionTypeParam");
                }
                flowParseFunctionTypeParams(t = []) {
                    let e26 = null;
                    for(; !this.match(c6.parenR) && !this.match(c6.ellipsis);)t.push(this.flowParseFunctionTypeParam()), this.match(c6.parenR) || this.expect(c6.comma);
                    return this.eat(c6.ellipsis) && (e26 = this.flowParseFunctionTypeParam()), {
                        params: t,
                        rest: e26
                    };
                }
                flowIdentToTypeAnnotation(t, e, s, r) {
                    switch(r.name){
                        case "any":
                            return this.finishNode(s, "AnyTypeAnnotation");
                        case "bool":
                        case "boolean":
                            return this.finishNode(s, "BooleanTypeAnnotation");
                        case "mixed":
                            return this.finishNode(s, "MixedTypeAnnotation");
                        case "empty":
                            return this.finishNode(s, "EmptyTypeAnnotation");
                        case "number":
                            return this.finishNode(s, "NumberTypeAnnotation");
                        case "string":
                            return this.finishNode(s, "StringTypeAnnotation");
                        case "symbol":
                            return this.finishNode(s, "SymbolTypeAnnotation");
                        default:
                            return this.checkNotUnderscore(r.name), this.flowParseGenericType(t, e, r);
                    }
                }
                flowParsePrimaryType() {
                    const t23 = this.state.start, e26 = this.state.startLoc, s7 = this.startNode();
                    let r8, i7, n9 = !1;
                    const a6 = this.state.noAnonFunctionType;
                    switch(this.state.type){
                        case c6.name:
                            return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t23, e26, s7, this.parseIdentifier());
                        case c6.braceL:
                            return this.flowParseObjectType({
                                allowStatic: !1,
                                allowExact: !1,
                                allowSpread: !0,
                                allowProto: !1,
                                allowInexact: !0
                            });
                        case c6.braceBarL:
                            return this.flowParseObjectType({
                                allowStatic: !1,
                                allowExact: !0,
                                allowSpread: !0,
                                allowProto: !1,
                                allowInexact: !1
                            });
                        case c6.bracketL:
                            return this.state.noAnonFunctionType = !1, i7 = this.flowParseTupleType(), this.state.noAnonFunctionType = a6, i7;
                        case c6.relational:
                            if ("<" === this.state.value) return s7.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(c6.parenL), r8 = this.flowParseFunctionTypeParams(), s7.params = r8.params, s7.rest = r8.rest, this.expect(c6.parenR), this.expect(c6.arrow), s7.returnType = this.flowParseType(), this.finishNode(s7, "FunctionTypeAnnotation");
                            break;
                        case c6.parenL:
                            if (this.next(), !this.match(c6.parenR) && !this.match(c6.ellipsis)) {
                                if (this.match(c6.name)) {
                                    const t24 = this.lookahead().type;
                                    n9 = t24 !== c6.question && t24 !== c6.colon;
                                } else n9 = !0;
                            }
                            if (n9) {
                                if (this.state.noAnonFunctionType = !1, i7 = this.flowParseType(), this.state.noAnonFunctionType = a6, this.state.noAnonFunctionType || !(this.match(c6.comma) || this.match(c6.parenR) && this.lookahead().type === c6.arrow)) return this.expect(c6.parenR), i7;
                                this.eat(c6.comma);
                            }
                            return r8 = i7 ? this.flowParseFunctionTypeParams([
                                this.reinterpretTypeAsFunctionTypeParam(i7)
                            ]) : this.flowParseFunctionTypeParams(), s7.params = r8.params, s7.rest = r8.rest, this.expect(c6.parenR), this.expect(c6.arrow), s7.returnType = this.flowParseType(), s7.typeParameters = null, this.finishNode(s7, "FunctionTypeAnnotation");
                        case c6.string:
                            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                        case c6._true:
                        case c6._false:
                            return s7.value = this.match(c6._true), this.next(), this.finishNode(s7, "BooleanLiteralTypeAnnotation");
                        case c6.plusMin:
                            if ("-" === this.state.value) {
                                if (this.next(), this.match(c6.num)) return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", s7.start, s7.loc.start);
                                if (this.match(c6.bigint)) return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", s7.start, s7.loc.start);
                                throw this.raise(this.state.start, K4.UnexpectedSubtractionOperand);
                            }
                            throw this.unexpected();
                        case c6.num:
                            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                        case c6.bigint:
                            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                        case c6._void:
                            return this.next(), this.finishNode(s7, "VoidTypeAnnotation");
                        case c6._null:
                            return this.next(), this.finishNode(s7, "NullLiteralTypeAnnotation");
                        case c6._this:
                            return this.next(), this.finishNode(s7, "ThisTypeAnnotation");
                        case c6.star:
                            return this.next(), this.finishNode(s7, "ExistsTypeAnnotation");
                        default:
                            if ("typeof" === this.state.type.keyword) return this.flowParseTypeofType();
                            if (this.state.type.keyword) {
                                const t24 = this.state.type.label;
                                return this.next(), super.createIdentifier(s7, t24);
                            }
                    }
                    throw this.unexpected();
                }
                flowParsePostfixType() {
                    const t23 = this.state.start, e26 = this.state.startLoc;
                    let s7 = this.flowParsePrimaryType();
                    for(; this.match(c6.bracketL) && !this.canInsertSemicolon();){
                        const r8 = this.startNodeAt(t23, e26);
                        r8.elementType = s7, this.expect(c6.bracketL), this.expect(c6.bracketR), s7 = this.finishNode(r8, "ArrayTypeAnnotation");
                    }
                    return s7;
                }
                flowParsePrefixType() {
                    const t23 = this.startNode();
                    return this.eat(c6.question) ? (t23.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t23, "NullableTypeAnnotation")) : this.flowParsePostfixType();
                }
                flowParseAnonFunctionWithoutParens() {
                    const t23 = this.flowParsePrefixType();
                    if (!this.state.noAnonFunctionType && this.eat(c6.arrow)) {
                        const e26 = this.startNodeAt(t23.start, t23.loc.start);
                        return e26.params = [
                            this.reinterpretTypeAsFunctionTypeParam(t23)
                        ], e26.rest = null, e26.returnType = this.flowParseType(), e26.typeParameters = null, this.finishNode(e26, "FunctionTypeAnnotation");
                    }
                    return t23;
                }
                flowParseIntersectionType() {
                    const t23 = this.startNode();
                    this.eat(c6.bitwiseAND);
                    const e26 = this.flowParseAnonFunctionWithoutParens();
                    for(t23.types = [
                        e26
                    ]; this.eat(c6.bitwiseAND);)t23.types.push(this.flowParseAnonFunctionWithoutParens());
                    return 1 === t23.types.length ? e26 : this.finishNode(t23, "IntersectionTypeAnnotation");
                }
                flowParseUnionType() {
                    const t23 = this.startNode();
                    this.eat(c6.bitwiseOR);
                    const e26 = this.flowParseIntersectionType();
                    for(t23.types = [
                        e26
                    ]; this.eat(c6.bitwiseOR);)t23.types.push(this.flowParseIntersectionType());
                    return 1 === t23.types.length ? e26 : this.finishNode(t23, "UnionTypeAnnotation");
                }
                flowParseType() {
                    const t23 = this.state.inType;
                    this.state.inType = !0;
                    const e26 = this.flowParseUnionType();
                    return this.state.inType = t23, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e26;
                }
                flowParseTypeOrImplicitInstantiation() {
                    if (this.state.type === c6.name && "_" === this.state.value) {
                        const t23 = this.state.start, e26 = this.state.startLoc, s7 = this.parseIdentifier();
                        return this.flowParseGenericType(t23, e26, s7);
                    }
                    return this.flowParseType();
                }
                flowParseTypeAnnotation() {
                    const t23 = this.startNode();
                    return t23.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t23, "TypeAnnotation");
                }
                flowParseTypeAnnotatableIdentifier(t) {
                    const e26 = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                    return this.match(c6.colon) && (e26.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e26)), e26;
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;
                }
                flowParseVariance() {
                    let t23 = null;
                    return this.match(c6.plusMin) && (t23 = this.startNode(), "+" === this.state.value ? t23.kind = "plus" : t23.kind = "minus", this.next(), this.finishNode(t23, "Variance")), t23;
                }
                parseFunctionBody(t, e, s = !1) {
                    return e ? this.forwardNoArrowParamsConversionAt(t, ()=>super.parseFunctionBody(t, !0, s)
                    ) : super.parseFunctionBody(t, !1, s);
                }
                parseFunctionBodyAndFinish(t, e, s = !1) {
                    if (this.match(c6.colon)) {
                        const e26 = this.startNode();
                        [e26.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = e26.typeAnnotation ? this.finishNode(e26, "TypeAnnotation") : null;
                    }
                    super.parseFunctionBodyAndFinish(t, e, s);
                }
                parseStatement(t, e) {
                    if (this.state.strict && this.match(c6.name) && "interface" === this.state.value) {
                        const t23 = this.lookahead();
                        if (t23.type === c6.name || W3(t23.value)) {
                            const t24 = this.startNode();
                            return this.next(), this.flowParseInterface(t24);
                        }
                    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
                        const t23 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(t23);
                    }
                    const s7 = super.parseStatement(t, e);
                    return (void 0) !== this.flowPragma || this.isValidDirective(s7) || (this.flowPragma = null), s7;
                }
                parseExpressionStatement(t, e) {
                    if ("Identifier" === e.type) {
                        if ("declare" === e.name) {
                            if (this.match(c6._class) || this.match(c6.name) || this.match(c6._function) || this.match(c6._var) || this.match(c6._export)) return this.flowParseDeclare(t);
                        } else if (this.match(c6.name)) {
                            if ("interface" === e.name) return this.flowParseInterface(t);
                            if ("type" === e.name) return this.flowParseTypeAlias(t);
                            if ("opaque" === e.name) return this.flowParseOpaqueType(t, !1);
                        }
                    }
                    return super.parseExpressionStatement(t, e);
                }
                shouldParseExportDeclaration() {
                    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
                }
                isExportDefaultSpecifier() {
                    return (!this.match(c6.name) || !("type" === this.state.value || "interface" === this.state.value || "opaque" === this.state.value || this.shouldParseEnums() && "enum" === this.state.value)) && super.isExportDefaultSpecifier();
                }
                parseExportDefaultExpression() {
                    if (this.shouldParseEnums() && this.isContextual("enum")) {
                        const t23 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(t23);
                    }
                    return super.parseExportDefaultExpression();
                }
                parseConditional(t, e, s, r) {
                    if (!this.match(c6.question)) return t;
                    if (r) {
                        const i7 = this.tryParse(()=>super.parseConditional(t, e, s)
                        );
                        return i7.node ? (i7.error && (this.state = i7.failState), i7.node) : (r.start = i7.error.pos || this.state.start, t);
                    }
                    this.expect(c6.question);
                    const i7 = this.state.clone(), n9 = this.state.noArrowAt, a6 = this.startNodeAt(e, s);
                    let { consequent: o6 , failed: u5  } = this.tryParseConditionalConsequent(), [h6, p7] = this.getArrowLikeExpressions(o6);
                    if (u5 || p7.length > 0) {
                        const t23 = [
                            ...n9
                        ];
                        if (p7.length > 0) {
                            this.state = i7, this.state.noArrowAt = t23;
                            for(let e26 = 0; e26 < p7.length; e26++)t23.push(p7[e26].start);
                            ({ consequent: o6 , failed: u5  } = this.tryParseConditionalConsequent()), [h6, p7] = this.getArrowLikeExpressions(o6);
                        }
                        u5 && h6.length > 1 && this.raise(i7.start, K4.AmbiguousConditionalArrow), u5 && 1 === h6.length && (this.state = i7, this.state.noArrowAt = t23.concat(h6[0].start), { consequent: o6 , failed: u5  } = this.tryParseConditionalConsequent());
                    }
                    return this.getArrowLikeExpressions(o6, !0), this.state.noArrowAt = n9, this.expect(c6.colon), a6.test = t, a6.consequent = o6, a6.alternate = this.forwardNoArrowParamsConversionAt(a6, ()=>this.parseMaybeAssign(void 0, void 0, void 0)
                    ), this.finishNode(a6, "ConditionalExpression");
                }
                tryParseConditionalConsequent() {
                    this.state.noArrowParamsConversionAt.push(this.state.start);
                    const t23 = this.parseMaybeAssignAllowIn(), e26 = !this.match(c6.colon);
                    return this.state.noArrowParamsConversionAt.pop(), {
                        consequent: t23,
                        failed: e26
                    };
                }
                getArrowLikeExpressions(t, e) {
                    const s7 = [
                        t
                    ], r8 = [];
                    for(; 0 !== s7.length;){
                        const t23 = s7.pop();
                        "ArrowFunctionExpression" === t23.type ? (t23.typeParameters || !t23.returnType ? this.finishArrowValidation(t23) : r8.push(t23), s7.push(t23.body)) : "ConditionalExpression" === t23.type && (s7.push(t23.consequent), s7.push(t23.alternate));
                    }
                    return e ? (r8.forEach((t23)=>this.finishArrowValidation(t23)
                    ), [
                        r8,
                        []
                    ]) : (function(t23, e26) {
                        const s8 = [], r9 = [];
                        for(let i7 = 0; i7 < t23.length; i7++)(e26(t23[i7], i7, t23) ? s8 : r9).push(t23[i7]);
                        return [
                            s8,
                            r9
                        ];
                    })(r8, (t23)=>t23.params.every((t24)=>this.isAssignable(t24, !0)
                        )
                    );
                }
                finishArrowValidation(t) {
                    var e26;
                    this.toAssignableList(t.params, null == (e26 = t.extra) ? void 0 : e26.trailingComma), this.scope.enter(6), super.checkParams(t, !1, !0), this.scope.exit();
                }
                forwardNoArrowParamsConversionAt(t, e) {
                    let s7;
                    return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s7 = e(), this.state.noArrowParamsConversionAt.pop()) : s7 = e(), s7;
                }
                parseParenItem(t, e, s) {
                    if (t = super.parseParenItem(t, e, s), this.eat(c6.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(c6.colon)) {
                        const r8 = this.startNodeAt(e, s);
                        return r8.expression = t, r8.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r8, "TypeCastExpression");
                    }
                    return t;
                }
                assertModuleNodeAllowed(t) {
                    "ImportDeclaration" === t.type && ("type" === t.importKind || "typeof" === t.importKind) || "ExportNamedDeclaration" === t.type && "type" === t.exportKind || "ExportAllDeclaration" === t.type && "type" === t.exportKind || super.assertModuleNodeAllowed(t);
                }
                parseExport(t) {
                    const e26 = super.parseExport(t);
                    return "ExportNamedDeclaration" !== e26.type && "ExportAllDeclaration" !== e26.type || (e26.exportKind = e26.exportKind || "value"), e26;
                }
                parseExportDeclaration(t) {
                    if (this.isContextual("type")) {
                        t.exportKind = "type";
                        const e26 = this.startNode();
                        return this.next(), this.match(c6.braceL) ? (t.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t), null) : this.flowParseTypeAlias(e26);
                    }
                    if (this.isContextual("opaque")) {
                        t.exportKind = "type";
                        const e26 = this.startNode();
                        return this.next(), this.flowParseOpaqueType(e26, !1);
                    }
                    if (this.isContextual("interface")) {
                        t.exportKind = "type";
                        const e26 = this.startNode();
                        return this.next(), this.flowParseInterface(e26);
                    }
                    if (this.shouldParseEnums() && this.isContextual("enum")) {
                        t.exportKind = "value";
                        const e26 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(e26);
                    }
                    return super.parseExportDeclaration(t);
                }
                eatExportStar(t) {
                    return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== c6.star) && (t.exportKind = "type", this.next(), this.next(), !0);
                }
                maybeParseExportNamespaceSpecifier(t) {
                    const e26 = this.state.start, s7 = super.maybeParseExportNamespaceSpecifier(t);
                    return s7 && "type" === t.exportKind && this.unexpected(e26), s7;
                }
                parseClassId(t, e, s) {
                    super.parseClassId(t, e, s), this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration());
                }
                parseClassMember(t, e, s) {
                    const r8 = this.state.start;
                    if (this.isContextual("declare")) {
                        if (this.parseClassMemberFromModifier(t, e)) return;
                        e.declare = !0;
                    }
                    super.parseClassMember(t, e, s), e.declare && ("ClassProperty" !== e.type && "ClassPrivateProperty" !== e.type ? this.raise(r8, K4.DeclareClassElement) : e.value && this.raise(e.value.start, K4.DeclareClassFieldInitializer));
                }
                getTokenFromCode(t) {
                    const e26 = this.input.charCodeAt(this.state.pos + 1);
                    return 123 === t && 124 === e26 ? this.finishOp(c6.braceBarL, 2) : !this.state.inType || 62 !== t && 60 !== t ? this.state.inType && 63 === t ? this.finishOp(c6.question, 1) : (function(t23, e27) {
                        return 64 === t23 && 64 === e27;
                    })(t, e26) ? (this.state.isIterator = !0, super.readWord()) : super.getTokenFromCode(t) : this.finishOp(c6.relational, 1);
                }
                isAssignable(t, e) {
                    switch(t.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                            return !0;
                        case "ObjectExpression":
                            {
                                const e26 = t.properties.length - 1;
                                return t.properties.every((t23, s7)=>"ObjectMethod" !== t23.type && (s7 === e26 || "SpreadElement" === t23.type) && this.isAssignable(t23)
                                );
                            }
                        case "ObjectProperty":
                            return this.isAssignable(t.value);
                        case "SpreadElement":
                            return this.isAssignable(t.argument);
                        case "ArrayExpression":
                            return t.elements.every((t23)=>this.isAssignable(t23)
                            );
                        case "AssignmentExpression":
                            return "=" === t.operator;
                        case "ParenthesizedExpression":
                        case "TypeCastExpression":
                            return this.isAssignable(t.expression);
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return !e;
                        default:
                            return !1;
                    }
                }
                toAssignable(t) {
                    return "TypeCastExpression" === t.type ? super.toAssignable(this.typeCastToParameter(t)) : super.toAssignable(t);
                }
                toAssignableList(t, e) {
                    for(let e26 = 0; e26 < t.length; e26++){
                        const s7 = t[e26];
                        "TypeCastExpression" === (null == s7 ? void 0 : s7.type) && (t[e26] = this.typeCastToParameter(s7));
                    }
                    return super.toAssignableList(t, e);
                }
                toReferencedList(t, e) {
                    for(let r8 = 0; r8 < t.length; r8++){
                        var s7;
                        const i7 = t[r8];
                        i7 && "TypeCastExpression" === i7.type && !(null == (s7 = i7.extra) ? void 0 : s7.parenthesized) && (t.length > 1 || !e) && this.raise(i7.typeAnnotation.start, K4.TypeCastInPattern);
                    }
                    return t;
                }
                parseArrayLike(t, e, s, r) {
                    const i7 = super.parseArrayLike(t, e, s, r);
                    return e && !this.state.maybeInArrowParameters && this.toReferencedList(i7.elements), i7;
                }
                checkLVal(t, e = 64, s, r) {
                    if ("TypeCastExpression" !== t.type) return super.checkLVal(t, e, s, r);
                }
                parseClassProperty(t) {
                    return this.match(c6.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t);
                }
                parseClassPrivateProperty(t) {
                    return this.match(c6.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t);
                }
                isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                }
                isClassProperty() {
                    return this.match(c6.colon) || super.isClassProperty();
                }
                isNonstaticConstructor(t) {
                    return !this.match(c6.colon) && super.isNonstaticConstructor(t);
                }
                pushClassMethod(t, e, s, r, i, n) {
                    e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t, e, s, r, i, n);
                }
                pushClassPrivateMethod(t, e, s, r) {
                    e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t, e, s, r);
                }
                parseClassSuper(t) {
                    if (super.parseClassSuper(t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
                        this.next();
                        const e26 = t.implements = [];
                        do {
                            const t23 = this.startNode();
                            t23.id = this.flowParseRestrictedIdentifier(!0), this.isRelational("<") ? t23.typeParameters = this.flowParseTypeParameterInstantiation() : t23.typeParameters = null, e26.push(this.finishNode(t23, "ClassImplements"));
                        }while (this.eat(c6.comma))
                    }
                }
                parsePropertyName(t, e) {
                    const s7 = this.flowParseVariance(), r8 = super.parsePropertyName(t, e);
                    return t.variance = s7, r8;
                }
                parseObjPropValue(t, e, s, r, i, n, a, o) {
                    let u5;
                    t.variance && this.unexpected(t.variance.start), delete t.variance, this.isRelational("<") && !a && (u5 = this.flowParseTypeParameterDeclaration(), this.match(c6.parenL) || this.unexpected()), super.parseObjPropValue(t, e, s, r, i, n, a, o), u5 && ((t.value || t).typeParameters = u5);
                }
                parseAssignableListItemTypes(t) {
                    return this.eat(c6.question) && ("Identifier" !== t.type && this.raise(t.start, K4.OptionalBindingPattern), t.optional = !0), this.match(c6.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t), t;
                }
                parseMaybeDefault(t, e, s) {
                    const r8 = super.parseMaybeDefault(t, e, s);
                    return "AssignmentPattern" === r8.type && r8.typeAnnotation && r8.right.start < r8.typeAnnotation.start && this.raise(r8.typeAnnotation.start, K4.TypeBeforeInitializer), r8;
                }
                shouldParseDefaultImport(t) {
                    return J3(t) ? $3(this.state) : super.shouldParseDefaultImport(t);
                }
                parseImportSpecifierLocal(t, e, s, r) {
                    e.local = J3(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, r), t.specifiers.push(this.finishNode(e, s));
                }
                maybeParseDefaultImportSpecifier(t) {
                    t.importKind = "value";
                    let e26 = null;
                    if (this.match(c6._typeof) ? e26 = "typeof" : this.isContextual("type") && (e26 = "type"), e26) {
                        const s7 = this.lookahead();
                        "type" === e26 && s7.type === c6.star && this.unexpected(s7.start), ($3(s7) || s7.type === c6.braceL || s7.type === c6.star) && (this.next(), t.importKind = e26);
                    }
                    return super.maybeParseDefaultImportSpecifier(t);
                }
                parseImportSpecifier(t) {
                    const e26 = this.startNode(), s7 = this.state.start, r8 = this.parseModuleExportName();
                    let i7 = null;
                    "Identifier" === r8.type && ("type" === r8.name ? i7 = "type" : "typeof" === r8.name && (i7 = "typeof"));
                    let n9 = !1;
                    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
                        const t23 = this.parseIdentifier(!0);
                        null === i7 || this.match(c6.name) || this.state.type.keyword ? (e26.imported = r8, e26.importKind = null, e26.local = this.parseIdentifier()) : (e26.imported = t23, e26.importKind = i7, e26.local = t23.__clone());
                    } else if (null !== i7 && (this.match(c6.name) || this.state.type.keyword)) e26.imported = this.parseIdentifier(!0), e26.importKind = i7, this.eatContextual("as") ? e26.local = this.parseIdentifier() : (n9 = !0, e26.local = e26.imported.__clone());
                    else {
                        if ("StringLiteral" === r8.type) throw this.raise(e26.start, g6.ImportBindingIsString, r8.value);
                        n9 = !0, e26.imported = r8, e26.importKind = null, e26.local = e26.imported.__clone();
                    }
                    const a6 = J3(t), o6 = J3(e26);
                    a6 && o6 && this.raise(s7, K4.ImportTypeShorthandOnlyInPureImport), (a6 || o6) && this.checkReservedType(e26.local.name, e26.local.start, !0), !n9 || a6 || o6 || this.checkReservedWord(e26.local.name, e26.start, !0, !0), this.checkLVal(e26.local, 9, void 0, "import specifier"), t.specifiers.push(this.finishNode(e26, "ImportSpecifier"));
                }
                parseFunctionParams(t, e) {
                    const s7 = t.kind;
                    "get" !== s7 && "set" !== s7 && this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t, e);
                }
                parseVarId(t, e) {
                    super.parseVarId(t, e), this.match(c6.colon) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id));
                }
                parseAsyncArrowFromCallExpression(t, e) {
                    if (this.match(c6.colon)) {
                        const e26 = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e26;
                    }
                    return super.parseAsyncArrowFromCallExpression(t, e);
                }
                shouldParseAsyncArrow() {
                    return this.match(c6.colon) || super.shouldParseAsyncArrow();
                }
                parseMaybeAssign(t, e, s) {
                    var r8;
                    let i7, n9 = null;
                    if (this.hasPlugin("jsx") && (this.match(c6.jsxTagStart) || this.isRelational("<"))) {
                        if (n9 = this.state.clone(), i7 = this.tryParse(()=>super.parseMaybeAssign(t, e, s)
                        , n9), !i7.error) return i7.node;
                        const { context: r9  } = this.state;
                        r9[r9.length - 1] === T5.j_oTag ? r9.length -= 2 : r9[r9.length - 1] === T5.j_expr && (r9.length -= 1);
                    }
                    if ((null == (r8 = i7) ? void 0 : r8.error) || this.isRelational("<")) {
                        var a6, o6;
                        let r9;
                        n9 = n9 || this.state.clone();
                        const u5 = this.tryParse((i8)=>{
                            var n10;
                            r9 = this.flowParseTypeParameterDeclaration();
                            const a7 = this.forwardNoArrowParamsConversionAt(r9, ()=>{
                                const i9 = super.parseMaybeAssign(t, e, s);
                                return this.resetStartLocationFromNode(i9, r9), i9;
                            });
                            "ArrowFunctionExpression" !== a7.type && (null == (n10 = a7.extra) ? void 0 : n10.parenthesized) && i8();
                            const o7 = this.maybeUnwrapTypeCastExpression(a7);
                            return o7.typeParameters = r9, this.resetStartLocationFromNode(o7, r9), a7;
                        }, n9);
                        let h6 = null;
                        if (u5.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(u5.node).type) {
                            if (!u5.error && !u5.aborted) return u5.node.async && this.raise(r9.start, K4.UnexpectedTypeParameterBeforeAsyncArrowFunction), u5.node;
                            h6 = u5.node;
                        }
                        if (null == (a6 = i7) ? void 0 : a6.node) return this.state = i7.failState, i7.node;
                        if (h6) return this.state = u5.failState, h6;
                        if (null == (o6 = i7) ? void 0 : o6.thrown) throw i7.error;
                        if (u5.thrown) throw u5.error;
                        throw this.raise(r9.start, K4.UnexpectedTokenAfterTypeParameter);
                    }
                    return super.parseMaybeAssign(t, e, s);
                }
                parseArrow(t) {
                    if (this.match(c6.colon)) {
                        const e26 = this.tryParse(()=>{
                            const e27 = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = !0;
                            const s7 = this.startNode();
                            return [s7.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e27, this.canInsertSemicolon() && this.unexpected(), this.match(c6.arrow) || this.unexpected(), s7;
                        });
                        if (e26.thrown) return null;
                        e26.error && (this.state = e26.failState), t.returnType = e26.node.typeAnnotation ? this.finishNode(e26.node, "TypeAnnotation") : null;
                    }
                    return super.parseArrow(t);
                }
                shouldParseArrow() {
                    return this.match(c6.colon) || super.shouldParseArrow();
                }
                setArrowFunctionParameters(t, e) {
                    -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? t.params = e : super.setArrowFunctionParameters(t, e);
                }
                checkParams(t, e, s) {
                    if (!s || -1 === this.state.noArrowParamsConversionAt.indexOf(t.start)) return super.checkParams(...arguments);
                }
                parseParenAndDistinguishExpression(t) {
                    return super.parseParenAndDistinguishExpression(t && -1 === this.state.noArrowAt.indexOf(this.state.start));
                }
                parseSubscripts(t, e, s, r) {
                    if ("Identifier" === t.type && "async" === t.name && -1 !== this.state.noArrowAt.indexOf(e)) {
                        this.next();
                        const r8 = this.startNodeAt(e, s);
                        r8.callee = t, r8.arguments = this.parseCallExpressionArguments(c6.parenR, !1), t = this.finishNode(r8, "CallExpression");
                    } else if ("Identifier" === t.type && "async" === t.name && this.isRelational("<")) {
                        const i7 = this.state.clone(), n9 = this.tryParse((t23)=>this.parseAsyncArrowWithTypeParameters(e, s) || t23()
                        , i7);
                        if (!n9.error && !n9.aborted) return n9.node;
                        const a6 = this.tryParse(()=>super.parseSubscripts(t, e, s, r)
                        , i7);
                        if (a6.node && !a6.error) return a6.node;
                        if (n9.node) return this.state = n9.failState, n9.node;
                        if (a6.node) return this.state = a6.failState, a6.node;
                        throw n9.error || a6.error;
                    }
                    return super.parseSubscripts(t, e, s, r);
                }
                parseSubscript(t, e, s, r, i) {
                    if (this.match(c6.questionDot) && this.isLookaheadToken_lt()) {
                        if (i.optionalChainMember = !0, r) return i.stop = !0, t;
                        this.next();
                        const n9 = this.startNodeAt(e, s);
                        return n9.callee = t, n9.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(c6.parenL), n9.arguments = this.parseCallExpressionArguments(c6.parenR, !1), n9.optional = !0, this.finishCallExpression(n9, !0);
                    }
                    if (!r && this.shouldParseTypes() && this.isRelational("<")) {
                        const r8 = this.startNodeAt(e, s);
                        r8.callee = t;
                        const n9 = this.tryParse(()=>(r8.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(c6.parenL), r8.arguments = this.parseCallExpressionArguments(c6.parenR, !1), i.optionalChainMember && (r8.optional = !1), this.finishCallExpression(r8, i.optionalChainMember))
                        );
                        if (n9.node) return n9.error && (this.state = n9.failState), n9.node;
                    }
                    return super.parseSubscript(t, e, s, r, i);
                }
                parseNewArguments(t) {
                    let e26 = null;
                    this.shouldParseTypes() && this.isRelational("<") && (e26 = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()
                    ).node), t.typeArguments = e26, super.parseNewArguments(t);
                }
                parseAsyncArrowWithTypeParameters(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    if (this.parseFunctionParams(s7), this.parseArrow(s7)) return this.parseArrowExpression(s7, void 0, !0);
                }
                readToken_mult_modulo(t) {
                    const e26 = this.input.charCodeAt(this.state.pos + 1);
                    if (42 === t && 47 === e26 && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
                    super.readToken_mult_modulo(t);
                }
                readToken_pipe_amp(t) {
                    const e26 = this.input.charCodeAt(this.state.pos + 1);
                    124 !== t || 125 !== e26 ? super.readToken_pipe_amp(t) : this.finishOp(c6.braceBarR, 2);
                }
                parseTopLevel(t, e) {
                    const s7 = super.parseTopLevel(t, e);
                    return this.state.hasFlowComment && this.raise(this.state.pos, K4.UnterminatedFlowComment), s7;
                }
                skipBlockComment() {
                    if (this.hasPlugin("flowComments") && this.skipFlowComment()) return this.state.hasFlowComment && this.unexpected(null, K4.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0);
                    if (this.state.hasFlowComment) {
                        const t23 = this.input.indexOf("*-/", this.state.pos += 2);
                        if (-1 === t23) throw this.raise(this.state.pos - 2, g6.UnterminatedComment);
                        this.state.pos = t23 + 3;
                    } else super.skipBlockComment();
                }
                skipFlowComment() {
                    const { pos: t23  } = this.state;
                    let e26 = 2;
                    for(; [
                        32,
                        9
                    ].includes(this.input.charCodeAt(t23 + e26));)e26++;
                    const s7 = this.input.charCodeAt(e26 + t23), r8 = this.input.charCodeAt(e26 + t23 + 1);
                    return 58 === s7 && 58 === r8 ? e26 + 2 : "flow-include" === this.input.slice(e26 + t23, e26 + t23 + 12) ? e26 + 12 : 58 === s7 && 58 !== r8 && e26;
                }
                hasFlowCommentCompletion() {
                    if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(this.state.pos, g6.UnterminatedComment);
                }
                flowEnumErrorBooleanMemberNotInitialized(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K4.EnumBooleanMemberNotInitialized, s, e);
                }
                flowEnumErrorInvalidMemberName(t, { enumName: e , memberName: s  }) {
                    const r8 = s[0].toUpperCase() + s.slice(1);
                    this.raise(t, K4.EnumInvalidMemberName, s, r8, e);
                }
                flowEnumErrorDuplicateMemberName(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K4.EnumDuplicateMemberName, s, e);
                }
                flowEnumErrorInconsistentMemberValues(t, { enumName: e  }) {
                    this.raise(t, K4.EnumInconsistentMemberValues, e);
                }
                flowEnumErrorInvalidExplicitType(t, { enumName: e , suppliedType: s  }) {
                    return this.raise(t, null === s ? K4.EnumInvalidExplicitTypeUnknownSupplied : K4.EnumInvalidExplicitType, e, s);
                }
                flowEnumErrorInvalidMemberInitializer(t, { enumName: e , explicitType: s , memberName: r  }) {
                    let i7 = null;
                    switch(s){
                        case "boolean":
                        case "number":
                        case "string":
                            i7 = K4.EnumInvalidMemberInitializerPrimaryType;
                            break;
                        case "symbol":
                            i7 = K4.EnumInvalidMemberInitializerSymbolType;
                            break;
                        default:
                            i7 = K4.EnumInvalidMemberInitializerUnknownType;
                    }
                    return this.raise(t, i7, e, r, s);
                }
                flowEnumErrorNumberMemberNotInitialized(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K4.EnumNumberMemberNotInitialized, e, s);
                }
                flowEnumErrorStringMemberInconsistentlyInitailized(t, { enumName: e  }) {
                    this.raise(t, K4.EnumStringMemberInconsistentlyInitailized, e);
                }
                flowEnumMemberInit() {
                    const t23 = this.state.start, e26 = ()=>this.match(c6.comma) || this.match(c6.braceR)
                    ;
                    switch(this.state.type){
                        case c6.num:
                            {
                                const s7 = this.parseLiteral(this.state.value, "NumericLiteral");
                                return e26() ? {
                                    type: "number",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t23
                                };
                            }
                        case c6.string:
                            {
                                const s7 = this.parseLiteral(this.state.value, "StringLiteral");
                                return e26() ? {
                                    type: "string",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t23
                                };
                            }
                        case c6._true:
                        case c6._false:
                            {
                                const s7 = this.parseBooleanLiteral();
                                return e26() ? {
                                    type: "boolean",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t23
                                };
                            }
                        default:
                            return {
                                type: "invalid",
                                pos: t23
                            };
                    }
                }
                flowEnumMemberRaw() {
                    const t23 = this.state.start;
                    return {
                        id: this.parseIdentifier(!0),
                        init: this.eat(c6.eq) ? this.flowEnumMemberInit() : {
                            type: "none",
                            pos: t23
                        }
                    };
                }
                flowEnumCheckExplicitTypeMismatch(t, e, s) {
                    const { explicitType: r8  } = e;
                    null !== r8 && r8 !== s && this.flowEnumErrorInvalidMemberInitializer(t, e);
                }
                flowEnumMembers({ enumName: t , explicitType: e  }) {
                    const s7 = new Set, r8 = {
                        booleanMembers: [],
                        numberMembers: [],
                        stringMembers: [],
                        defaultedMembers: []
                    };
                    for(; !this.match(c6.braceR);){
                        const i7 = this.startNode(), { id: n9 , init: a6  } = this.flowEnumMemberRaw(), o6 = n9.name;
                        if ("" === o6) continue;
                        /^[a-z]/.test(o6) && this.flowEnumErrorInvalidMemberName(n9.start, {
                            enumName: t,
                            memberName: o6
                        }), s7.has(o6) && this.flowEnumErrorDuplicateMemberName(n9.start, {
                            enumName: t,
                            memberName: o6
                        }), s7.add(o6);
                        const u5 = {
                            enumName: t,
                            explicitType: e,
                            memberName: o6
                        };
                        switch(i7.id = n9, a6.type){
                            case "boolean":
                                this.flowEnumCheckExplicitTypeMismatch(a6.pos, u5, "boolean"), i7.init = a6.value, r8.booleanMembers.push(this.finishNode(i7, "EnumBooleanMember"));
                                break;
                            case "number":
                                this.flowEnumCheckExplicitTypeMismatch(a6.pos, u5, "number"), i7.init = a6.value, r8.numberMembers.push(this.finishNode(i7, "EnumNumberMember"));
                                break;
                            case "string":
                                this.flowEnumCheckExplicitTypeMismatch(a6.pos, u5, "string"), i7.init = a6.value, r8.stringMembers.push(this.finishNode(i7, "EnumStringMember"));
                                break;
                            case "invalid":
                                throw this.flowEnumErrorInvalidMemberInitializer(a6.pos, u5);
                            case "none":
                                switch(e){
                                    case "boolean":
                                        this.flowEnumErrorBooleanMemberNotInitialized(a6.pos, u5);
                                        break;
                                    case "number":
                                        this.flowEnumErrorNumberMemberNotInitialized(a6.pos, u5);
                                        break;
                                    default:
                                        r8.defaultedMembers.push(this.finishNode(i7, "EnumDefaultedMember"));
                                }
                        }
                        this.match(c6.braceR) || this.expect(c6.comma);
                    }
                    return r8;
                }
                flowEnumStringMembers(t, e, { enumName: s  }) {
                    if (0 === t.length) return e;
                    if (0 === e.length) return t;
                    if (e.length > t.length) {
                        for(let e26 = 0; e26 < t.length; e26++){
                            const r8 = t[e26];
                            this.flowEnumErrorStringMemberInconsistentlyInitailized(r8.start, {
                                enumName: s
                            });
                        }
                        return e;
                    }
                    for(let t23 = 0; t23 < e.length; t23++){
                        const r8 = e[t23];
                        this.flowEnumErrorStringMemberInconsistentlyInitailized(r8.start, {
                            enumName: s
                        });
                    }
                    return t;
                }
                flowEnumParseExplicitType({ enumName: t  }) {
                    if (this.eatContextual("of")) {
                        if (!this.match(c6.name)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                            enumName: t,
                            suppliedType: null
                        });
                        const { value: e26  } = this.state;
                        return this.next(), "boolean" !== e26 && "number" !== e26 && "string" !== e26 && "symbol" !== e26 && this.flowEnumErrorInvalidExplicitType(this.state.start, {
                            enumName: t,
                            suppliedType: e26
                        }), e26;
                    }
                    return null;
                }
                flowEnumBody(t, { enumName: e , nameLoc: s  }) {
                    const r8 = this.flowEnumParseExplicitType({
                        enumName: e
                    });
                    this.expect(c6.braceL);
                    const i7 = this.flowEnumMembers({
                        enumName: e,
                        explicitType: r8
                    });
                    switch(r8){
                        case "boolean":
                            return t.explicitType = !0, t.members = i7.booleanMembers, this.expect(c6.braceR), this.finishNode(t, "EnumBooleanBody");
                        case "number":
                            return t.explicitType = !0, t.members = i7.numberMembers, this.expect(c6.braceR), this.finishNode(t, "EnumNumberBody");
                        case "string":
                            return t.explicitType = !0, t.members = this.flowEnumStringMembers(i7.stringMembers, i7.defaultedMembers, {
                                enumName: e
                            }), this.expect(c6.braceR), this.finishNode(t, "EnumStringBody");
                        case "symbol":
                            return t.members = i7.defaultedMembers, this.expect(c6.braceR), this.finishNode(t, "EnumSymbolBody");
                        default:
                            {
                                const r9 = ()=>(t.members = [], this.expect(c6.braceR), this.finishNode(t, "EnumStringBody"))
                                ;
                                t.explicitType = !1;
                                const n9 = i7.booleanMembers.length, a6 = i7.numberMembers.length, o6 = i7.stringMembers.length, u5 = i7.defaultedMembers.length;
                                if (n9 || a6 || o6 || u5) {
                                    if (n9 || a6) {
                                        if (!a6 && !o6 && n9 >= u5) {
                                            for(let t23 = 0, s7 = i7.defaultedMembers; t23 < s7.length; t23++){
                                                const r10 = s7[t23];
                                                this.flowEnumErrorBooleanMemberNotInitialized(r10.start, {
                                                    enumName: e,
                                                    memberName: r10.id.name
                                                });
                                            }
                                            return t.members = i7.booleanMembers, this.expect(c6.braceR), this.finishNode(t, "EnumBooleanBody");
                                        }
                                        if (!n9 && !o6 && a6 >= u5) {
                                            for(let t23 = 0, s7 = i7.defaultedMembers; t23 < s7.length; t23++){
                                                const r10 = s7[t23];
                                                this.flowEnumErrorNumberMemberNotInitialized(r10.start, {
                                                    enumName: e,
                                                    memberName: r10.id.name
                                                });
                                            }
                                            return t.members = i7.numberMembers, this.expect(c6.braceR), this.finishNode(t, "EnumNumberBody");
                                        }
                                        return this.flowEnumErrorInconsistentMemberValues(s, {
                                            enumName: e
                                        }), r9();
                                    }
                                    return t.members = this.flowEnumStringMembers(i7.stringMembers, i7.defaultedMembers, {
                                        enumName: e
                                    }), this.expect(c6.braceR), this.finishNode(t, "EnumStringBody");
                                }
                                return r9();
                            }
                    }
                }
                flowParseEnumDeclaration(t) {
                    const e26 = this.parseIdentifier();
                    return t.id = e26, t.body = this.flowEnumBody(this.startNode(), {
                        enumName: e26.name,
                        nameLoc: e26.start
                    }), this.finishNode(t, "EnumDeclaration");
                }
                updateContext(t) {
                    this.match(c6.name) && "of" === this.state.value && t === c6.name && "interface" === this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ? this.state.exprAllowed = !1 : super.updateContext(t);
                }
                isLookaheadToken_lt() {
                    const t23 = this.nextTokenStart();
                    if (60 === this.input.charCodeAt(t23)) {
                        const e26 = this.input.charCodeAt(t23 + 1);
                        return 60 !== e26 && 61 !== e26;
                    }
                    return !1;
                }
                maybeUnwrapTypeCastExpression(t) {
                    return "TypeCastExpression" === t.type ? t.expression : t;
                }
            }
        ,
        typescript: (t21)=>class extends t21 {
                getScopeHandler() {
                    return ut3;
                }
                tsIsIdentifier() {
                    return this.match(c6.name);
                }
                tsNextTokenCanFollowModifier() {
                    return this.next(), !(this.hasPrecedingLineBreak() || this.match(c6.parenL) || this.match(c6.parenR) || this.match(c6.colon) || this.match(c6.eq) || this.match(c6.question) || this.match(c6.bang));
                }
                tsParseModifier(t) {
                    if (!this.match(c6.name)) return;
                    const e25 = this.state.value;
                    return -1 !== t.indexOf(e25) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e25 : void 0;
                }
                tsParseModifiers(t, e) {
                    for(;;){
                        const s7 = this.state.start, r8 = this.tsParseModifier(e);
                        if (!r8) break;
                        Object.hasOwnProperty.call(t, r8) && this.raise(s7, dt3.DuplicateModifier, r8), t[r8] = !0;
                    }
                }
                tsIsListTerminator(t) {
                    switch(t){
                        case "EnumMembers":
                        case "TypeMembers":
                            return this.match(c6.braceR);
                        case "HeritageClauseElement":
                            return this.match(c6.braceL);
                        case "TupleElementTypes":
                            return this.match(c6.bracketR);
                        case "TypeParametersOrArguments":
                            return this.isRelational(">");
                    }
                    throw new Error("Unreachable");
                }
                tsParseList(t, e) {
                    const s7 = [];
                    for(; !this.tsIsListTerminator(t);)s7.push(e());
                    return s7;
                }
                tsParseDelimitedList(t, e) {
                    return pt3(this.tsParseDelimitedListWorker(t, e, !0));
                }
                tsParseDelimitedListWorker(t, e, s) {
                    const r8 = [];
                    for(; !this.tsIsListTerminator(t);){
                        const i7 = e();
                        if (null == i7) return;
                        if (r8.push(i7), !this.eat(c6.comma)) {
                            if (this.tsIsListTerminator(t)) break;
                            return void (s && this.expect(c6.comma));
                        }
                    }
                    return r8;
                }
                tsParseBracketedList(t, e, s, r) {
                    r || (s ? this.expect(c6.bracketL) : this.expectRelational("<"));
                    const i7 = this.tsParseDelimitedList(t, e);
                    return s ? this.expect(c6.bracketR) : this.expectRelational(">"), i7;
                }
                tsParseImportType() {
                    const t22 = this.startNode();
                    return this.expect(c6._import), this.expect(c6.parenL), this.match(c6.string) || this.raise(this.state.start, dt3.UnsupportedImportTypeArgument), t22.argument = this.parseExprAtom(), this.expect(c6.parenR), this.eat(c6.dot) && (t22.qualifier = this.tsParseEntityName(!0)), this.isRelational("<") && (t22.typeParameters = this.tsParseTypeArguments()), this.finishNode(t22, "TSImportType");
                }
                tsParseEntityName(t) {
                    let e25 = this.parseIdentifier();
                    for(; this.eat(c6.dot);){
                        const s7 = this.startNodeAtNode(e25);
                        s7.left = e25, s7.right = this.parseIdentifier(t), e25 = this.finishNode(s7, "TSQualifiedName");
                    }
                    return e25;
                }
                tsParseTypeReference() {
                    const t22 = this.startNode();
                    return t22.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational("<") && (t22.typeParameters = this.tsParseTypeArguments()), this.finishNode(t22, "TSTypeReference");
                }
                tsParseThisTypePredicate(t) {
                    this.next();
                    const e25 = this.startNodeAtNode(t);
                    return e25.parameterName = t, e25.typeAnnotation = this.tsParseTypeAnnotation(!1), this.finishNode(e25, "TSTypePredicate");
                }
                tsParseThisTypeNode() {
                    const t22 = this.startNode();
                    return this.next(), this.finishNode(t22, "TSThisType");
                }
                tsParseTypeQuery() {
                    const t22 = this.startNode();
                    return this.expect(c6._typeof), this.match(c6._import) ? t22.exprName = this.tsParseImportType() : t22.exprName = this.tsParseEntityName(!0), this.finishNode(t22, "TSTypeQuery");
                }
                tsParseTypeParameter() {
                    const t22 = this.startNode();
                    return t22.name = this.parseIdentifierName(t22.start), t22.constraint = this.tsEatThenParseType(c6._extends), t22.default = this.tsEatThenParseType(c6.eq), this.finishNode(t22, "TSTypeParameter");
                }
                tsTryParseTypeParameters() {
                    if (this.isRelational("<")) return this.tsParseTypeParameters();
                }
                tsParseTypeParameters() {
                    const t22 = this.startNode();
                    return this.isRelational("<") || this.match(c6.jsxTagStart) ? this.next() : this.unexpected(), t22.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0), 0 === t22.params.length && this.raise(t22.start, dt3.EmptyTypeParameters), this.finishNode(t22, "TSTypeParameterDeclaration");
                }
                tsTryNextParseConstantContext() {
                    return this.lookahead().type === c6._const ? (this.next(), this.tsParseTypeReference()) : null;
                }
                tsFillSignature(t, e) {
                    const s7 = t === c6.arrow;
                    e.typeParameters = this.tsTryParseTypeParameters(), this.expect(c6.parenL), e.parameters = this.tsParseBindingListForSignature(), (s7 || this.match(t)) && (e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t));
                }
                tsParseBindingListForSignature() {
                    return this.parseBindingList(c6.parenR, 41).map((t22)=>("Identifier" !== t22.type && "RestElement" !== t22.type && "ObjectPattern" !== t22.type && "ArrayPattern" !== t22.type && this.raise(t22.start, dt3.UnsupportedSignatureParameterKind, t22.type), t22)
                    );
                }
                tsParseTypeMemberSemicolon() {
                    this.eat(c6.comma) || this.semicolon();
                }
                tsParseSignatureMember(t, e) {
                    return this.tsFillSignature(c6.colon, e), this.tsParseTypeMemberSemicolon(), this.finishNode(e, t);
                }
                tsIsUnambiguouslyIndexSignature() {
                    return this.next(), this.eat(c6.name) && this.match(c6.colon);
                }
                tsTryParseIndexSignature(t) {
                    if (!this.match(c6.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
                    this.expect(c6.bracketL);
                    const e25 = this.parseIdentifier();
                    e25.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e25), this.expect(c6.bracketR), t.parameters = [
                        e25
                    ];
                    const s7 = this.tsTryParseTypeAnnotation();
                    return s7 && (t.typeAnnotation = s7), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSIndexSignature");
                }
                tsParsePropertyOrMethodSignature(t, e) {
                    this.eat(c6.question) && (t.optional = !0);
                    const s7 = t;
                    if (e || !this.match(c6.parenL) && !this.isRelational("<")) {
                        const t22 = t;
                        e && (t.readonly = !0);
                        const r8 = this.tsTryParseTypeAnnotation();
                        return r8 && (t.typeAnnotation = r8), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSPropertySignature");
                    }
                    {
                        const t22 = t;
                        return this.tsFillSignature(c6.colon, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSMethodSignature");
                    }
                }
                tsParseTypeMember() {
                    const t22 = this.startNode();
                    if (this.match(c6.parenL) || this.isRelational("<")) return this.tsParseSignatureMember("TSCallSignatureDeclaration", t22);
                    if (this.match(c6._new)) {
                        const e25 = this.startNode();
                        return this.next(), this.match(c6.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t22) : (t22.key = this.createIdentifier(e25, "new"), this.tsParsePropertyOrMethodSignature(t22, !1));
                    }
                    const e25 = !!this.tsParseModifier([
                        "readonly"
                    ]), s7 = this.tsTryParseIndexSignature(t22);
                    return s7 ? (e25 && (t22.readonly = !0), s7) : (this.parsePropertyName(t22, !1), this.tsParsePropertyOrMethodSignature(t22, e25));
                }
                tsParseTypeLiteral() {
                    const t22 = this.startNode();
                    return t22.members = this.tsParseObjectTypeMembers(), this.finishNode(t22, "TSTypeLiteral");
                }
                tsParseObjectTypeMembers() {
                    this.expect(c6.braceL);
                    const t22 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                    return this.expect(c6.braceR), t22;
                }
                tsIsStartOfMappedType() {
                    return this.next(), this.eat(c6.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(c6.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(c6._in))));
                }
                tsParseMappedTypeParameter() {
                    const t22 = this.startNode();
                    return t22.name = this.parseIdentifierName(t22.start), t22.constraint = this.tsExpectThenParseType(c6._in), this.finishNode(t22, "TSTypeParameter");
                }
                tsParseMappedType() {
                    const t22 = this.startNode();
                    return this.expect(c6.braceL), this.match(c6.plusMin) ? (t22.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t22.readonly = !0), this.expect(c6.bracketL), t22.typeParameter = this.tsParseMappedTypeParameter(), t22.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(c6.bracketR), this.match(c6.plusMin) ? (t22.optional = this.state.value, this.next(), this.expect(c6.question)) : this.eat(c6.question) && (t22.optional = !0), t22.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(c6.braceR), this.finishNode(t22, "TSMappedType");
                }
                tsParseTupleType() {
                    const t22 = this.startNode();
                    t22.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
                    let e25 = !1, s7 = null;
                    return t22.elementTypes.forEach((t23)=>{
                        var r8;
                        let { type: i7  } = t23;
                        !e25 || "TSRestType" === i7 || "TSOptionalType" === i7 || "TSNamedTupleMember" === i7 && t23.optional || this.raise(t23.start, dt3.OptionalTypeBeforeRequired), e25 = e25 || "TSNamedTupleMember" === i7 && t23.optional || "TSOptionalType" === i7, "TSRestType" === i7 && (i7 = (t23 = t23.typeAnnotation).type);
                        const n9 = "TSNamedTupleMember" === i7;
                        s7 = null != (r8 = s7) ? r8 : n9, s7 !== n9 && this.raise(t23.start, dt3.MixedLabeledAndUnlabeledElements);
                    }), this.finishNode(t22, "TSTupleType");
                }
                tsParseTupleElementType() {
                    const { start: t22 , startLoc: e25  } = this.state, s7 = this.eat(c6.ellipsis);
                    let r8 = this.tsParseType();
                    const i7 = this.eat(c6.question);
                    if (this.eat(c6.colon)) {
                        const t23 = this.startNodeAtNode(r8);
                        t23.optional = i7, "TSTypeReference" !== r8.type || r8.typeParameters || "Identifier" !== r8.typeName.type ? (this.raise(r8.start, dt3.InvalidTupleMemberLabel), t23.label = r8) : t23.label = r8.typeName, t23.elementType = this.tsParseType(), r8 = this.finishNode(t23, "TSNamedTupleMember");
                    } else if (i7) {
                        const t23 = this.startNodeAtNode(r8);
                        t23.typeAnnotation = r8, r8 = this.finishNode(t23, "TSOptionalType");
                    }
                    if (s7) {
                        const s8 = this.startNodeAt(t22, e25);
                        s8.typeAnnotation = r8, r8 = this.finishNode(s8, "TSRestType");
                    }
                    return r8;
                }
                tsParseParenthesizedType() {
                    const t22 = this.startNode();
                    return this.expect(c6.parenL), t22.typeAnnotation = this.tsParseType(), this.expect(c6.parenR), this.finishNode(t22, "TSParenthesizedType");
                }
                tsParseFunctionOrConstructorType(t) {
                    const e25 = this.startNode();
                    return "TSConstructorType" === t && this.expect(c6._new), this.tsFillSignature(c6.arrow, e25), this.finishNode(e25, t);
                }
                tsParseLiteralTypeNode() {
                    const t22 = this.startNode();
                    return t22.literal = (()=>{
                        switch(this.state.type){
                            case c6.num:
                            case c6.bigint:
                            case c6.string:
                            case c6._true:
                            case c6._false:
                                return this.parseExprAtom();
                            default:
                                throw this.unexpected();
                        }
                    })(), this.finishNode(t22, "TSLiteralType");
                }
                tsParseTemplateLiteralType() {
                    const t22 = this.startNode();
                    return t22.literal = this.parseTemplate(!1), this.finishNode(t22, "TSLiteralType");
                }
                parseTemplateSubstitution() {
                    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
                }
                tsParseThisTypeOrThisTypePredicate() {
                    const t22 = this.tsParseThisTypeNode();
                    return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t22) : t22;
                }
                tsParseNonArrayType() {
                    switch(this.state.type){
                        case c6.name:
                        case c6._void:
                        case c6._null:
                            {
                                const t22 = this.match(c6._void) ? "TSVoidKeyword" : this.match(c6._null) ? "TSNullKeyword" : function(t23) {
                                    switch(t23){
                                        case "any":
                                            return "TSAnyKeyword";
                                        case "boolean":
                                            return "TSBooleanKeyword";
                                        case "bigint":
                                            return "TSBigIntKeyword";
                                        case "never":
                                            return "TSNeverKeyword";
                                        case "number":
                                            return "TSNumberKeyword";
                                        case "object":
                                            return "TSObjectKeyword";
                                        case "string":
                                            return "TSStringKeyword";
                                        case "symbol":
                                            return "TSSymbolKeyword";
                                        case "undefined":
                                            return "TSUndefinedKeyword";
                                        case "unknown":
                                            return "TSUnknownKeyword";
                                        default:
                                            return;
                                    }
                                }(this.state.value);
                                if ((void 0) !== t22 && 46 !== this.lookaheadCharCode()) {
                                    const e25 = this.startNode();
                                    return this.next(), this.finishNode(e25, t22);
                                }
                                return this.tsParseTypeReference();
                            }
                        case c6.string:
                        case c6.num:
                        case c6.bigint:
                        case c6._true:
                        case c6._false:
                            return this.tsParseLiteralTypeNode();
                        case c6.plusMin:
                            if ("-" === this.state.value) {
                                const t22 = this.startNode(), e25 = this.lookahead();
                                if (e25.type !== c6.num && e25.type !== c6.bigint) throw this.unexpected();
                                return t22.literal = this.parseMaybeUnary(), this.finishNode(t22, "TSLiteralType");
                            }
                            break;
                        case c6._this:
                            return this.tsParseThisTypeOrThisTypePredicate();
                        case c6._typeof:
                            return this.tsParseTypeQuery();
                        case c6._import:
                            return this.tsParseImportType();
                        case c6.braceL:
                            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                        case c6.bracketL:
                            return this.tsParseTupleType();
                        case c6.parenL:
                            return this.tsParseParenthesizedType();
                        case c6.backQuote:
                            return this.tsParseTemplateLiteralType();
                    }
                    throw this.unexpected();
                }
                tsParseArrayTypeOrHigher() {
                    let t22 = this.tsParseNonArrayType();
                    for(; !this.hasPrecedingLineBreak() && this.eat(c6.bracketL);)if (this.match(c6.bracketR)) {
                        const e25 = this.startNodeAtNode(t22);
                        e25.elementType = t22, this.expect(c6.bracketR), t22 = this.finishNode(e25, "TSArrayType");
                    } else {
                        const e25 = this.startNodeAtNode(t22);
                        e25.objectType = t22, e25.indexType = this.tsParseType(), this.expect(c6.bracketR), t22 = this.finishNode(e25, "TSIndexedAccessType");
                    }
                    return t22;
                }
                tsParseTypeOperator(t) {
                    const e25 = this.startNode();
                    return this.expectContextual(t), e25.operator = t, e25.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e25), this.finishNode(e25, "TSTypeOperator");
                }
                tsCheckTypeAnnotationForReadOnly(t) {
                    switch(t.typeAnnotation.type){
                        case "TSTupleType":
                        case "TSArrayType":
                            return;
                        default:
                            this.raise(t.start, dt3.UnexpectedReadonly);
                    }
                }
                tsParseInferType() {
                    const t22 = this.startNode();
                    this.expectContextual("infer");
                    const e25 = this.startNode();
                    return e25.name = this.parseIdentifierName(e25.start), t22.typeParameter = this.finishNode(e25, "TSTypeParameter"), this.finishNode(t22, "TSInferType");
                }
                tsParseTypeOperatorOrHigher() {
                    const t22 = [
                        "keyof",
                        "unique",
                        "readonly"
                    ].find((t23)=>this.isContextual(t23)
                    );
                    return t22 ? this.tsParseTypeOperator(t22) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
                }
                tsParseUnionOrIntersectionType(t, e, s) {
                    this.eat(s);
                    let r8 = e();
                    if (this.match(s)) {
                        const i7 = [
                            r8
                        ];
                        for(; this.eat(s);)i7.push(e());
                        const n9 = this.startNodeAtNode(r8);
                        n9.types = i7, r8 = this.finishNode(n9, t);
                    }
                    return r8;
                }
                tsParseIntersectionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), c6.bitwiseAND);
                }
                tsParseUnionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), c6.bitwiseOR);
                }
                tsIsStartOfFunctionType() {
                    return !!this.isRelational("<") || this.match(c6.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                }
                tsSkipParameterStart() {
                    if (this.match(c6.name) || this.match(c6._this)) return this.next(), !0;
                    if (this.match(c6.braceL)) {
                        let t22 = 1;
                        for(this.next(); t22 > 0;)this.match(c6.braceL) ? ++t22 : this.match(c6.braceR) && --t22, this.next();
                        return !0;
                    }
                    if (this.match(c6.bracketL)) {
                        let t22 = 1;
                        for(this.next(); t22 > 0;)this.match(c6.bracketL) ? ++t22 : this.match(c6.bracketR) && --t22, this.next();
                        return !0;
                    }
                    return !1;
                }
                tsIsUnambiguouslyStartOfFunctionType() {
                    if (this.next(), this.match(c6.parenR) || this.match(c6.ellipsis)) return !0;
                    if (this.tsSkipParameterStart()) {
                        if (this.match(c6.colon) || this.match(c6.comma) || this.match(c6.question) || this.match(c6.eq)) return !0;
                        if (this.match(c6.parenR) && (this.next(), this.match(c6.arrow))) return !0;
                    }
                    return !1;
                }
                tsParseTypeOrTypePredicateAnnotation(t) {
                    return this.tsInType(()=>{
                        const e25 = this.startNode();
                        this.expect(t);
                        const s7 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                        if (s7 && this.match(c6._this)) {
                            let t22 = this.tsParseThisTypeOrThisTypePredicate();
                            if ("TSThisType" === t22.type) {
                                const s8 = this.startNodeAtNode(e25);
                                s8.parameterName = t22, s8.asserts = !0, t22 = this.finishNode(s8, "TSTypePredicate");
                            } else t22.asserts = !0;
                            return e25.typeAnnotation = t22, this.finishNode(e25, "TSTypeAnnotation");
                        }
                        const r8 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                        if (!r8) {
                            if (!s7) return this.tsParseTypeAnnotation(!1, e25);
                            const t22 = this.startNodeAtNode(e25);
                            return t22.parameterName = this.parseIdentifier(), t22.asserts = s7, e25.typeAnnotation = this.finishNode(t22, "TSTypePredicate"), this.finishNode(e25, "TSTypeAnnotation");
                        }
                        const i7 = this.tsParseTypeAnnotation(!1), n9 = this.startNodeAtNode(e25);
                        return n9.parameterName = r8, n9.typeAnnotation = i7, n9.asserts = s7, e25.typeAnnotation = this.finishNode(n9, "TSTypePredicate"), this.finishNode(e25, "TSTypeAnnotation");
                    });
                }
                tsTryParseTypeOrTypePredicateAnnotation() {
                    return this.match(c6.colon) ? this.tsParseTypeOrTypePredicateAnnotation(c6.colon) : void 0;
                }
                tsTryParseTypeAnnotation() {
                    return this.match(c6.colon) ? this.tsParseTypeAnnotation() : void 0;
                }
                tsTryParseType() {
                    return this.tsEatThenParseType(c6.colon);
                }
                tsParseTypePredicatePrefix() {
                    const t22 = this.parseIdentifier();
                    if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), t22;
                }
                tsParseTypePredicateAsserts() {
                    if (!this.match(c6.name) || "asserts" !== this.state.value || this.hasPrecedingLineBreak()) return !1;
                    const t22 = this.state.containsEsc;
                    return this.next(), !(!this.match(c6.name) && !this.match(c6._this)) && (t22 && this.raise(this.state.lastTokStart, g6.InvalidEscapedReservedWord, "asserts"), !0);
                }
                tsParseTypeAnnotation(t = !0, e = this.startNode()) {
                    return this.tsInType(()=>{
                        t && this.expect(c6.colon), e.typeAnnotation = this.tsParseType();
                    }), this.finishNode(e, "TSTypeAnnotation");
                }
                tsParseType() {
                    lt3(this.state.inType);
                    const t22 = this.tsParseNonConditionalType();
                    if (this.hasPrecedingLineBreak() || !this.eat(c6._extends)) return t22;
                    const e25 = this.startNodeAtNode(t22);
                    return e25.checkType = t22, e25.extendsType = this.tsParseNonConditionalType(), this.expect(c6.question), e25.trueType = this.tsParseType(), this.expect(c6.colon), e25.falseType = this.tsParseType(), this.finishNode(e25, "TSConditionalType");
                }
                tsParseNonConditionalType() {
                    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(c6._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.tsParseUnionTypeOrHigher();
                }
                tsParseTypeAssertion() {
                    const t22 = this.startNode(), e25 = this.tsTryNextParseConstantContext();
                    return t22.typeAnnotation = e25 || this.tsNextThenParseType(), this.expectRelational(">"), t22.expression = this.parseMaybeUnary(), this.finishNode(t22, "TSTypeAssertion");
                }
                tsParseHeritageClause(t) {
                    const e25 = this.state.start, s7 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
                    return s7.length || this.raise(e25, dt3.EmptyHeritageClauseType, t), s7;
                }
                tsParseExpressionWithTypeArguments() {
                    const t22 = this.startNode();
                    return t22.expression = this.tsParseEntityName(!1), this.isRelational("<") && (t22.typeParameters = this.tsParseTypeArguments()), this.finishNode(t22, "TSExpressionWithTypeArguments");
                }
                tsParseInterfaceDeclaration(t) {
                    t.id = this.parseIdentifier(), this.checkLVal(t.id, 130, void 0, "typescript interface declaration"), t.typeParameters = this.tsTryParseTypeParameters(), this.eat(c6._extends) && (t.extends = this.tsParseHeritageClause("extends"));
                    const e25 = this.startNode();
                    return e25.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(e25, "TSInterfaceBody"), this.finishNode(t, "TSInterfaceDeclaration");
                }
                tsParseTypeAliasDeclaration(t) {
                    return t.id = this.parseIdentifier(), this.checkLVal(t.id, 2, void 0, "typescript type alias"), t.typeParameters = this.tsTryParseTypeParameters(), t.typeAnnotation = this.tsInType(()=>{
                        if (this.expect(c6.eq), this.isContextual("intrinsic") && this.lookahead().type !== c6.dot) {
                            const t22 = this.startNode();
                            return this.next(), this.finishNode(t22, "TSIntrinsicKeyword");
                        }
                        return this.tsParseType();
                    }), this.semicolon(), this.finishNode(t, "TSTypeAliasDeclaration");
                }
                tsInNoContext(t) {
                    const e25 = this.state.context;
                    this.state.context = [
                        e25[0]
                    ];
                    try {
                        return t();
                    } finally{
                        this.state.context = e25;
                    }
                }
                tsInType(t) {
                    const e25 = this.state.inType;
                    this.state.inType = !0;
                    try {
                        return t();
                    } finally{
                        this.state.inType = e25;
                    }
                }
                tsEatThenParseType(t) {
                    return this.match(t) ? this.tsNextThenParseType() : void 0;
                }
                tsExpectThenParseType(t) {
                    return this.tsDoThenParseType(()=>this.expect(t)
                    );
                }
                tsNextThenParseType() {
                    return this.tsDoThenParseType(()=>this.next()
                    );
                }
                tsDoThenParseType(t) {
                    return this.tsInType(()=>(t(), this.tsParseType())
                    );
                }
                tsParseEnumMember() {
                    const t22 = this.startNode();
                    return t22.id = this.match(c6.string) ? this.parseExprAtom() : this.parseIdentifier(!0), this.eat(c6.eq) && (t22.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(t22, "TSEnumMember");
                }
                tsParseEnumDeclaration(t, e) {
                    return e && (t.const = !0), t.id = this.parseIdentifier(), this.checkLVal(t.id, e ? 779 : 267, void 0, "typescript enum declaration"), this.expect(c6.braceL), t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(c6.braceR), this.finishNode(t, "TSEnumDeclaration");
                }
                tsParseModuleBlock() {
                    const t22 = this.startNode();
                    return this.scope.enter(0), this.expect(c6.braceL), this.parseBlockOrModuleBlockBody(t22.body = [], void 0, !0, c6.braceR), this.scope.exit(), this.finishNode(t22, "TSModuleBlock");
                }
                tsParseModuleOrNamespaceDeclaration(t, e = !1) {
                    if (t.id = this.parseIdentifier(), e || this.checkLVal(t.id, 1024, null, "module or namespace declaration"), this.eat(c6.dot)) {
                        const e25 = this.startNode();
                        this.tsParseModuleOrNamespaceDeclaration(e25, !0), t.body = e25;
                    } else this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
                    return this.finishNode(t, "TSModuleDeclaration");
                }
                tsParseAmbientExternalModuleDeclaration(t) {
                    return this.isContextual("global") ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(c6.string) ? t.id = this.parseExprAtom() : this.unexpected(), this.match(c6.braceL) ? (this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, "TSModuleDeclaration");
                }
                tsParseImportEqualsDeclaration(t, e) {
                    return t.isExport = e || !1, t.id = this.parseIdentifier(), this.checkLVal(t.id, 9, void 0, "import equals declaration"), this.expect(c6.eq), t.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t, "TSImportEqualsDeclaration");
                }
                tsIsExternalModuleReference() {
                    return this.isContextual("require") && 40 === this.lookaheadCharCode();
                }
                tsParseModuleReference() {
                    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
                }
                tsParseExternalModuleReference() {
                    const t22 = this.startNode();
                    if (this.expectContextual("require"), this.expect(c6.parenL), !this.match(c6.string)) throw this.unexpected();
                    return t22.expression = this.parseExprAtom(), this.expect(c6.parenR), this.finishNode(t22, "TSExternalModuleReference");
                }
                tsLookAhead(t) {
                    const e25 = this.state.clone(), s7 = t();
                    return this.state = e25, s7;
                }
                tsTryParseAndCatch(t) {
                    const e25 = this.tryParse((e26)=>t() || e26()
                    );
                    if (!e25.aborted && e25.node) return e25.error && (this.state = e25.failState), e25.node;
                }
                tsTryParse(t) {
                    const e25 = this.state.clone(), s7 = t();
                    return (void 0) !== s7 && !1 !== s7 ? s7 : void (this.state = e25);
                }
                tsTryParseDeclare(t) {
                    if (this.isLineTerminator()) return;
                    let e25, s7 = this.state.type;
                    return this.isContextual("let") && (s7 = c6._var, e25 = "let"), this.tsInDeclareContext(()=>{
                        switch(s7){
                            case c6._function:
                                return t.declare = !0, this.parseFunctionStatement(t, !1, !0);
                            case c6._class:
                                return t.declare = !0, this.parseClass(t, !0, !1);
                            case c6._const:
                                if (this.match(c6._const) && this.isLookaheadContextual("enum")) return this.expect(c6._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t, !0);
                            case c6._var:
                                return e25 = e25 || this.state.value, this.parseVarStatement(t, e25);
                            case c6.name:
                                {
                                    const e26 = this.state.value;
                                    return "global" === e26 ? this.tsParseAmbientExternalModuleDeclaration(t) : this.tsParseDeclaration(t, e26, !0);
                                }
                        }
                    });
                }
                tsTryParseExportDeclaration() {
                    return this.tsParseDeclaration(this.startNode(), this.state.value, !0);
                }
                tsParseExpressionStatement(t, e) {
                    switch(e.name){
                        case "declare":
                            {
                                const e25 = this.tsTryParseDeclare(t);
                                if (e25) return e25.declare = !0, e25;
                                break;
                            }
                        case "global":
                            if (this.match(c6.braceL)) {
                                this.scope.enter(128), this.prodParam.enter(0);
                                const s7 = t;
                                return t.global = !0, t.id = e, t.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(t, "TSModuleDeclaration");
                            }
                            break;
                        default:
                            return this.tsParseDeclaration(t, e.name, !1);
                    }
                }
                tsParseDeclaration(t, e, s) {
                    switch(e){
                        case "abstract":
                            if (this.tsCheckLineTerminatorAndMatch(c6._class, s)) {
                                const e25 = t;
                                return t.abstract = !0, s && (this.next(), this.match(c6._class) || this.unexpected(null, c6._class)), this.parseClass(t, !0, !1);
                            }
                            break;
                        case "enum":
                            if (s || this.match(c6.name)) return s && this.next(), this.tsParseEnumDeclaration(t, !1);
                            break;
                        case "interface":
                            if (this.tsCheckLineTerminatorAndMatch(c6.name, s)) return s && this.next(), this.tsParseInterfaceDeclaration(t);
                            break;
                        case "module":
                            if (s && this.next(), this.match(c6.string)) return this.tsParseAmbientExternalModuleDeclaration(t);
                            if (this.tsCheckLineTerminatorAndMatch(c6.name, s)) return this.tsParseModuleOrNamespaceDeclaration(t);
                            break;
                        case "namespace":
                            if (this.tsCheckLineTerminatorAndMatch(c6.name, s)) return s && this.next(), this.tsParseModuleOrNamespaceDeclaration(t);
                            break;
                        case "type":
                            if (this.tsCheckLineTerminatorAndMatch(c6.name, s)) return s && this.next(), this.tsParseTypeAliasDeclaration(t);
                    }
                }
                tsCheckLineTerminatorAndMatch(t, e) {
                    return (e || this.match(t)) && !this.isLineTerminator();
                }
                tsTryParseGenericAsyncArrowFunction(t, e) {
                    if (!this.isRelational("<")) return;
                    const s7 = this.state.maybeInArrowParameters;
                    this.state.maybeInArrowParameters = !0;
                    const r8 = this.tsTryParseAndCatch(()=>{
                        const s8 = this.startNodeAt(t, e);
                        return s8.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s8), s8.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(c6.arrow), s8;
                    });
                    return this.state.maybeInArrowParameters = s7, r8 ? this.parseArrowExpression(r8, null, !0) : void 0;
                }
                tsParseTypeArguments() {
                    const t22 = this.startNode();
                    return t22.params = this.tsInType(()=>this.tsInNoContext(()=>(this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this)))
                        )
                    ), 0 === t22.params.length && this.raise(t22.start, dt3.EmptyTypeArguments), this.state.exprAllowed = !1, this.expectRelational(">"), this.finishNode(t22, "TSTypeParameterInstantiation");
                }
                tsIsDeclarationStart() {
                    if (this.match(c6.name)) switch(this.state.value){
                        case "abstract":
                        case "declare":
                        case "enum":
                        case "interface":
                        case "module":
                        case "namespace":
                        case "type":
                            return !0;
                    }
                    return !1;
                }
                isExportDefaultSpecifier() {
                    return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
                }
                parseAssignableListItem(t, e) {
                    const s7 = this.state.start, r8 = this.state.startLoc;
                    let i7, n9 = !1;
                    (void 0) !== t && (i7 = this.parseAccessModifier(), n9 = !!this.tsParseModifier([
                        "readonly"
                    ]), !1 === t && (i7 || n9) && this.raise(s7, dt3.UnexpectedParameterModifier));
                    const a6 = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(a6);
                    const o6 = this.parseMaybeDefault(a6.start, a6.loc.start, a6);
                    if (i7 || n9) {
                        const t22 = this.startNodeAt(s7, r8);
                        return e.length && (t22.decorators = e), i7 && (t22.accessibility = i7), n9 && (t22.readonly = n9), "Identifier" !== o6.type && "AssignmentPattern" !== o6.type && this.raise(t22.start, dt3.UnsupportedParameterPropertyKind), t22.parameter = o6, this.finishNode(t22, "TSParameterProperty");
                    }
                    return e.length && (a6.decorators = e), o6;
                }
                parseFunctionBodyAndFinish(t, e, s = !1) {
                    this.match(c6.colon) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(c6.colon));
                    const r8 = "FunctionDeclaration" === e ? "TSDeclareFunction" : "ClassMethod" === e ? "TSDeclareMethod" : void 0;
                    r8 && !this.match(c6.braceL) && this.isLineTerminator() ? this.finishNode(t, r8) : "TSDeclareFunction" === r8 && this.state.isDeclareContext && (this.raise(t.start, dt3.DeclareFunctionHasImplementation), t.declare) ? super.parseFunctionBodyAndFinish(t, r8, s) : super.parseFunctionBodyAndFinish(t, e, s);
                }
                registerFunctionStatementId(t) {
                    !t.body && t.id ? this.checkLVal(t.id, 1024, null, "function name") : super.registerFunctionStatementId(...arguments);
                }
                tsCheckForInvalidTypeCasts(t) {
                    t.forEach((t22)=>{
                        "TSTypeCastExpression" === (null == t22 ? void 0 : t22.type) && this.raise(t22.typeAnnotation.start, dt3.UnexpectedTypeAnnotation);
                    });
                }
                toReferencedList(t, e) {
                    return this.tsCheckForInvalidTypeCasts(t), t;
                }
                parseArrayLike(...t) {
                    const e25 = super.parseArrayLike(...t);
                    return "ArrayExpression" === e25.type && this.tsCheckForInvalidTypeCasts(e25.elements), e25;
                }
                parseSubscript(t, e, s, r, i) {
                    if (!this.hasPrecedingLineBreak() && this.match(c6.bang)) {
                        this.state.exprAllowed = !1, this.next();
                        const r8 = this.startNodeAt(e, s);
                        return r8.expression = t, this.finishNode(r8, "TSNonNullExpression");
                    }
                    if (this.isRelational("<")) {
                        const n9 = this.tsTryParseAndCatch(()=>{
                            if (!r && this.atPossibleAsyncArrow(t)) {
                                const t22 = this.tsTryParseGenericAsyncArrowFunction(e, s);
                                if (t22) return t22;
                            }
                            const n10 = this.startNodeAt(e, s);
                            n10.callee = t;
                            const a6 = this.tsParseTypeArguments();
                            if (a6) {
                                if (!r && this.eat(c6.parenL)) return n10.arguments = this.parseCallExpressionArguments(c6.parenR, !1), this.tsCheckForInvalidTypeCasts(n10.arguments), n10.typeParameters = a6, this.finishCallExpression(n10, i.optionalChainMember);
                                if (this.match(c6.backQuote)) {
                                    const r8 = this.parseTaggedTemplateExpression(t, e, s, i);
                                    return r8.typeParameters = a6, r8;
                                }
                            }
                            this.unexpected();
                        });
                        if (n9) return n9;
                    }
                    return super.parseSubscript(t, e, s, r, i);
                }
                parseNewArguments(t) {
                    if (this.isRelational("<")) {
                        const e25 = this.tsTryParseAndCatch(()=>{
                            const t22 = this.tsParseTypeArguments();
                            return this.match(c6.parenL) || this.unexpected(), t22;
                        });
                        e25 && (t.typeParameters = e25);
                    }
                    super.parseNewArguments(t);
                }
                parseExprOp(t, e, s, r) {
                    if (pt3(c6._in.binop) > r && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
                        const i7 = this.startNodeAt(e, s);
                        i7.expression = t;
                        const n9 = this.tsTryNextParseConstantContext();
                        return i7.typeAnnotation = n9 || this.tsNextThenParseType(), this.finishNode(i7, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i7, e, s, r);
                    }
                    return super.parseExprOp(t, e, s, r);
                }
                checkReservedWord(t, e, s, r) {
                }
                checkDuplicateExports() {
                }
                parseImport(t) {
                    if (this.match(c6.name) || this.match(c6.star) || this.match(c6.braceL)) {
                        const e25 = this.lookahead();
                        if (this.match(c6.name) && e25.type === c6.eq) return this.tsParseImportEqualsDeclaration(t);
                        !this.isContextual("type") || e25.type === c6.comma || e25.type === c6.name && "from" === e25.value || (t.importKind = "type", this.next());
                    }
                    t.importKind || (t.importKind = "value");
                    const e25 = super.parseImport(t);
                    return "type" === e25.importKind && e25.specifiers.length > 1 && "ImportDefaultSpecifier" === e25.specifiers[0].type && this.raise(e25.start, "A type-only import can specify a default import or named bindings, but not both."), e25;
                }
                parseExport(t) {
                    if (this.match(c6._import)) return this.expect(c6._import), this.tsParseImportEqualsDeclaration(t, !0);
                    if (this.eat(c6.eq)) {
                        const e25 = t;
                        return t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "TSExportAssignment");
                    }
                    if (this.eatContextual("as")) {
                        const e25 = t;
                        return this.expectContextual("namespace"), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
                    }
                    return this.isContextual("type") && this.lookahead().type === c6.braceL ? (this.next(), t.exportKind = "type") : t.exportKind = "value", super.parseExport(t);
                }
                isAbstractClass() {
                    return this.isContextual("abstract") && this.lookahead().type === c6._class;
                }
                parseExportDefaultExpression() {
                    if (this.isAbstractClass()) {
                        const t22 = this.startNode();
                        return this.next(), this.parseClass(t22, !0, !0), t22.abstract = !0, t22;
                    }
                    if ("interface" === this.state.value) {
                        const t22 = this.tsParseDeclaration(this.startNode(), this.state.value, !0);
                        if (t22) return t22;
                    }
                    return super.parseExportDefaultExpression();
                }
                parseStatementContent(t, e) {
                    if (this.state.type === c6._const) {
                        const t22 = this.lookahead();
                        if (t22.type === c6.name && "enum" === t22.value) {
                            const t23 = this.startNode();
                            return this.expect(c6._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t23, !0);
                        }
                    }
                    return super.parseStatementContent(t, e);
                }
                parseAccessModifier() {
                    return this.tsParseModifier([
                        "public",
                        "protected",
                        "private"
                    ]);
                }
                parseClassMember(t, e, s) {
                    this.tsParseModifiers(e, [
                        "declare"
                    ]);
                    const r8 = this.parseAccessModifier();
                    r8 && (e.accessibility = r8), this.tsParseModifiers(e, [
                        "declare"
                    ]);
                    const i7 = ()=>{
                        super.parseClassMember(t, e, s);
                    };
                    e.declare ? this.tsInDeclareContext(i7) : i7();
                }
                parseClassMemberWithIsStatic(t, e, s, r) {
                    this.tsParseModifiers(e, [
                        "abstract",
                        "readonly",
                        "declare"
                    ]);
                    const i7 = this.tsTryParseIndexSignature(e);
                    if (i7) return t.body.push(i7), e.abstract && this.raise(e.start, dt3.IndexSignatureHasAbstract), r && this.raise(e.start, dt3.IndexSignatureHasStatic), e.accessibility && this.raise(e.start, dt3.IndexSignatureHasAccessibility, e.accessibility), void (e.declare && this.raise(e.start, dt3.IndexSignatureHasDeclare));
                    super.parseClassMemberWithIsStatic(t, e, s, r);
                }
                parsePostMemberNameModifiers(t) {
                    this.eat(c6.question) && (t.optional = !0), t.readonly && this.match(c6.parenL) && this.raise(t.start, dt3.ClassMethodHasReadonly), t.declare && this.match(c6.parenL) && this.raise(t.start, dt3.ClassMethodHasDeclare);
                }
                parseExpressionStatement(t, e) {
                    return ("Identifier" === e.type ? this.tsParseExpressionStatement(t, e) : void 0) || super.parseExpressionStatement(t, e);
                }
                shouldParseExportDeclaration() {
                    return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
                }
                parseConditional(t, e, s, r) {
                    if (!r || !this.match(c6.question)) return super.parseConditional(t, e, s, r);
                    const i7 = this.tryParse(()=>super.parseConditional(t, e, s)
                    );
                    return i7.node ? (i7.error && (this.state = i7.failState), i7.node) : (r.start = i7.error.pos || this.state.start, t);
                }
                parseParenItem(t, e, s) {
                    if (t = super.parseParenItem(t, e, s), this.eat(c6.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(c6.colon)) {
                        const r8 = this.startNodeAt(e, s);
                        return r8.expression = t, r8.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r8, "TSTypeCastExpression");
                    }
                    return t;
                }
                parseExportDeclaration(t) {
                    const e25 = this.state.start, s7 = this.state.startLoc, r8 = this.eatContextual("declare");
                    let i7;
                    return this.match(c6.name) && (i7 = this.tsTryParseExportDeclaration()), i7 || (i7 = super.parseExportDeclaration(t)), i7 && ("TSInterfaceDeclaration" === i7.type || "TSTypeAliasDeclaration" === i7.type || r8) && (t.exportKind = "type"), i7 && r8 && (this.resetStartLocation(i7, e25, s7), i7.declare = !0), i7;
                }
                parseClassId(t, e, s) {
                    if ((!e || s) && this.isContextual("implements")) return;
                    super.parseClassId(t, e, s, t.declare ? 1024 : 139);
                    const r8 = this.tsTryParseTypeParameters();
                    r8 && (t.typeParameters = r8);
                }
                parseClassPropertyAnnotation(t) {
                    !t.optional && this.eat(c6.bang) && (t.definite = !0);
                    const e25 = this.tsTryParseTypeAnnotation();
                    e25 && (t.typeAnnotation = e25);
                }
                parseClassProperty(t) {
                    return this.parseClassPropertyAnnotation(t), this.state.isDeclareContext && this.match(c6.eq) && this.raise(this.state.start, dt3.DeclareClassFieldHasInitializer), super.parseClassProperty(t);
                }
                parseClassPrivateProperty(t) {
                    return t.abstract && this.raise(t.start, dt3.PrivateElementHasAbstract), t.accessibility && this.raise(t.start, dt3.PrivateElementHasAccessibility, t.accessibility), this.parseClassPropertyAnnotation(t), super.parseClassPrivateProperty(t);
                }
                pushClassMethod(t, e, s, r, i, n) {
                    const a6 = this.tsTryParseTypeParameters();
                    a6 && i && this.raise(a6.start, dt3.ConstructorHasTypeParameters), a6 && (e.typeParameters = a6), super.pushClassMethod(t, e, s, r, i, n);
                }
                pushClassPrivateMethod(t, e, s, r) {
                    const i7 = this.tsTryParseTypeParameters();
                    i7 && (e.typeParameters = i7), super.pushClassPrivateMethod(t, e, s, r);
                }
                parseClassSuper(t) {
                    super.parseClassSuper(t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (t.implements = this.tsParseHeritageClause("implements"));
                }
                parseObjPropValue(t, ...e) {
                    const s7 = this.tsTryParseTypeParameters();
                    s7 && (t.typeParameters = s7), super.parseObjPropValue(t, ...e);
                }
                parseFunctionParams(t, e) {
                    const s7 = this.tsTryParseTypeParameters();
                    s7 && (t.typeParameters = s7), super.parseFunctionParams(t, e);
                }
                parseVarId(t, e) {
                    super.parseVarId(t, e), "Identifier" === t.id.type && this.eat(c6.bang) && (t.definite = !0);
                    const s7 = this.tsTryParseTypeAnnotation();
                    s7 && (t.id.typeAnnotation = s7, this.resetEndLocation(t.id));
                }
                parseAsyncArrowFromCallExpression(t, e) {
                    return this.match(c6.colon) && (t.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t, e);
                }
                parseMaybeAssign(...t) {
                    var e25, s7, r8, i7, n9, a6, o6;
                    let u5, h6, p7, l6;
                    if (this.match(c6.jsxTagStart)) {
                        if (u5 = this.state.clone(), h6 = this.tryParse(()=>super.parseMaybeAssign(...t)
                        , u5), !h6.error) return h6.node;
                        const { context: e26  } = this.state;
                        e26[e26.length - 1] === T5.j_oTag ? e26.length -= 2 : e26[e26.length - 1] === T5.j_expr && (e26.length -= 1);
                    }
                    if (!(null == (e25 = h6) ? void 0 : e25.error) && !this.isRelational("<")) return super.parseMaybeAssign(...t);
                    u5 = u5 || this.state.clone();
                    const d7 = this.tryParse((e26)=>{
                        var s8;
                        l6 = this.tsParseTypeParameters();
                        const r9 = super.parseMaybeAssign(...t);
                        return ("ArrowFunctionExpression" !== r9.type || r9.extra && r9.extra.parenthesized) && e26(), 0 !== (null == (s8 = l6) ? void 0 : s8.params.length) && this.resetStartLocationFromNode(r9, l6), r9.typeParameters = l6, r9;
                    }, u5);
                    if (!d7.error && !d7.aborted) return d7.node;
                    if (!h6 && (lt3(!this.hasPlugin("jsx")), p7 = this.tryParse(()=>super.parseMaybeAssign(...t)
                    , u5), !p7.error)) return p7.node;
                    if (null == (s7 = h6) ? void 0 : s7.node) return this.state = h6.failState, h6.node;
                    if (d7.node) return this.state = d7.failState, d7.node;
                    if (null == (r8 = p7) ? void 0 : r8.node) return this.state = p7.failState, p7.node;
                    if (null == (i7 = h6) ? void 0 : i7.thrown) throw h6.error;
                    if (d7.thrown) throw d7.error;
                    if (null == (n9 = p7) ? void 0 : n9.thrown) throw p7.error;
                    throw (null == (a6 = h6) ? void 0 : a6.error) || d7.error || (null == (o6 = p7) ? void 0 : o6.error);
                }
                parseMaybeUnary(t) {
                    return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t);
                }
                parseArrow(t) {
                    if (this.match(c6.colon)) {
                        const e25 = this.tryParse((t22)=>{
                            const e26 = this.tsParseTypeOrTypePredicateAnnotation(c6.colon);
                            return !this.canInsertSemicolon() && this.match(c6.arrow) || t22(), e26;
                        });
                        if (e25.aborted) return;
                        e25.thrown || (e25.error && (this.state = e25.failState), t.returnType = e25.node);
                    }
                    return super.parseArrow(t);
                }
                parseAssignableListItemTypes(t) {
                    this.eat(c6.question) && ("Identifier" === t.type || this.state.isDeclareContext || this.state.inType || this.raise(t.start, dt3.PatternIsOptional), t.optional = !0);
                    const e25 = this.tsTryParseTypeAnnotation();
                    return e25 && (t.typeAnnotation = e25), this.resetEndLocation(t), t;
                }
                toAssignable(t) {
                    switch(t.type){
                        case "TSTypeCastExpression":
                            return super.toAssignable(this.typeCastToParameter(t));
                        case "TSParameterProperty":
                            return super.toAssignable(t);
                        case "TSAsExpression":
                        case "TSNonNullExpression":
                        case "TSTypeAssertion":
                            return t.expression = this.toAssignable(t.expression), t;
                        default:
                            return super.toAssignable(t);
                    }
                }
                checkLVal(t, e = 64, s, r) {
                    switch(t.type){
                        case "TSTypeCastExpression":
                            return;
                        case "TSParameterProperty":
                            return void this.checkLVal(t.parameter, e, s, "parameter property");
                        case "TSAsExpression":
                        case "TSNonNullExpression":
                        case "TSTypeAssertion":
                            return void this.checkLVal(t.expression, e, s, r);
                        default:
                            return void super.checkLVal(t, e, s, r);
                    }
                }
                parseBindingAtom() {
                    switch(this.state.type){
                        case c6._this:
                            return this.parseIdentifier(!0);
                        default:
                            return super.parseBindingAtom();
                    }
                }
                parseMaybeDecoratorArguments(t) {
                    if (this.isRelational("<")) {
                        const e25 = this.tsParseTypeArguments();
                        if (this.match(c6.parenL)) {
                            const s7 = super.parseMaybeDecoratorArguments(t);
                            return s7.typeParameters = e25, s7;
                        }
                        this.unexpected(this.state.start, c6.parenL);
                    }
                    return super.parseMaybeDecoratorArguments(t);
                }
                isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                }
                isClassProperty() {
                    return this.match(c6.bang) || this.match(c6.colon) || super.isClassProperty();
                }
                parseMaybeDefault(...t) {
                    const e25 = super.parseMaybeDefault(...t);
                    return "AssignmentPattern" === e25.type && e25.typeAnnotation && e25.right.start < e25.typeAnnotation.start && this.raise(e25.typeAnnotation.start, dt3.TypeAnnotationAfterAssign), e25;
                }
                getTokenFromCode(t) {
                    return !this.state.inType || 62 !== t && 60 !== t ? super.getTokenFromCode(t) : this.finishOp(c6.relational, 1);
                }
                reScan_lt_gt() {
                    if (this.match(c6.relational)) {
                        const t22 = this.input.charCodeAt(this.state.start);
                        60 !== t22 && 62 !== t22 || (this.state.pos -= 1, this.readToken_lt_gt(t22));
                    }
                }
                toAssignableList(t) {
                    for(let e25 = 0; e25 < t.length; e25++){
                        const s7 = t[e25];
                        if (s7) switch(s7.type){
                            case "TSTypeCastExpression":
                                t[e25] = this.typeCastToParameter(s7);
                                break;
                            case "TSAsExpression":
                            case "TSTypeAssertion":
                                this.state.maybeInArrowParameters ? this.raise(s7.start, dt3.UnexpectedTypeCastInParameter) : t[e25] = this.typeCastToParameter(s7);
                        }
                    }
                    return super.toAssignableList(...arguments);
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;
                }
                shouldParseArrow() {
                    return this.match(c6.colon) || super.shouldParseArrow();
                }
                shouldParseAsyncArrow() {
                    return this.match(c6.colon) || super.shouldParseAsyncArrow();
                }
                canHaveLeadingDecorator() {
                    return super.canHaveLeadingDecorator() || this.isAbstractClass();
                }
                jsxParseOpeningElementAfterName(t) {
                    if (this.isRelational("<")) {
                        const e25 = this.tsTryParseAndCatch(()=>this.tsParseTypeArguments()
                        );
                        e25 && (t.typeParameters = e25);
                    }
                    return super.jsxParseOpeningElementAfterName(t);
                }
                getGetterSetterExpectedParamCount(t) {
                    const e25 = super.getGetterSetterExpectedParamCount(t), s7 = t.params[0];
                    return s7 && "Identifier" === s7.type && "this" === s7.name ? e25 + 1 : e25;
                }
                parseCatchClauseParam() {
                    const t22 = super.parseCatchClauseParam(), e25 = this.tsTryParseTypeAnnotation();
                    return e25 && (t22.typeAnnotation = e25, this.resetEndLocation(t22)), t22;
                }
                tsInDeclareContext(t) {
                    const e25 = this.state.isDeclareContext;
                    this.state.isDeclareContext = !0;
                    try {
                        return t();
                    } finally{
                        this.state.isDeclareContext = e25;
                    }
                }
            }
        ,
        v8intrinsic: (t21)=>class extends t21 {
                parseV8Intrinsic() {
                    if (this.match(c6.modulo)) {
                        const t22 = this.state.start, e25 = this.startNode();
                        if (this.eat(c6.modulo), this.match(c6.name)) {
                            const t23 = this.parseIdentifierName(this.state.start), s7 = this.createIdentifier(e25, t23);
                            if (s7.type = "V8IntrinsicIdentifier", this.match(c6.parenL)) return s7;
                        }
                        this.unexpected(t22);
                    }
                }
                parseExprAtom() {
                    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
                }
            }
        ,
        placeholders: (t21)=>class extends t21 {
                parsePlaceholder(t) {
                    if (this.match(c6.placeholder)) {
                        const e25 = this.startNode();
                        return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e25.name = super.parseIdentifier(!0), this.assertNoSpace("Unexpected space in placeholder."), this.expect(c6.placeholder), this.finishPlaceholder(e25, t);
                    }
                }
                finishPlaceholder(t, e) {
                    const s7 = !(!t.expectedNode || "Placeholder" !== t.type);
                    return t.expectedNode = e, s7 ? t : this.finishNode(t, "Placeholder");
                }
                getTokenFromCode(t) {
                    return 37 === t && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c6.placeholder, 2) : super.getTokenFromCode(...arguments);
                }
                parseExprAtom() {
                    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
                }
                parseIdentifier() {
                    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
                }
                checkReservedWord(t) {
                    (void 0) !== t && super.checkReservedWord(...arguments);
                }
                parseBindingAtom() {
                    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
                }
                checkLVal(t) {
                    "Placeholder" !== t.type && super.checkLVal(...arguments);
                }
                toAssignable(t) {
                    return t && "Placeholder" === t.type && "Expression" === t.expectedNode ? (t.expectedNode = "Pattern", t) : super.toAssignable(...arguments);
                }
                verifyBreakContinue(t) {
                    t.label && "Placeholder" === t.label.type || super.verifyBreakContinue(...arguments);
                }
                parseExpressionStatement(t, e) {
                    if ("Placeholder" !== e.type || e.extra && e.extra.parenthesized) return super.parseExpressionStatement(...arguments);
                    if (this.match(c6.colon)) {
                        const s7 = t;
                        return t.label = this.finishPlaceholder(e, "Identifier"), this.next(), t.body = this.parseStatement("label"), this.finishNode(t, "LabeledStatement");
                    }
                    return this.semicolon(), t.name = e.name, this.finishPlaceholder(t, "Statement");
                }
                parseBlock() {
                    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
                }
                parseFunctionId() {
                    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
                }
                parseClass(t, e, s) {
                    const r8 = e ? "ClassDeclaration" : "ClassExpression";
                    this.next(), this.takeDecorators(t);
                    const i7 = this.state.strict, n9 = this.parsePlaceholder("Identifier");
                    if (n9) {
                        if (this.match(c6._extends) || this.match(c6.placeholder) || this.match(c6.braceL)) t.id = n9;
                        else {
                            if (s || !e) return t.id = null, t.body = this.finishPlaceholder(n9, "ClassBody"), this.finishNode(t, r8);
                            this.unexpected(null, "A class name is required");
                        }
                    } else this.parseClassId(t, e, s);
                    return this.parseClassSuper(t), t.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t.superClass, i7), this.finishNode(t, r8);
                }
                parseExport(t) {
                    const e25 = this.parsePlaceholder("Identifier");
                    if (!e25) return super.parseExport(...arguments);
                    if (!this.isContextual("from") && !this.match(c6.comma)) return t.specifiers = [], t.source = null, t.declaration = this.finishPlaceholder(e25, "Declaration"), this.finishNode(t, "ExportNamedDeclaration");
                    this.expectPlugin("exportDefaultFrom");
                    const s7 = this.startNode();
                    return s7.exported = e25, t.specifiers = [
                        this.finishNode(s7, "ExportDefaultSpecifier")
                    ], super.parseExport(t);
                }
                isExportDefaultSpecifier() {
                    if (this.match(c6._default)) {
                        const t22 = this.nextTokenStart();
                        if (this.isUnparsedContextual(t22, "from") && this.input.startsWith(c6.placeholder.label, this.nextTokenStartSince(t22 + 4))) return !0;
                    }
                    return super.isExportDefaultSpecifier();
                }
                maybeParseExportDefaultSpecifier(t) {
                    return !!(t.specifiers && t.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
                }
                checkExport(t) {
                    const { specifiers: e25  } = t;
                    (null == e25 ? void 0 : e25.length) && (t.specifiers = e25.filter((t22)=>"Placeholder" === t22.exported.type
                    )), super.checkExport(t), t.specifiers = e25;
                }
                parseImport(t) {
                    const e25 = this.parsePlaceholder("Identifier");
                    if (!e25) return super.parseImport(...arguments);
                    if (t.specifiers = [], !this.isContextual("from") && !this.match(c6.comma)) return t.source = this.finishPlaceholder(e25, "StringLiteral"), this.semicolon(), this.finishNode(t, "ImportDeclaration");
                    const s7 = this.startNodeAtNode(e25);
                    if (s7.local = e25, this.finishNode(s7, "ImportDefaultSpecifier"), t.specifiers.push(s7), this.eat(c6.comma)) {
                        this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t);
                    }
                    return this.expectContextual("from"), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, "ImportDeclaration");
                }
                parseImportSource() {
                    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
                }
            }
    }, At2 = Object.keys(Et2), Ct2 = {
        sourceType: "script",
        sourceFilename: void 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1
    };
    class xt2 {
        constructor(){
            this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inPipeline = !1, this.inType = !1, this.noAnonFunctionType = !1, this.inPropertyName = !1, this.hasFlowComment = !1, this.isIterator = !1, this.isDeclareContext = !1, this.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.decoratorStack = [
                []
            ], this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = c6.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [
                T5.braceStatement
            ], this.exprAllowed = !0, this.containsEsc = !1, this.octalPositions = [], this.exportedIdentifiers = [], this.tokensLength = 0;
        }
        init(t) {
            this.strict = !1 !== t.strictMode && "module" === t.sourceType, this.curLine = t.startLine, this.startLoc = this.endLoc = this.curPosition();
        }
        curPosition() {
            return new C5(this.curLine, this.pos - this.lineStart);
        }
        clone(t) {
            const e25 = new xt2, s7 = Object.keys(this);
            for(let r8 = 0, i7 = s7.length; r8 < i7; r8++){
                const i7 = s7[r8];
                let n9 = this[i7];
                !t && Array.isArray(n9) && (n9 = n9.slice()), e25[i7] = n9;
            }
            return e25;
        }
    }
    var Ft2 = function(t21) {
        return t21 >= 48 && t21 <= 57;
    };
    const gt2 = new Set([
        "g",
        "m",
        "s",
        "i",
        "y",
        "u"
    ]), bt2 = {
        decBinOct: [
            46,
            66,
            69,
            79,
            95,
            98,
            101,
            111
        ],
        hex: [
            46,
            88,
            95,
            120
        ]
    }, Pt2 = {
        bin: [
            48,
            49
        ]
    };
    Pt2.oct = [
        ...Pt2.bin,
        50,
        51,
        52,
        53,
        54,
        55
    ], Pt2.dec = [
        ...Pt2.oct,
        56,
        57
    ], Pt2.hex = [
        ...Pt2.dec,
        65,
        66,
        67,
        68,
        69,
        70,
        97,
        98,
        99,
        100,
        101,
        102
    ];
    class Tt2 {
        constructor(t21){
            this.type = t21.type, this.value = t21.value, this.start = t21.start, this.end = t21.end, this.loc = new x6(t21.startLoc, t21.endLoc);
        }
    }
    class wt2 {
        constructor(){
            this.shorthandAssign = -1, this.doubleProto = -1;
        }
    }
    class Bt3 {
        constructor(t22, e25, s7){
            this.type = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.range = void 0, this.leadingComments = void 0, this.trailingComments = void 0, this.innerComments = void 0, this.extra = void 0, this.type = "", this.start = e25, this.end = 0, this.loc = new x6(s7), (null == t22 ? void 0 : t22.options.ranges) && (this.range = [
                e25,
                0
            ]), (null == t22 ? void 0 : t22.filename) && (this.loc.filename = t22.filename);
        }
        __clone() {
            const t23 = new Bt3, e26 = Object.keys(this);
            for(let s8 = 0, r8 = e26.length; s8 < r8; s8++){
                const r8 = e26[s8];
                "leadingComments" !== r8 && "trailingComments" !== r8 && "innerComments" !== r8 && (t23[r8] = this[r8]);
            }
            return t23;
        }
    }
    const St2 = (t23)=>"ParenthesizedExpression" === t23.type ? St2(t23.expression) : t23
    ;
    class Nt2 {
        constructor(t23 = 0){
            this.type = void 0, this.type = t23;
        }
        canBeArrowParameterDeclaration() {
            return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
            return 3 === this.type;
        }
    }
    class It3 extends Nt2 {
        constructor(t24){
            super(t24), this.errors = new Map;
        }
        recordDeclarationError(t, e) {
            this.errors.set(t, e);
        }
        clearDeclarationError(t) {
            this.errors.delete(t);
        }
        iterateErrors(t) {
            this.errors.forEach(t);
        }
    }
    class vt2 {
        constructor(t25){
            this.stack = [
                new Nt2
            ], this.raise = t25;
        }
        enter(t) {
            this.stack.push(t);
        }
        exit() {
            this.stack.pop();
        }
        recordParameterInitializerError(t, e) {
            const { stack: s8  } = this;
            let r8 = s8.length - 1, i7 = s8[r8];
            for(; !i7.isCertainlyParameterDeclaration();){
                if (!i7.canBeArrowParameterDeclaration()) return;
                i7.recordDeclarationError(t, e), i7 = s8[--r8];
            }
            this.raise(t, e);
        }
        recordAsyncArrowParametersError(t, e) {
            const { stack: s8  } = this;
            let r8 = s8.length - 1, i7 = s8[r8];
            for(; i7.canBeArrowParameterDeclaration();)2 === i7.type && i7.recordDeclarationError(t, e), i7 = s8[--r8];
        }
        validateAsPattern() {
            const { stack: t26  } = this, e26 = t26[t26.length - 1];
            e26.canBeArrowParameterDeclaration() && e26.iterateErrors((e27, s8)=>{
                this.raise(s8, e27);
                let r8 = t26.length - 2, i7 = t26[r8];
                for(; i7.canBeArrowParameterDeclaration();)i7.clearDeclarationError(s8), i7 = t26[--r8];
            });
        }
    }
    function kt2() {
        return new Nt2;
    }
    const Lt3 = {
        kind: "loop"
    }, Ot2 = {
        kind: "switch"
    }, Mt3 = /[\uD800-\uDFFF]/u;
    class Rt2 {
        constructor(){
            this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
        }
    }
    class _t3 {
        constructor(t26){
            this.stack = [], this.undefinedPrivateNames = new Map, this.raise = t26;
        }
        current() {
            return this.stack[this.stack.length - 1];
        }
        enter() {
            this.stack.push(new Rt2);
        }
        exit() {
            const t27 = this.stack.pop(), e26 = this.current();
            for(let s8 = 0, r8 = Array.from(t27.undefinedPrivateNames); s8 < r8.length; s8++){
                const [t28, i7] = r8[s8];
                e26 ? e26.undefinedPrivateNames.has(t28) || e26.undefinedPrivateNames.set(t28, i7) : this.raise(i7, g6.InvalidPrivateFieldResolution, t28);
            }
        }
        declarePrivateName(t, e, s) {
            const r8 = this.current();
            let i7 = r8.privateNames.has(t);
            if (3 & e) {
                const s8 = i7 && r8.loneAccessors.get(t);
                if (s8) {
                    const n9 = 4 & s8, a6 = 4 & e;
                    i7 = (3 & s8) === (3 & e) || n9 !== a6, i7 || r8.loneAccessors.delete(t);
                } else i7 || r8.loneAccessors.set(t, e);
            }
            i7 && this.raise(s, g6.PrivateNameRedeclaration, t), r8.privateNames.add(t), r8.undefinedPrivateNames.delete(t);
        }
        usePrivateName(t, e) {
            let s8;
            for(let e26 = 0, r8 = this.stack; e26 < r8.length; e26++)if (s8 = r8[e26], s8.privateNames.has(t)) return;
            s8 ? s8.undefinedPrivateNames.set(t, e) : this.raise(e, g6.InvalidPrivateFieldResolution, t);
        }
    }
    class jt3 extends class extends class extends class extends class extends class extends class extends class extends class extends class {
        constructor(){
            this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
        }
        hasPlugin(t) {
            return this.plugins.has(t);
        }
        getPluginOption(t, e) {
            if (this.hasPlugin(t)) return this.plugins.get(t)[e];
        }
    } {
        addComment(t) {
            this.filename && (t.loc.filename = this.filename), this.state.trailingComments.push(t), this.state.leadingComments.push(t);
        }
        adjustCommentsAfterTrailingComma(t, e, s) {
            if (0 === this.state.leadingComments.length) return;
            let r8 = null, i7 = e.length;
            for(; null === r8 && i7 > 0;)r8 = e[--i7];
            if (null === r8) return;
            for(let t27 = 0; t27 < this.state.leadingComments.length; t27++)this.state.leadingComments[t27].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(t27, 1), t27--);
            const n9 = [];
            for(let e26 = 0; e26 < this.state.leadingComments.length; e26++){
                const r9 = this.state.leadingComments[e26];
                r9.end < t.end ? (n9.push(r9), s || (this.state.leadingComments.splice(e26, 1), e26--)) : ((void 0) === t.trailingComments && (t.trailingComments = []), t.trailingComments.push(r9));
            }
            s && (this.state.leadingComments = []), n9.length > 0 ? r8.trailingComments = n9 : (void 0) !== r8.trailingComments && (r8.trailingComments = []);
        }
        processComment(t) {
            if ("Program" === t.type && t.body.length > 0) return;
            const e26 = this.state.commentStack;
            let s8, r8, i7, n9, a6;
            if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= t.end ? (i7 = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;
            else if (e26.length > 0) {
                const s9 = F4(e26);
                s9.trailingComments && s9.trailingComments[0].start >= t.end && (i7 = s9.trailingComments, delete s9.trailingComments);
            }
            for(e26.length > 0 && F4(e26).start >= t.start && (s8 = e26.pop()); e26.length > 0 && F4(e26).start >= t.start;)r8 = e26.pop();
            if (!r8 && s8 && (r8 = s8), s8) switch(t.type){
                case "ObjectExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.properties);
                    break;
                case "ObjectPattern":
                    this.adjustCommentsAfterTrailingComma(t, t.properties, !0);
                    break;
                case "CallExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.arguments);
                    break;
                case "ArrayExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.elements);
                    break;
                case "ArrayPattern":
                    this.adjustCommentsAfterTrailingComma(t, t.elements, !0);
            }
            else this.state.commentPreviousNode && ("ImportSpecifier" === this.state.commentPreviousNode.type && "ImportSpecifier" !== t.type || "ExportSpecifier" === this.state.commentPreviousNode.type && "ExportSpecifier" !== t.type) && this.adjustCommentsAfterTrailingComma(t, [
                this.state.commentPreviousNode
            ]);
            if (r8) {
                if (r8.leadingComments) {
                    if (r8 !== t && r8.leadingComments.length > 0 && F4(r8.leadingComments).end <= t.start) t.leadingComments = r8.leadingComments, delete r8.leadingComments;
                    else for(n9 = r8.leadingComments.length - 2; n9 >= 0; --n9)if (r8.leadingComments[n9].end <= t.start) {
                        t.leadingComments = r8.leadingComments.splice(0, n9 + 1);
                        break;
                    }
                }
            } else if (this.state.leadingComments.length > 0) {
                if (F4(this.state.leadingComments).end <= t.start) {
                    if (this.state.commentPreviousNode) for(a6 = 0; a6 < this.state.leadingComments.length; a6++)this.state.leadingComments[a6].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(a6, 1), a6--);
                    this.state.leadingComments.length > 0 && (t.leadingComments = this.state.leadingComments, this.state.leadingComments = []);
                } else {
                    for(n9 = 0; n9 < this.state.leadingComments.length && !(this.state.leadingComments[n9].end > t.start); n9++);
                    const e27 = this.state.leadingComments.slice(0, n9);
                    e27.length && (t.leadingComments = e27), i7 = this.state.leadingComments.slice(n9), 0 === i7.length && (i7 = null);
                }
            }
            if (this.state.commentPreviousNode = t, i7) {
                if (i7.length && i7[0].start >= t.start && F4(i7).end <= t.end) t.innerComments = i7;
                else {
                    const e27 = i7.findIndex((e28)=>e28.end >= t.end
                    );
                    e27 > 0 ? (t.innerComments = i7.slice(0, e27), t.trailingComments = i7.slice(e27)) : t.trailingComments = i7;
                }
            }
            e26.push(t);
        }
    } {
        getLocationForPosition(t) {
            let e26;
            return e26 = t === this.state.start ? this.state.startLoc : t === this.state.lastTokStart ? this.state.lastTokStartLoc : t === this.state.end ? this.state.endLoc : t === this.state.lastTokEnd ? this.state.lastTokEndLoc : (function(t27, e27) {
                let s8, r8 = 1, i7 = 0;
                for(f5.lastIndex = 0; (s8 = f5.exec(t27)) && s8.index < e27;)r8++, i7 = f5.lastIndex;
                return new C5(r8, e27 - i7);
            })(this.input, t), e26;
        }
        raise(t, e, ...s) {
            return this.raiseWithData(t, void 0, e, ...s);
        }
        raiseWithData(t, e, s, ...r) {
            const i7 = this.getLocationForPosition(t), n9 = s.replace(/%(\d+)/g, (t27, e26)=>r[e26]
            ) + " (".concat(i7.line, ":").concat(i7.column, ")");
            return this._raise(Object.assign({
                loc: i7,
                pos: t
            }, e), n9);
        }
        _raise(t, e) {
            const s8 = new SyntaxError(e);
            if (Object.assign(s8, t), this.options.errorRecovery) return this.isLookahead || this.state.errors.push(s8), s8;
            throw s8;
        }
    } {
        constructor(t27, e26){
            super(), this.isLookahead = void 0, this.tokens = [], this.state = new xt2, this.state.init(t27), this.input = e26, this.length = e26.length, this.isLookahead = !1;
        }
        pushToken(t) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
        }
        next() {
            this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Tt2(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
        }
        eat(t) {
            return !!this.match(t) && (this.next(), !0);
        }
        match(t) {
            return this.state.type === t;
        }
        lookahead() {
            const t28 = this.state;
            this.state = t28.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1;
            const e27 = this.state;
            return this.state = t28, e27;
        }
        nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(t) {
            E5.lastIndex = t;
            return t + E5.exec(this.input)[0].length;
        }
        lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
        }
        setStrict(t) {
            if (this.state.strict = t, this.match(c6.num) || this.match(c6.string)) {
                for(this.state.pos = this.state.start; this.state.pos < this.state.lineStart;)this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1, --this.state.curLine;
                this.nextToken();
            }
        }
        curContext() {
            return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
            const t28 = this.curContext();
            if ((null == t28 ? void 0 : t28.preserveSpace) || this.skipSpace(), this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length) return void this.finishToken(c6.eof);
            const e27 = null == t28 ? void 0 : t28.override;
            e27 ? e27(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));
        }
        pushComment(t, e, s, r, i, n) {
            const a6 = {
                type: t ? "CommentBlock" : "CommentLine",
                value: e,
                start: s,
                end: r,
                loc: new x6(i, n)
            };
            this.options.tokens && this.pushToken(a6), this.state.comments.push(a6), this.addComment(a6);
        }
        skipBlockComment() {
            const t28 = this.state.curPosition(), e27 = this.state.pos, s8 = this.input.indexOf("*/", this.state.pos + 2);
            if (-1 === s8) throw this.raise(e27, g6.UnterminatedComment);
            let r8;
            for(this.state.pos = s8 + 2, f5.lastIndex = e27; (r8 = f5.exec(this.input)) && r8.index < this.state.pos;)++this.state.curLine, this.state.lineStart = r8.index + r8[0].length;
            this.isLookahead || this.pushComment(!0, this.input.slice(e27 + 2, s8), e27, this.state.pos, t28, this.state.curPosition());
        }
        skipLineComment(t) {
            const e27 = this.state.pos, s8 = this.state.curPosition();
            let r8 = this.input.charCodeAt(this.state.pos += t);
            if (this.state.pos < this.length) for(; !y6(r8) && (++this.state.pos) < this.length;)r8 = this.input.charCodeAt(this.state.pos);
            this.isLookahead || this.pushComment(!1, this.input.slice(e27 + t, this.state.pos), e27, this.state.pos, s8, this.state.curPosition());
        }
        skipSpace() {
            t: for(; this.state.pos < this.length;){
                const t28 = this.input.charCodeAt(this.state.pos);
                switch(t28){
                    case 32:
                    case 160:
                    case 9:
                        ++this.state.pos;
                        break;
                    case 13:
                        10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                        break;
                    case 47:
                        switch(this.input.charCodeAt(this.state.pos + 1)){
                            case 42:
                                this.skipBlockComment();
                                break;
                            case 47:
                                this.skipLineComment(2);
                                break;
                            default: break t;
                        }
                        break;
                    default:
                        if (!A5(t28)) break t;
                        ++this.state.pos;
                }
            }
        }
        finishToken(t, e) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const s8 = this.state.type;
            this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s8);
        }
        readToken_numberSign() {
            if (0 === this.state.pos && this.readToken_interpreter()) return;
            const t28 = this.state.pos + 1, e27 = this.input.charCodeAt(t28);
            if (e27 >= 48 && e27 <= 57) throw this.raise(this.state.pos, g6.UnexpectedDigitAfterHash);
            if (123 === e27 || 91 === e27 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, 123 === e27 ? g6.RecordExpressionHashIncorrectStartSyntaxType : g6.TupleExpressionHashIncorrectStartSyntaxType);
                123 === e27 ? this.finishToken(c6.braceHashL) : this.finishToken(c6.bracketHashL), this.state.pos += 2;
            } else this.finishOp(c6.hash, 1);
        }
        readToken_dot() {
            const t28 = this.input.charCodeAt(this.state.pos + 1);
            t28 >= 48 && t28 <= 57 ? this.readNumber(!0) : 46 === t28 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(c6.ellipsis)) : (++this.state.pos, this.finishToken(c6.dot));
        }
        readToken_slash() {
            if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp();
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c6.assign, 2) : this.finishOp(c6.slash, 1);
        }
        readToken_interpreter() {
            if (0 !== this.state.pos || this.length < 2) return !1;
            let t28 = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== t28) return !1;
            const e27 = this.state.pos;
            for(this.state.pos += 1; !y6(t28) && (++this.state.pos) < this.length;)t28 = this.input.charCodeAt(this.state.pos);
            const s8 = this.input.slice(e27 + 2, this.state.pos);
            return this.finishToken(c6.interpreterDirective, s8), !0;
        }
        readToken_mult_modulo(t) {
            let e27 = 42 === t ? c6.star : c6.modulo, s8 = 1, r8 = this.input.charCodeAt(this.state.pos + 1);
            const i7 = this.state.exprAllowed;
            42 === t && 42 === r8 && (s8++, r8 = this.input.charCodeAt(this.state.pos + 2), e27 = c6.exponent), 61 !== r8 || i7 || (s8++, e27 = c6.assign), this.finishOp(e27, s8);
        }
        readToken_pipe_amp(t) {
            const e27 = this.input.charCodeAt(this.state.pos + 1);
            if (e27 !== t) {
                if (124 === t) {
                    if (62 === e27) return void this.finishOp(c6.pipeline, 2);
                    if (this.hasPlugin("recordAndTuple") && 125 === e27) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g6.RecordExpressionBarIncorrectEndSyntaxType);
                        return void this.finishOp(c6.braceBarR, 2);
                    }
                    if (this.hasPlugin("recordAndTuple") && 93 === e27) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g6.TupleExpressionBarIncorrectEndSyntaxType);
                        return void this.finishOp(c6.bracketBarR, 2);
                    }
                }
                61 !== e27 ? this.finishOp(124 === t ? c6.bitwiseOR : c6.bitwiseAND, 1) : this.finishOp(c6.assign, 2);
            } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(c6.assign, 3) : this.finishOp(124 === t ? c6.logicalOR : c6.logicalAND, 2);
        }
        readToken_caret() {
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c6.assign, 2) : this.finishOp(c6.bitwiseXOR, 1);
        }
        readToken_plus_min(t) {
            const e27 = this.input.charCodeAt(this.state.pos + 1);
            if (e27 === t) return 45 !== e27 || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !this.hasPrecedingLineBreak() ? void this.finishOp(c6.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());
            61 === e27 ? this.finishOp(c6.assign, 2) : this.finishOp(c6.plusMin, 1);
        }
        readToken_lt_gt(t) {
            const e27 = this.input.charCodeAt(this.state.pos + 1);
            let s8 = 1;
            return e27 === t ? (s8 = 62 === t && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s8) ? void this.finishOp(c6.assign, s8 + 1) : void this.finishOp(c6.bitShift, s8)) : 33 !== e27 || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e27 && (s8 = 2), void this.finishOp(c6.relational, s8)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());
        }
        readToken_eq_excl(t) {
            const e27 = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== e27) return 61 === t && 62 === e27 ? (this.state.pos += 2, void this.finishToken(c6.arrow)) : void this.finishOp(61 === t ? c6.eq : c6.bang, 1);
            this.finishOp(c6.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
            const t28 = this.input.charCodeAt(this.state.pos + 1), e27 = this.input.charCodeAt(this.state.pos + 2);
            63 === t28 ? 61 === e27 ? this.finishOp(c6.assign, 3) : this.finishOp(c6.nullishCoalescing, 2) : 46 !== t28 || e27 >= 48 && e27 <= 57 ? (++this.state.pos, this.finishToken(c6.question)) : (this.state.pos += 2, this.finishToken(c6.questionDot));
        }
        getTokenFromCode(t) {
            switch(t){
                case 46:
                    return void this.readToken_dot();
                case 40:
                    return ++this.state.pos, void this.finishToken(c6.parenL);
                case 41:
                    return ++this.state.pos, void this.finishToken(c6.parenR);
                case 59:
                    return ++this.state.pos, void this.finishToken(c6.semi);
                case 44:
                    return ++this.state.pos, void this.finishToken(c6.comma);
                case 91:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g6.TupleExpressionBarIncorrectStartSyntaxType);
                        this.finishToken(c6.bracketBarL), this.state.pos += 2;
                    } else ++this.state.pos, this.finishToken(c6.bracketL);
                    return;
                case 93:
                    return ++this.state.pos, void this.finishToken(c6.bracketR);
                case 123:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g6.RecordExpressionBarIncorrectStartSyntaxType);
                        this.finishToken(c6.braceBarL), this.state.pos += 2;
                    } else ++this.state.pos, this.finishToken(c6.braceL);
                    return;
                case 125:
                    return ++this.state.pos, void this.finishToken(c6.braceR);
                case 58:
                    return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c6.doubleColon, 2) : (++this.state.pos, this.finishToken(c6.colon)));
                case 63:
                    return void this.readToken_question();
                case 96:
                    return ++this.state.pos, void this.finishToken(c6.backQuote);
                case 48:
                    {
                        const t28 = this.input.charCodeAt(this.state.pos + 1);
                        if (120 === t28 || 88 === t28) return void this.readRadixNumber(16);
                        if (111 === t28 || 79 === t28) return void this.readRadixNumber(8);
                        if (98 === t28 || 66 === t28) return void this.readRadixNumber(2);
                    }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return void this.readNumber(!1);
                case 34:
                case 39:
                    return void this.readString(t);
                case 47:
                    return void this.readToken_slash();
                case 37:
                case 42:
                    return void this.readToken_mult_modulo(t);
                case 124:
                case 38:
                    return void this.readToken_pipe_amp(t);
                case 94:
                    return void this.readToken_caret();
                case 43:
                case 45:
                    return void this.readToken_plus_min(t);
                case 60:
                case 62:
                    return void this.readToken_lt_gt(t);
                case 61:
                case 33:
                    return void this.readToken_eq_excl(t);
                case 126:
                    return void this.finishOp(c6.tilde, 1);
                case 64:
                    return ++this.state.pos, void this.finishToken(c6.at);
                case 35:
                    return void this.readToken_numberSign();
                case 92:
                    return void this.readWord();
                default:
                    if (L3(t)) return void this.readWord();
            }
            throw this.raise(this.state.pos, g6.InvalidOrUnexpectedToken, String.fromCodePoint(t));
        }
        finishOp(t, e) {
            const s8 = this.input.slice(this.state.pos, this.state.pos + e);
            this.state.pos += e, this.finishToken(t, s8);
        }
        readRegexp() {
            const t28 = this.state.pos;
            let e27, s8;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(t28, g6.UnterminatedRegExp);
                const r8 = this.input.charAt(this.state.pos);
                if (m5.test(r8)) throw this.raise(t28, g6.UnterminatedRegExp);
                if (e27) e27 = !1;
                else {
                    if ("[" === r8) s8 = !0;
                    else if ("]" === r8 && s8) s8 = !1;
                    else if ("/" === r8 && !s8) break;
                    e27 = "\\" === r8;
                }
                ++this.state.pos;
            }
            const r8 = this.input.slice(t28, this.state.pos);
            ++this.state.pos;
            let i7 = "";
            for(; this.state.pos < this.length;){
                const t29 = this.input[this.state.pos], e28 = this.input.codePointAt(this.state.pos);
                if (gt2.has(t29)) i7.indexOf(t29) > -1 && this.raise(this.state.pos + 1, g6.DuplicateRegExpFlags);
                else {
                    if (!O4(e28) && 92 !== e28) break;
                    this.raise(this.state.pos + 1, g6.MalformedRegExpFlags);
                }
                ++this.state.pos, i7 += t29;
            }
            this.finishToken(c6.regexp, {
                pattern: r8,
                flags: i7
            });
        }
        readInt(t, e, s, r = !0) {
            const i7 = this.state.pos, n9 = 16 === t ? bt2.hex : bt2.decBinOct, a6 = 16 === t ? Pt2.hex : 10 === t ? Pt2.dec : 8 === t ? Pt2.oct : Pt2.bin;
            let o6 = !1, u5 = 0;
            for(let i8 = 0, h6 = null == e ? 1 / 0 : e; i8 < h6; ++i8){
                const e27 = this.input.charCodeAt(this.state.pos);
                let h6;
                if (95 !== e27) {
                    if (h6 = e27 >= 97 ? e27 - 97 + 10 : e27 >= 65 ? e27 - 65 + 10 : Ft2(e27) ? e27 - 48 : 1 / 0, h6 >= t) {
                        if (this.options.errorRecovery && h6 <= 9) h6 = 0, this.raise(this.state.start + i8 + 2, g6.InvalidDigit, t);
                        else {
                            if (!s) break;
                            h6 = 0, o6 = !0;
                        }
                    }
                    ++this.state.pos, u5 = u5 * t + h6;
                } else {
                    const t28 = this.input.charCodeAt(this.state.pos - 1), e28 = this.input.charCodeAt(this.state.pos + 1);
                    (-1 === a6.indexOf(e28) || n9.indexOf(t28) > -1 || n9.indexOf(e28) > -1 || Number.isNaN(e28)) && this.raise(this.state.pos, g6.UnexpectedNumericSeparator), r || this.raise(this.state.pos, g6.NumericSeparatorInEscapeSequence), ++this.state.pos;
                }
            }
            return this.state.pos === i7 || null != e && this.state.pos - i7 !== e || o6 ? null : u5;
        }
        readRadixNumber(t) {
            const e27 = this.state.pos;
            let s8 = !1;
            this.state.pos += 2;
            const r8 = this.readInt(t);
            null == r8 && this.raise(this.state.start + 2, g6.InvalidDigit, t);
            const i7 = this.input.charCodeAt(this.state.pos);
            if (110 === i7) ++this.state.pos, s8 = !0;
            else if (109 === i7) throw this.raise(e27, g6.InvalidDecimal);
            if (L3(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, g6.NumberIdentifier);
            if (s8) {
                const t28 = this.input.slice(e27, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(c6.bigint, t28);
            } else this.finishToken(c6.num, r8);
        }
        readNumber(t) {
            const e27 = this.state.pos;
            let s8 = !1, r8 = !1, i7 = !1, n9 = !1, a6 = !1;
            t || null !== this.readInt(10) || this.raise(e27, g6.InvalidNumber);
            const o6 = this.state.pos - e27 >= 2 && 48 === this.input.charCodeAt(e27);
            if (o6) {
                const t28 = this.input.slice(e27, this.state.pos);
                if (this.state.strict) this.raise(e27, g6.StrictOctalLiteral);
                else {
                    const s9 = t28.indexOf("_");
                    s9 > 0 && this.raise(s9 + e27, g6.ZeroDigitNumericSeparator);
                }
                a6 = o6 && !/[89]/.test(t28);
            }
            let u5 = this.input.charCodeAt(this.state.pos);
            if (46 !== u5 || a6 || (++this.state.pos, this.readInt(10), s8 = !0, u5 = this.input.charCodeAt(this.state.pos)), 69 !== u5 && 101 !== u5 || a6 || (u5 = this.input.charCodeAt(++this.state.pos), 43 !== u5 && 45 !== u5 || ++this.state.pos, null === this.readInt(10) && this.raise(e27, g6.InvalidOrMissingExponent), s8 = !0, n9 = !0, u5 = this.input.charCodeAt(this.state.pos)), 110 === u5 && ((s8 || o6) && this.raise(e27, g6.InvalidBigIntLiteral), ++this.state.pos, r8 = !0), 109 === u5 && (this.expectPlugin("decimal", this.state.pos), (n9 || o6) && this.raise(e27, g6.InvalidDecimal), ++this.state.pos, i7 = !0), L3(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, g6.NumberIdentifier);
            const h6 = this.input.slice(e27, this.state.pos).replace(/[_mn]/g, "");
            if (r8) return void this.finishToken(c6.bigint, h6);
            if (i7) return void this.finishToken(c6.decimal, h6);
            const p7 = a6 ? parseInt(h6, 8) : parseFloat(h6);
            this.finishToken(c6.num, p7);
        }
        readCodePoint(t) {
            let e27;
            if (123 === this.input.charCodeAt(this.state.pos)) {
                const s8 = ++this.state.pos;
                if (e27 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, t), ++this.state.pos, null !== e27 && e27 > 1114111) {
                    if (!t) return null;
                    this.raise(s8, g6.InvalidCodePoint);
                }
            } else e27 = this.readHexChar(4, !1, t);
            return e27;
        }
        readString(t) {
            let e27 = "", s8 = ++this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, g6.UnterminatedString);
                const r8 = this.input.charCodeAt(this.state.pos);
                if (r8 === t) break;
                if (92 === r8) e27 += this.input.slice(s8, this.state.pos), e27 += this.readEscapedChar(!1), s8 = this.state.pos;
                else if (8232 === r8 || 8233 === r8) ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                else {
                    if (y6(r8)) throw this.raise(this.state.start, g6.UnterminatedString);
                    ++this.state.pos;
                }
            }
            e27 += this.input.slice(s8, this.state.pos++), this.finishToken(c6.string, e27);
        }
        readTmplToken() {
            let t28 = "", e27 = this.state.pos, s8 = !1;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, g6.UnterminatedTemplate);
                const r8 = this.input.charCodeAt(this.state.pos);
                if (96 === r8 || 36 === r8 && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(c6.template) ? 36 === r8 ? (this.state.pos += 2, void this.finishToken(c6.dollarBraceL)) : (++this.state.pos, void this.finishToken(c6.backQuote)) : (t28 += this.input.slice(e27, this.state.pos), void this.finishToken(c6.template, s8 ? null : t28));
                if (92 === r8) {
                    t28 += this.input.slice(e27, this.state.pos);
                    const r9 = this.readEscapedChar(!0);
                    null === r9 ? s8 = !0 : t28 += r9, e27 = this.state.pos;
                } else if (y6(r8)) {
                    switch(t28 += this.input.slice(e27, this.state.pos), ++this.state.pos, r8){
                        case 13:
                            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                        case 10:
                            t28 += "\n";
                            break;
                        default:
                            t28 += String.fromCharCode(r8);
                    }
                    ++this.state.curLine, this.state.lineStart = this.state.pos, e27 = this.state.pos;
                } else ++this.state.pos;
            }
        }
        readEscapedChar(t) {
            const e27 = !t, s8 = this.input.charCodeAt(++this.state.pos);
            switch(++this.state.pos, s8){
                case 110:
                    return "\n";
                case 114:
                    return "\r";
                case 120:
                    {
                        const t28 = this.readHexChar(2, !1, e27);
                        return null === t28 ? null : String.fromCharCode(t28);
                    }
                case 117:
                    {
                        const t28 = this.readCodePoint(e27);
                        return null === t28 ? null : String.fromCodePoint(t28);
                    }
                case 116:
                    return "\t";
                case 98:
                    return "\b";
                case 118:
                    return "\v";
                case 102:
                    return "\f";
                case 13:
                    10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                case 10:
                    this.state.lineStart = this.state.pos, ++this.state.curLine;
                case 8232:
                case 8233:
                    return "";
                case 56:
                case 57:
                    if (t) return null;
                    this.state.strict && this.raise(this.state.pos - 1, g6.StrictNumericEscape);
                default:
                    if (s8 >= 48 && s8 <= 55) {
                        const e28 = this.state.pos - 1;
                        let s9 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r8 = parseInt(s9, 8);
                        r8 > 255 && (s9 = s9.slice(0, -1), r8 = parseInt(s9, 8)), this.state.pos += s9.length - 1;
                        const i7 = this.input.charCodeAt(this.state.pos);
                        if ("0" !== s9 || 56 === i7 || 57 === i7) {
                            if (t) return null;
                            this.state.strict ? this.raise(e28, g6.StrictNumericEscape) : this.state.octalPositions.push(e28);
                        }
                        return String.fromCharCode(r8);
                    }
                    return String.fromCharCode(s8);
            }
        }
        readHexChar(t, e, s) {
            const r8 = this.state.pos, i7 = this.readInt(16, t, e, !1);
            return null === i7 && (s ? this.raise(r8, g6.InvalidEscapeSequence) : this.state.pos = r8 - 1), i7;
        }
        readWord1() {
            let t28 = "";
            this.state.containsEsc = !1;
            const e27 = this.state.pos;
            let s8 = this.state.pos;
            for(; this.state.pos < this.length;){
                const r8 = this.input.codePointAt(this.state.pos);
                if (O4(r8)) this.state.pos += r8 <= 65535 ? 1 : 2;
                else if (this.state.isIterator && 64 === r8) ++this.state.pos;
                else {
                    if (92 !== r8) break;
                    {
                        this.state.containsEsc = !0, t28 += this.input.slice(s8, this.state.pos);
                        const r9 = this.state.pos, i7 = this.state.pos === e27 ? L3 : O4;
                        if (117 !== this.input.charCodeAt(++this.state.pos)) {
                            this.raise(this.state.pos, g6.MissingUnicodeEscape);
                            continue;
                        }
                        ++this.state.pos;
                        const n9 = this.readCodePoint(!0);
                        null !== n9 && (i7(n9) || this.raise(r9, g6.EscapedCharNotAnIdentifier), t28 += String.fromCodePoint(n9)), s8 = this.state.pos;
                    }
                }
            }
            return t28 + this.input.slice(s8, this.state.pos);
        }
        isIterator(t) {
            return "@@iterator" === t || "@@asyncIterator" === t;
        }
        readWord() {
            const t28 = this.readWord1(), e27 = o5.get(t28) || c6.name;
            !this.state.isIterator || this.isIterator(t28) && this.state.inType || this.raise(this.state.pos, g6.InvalidIdentifier, t28), this.finishToken(e27, t28);
        }
        checkKeywordEscapes() {
            const t28 = this.state.type.keyword;
            t28 && this.state.containsEsc && this.raise(this.state.start, g6.InvalidEscapedReservedWord, t28);
        }
        braceIsBlock(t) {
            const e27 = this.curContext();
            return e27 === T5.functionExpression || e27 === T5.functionStatement || (t !== c6.colon || e27 !== T5.braceStatement && e27 !== T5.braceExpression ? t === c6._return || t === c6.name && this.state.exprAllowed ? this.hasPrecedingLineBreak() : t === c6._else || t === c6.semi || t === c6.eof || t === c6.parenR || t === c6.arrow || (t === c6.braceL ? e27 === T5.braceStatement : t !== c6._var && t !== c6._const && t !== c6.name && (t === c6.relational || !this.state.exprAllowed)) : !e27.isExpr);
        }
        updateContext(t) {
            const e27 = this.state.type;
            let s8;
            !e27.keyword || t !== c6.dot && t !== c6.questionDot ? (s8 = e27.updateContext) ? s8.call(this, t) : this.state.exprAllowed = e27.beforeExpr : this.state.exprAllowed = !1;
        }
    } {
        addExtra(t, e, s) {
            if (!t) return;
            (t.extra = t.extra || {
            })[e] = s;
        }
        isRelational(t) {
            return this.match(c6.relational) && this.state.value === t;
        }
        expectRelational(t) {
            this.isRelational(t) ? this.next() : this.unexpected(null, c6.relational);
        }
        isContextual(t) {
            return this.match(c6.name) && this.state.value === t && !this.state.containsEsc;
        }
        isUnparsedContextual(t, e) {
            const s8 = t + e.length;
            return this.input.slice(t, s8) === e && (s8 === this.input.length || !O4(this.input.charCodeAt(s8)));
        }
        isLookaheadContextual(t) {
            const e27 = this.nextTokenStart();
            return this.isUnparsedContextual(e27, t);
        }
        eatContextual(t) {
            return this.isContextual(t) && this.eat(c6.name);
        }
        expectContextual(t, e) {
            this.eatContextual(t) || this.unexpected(null, e);
        }
        canInsertSemicolon() {
            return this.match(c6.eof) || this.match(c6.braceR) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
            return m5.test(this.input.slice(this.state.lastTokEnd, this.state.start));
        }
        isLineTerminator() {
            return this.eat(c6.semi) || this.canInsertSemicolon();
        }
        semicolon() {
            this.isLineTerminator() || this.unexpected(null, c6.semi);
        }
        expect(t, e) {
            this.eat(t) || this.unexpected(e, t);
        }
        assertNoSpace(t = "Unexpected space.") {
            this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, t);
        }
        unexpected(t, e = "Unexpected token") {
            throw "string" != typeof e && (e = 'Unexpected token, expected "'.concat(e.label, '"')), this.raise(null != t ? t : this.state.start, e);
        }
        expectPlugin(t, e) {
            if (!this.hasPlugin(t)) throw this.raiseWithData(null != e ? e : this.state.start, {
                missingPlugin: [
                    t
                ]
            }, "This experimental syntax requires enabling the parser plugin: '".concat(t, "'"));
            return !0;
        }
        expectOnePlugin(t, e) {
            if (!t.some((t28)=>this.hasPlugin(t28)
            )) throw this.raiseWithData(null != e ? e : this.state.start, {
                missingPlugin: t
            }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t.join(", "), "'"));
        }
        tryParse(t, e = this.state.clone()) {
            const s8 = {
                node: null
            };
            try {
                const r8 = t((t28 = null)=>{
                    throw s8.node = t28, s8;
                });
                if (this.state.errors.length > e.errors.length) {
                    const t28 = this.state;
                    return this.state = e, {
                        node: r8,
                        error: t28.errors[e.errors.length],
                        thrown: !1,
                        aborted: !1,
                        failState: t28
                    };
                }
                return {
                    node: r8,
                    error: null,
                    thrown: !1,
                    aborted: !1,
                    failState: null
                };
            } catch (t) {
                const r9 = this.state;
                if (this.state = e, t instanceof SyntaxError) return {
                    node: null,
                    error: t,
                    thrown: !0,
                    aborted: !1,
                    failState: r9
                };
                if (t === s8) return {
                    node: s8.node,
                    error: null,
                    thrown: !1,
                    aborted: !0,
                    failState: r9
                };
                throw t;
            }
        }
        checkExpressionErrors(t, e) {
            if (!t) return !1;
            const { shorthandAssign: s8 , doubleProto: r8  } = t;
            if (!e) return s8 >= 0 || r8 >= 0;
            s8 >= 0 && this.unexpected(s8), r8 >= 0 && this.raise(r8, g6.DuplicateProto);
        }
        isLiteralPropertyName() {
            return this.match(c6.name) || !!this.state.type.keyword || this.match(c6.string) || this.match(c6.num) || this.match(c6.bigint) || this.match(c6.decimal);
        }
    } {
        startNode() {
            return new Bt3(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(t, e) {
            return new Bt3(this, t, e);
        }
        startNodeAtNode(t) {
            return this.startNodeAt(t.start, t.loc.start);
        }
        finishNode(t, e) {
            return this.finishNodeAt(t, e, this.state.lastTokEnd, this.state.lastTokEndLoc);
        }
        finishNodeAt(t, e, s, r) {
            return t.type = e, t.end = s, t.loc.end = r, this.options.ranges && (t.range[1] = s), this.processComment(t), t;
        }
        resetStartLocation(t, e, s) {
            t.start = e, t.loc.start = s, this.options.ranges && (t.range[0] = e);
        }
        resetEndLocation(t, e = this.state.lastTokEnd, s = this.state.lastTokEndLoc) {
            t.end = e, t.loc.end = s, this.options.ranges && (t.range[1] = e);
        }
        resetStartLocationFromNode(t, e) {
            this.resetStartLocation(t, e.start, e.loc.start);
        }
    } {
        toAssignable(t) {
            var e27, s8;
            let r8 = void 0;
            switch(("ParenthesizedExpression" === t.type || (null == (e27 = t.extra) ? void 0 : e27.parenthesized)) && (r8 = St2(t), "Identifier" !== r8.type && "MemberExpression" !== r8.type && this.raise(t.start, g6.InvalidParenthesizedAssignment)), t.type){
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern": break;
                case "ObjectExpression":
                    t.type = "ObjectPattern";
                    for(let e28 = 0, s9 = t.properties.length, r9 = s9 - 1; e28 < s9; e28++){
                        var i7;
                        const s9 = t.properties[e28], n9 = e28 === r9;
                        this.toAssignableObjectExpressionProp(s9, n9), n9 && "RestElement" === s9.type && (null == (i7 = t.extra) ? void 0 : i7.trailingComma) && this.raiseRestNotLast(t.extra.trailingComma);
                    }
                    break;
                case "ObjectProperty":
                    this.toAssignable(t.value);
                    break;
                case "SpreadElement":
                    {
                        this.checkToRestConversion(t), t.type = "RestElement";
                        const e29 = t.argument;
                        this.toAssignable(e29);
                        break;
                    }
                case "ArrayExpression":
                    t.type = "ArrayPattern", this.toAssignableList(t.elements, null == (s8 = t.extra) ? void 0 : s8.trailingComma);
                    break;
                case "AssignmentExpression":
                    "=" !== t.operator && this.raise(t.left.end, g6.MissingEqInAssignment), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left);
                    break;
                case "ParenthesizedExpression":
                    this.toAssignable(r8);
            }
            return t;
        }
        toAssignableObjectExpressionProp(t, e) {
            if ("ObjectMethod" === t.type) {
                const e27 = "get" === t.kind || "set" === t.kind ? g6.PatternHasAccessor : g6.PatternHasMethod;
                this.raise(t.key.start, e27);
            } else "SpreadElement" !== t.type || e ? this.toAssignable(t) : this.raiseRestNotLast(t.start);
        }
        toAssignableList(t, e) {
            let s8 = t.length;
            if (s8) {
                const r8 = t[s8 - 1];
                if ("RestElement" === (null == r8 ? void 0 : r8.type)) --s8;
                else if ("SpreadElement" === (null == r8 ? void 0 : r8.type)) {
                    r8.type = "RestElement";
                    const t28 = r8.argument;
                    this.toAssignable(t28), "Identifier" !== t28.type && "MemberExpression" !== t28.type && "ArrayPattern" !== t28.type && "ObjectPattern" !== t28.type && this.unexpected(t28.start), e && this.raiseTrailingCommaAfterRest(e), --s8;
                }
            }
            for(let e27 = 0; e27 < s8; e27++){
                const s9 = t[e27];
                s9 && (this.toAssignable(s9), "RestElement" === s9.type && this.raiseRestNotLast(s9.start));
            }
            return t;
        }
        toReferencedList(t, e) {
            return t;
        }
        toReferencedListDeep(t, e) {
            this.toReferencedList(t, e);
            for(let e27 = 0; e27 < t.length; e27++){
                const s8 = t[e27];
                "ArrayExpression" === (null == s8 ? void 0 : s8.type) && this.toReferencedListDeep(s8.elements);
            }
        }
        parseSpread(t, e) {
            const s8 = this.startNode();
            return this.next(), s8.argument = this.parseMaybeAssignAllowIn(t, void 0, e), this.finishNode(s8, "SpreadElement");
        }
        parseRestBinding() {
            const t28 = this.startNode();
            return this.next(), t28.argument = this.parseBindingAtom(), this.finishNode(t28, "RestElement");
        }
        parseBindingAtom() {
            switch(this.state.type){
                case c6.bracketL:
                    {
                        const t28 = this.startNode();
                        return this.next(), t28.elements = this.parseBindingList(c6.bracketR, 93, !0), this.finishNode(t28, "ArrayPattern");
                    }
                case c6.braceL:
                    return this.parseObjectLike(c6.braceR, !0);
            }
            return this.parseIdentifier();
        }
        parseBindingList(t, e, s, r) {
            const i7 = [];
            let n9 = !0;
            for(; !this.eat(t);)if (n9 ? n9 = !1 : this.expect(c6.comma), s && this.match(c6.comma)) i7.push(null);
            else {
                if (this.eat(t)) break;
                if (this.match(c6.ellipsis)) {
                    i7.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e), this.expect(t);
                    break;
                }
                {
                    const t28 = [];
                    for(this.match(c6.at) && this.hasPlugin("decorators") && this.raise(this.state.start, g6.UnsupportedParameterDecorator); this.match(c6.at);)t28.push(this.parseDecorator());
                    i7.push(this.parseAssignableListItem(r, t28));
                }
            }
            return i7;
        }
        parseAssignableListItem(t, e) {
            const s8 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s8);
            const r8 = this.parseMaybeDefault(s8.start, s8.loc.start, s8);
            return e.length && (s8.decorators = e), r8;
        }
        parseAssignableListItemTypes(t) {
            return t;
        }
        parseMaybeDefault(t, e, s) {
            var r8, i7, n9;
            if (e = null != (r8 = e) ? r8 : this.state.startLoc, t = null != (i7 = t) ? i7 : this.state.start, s = null != (n9 = s) ? n9 : this.parseBindingAtom(), !this.eat(c6.eq)) return s;
            const a6 = this.startNodeAt(t, e);
            return a6.left = s, a6.right = this.parseMaybeAssignAllowIn(), this.finishNode(a6, "AssignmentPattern");
        }
        checkLVal(t, e = 64, s, r, i, n = !1) {
            switch(t.type){
                case "Identifier":
                    if (this.state.strict && (n ? H5(t.name, this.inModule) : z5(t.name)) && this.raise(t.start, e === 64 ? g6.StrictEvalArguments : g6.StrictEvalArgumentsBinding, t.name), s) {
                        const e27 = "_".concat(t.name);
                        s[e27] ? this.raise(t.start, g6.ParamDupe) : s[e27] = !0;
                    }
                    i && "let" === t.name && this.raise(t.start, g6.LetInLexicalBinding), e & 64 || this.scope.declareName(t.name, e, t.start);
                    break;
                case "MemberExpression":
                    e !== 64 && this.raise(t.start, g6.InvalidPropertyBindingPattern);
                    break;
                case "ObjectPattern":
                    for(let r8 = 0, n9 = t.properties; r8 < n9.length; r8++){
                        let t28 = n9[r8];
                        if ("ObjectProperty" === t28.type) t28 = t28.value;
                        else if ("ObjectMethod" === t28.type) continue;
                        this.checkLVal(t28, e, s, "object destructuring pattern", i);
                    }
                    break;
                case "ArrayPattern":
                    for(let r9 = 0, n10 = t.elements; r9 < n10.length; r9++){
                        const t28 = n10[r9];
                        t28 && this.checkLVal(t28, e, s, "array destructuring pattern", i);
                    }
                    break;
                case "AssignmentPattern":
                    this.checkLVal(t.left, e, s, "assignment pattern");
                    break;
                case "RestElement":
                    this.checkLVal(t.argument, e, s, "rest element");
                    break;
                case "ParenthesizedExpression":
                    this.checkLVal(t.expression, e, s, "parenthesized expression");
                    break;
                default:
                    this.raise(t.start, e === 64 ? g6.InvalidLhs : g6.InvalidLhsBinding, r);
            }
        }
        checkToRestConversion(t) {
            "Identifier" !== t.argument.type && "MemberExpression" !== t.argument.type && this.raise(t.argument.start, g6.InvalidRestAssignmentPattern);
        }
        checkCommaAfterRest(t) {
            this.match(c6.comma) && (this.lookaheadCharCode() === t ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
        }
        raiseRestNotLast(t) {
            throw this.raise(t, g6.ElementAfterRest);
        }
        raiseTrailingCommaAfterRest(t) {
            this.raise(t, g6.RestTrailingComma);
        }
    } {
        checkProto(t, e, s, r) {
            if ("SpreadElement" === t.type || "ObjectMethod" === t.type || t.computed || t.shorthand) return;
            const i7 = t.key;
            if ("__proto__" === ("Identifier" === i7.type ? i7.name : i7.value)) {
                if (e) return void this.raise(i7.start, g6.RecordNoProto);
                s.used && (r ? -1 === r.doubleProto && (r.doubleProto = i7.start) : this.raise(i7.start, g6.DuplicateProto)), s.used = !0;
            }
        }
        shouldExitDescending(t, e) {
            return "ArrowFunctionExpression" === t.type && t.start === e;
        }
        getExpression() {
            let t28 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t28 |= 2), this.scope.enter(1), this.prodParam.enter(t28), this.nextToken();
            const e27 = this.parseExpression();
            return this.match(c6.eof) || this.unexpected(), e27.comments = this.state.comments, e27.errors = this.state.errors, e27;
        }
        parseExpression(t, e) {
            return t ? this.disallowInAnd(()=>this.parseExpressionBase(e)
            ) : this.allowInAnd(()=>this.parseExpressionBase(e)
            );
        }
        parseExpressionBase(t) {
            const e27 = this.state.start, s8 = this.state.startLoc, r8 = this.parseMaybeAssign(t);
            if (this.match(c6.comma)) {
                const i7 = this.startNodeAt(e27, s8);
                for(i7.expressions = [
                    r8
                ]; this.eat(c6.comma);)i7.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(i7.expressions), this.finishNode(i7, "SequenceExpression");
            }
            return r8;
        }
        parseMaybeAssignDisallowIn(t, e, s) {
            return this.disallowInAnd(()=>this.parseMaybeAssign(t, e, s)
            );
        }
        parseMaybeAssignAllowIn(t, e, s) {
            return this.allowInAnd(()=>this.parseMaybeAssign(t, e, s)
            );
        }
        parseMaybeAssign(t, e, s) {
            const r8 = this.state.start, i7 = this.state.startLoc;
            if (this.isContextual("yield") && this.prodParam.hasYield) {
                this.state.exprAllowed = !0;
                let t28 = this.parseYield();
                return e && (t28 = e.call(this, t28, r8, i7)), t28;
            }
            let n9;
            t ? n9 = !1 : (t = new wt2, n9 = !0), (this.match(c6.parenL) || this.match(c6.name)) && (this.state.potentialArrowAt = this.state.start);
            let a6 = this.parseMaybeConditional(t, s);
            if (e && (a6 = e.call(this, a6, r8, i7)), this.state.type.isAssign) {
                const e27 = this.startNodeAt(r8, i7), s8 = this.state.value;
                return e27.operator = s8, this.match(c6.eq) ? (e27.left = this.toAssignable(a6), t.doubleProto = -1) : e27.left = a6, t.shorthandAssign >= e27.left.start && (t.shorthandAssign = -1), this.checkLVal(a6, void 0, void 0, "assignment expression"), this.next(), e27.right = this.parseMaybeAssign(), this.finishNode(e27, "AssignmentExpression");
            }
            return n9 && this.checkExpressionErrors(t, !0), a6;
        }
        parseMaybeConditional(t, e) {
            const s8 = this.state.start, r8 = this.state.startLoc, i7 = this.state.potentialArrowAt, n9 = this.parseExprOps(t);
            return this.shouldExitDescending(n9, i7) ? n9 : this.parseConditional(n9, s8, r8, e);
        }
        parseConditional(t, e, s, r) {
            if (this.eat(c6.question)) {
                const r8 = this.startNodeAt(e, s);
                return r8.test = t, r8.consequent = this.parseMaybeAssignAllowIn(), this.expect(c6.colon), r8.alternate = this.parseMaybeAssign(), this.finishNode(r8, "ConditionalExpression");
            }
            return t;
        }
        parseExprOps(t) {
            const e27 = this.state.start, s8 = this.state.startLoc, r8 = this.state.potentialArrowAt, i7 = this.parseMaybeUnary(t);
            return this.shouldExitDescending(i7, r8) ? i7 : this.parseExprOp(i7, e27, s8, -1);
        }
        parseExprOp(t, e, s, r) {
            let i7 = this.state.type.binop;
            if (null != i7 && (this.prodParam.hasIn || !this.match(c6._in)) && i7 > r) {
                const n9 = this.state.type;
                if (n9 === c6.pipeline) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                    this.state.inPipeline = !0, this.checkPipelineAtInfixOperator(t, e);
                }
                const a6 = this.startNodeAt(e, s);
                a6.left = t, a6.operator = this.state.value, n9 !== c6.exponent || "UnaryExpression" !== t.type || !this.options.createParenthesizedExpressions && t.extra && t.extra.parenthesized || this.raise(t.argument.start, g6.UnexpectedTokenUnaryExponentiation);
                const o6 = n9 === c6.logicalOR || n9 === c6.logicalAND, u5 = n9 === c6.nullishCoalescing;
                if (u5 && (i7 = c6.logicalAND.binop), this.next(), n9 === c6.pipeline && "minimal" === this.getPluginOption("pipelineOperator", "proposal") && this.match(c6.name) && "await" === this.state.value && this.prodParam.hasAwait) throw this.raise(this.state.start, g6.UnexpectedAwaitAfterPipelineBody);
                a6.right = this.parseExprOpRightExpr(n9, i7), this.finishNode(a6, o6 || u5 ? "LogicalExpression" : "BinaryExpression");
                const h6 = this.state.type;
                if (u5 && (h6 === c6.logicalOR || h6 === c6.logicalAND) || o6 && h6 === c6.nullishCoalescing) throw this.raise(this.state.start, g6.MixingCoalesceWithLogical);
                return this.parseExprOp(a6, e, s, r);
            }
            return t;
        }
        parseExprOpRightExpr(t, e) {
            const s8 = this.state.start, r8 = this.state.startLoc;
            switch(t){
                case c6.pipeline:
                    switch(this.getPluginOption("pipelineOperator", "proposal")){
                        case "smart":
                            return this.withTopicPermittingContext(()=>this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t, e), s8, r8)
                            );
                        case "fsharp":
                            return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(e)
                            );
                    }
                default:
                    return this.parseExprOpBaseRightExpr(t, e);
            }
        }
        parseExprOpBaseRightExpr(t, e) {
            const s8 = this.state.start, r8 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnary(), s8, r8, t.rightAssociative ? e - 1 : e);
        }
        parseMaybeUnary(t) {
            if (this.isContextual("await") && this.isAwaitAllowed()) return this.parseAwait();
            const e27 = this.match(c6.incDec), s8 = this.startNode();
            if (this.state.type.prefix) {
                s8.operator = this.state.value, s8.prefix = !0, this.match(c6._throw) && this.expectPlugin("throwExpressions");
                const r8 = this.match(c6._delete);
                if (this.next(), s8.argument = this.parseMaybeUnary(), this.checkExpressionErrors(t, !0), this.state.strict && r8) {
                    const t28 = s8.argument;
                    "Identifier" === t28.type ? this.raise(s8.start, g6.StrictDelete) : "MemberExpression" !== t28.type && "OptionalMemberExpression" !== t28.type || "PrivateName" !== t28.property.type || this.raise(s8.start, g6.DeletePrivateField);
                }
                if (!e27) return this.finishNode(s8, "UnaryExpression");
            }
            return this.parseUpdate(s8, e27, t);
        }
        parseUpdate(t, e, s) {
            if (e) return this.checkLVal(t.argument, void 0, void 0, "prefix operation"), this.finishNode(t, "UpdateExpression");
            const r8 = this.state.start, i7 = this.state.startLoc;
            let n9 = this.parseExprSubscripts(s);
            if (this.checkExpressionErrors(s, !1)) return n9;
            for(; this.state.type.postfix && !this.canInsertSemicolon();){
                const t28 = this.startNodeAt(r8, i7);
                t28.operator = this.state.value, t28.prefix = !1, t28.argument = n9, this.checkLVal(n9, void 0, void 0, "postfix operation"), this.next(), n9 = this.finishNode(t28, "UpdateExpression");
            }
            return n9;
        }
        parseExprSubscripts(t) {
            const e27 = this.state.start, s8 = this.state.startLoc, r8 = this.state.potentialArrowAt, i7 = this.parseExprAtom(t);
            return this.shouldExitDescending(i7, r8) ? i7 : this.parseSubscripts(i7, e27, s8);
        }
        parseSubscripts(t, e, s, r) {
            const i7 = {
                optionalChainMember: !1,
                maybeAsyncArrow: this.atPossibleAsyncArrow(t),
                stop: !1
            };
            do {
                t = this.parseSubscript(t, e, s, r, i7), i7.maybeAsyncArrow = !1;
            }while (!i7.stop)
            return t;
        }
        parseSubscript(t, e, s, r, i) {
            if (!r && this.eat(c6.doubleColon)) return this.parseBind(t, e, s, r, i);
            if (this.match(c6.backQuote)) return this.parseTaggedTemplateExpression(t, e, s, i);
            let n9 = !1;
            if (this.match(c6.questionDot)) {
                if (i.optionalChainMember = n9 = !0, r && 40 === this.lookaheadCharCode()) return i.stop = !0, t;
                this.next();
            }
            return !r && this.match(c6.parenL) ? this.parseCoverCallAndAsyncArrowHead(t, e, s, i, n9) : n9 || this.match(c6.bracketL) || this.eat(c6.dot) ? this.parseMember(t, e, s, i, n9) : (i.stop = !0, t);
        }
        parseMember(t, e, s, r, i) {
            const n9 = this.startNodeAt(e, s), a6 = this.eat(c6.bracketL);
            n9.object = t, n9.computed = a6;
            const o6 = a6 ? this.parseExpression() : this.parseMaybePrivateName(!0);
            return "PrivateName" === o6.type && ("Super" === n9.object.type && this.raise(e, g6.SuperPrivateField), this.classScope.usePrivateName(o6.id.name, o6.start)), n9.property = o6, a6 && this.expect(c6.bracketR), r.optionalChainMember ? (n9.optional = i, this.finishNode(n9, "OptionalMemberExpression")) : this.finishNode(n9, "MemberExpression");
        }
        parseBind(t, e, s, r, i) {
            const n9 = this.startNodeAt(e, s);
            return n9.object = t, n9.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(n9, "BindExpression"), e, s, r);
        }
        parseCoverCallAndAsyncArrowHead(t, e, s, r, i) {
            const n9 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0, this.next();
            let a6 = this.startNodeAt(e, s);
            return a6.callee = t, r.maybeAsyncArrow && this.expressionScope.enter(new It3(2)), r.optionalChainMember && (a6.optional = i), a6.arguments = i ? this.parseCallExpressionArguments(c6.parenR, !1) : this.parseCallExpressionArguments(c6.parenR, r.maybeAsyncArrow, "Import" === t.type, "Super" !== t.type, a6), this.finishCallExpression(a6, r.optionalChainMember), r.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i ? (r.stop = !0, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), a6 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), a6)) : (r.maybeAsyncArrow && this.expressionScope.exit(), this.toReferencedArguments(a6)), this.state.maybeInArrowParameters = n9, a6;
        }
        toReferencedArguments(t, e) {
            this.toReferencedListDeep(t.arguments, e);
        }
        parseTaggedTemplateExpression(t, e, s, r) {
            const i7 = this.startNodeAt(e, s);
            return i7.tag = t, i7.quasi = this.parseTemplate(!0), r.optionalChainMember && this.raise(e, g6.OptionalChainingNoTemplate), this.finishNode(i7, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(t) {
            return "Identifier" === t.type && "async" === t.name && this.state.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && t.start === this.state.potentialArrowAt;
        }
        finishCallExpression(t, e) {
            if ("Import" === t.callee.type) {
                if (2 === t.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), 0 === t.arguments.length || t.arguments.length > 2) this.raise(t.start, g6.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
                else for(let e27 = 0, s8 = t.arguments; e27 < s8.length; e27++){
                    const t28 = s8[e27];
                    "SpreadElement" === t28.type && this.raise(t28.start, g6.ImportCallSpreadArgument);
                }
            }
            return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(t, e, s, r, i) {
            const n9 = [];
            let a6, o6 = !0;
            const u5 = this.state.inFSharpPipelineDirectBody;
            for(this.state.inFSharpPipelineDirectBody = !1; !this.eat(t);){
                if (o6) o6 = !1;
                else if (this.expect(c6.comma), this.match(t)) {
                    !s || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, g6.ImportCallArgumentTrailingComma), i && this.addExtra(i, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                }
                this.match(c6.parenL) && !a6 && (a6 = this.state.start), n9.push(this.parseExprListItem(!1, e ? new wt2 : void 0, e ? {
                    start: 0
                } : void 0, r));
            }
            return e && a6 && this.shouldParseAsyncArrow() && this.unexpected(), this.state.inFSharpPipelineDirectBody = u5, n9;
        }
        shouldParseAsyncArrow() {
            return this.match(c6.arrow) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(t, e) {
            var s8;
            return this.expect(c6.arrow), this.parseArrowExpression(t, e.arguments, !0, null == (s8 = e.extra) ? void 0 : s8.trailingComma), t;
        }
        parseNoCallExpr() {
            const t28 = this.state.start, e27 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t28, e27, !0);
        }
        parseExprAtom(t) {
            this.state.type === c6.slash && this.readRegexp();
            const e27 = this.state.potentialArrowAt === this.state.start;
            let s8;
            switch(this.state.type){
                case c6._super:
                    return this.parseSuper();
                case c6._import:
                    return s8 = this.startNode(), this.next(), this.match(c6.dot) ? this.parseImportMetaProperty(s8) : (this.match(c6.parenL) || this.raise(this.state.lastTokStart, g6.UnsupportedImport), this.finishNode(s8, "Import"));
                case c6._this:
                    return s8 = this.startNode(), this.next(), this.finishNode(s8, "ThisExpression");
                case c6.name:
                    {
                        const t28 = this.state.containsEsc, s9 = this.parseIdentifier();
                        if (!t28 && "async" === s9.name && !this.canInsertSemicolon()) {
                            if (this.match(c6._function)) {
                                const t29 = this.state.context.length - 1;
                                if (this.state.context[t29] !== T5.functionStatement) throw new Error("Internal error");
                                return this.state.context[t29] = T5.functionExpression, this.next(), this.parseFunction(this.startNodeAtNode(s9), void 0, !0);
                            }
                            if (this.match(c6.name)) return this.parseAsyncArrowUnaryFunction(s9);
                        }
                        return e27 && this.match(c6.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s9), [
                            s9
                        ], !1)) : s9;
                    }
                case c6._do:
                    return this.parseDo();
                case c6.regexp:
                    {
                        const t28 = this.state.value;
                        return s8 = this.parseLiteral(t28.value, "RegExpLiteral"), s8.pattern = t28.pattern, s8.flags = t28.flags, s8;
                    }
                case c6.num:
                    return this.parseLiteral(this.state.value, "NumericLiteral");
                case c6.bigint:
                    return this.parseLiteral(this.state.value, "BigIntLiteral");
                case c6.decimal:
                    return this.parseLiteral(this.state.value, "DecimalLiteral");
                case c6.string:
                    return this.parseLiteral(this.state.value, "StringLiteral");
                case c6._null:
                    return s8 = this.startNode(), this.next(), this.finishNode(s8, "NullLiteral");
                case c6._true:
                case c6._false:
                    return this.parseBooleanLiteral();
                case c6.parenL:
                    return this.parseParenAndDistinguishExpression(e27);
                case c6.bracketBarL:
                case c6.bracketHashL:
                    return this.parseArrayLike(this.state.type === c6.bracketBarL ? c6.bracketBarR : c6.bracketR, !1, !0, t);
                case c6.bracketL:
                    return this.parseArrayLike(c6.bracketR, !0, !1, t);
                case c6.braceBarL:
                case c6.braceHashL:
                    return this.parseObjectLike(this.state.type === c6.braceBarL ? c6.braceBarR : c6.braceR, !1, !0, t);
                case c6.braceL:
                    return this.parseObjectLike(c6.braceR, !1, !1, t);
                case c6._function:
                    return this.parseFunctionOrFunctionSent();
                case c6.at:
                    this.parseDecorators();
                case c6._class:
                    return s8 = this.startNode(), this.takeDecorators(s8), this.parseClass(s8, !1);
                case c6._new:
                    return this.parseNewOrNewTarget();
                case c6.backQuote:
                    return this.parseTemplate(!1);
                case c6.doubleColon:
                    {
                        s8 = this.startNode(), this.next(), s8.object = null;
                        const t28 = s8.callee = this.parseNoCallExpr();
                        if ("MemberExpression" === t28.type) return this.finishNode(s8, "BindExpression");
                        throw this.raise(t28.start, g6.UnsupportedBind);
                    }
                case c6.hash:
                    {
                        if (this.state.inPipeline) return s8 = this.startNode(), "smart" !== this.getPluginOption("pipelineOperator", "proposal") && this.raise(s8.start, g6.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(s8.start, g6.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(s8, "PipelinePrimaryTopicReference");
                        const t28 = this.input.codePointAt(this.state.end);
                        if (L3(t28) || 92 === t28) {
                            const t29 = this.state.start;
                            if (s8 = this.parseMaybePrivateName(!0), this.match(c6._in)) this.expectPlugin("privateIn"), this.classScope.usePrivateName(s8.id.name, s8.start);
                            else {
                                if (!this.hasPlugin("privateIn")) throw this.unexpected(t29);
                                this.raise(this.state.start, g6.PrivateInExpectedIn, s8.id.name);
                            }
                            return s8;
                        }
                    }
                case c6.relational:
                    if ("<" === this.state.value) {
                        const t28 = this.input.codePointAt(this.nextTokenStart());
                        (L3(t28) || 62 === t28) && this.expectOnePlugin([
                            "jsx",
                            "flow",
                            "typescript"
                        ]);
                    }
                default:
                    throw this.unexpected();
            }
        }
        parseAsyncArrowUnaryFunction(t) {
            const e27 = this.startNodeAtNode(t);
            this.prodParam.enter(ct2(!0, this.prodParam.hasYield));
            const s8 = [
                this.parseIdentifier()
            ];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, g6.LineTerminatorBeforeArrow), this.expect(c6.arrow), this.parseArrowExpression(e27, s8, !0), e27;
        }
        parseDo() {
            this.expectPlugin("doExpressions");
            const t28 = this.startNode();
            this.next();
            const e27 = this.state.labels;
            return this.state.labels = [], t28.body = this.parseBlock(), this.state.labels = e27, this.finishNode(t28, "DoExpression");
        }
        parseSuper() {
            const t28 = this.startNode();
            return this.next(), !this.match(c6.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t28.start, g6.UnexpectedSuper) : this.raise(t28.start, g6.SuperNotAllowed), this.match(c6.parenL) || this.match(c6.bracketL) || this.match(c6.dot) || this.raise(t28.start, g6.UnsupportedSuper), this.finishNode(t28, "Super");
        }
        parseBooleanLiteral() {
            const t28 = this.startNode();
            return t28.value = this.match(c6._true), this.next(), this.finishNode(t28, "BooleanLiteral");
        }
        parseMaybePrivateName(t) {
            if (this.match(c6.hash)) {
                this.expectOnePlugin([
                    "classPrivateProperties",
                    "classPrivateMethods"
                ]), t || this.raise(this.state.pos, g6.UnexpectedPrivateField);
                const e27 = this.startNode();
                return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), e27.id = this.parseIdentifier(!0), this.finishNode(e27, "PrivateName");
            }
            return this.parseIdentifier(!0);
        }
        parseFunctionOrFunctionSent() {
            const t28 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(c6.dot)) {
                const e27 = this.createIdentifier(this.startNodeAtNode(t28), "function");
                return this.next(), this.parseMetaProperty(t28, e27, "sent");
            }
            return this.parseFunction(t28);
        }
        parseMetaProperty(t, e, s) {
            t.meta = e, "function" === e.name && "sent" === s && (this.isContextual(s) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
            const r8 = this.state.containsEsc;
            return t.property = this.parseIdentifier(!0), (t.property.name !== s || r8) && this.raise(t.property.start, g6.UnsupportedMetaProperty, e.name, s), this.finishNode(t, "MetaProperty");
        }
        parseImportMetaProperty(t) {
            const e27 = this.createIdentifier(this.startNodeAtNode(t), "import");
            return this.next(), this.isContextual("meta") && (this.inModule || this.raiseWithData(e27.start, {
                code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            }, g6.ImportMetaOutsideModule), this.sawUnambiguousESM = !0), this.parseMetaProperty(t, e27, "meta");
        }
        parseLiteral(t, e, s, r) {
            s = s || this.state.start, r = r || this.state.startLoc;
            const i7 = this.startNodeAt(s, r);
            return this.addExtra(i7, "rawValue", t), this.addExtra(i7, "raw", this.input.slice(s, this.state.end)), i7.value = t, this.next(), this.finishNode(i7, e);
        }
        parseParenAndDistinguishExpression(t) {
            const e27 = this.state.start, s8 = this.state.startLoc;
            let r8;
            this.next(), this.expressionScope.enter(new It3(1));
            const i7 = this.state.maybeInArrowParameters, n9 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
            const a6 = this.state.start, o6 = this.state.startLoc, u5 = [], h6 = new wt2, p7 = {
                start: 0
            };
            let l6, d7, D6 = !0;
            for(; !this.match(c6.parenR);){
                if (D6) D6 = !1;
                else if (this.expect(c6.comma, p7.start || null), this.match(c6.parenR)) {
                    d7 = this.state.start;
                    break;
                }
                if (this.match(c6.ellipsis)) {
                    const t28 = this.state.start, e28 = this.state.startLoc;
                    l6 = this.state.start, u5.push(this.parseParenItem(this.parseRestBinding(), t28, e28)), this.checkCommaAfterRest(41);
                    break;
                }
                u5.push(this.parseMaybeAssignAllowIn(h6, this.parseParenItem, p7));
            }
            const m6 = this.state.lastTokEnd, f6 = this.state.lastTokEndLoc;
            this.expect(c6.parenR), this.state.maybeInArrowParameters = i7, this.state.inFSharpPipelineDirectBody = n9;
            let y7 = this.startNodeAt(e27, s8);
            if (t && this.shouldParseArrow() && (y7 = this.parseArrow(y7))) {
                this.expressionScope.validateAsPattern(), this.expressionScope.exit();
                for(let t28 = 0; t28 < u5.length; t28++){
                    const e28 = u5[t28];
                    e28.extra && e28.extra.parenthesized && this.unexpected(e28.extra.parenStart);
                }
                return this.parseArrowExpression(y7, u5, !1), y7;
            }
            if (this.expressionScope.exit(), u5.length || this.unexpected(this.state.lastTokStart), d7 && this.unexpected(d7), l6 && this.unexpected(l6), this.checkExpressionErrors(h6, !0), p7.start && this.unexpected(p7.start), this.toReferencedListDeep(u5, !0), u5.length > 1 ? (r8 = this.startNodeAt(a6, o6), r8.expressions = u5, this.finishNodeAt(r8, "SequenceExpression", m6, f6)) : r8 = u5[0], !this.options.createParenthesizedExpressions) return this.addExtra(r8, "parenthesized", !0), this.addExtra(r8, "parenStart", e27), r8;
            const E6 = this.startNodeAt(e27, s8);
            return E6.expression = r8, this.finishNode(E6, "ParenthesizedExpression"), E6;
        }
        shouldParseArrow() {
            return !this.canInsertSemicolon();
        }
        parseArrow(t) {
            if (this.eat(c6.arrow)) return t;
        }
        parseParenItem(t, e, s) {
            return t;
        }
        parseNewOrNewTarget() {
            const t28 = this.startNode();
            if (this.next(), this.match(c6.dot)) {
                const e27 = this.createIdentifier(this.startNodeAtNode(t28), "new");
                this.next();
                const s8 = this.parseMetaProperty(t28, e27, "target");
                if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                    let t29 = g6.UnexpectedNewTarget;
                    this.hasPlugin("classProperties") && (t29 += " or class properties"), this.raise(s8.start, t29);
                }
                return s8;
            }
            return this.parseNew(t28);
        }
        parseNew(t) {
            return t.callee = this.parseNoCallExpr(), "Import" === t.callee.type ? this.raise(t.callee.start, g6.ImportCallNotNewExpression) : "OptionalMemberExpression" === t.callee.type || "OptionalCallExpression" === t.callee.type ? this.raise(this.state.lastTokEnd, g6.OptionalChainingNoNew) : this.eat(c6.questionDot) && this.raise(this.state.start, g6.OptionalChainingNoNew), this.parseNewArguments(t), this.finishNode(t, "NewExpression");
        }
        parseNewArguments(t) {
            if (this.eat(c6.parenL)) {
                const e27 = this.parseExprList(c6.parenR);
                this.toReferencedList(e27), t.arguments = e27;
            } else t.arguments = [];
        }
        parseTemplateElement(t) {
            const e27 = this.startNode();
            return null === this.state.value && (t || this.raise(this.state.start + 1, g6.InvalidEscapeSequenceTemplate)), e27.value = {
                raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
                cooked: this.state.value
            }, this.next(), e27.tail = this.match(c6.backQuote), this.finishNode(e27, "TemplateElement");
        }
        parseTemplate(t) {
            const e27 = this.startNode();
            this.next(), e27.expressions = [];
            let s8 = this.parseTemplateElement(t);
            for(e27.quasis = [
                s8
            ]; !s8.tail;)this.expect(c6.dollarBraceL), e27.expressions.push(this.parseTemplateSubstitution()), this.expect(c6.braceR), e27.quasis.push(s8 = this.parseTemplateElement(t));
            return this.next(), this.finishNode(e27, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
            return this.parseExpression();
        }
        parseObjectLike(t, e, s, r) {
            s && this.expectPlugin("recordAndTuple");
            const i7 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const n9 = Object.create(null);
            let a6 = !0;
            const o6 = this.startNode();
            for(o6.properties = [], this.next(); !this.match(t);){
                if (a6) a6 = !1;
                else if (this.expect(c6.comma), this.match(t)) {
                    this.addExtra(o6, "trailingComma", this.state.lastTokStart);
                    break;
                }
                const i8 = this.parsePropertyDefinition(e, r);
                e || this.checkProto(i8, s, n9, r), s && "ObjectProperty" !== i8.type && "SpreadElement" !== i8.type && this.raise(i8.start, g6.InvalidRecordProperty), i8.shorthand && this.addExtra(i8, "shorthand", !0), o6.properties.push(i8);
            }
            this.state.exprAllowed = !1, this.next(), this.state.inFSharpPipelineDirectBody = i7;
            let u5 = "ObjectExpression";
            return e ? u5 = "ObjectPattern" : s && (u5 = "RecordExpression"), this.finishNode(o6, u5);
        }
        maybeAsyncOrAccessorProp(t) {
            return !t.computed && "Identifier" === t.key.type && (this.isLiteralPropertyName() || this.match(c6.bracketL) || this.match(c6.star));
        }
        parsePropertyDefinition(t, e) {
            let s8 = [];
            if (this.match(c6.at)) for(this.hasPlugin("decorators") && this.raise(this.state.start, g6.UnsupportedPropertyDecorator); this.match(c6.at);)s8.push(this.parseDecorator());
            const r8 = this.startNode();
            let i7, n9, a6 = !1, o6 = !1, u5 = !1;
            if (this.match(c6.ellipsis)) return s8.length && this.unexpected(), t ? (this.next(), r8.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r8, "RestElement")) : this.parseSpread();
            s8.length && (r8.decorators = s8, s8 = []), r8.method = !1, (t || e) && (i7 = this.state.start, n9 = this.state.startLoc), t || (a6 = this.eat(c6.star));
            const h6 = this.state.containsEsc, p7 = this.parsePropertyName(r8, !1);
            if (!t && !a6 && !h6 && this.maybeAsyncOrAccessorProp(r8)) {
                const t28 = p7.name;
                "async" !== t28 || this.hasPrecedingLineBreak() || (o6 = !0, a6 = this.eat(c6.star), this.parsePropertyName(r8, !1)), "get" !== t28 && "set" !== t28 || (u5 = !0, r8.kind = t28, this.match(c6.star) && (a6 = !0, this.raise(this.state.pos, g6.AccessorIsGenerator, t28), this.next()), this.parsePropertyName(r8, !1));
            }
            return this.parseObjPropValue(r8, i7, n9, a6, o6, t, u5, e), r8;
        }
        getGetterSetterExpectedParamCount(t) {
            return "get" === t.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(t) {
            return t.params;
        }
        checkGetterSetterParams(t) {
            var e27;
            const s8 = this.getGetterSetterExpectedParamCount(t), r8 = this.getObjectOrClassMethodParams(t), i7 = t.start;
            r8.length !== s8 && ("get" === t.kind ? this.raise(i7, g6.BadGetterArity) : this.raise(i7, g6.BadSetterArity)), "set" === t.kind && "RestElement" === (null == (e27 = r8[r8.length - 1]) ? void 0 : e27.type) && this.raise(i7, g6.BadSetterRestParameter);
        }
        parseObjectMethod(t, e, s, r, i) {
            return i ? (this.parseMethod(t, e, !1, !1, !1, "ObjectMethod"), this.checkGetterSetterParams(t), t) : s || e || this.match(c6.parenL) ? (r && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, e, s, !1, !1, "ObjectMethod")) : void 0;
        }
        parseObjectProperty(t, e, s, r, i) {
            return t.shorthand = !1, this.eat(c6.colon) ? (t.value = r ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProperty")) : t.computed || "Identifier" !== t.key.type ? void 0 : (this.checkReservedWord(t.key.name, t.key.start, !0, !1), r ? t.value = this.parseMaybeDefault(e, s, t.key.__clone()) : this.match(c6.eq) && i ? (-1 === i.shorthandAssign && (i.shorthandAssign = this.state.start), t.value = this.parseMaybeDefault(e, s, t.key.__clone())) : t.value = t.key.__clone(), t.shorthand = !0, this.finishNode(t, "ObjectProperty"));
        }
        parseObjPropValue(t, e, s, r, i, n, a, o) {
            const u5 = this.parseObjectMethod(t, r, i, n, a) || this.parseObjectProperty(t, e, s, n, o);
            return u5 || this.unexpected(), u5;
        }
        parsePropertyName(t, e) {
            if (this.eat(c6.bracketL)) t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(c6.bracketR);
            else {
                const s8 = this.state.inPropertyName;
                this.state.inPropertyName = !0, t.key = this.match(c6.num) || this.match(c6.string) || this.match(c6.bigint) || this.match(c6.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(e), "PrivateName" !== t.key.type && (t.computed = !1), this.state.inPropertyName = s8;
            }
            return t.key;
        }
        initFunction(t, e) {
            t.id = null, t.generator = !1, t.async = !!e;
        }
        parseMethod(t, e, s, r, i, n, a = !1) {
            this.initFunction(t, s), t.generator = !!e;
            const o6 = r;
            return this.scope.enter(18 | (a ? 64 : 0) | (i ? 32 : 0)), this.prodParam.enter(ct2(s, t.generator)), this.parseFunctionParams(t, r), this.parseFunctionBodyAndFinish(t, n, !0), this.prodParam.exit(), this.scope.exit(), t;
        }
        parseArrayLike(t, e, s, r) {
            s && this.expectPlugin("recordAndTuple");
            const i7 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const n9 = this.startNode();
            return this.next(), n9.elements = this.parseExprList(t, !s, r, n9), this.state.inFSharpPipelineDirectBody = i7, this.finishNode(n9, s ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(t, e, s, r) {
            this.scope.enter(6);
            let i7 = ct2(s, !1);
            !this.match(c6.bracketL) && this.prodParam.hasIn && (i7 |= 8), this.prodParam.enter(i7), this.initFunction(t, s);
            const n9 = this.state.maybeInArrowParameters;
            return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, r)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n9, this.finishNode(t, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(t, e, s) {
            t.params = this.toAssignableList(e, s);
        }
        parseFunctionBodyAndFinish(t, e, s = !1) {
            this.parseFunctionBody(t, !1, s), this.finishNode(t, e);
        }
        parseFunctionBody(t, e, s = !1) {
            const r8 = e && !this.match(c6.braceL);
            if (this.expressionScope.enter(kt2()), r8) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1);
            else {
                const r9 = this.state.strict, i7 = this.state.labels;
                this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t.body = this.parseBlock(!0, !1, (i8)=>{
                    const n9 = !this.isSimpleParamList(t.params);
                    if (i8 && n9) {
                        const e27 = "method" !== t.kind && "constructor" !== t.kind || !t.key ? t.start : t.key.end;
                        this.raise(e27, g6.IllegalLanguageModeDirective);
                    }
                    const a6 = !r9 && this.state.strict;
                    this.checkParams(t, !(this.state.strict || e || s || n9), e, a6), this.state.strict && t.id && this.checkLVal(t.id, 65, void 0, "function name", void 0, a6);
                }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i7;
            }
        }
        isSimpleParamList(t) {
            for(let e27 = 0, s8 = t.length; e27 < s8; e27++)if ("Identifier" !== t[e27].type) return !1;
            return !0;
        }
        checkParams(t, e, s, r = !0) {
            const i7 = Object.create(null);
            for(let s8 = 0; s8 < t.params.length; s8++)this.checkLVal(t.params[s8], 5, e ? null : i7, "function parameter list", void 0, r);
        }
        parseExprList(t, e, s, r) {
            const i7 = [];
            let n9 = !0;
            for(; !this.eat(t);){
                if (n9) n9 = !1;
                else if (this.expect(c6.comma), this.match(t)) {
                    r && this.addExtra(r, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                }
                i7.push(this.parseExprListItem(e, s));
            }
            return i7;
        }
        parseExprListItem(t, e, s, r) {
            let i7;
            if (this.match(c6.comma)) t || this.raise(this.state.pos, g6.UnexpectedToken, ","), i7 = null;
            else if (this.match(c6.ellipsis)) {
                const t28 = this.state.start, r8 = this.state.startLoc;
                i7 = this.parseParenItem(this.parseSpread(e, s), t28, r8);
            } else if (this.match(c6.question)) {
                this.expectPlugin("partialApplication"), r || this.raise(this.state.start, g6.UnexpectedArgumentPlaceholder);
                const t28 = this.startNode();
                this.next(), i7 = this.finishNode(t28, "ArgumentPlaceholder");
            } else i7 = this.parseMaybeAssignAllowIn(e, this.parseParenItem, s);
            return i7;
        }
        parseIdentifier(t) {
            const e27 = this.startNode(), s8 = this.parseIdentifierName(e27.start, t);
            return this.createIdentifier(e27, s8);
        }
        createIdentifier(t, e) {
            return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
        }
        parseIdentifierName(t, e) {
            let s8;
            const { start: r8 , type: i7  } = this.state;
            if (i7 === c6.name) s8 = this.state.value;
            else {
                if (!i7.keyword) throw this.unexpected();
                {
                    s8 = i7.keyword;
                    const t28 = this.curContext();
                    i7 !== c6._class && i7 !== c6._function || t28 !== T5.functionStatement && t28 !== T5.functionExpression || this.state.context.pop();
                }
            }
            return e ? this.state.type = c6.name : this.checkReservedWord(s8, r8, !!i7.keyword, !1), this.next(), s8;
        }
        checkReservedWord(t, e, s, r) {
            if (this.prodParam.hasYield && "yield" === t) return void this.raise(e, g6.YieldBindingIdentifier);
            if ("await" === t) {
                if (this.prodParam.hasAwait) return void this.raise(e, g6.AwaitBindingIdentifier);
                this.expressionScope.recordAsyncArrowParametersError(e, g6.AwaitBindingIdentifier);
            }
            if (this.scope.inClass && !this.scope.inNonArrowFunction && "arguments" === t) return void this.raise(e, g6.ArgumentsInClass);
            if (s && W3(t)) return void this.raise(e, g6.UnexpectedKeyword, t);
            (this.state.strict ? r ? H5 : V4 : q5)(t, this.inModule) && (this.prodParam.hasAwait || "await" !== t ? this.raise(e, g6.UnexpectedReservedWord, t) : this.raise(e, this.hasPlugin("topLevelAwait") ? g6.AwaitNotInAsyncContext : g6.AwaitNotInAsyncFunction));
        }
        isAwaitAllowed() {
            return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin("topLevelAwait") && (this.inModule && this.prodParam.hasAwait);
        }
        parseAwait() {
            const t28 = this.startNode();
            return this.next(), this.expressionScope.recordParameterInitializerError(t28.start, g6.AwaitExpressionFormalParameter), this.eat(c6.star) && this.raise(t28.start, g6.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(c6.plusMin) || this.match(c6.parenL) || this.match(c6.bracketL) || this.match(c6.backQuote) || this.match(c6.regexp) || this.match(c6.slash) || this.hasPlugin("v8intrinsic") && this.match(c6.modulo) ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t28.argument = this.parseMaybeUnary()), this.finishNode(t28, "AwaitExpression");
        }
        parseYield() {
            const t28 = this.startNode();
            return this.expressionScope.recordParameterInitializerError(t28.start, g6.YieldInParameter), this.next(), this.match(c6.semi) || !this.match(c6.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (t28.delegate = !1, t28.argument = null) : (t28.delegate = this.eat(c6.star), t28.argument = this.parseMaybeAssign()), this.finishNode(t28, "YieldExpression");
        }
        checkPipelineAtInfixOperator(t, e) {
            "smart" === this.getPluginOption("pipelineOperator", "proposal") && "SequenceExpression" === t.type && this.raise(e, g6.PipelineHeadSequenceExpression);
        }
        parseSmartPipelineBody(t, e, s) {
            return this.checkSmartPipelineBodyEarlyErrors(t, e), this.parseSmartPipelineBodyInStyle(t, e, s);
        }
        checkSmartPipelineBodyEarlyErrors(t, e) {
            if (this.match(c6.arrow)) throw this.raise(this.state.start, g6.PipelineBodyNoArrow);
            "SequenceExpression" === t.type && this.raise(e, g6.PipelineBodySequenceExpression);
        }
        parseSmartPipelineBodyInStyle(t, e, s) {
            const r8 = this.startNodeAt(e, s), i7 = this.isSimpleReference(t);
            return i7 ? r8.callee = t : (this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(e, g6.PipelineTopicUnused), r8.expression = t), this.finishNode(r8, i7 ? "PipelineBareFunction" : "PipelineTopicExpression");
        }
        isSimpleReference(t) {
            switch(t.type){
                case "MemberExpression":
                    return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                    return !0;
                default:
                    return !1;
            }
        }
        withTopicPermittingContext(t) {
            const e27 = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 1,
                maxTopicIndex: null
            };
            try {
                return t();
            } finally{
                this.state.topicContext = e27;
            }
        }
        withTopicForbiddingContext(t) {
            const e27 = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            };
            try {
                return t();
            } finally{
                this.state.topicContext = e27;
            }
        }
        withSoloAwaitPermittingContext(t) {
            const e27 = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
                return t();
            } finally{
                this.state.soloAwait = e27;
            }
        }
        allowInAnd(t) {
            const e27 = this.prodParam.currentFlags();
            if (8 & ~e27) {
                this.prodParam.enter(8 | e27);
                try {
                    return t();
                } finally{
                    this.prodParam.exit();
                }
            }
            return t();
        }
        disallowInAnd(t) {
            const e27 = this.prodParam.currentFlags();
            if (8 & e27) {
                this.prodParam.enter(-9 & e27);
                try {
                    return t();
                } finally{
                    this.prodParam.exit();
                }
            }
            return t();
        }
        registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
        }
        primaryTopicReferenceIsAllowedInCurrentTopicContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentTopicContext() {
            return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(t) {
            const e27 = this.state.start, s8 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const r8 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            const i7 = this.parseExprOp(this.parseMaybeUnary(), e27, s8, t);
            return this.state.inFSharpPipelineDirectBody = r8, i7;
        }
    } {
        parseTopLevel(t, e) {
            if (e.sourceType = this.options.sourceType, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, c6.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for(let t28 = 0, e27 = Array.from(this.scope.undefinedExports); t28 < e27.length; t28++){
                const [s8] = e27[t28], r8 = this.scope.undefinedExports.get(s8);
                this.raise(r8, g6.ModuleExportUndefined, s8);
            }
            return t.program = this.finishNode(e, "Program"), t.comments = this.state.comments, this.options.tokens && (t.tokens = this.tokens), this.finishNode(t, "File");
        }
        stmtToDirective(t) {
            const e27 = t.expression, s8 = this.startNodeAt(e27.start, e27.loc.start), r8 = this.startNodeAt(t.start, t.loc.start), i7 = this.input.slice(e27.start, e27.end), n9 = s8.value = i7.slice(1, -1);
            return this.addExtra(s8, "raw", i7), this.addExtra(s8, "rawValue", n9), r8.value = this.finishNodeAt(s8, "DirectiveLiteral", e27.end, e27.loc.end), this.finishNodeAt(r8, "Directive", t.end, t.loc.end);
        }
        parseInterpreterDirective() {
            if (!this.match(c6.interpreterDirective)) return null;
            const t28 = this.startNode();
            return t28.value = this.state.value, this.next(), this.finishNode(t28, "InterpreterDirective");
        }
        isLet(t) {
            if (!this.isContextual("let")) return !1;
            const e27 = this.nextTokenStart(), s8 = this.input.charCodeAt(e27);
            if (91 === s8) return !0;
            if (t) return !1;
            if (123 === s8) return !0;
            if (L3(s8)) {
                let t28 = e27 + 1;
                for(; O4(this.input.charCodeAt(t28));)++t28;
                const s9 = this.input.slice(e27, t28);
                if (!G4.test(s9)) return !0;
            }
            return !1;
        }
        parseStatement(t, e) {
            return this.match(c6.at) && this.parseDecorators(!0), this.parseStatementContent(t, e);
        }
        parseStatementContent(t, e) {
            let s8 = this.state.type;
            const r8 = this.startNode();
            let i7;
            switch(this.isLet(t) && (s8 = c6._var, i7 = "let"), s8){
                case c6._break:
                case c6._continue:
                    return this.parseBreakContinueStatement(r8, s8.keyword);
                case c6._debugger:
                    return this.parseDebuggerStatement(r8);
                case c6._do:
                    return this.parseDoStatement(r8);
                case c6._for:
                    return this.parseForStatement(r8);
                case c6._function:
                    if (46 === this.lookaheadCharCode()) break;
                    return t && (this.state.strict ? this.raise(this.state.start, g6.StrictFunction) : "if" !== t && "label" !== t && this.raise(this.state.start, g6.SloppyFunction)), this.parseFunctionStatement(r8, !1, !t);
                case c6._class:
                    return t && this.unexpected(), this.parseClass(r8, !0);
                case c6._if:
                    return this.parseIfStatement(r8);
                case c6._return:
                    return this.parseReturnStatement(r8);
                case c6._switch:
                    return this.parseSwitchStatement(r8);
                case c6._throw:
                    return this.parseThrowStatement(r8);
                case c6._try:
                    return this.parseTryStatement(r8);
                case c6._const:
                case c6._var:
                    return i7 = i7 || this.state.value, t && "var" !== i7 && this.raise(this.state.start, g6.UnexpectedLexicalDeclaration), this.parseVarStatement(r8, i7);
                case c6._while:
                    return this.parseWhileStatement(r8);
                case c6._with:
                    return this.parseWithStatement(r8);
                case c6.braceL:
                    return this.parseBlock();
                case c6.semi:
                    return this.parseEmptyStatement(r8);
                case c6._import:
                    {
                        const t28 = this.lookaheadCharCode();
                        if (40 === t28 || 46 === t28) break;
                    }
                case c6._export:
                    {
                        let t28;
                        return this.options.allowImportExportEverywhere || e || this.raise(this.state.start, g6.UnexpectedImportExport), this.next(), s8 === c6._import ? (t28 = this.parseImport(r8), "ImportDeclaration" !== t28.type || t28.importKind && "value" !== t28.importKind || (this.sawUnambiguousESM = !0)) : (t28 = this.parseExport(r8), ("ExportNamedDeclaration" !== t28.type || t28.exportKind && "value" !== t28.exportKind) && ("ExportAllDeclaration" !== t28.type || t28.exportKind && "value" !== t28.exportKind) && "ExportDefaultDeclaration" !== t28.type || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(r8), t28;
                    }
                default:
                    if (this.isAsyncFunction()) return t && this.raise(this.state.start, g6.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r8, !0, !t);
            }
            const n9 = this.state.value, a6 = this.parseExpression();
            return s8 === c6.name && "Identifier" === a6.type && this.eat(c6.colon) ? this.parseLabeledStatement(r8, n9, a6, t) : this.parseExpressionStatement(r8, a6);
        }
        assertModuleNodeAllowed(t) {
            this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(t.start, {
                code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            }, g6.ImportOutsideModule);
        }
        takeDecorators(t) {
            const e27 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            e27.length && (t.decorators = e27, this.resetStartLocationFromNode(t, e27[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
        }
        canHaveLeadingDecorator() {
            return this.match(c6._class);
        }
        parseDecorators(t) {
            const e27 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            for(; this.match(c6.at);){
                const t28 = this.parseDecorator();
                e27.push(t28);
            }
            if (this.match(c6._export)) t || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, g6.DecoratorExportClass);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, g6.UnexpectedLeadingDecorator);
        }
        parseDecorator() {
            this.expectOnePlugin([
                "decorators-legacy",
                "decorators"
            ]);
            const t28 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
                this.state.decoratorStack.push([]);
                const e27 = this.state.start, s8 = this.state.startLoc;
                let r8;
                if (this.eat(c6.parenL)) r8 = this.parseExpression(), this.expect(c6.parenR);
                else for(r8 = this.parseIdentifier(!1); this.eat(c6.dot);){
                    const t29 = this.startNodeAt(e27, s8);
                    t29.object = r8, t29.property = this.parseIdentifier(!0), t29.computed = !1, r8 = this.finishNode(t29, "MemberExpression");
                }
                t28.expression = this.parseMaybeDecoratorArguments(r8), this.state.decoratorStack.pop();
            } else t28.expression = this.parseExprSubscripts();
            return this.finishNode(t28, "Decorator");
        }
        parseMaybeDecoratorArguments(t) {
            if (this.eat(c6.parenL)) {
                const e27 = this.startNodeAtNode(t);
                return e27.callee = t, e27.arguments = this.parseCallExpressionArguments(c6.parenR, !1), this.toReferencedList(e27.arguments), this.finishNode(e27, "CallExpression");
            }
            return t;
        }
        parseBreakContinueStatement(t, e) {
            const s8 = "break" === e;
            return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, s8 ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(t, e) {
            const s8 = "break" === e;
            let r8;
            for(r8 = 0; r8 < this.state.labels.length; ++r8){
                const e27 = this.state.labels[r8];
                if (null == t.label || e27.name === t.label.name) {
                    if (null != e27.kind && (s8 || "loop" === e27.kind)) break;
                    if (t.label && s8) break;
                }
            }
            r8 === this.state.labels.length && this.raise(t.start, g6.IllegalBreakContinue, e);
        }
        parseDebuggerStatement(t) {
            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
        }
        parseHeaderExpression() {
            this.expect(c6.parenL);
            const t28 = this.parseExpression();
            return this.expect(c6.parenR), t28;
        }
        parseDoStatement(t) {
            return this.next(), this.state.labels.push(Lt3), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("do")
            ), this.state.labels.pop(), this.expect(c6._while), t.test = this.parseHeaderExpression(), this.eat(c6.semi), this.finishNode(t, "DoWhileStatement");
        }
        parseForStatement(t) {
            this.next(), this.state.labels.push(Lt3);
            let e27 = -1;
            if (this.isAwaitAllowed() && this.eatContextual("await") && (e27 = this.state.lastTokStart), this.scope.enter(0), this.expect(c6.parenL), this.match(c6.semi)) return e27 > -1 && this.unexpected(e27), this.parseFor(t, null);
            const s8 = this.isLet();
            if (this.match(c6._var) || this.match(c6._const) || s8) {
                const r8 = this.startNode(), i7 = s8 ? "let" : this.state.value;
                return this.next(), this.parseVar(r8, !0, i7), this.finishNode(r8, "VariableDeclaration"), (this.match(c6._in) || this.isContextual("of")) && 1 === r8.declarations.length ? this.parseForIn(t, r8, e27) : (e27 > -1 && this.unexpected(e27), this.parseFor(t, r8));
            }
            const r8 = new wt2, i7 = this.parseExpression(!0, r8);
            if (this.match(c6._in) || this.isContextual("of")) {
                this.toAssignable(i7);
                const s9 = this.isContextual("of") ? "for-of statement" : "for-in statement";
                return this.checkLVal(i7, void 0, void 0, s9), this.parseForIn(t, i7, e27);
            }
            return this.checkExpressionErrors(r8, !0), e27 > -1 && this.unexpected(e27), this.parseFor(t, i7);
        }
        parseFunctionStatement(t, e, s) {
            return this.next(), this.parseFunction(t, 1 | (s ? 0 : 2), e);
        }
        parseIfStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(c6._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
        }
        parseReturnStatement(t) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, g6.IllegalReturn), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
        }
        parseSwitchStatement(t) {
            this.next(), t.discriminant = this.parseHeaderExpression();
            const e27 = t.cases = [];
            let s8, r8;
            for(this.expect(c6.braceL), this.state.labels.push(Ot2), this.scope.enter(0); !this.match(c6.braceR);)if (this.match(c6._case) || this.match(c6._default)) {
                const t28 = this.match(c6._case);
                s8 && this.finishNode(s8, "SwitchCase"), e27.push(s8 = this.startNode()), s8.consequent = [], this.next(), t28 ? s8.test = this.parseExpression() : (r8 && this.raise(this.state.lastTokStart, g6.MultipleDefaultsInSwitch), r8 = !0, s8.test = null), this.expect(c6.colon);
            } else s8 ? s8.consequent.push(this.parseStatement(null)) : this.unexpected();
            return this.scope.exit(), s8 && this.finishNode(s8, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
        }
        parseThrowStatement(t) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, g6.NewlineAfterThrow), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
        }
        parseCatchClauseParam() {
            const t28 = this.parseBindingAtom(), e27 = "Identifier" === t28.type;
            return this.scope.enter(e27 ? 8 : 0), this.checkLVal(t28, 9, null, "catch clause"), t28;
        }
        parseTryStatement(t) {
            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(c6._catch)) {
                const e27 = this.startNode();
                this.next(), this.match(c6.parenL) ? (this.expect(c6.parenL), e27.param = this.parseCatchClauseParam(), this.expect(c6.parenR)) : (e27.param = null, this.scope.enter(0)), e27.body = this.withTopicForbiddingContext(()=>this.parseBlock(!1, !1)
                ), this.scope.exit(), t.handler = this.finishNode(e27, "CatchClause");
            }
            return t.finalizer = this.eat(c6._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, g6.NoCatchOrFinally), this.finishNode(t, "TryStatement");
        }
        parseVarStatement(t, e) {
            return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
        }
        parseWhileStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Lt3), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("while")
            ), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
        }
        parseWithStatement(t) {
            return this.state.strict && this.raise(this.state.start, g6.StrictWith), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("with")
            ), this.finishNode(t, "WithStatement");
        }
        parseEmptyStatement(t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
        }
        parseLabeledStatement(t, e, s, r) {
            for(let t28 = 0, r8 = this.state.labels; t28 < r8.length; t28++){
                r8[t28].name === e && this.raise(s.start, g6.LabelRedeclaration, e);
            }
            const i7 = this.state.type.isLoop ? "loop" : this.match(c6._switch) ? "switch" : null;
            for(let e27 = this.state.labels.length - 1; e27 >= 0; e27--){
                const s8 = this.state.labels[e27];
                if (s8.statementStart !== t.start) break;
                s8.statementStart = this.state.start, s8.kind = i7;
            }
            return this.state.labels.push({
                name: e,
                kind: i7,
                statementStart: this.state.start
            }), t.body = this.parseStatement(r ? -1 === r.indexOf("label") ? r + "label" : r : "label"), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
        }
        parseExpressionStatement(t, e) {
            return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
        }
        parseBlock(t = !1, e = !0, s) {
            const r8 = this.startNode();
            return this.expect(c6.braceL), e && this.scope.enter(0), this.parseBlockBody(r8, t, !1, c6.braceR, s), e && this.scope.exit(), this.finishNode(r8, "BlockStatement");
        }
        isValidDirective(t) {
            return "ExpressionStatement" === t.type && "StringLiteral" === t.expression.type && !t.expression.extra.parenthesized;
        }
        parseBlockBody(t, e, s, r, i) {
            const n9 = t.body = [], a6 = t.directives = [];
            this.parseBlockOrModuleBlockBody(n9, e ? a6 : void 0, s, r, i);
        }
        parseBlockOrModuleBlockBody(t, e, s, r, i) {
            const n9 = [], a6 = this.state.strict;
            let o6 = !1, u5 = !1;
            for(; !this.match(r);){
                !u5 && this.state.octalPositions.length && n9.push(...this.state.octalPositions);
                const r8 = this.parseStatement(null, s);
                if (e && !u5 && this.isValidDirective(r8)) {
                    const t28 = this.stmtToDirective(r8);
                    e.push(t28), o6 || "use strict" !== t28.value.value || (o6 = !0, this.setStrict(!0));
                } else u5 = !0, t.push(r8);
            }
            if (this.state.strict && n9.length) for(let t28 = 0; t28 < n9.length; t28++){
                const e27 = n9[t28];
                this.raise(e27, g6.StrictOctalLiteral);
            }
            i && i.call(this, o6), a6 || this.setStrict(!1), this.next();
        }
        parseFor(t, e) {
            return t.init = e, this.expect(c6.semi), t.test = this.match(c6.semi) ? null : this.parseExpression(), this.expect(c6.semi), t.update = this.match(c6.parenR) ? null : this.parseExpression(), this.expect(c6.parenR), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("for")
            ), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
        }
        parseForIn(t, e, s) {
            const r8 = this.match(c6._in);
            return this.next(), r8 ? s > -1 && this.unexpected(s) : t.await = s > -1, "VariableDeclaration" !== e.type || null == e.declarations[0].init || r8 && !this.state.strict && "var" === e.kind && "Identifier" === e.declarations[0].id.type ? "AssignmentPattern" === e.type && this.raise(e.start, g6.InvalidLhs, "for-loop") : this.raise(e.start, g6.ForInOfLoopInitializer, r8 ? "for-in" : "for-of"), t.left = e, t.right = r8 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(c6.parenR), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("for")
            ), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, r8 ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(t, e, s) {
            const r8 = t.declarations = [], i7 = this.hasPlugin("typescript");
            for(t.kind = s;;){
                const t28 = this.startNode();
                if (this.parseVarId(t28, s), this.eat(c6.eq) ? t28.init = e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : ("const" !== s || this.match(c6._in) || this.isContextual("of") ? "Identifier" === t28.id.type || e && (this.match(c6._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, g6.DeclarationMissingInitializer, "Complex binding patterns") : i7 || this.raise(this.state.lastTokEnd, g6.DeclarationMissingInitializer, "Const declarations"), t28.init = null), r8.push(this.finishNode(t28, "VariableDeclarator")), !this.eat(c6.comma)) break;
            }
            return t;
        }
        parseVarId(t, e) {
            t.id = this.parseBindingAtom(), this.checkLVal(t.id, "var" === e ? 5 : 9, void 0, "variable declaration", "var" !== e);
        }
        parseFunction(t, e = 0, s = !1) {
            const r8 = 1 & e, i7 = 2 & e, n9 = !(!r8 || 4 & e);
            this.initFunction(t, s), this.match(c6.star) && i7 && this.raise(this.state.start, g6.GeneratorInSingleStatementContext), t.generator = this.eat(c6.star), r8 && (t.id = this.parseFunctionId(n9));
            const a6 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ct2(s, t.generator)), r8 || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withTopicForbiddingContext(()=>{
                this.parseFunctionBodyAndFinish(t, r8 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), r8 && !i7 && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = a6, t;
        }
        parseFunctionId(t) {
            return t || this.match(c6.name) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(t, e) {
            this.expect(c6.parenL), this.expressionScope.enter(new Nt2(3)), t.params = this.parseBindingList(c6.parenR, 41, !1, e), this.expressionScope.exit();
        }
        registerFunctionStatementId(t) {
            t.id && this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t.id.start);
        }
        parseClass(t, e, s) {
            this.next(), this.takeDecorators(t);
            const r8 = this.state.strict;
            return this.state.strict = !0, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, r8), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
            return this.match(c6.eq) || this.match(c6.semi) || this.match(c6.braceR);
        }
        isClassMethod() {
            return this.match(c6.parenL);
        }
        isNonstaticConstructor(t) {
            return !(t.computed || t.static || "constructor" !== t.key.name && "constructor" !== t.key.value);
        }
        parseClassBody(t, e) {
            this.classScope.enter();
            const s8 = {
                constructorAllowsSuper: t,
                hadConstructor: !1,
                hadStaticBlock: !1
            };
            let r8 = [];
            const i7 = this.startNode();
            if (i7.body = [], this.expect(c6.braceL), this.withTopicForbiddingContext(()=>{
                for(; !this.match(c6.braceR);){
                    if (this.eat(c6.semi)) {
                        if (r8.length > 0) throw this.raise(this.state.lastTokEnd, g6.DecoratorSemicolon);
                        continue;
                    }
                    if (this.match(c6.at)) {
                        r8.push(this.parseDecorator());
                        continue;
                    }
                    const t28 = this.startNode();
                    r8.length && (t28.decorators = r8, this.resetStartLocationFromNode(t28, r8[0]), r8 = []), this.parseClassMember(i7, t28, s8), "constructor" === t28.kind && t28.decorators && t28.decorators.length > 0 && this.raise(t28.start, g6.DecoratorConstructor);
                }
            }), this.state.strict = e, this.next(), r8.length) throw this.raise(this.state.start, g6.TrailingDecorator);
            return this.classScope.exit(), this.finishNode(i7, "ClassBody");
        }
        parseClassMemberFromModifier(t, e) {
            const s8 = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
                const r8 = e;
                return e.kind = "method", e.computed = !1, e.key = s8, e.static = !1, this.pushClassMethod(t, e, !1, !1, !1, !1), !0;
            }
            if (this.isClassProperty()) {
                const r8 = e;
                return e.computed = !1, e.key = s8, e.static = !1, t.body.push(this.parseClassProperty(e)), !0;
            }
            return !1;
        }
        parseClassMember(t, e, s) {
            const r8 = this.isContextual("static");
            if (r8) {
                if (this.parseClassMemberFromModifier(t, e)) return;
                if (this.eat(c6.braceL)) return void this.parseClassStaticBlock(t, e, s);
            }
            this.parseClassMemberWithIsStatic(t, e, s, r8);
        }
        parseClassMemberWithIsStatic(t, e, s, r) {
            const i7 = e, n9 = e, a6 = e, o6 = e, u5 = i7, h6 = i7;
            if (e.static = r, this.eat(c6.star)) return i7.kind = "method", this.parseClassElementName(i7), "PrivateName" === i7.key.type ? void this.pushClassPrivateMethod(t, e, !0, !1) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g6.ConstructorIsGenerator), void this.pushClassMethod(t, e, !0, !1, !1, !1));
            const p7 = this.state.containsEsc, l6 = this.parseClassElementName(e), d7 = "PrivateName" === l6.type, D6 = "Identifier" === l6.type, m6 = this.state.start;
            if (this.parsePostMemberNameModifiers(i7), this.isClassMethod()) {
                if (i7.kind = "method", d7) return void this.pushClassPrivateMethod(t, e, !1, !1);
                const e27 = this.isNonstaticConstructor(e);
                let r8 = !1;
                e27 && (e.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(l6.start, g6.DuplicateConstructor), s.hadConstructor = !0, r8 = s.constructorAllowsSuper), this.pushClassMethod(t, e, !1, !1, e27, r8);
            } else if (this.isClassProperty()) d7 ? this.pushClassPrivateProperty(t, e) : this.pushClassProperty(t, e);
            else if (!D6 || "async" !== l6.name || p7 || this.isLineTerminator()) !D6 || "get" !== l6.name && "set" !== l6.name || p7 || this.match(c6.star) && this.isLineTerminator() ? this.isLineTerminator() ? d7 ? this.pushClassPrivateProperty(t, e) : this.pushClassProperty(t, e) : this.unexpected() : (i7.kind = l6.name, this.parseClassElementName(e), "PrivateName" === i7.key.type ? this.pushClassPrivateMethod(t, e, !1, !1) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g6.ConstructorIsAccessor), this.pushClassMethod(t, e, !1, !1, !1, !1)), this.checkGetterSetterParams(e));
            else {
                const e27 = this.eat(c6.star);
                i7.optional && this.unexpected(m6), i7.kind = "method", this.parseClassElementName(i7), this.parsePostMemberNameModifiers(i7), "PrivateName" === i7.key.type ? this.pushClassPrivateMethod(t, e, e27, !0) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g6.ConstructorIsAsync), this.pushClassMethod(t, e, e27, !0, !1, !1));
            }
        }
        parseClassElementName(t) {
            const e27 = this.parsePropertyName(t, !0);
            return t.computed || !t.static || "prototype" !== e27.name && "prototype" !== e27.value || this.raise(e27.start, g6.StaticPrototype), "PrivateName" === e27.type && "constructor" === e27.id.name && this.raise(e27.start, g6.ConstructorClassPrivateField), e27;
        }
        parseClassStaticBlock(t, e, s) {
            var r8;
            this.expectPlugin("classStaticBlock", e.start), this.scope.enter(80), this.expressionScope.enter(kt2());
            const i7 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const n9 = e.body = [];
            this.parseBlockOrModuleBlockBody(n9, void 0, !1, c6.braceR), this.prodParam.exit(), this.expressionScope.exit(), this.scope.exit(), this.state.labels = i7, t.body.push(this.finishNode(e, "StaticBlock")), s.hadStaticBlock && this.raise(e.start, g6.DuplicateStaticBlock), (null == (r8 = e.decorators) ? void 0 : r8.length) && this.raise(e.start, g6.DecoratorStaticBlock), s.hadStaticBlock = !0;
        }
        pushClassProperty(t, e) {
            e.computed || "constructor" !== e.key.name && "constructor" !== e.key.value || this.raise(e.key.start, g6.ConstructorClassField), t.body.push(this.parseClassProperty(e));
        }
        pushClassPrivateProperty(t, e) {
            this.expectPlugin("classPrivateProperties", e.key.start);
            const s8 = this.parseClassPrivateProperty(e);
            t.body.push(s8), this.classScope.declarePrivateName(s8.key.id.name, 0, s8.key.start);
        }
        pushClassMethod(t, e, s, r, i, n) {
            t.body.push(this.parseMethod(e, s, r, i, n, "ClassMethod", !0));
        }
        pushClassPrivateMethod(t, e, s, r) {
            this.expectPlugin("classPrivateMethods", e.key.start);
            const i7 = this.parseMethod(e, s, r, !1, !1, "ClassPrivateMethod", !0);
            t.body.push(i7);
            const n9 = "get" === i7.kind ? i7.static ? 6 : 2 : "set" === i7.kind ? i7.static ? 5 : 1 : 0;
            this.classScope.declarePrivateName(i7.key.id.name, n9, i7.key.start);
        }
        parsePostMemberNameModifiers(t) {
        }
        parseClassPrivateProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
        }
        parseClassProperty(t) {
            return t.typeAnnotation && !this.match(c6.eq) || this.expectPlugin("classProperties"), this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
        }
        parseInitializer(t) {
            this.scope.enter(80), this.expressionScope.enter(kt2()), this.prodParam.enter(0), t.value = this.eat(c6.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(t, e, s, r = 139) {
            this.match(c6.name) ? (t.id = this.parseIdentifier(), e && this.checkLVal(t.id, r, void 0, "class name")) : s || !e ? t.id = null : this.unexpected(null, g6.MissingClassName);
        }
        parseClassSuper(t) {
            t.superClass = this.eat(c6._extends) ? this.parseExprSubscripts() : null;
        }
        parseExport(t) {
            const e27 = this.maybeParseExportDefaultSpecifier(t), s8 = !e27 || this.eat(c6.comma), r8 = s8 && this.eatExportStar(t), i7 = r8 && this.maybeParseExportNamespaceSpecifier(t), n9 = s8 && (!i7 || this.eat(c6.comma)), a6 = e27 || r8;
            if (r8 && !i7) return e27 && this.unexpected(), this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
            const o6 = this.maybeParseExportNamedSpecifiers(t);
            if (e27 && s8 && !r8 && !o6 || i7 && n9 && !o6) throw this.unexpected(null, c6.braceL);
            let u5;
            if (a6 || o6 ? (u5 = !1, this.parseExportFrom(t, a6)) : u5 = this.maybeParseExportDeclaration(t), a6 || o6 || u5) return this.checkExport(t, !0, !1, !!t.source), this.finishNode(t, "ExportNamedDeclaration");
            if (this.eat(c6._default)) return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, !0, !0), this.finishNode(t, "ExportDefaultDeclaration");
            throw this.unexpected(null, c6.braceL);
        }
        eatExportStar(t) {
            return this.eat(c6.star);
        }
        maybeParseExportDefaultSpecifier(t) {
            if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                const e27 = this.startNode();
                return e27.exported = this.parseIdentifier(!0), t.specifiers = [
                    this.finishNode(e27, "ExportDefaultSpecifier")
                ], !0;
            }
            return !1;
        }
        maybeParseExportNamespaceSpecifier(t) {
            if (this.isContextual("as")) {
                t.specifiers || (t.specifiers = []);
                const e27 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                return this.next(), e27.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e27, "ExportNamespaceSpecifier")), !0;
            }
            return !1;
        }
        maybeParseExportNamedSpecifiers(t) {
            return !!this.match(c6.braceL) && (t.specifiers || (t.specifiers = []), t.specifiers.push(...this.parseExportSpecifiers()), t.source = null, t.declaration = null, !0);
        }
        maybeParseExportDeclaration(t) {
            return !!this.shouldParseExportDeclaration() && (t.specifiers = [], t.source = null, t.declaration = this.parseExportDeclaration(t), !0);
        }
        isAsyncFunction() {
            if (!this.isContextual("async")) return !1;
            const t28 = this.nextTokenStart();
            return !m5.test(this.input.slice(this.state.pos, t28)) && this.isUnparsedContextual(t28, "function");
        }
        parseExportDefaultExpression() {
            const t28 = this.startNode(), e27 = this.isAsyncFunction();
            if (this.match(c6._function) || e27) return this.next(), e27 && this.next(), this.parseFunction(t28, 5, e27);
            if (this.match(c6._class)) return this.parseClass(t28, !0, !0);
            if (this.match(c6.at)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, g6.DecoratorBeforeExport), this.parseDecorators(!1), this.parseClass(t28, !0, !0);
            if (this.match(c6._const) || this.match(c6._var) || this.isLet()) throw this.raise(this.state.start, g6.UnsupportedDefaultExport);
            {
                const t29 = this.parseMaybeAssignAllowIn();
                return this.semicolon(), t29;
            }
        }
        parseExportDeclaration(t) {
            return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
            if (this.match(c6.name)) {
                const t28 = this.state.value;
                if ("async" === t28 && !this.state.containsEsc || "let" === t28) return !1;
                if (("type" === t28 || "interface" === t28) && !this.state.containsEsc) {
                    const t29 = this.lookahead();
                    if (t29.type === c6.name && "from" !== t29.value || t29.type === c6.braceL) return this.expectOnePlugin([
                        "flow",
                        "typescript"
                    ]), !1;
                }
            } else if (!this.match(c6._default)) return !1;
            const t28 = this.nextTokenStart(), e27 = this.isUnparsedContextual(t28, "from");
            if (44 === this.input.charCodeAt(t28) || this.match(c6.name) && e27) return !0;
            if (this.match(c6._default) && e27) {
                const e28 = this.input.charCodeAt(this.nextTokenStartSince(t28 + 4));
                return 34 === e28 || 39 === e28;
            }
            return !1;
        }
        parseExportFrom(t, e) {
            if (this.eatContextual("from")) {
                t.source = this.parseImportSource(), this.checkExport(t);
                const e27 = this.maybeParseImportAssertions();
                e27 && (t.assertions = e27);
            } else e ? this.unexpected() : t.source = null;
            this.semicolon();
        }
        shouldParseExportDeclaration() {
            if (this.match(c6.at) && (this.expectOnePlugin([
                "decorators",
                "decorators-legacy"
            ]), this.hasPlugin("decorators"))) {
                if (!this.getPluginOption("decorators", "decoratorsBeforeExport")) return !0;
                this.unexpected(this.state.start, g6.DecoratorBeforeExport);
            }
            return "var" === this.state.type.keyword || "const" === this.state.type.keyword || "function" === this.state.type.keyword || "class" === this.state.type.keyword || this.isLet() || this.isAsyncFunction();
        }
        checkExport(t, e, s, r) {
            if (e) {
                if (s) {
                    if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                        var i7;
                        const e27 = t.declaration;
                        "Identifier" !== e27.type || "from" !== e27.name || e27.end - e27.start != 4 || (null == (i7 = e27.extra) ? void 0 : i7.parenthesized) || this.raise(e27.start, g6.ExportDefaultFromAsIdentifier);
                    }
                } else if (t.specifiers && t.specifiers.length) for(let e27 = 0, s8 = t.specifiers; e27 < s8.length; e27++){
                    const t28 = s8[e27], { exported: i7  } = t28, n9 = "Identifier" === i7.type ? i7.name : i7.value;
                    if (this.checkDuplicateExports(t28, n9), !r && t28.local) {
                        const { local: e28  } = t28;
                        "StringLiteral" === e28.type ? this.raise(t28.start, g6.ExportBindingIsString, e28.extra.raw, n9) : (this.checkReservedWord(e28.name, e28.start, !0, !1), this.scope.checkLocalExport(e28));
                    }
                }
                else if (t.declaration) {
                    if ("FunctionDeclaration" === t.declaration.type || "ClassDeclaration" === t.declaration.type) {
                        const e28 = t.declaration.id;
                        if (!e28) throw new Error("Assertion failure");
                        this.checkDuplicateExports(t, e28.name);
                    } else if ("VariableDeclaration" === t.declaration.type) for(let e28 = 0, s9 = t.declaration.declarations; e28 < s9.length; e28++){
                        const t28 = s9[e28];
                        this.checkDeclaration(t28.id);
                    }
                }
            }
            if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) throw this.raise(t.start, g6.UnsupportedDecoratorExport);
        }
        checkDeclaration(t) {
            if ("Identifier" === t.type) this.checkDuplicateExports(t, t.name);
            else if ("ObjectPattern" === t.type) for(let e27 = 0, s8 = t.properties; e27 < s8.length; e27++){
                const t28 = s8[e27];
                this.checkDeclaration(t28);
            }
            else if ("ArrayPattern" === t.type) for(let e28 = 0, s9 = t.elements; e28 < s9.length; e28++){
                const t28 = s9[e28];
                t28 && this.checkDeclaration(t28);
            }
            else "ObjectProperty" === t.type ? this.checkDeclaration(t.value) : "RestElement" === t.type ? this.checkDeclaration(t.argument) : "AssignmentPattern" === t.type && this.checkDeclaration(t.left);
        }
        checkDuplicateExports(t, e) {
            this.state.exportedIdentifiers.indexOf(e) > -1 && this.raise(t.start, "default" === e ? g6.DuplicateDefaultExport : g6.DuplicateExport, e), this.state.exportedIdentifiers.push(e);
        }
        parseExportSpecifiers() {
            const t28 = [];
            let e27 = !0;
            for(this.expect(c6.braceL); !this.eat(c6.braceR);){
                if (e27) e27 = !1;
                else if (this.expect(c6.comma), this.eat(c6.braceR)) break;
                const s8 = this.startNode();
                s8.local = this.parseModuleExportName(), s8.exported = this.eatContextual("as") ? this.parseModuleExportName() : s8.local.__clone(), t28.push(this.finishNode(s8, "ExportSpecifier"));
            }
            return t28;
        }
        parseModuleExportName() {
            if (this.match(c6.string)) {
                this.expectPlugin("moduleStringNames");
                const t28 = this.parseLiteral(this.state.value, "StringLiteral"), e27 = t28.value.match(Mt3);
                return e27 && this.raise(t28.start, g6.ModuleExportNameHasLoneSurrogate, e27[0].charCodeAt(0).toString(16)), t28;
            }
            return this.parseIdentifier(!0);
        }
        parseImport(t) {
            if (t.specifiers = [], !this.match(c6.string)) {
                const e27 = !this.maybeParseDefaultImportSpecifier(t) || this.eat(c6.comma), s8 = e27 && this.maybeParseStarImportSpecifier(t);
                e27 && !s8 && this.parseNamedImportSpecifiers(t), this.expectContextual("from");
            }
            t.source = this.parseImportSource();
            const e27 = this.maybeParseImportAssertions();
            if (e27) t.assertions = e27;
            else {
                const e28 = this.maybeParseModuleAttributes();
                e28 && (t.attributes = e28);
            }
            return this.semicolon(), this.finishNode(t, "ImportDeclaration");
        }
        parseImportSource() {
            return this.match(c6.string) || this.unexpected(), this.parseExprAtom();
        }
        shouldParseDefaultImport(t) {
            return this.match(c6.name);
        }
        parseImportSpecifierLocal(t, e, s, r) {
            e.local = this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, r), t.specifiers.push(this.finishNode(e, s));
        }
        parseAssertEntries() {
            const t28 = [], e27 = new Set;
            do {
                if (this.match(c6.braceR)) break;
                const s8 = this.startNode(), r8 = this.state.value;
                if (this.match(c6.string) ? s8.key = this.parseLiteral(r8, "StringLiteral") : s8.key = this.parseIdentifier(!0), this.expect(c6.colon), "type" !== r8 && this.raise(s8.key.start, g6.ModuleAttributeDifferentFromType, r8), e27.has(r8) && this.raise(s8.key.start, g6.ModuleAttributesWithDuplicateKeys, r8), e27.add(r8), !this.match(c6.string)) throw this.unexpected(this.state.start, g6.ModuleAttributeInvalidValue);
                s8.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s8, "ImportAttribute"), t28.push(s8);
            }while (this.eat(c6.comma))
            return t28;
        }
        maybeParseModuleAttributes() {
            if (!this.match(c6._with) || this.hasPrecedingLineBreak()) return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            const t28 = [], e27 = new Set;
            do {
                const s8 = this.startNode();
                if (s8.key = this.parseIdentifier(!0), "type" !== s8.key.name && this.raise(s8.key.start, g6.ModuleAttributeDifferentFromType, s8.key.name), e27.has(s8.key.name) && this.raise(s8.key.start, g6.ModuleAttributesWithDuplicateKeys, s8.key.name), e27.add(s8.key.name), this.expect(c6.colon), !this.match(c6.string)) throw this.unexpected(this.state.start, g6.ModuleAttributeInvalidValue);
                s8.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s8, "ImportAttribute"), t28.push(s8);
            }while (this.eat(c6.comma))
            return t28;
        }
        maybeParseImportAssertions() {
            if (!this.isContextual("assert") || this.hasPrecedingLineBreak()) return this.hasPlugin("importAssertions") ? [] : null;
            this.expectPlugin("importAssertions"), this.next(), this.eat(c6.braceL);
            const t28 = this.parseAssertEntries();
            return this.eat(c6.braceR), t28;
        }
        maybeParseDefaultImportSpecifier(t) {
            return !!this.shouldParseDefaultImport(t) && (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), !0);
        }
        maybeParseStarImportSpecifier(t) {
            if (this.match(c6.star)) {
                const e27 = this.startNode();
                return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(t, e27, "ImportNamespaceSpecifier", "import namespace specifier"), !0;
            }
            return !1;
        }
        parseNamedImportSpecifiers(t) {
            let e27 = !0;
            for(this.expect(c6.braceL); !this.eat(c6.braceR);){
                if (e27) e27 = !1;
                else {
                    if (this.eat(c6.colon)) throw this.raise(this.state.start, g6.DestructureNamedImport);
                    if (this.expect(c6.comma), this.eat(c6.braceR)) break;
                }
                this.parseImportSpecifier(t);
            }
        }
        parseImportSpecifier(t) {
            const e27 = this.startNode();
            if (e27.imported = this.parseModuleExportName(), this.eatContextual("as")) e27.local = this.parseIdentifier();
            else {
                const { imported: t28  } = e27;
                if ("StringLiteral" === t28.type) throw this.raise(e27.start, g6.ImportBindingIsString, t28.value);
                this.checkReservedWord(t28.name, e27.start, !0, !0), e27.local = t28.__clone();
            }
            this.checkLVal(e27.local, 9, void 0, "import specifier"), t.specifiers.push(this.finishNode(e27, "ImportSpecifier"));
        }
    } {
        constructor(t28, e27){
            super(t28 = function(t29) {
                const e28 = {
                };
                for(let s8 = 0, r8 = Object.keys(Ct2); s8 < r8.length; s8++){
                    const i7 = r8[s8];
                    e28[i7] = t29 && null != t29[i7] ? t29[i7] : Ct2[i7];
                }
                return e28;
            }(t28), e27);
            const s8 = this.getScopeHandler();
            this.options = t28, this.inModule = "module" === this.options.sourceType, this.scope = new s8(this.raise.bind(this), this.inModule), this.prodParam = new ht3, this.classScope = new _t3(this.raise.bind(this)), this.expressionScope = new vt2(this.raise.bind(this)), this.plugins = (function(t29) {
                const e28 = new Map;
                for(let s9 = 0; s9 < t29.length; s9++){
                    const r8 = t29[s9], [i7, n9] = Array.isArray(r8) ? r8 : [
                        r8,
                        {
                        }
                    ];
                    e28.has(i7) || e28.set(i7, n9 || {
                    });
                }
                return e28;
            })(this.options.plugins), this.filename = t28.sourceFilename;
        }
        getScopeHandler() {
            return at3;
        }
        parse() {
            let t29 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t29 |= 2), this.scope.enter(1), this.prodParam.enter(t29);
            const e28 = this.startNode(), s9 = this.startNode();
            return this.nextToken(), e28.errors = null, this.parseTopLevel(e28, s9), e28.errors = this.state.errors, e28;
        }
    }
    function Ut3(t29, e28) {
        let s9 = jt3;
        return ((null == t29 ? void 0 : t29.plugins) && (!function(t30) {
            if (Dt3(t30, "decorators")) {
                if (Dt3(t30, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                const e29 = mt2(t30, "decorators", "decoratorsBeforeExport");
                if (null == e29) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
                if ("boolean" != typeof e29) throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (Dt3(t30, "flow") && Dt3(t30, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
            if (Dt3(t30, "placeholders") && Dt3(t30, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (Dt3(t30, "pipelineOperator") && !ft3.includes(mt2(t30, "pipelineOperator", "proposal"))) throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + ft3.map((t31)=>"'".concat(t31, "'")
            ).join(", "));
            if (Dt3(t30, "moduleAttributes")) {
                if (Dt3(t30, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
                if ("may-2020" !== mt2(t30, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (Dt3(t30, "recordAndTuple") && !yt2.includes(mt2(t30, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + yt2.map((t31)=>"'".concat(t31, "'")
            ).join(", "));
        }(t29.plugins), s9 = function(t30) {
            const e29 = At2.filter((e30)=>Dt3(t30, e30)
            ), s10 = e29.join("/");
            let r8 = qt3[s10];
            if (!r8) {
                r8 = jt3;
                for(let t31 = 0; t31 < e29.length; t31++){
                    const s11 = e29[t31];
                    r8 = Et2[s11](r8);
                }
                qt3[s10] = r8;
            }
            return r8;
        }(t29.plugins)), new s9(t29, e28));
    }
    const qt3 = {
    };
    e19.parse = function(t29, e28) {
        var s9;
        if ("unambiguous" !== (null == (s9 = e28) ? void 0 : s9.sourceType)) return Ut3(e28, t29).parse();
        e28 = Object.assign({
        }, e28);
        try {
            e28.sourceType = "module";
            const s10 = Ut3(e28, t29), r8 = s10.parse();
            if (s10.sawUnambiguousESM) return r8;
            if (s10.ambiguousScriptDifferentAst) try {
                return e28.sourceType = "script", Ut3(e28, t29).parse();
            } catch (t) {
            }
            else r8.program.sourceType = "script";
            return r8;
        } catch (s) {
            try {
                return e28.sourceType = "script", Ut3(e28, t29).parse();
            } catch (t) {
            }
            throw s;
        }
    }, e19.parseExpression = function(t29, e28) {
        const s9 = Ut3(e28, t29);
        return s9.options.strictMode && (s9.state.strict = !0), s9.getExpression();
    }, e19.tokTypes = c6;
});
const { getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Rs1 , getShebang: _s1  } = It2, { hasPragma: js1  } = Wt2, { locStart: Us1 , locEnd: qs1  } = Jt1;
function zs1(e19, ...s5) {
    return (r6, i6, n8 = {
    })=>{
        if ("babel" === n8.parser && (function(t13, e20) {
            if (e20.filepath && e20.filepath.endsWith(".js.flow")) return !0;
            const s6 = _s1(t13);
            s6 && (t13 = t13.slice(s6.length));
            const r7 = Rs1(t13, 0);
            return !1 !== r7 && (t13 = t13.slice(0, r7)), Vs1.test(t13);
        })(r6, n8)) return n8.parser = "babel-flow", Ws2(r6, i6, n8);
        const a5 = Ms1, o5 = "script" === n8.__babelSourceType ? "script" : "module";
        let u4;
        try {
            u4 = (function(t13, e20) {
                let s6;
                for(let r7 = 0; r7 < e20.length; r7++)try {
                    return Js1(t13(e20[r7]));
                } catch (t) {
                    s6 || (s6 = t);
                }
                throw s6;
            })((t13)=>Ms1[e19](r6, t13)
            , (function(t13, e20, s6) {
                if (!t13) return e20;
                const r7 = [];
                for (const t14 of e20)for (const e21 of s6)r7.push([
                    ...t14,
                    e21
                ]);
                return r7;
            })(r6.includes("|>"), s5, [
                [
                    "pipelineOperator",
                    {
                        proposal: "smart"
                    }
                ],
                [
                    "pipelineOperator",
                    {
                        proposal: "minimal"
                    }
                ],
                [
                    "pipelineOperator",
                    {
                        proposal: "fsharp"
                    }
                ]
            ]).map((t13)=>(function({ sourceType: t14 , extraPlugins: e20 = []  }) {
                    return {
                        sourceType: t14,
                        allowAwaitOutsideFunction: !0,
                        allowImportExportEverywhere: !0,
                        allowReturnOutsideFunction: !0,
                        allowSuperOutsideMethod: !0,
                        allowUndeclaredExports: !0,
                        errorRecovery: !0,
                        createParenthesizedExpressions: !0,
                        plugins: [
                            "doExpressions",
                            "classProperties",
                            "exportDefaultFrom",
                            "functionBind",
                            "functionSent",
                            "classPrivateProperties",
                            "throwExpressions",
                            "classPrivateMethods",
                            "v8intrinsic",
                            "partialApplication",
                            [
                                "decorators",
                                {
                                    decoratorsBeforeExport: !1
                                }
                            ],
                            "privateIn",
                            "importAssertions",
                            [
                                "recordAndTuple",
                                {
                                    syntaxType: "hash"
                                }
                            ],
                            "decimal",
                            "moduleStringNames",
                            "classStaticBlock",
                            ...e20
                        ],
                        tokens: !0,
                        ranges: !0
                    };
                })({
                    sourceType: o5,
                    extraPlugins: t13
                })
            ));
        } catch (e) {
            const { message: s6 , loc: r7  } = e;
            throw t2(s6.replace(/ \(.*\)/, ""), {
                start: {
                    line: r7 ? r7.line : 0,
                    column: r7 ? r7.column + 1 : 0
                }
            });
        }
        return Os1(u4, Object.assign({
        }, n8, {
            originalText: r6
        }));
    };
}
const Hs1 = zs1("parse", [
    "jsx",
    "flow"
]), Ws2 = zs1("parse", [
    "jsx",
    [
        "flow",
        {
            all: !0,
            enums: !0
        }
    ]
]), Gs1 = zs1("parse", [
    "jsx",
    "typescript"
], [
    "typescript"
]), Xs1 = zs1("parseExpression", [
    "jsx"
]);
const Ys1 = {
    parse: Hs1,
    astFormat: "estree",
    hasPragma: js1,
    locStart: Us1,
    locEnd: qs1
}, Qs1 = Object.assign({
}, Ys1, {
    parse: Ws2
}), Zs1 = Object.assign({
}, Ys1, {
    parse: Gs1
}), tr1 = Object.assign({
}, Ys1, {
    parse: Xs1
});
var er1 = {
    parsers: {
        babel: Ys1,
        "babel-flow": Qs1,
        "babel-ts": Zs1,
        json: Object.assign({
        }, tr1, {
            hasPragma: ()=>!0
        }),
        json5: tr1,
        "json-stringify": {
            parse: function(t13, e19, s5) {
                const r6 = Xs1(t13, e19, s5);
                return (r6.comments.forEach($s1), $s1(r6), r6);
            },
            astFormat: "estree-json",
            locStart: Us1,
            locEnd: qs1
        },
        __js_expression: tr1,
        __vue_expression: tr1,
        __vue_event_binding: Ys1
    }
};
function L3() {
    O1 && N2 && (O1 = !1, N2.length ? x4 = N2.concat(x4) : R2 = -1, x4.length && P4());
}
function P4() {
    if (!O1) {
        var e19 = k2(L3);
        O1 = !0;
        for(var t13 = x4.length; t13;){
            for(N2 = x4, x4 = []; (++R2) < t13;)N2 && N2[R2].run();
            R2 = -1, t13 = x4.length;
        }
        N2 = null, O1 = !1, (function(e20) {
            if (w2 === clearTimeout) return clearTimeout(e20);
            if ((w2 === A2 || !w2) && clearTimeout) return w2 = clearTimeout, clearTimeout(e20);
            try {
                w2(e20);
            } catch (t) {
                try {
                    return w2.call(null, e20);
                } catch (t) {
                    return w2.call(this, e20);
                }
            }
        })(e19);
    }
}
var W3 = {
    nextTick: function(e19) {
        var t13 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n8 = 1; n8 < arguments.length; n8++)t13[n8 - 1] = arguments[n8];
        x4.push(new B1(e19, t13)), 1 !== x4.length || O1 || k2(P4);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: q2,
    addListener: $1,
    once: M1,
    off: U2,
    removeListener: G1,
    removeAllListeners: V2,
    emit: j1,
    binding: function(e19) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(e19) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(e19) {
        var t13 = 0.001 * X1.call(H1), n8 = Math.floor(t13), r6 = Math.floor(t13 % 1 * 1000000000);
        return (e19 && (n8 -= e19[0], (r6 -= e19[1]) < 0 && (n8--, r6 += 1000000000)), [
            n8,
            r6
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - z1) / 1000;
    }
};
var Q4 = "object" == typeof W3 && W3.env && W3.env.NODE_DEBUG && /\bsemver\b/i.test(W3.env.NODE_DEBUG) ? (...e19)=>console.error("SEMVER", ...e19)
 : ()=>{
};
var Y3 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
}, J3 = t3(function(e19, t13) {
    const { MAX_SAFE_COMPONENT_LENGTH: n8  } = Y3, r6 = (t13 = e19.exports = {
    }).re = [], s5 = t13.src = [], i6 = t13.t = {
    };
    let o5 = 0;
    const a5 = (e20, t14, n9)=>{
        const a6 = o5++;
        Q4(a6, t14), i6[e20] = a6, s5[a6] = t14, r6[a6] = new RegExp(t14, n9 ? "g" : void 0);
    };
    a5("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a5("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a5("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a5("MAINVERSION", "(".concat(s5[i6.NUMERICIDENTIFIER], ")\\.") + "(".concat(s5[i6.NUMERICIDENTIFIER], ")\\.") + "(".concat(s5[i6.NUMERICIDENTIFIER], ")")), a5("MAINVERSIONLOOSE", "(".concat(s5[i6.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s5[i6.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s5[i6.NUMERICIDENTIFIERLOOSE], ")")), a5("PRERELEASEIDENTIFIER", "(?:".concat(s5[i6.NUMERICIDENTIFIER], "|").concat(s5[i6.NONNUMERICIDENTIFIER], ")")), a5("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(s5[i6.NUMERICIDENTIFIERLOOSE], "|").concat(s5[i6.NONNUMERICIDENTIFIER], ")")), a5("PRERELEASE", "(?:-(".concat(s5[i6.PRERELEASEIDENTIFIER], "(?:\\.").concat(s5[i6.PRERELEASEIDENTIFIER], ")*))")), a5("PRERELEASELOOSE", "(?:-?(".concat(s5[i6.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(s5[i6.PRERELEASEIDENTIFIERLOOSE], ")*))")), a5("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a5("BUILD", "(?:\\+(".concat(s5[i6.BUILDIDENTIFIER], "(?:\\.").concat(s5[i6.BUILDIDENTIFIER], ")*))")), a5("FULLPLAIN", "v?".concat(s5[i6.MAINVERSION]).concat(s5[i6.PRERELEASE], "?").concat(s5[i6.BUILD], "?")), a5("FULL", "^".concat(s5[i6.FULLPLAIN], "$")), a5("LOOSEPLAIN", "[v=\\s]*".concat(s5[i6.MAINVERSIONLOOSE]).concat(s5[i6.PRERELEASELOOSE], "?").concat(s5[i6.BUILD], "?")), a5("LOOSE", "^".concat(s5[i6.LOOSEPLAIN], "$")), a5("GTLT", "((?:<|>)?=?)"), a5("XRANGEIDENTIFIERLOOSE", "".concat(s5[i6.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a5("XRANGEIDENTIFIER", "".concat(s5[i6.NUMERICIDENTIFIER], "|x|X|\\*")), a5("XRANGEPLAIN", "[v=\\s]*(".concat(s5[i6.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s5[i6.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s5[i6.XRANGEIDENTIFIER], ")") + "(?:".concat(s5[i6.PRERELEASE], ")?").concat(s5[i6.BUILD], "?") + ")?)?"), a5("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(s5[i6.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s5[i6.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s5[i6.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(s5[i6.PRERELEASELOOSE], ")?").concat(s5[i6.BUILD], "?") + ")?)?"), a5("XRANGE", "^".concat(s5[i6.GTLT], "\\s*").concat(s5[i6.XRANGEPLAIN], "$")), a5("XRANGELOOSE", "^".concat(s5[i6.GTLT], "\\s*").concat(s5[i6.XRANGEPLAINLOOSE], "$")), a5("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n8, "})") + "(?:\\.(\\d{1,".concat(n8, "}))?") + "(?:\\.(\\d{1,".concat(n8, "}))?") + "(?:$|[^\\d])"), a5("COERCERTL", s5[i6.COERCE], !0), a5("LONETILDE", "(?:~>?)"), a5("TILDETRIM", "(\\s*)".concat(s5[i6.LONETILDE], "\\s+"), !0), t13.tildeTrimReplace = "$1~", a5("TILDE", "^".concat(s5[i6.LONETILDE]).concat(s5[i6.XRANGEPLAIN], "$")), a5("TILDELOOSE", "^".concat(s5[i6.LONETILDE]).concat(s5[i6.XRANGEPLAINLOOSE], "$")), a5("LONECARET", "(?:\\^)"), a5("CARETTRIM", "(\\s*)".concat(s5[i6.LONECARET], "\\s+"), !0), t13.caretTrimReplace = "$1^", a5("CARET", "^".concat(s5[i6.LONECARET]).concat(s5[i6.XRANGEPLAIN], "$")), a5("CARETLOOSE", "^".concat(s5[i6.LONECARET]).concat(s5[i6.XRANGEPLAINLOOSE], "$")), a5("COMPARATORLOOSE", "^".concat(s5[i6.GTLT], "\\s*(").concat(s5[i6.LOOSEPLAIN], ")$|^$")), a5("COMPARATOR", "^".concat(s5[i6.GTLT], "\\s*(").concat(s5[i6.FULLPLAIN], ")$|^$")), a5("COMPARATORTRIM", "(\\s*)".concat(s5[i6.GTLT], "\\s*(").concat(s5[i6.LOOSEPLAIN], "|").concat(s5[i6.XRANGEPLAIN], ")"), !0), t13.comparatorTrimReplace = "$1$2$3", a5("HYPHENRANGE", "^\\s*(".concat(s5[i6.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(s5[i6.XRANGEPLAIN], ")") + "\\s*$"), a5("HYPHENRANGELOOSE", "^\\s*(".concat(s5[i6.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(s5[i6.XRANGEPLAINLOOSE], ")") + "\\s*$"), a5("STAR", "(<|>)?=?\\s*\\*"), a5("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a5("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: te3 , MAX_SAFE_INTEGER: ne4  } = Y3, { re: re3 , t: se3  } = J3, { compareIdentifiers: ie3  } = ee1;
class oe3 {
    constructor(e19, t13){
        if (t13 && "object" == typeof t13 || (t13 = {
            loose: !!t13,
            includePrerelease: !1
        }), e19 instanceof oe3) {
            if (e19.loose === !!t13.loose && e19.includePrerelease === !!t13.includePrerelease) return e19;
            e19 = e19.version;
        } else if ("string" != typeof e19) throw new TypeError("Invalid Version: ".concat(e19));
        if (e19.length > te3) throw new TypeError("version is longer than ".concat(te3, " characters"));
        Q4("SemVer", e19, t13), this.options = t13, this.loose = !!t13.loose, this.includePrerelease = !!t13.includePrerelease;
        const n8 = e19.trim().match(t13.loose ? re3[se3.LOOSE] : re3[se3.FULL]);
        if (!n8) throw new TypeError("Invalid Version: ".concat(e19));
        if (this.raw = e19, this.major = +n8[1], this.minor = +n8[2], this.patch = +n8[3], this.major > ne4 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > ne4 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > ne4 || this.patch < 0) throw new TypeError("Invalid patch version");
        n8[4] ? this.prerelease = n8[4].split(".").map((e20)=>{
            if (/^[0-9]+$/.test(e20)) {
                const t14 = +e20;
                if (t14 >= 0 && t14 < ne4) return t14;
            }
            return e20;
        }) : this.prerelease = [], this.build = n8[5] ? n8[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(e) {
        if (Q4("SemVer.compare", this.version, this.options, e), !(e instanceof oe3)) {
            if ("string" == typeof e && e === this.version) return 0;
            e = new oe3(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
        return e instanceof oe3 || (e = new oe3(e, this.options)), ie3(this.major, e.major) || ie3(this.minor, e.minor) || ie3(this.patch, e.patch);
    }
    comparePre(e) {
        if (e instanceof oe3 || (e = new oe3(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t14 = 0;
        do {
            const n9 = this.prerelease[t14], r6 = e.prerelease[t14];
            if (Q4("prerelease compare", t14, n9, r6), (void 0) === n9 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === n9) return -1;
            if (n9 !== r6) return ie3(n9, r6);
        }while (++t14)
    }
    compareBuild(e) {
        e instanceof oe3 || (e = new oe3(e, this.options));
        let t14 = 0;
        do {
            const n9 = this.build[t14], r6 = e.build[t14];
            if (Q4("prerelease compare", t14, n9, r6), (void 0) === n9 && (void 0) === r6) return 0;
            if ((void 0) === r6) return 1;
            if ((void 0) === n9) return -1;
            if (n9 !== r6) return ie3(n9, r6);
        }while (++t14)
    }
    inc(e, t) {
        switch(e){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let e20 = this.prerelease.length;
                    for(; (--e20) >= 0;)"number" == typeof this.prerelease[e20] && (this.prerelease[e20]++, e20 = -2);
                    -1 === e20 && this.prerelease.push(0);
                }
                t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    t,
                    0
                ]) : this.prerelease = [
                    t,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(e));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var ae3 = oe3;
var ue3 = (e20, t14, n9)=>new ae3(e20, n9).compare(new ae3(t14, n9))
;
var ce4 = (e20, t14, n9)=>ue3(e20, t14, n9) < 0
;
var le2 = (e20, t14, n9)=>ue3(e20, t14, n9) >= 0
, pe3 = "2.2.1", De3 = t3(function(e20, t14) {
    function n9() {
        for(var e21 = [], t15 = 0; t15 < arguments.length; t15++)e21[t15] = arguments[t15];
    }
    function r6() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: n9,
            delete: n9,
            get: n9,
            set: n9,
            has: function(e21) {
                return !1;
            }
        };
    }
    Object.defineProperty(t14, "__esModule", {
        value: !0
    });
    var s5 = Object.prototype.hasOwnProperty, i6 = function(e21, t15) {
        return s5.call(e21, t15);
    };
    function o5(e21, t15) {
        for(var n10 in t15)i6(t15, n10) && (e21[n10] = t15[n10]);
        return e21;
    }
    var a5 = /^[ \t]*(?:\r\n|\r|\n)/, u4 = /(?:\r\n|\r|\n)[ \t]*$/, c6 = /^(?:[\r\n]|$)/, l5 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p6 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function D5(e21, t15, n10) {
        var r7 = 0, s6 = e21[0].match(l5);
        s6 && (r7 = s6[1].length);
        var i7 = new RegExp("(\\r\\n|\\r|\\n).{0," + r7 + "}", "g");
        t15 && (e21 = e21.slice(1));
        var o6 = n10.newline, c7 = n10.trimLeadingNewline, p7 = n10.trimTrailingNewline, D5 = "string" == typeof o6, h5 = e21.length;
        return e21.map(function(e22, t16) {
            return (e22 = e22.replace(i7, "$1"), 0 === t16 && c7 && (e22 = e22.replace(a5, "")), t16 === h5 - 1 && p7 && (e22 = e22.replace(u4, "")), D5 && (e22 = e22.replace(/\r\n|\n|\r/g, function(e23) {
                return o6;
            })), e22);
        });
    }
    function h5(e21, t15) {
        for(var n10 = "", r7 = 0, s6 = e21.length; r7 < s6; r7++)n10 += e21[r7], r7 < s6 - 1 && (n10 += t15[r7]);
        return n10;
    }
    function d6(e21) {
        return i6(e21, "raw") && i6(e21, "length");
    }
    var f5 = function e20(t15) {
        var n10 = r6(), s6 = r6();
        return o5(function r7(i7) {
            for(var a6 = [], u5 = 1; u5 < arguments.length; u5++)a6[u5 - 1] = arguments[u5];
            if (d6(i7)) {
                var l6 = i7, m5 = (a6[0] === r7 || a6[0] === f5) && p6.test(l6[0]) && c6.test(l6[1]), g6 = m5 ? s6 : n10, E5 = g6.get(l6);
                if ((E5 || (E5 = D5(l6, m5, t15), g6.set(l6, E5)), 0 === a6.length)) return E5[0];
                var C5 = h5(E5, m5 ? a6.slice(1) : a6);
                return C5;
            }
            return e20(o5(o5({
            }, t15), i7 || {
            }));
        }, {
            string: function(e21) {
                return D5([
                    e21
                ], !1, t15)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    t14.outdent = f5, t14.default = f5;
    try {
        e20.exports = f5, Object.defineProperty(f5, "__esModule", {
            value: !0
        }), f5.default = f5, f5.outdent = f5;
    } catch (e) {
    }
});
const { outdent: Ce3  } = De3, Te2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(Ee1()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: Ce3(ge2())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (e20)=>"string" == typeof e20 || "function" == typeof e20
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (e20)=>"string" == typeof e20 || "object" == typeof e20
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: Ce3(me2()),
        exception: (e20)=>"string" == typeof e20 || "object" == typeof e20
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(fe2()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(de2()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: Ce3(he2()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const ye3 = {
    compare: ue3,
    lt: ce4,
    gte: le2
}, _e2 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: Te2
}.options;
var be3 = {
    getSupportInfo: function({ plugins: e20 = [] , showUnreleased: t14 = !1 , showDeprecated: n9 = !1 , showInternal: r6 = !1  } = {
    }) {
        const s5 = pe3.split("-", 1)[0], i6 = e20.reduce((e21, t15)=>e21.concat(t15.languages || [])
        , []).filter(a5), o5 = ((e21, t15)=>Object.entries(e21).map(([e22, n10])=>Object.assign({
                    [t15]: e22
                }, n10)
            )
        )(Object.assign({
        }, ...e20.map(({ options: e21  })=>e21
        ), _e2), "name").filter((e21)=>a5(e21) && u4(e21)
        ).sort((e21, t15)=>e21.name === t15.name ? 0 : e21.name < t15.name ? -1 : 1
        ).map(function(e21) {
            if (r6) return e21;
            return function(e22, t15) {
                if (null == e22) return {
                };
                var n10, r7, s6 = {
                }, i7 = Object.keys(e22);
                for(r7 = 0; r7 < i7.length; r7++)n10 = i7[r7], t15.indexOf(n10) >= 0 || (s6[n10] = e22[n10]);
                return s6;
            }(e21, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((t15)=>{
            t15 = Object.assign({
            }, t15), Array.isArray(t15.default) && (t15.default = 1 === t15.default.length ? t15.default[0].value : t15.default.filter(a5).sort((e21, t16)=>ye3.compare(t16.since, e21.since)
            )[0].value), Array.isArray(t15.choices) && (t15.choices = t15.choices.filter((e21)=>a5(e21) && u4(e21)
            ), "parser" === t15.name && (function(e21, t16, n10) {
                const r7 = new Set(e21.choices.map((e22)=>e22.value
                ));
                for (const s6 of t16)if (s6.parsers) for (const t17 of s6.parsers)if (!r7.has(t17)) {
                    r7.add(t17);
                    const i7 = n10.find((e22)=>e22.parsers && e22.parsers[t17]
                    );
                    let o6 = s6.name;
                    i7 && i7.name && (o6 += " (plugin: ".concat(i7.name, ")")), e21.choices.push({
                        value: t17,
                        description: o6
                    });
                }
            })(t15, i6, e20));
            const n10 = e20.filter((e21)=>e21.defaultOptions && (void 0) !== e21.defaultOptions[t15.name]
            ).reduce((e21, n11)=>(e21[n11.name] = n11.defaultOptions[t15.name], e21)
            , {
            });
            return Object.assign({
            }, t15, {
                pluginDefaults: n10
            });
        });
        return {
            languages: i6,
            options: o5
        };
        function a5(e21) {
            return t14 || !("since" in e21) || e21.since && ye3.gte(s5, e21.since);
        }
        function u4(e21) {
            return n9 || !("deprecated" in e21) || e21.deprecated && ye3.lt(s5, e21.deprecated);
        }
    }
};
const { getSupportInfo: Fe2  } = be3, Ae2 = /[^\x20-\x7F]/;
var Ve2 = {
    inferParserByLanguage: function(e20, t14) {
        const { languages: n9  } = Fe2({
            plugins: t14.plugins
        }), r6 = n9.find(({ name: t15  })=>t15.toLowerCase() === e20
        ) || n9.find(({ aliases: t15  })=>Array.isArray(t15) && t15.includes(e20)
        ) || n9.find(({ extensions: t15  })=>Array.isArray(t15) && t15.includes(".".concat(e20))
        );
        return r6 && r6.parsers[0];
    },
    replaceEndOfLineWith: function(e20, t14) {
        const n9 = [];
        for (const r6 of e20.split("\n"))0 !== n9.length && n9.push(t14), n9.push(r6);
        return n9;
    },
    getStringWidth: function(e20) {
        return e20 ? Ae2.test(e20) ? y3(e20) : e20.length : 0;
    },
    getMaxContinuousCount: function(e20, t14) {
        const n9 = e20.match(new RegExp("(".concat(a3(t14), ")+"), "g"));
        return null === n9 ? 0 : n9.reduce((e21, n10)=>Math.max(e21, n10.length / t14.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(e20, t14) {
        const n9 = e20.match(new RegExp("(".concat(a3(t14), ")+"), "g"));
        if (null === n9) return 0;
        const r6 = new Map;
        let s5 = 0;
        for (const e21 of n9){
            const n10 = e21.length / t14.length;
            r6.set(n10, !0), n10 > s5 && (s5 = n10);
        }
        for(let e22 = 1; e22 < s5; e22++)if (!r6.get(e22)) return e22;
        return s5 + 1;
    },
    getPenultimate: (e20)=>e20[e20.length - 2]
    ,
    getLast: (e20)=>e20[e20.length - 1]
    ,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ie1,
    getNextNonSpaceNonCommentCharacterIndex: qe2,
    getNextNonSpaceNonCommentCharacter: function(e20, t14, n9) {
        return e20.charAt(qe2(e20, t14, n9));
    },
    skip: ve2,
    skipWhitespace: we2,
    skipSpaces: ke2,
    skipToLineEnd: Ne2,
    skipEverythingButNewLine: xe1,
    skipInlineComment: Oe1,
    skipTrailingComment: Re1,
    skipNewline: Le2,
    isNextLineEmptyAfterIndex: Be2,
    isNextLineEmpty: function(e20, t14, n9) {
        return Be2(e20, n9(t14));
    },
    isPreviousLineEmpty: function(e20, t14, n9) {
        let r6 = n9(t14) - 1;
        return (r6 = ke2(e20, r6, {
            backwards: !0
        }), r6 = Le2(e20, r6, {
            backwards: !0
        }), r6 = ke2(e20, r6, {
            backwards: !0
        }), r6 !== Le2(e20, r6, {
            backwards: !0
        }));
    },
    hasNewline: Pe2,
    hasNewlineInRange: function(e20, t14, n9) {
        for(let r6 = t14; r6 < n9; ++r6)if ("\n" === e20.charAt(r6)) return !0;
        return !1;
    },
    hasSpaces: function(e20, t14, n9) {
        return ke2(e20, (n9 = n9 || {
        }).backwards ? t14 - 1 : t14, n9) !== t14;
    },
    getAlignmentSize: $e1,
    getIndentSize: function(e20, t14) {
        const n9 = e20.lastIndexOf("\n");
        return -1 === n9 ? 0 : $e1(e20.slice(n9 + 1).match(/^[\t ]*/)[0], t14);
    },
    getPreferredQuote: Me2,
    printString: function(e20, t14, n9) {
        const r6 = e20.slice(1, -1), s5 = !r6.includes('"') && !r6.includes("'"), i6 = "json" === t14.parser ? '"' : t14.__isInHtmlAttribute ? "'" : Me2(e20, t14.singleQuote ? "'" : '"');
        return n9 ? s5 ? i6 + r6 + i6 : e20 : Ue1(r6, i6, !("css" === t14.parser || "less" === t14.parser || "scss" === t14.parser || t14.embeddedInHtml));
    },
    printNumber: function(e20) {
        return e20.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(e20) {
        return "prettier-ignore" === e20.value.trim();
    },
    makeString: Ue1,
    addLeadingComment: function(e20, t14) {
        t14.leading = !0, t14.trailing = !1, Ge(e20, t14);
    },
    addDanglingComment: function(e20, t14, n9) {
        t14.leading = !1, t14.trailing = !1, n9 && (t14.marker = n9), Ge(e20, t14);
    },
    addTrailingComment: function(e20, t14) {
        t14.leading = !1, t14.trailing = !0, Ge(e20, t14);
    },
    isFrontMatterNode: function(e20) {
        return e20 && "front-matter" === e20.type;
    },
    getShebang: function(e20) {
        if (!e20.startsWith("#!")) return "";
        const t14 = e20.indexOf("\n");
        return -1 === t14 ? e20 : e20.slice(0, t14);
    }
};
const { getStringWidth: He2  } = Ve2, { convertEndOfLineToChars: Xe2  } = je2, { concat: ze2 , fill: We2 , cursor: Qe2  } = f3;
function tt2(e20, t14, n9, r6, s5) {
    let i6 = t14.length;
    const o5 = [
        e20
    ], a5 = [];
    for(; n9 >= 0;){
        if (0 === o5.length) {
            if (0 === i6) return !0;
            o5.push(t14[i6 - 1]), i6--;
            continue;
        }
        const [e21, u4, c6] = o5.pop();
        if ("string" == typeof c6) a5.push(c6), n9 -= He2(c6);
        else switch(c6.type){
            case "concat":
                for(let t15 = c6.parts.length - 1; t15 >= 0; t15--)o5.push([
                    e21,
                    u4,
                    c6.parts[t15]
                ]);
                break;
            case "indent":
                o5.push([
                    Je(e21, r6),
                    u4,
                    c6.contents
                ]);
                break;
            case "align":
                o5.push([
                    Ze(e21, c6.n, r6),
                    u4,
                    c6.contents
                ]);
                break;
            case "trim":
                n9 += et2(a5);
                break;
            case "group":
                if (s5 && c6.break) return !1;
                o5.push([
                    e21,
                    c6.break ? 1 : u4,
                    c6.contents
                ]), c6.id && (Ye[c6.id] = o5[o5.length - 1][1]);
                break;
            case "fill":
                for(let t16 = c6.parts.length - 1; t16 >= 0; t16--)o5.push([
                    e21,
                    u4,
                    c6.parts[t16]
                ]);
                break;
            case "if-break":
                {
                    const t17 = c6.groupId ? Ye[c6.groupId] : u4;
                    1 === t17 && c6.breakContents && o5.push([
                        e21,
                        u4,
                        c6.breakContents
                    ]), 2 === t17 && c6.flatContents && o5.push([
                        e21,
                        u4,
                        c6.flatContents
                    ]);
                    break;
                }
            case "line":
                switch(u4){
                    case 2:
                        if (!c6.hard) {
                            c6.soft || (a5.push(" "), n9 -= 1);
                            break;
                        }
                        return !0;
                    case 1:
                        return !0;
                }
        }
    }
    return !1;
}
var nt2 = {
    printDocToString: function(e20, t14) {
        Ye = {
        };
        const n9 = t14.printWidth, r6 = Xe2(t14.endOfLine);
        let s5 = 0;
        const i6 = [
            [
                {
                    value: "",
                    length: 0,
                    queue: []
                },
                1,
                e20
            ]
        ], o5 = [];
        let a5 = !1, u4 = [];
        for(; 0 !== i6.length;){
            const [e21, c6, l5] = i6.pop();
            if ("string" == typeof l5) {
                const e22 = "\n" !== r6 && l5.includes("\n") ? l5.replace(/\n/g, r6) : l5;
                o5.push(e22), s5 += He2(e22);
            } else switch(l5.type){
                case "cursor":
                    o5.push(Qe2.placeholder);
                    break;
                case "concat":
                    for(let t15 = l5.parts.length - 1; t15 >= 0; t15--)i6.push([
                        e21,
                        c6,
                        l5.parts[t15]
                    ]);
                    break;
                case "indent":
                    i6.push([
                        Je(e21, t14),
                        c6,
                        l5.contents
                    ]);
                    break;
                case "align":
                    i6.push([
                        Ze(e21, l5.n, t14),
                        c6,
                        l5.contents
                    ]);
                    break;
                case "trim":
                    s5 -= et2(o5);
                    break;
                case "group":
                    switch(c6){
                        case 2:
                            if (!a5) {
                                i6.push([
                                    e21,
                                    l5.break ? 1 : 2,
                                    l5.contents
                                ]);
                                break;
                            }
                        case 1:
                            {
                                a5 = !1;
                                const r7 = [
                                    e21,
                                    2,
                                    l5.contents
                                ], o6 = n9 - s5;
                                if (!l5.break && tt2(r7, i6, o6, t14)) i6.push(r7);
                                else if (l5.expandedStates) {
                                    const n10 = l5.expandedStates[l5.expandedStates.length - 1];
                                    if (l5.break) {
                                        i6.push([
                                            e21,
                                            1,
                                            n10
                                        ]);
                                        break;
                                    }
                                    for(let r8 = 1; r8 < l5.expandedStates.length + 1; r8++){
                                        if (r8 >= l5.expandedStates.length) {
                                            i6.push([
                                                e21,
                                                1,
                                                n10
                                            ]);
                                            break;
                                        }
                                        {
                                            const n11 = [
                                                e21,
                                                2,
                                                l5.expandedStates[r8]
                                            ];
                                            if (tt2(n11, i6, o6, t14)) {
                                                i6.push(n11);
                                                break;
                                            }
                                        }
                                    }
                                } else i6.push([
                                    e21,
                                    1,
                                    l5.contents
                                ]);
                                break;
                            }
                    }
                    l5.id && (Ye[l5.id] = i6[i6.length - 1][1]);
                    break;
                case "fill":
                    {
                        const r7 = n9 - s5, { parts: o6  } = l5;
                        if (0 === o6.length) break;
                        const [a6, u5] = o6, p6 = [
                            e21,
                            2,
                            a6
                        ], D5 = [
                            e21,
                            1,
                            a6
                        ], h5 = tt2(p6, [], r7, t14, !0);
                        if (1 === o6.length) {
                            h5 ? i6.push(p6) : i6.push(D5);
                            break;
                        }
                        const d6 = [
                            e21,
                            2,
                            u5
                        ], f5 = [
                            e21,
                            1,
                            u5
                        ];
                        if (2 === o6.length) {
                            h5 ? (i6.push(d6), i6.push(p6)) : (i6.push(f5), i6.push(D5));
                            break;
                        }
                        o6.splice(0, 2);
                        const m5 = [
                            e21,
                            c6,
                            We2(o6)
                        ], g6 = o6[0];
                        tt2([
                            e21,
                            2,
                            ze2([
                                a6,
                                u5,
                                g6
                            ])
                        ], [], r7, t14, !0) ? (i6.push(m5), i6.push(d6), i6.push(p6)) : h5 ? (i6.push(m5), i6.push(f5), i6.push(p6)) : (i6.push(m5), i6.push(f5), i6.push(D5));
                        break;
                    }
                case "if-break":
                    {
                        const t16 = l5.groupId ? Ye[l5.groupId] : c6;
                        1 === t16 && l5.breakContents && i6.push([
                            e21,
                            c6,
                            l5.breakContents
                        ]), 2 === t16 && l5.flatContents && i6.push([
                            e21,
                            c6,
                            l5.flatContents
                        ]);
                        break;
                    }
                case "line-suffix":
                    u4.push([
                        e21,
                        c6,
                        l5.contents
                    ]);
                    break;
                case "line-suffix-boundary":
                    u4.length > 0 && i6.push([
                        e21,
                        c6,
                        {
                            type: "line",
                            hard: !0
                        }
                    ]);
                    break;
                case "line":
                    switch(c6){
                        case 2:
                            if (!l5.hard) {
                                l5.soft || (o5.push(" "), s5 += 1);
                                break;
                            }
                            a5 = !0;
                        case 1:
                            if (u4.length) {
                                i6.push([
                                    e21,
                                    c6,
                                    l5
                                ]), i6.push(...u4.reverse()), u4 = [];
                                break;
                            }
                            l5.literal ? e21.root ? (o5.push(r6, e21.root.value), s5 = e21.root.length) : (o5.push(r6), s5 = 0) : (s5 -= et2(o5), o5.push(r6 + e21.value), s5 = e21.length);
                    }
            }
            0 === i6.length && u4.length && (i6.push(...u4.reverse()), u4 = []);
        }
        const c6 = o5.indexOf(Qe2.placeholder);
        if (-1 !== c6) {
            const e21 = o5.indexOf(Qe2.placeholder, c6 + 1), t15 = o5.slice(0, c6).join(""), n10 = o5.slice(c6 + 1, e21).join("");
            return {
                formatted: t15 + n10 + o5.slice(e21 + 1).join(""),
                cursorNodeStart: t15.length,
                cursorNodeText: n10
            };
        }
        return {
            formatted: o5.join("")
        };
    }
};
var mt2 = {
    builders: f3,
    printer: nt2,
    utils: {
        isEmpty: function(e20) {
            return "string" == typeof e20 && 0 === e20.length;
        },
        willBreak: function(e20) {
            return ut1(e20, lt, !1);
        },
        isLineNext: function(e20) {
            return ut1(e20, ct, !1);
        },
        traverseDoc: ot1,
        findInDoc: ut1,
        mapDoc: at1,
        propagateBreaks: function(e20) {
            const t14 = new Set, n9 = [];
            ot1(e20, function(e21) {
                if (("break-parent" === e21.type && pt(n9), "group" === e21.type)) {
                    if ((n9.push(e21), t14.has(e21))) return !1;
                    t14.add(e21);
                }
            }, function(e21) {
                if ("group" === e21.type) {
                    n9.pop().break && pt(n9);
                }
            }, !0);
        },
        removeLines: function(e20) {
            return at1(e20, Dt1);
        },
        stripTrailingHardline: function e20(t14, n9 = !1) {
            if ("concat" === t14.type && 0 !== t14.parts.length) {
                const r6 = n9 ? function(e21) {
                    let t15, { parts: n10  } = e21;
                    for(let r7 = e21.parts.length; r7 > 0 && !t15; r7--)t15 = n10[r7 - 1];
                    return "group" === t15.type && (n10 = t15.contents.parts), n10;
                }(t14) : t14.parts, s5 = r6[r6.length - 1];
                if ("concat" === s5.type) return 2 === s5.parts.length && s5.parts[0].hard && "break-parent" === s5.parts[1].type ? {
                    type: "concat",
                    parts: r6.slice(0, -1)
                } : {
                    type: "concat",
                    parts: t14.parts.slice(0, -1).concat(e20(s5))
                };
            }
            return t14;
        },
        normalizeParts: ht1,
        normalizeDoc: function(e21) {
            return at1(e21, (e22)=>e22.parts ? Object.assign({
                }, e22, {
                    parts: ht1(e22.parts)
                }) : e22
            );
        },
        replaceNewlinesWithLiterallines: function(e21) {
            return at1(e21, (e22)=>"string" == typeof e22 && e22.includes("\n") ? st1(e22.split(/(\n)/g).map((e23, t14)=>t14 % 2 == 0 ? e23 : rt2
                )) : e22
            );
        }
    },
    debug: {
        printDocToDebug: (e20)=>ft1(dt(e20))
    }
};
const { builders: { hardline: gt2 , concat: Et2 , markAsRoot: Ct2  }  } = mt2, Tt2 = {
    "---": "yaml",
    "+++": "toml"
};
var yt2 = {
    parse: function(e20) {
        const t14 = Object.keys(Tt2).map(a3).join("|"), n9 = e20.match(new RegExp("^(".concat(t14, ")([^\\n]*)\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));
        if (null === n9) return {
            frontMatter: null,
            content: e20
        };
        const [r6, s5, i6, o5] = n9;
        let u4 = Tt2[s5];
        return ("toml" !== u4 && i6 && i6.trim() && (u4 = i6.trim()), {
            frontMatter: {
                type: "front-matter",
                lang: u4,
                value: o5,
                raw: r6.replace(/\n$/, "")
            },
            content: r6.replace(/[^\n]/g, " ") + e20.slice(r6.length)
        });
    },
    print: function(e20, t14) {
        if ("yaml" === e20.lang) {
            const n9 = e20.value.trim(), r6 = n9 ? t14(n9, {
                parser: "yaml"
            }, {
                stripTrailingHardline: !0
            }) : "";
            return Ct2(Et2([
                "---",
                gt2,
                r6,
                r6 ? gt2 : "",
                "---"
            ]));
        }
    }
};
const { inferParserByLanguage: bt2 , isFrontMatterNode: Ft2  } = Ve2, { CSS_DISPLAY_TAGS: At2 , CSS_DISPLAY_DEFAULT: vt2 , CSS_WHITE_SPACE_TAGS: wt2 , CSS_WHITE_SPACE_DEFAULT: kt2  } = {
    CSS_DISPLAY_TAGS: {
        area: "none",
        base: "none",
        basefont: "none",
        datalist: "none",
        head: "none",
        link: "none",
        meta: "none",
        noembed: "none",
        noframes: "none",
        param: "block",
        rp: "none",
        script: "block",
        source: "block",
        style: "none",
        template: "inline",
        track: "block",
        title: "none",
        html: "block",
        body: "block",
        address: "block",
        blockquote: "block",
        center: "block",
        div: "block",
        figure: "block",
        figcaption: "block",
        footer: "block",
        form: "block",
        header: "block",
        hr: "block",
        legend: "block",
        listing: "block",
        main: "block",
        p: "block",
        plaintext: "block",
        pre: "block",
        xmp: "block",
        slot: "contents",
        ruby: "ruby",
        rt: "ruby-text",
        article: "block",
        aside: "block",
        h1: "block",
        h2: "block",
        h3: "block",
        h4: "block",
        h5: "block",
        h6: "block",
        hgroup: "block",
        nav: "block",
        section: "block",
        dir: "block",
        dd: "block",
        dl: "block",
        dt: "block",
        ol: "block",
        ul: "block",
        li: "list-item",
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell",
        fieldset: "block",
        button: "inline-block",
        details: "block",
        summary: "block",
        dialog: "block",
        meter: "inline-block",
        progress: "inline-block",
        object: "inline-block",
        video: "inline-block",
        audio: "inline-block",
        select: "inline-block",
        option: "block",
        optgroup: "block"
    },
    CSS_DISPLAY_DEFAULT: "inline",
    CSS_WHITE_SPACE_TAGS: {
        listing: "pre",
        plaintext: "pre",
        pre: "pre",
        xmp: "pre",
        nobr: "nowrap",
        table: "initial",
        textarea: "pre-wrap"
    },
    CSS_WHITE_SPACE_DEFAULT: "normal"
}, Nt2 = Lt1([
    "a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "command",
    "content",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "image",
    "img",
    "input",
    "ins",
    "isindex",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "math",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "multicol",
    "nav",
    "nextid",
    "nobr",
    "noembed",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "plaintext",
    "pre",
    "progress",
    "q",
    "rb",
    "rbc",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "slot",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "svg",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp"
]), xt2 = function(e20, t14) {
    const n9 = Object.create(null);
    for (const r6 of Object.keys(e20))n9[r6] = t14(e20[r6], r6);
    return n9;
}(_t, Lt1), Ot2 = new Set([
    "\t",
    "\n",
    "\f",
    "\r",
    " "
]), Rt2 = (e20)=>e20.replace(/[\t\n\f\r ]+$/, "")
;
function Pt2(e20, t14) {
    return !("ieConditionalComment" !== e20.type || !e20.lastChild || e20.lastChild.isSelfClosing || e20.lastChild.endSourceSpan) || ("ieConditionalComment" === e20.type && !e20.complete || (!(!zt3(e20) || !e20.children.some((e21)=>"text" !== e21.type && "interpolation" !== e21.type
    )) || !(!Kt2(e20, t14) || It(e20) || "interpolation" === e20.type)));
}
function qt3(e20) {
    return Qt3(e20).startsWith("pre");
}
function zt3(e20) {
    return Qt3(e20).startsWith("pre");
}
function Qt3(e20) {
    return "element" === e20.type && (!e20.namespace || Wt(e20)) && wt2[e20.name] || kt2;
}
var en1 = {
    HTML_ELEMENT_ATTRIBUTES: xt2,
    HTML_TAGS: Nt2,
    htmlTrim: (e20)=>((e21)=>e21.replace(/^[\t\n\f\r ]+/, "")
        )(Rt2(e20))
    ,
    htmlTrimPreserveIndentation: (e20)=>((e21)=>e21.replace(/^[\t\f\r ]*?\n/g, "")
        )(Rt2(e20))
    ,
    splitByHtmlWhitespace: (e20)=>e20.split(/[\t\n\f\r ]+/)
    ,
    hasHtmlWhitespace: (e20)=>/[\t\n\f\r ]/.test(e20)
    ,
    getLeadingAndTrailingHtmlWhitespace: (e20)=>{
        const [, t14, n9, r6] = e20.match(/^([\t\n\f\r ]*)([\S\s]*?)([\t\n\f\r ]*)$/);
        return {
            leadingWhitespace: t14,
            trailingWhitespace: r6,
            text: n9
        };
    },
    canHaveInterpolation: function(e20) {
        return e20.children && !It(e20);
    },
    countChars: function(e20, t14) {
        let n9 = 0;
        for(let r6 = 0; r6 < e20.length; r6++)e20[r6] === t14 && n9++;
        return n9;
    },
    countParents: function(e20, t14) {
        let n9 = 0;
        for(let r6 = e20.stack.length - 1; r6 >= 0; r6--){
            const s5 = e20.stack[r6];
            s5 && "object" == typeof s5 && !Array.isArray(s5) && t14(s5) && n9++;
        }
        return n9;
    },
    dedentString: function(e20, t14 = function(e21) {
        let t15 = 1 / 0;
        for (const r6 of e21.split("\n")){
            if (0 === r6.length) continue;
            if (!Ot2.has(r6[0])) return 0;
            const e22 = (n9 = r6, n9.match(/^[\t\n\f\r ]*/)[0]).length;
            r6.length !== e22 && e22 < t15 && (t15 = e22);
        }
        var n9;
        return t15 === 1 / 0 ? 0 : t15;
    }(e20)) {
        return 0 === t14 ? e20 : e20.split("\n").map((e21)=>e21.slice(t14)
        ).join("\n");
    },
    forceBreakChildren: $t2,
    forceBreakContent: function(e20) {
        return $t2(e20) || "element" === e20.type && 0 !== e20.children.length && ([
            "body",
            "script",
            "style"
        ].includes(e20.name) || e20.children.some((e21)=>(function(e22) {
                return e22.children && e22.children.some((e23)=>"text" !== e23.type
                );
            })(e21)
        )) || e20.firstChild && e20.firstChild === e20.lastChild && "text" !== e20.firstChild.type && Gt2(e20.firstChild) && (!e20.lastChild.isTrailingSpaceSensitive || Vt1(e20.lastChild));
    },
    forceNextEmptyLine: function(e20) {
        return Ft2(e20) || e20.next && e20.sourceSpan.end && e20.sourceSpan.end.line + 1 < e20.next.sourceSpan.start.line;
    },
    getLastDescendant: function e20(t14) {
        return t14.lastChild ? e20(t14.lastChild) : t14;
    },
    getNodeCssStyleDisplay: function(e21, t14) {
        if (e21.prev && "comment" === e21.prev.type) {
            const t15 = e21.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t15) return t15[1];
        }
        let n9 = !1;
        if ("element" === e21.type && "svg" === e21.namespace) {
            if (!function(e22, t15) {
                let n10 = e22;
                for(; n10;){
                    if (t15(n10)) return !0;
                    n10 = n10.parent;
                }
                return !1;
            }(e21, (e22)=>"svg:foreignObject" === e22.fullName
            )) return "svg" === e21.name ? "inline-block" : "block";
            n9 = !0;
        }
        switch(t14.htmlWhitespaceSensitivity){
            case "strict":
                return "inline";
            case "ignore":
                return "block";
            default:
                return "vue" === t14.parser && e21.parent && "root" === e21.parent.type ? "block" : "element" === e21.type && (!e21.namespace || n9 || Wt(e21)) && At2[e21.name] || vt2;
        }
    },
    getNodeCssStyleWhiteSpace: Qt3,
    getPrettierIgnoreAttributeCommentData: function(e21) {
        const t14 = e21.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);
        return !!t14 && (!t14[1] || t14[1].split(/\s+/));
    },
    hasPrettierIgnore: Bt2,
    inferScriptParser: function(e21, t14) {
        return "script" !== e21.name || e21.attrMap.src ? "style" === e21.name ? function(e22) {
            const { lang: t15  } = e22.attrMap;
            return t15 && "postcss" !== t15 && "css" !== t15 ? "scss" === t15 ? "scss" : "less" === t15 ? "less" : void 0 : "css";
        }(e21) : t14 && Kt2(e21, t14) ? Ht1(e21) || !("src" in e21.attrMap) && bt2(e21.attrMap.lang, t14) : void 0 : e21.attrMap.lang || e21.attrMap.type ? Ht1(e21) : "babel";
    },
    isVueCustomBlock: Jt2,
    isVueNonHtmlBlock: Kt2,
    isVueSlotAttribute: function(e21) {
        const t14 = e21.fullName;
        return "#" === t14.charAt(0) || "slot-scope" === t14 || "v-slot" === t14 || t14.startsWith("v-slot:");
    },
    isVueSfcBindingsAttribute: function(e21, t14) {
        const n9 = e21.parent;
        if (!Zt1(n9, t14)) return !1;
        const r6 = n9.fullName, s5 = e21.fullName;
        return "script" === r6 && "setup" === s5 || "style" === r6 && "vars" === s5;
    },
    isDanglingSpaceSensitiveNode: function(e21) {
        return !(t14 = e21.cssDisplay, Xt2(t14) || "inline-block" === t14 || It(e21));
        var t14;
    },
    isIndentationSensitiveNode: qt3,
    isLeadingSpaceSensitiveNode: function(e21, t14) {
        const n9 = function() {
            if (Ft2(e21)) return !1;
            if (("text" === e21.type || "interpolation" === e21.type) && e21.prev && ("text" === e21.prev.type || "interpolation" === e21.prev.type)) return !0;
            if (!e21.parent || "none" === e21.parent.cssDisplay) return !1;
            if (zt3(e21.parent)) return !0;
            if (!e21.prev && ("root" === e21.parent.type || zt3(e21) && e21.parent || It(e21.parent) || Jt2(e21.parent, t14) || (n9 = e21.parent.cssDisplay, Xt2(n9) || "inline-block" === n9))) return !1;
            var n9;
            if (e21.prev && !(function(e22) {
                return !Xt2(e22);
            })(e21.prev.cssDisplay)) return !1;
            return !0;
        }();
        return n9 && !e21.prev && e21.parent && e21.parent.tagDefinition && e21.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e21.type : n9;
    },
    isPreLikeNode: zt3,
    isScriptLikeTag: It,
    isTextLikeNode: function(e21) {
        return "text" === e21.type || "comment" === e21.type;
    },
    isTrailingSpaceSensitiveNode: function(e21, t14) {
        return !Ft2(e21) && (!("text" !== e21.type && "interpolation" !== e21.type || !e21.next || "text" !== e21.next.type && "interpolation" !== e21.next.type) || !(!e21.parent || "none" === e21.parent.cssDisplay) && (!!zt3(e21.parent) || !(!e21.next && ("root" === e21.parent.type || zt3(e21) && e21.parent || It(e21.parent) || Jt2(e21.parent, t14) || (n9 = e21.parent.cssDisplay, Xt2(n9) || "inline-block" === n9))) && !(e21.next && !function(e22) {
            return !Xt2(e22);
        }(e21.next.cssDisplay))));
        var n9;
    },
    isWhitespaceSensitiveNode: function(e21) {
        return It(e21) || "interpolation" === e21.type || qt3(e21);
    },
    isUnknownNamespace: Wt,
    preferHardlineAsLeadingSpaces: function(e21) {
        return jt1(e21) || e21.prev && Mt(e21.prev) || Ut1(e21);
    },
    preferHardlineAsTrailingSpaces: Mt,
    shouldNotPrintClosingTag: function(e21, t14) {
        return !e21.isSelfClosing && !e21.endSourceSpan && (Bt2(e21) || Pt2(e21.parent, t14));
    },
    shouldPreserveContent: Pt2,
    unescapeQuoteEntities: function(e21) {
        return e21.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
};
const { ParseSourceSpan: Sn1 , ParseLocation: _n1 , ParseSourceFile: bn1  } = o4, { parse: Fn1  } = yt2, { inferParserByLanguage: An1  } = Ve2, { HTML_ELEMENT_ATTRIBUTES: vn1 , HTML_TAGS: wn1 , isUnknownNamespace: kn1  } = en1, { hasPragma: Nn1  } = tn1, { Node: xn1  } = an1, { parseIeConditionalComment: On1  } = ln1, { locStart: Rn1 , locEnd: Ln1  } = pn;
function Pn1(e20, { recognizeSelfClosing: t14 , normalizeTagName: n9 , normalizeAttributeName: r6 , allowHtmComponentClosingTags: s5 , isTagNameCaseSensitive: i6 , getTagContentType: a5  }, u4) {
    const c6 = yn, { RecursiveVisitor: l5 , visitAll: p6 , Attribute: D5 , CDATA: h5 , Comment: d6 , DocType: f5 , Element: m5 , Text: g6  } = fn, { ParseSourceSpan: E5  } = o4, { getHtmlTagDefinition: C5  } = hn;
    let { rootNodes: T5 , errors: y6  } = yn.parse(e20, {
        canSelfClose: t14,
        allowHtmComponentClosingTags: s5,
        isTagNameCaseSensitive: i6,
        getTagContentType: a5
    });
    const S4 = "vue" === u4.parser && T5.some((e21)=>e21 instanceof f5 && "html" === e21.value || e21 instanceof m5 && "html" === e21.name.toLowerCase()
    );
    if ("vue" !== u4.parser || S4) {
        if (S4) {
            t14 = !0, n9 = !0, r6 = !0, s5 = !0, i6 = !1;
            const o5 = yn.parse(e20, {
                canSelfClose: t14,
                allowHtmComponentClosingTags: s5,
                isTagNameCaseSensitive: i6
            });
            T5 = o5.rootNodes, y6 = o5.errors;
        }
    } else {
        const n10 = (e21)=>{
            if (!e21) return !1;
            if ("template" !== e21.name) return !1;
            const t15 = e21.attrs.find((e22)=>"lang" === e22.name
            ), n11 = t15 && t15.value;
            return null == n11 || "html" === An1(n11, u4);
        };
        if (T5.some(n10)) {
            let r7;
            const o5 = ()=>yn.parse(e20, {
                    canSelfClose: t14,
                    allowHtmComponentClosingTags: s5,
                    isTagNameCaseSensitive: i6
                })
            , a6 = ()=>r7 || (r7 = o5())
            , u5 = (e21)=>a6().rootNodes.find(({ startSourceSpan: t15  })=>t15 && t15.start.offset === e21.startSourceSpan.start.offset
                )
            ;
            for(let e21 = 0; e21 < T5.length; e21++){
                const t15 = T5[e21], { endSourceSpan: r8 , startSourceSpan: s6  } = t15;
                if (null === r8) {
                    y6 = a6().errors, T5[e21] = u5(t15) || t15;
                } else if (n10(t15)) {
                    const n11 = a6(), i7 = s6.end.offset, o6 = r8.start.offset;
                    for (const e22 of n11.errors){
                        const { offset: t16  } = e22.span.start;
                        if (i7 < t16 && t16 < o6) {
                            y6 = [
                                e22
                            ];
                            break;
                        }
                    }
                    T5[e21] = u5(t15) || t15;
                }
            }
        }
    }
    if (0 !== y6.length) {
        const { msg: e21 , span: { start: t15 , end: n10  }  } = y6[0];
        throw St(e21, {
            start: {
                line: t15.line + 1,
                column: t15.col + 1
            },
            end: {
                line: n10.line + 1,
                column: n10.col + 1
            }
        });
    }
    const _4 = (e21)=>{
        const t15 = e21.name.startsWith(":") ? e21.name.slice(1).split(":")[0] : null, n10 = e21.nameSpan.toString(), r7 = n10.startsWith("".concat(t15, ":")), s6 = r7 ? n10.slice(t15.length + 1) : n10;
        e21.name = s6, e21.namespace = t15, e21.hasExplicitNamespace = r7;
    }, b4 = (e21, t15)=>{
        const n10 = e21.toLowerCase();
        return t15(n10) ? n10 : e21;
    };
    return p6(new class extends l5 {
        visit(e) {
            ((e21)=>{
                if (e21 instanceof D5) e21.type = "attribute";
                else if (e21 instanceof h5) e21.type = "cdata";
                else if (e21 instanceof d6) e21.type = "comment";
                else if (e21 instanceof f5) e21.type = "docType";
                else if (e21 instanceof m5) e21.type = "element";
                else {
                    if (!(e21 instanceof g6)) throw new Error("Unexpected node ".concat(JSON.stringify(e21)));
                    e21.type = "text";
                }
            })(e), ((e21)=>{
                e21 instanceof m5 ? (_4(e21), e21.attrs.forEach((e22)=>{
                    _4(e22), e22.valueSpan ? (e22.value = e22.valueSpan.toString(), /["']/.test(e22.value[0]) && (e22.value = e22.value.slice(1, -1))) : e22.value = null;
                })) : e21 instanceof d6 ? e21.value = e21.sourceSpan.toString().slice("\x3c!--".length, -"--\x3e".length) : e21 instanceof g6 && (e21.value = e21.sourceSpan.toString());
            })(e), ((e21)=>{
                if (e21 instanceof m5) {
                    const t15 = C5(i6 ? e21.name : e21.name.toLowerCase());
                    !e21.namespace || e21.namespace === t15.implicitNamespacePrefix || kn1(e21) ? e21.tagDefinition = t15 : e21.tagDefinition = C5("");
                }
            })(e), ((e21)=>{
                if (e21 instanceof m5 && (!n9 || e21.namespace && e21.namespace !== e21.tagDefinition.implicitNamespacePrefix && !kn1(e21) || (e21.name = b4(e21.name, (e22)=>e22 in wn1
                )), r6)) {
                    const t15 = vn1[e21.name] || Object.create(null);
                    e21.attrs.forEach((n10)=>{
                        n10.namespace || (n10.name = b4(n10.name, (n11)=>e21.name in vn1 && (n11 in vn1["*"] || n11 in t15)
                        ));
                    });
                }
            })(e), ((e21)=>{
                e21.sourceSpan && e21.endSourceSpan && (e21.sourceSpan = new E5(e21.sourceSpan.start, e21.endSourceSpan.end));
            })(e);
        }
    }, T5), T5;
}
function Bn1(e20, t14, n9, r6 = !0) {
    const { frontMatter: s5 , content: i6  } = r6 ? Fn1(e20) : {
        frontMatter: null,
        content: e20
    }, o5 = new bn1(e20, t14.filepath), a5 = new _n1(o5, 0, 0, 0), u4 = a5.moveBy(e20.length), c6 = {
        type: "root",
        sourceSpan: new Sn1(a5, u4),
        children: Pn1(i6, n9, t14)
    };
    if (s5) {
        const e21 = new _n1(o5, 0, 0, 0), t15 = e21.moveBy(s5.raw.length);
        s5.sourceSpan = new Sn1(e21, t15), c6.children.unshift(s5);
    }
    const l5 = new xn1(c6), p6 = (r7, s6)=>{
        const { offset: i7  } = s6, o6 = Bn1(e20.slice(0, i7).replace(/[^\n\r]/g, " ") + r7, t14, n9, !1);
        o6.sourceSpan = new Sn1(s6, o6.children[o6.children.length - 1].sourceSpan.end);
        const a6 = o6.children[0];
        return a6.length === i7 ? o6.children.shift() : (a6.sourceSpan = new Sn1(a6.sourceSpan.start.moveBy(i7), a6.sourceSpan.end), a6.value = a6.value.slice(i7)), o6;
    };
    return l5.map((e21)=>{
        if ("comment" === e21.type) {
            const t15 = On1(e21, p6);
            if (t15) return t15;
        }
        return e21;
    });
}
function In1({ recognizeSelfClosing: e20 = !1 , normalizeTagName: t14 = !1 , normalizeAttributeName: n9 = !1 , allowHtmComponentClosingTags: r6 = !1 , isTagNameCaseSensitive: s5 = !1 , getTagContentType: i6  } = {
}) {
    return {
        parse: (o5, a5, u4)=>Bn1(o5, u4, {
                recognizeSelfClosing: e20,
                normalizeTagName: t14,
                normalizeAttributeName: n9,
                allowHtmComponentClosingTags: r6,
                isTagNameCaseSensitive: s5,
                getTagContentType: i6
            })
        ,
        hasPragma: Nn1,
        astFormat: "html",
        locStart: Rn1,
        locEnd: Ln1
    };
}
var qn1 = {
    parsers: {
        html: In1({
            recognizeSelfClosing: !0,
            normalizeTagName: !0,
            normalizeAttributeName: !0,
            allowHtmComponentClosingTags: !0
        }),
        angular: In1(),
        vue: In1({
            recognizeSelfClosing: !0,
            isTagNameCaseSensitive: !0,
            getTagContentType: (e20, t14, n9, r6)=>{
                if ("html" !== e20.toLowerCase() && !n9 && ("template" !== e20 || r6.some(({ name: e21 , value: t15  })=>"lang" === e21 && "html" !== t15
                ))) return yn.TagContentType.RAW_TEXT;
            }
        }),
        lwc: In1()
    }
};
var processStyleValue = function processStyleValue2(key, value) {
    switch(key){
        case "animation":
        case "animationName":
            {
                if (typeof value === "string") {
                    return value.replace(animationRegex, function(match, p11, p21) {
                        cursor = {
                            name: p11,
                            styles: p21,
                            next: cursor
                        };
                        return p11;
                    });
                }
            }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
    }
    return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
        return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
    }
    switch(typeof interpolation){
        case "boolean":
            {
                return "";
            }
        case "object":
            {
                if (interpolation.anim === 1) {
                    cursor = {
                        name: interpolation.name,
                        styles: interpolation.styles,
                        next: cursor
                    };
                    return interpolation.name;
                }
                if (interpolation.styles !== void 0) {
                    var next = interpolation.next;
                    if (next !== void 0) {
                        while(next !== void 0){
                            cursor = {
                                name: next.name,
                                styles: next.styles,
                                next: cursor
                            };
                            next = next.next;
                        }
                    }
                    var styles = interpolation.styles + ";";
                    return styles;
                }
                return createStringFromObject(mergedProps, registered, interpolation);
            }
        case "function":
            {
                if (mergedProps !== void 0) {
                    var previousCursor = cursor;
                    var result = interpolation(mergedProps);
                    cursor = previousCursor;
                    return handleInterpolation(mergedProps, registered, result);
                }
                break;
            }
    }
    if (registered == null) {
        return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
        for(var i6 = 0; i6 < obj.length; i6++){
            string += handleInterpolation(mergedProps, registered, obj[i6]) + ";";
        }
    } else {
        for(var _key in obj){
            var value = obj[_key];
            if (typeof value !== "object") {
                if (registered != null && registered[value] !== void 0) {
                    string += _key + "{" + registered[value] + "}";
                } else if (isProcessableValue(value)) {
                    string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
                }
            } else {
                if (_key === "NO_COMPONENT_SELECTOR" && false) {
                    throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
                }
                if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
                    for(var _i1 = 0; _i1 < value.length; _i1++){
                        if (isProcessableValue(value[_i1])) {
                            string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i1]) + ";";
                        }
                    }
                } else {
                    var interpolated = handleInterpolation(mergedProps, registered, value);
                    switch(_key){
                        case "animation":
                        case "animationName":
                            {
                                string += processStyleName(_key) + ":" + interpolated + ";";
                                break;
                            }
                        default:
                            {
                                string += _key + "{" + interpolated + "}";
                            }
                    }
                }
            }
        }
    }
    return string;
}
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
    } else {
        styles += strings[0];
    }
    for(var i6 = 1; i6 < args.length; i6++){
        styles += handleInterpolation(mergedProps, registered, args[i6]);
        if (stringMode) {
            styles += strings[i6];
        }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match;
    while((match = labelPattern.exec(styles)) !== null){
        identifierName += "-" + match[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
        name,
        styles,
        next: cursor
    };
};
var Emotion = withEmotionCache(function(props, cache2, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
        cssProp = cache2.registered[cssProp];
    }
    var type = props[typePropName];
    var registeredStyles = [
        cssProp
    ];
    var className = "";
    if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
        className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, typeof cssProp === "function" || Array.isArray(cssProp) ? useContext(ThemeContext) : void 0);
    var rules = insertStyles(cache2, serialized, typeof type === "string");
    className += cache2.key + "-" + serialized.name;
    var newProps = {
    };
    for(var key in props){
        if (hasOwnProperty1.call(props, key) && key !== "css" && key !== typePropName && true) {
            newProps[key] = props[key];
        }
    }
    newProps.ref = ref;
    newProps.className = className;
    var ele = createElement(type, newProps);
    return ele;
});
function css() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return serializeStyles(args);
}
async function transpileCode(code, hasToReport) {
    transform = transform || await init();
    return await transform(code, hasToReport);
}
async function getIpfsiD() {
    if (node) return node;
    let ipfsId = await shaDB2.get("ipfs");
    if (!ipfsId) {
        ipfsId = v4();
        await shaDB2.put("ipfs", ipfsId);
    }
    return ipfsId;
}
function init() {
    const worker = new Worker("./src/transpile.worker.js");
    transform = wrap3(worker);
    return transform;
}
init();
async function getZkey(hash) {
    const uuid = await getUserId();
    const uKey = await sha256(uuid);
    const gKey = await sha256(hash + uKey);
    const vKey = await sha256(hash + uuid);
    return `${hash}${uKey}${gKey}${vKey}`;
}
async function getUserId() {
    const uuid = await shaDB3.get("uuid");
    if (!uuid) {
        const resp = await fetch("https://code.zed.vision/register");
        const data = await resp.json();
        await shaDB3.put("uuid", data.uuid);
        return data.uuid;
    }
    return uuid;
}
const getProjects1 = async ()=>{
    const uuid = await getUserId();
    const projects = await shaDB3.get(uuid, "json");
    if (typeof projects === "string" || projects === null || !projects.list) {
        const projectId = v41();
        await shaDB3.put(uuid, JSON.stringify({
            list: [
                projectId
            ],
            [projectId]: {
                created: Date.now(),
                lastOpen: Date.now()
            }
        }));
        return [
            projectId
        ];
    }
    return projects.list;
};
const saveCode1 = async (code)=>{
    const hash = await sha256(code);
    const projects = await getProjects1();
    const projectName = projects[0];
    try {
        const prevHash = await shaDB3.get(projectName);
        if (prevHash !== hash) {
            await shaDB3.put(hash, code);
            await shaDB3.put(projectName, hash);
        }
    } catch (e) {
        console.error(e);
    }
};
const ipfsKV = {
    add: async (data)=>(ipfsWorker || await initIpfsKV()).add(data)
};
function initIpfsKV() {
    const worker = new Worker("./src/ipfsKV.worker.js");
    ipfsWorker = wrap3(worker);
    return ipfsWorker;
}
initIpfsKV();
const shareItAsHtml = async ({ code , HTML , jsExport  })=>{
    const mod = createJsBlob(code);
    const Element2 = (await import(mod)).default;
    const css1 = Array.from(window.document.querySelector("head > style[data-emotion=css]").sheet.cssRules).map((x6)=>x6.cssText
    ).filter((cssRule)=>HTML.includes(cssRule.substring(3, 8))
    ).join("\n  ");
    const { getHtml , getCodeForImport  } = await import("./templates.js");
    const linkToCode = await saveToIPFS(code, "application/html");
    console.log({
        HTML,
        linkToCode,
        css: css1,
        code
    });
    const link = await saveHtml(getHtml({
        HTML,
        css: css1,
        js: getCodeForImport(linkToCode)
    }));
    return link;
};
function saveHtml(html) {
    return saveToIPFS(html, "text/html");
}
async function saveToIPFS(content, type) {
    const cid = await ipfsKV.add(URL.createObjectURL(new Blob([
        content
    ], {
        type
    })));
    return `https://ipfs.io/ipfs/${cid}`;
}
async function save(content, type) {
    const hash = await sha256(content);
    const request = new Request("https://code.zed.vision", {
        body: content,
        method: "POST",
        headers: {
            "Content-Type": type + ";charset=UTF-8",
            "ZKEY": await getZkey(hash)
        }
    });
    await fetch(request);
    return `https://code.zed.vision/${hash}`;
}
function formatter(code) {
    try {
        return zB.format(code, {
            "arrowParens": "always",
            "bracketSpacing": true,
            "embeddedLanguageFormatting": "auto",
            "htmlWhitespaceSensitivity": "css",
            "insertPragma": false,
            "jsxBracketSameLine": true,
            "jsxSingleQuote": false,
            "printWidth": 80,
            "proseWrap": "preserve",
            "quoteProps": "as-needed",
            "requirePragma": false,
            "semi": true,
            "singleQuote": true,
            "tabWidth": 2,
            "trailingComma": "all",
            "useTabs": false,
            parser: "babel-ts",
            plugins: [
                er1,
                qn1
            ]
        });
    } catch  {
        return code;
    }
}
export async function run(mode = "window", _w1) {
    console.log("Runner");
    const { document , React , ReactDOM , emotionReactJSXRuntime , location , open  } = _w1;
    const { jsx  } = emotionReactJSXRuntime;
    const session = getSession();
    session.code = formatter(await getCodeToLoad());
    session.transpiled = await transpileCode(session.code);
    if (mode === "editor") {
        const { renderDraggableEditor  } = await import("./DraggableEditor.js");
        await renderDraggableEditor();
    }
    if (mode === "window") {
        const onShare = async ()=>{
            const link = await shareItAsHtml({
                code: session.transpiled,
                HTML: session.HTML
            });
            open(link);
        };
        await __default1({
            ReactDOM,
            React,
            jsx,
            onShare
        });
    }
    const transpiled = await transpileCode(session.code);
    restartCode(transpiled);
    const modules = await __default({
        language: "typescript",
        code: formatter(session.code),
        onChange: (c6)=>runner(formatter(c6))
    });
    async function runner(cd1) {
        try {
            const transpiled1 = await transpileCode(cd1, session.lastErrors);
            if (session.transpiled === transpiled1) return;
            let restartError = false;
            if (transpiled1.length && session.lastErrors === 0) {
                restartError = restartCode(transpiled1);
            }
            const err = [
                ...restartError ? [
                    {
                        messageText: "Error while starting the app. Check the console!"
                    }, 
                ] : [],
                ...await getErrors(cd1), 
            ];
            if (session.lastErrors && err.length === 0) restartCode(transpiled1);
            session.lastErrors = err.length;
            const errorDiv = document.getElementById("error");
            if (err.length === 0 && transpiled1.length) {
                session.code = cd1;
                if (session.transpiled !== transpiled1) {
                    session.transpiled = transpiled1;
                    await saveCode2(formatter(cd1), session.transpiled);
                }
                await saveCode2(cd1);
            } else {
                session.error = cd1;
                const slices = await diff(session.code, cd1);
                if (slices.c.length <= 3) {
                    session.lastErrors = 0;
                    return;
                }
                if (slices.c.length == 4) {
                    session.lastErrors = 0;
                    modules.monaco.editor.setTheme("hc-black");
                    return;
                }
                errorDiv.innerHTML = err[0].messageText.toString();
                errorDiv.style.display = "block";
                return;
            }
            errorDiv.style.display = "none";
            modules.monaco.editor.setTheme("vs-dark");
        } catch (err) {
            modules.monaco.editor.setTheme("vs-light");
            setTimeout(()=>{
                modules.monaco.editor.setTheme("hc-black");
            }, 50);
            console.error(err);
        }
    }
    async function getErrors(code) {
        if (!modules || !modules.monaco) return;
        const { monaco  } = modules;
        const { sha256: sha2561  } = await import("./sha256.js");
        const shaCode = await sha2561(code);
        const filename = `file:///${shaCode}.tsx`;
        const uri = monaco.Uri.parse(filename);
        const model = monaco.editor.getModel(uri) || await monaco.editor.createModel(code, "typescript", uri);
        const worker = await monaco.languages.typescript.getTypeScriptWorker();
        const client = await worker(model.uri);
        const diag = client.getSemanticDiagnostics(filename);
        const comp = client.getCompilerOptionsDiagnostics(filename);
        const syntax = client.getSyntacticDiagnostics(filename);
        const fastError = await Promise.race([
            diag,
            comp,
            syntax
        ]);
        model.dispose();
        return [
            ...fastError, 
        ];
    }
    async function restartCode(transpiled1) {
        if (typeof transpiled1 !== "string" || transpiled1 === "") {
            return 1;
        }
        const codeToHydrate = mode === "window" ? transpiled1.replace("body{", "#zbody{") : transpiled1;
        const root = document.createElement("div");
        const Element2 = (await import(createJsBlob(codeToHydrate))).default;
        ReactDOM.render(Element2(), root);
        document.getElementById("zbody").removeChild();
        document.getElementById("zbody").appendChild(root);
        session.HTML = root.innerHTML;
        return !session.preRendered;
    }
    async function getCodeToLoad() {
        const projects = await getProjects2();
        const projectName = projects[0];
        const search = new URLSearchParams(location.search);
        const keyToLoad = search.get("h") || await shaDB1.get(projectName);
        if (keyToLoad) {
            let code;
            try {
                code = await shaDB1.get(keyToLoad);
            } catch  {
                console.error("error load key: " + keyToLoad);
            }
            if (code) return code;
            let text;
            try {
                const resp = await fetch("https://code.zed.vision/?h=" + keyToLoad);
                text = await resp.json();
            } catch (e) {
                const { sha256: sha2561  } = await import("./sha256.js");
                const shaHash = await sha2561(starter);
                shaDB1.put(shaHash, starter);
                await shaDB1.put(projectName, shaHash);
                return starter;
            }
            return text;
        }
        return starter;
    }
    function setQueryStringParameter(name, value) {
        const params = new URLSearchParams(window.location.search);
        params.set(name, value);
        window.history.replaceState({
        }, "", decodeURIComponent(`${window.location.pathname}?${params}`));
    }
}
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = ()=>{
            resolve(wrap1(request.result));
            unlisten();
        };
        const error = ()=>{
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise.then((value)=>{
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
    }).catch(()=>{
    });
    reverseTransformCache.set(promise, request);
    return promise;
}
let idbProxyTraps = {
    get (target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            if (prop === 'done') return transactionDoneMap.get(target);
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            if (prop === 'store') {
                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        return wrap1(target[prop]);
    },
    set (target, prop, value) {
        target[prop] = value;
        return true;
    },
    has (target, prop) {
        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    }
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
        return function(storeNames, ...args) {
            const tx1 = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx1, storeNames.sort ? storeNames.sort() : [
                storeNames
            ]);
            return wrap1(tx1);
        };
    }
    if (getCursorAdvanceMethods().includes(func)) {
        return function(...args) {
            func.apply(unwrap(this), args);
            return wrap1(cursorRequestMap.get(this));
        };
    }
    return function(...args) {
        return wrap1(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function') return wrapFunction(value);
    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
    return value;
}
function wrap1(value) {
    if (value instanceof IDBRequest) return promisifyRequest(value);
    if (transformCache.has(value)) return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
function openDB(name, version, { blocked , upgrade , blocking , terminated  } = {
}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap1(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event)=>{
            upgrade(wrap1(request.result), event.oldVersion, event.newVersion, wrap1(request.transaction));
        });
    }
    if (blocked) request.addEventListener('blocked', ()=>blocked()
    );
    openPromise.then((db2)=>{
        if (terminated) db2.addEventListener('close', ()=>terminated()
        );
        if (blocking) db2.addEventListener('versionchange', ()=>blocking()
        );
    }).catch(()=>{
    });
    return openPromise;
}
replaceTraps((oldTraps)=>({
        ...oldTraps,
        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver)
        ,
        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)
    })
);
function getDB() {
    const dbPromise = openDB("localZedCodeStore", 1, {
        upgrade (db) {
            db.createObjectStore("codeStore");
        },
        blocked () {
        },
        blocking () {
        },
        terminated () {
        }
    });
    return getDbObj(dbPromise, true);
}
const shaDB = {
    get: async (...args)=>{
        db1 = db1 || await getDB();
        return db1.get(...args);
    },
    put: async (...args)=>{
        db1 = db1 || await getDB();
        return db1.put(...args);
    }
};
const proxyTransferHandler = {
    canHandle: (val)=>isObject(val) && val[proxyMarker]
    ,
    serialize (obj) {
        const { port1 , port2  } = new MessageChannel();
        expose(obj, port1);
        return [
            port2,
            [
                port2
            ]
        ];
    },
    deserialize (port) {
        port.start();
        return wrap2(port);
    }
};
const transferHandlers = new Map([
    [
        "proxy",
        proxyTransferHandler
    ],
    [
        "throw",
        throwTransferHandler
    ], 
]);
function expose(obj, ep1 = self) {
    ep1.addEventListener("message", function callback(ev1) {
        if (!ev1 || !ev1.data) {
            return;
        }
        const { id: id1 , type , path  } = Object.assign({
            path: []
        }, ev1.data);
        const argumentList = (ev1.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj1, prop)=>obj1[prop]
            , obj);
            const rawValue = path.reduce((obj1, prop)=>obj1[prop]
            , obj);
            switch(type){
                case 0:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case 1:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev1.data.value);
                        returnValue = true;
                    }
                    break;
                case 2:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case 3:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case 4:
                    {
                        const { port1 , port2  } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [
                            port1
                        ]);
                    }
                    break;
                case 5:
                    {
                        returnValue = undefined;
                    }
                    break;
            }
        } catch (value) {
            returnValue = {
                value,
                [throwMarker]: 0
            };
        }
        Promise.resolve(returnValue).catch((value)=>{
            return {
                value,
                [throwMarker]: 0
            };
        }).then((returnValue1)=>{
            const [wireValue, transferables] = toWireValue(returnValue1);
            ep1.postMessage(Object.assign(Object.assign({
            }, wireValue), {
                id: id1
            }), transferables);
            if (type === 5) {
                ep1.removeEventListener("message", callback);
                closeEndPoint(ep1);
            }
        });
    });
    if (ep1.start) {
        ep1.start();
    }
}
function wrap2(ep1, target) {
    return createProxy(ep1, [], target);
}
function createProxy(ep1, path = [], target = function() {
}) {
    let isProxyReleased = false;
    const proxy1 = new Proxy(target, {
        get (_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return ()=>{
                    return requestResponseMessage(ep1, {
                        type: 5,
                        path: path.map((p6)=>p6.toString()
                        )
                    }).then(()=>{
                        closeEndPoint(ep1);
                        isProxyReleased = true;
                    });
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return {
                        then: ()=>proxy1
                    };
                }
                const r6 = requestResponseMessage(ep1, {
                    type: 0,
                    path: path.map((p6)=>p6.toString()
                    )
                }).then(fromWireValue);
                return r6.then.bind(r6);
            }
            return createProxy(ep1, [
                ...path,
                prop
            ]);
        },
        set (_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep1, {
                type: 1,
                path: [
                    ...path,
                    prop
                ].map((p6)=>p6.toString()
                ),
                value
            }, transferables).then(fromWireValue);
        },
        apply (_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep1, {
                    type: 4
                }).then(fromWireValue);
            }
            if (last === "bind") {
                return createProxy(ep1, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep1, {
                type: 2,
                path: path.map((p6)=>p6.toString()
                ),
                argumentList
            }, transferables).then(fromWireValue);
        },
        construct (_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep1, {
                type: 3,
                path: path.map((p6)=>p6.toString()
                ),
                argumentList
            }, transferables).then(fromWireValue);
        }
    });
    return proxy1;
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [
        processed.map((v5)=>v5[0]
        ),
        myFlat(processed.map((v5)=>v5[1]
        ))
    ];
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers){
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: 3,
                    name,
                    value: serializedValue
                },
                transferables, 
            ];
        }
    }
    return [
        {
            type: 0,
            value
        },
        transferCache.get(value) || [], 
    ];
}
function fromWireValue(value) {
    switch(value.type){
        case 3:
            return transferHandlers.get(value.name).deserialize(value.value);
        case 0:
            return value.value;
    }
}
const wrap3 = wrap2;
class lu {
    constructor(e20){
        return cu(e20);
    }
}
const getProjects2 = getProjects1;
const saveCode2 = saveCode1;
const shaDB1 = shaDB;
const shaDB2 = shaDB;
const shaDB3 = shaDB;

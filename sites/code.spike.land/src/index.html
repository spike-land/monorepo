<!DOCTYPE html>
<html lang="en">
<head profile="http://www.w3.org/2005/10/profile">
  <meta http-equiv="Content-Type" content="text/html,charset=utf-8" />
  <meta name="viewport" content="width=device-width">
  <link rel="preload" href="https://unpkg.com/monaco-editor@0.30.1/min/vs/editor/editor.main.js" as="script" />
  <link rel="icon" type="image/png" href="@VERSION/assets/zed-icon-big.png" />
  <link rel="stylesheet" href="@VERSION/assets/app.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch_uncompressed.js" integrity="sha512-nvDKZefgrUzFIvEHMqag0VFPe6QYOVKGP9e40yCfbY+nOeSzSxzoFSUj1D6Mpc5r5UZzQISujUWDNhwReIyRzA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <title>Instant React Editor</title>
  <style>
    body{
      background-image: url(./assets/synthwave.webp);
    }
			body {
				margin: 0;
				padding: 0;
				border: 0;
			}
    
     @font-face {
      font-family: 'codicon';
      src: url('https://unpkg.com/monaco-editor@0.30.1/min/vs/base/browser/ui/codicons/codicon/codicon.ttf')
        format('truetype');
    }
		
  </style>
		<link
			data-name="vs/editor/editor.main"
			rel="stylesheet"
			href="https://unpkg.com/monaco-editor@0.30.1/min/vs/editor/editor.main.css"
		/>
</head>
<body>
  <script async src="https://unpkg.com/es-module-shims@1.3.2/dist/es-module-shims.js"></script>
  <script type="importmap">
    $$IMPORTMAP
  </script>
  <script type="module">
    import app from "app";
    app()
  </script>
  <script type="text/javascript">
 (async () => {
  let currentWebSocket = null;

  const chCode = (code) => {
    try {
      window.starterCode = code;
      const { monaco } = window;
      if (!monaco || !monaco.Uri) return;
      const modelUri = monaco.Uri.parse(`file:///main.tsx`);
      const model = monaco.editor.getModel(modelUri);
      const oldCode = model.getValue();

      if (oldCode !== code) {
        console.log({ oldCode });

        model.setValue(code);
      }
    } catch (e) {
      console.error({ e });
    }
  };

  let hostname = window.location.host;
  if (hostname == "") {
    // Probably testing the HTML locally.
    hostname = "code.spike.land";
  }

  let roomName = "ROOMagain";
  let username = "Pisti" + Math.random();
  let lastSeenTimestamp = 0;
  let lastSeenCode = "";

  function join() {
    let ws = new WebSocket(
      "wss://" + hostname + "/api/room/" + roomName + "/websocket",
    );
    let rejoined = false;
    let startTime = Date.now();

    let rejoin = async () => {
      if (!rejoined) {
        rejoined = true;
        currentWebSocket = null;

        // Clear the roster.
        //  while (roster.firstChild) {
        //   roster.removeChild(roster.firstChild);
        //    }

        // Don't try to reconnect too rapidly.
        let timeSinceLastJoin = Date.now() - startTime;
        if (timeSinceLastJoin < 10000) {
          // Less than 10 seconds elapsed since last join. Pause a bit.
          await new Promise((resolve) =>
            setTimeout(resolve, 10000 - timeSinceLastJoin)
          );
        }

        // OK, reconnect now!
        join();
      }
    };

    ws.addEventListener("open", (event) => {
      console.log("connected");
      currentWebSocket = ws;
      window.chCode = chCode;
      window.broad = async (
        { code, hashOfCode, starterCode, hashOfStarterCode },
      ) => {
        console.log(code, hashOfCode);
        if (code !== lastSeenCode) {
          let difference;

          if (window.starterCode) {
            if (window.starterCode !== starterCode) {
              throw new Error(
                "window.starterCode !== starterCode",
                starterCode,
                window.starterCode,
              );
            }
            try {
              const dmp = new diff_match_patch();

              const patches = dmp.patch_make(window.starterCode, code);
              difference = dmp.patch_toText(patches);
              console.log(difference);
            } catch (e) {
              console.error({ e });
            }
          }

          const message = { hashOfCode };
          if (difference) {
            message.difference = difference;
            message.hashOfCode = hashOfCode,
            message.hashOfStarterCode = hashOfStarterCode;
            window[hashOfCode] = code;

            window.starterCode = starterCode;
          }
          if (!window.starterCode || !lastSeenCode) {
            console.error("NO STARTER-CODE");
            throw new Error("NO STARTER CODE");
          }

          currentWebSocket.send(JSON.stringify(message));
        }
      };

      // Send user info message.
      ws.send(JSON.stringify({ name: username }));
    });

    ws.addEventListener("message", (event) => {
      try {
        let data = JSON.parse(event.data);
        if (data.code && data.hashOfCode) {
          lastSeenCode = data.code;
          window[data.hashOfCode] = data.code;
          if (!window.starterCode) window.starterCode = data.code;
          window.hashOfCode = data.hashOfCode;
          window.starterCode = lastSeenCode;
        }
        if (data.hashOfCode && !data.code){
          if (window[data.hashOfCode]) {
            window.starterCode = window[data.hashOfCode];
            lastSeenCode = window.starterCode;
          }
        }

        // A regular chat message.
        if (data.timestamp > lastSeenTimestamp) {
          if (data.code && data.hashOfCode) {
            lastSeenCode = data.code;
            window.hashOfCode = data.hashOfCode;
            window.starterCode = lastSeenCode;
          } else if (
            (data.message === "undefined" || !data.message) &&
            data.message !== lastSeenCode && data.name !== username
          ) {
            if (
              data.difference
            ) {

              if (window[data.hashOfCode]){
                if (window[data.hashOfCode] !== window.starterCode){
                  lastSeenCode = window[data.hashOfCode];
                } 
              } else {


                const dmp = new diff_match_patch();
                const patches = dmp.patch_fromText(data.difference);
                const patched = dmp.patch_apply(patches, lastSeenCode);

                if (patched[0]) lastSeenCode = patched[0];
              }

              // const newLastSeen = window.assemble(lastSeenCode, JSON.stringify(data.difference.c));
              // console.log("AASSEMBLED", newLastSeen);
            }
          }

          if (lastSeenCode && lastSeenCode !== window.starterCode) {
            window.starterCode = lastSeenCode;
            window.hashOfCode = data.hashOfCode;
            if (data.username !== username) chCode(lastSeenCode);
          }
        }
        // addChatMessage(data.name, data.message);
        lastSeenTimestamp = data.timestamp;
      } catch (e) {
        console.error({ e });
      }
    });

    ws.addEventListener("close", (event) => {
      console.log("WebSocket closed, reconnecting:", event.code, event.reason);
      rejoin();
    });
    ws.addEventListener("error", (event) => {
      console.log("WebSocket error, reconnecting:", event);
      rejoin();
    });
  }

  console.log("hello hello2");
  join();
})();

    /**************/
  </script>
</body>
</html>

const sha256 = async (s) =>
  Array.from(
    new Uint8Array(
      await crypto.subtle.digest(
        "SHA-256",
        typeof s == "string" ? new TextEncoder().encode(s) : s,
      ),
    ).slice(0, 4),
  ).map((u) => ("00" + u.toString(16)).slice(-2)).join("");
(function (s, u) {
  typeof exports == "object" && typeof module != "undefined"
    ? u(exports)
    : typeof define == "function" && define.amd
    ? define(["exports"], u)
    : (s = s || self, u(s.Diff = {}));
})(this, function (s) {
  "use strict";
  function u() {}
  u.prototype = {
    diff: function (e, n) {
      var t = arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : {},
        r = t.callback;
      typeof t == "function" && (r = t, t = {}), this.options = t;
      var a = this;
      function o(k) {
        return r
          ? (setTimeout(function () {
            r(void 0, k);
          }, 0),
            !0)
          : k;
      }
      e = this.castInput(e),
        n = this.castInput(n),
        e = this.removeEmpty(this.tokenize(e)),
        n = this.removeEmpty(this.tokenize(n));
      var l = n.length,
        f = e.length,
        c = 1,
        d = l + f,
        m = [{ newPos: -1, components: [] }],
        b = this.extractCommon(m[0], n, e, 0);
      if (m[0].newPos + 1 >= l && b + 1 >= f) {
        return o([{ value: this.join(n), count: n.length }]);
      }
      function p() {
        for (var k = -1 * c; k <= c; k += 2) {
          var x = void 0,
            I = m[k - 1],
            F = m[k + 1],
            A = (F ? F.newPos : 0) - k;
          I && (m[k - 1] = void 0);
          var C = I && I.newPos + 1 < l, K = F && 0 <= A && A < f;
          if (!C && !K) {
            m[k] = void 0;
            continue;
          }
          if (
            !C || K && I.newPos < F.newPos
              ? (x = y(F), a.pushComponent(x.components, void 0, !0))
              : (x = I, x.newPos++, a.pushComponent(x.components, !0, void 0)),
              A = a.extractCommon(x, n, e, k),
              x.newPos + 1 >= l && A + 1 >= f
          ) {
            return o(w(a, x.components, n, e, a.useLongestToken));
          }
          m[k] = x;
        }
        c++;
      }
      if (r) {
        (function k() {
          setTimeout(function () {
            if (c > d) return r();
            p() || k();
          }, 0);
        })();
      } else {
        for (; c <= d;) {
          var L = p();
          if (L) return L;
        }
      }
    },
    pushComponent: function (e, n, t) {
      var r = e[e.length - 1];
      r && r.added === n && r.removed === t
        ? e[e.length - 1] = { count: r.count + 1, added: n, removed: t }
        : e.push({ count: 1, added: n, removed: t });
    },
    extractCommon: function (e, n, t, r) {
      for (
        var a = n.length, o = t.length, l = e.newPos, f = l - r, c = 0;
        l + 1 < a && f + 1 < o && this.equals(n[l + 1], t[f + 1]);
      ) {
        l++, f++, c++;
      }
      return c && e.components.push({ count: c }), e.newPos = l, f;
    },
    equals: function (e, n) {
      return this.options.comparator
        ? this.options.comparator(e, n)
        : e === n ||
          this.options.ignoreCase && e.toLowerCase() === n.toLowerCase();
    },
    removeEmpty: function (e) {
      for (var n = [], t = 0; t < e.length; t++) e[t] && n.push(e[t]);
      return n;
    },
    castInput: function (e) {
      return e;
    },
    tokenize: function (e) {
      return e.split("");
    },
    join: function (e) {
      return e.join("");
    },
  };
  function w(e, n, t, r, a) {
    for (var o = 0, l = n.length, f = 0, c = 0; o < l; o++) {
      var d = n[o];
      if (d.removed) {
        if (
          d.value = e.join(r.slice(c, c + d.count)),
            c += d.count,
            o && n[o - 1].added
        ) {
          var m = n[o - 1];
          n[o - 1] = n[o], n[o] = m;
        }
      } else {
        if (!d.added && a) {
          var b = t.slice(f, f + d.count);
          b = b.map(function (L, k) {
            var x = r[c + k];
            return x.length > L.length ? x : L;
          }), d.value = e.join(b);
        } else d.value = e.join(t.slice(f, f + d.count));
        f += d.count, d.added || (c += d.count);
      }
    }
    var p = n[l - 1];
    return l > 1 && typeof p.value == "string" && (p.added || p.removed) &&
      e.equals("", p.value) && (n[l - 2].value += p.value, n.pop()),
      n;
  }
  function y(e) {
    return { newPos: e.newPos, components: e.components.slice(0) };
  }
  var h = new u();
  function S(e, n, t) {
    return h.diff(e, n, t);
  }
  function N(e, n) {
    if (typeof e == "function") n.callback = e;
    else if (e) for (var t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
    return n;
  }
  var H = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,
    v = /\S/,
    g = new u();
  g.equals = function (e, n) {
    return this.options.ignoreCase &&
      (e = e.toLowerCase(), n = n.toLowerCase()),
      e === n || this.options.ignoreWhitespace && !v.test(e) && !v.test(n);
  },
    g.tokenize = function (e) {
      for (
        var n = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), t = 0;
        t < n.length - 1;
        t++
      ) {
        !n[t + 1] && n[t + 2] && H.test(n[t]) && H.test(n[t + 2]) &&
          (n[t] += n[t + 2], n.splice(t + 1, 2), t--);
      }
      return n;
    };
  function O(e, n, t) {
    return t = N(t, { ignoreWhitespace: !0 }), g.diff(e, n, t);
  }
  function P(e, n, t) {
    return g.diff(e, n, t);
  }
  var T = new u();
  T.tokenize = function (e) {
    var n = [], t = e.split(/(\n|\r\n)/);
    t[t.length - 1] || t.pop();
    for (var r = 0; r < t.length; r++) {
      var a = t[r];
      r % 2 && !this.options.newlineIsToken
        ? n[n.length - 1] += a
        : (this.options.ignoreWhitespace && (a = a.trim()), n.push(a));
    }
    return n;
  };
  function $(e, n, t) {
    return T.diff(e, n, t);
  }
  function R(e, n, t) {
    var r = N(t, { ignoreWhitespace: !0 });
    return T.diff(e, n, r);
  }
  var j = new u();
  j.tokenize = function (e) {
    return e.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
  function W(e, n, t) {
    return j.diff(e, n, t);
  }
  var B = new u();
  B.tokenize = function (e) {
    return e.split(/([{}:;,]|\s+)/);
  };
  function Q(e, n, t) {
    return B.diff(e, n, t);
  }
  function G(e) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? G = function (n) {
        return typeof n;
      }
      : G = function (n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol &&
            n !== Symbol.prototype
          ? "symbol"
          : typeof n;
      },
      G(e);
  }
  function D(e) {
    return He(e) || Fe(e) || Ae(e) || Ce();
  }
  function He(e) {
    if (Array.isArray(e)) return ae(e);
  }
  function Fe(e) {
    if (
      typeof Symbol != "undefined" && Symbol.iterator in Object(e)
    ) {
      return Array.from(e);
    }
  }
  function Ae(e, n) {
    if (!e) return;
    if (typeof e == "string") return ae(e, n);
    var t = Object.prototype.toString.call(e).slice(8, -1);
    if (
      t === "Object" && e.constructor && (t = e.constructor.name),
        t === "Map" || t === "Set"
    ) {
      return Array.from(e);
    }
    if (
      t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
    ) {
      return ae(e, n);
    }
  }
  function ae(e, n) {
    (n == null || n > e.length) && (n = e.length);
    for (var t = 0, r = new Array(n); t < n; t++) r[t] = e[t];
    return r;
  }
  function Ce() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var Oe = Object.prototype.toString, q = new u();
  q.useLongestToken = !0,
    q.tokenize = T.tokenize,
    q.castInput = function (e) {
      var n = this.options,
        t = n.undefinedReplacement,
        r = n.stringifyReplacer,
        a = r === void 0
          ? function (o, l) {
            return typeof l == "undefined" ? t : l;
          }
          : r;
      return typeof e == "string"
        ? e
        : JSON.stringify(ee(e, null, null, a), a, "  ");
    },
    q.equals = function (e, n) {
      return u.prototype.equals.call(
        q,
        e.replace(/,([\r\n])/g, "$1"),
        n.replace(/,([\r\n])/g, "$1"),
      );
    };
  function je(e, n, t) {
    return q.diff(e, n, t);
  }
  function ee(e, n, t, r, a) {
    n = n || [], t = t || [], r && (e = r(a, e));
    var o;
    for (o = 0; o < n.length; o += 1) if (n[o] === e) return t[o];
    var l;
    if (Oe.call(e) === "[object Array]") {
      for (
        n.push(e), l = new Array(e.length), t.push(l), o = 0;
        o < e.length;
        o += 1
      ) {
        l[o] = ee(e[o], n, t, r, a);
      }
      return n.pop(), t.pop(), l;
    }
    if (e && e.toJSON && (e = e.toJSON()), G(e) === "object" && e !== null) {
      n.push(e), l = {}, t.push(l);
      var f = [], c;
      for (c in e) e.hasOwnProperty(c) && f.push(c);
      for (f.sort(), o = 0; o < f.length; o += 1) {
        c = f[o], l[c] = ee(e[c], n, t, r, c);
      }
      n.pop(), t.pop();
    } else l = e;
    return l;
  }
  var ne = new u();
  ne.tokenize = function (e) {
    return e.slice();
  },
    ne.join = ne.removeEmpty = function (e) {
      return e;
    };
  function Pe(e, n, t) {
    return ne.diff(e, n, t);
  }
  function te(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      t = e.split(/\r\n|[\n\v\f\r\x85]/),
      r = e.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      a = [],
      o = 0;
    function l() {
      var d = {};
      for (a.push(d); o < t.length;) {
        var m = t[o];
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(m)) break;
        var b = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(m);
        b && (d.index = b[1]), o++;
      }
      for (f(d), f(d), d.hunks = []; o < t.length;) {
        var p = t[o];
        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(p)) break;
        if (/^@@/.test(p)) d.hunks.push(c());
        else {
          if (p && n.strict) {
            throw new Error(
              "Unknown line " + (o + 1) + " " + JSON.stringify(p),
            );
          }
          o++;
        }
      }
    }
    function f(d) {
      var m = /^(---|\+\+\+)\s+(.*)$/.exec(t[o]);
      if (m) {
        var b = m[1] === "---" ? "old" : "new",
          p = m[2].split("	", 2),
          L = p[0].replace(/\\\\/g, "\\");
        /^".*"$/.test(L) && (L = L.substr(1, L.length - 2)),
          d[b + "FileName"] = L,
          d[b + "Header"] = (p[1] || "").trim(),
          o++;
      }
    }
    function c() {
      var d = o,
        m = t[o++],
        b = m.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/),
        p = {
          oldStart: +b[1],
          oldLines: typeof b[2] == "undefined" ? 1 : +b[2],
          newStart: +b[3],
          newLines: typeof b[4] == "undefined" ? 1 : +b[4],
          lines: [],
          linedelimiters: [],
        };
      p.oldLines === 0 && (p.oldStart += 1),
        p.newLines === 0 && (p.newStart += 1);
      for (
        var L = 0, k = 0;
        o < t.length &&
        !(t[o].indexOf("--- ") === 0 && o + 2 < t.length &&
          t[o + 1].indexOf("+++ ") === 0 && t[o + 2].indexOf("@@") === 0);
        o++
      ) {
        var x = t[o].length == 0 && o != t.length - 1 ? " " : t[o][0];
        if (x === "+" || x === "-" || x === " " || x === "\\") {
          p.lines.push(t[o]),
            p.linedelimiters.push(
              r[o] || `
`,
            ),
            x === "+" ? L++ : x === "-"
              ? k++
              : x === " " && (L++, k++);
        } else break;
      }
      if (
        !L && p.newLines === 1 && (p.newLines = 0),
          !k && p.oldLines === 1 && (p.oldLines = 0),
          n.strict
      ) {
        if (L !== p.newLines) {
          throw new Error(
            "Added line count did not match for hunk at line " + (d + 1),
          );
        }
        if (k !== p.oldLines) {
          throw new Error(
            "Removed line count did not match for hunk at line " + (d + 1),
          );
        }
      }
      return p;
    }
    for (; o < t.length;) l();
    return a;
  }
  function Te(e, n, t) {
    var r = !0, a = !1, o = !1, l = 1;
    return function f() {
      if (r && !o) {
        if (a ? l++ : r = !1, e + l <= t) return l;
        o = !0;
      }
      if (!a) return o || (r = !0), n <= e - l ? -l++ : (a = !0, f());
    };
  }
  function ge(e, n) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof n == "string" && (n = te(n)), Array.isArray(n)) {
      if (n.length > 1) {throw new Error(
          "applyPatch only works with a single input.",
        );}
      n = n[0];
    }
    var r = e.split(/\r\n|[\n\v\f\r\x85]/),
      a = e.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      o = n.hunks,
      l = t.compareLine || function (pe, Z, se, _) {
        return Z === _;
      },
      f = 0,
      c = t.fuzzFactor || 0,
      d = 0,
      m = 0,
      b,
      p;
    function L(pe, Z) {
      for (var se = 0; se < pe.lines.length; se++) {
        var _ = pe.lines[se],
          he = _.length > 0 ? _[0] : " ",
          We = _.length > 0 ? _.substr(1) : _;
        if (he === " " || he === "-") {
          if (!l(Z + 1, r[Z], he, We) && (f++, f > c)) return !1;
          Z++;
        }
      }
      return !0;
    }
    for (var k = 0; k < o.length; k++) {
      for (
        var x = o[k],
          I = r.length - x.oldLines,
          F = 0,
          A = m + x.oldStart - 1,
          C = Te(A, d, I);
        F !== void 0;
        F = C()
      ) {
        if (L(x, A + F)) {
          x.offset = m += F;
          break;
        }
      }
      if (F === void 0) return !1;
      d = x.offset + x.oldStart + x.oldLines;
    }
    for (var K = 0, X = 0; X < o.length; X++) {
      var E = o[X], J = E.oldStart + E.offset + K - 1;
      K += E.newLines - E.oldLines;
      for (var U = 0; U < E.lines.length; U++) {
        var M = E.lines[U],
          V = M.length > 0 ? M[0] : " ",
          de = M.length > 0 ? M.substr(1) : M,
          ie = E.linedelimiters[U];
        if (V === " ") J++;
        else if (V === "-") r.splice(J, 1), a.splice(J, 1);
        else if (V === "+") r.splice(J, 0, de), a.splice(J, 0, ie), J++;
        else if (V === "\\") {
          var oe = E.lines[U - 1] ? E.lines[U - 1][0] : null;
          oe === "+" ? b = !0 : oe === "-" && (p = !0);
        }
      }
    }
    if (b) for (; !r[r.length - 1];) r.pop(), a.pop();
    else {
      p && (r.push(""),
        a.push(`
`));
    }
    for (var Y = 0; Y < r.length - 1; Y++) r[Y] = r[Y] + a[Y];
    return r.join("");
  }
  function Ee(e, n) {
    typeof e == "string" && (e = te(e));
    var t = 0;
    function r() {
      var a = e[t++];
      if (!a) return n.complete();
      n.loadFile(a, function (o, l) {
        if (o) return n.complete(o);
        var f = ge(l, a, n);
        n.patched(a, f, function (c) {
          if (c) return n.complete(c);
          r();
        });
      });
    }
    r();
  }
  function le(e, n, t, r, a, o, l) {
    l || (l = {}), typeof l.context == "undefined" && (l.context = 4);
    var f = $(t, r, l);
    f.push({ value: "", lines: [] });
    function c(F) {
      return F.map(function (A) {
        return " " + A;
      });
    }
    for (
      var d = [],
        m = 0,
        b = 0,
        p = [],
        L = 1,
        k = 1,
        x = function (F) {
          var A = f[F],
            C = A.lines || A.value.replace(/\n$/, "").split(`
`);
          if (A.lines = C, A.added || A.removed) {
            var K;
            if (!m) {
              var X = f[F - 1];
              m = L,
                b = k,
                X &&
                (p = l.context > 0 ? c(X.lines.slice(-l.context)) : [],
                  m -= p.length,
                  b -= p.length);
            }
            (K = p).push.apply(
              K,
              D(C.map(function (oe) {
                return (A.added ? "+" : "-") + oe;
              })),
            ), A.added ? k += C.length : L += C.length;
          } else {
            if (m) {
              if (C.length <= l.context * 2 && F < f.length - 2) {
                var E;
                (E = p).push.apply(E, D(c(C)));
              } else {
                var J, U = Math.min(C.length, l.context);
                (J = p).push.apply(J, D(c(C.slice(0, U))));
                var M = {
                  oldStart: m,
                  oldLines: L - m + U,
                  newStart: b,
                  newLines: k - b + U,
                  lines: p,
                };
                if (F >= f.length - 2 && C.length <= l.context) {
                  var V = /\n$/.test(t),
                    de = /\n$/.test(r),
                    ie = C.length == 0 && p.length > M.oldLines;
                  !V && ie && t.length > 0 &&
                  p.splice(M.oldLines, 0, "\\ No newline at end of file"),
                    (!V && !ie || !de) &&
                    p.push("\\ No newline at end of file");
                }
                d.push(M), m = 0, b = 0, p = [];
              }
            }
            L += C.length, k += C.length;
          }
        },
        I = 0;
      I < f.length;
      I++
    ) {
      x(I);
    }
    return {
      oldFileName: e,
      newFileName: n,
      oldHeader: a,
      newHeader: o,
      hunks: d,
    };
  }
  function Ie(e) {
    var n = [];
    e.oldFileName == e.newFileName && n.push("Index: " + e.oldFileName),
      n.push(
        "===================================================================",
      ),
      n.push(
        "--- " + e.oldFileName +
          (typeof e.oldHeader == "undefined" ? "" : "	" + e.oldHeader),
      ),
      n.push(
        "+++ " + e.newFileName +
          (typeof e.newHeader == "undefined" ? "" : "	" + e.newHeader),
      );
    for (var t = 0; t < e.hunks.length; t++) {
      var r = e.hunks[t];
      r.oldLines === 0 && (r.oldStart -= 1),
        r.newLines === 0 && (r.newStart -= 1),
        n.push(
          "@@ -" + r.oldStart + "," + r.oldLines + " +" + r.newStart + "," +
            r.newLines + " @@",
        ),
        n.push.apply(n, r.lines);
    }
    return n.join(`
`) + `
`;
  }
  function we(e, n, t, r, a, o, l) {
    return Ie(le(e, n, t, r, a, o, l));
  }
  function Re(e, n, t, r, a, o) {
    return we(e, e, n, t, r, a, o);
  }
  function De(e, n) {
    return e.length !== n.length ? !1 : ue(e, n);
  }
  function ue(e, n) {
    if (n.length > e.length) return !1;
    for (var t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1;
    return !0;
  }
  function Ue(e) {
    var n = ce(e.lines), t = n.oldLines, r = n.newLines;
    t !== void 0 ? e.oldLines = t : delete e.oldLines,
      r !== void 0 ? e.newLines = r : delete e.newLines;
  }
  function $e(e, n, t) {
    e = ve(e, t), n = ve(n, t);
    var r = {};
    (e.index || n.index) && (r.index = e.index || n.index),
      (e.newFileName || n.newFileName) && (me(e)
        ? me(n)
          ? (r.oldFileName = re(r, e.oldFileName, n.oldFileName),
            r.newFileName = re(r, e.newFileName, n.newFileName),
            r.oldHeader = re(r, e.oldHeader, n.oldHeader),
            r.newHeader = re(r, e.newHeader, n.newHeader))
          : (r.oldFileName = e.oldFileName,
            r.newFileName = e.newFileName,
            r.oldHeader = e.oldHeader,
            r.newHeader = e.newHeader)
        : (r.oldFileName = n.oldFileName || e.oldFileName,
          r.newFileName = n.newFileName || e.newFileName,
          r.oldHeader = n.oldHeader || e.oldHeader,
          r.newHeader = n.newHeader || e.newHeader)),
      r.hunks = [];
    for (
      var a = 0, o = 0, l = 0, f = 0;
      a < e.hunks.length || o < n.hunks.length;
    ) {
      var c = e.hunks[a] || { oldStart: Infinity },
        d = n.hunks[o] || { oldStart: Infinity };
      if (ye(c, d)) r.hunks.push(Se(c, l)), a++, f += c.newLines - c.oldLines;
      else if (ye(d, c)) {
        r.hunks.push(Se(d, f)), o++, l += d.newLines - d.oldLines;
      } else {
        var m = {
          oldStart: Math.min(c.oldStart, d.oldStart),
          oldLines: 0,
          newStart: Math.min(c.newStart + l, d.oldStart + f),
          newLines: 0,
          lines: [],
        };
        Je(m, c.oldStart, c.lines, d.oldStart, d.lines),
          o++,
          a++,
          r.hunks.push(m);
      }
    }
    return r;
  }
  function ve(e, n) {
    if (typeof e == "string") {
      if (/^@@/m.test(e) || /^Index:/m.test(e)) return te(e)[0];
      if (!n) {
        throw new Error("Must provide a base reference or pass in a patch");
      }
      return le(void 0, void 0, n, e);
    }
    return e;
  }
  function me(e) {
    return e.newFileName && e.newFileName !== e.oldFileName;
  }
  function re(e, n, t) {
    return n === t ? n : (e.conflict = !0, { mine: n, theirs: t });
  }
  function ye(e, n) {
    return e.oldStart < n.oldStart && e.oldStart + e.oldLines < n.oldStart;
  }
  function Se(e, n) {
    return {
      oldStart: e.oldStart,
      oldLines: e.oldLines,
      newStart: e.newStart + n,
      newLines: e.newLines,
      lines: e.lines,
    };
  }
  function Je(e, n, t, r, a) {
    var o = { offset: n, lines: t, index: 0 },
      l = { offset: r, lines: a, index: 0 };
    for (
      xe(e, o, l), xe(e, l, o);
      o.index < o.lines.length && l.index < l.lines.length;
    ) {
      var f = o.lines[o.index], c = l.lines[l.index];
      if ((f[0] === "-" || f[0] === "+") && (c[0] === "-" || c[0] === "+")) {
        Me(e, o, l);
      } else if (f[0] === "+" && c[0] === " ") {
        var d;
        (d = e.lines).push.apply(d, D(z(o)));
      } else if (c[0] === "+" && f[0] === " ") {
        var m;
        (m = e.lines).push.apply(m, D(z(l)));
      } else {
        f[0] === "-" && c[0] === " "
          ? ke(e, o, l)
          : c[0] === "-" && f[0] === " "
          ? ke(e, l, o, !0)
          : f === c
          ? (e.lines.push(f), o.index++, l.index++)
          : fe(e, z(o), z(l));
      }
    }
    be(e, o), be(e, l), Ue(e);
  }
  function Me(e, n, t) {
    var r = z(n), a = z(t);
    if (Le(r) && Le(a)) {
      if (ue(r, a) && Ne(t, r, r.length - a.length)) {
        var o;
        (o = e.lines).push.apply(o, D(r));
        return;
      } else if (ue(a, r) && Ne(n, a, a.length - r.length)) {
        var l;
        (l = e.lines).push.apply(l, D(a));
        return;
      }
    } else if (De(r, a)) {
      var f;
      (f = e.lines).push.apply(f, D(r));
      return;
    }
    fe(e, r, a);
  }
  function ke(e, n, t, r) {
    var a = z(n), o = Ke(t, a);
    if (o.merged) {
      var l;
      (l = e.lines).push.apply(l, D(o.merged));
    } else fe(e, r ? o : a, r ? a : o);
  }
  function fe(e, n, t) {
    e.conflict = !0, e.lines.push({ conflict: !0, mine: n, theirs: t });
  }
  function xe(e, n, t) {
    for (; n.offset < t.offset && n.index < n.lines.length;) {
      var r = n.lines[n.index++];
      e.lines.push(r), n.offset++;
    }
  }
  function be(e, n) {
    for (; n.index < n.lines.length;) {
      var t = n.lines[n.index++];
      e.lines.push(t);
    }
  }
  function z(e) {
    for (var n = [], t = e.lines[e.index][0]; e.index < e.lines.length;) {
      var r = e.lines[e.index];
      if (t === "-" && r[0] === "+" && (t = "+"), t === r[0]) {
        n.push(r), e.index++;
      } else break;
    }
    return n;
  }
  function Ke(e, n) {
    for (
      var t = [], r = [], a = 0, o = !1, l = !1;
      a < n.length && e.index < e.lines.length;
    ) {
      var f = e.lines[e.index], c = n[a];
      if (c[0] === "+") break;
      if (o = o || f[0] !== " ", r.push(c), a++, f[0] === "+") {
        for (l = !0; f[0] === "+";) {
          t.push(f), f = e.lines[++e.index];
        }
      }
      c.substr(1) === f.substr(1) ? (t.push(f), e.index++) : l = !0;
    }
    if ((n[a] || "")[0] === "+" && o && (l = !0), l) return t;
    for (; a < n.length;) r.push(n[a++]);
    return { merged: r, changes: t };
  }
  function Le(e) {
    return e.reduce(function (n, t) {
      return n && t[0] === "-";
    }, !0);
  }
  function Ne(e, n, t) {
    for (var r = 0; r < t; r++) {
      var a = n[n.length - t + r].substr(1);
      if (e.lines[e.index + r] !== " " + a) return !1;
    }
    return e.index += t, !0;
  }
  function ce(e) {
    var n = 0, t = 0;
    return e.forEach(function (r) {
      if (typeof r != "string") {
        var a = ce(r.mine), o = ce(r.theirs);
        n !== void 0 &&
        (a.oldLines === o.oldLines ? n += a.oldLines : n = void 0),
          t !== void 0 &&
          (a.newLines === o.newLines ? t += a.newLines : t = void 0);
      } else {
        t !== void 0 && (r[0] === "+" || r[0] === " ") && t++,
          n !== void 0 && (r[0] === "-" || r[0] === " ") && n++;
      }
    }),
      { oldLines: n, newLines: t };
  }
  function ze(e) {
    for (var n = [], t, r, a = 0; a < e.length; a++) {
      t = e[a],
        t.added ? r = 1 : t.removed ? r = -1 : r = 0,
        n.push([r, t.value]);
    }
    return n;
  }
  function Ve(e) {
    for (var n = [], t = 0; t < e.length; t++) {
      var r = e[t];
      r.added ? n.push("<ins>") : r.removed && n.push("<del>"),
        n.push(_e(r.value)),
        r.added ? n.push("</ins>") : r.removed && n.push("</del>");
    }
    return n.join("");
  }
  function _e(e) {
    var n = e;
    return n = n.replace(/&/g, "&amp;"),
      n = n.replace(/</g, "&lt;"),
      n = n.replace(/>/g, "&gt;"),
      n = n.replace(/"/g, "&quot;"),
      n;
  }
  s.Diff = u,
    s.applyPatch = ge,
    s.applyPatches = Ee,
    s.canonicalize = ee,
    s.convertChangesToDMP = ze,
    s.convertChangesToXML = Ve,
    s.createPatch = Re,
    s.createTwoFilesPatch = we,
    s.diffArrays = Pe,
    s.diffChars = S,
    s.diffCss = Q,
    s.diffJson = je,
    s.diffLines = $,
    s.diffSentences = W,
    s.diffTrimmedLines = R,
    s.diffWords = O,
    s.diffWordsWithSpace = P,
    s.merge = $e,
    s.parsePatch = te,
    s.structuredPatch = le,
    Object.defineProperty(s, "__esModule", { value: !0 });
});
const Be = async (s) =>
    Array.from(
      new Uint8Array(
        await crypto.subtle.digest(
          "SHA-256",
          typeof s == "string" ? new TextEncoder().encode(s) : s,
        ),
      ).slice(0, 4),
    ).map((u) => ("00" + u.toString(16)).slice(-2)).join(""),
  diff = async (s, u) => {
    const w = Be(s), y = Diff.diffChars(s, u);
    return {
      b: await w,
      c: y.map((h) => h.added ? h.value : h.removed ? -h.count : h.count),
    };
  },
  isDiff = (s) => {
    if (s.length < 10) return !1;
    const u = [...s.slice(0, 8)].filter((y) => y < "0" || y > "f").length === 0,
      w = s.slice(8);
    if (u && w[0] === "[" && w[w.length - 1] === "]") {
      try {
        return JSON.parse(w).length > 1;
      } catch {
        return !1;
      }
    }
    return !1;
  },
  assemble = (s, u) => {
    const w = JSON.parse(u);
    let y = s.slice(), h = "";
    return w.forEach((S) => {
      if (Number(S) === S) {
        const N = Math.abs(S), H = y.slice(0, N);
        y = y.slice(N), S > 0 && (h += String(H));
      } else h += String(S);
    }),
      h;
  },
  getDbObj = (s, u = !1) => {
    const w = {
      async get(y, h = "string") {
        let S;
        try {
          if (
            u ? S = await (await s).get("codeStore", y) : S = await s.get(y), !S
          ) {
            return null;
          }
        } catch (N) {
          return null;
        }
        if (h === "json") return JSON.parse(S);
        if (h === "string") {
          const N = await S;
          if (typeof N == "string" && h === "string") {
            const H = N;
            if (isDiff(N)) {
              const v = N.slice(0, 8), g = N.slice(8), O = await w.get(v);
              return assemble(O, g);
            }
            return N;
          }
          return new TextDecoder().decode(N);
        }
        return S;
      },
      async put(y, h) {
        let S;
        try {
          const H = await w.get(y);
          if (
            typeof H == "string" && typeof h == "string" && H.length === 8 &&
            H !== h
          ) {
            const v = await w.get(h), g = await w.get(H);
            if (typeof g == "string") {
              const O = await sha256(g);
              if (O === H) {
                const P = await diff(v, g), T = P.b + JSON.stringify(P.c);
                w.put(O, T);
              }
            }
          }
        } catch {
          S = "";
        }
        if (S !== "" && h === S) return h;
        let N;
        return typeof h != "string" ? N = new TextDecoder().decode(h) : N = h,
          u ? (await s).put("codeStore", N, y) : await s.put(y, N);
      },
      async delete(y) {
        return (await s).delete("codeStore", y);
      },
      async clear() {
        return (await s).clear("codeStore");
      },
      async keys() {
        return (await s).getAllKeys("codeStore");
      },
    };
    return w;
  };
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (
    !getRandomValues &&
    (getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues &&
        crypto.getRandomValues.bind(crypto) ||
      typeof msCrypto != "undefined" &&
        typeof msCrypto.getRandomValues == "function" &&
        msCrypto.getRandomValues.bind(msCrypto),
      !getRandomValues)
  ) {
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported",
    );
  }
  return getRandomValues(rnds8);
}
const __default =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(s) {
  return typeof s == "string" && __default.test(s);
}
for (var byteToHex = [], i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(s) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    w = (byteToHex[s[u + 0]] + byteToHex[s[u + 1]] + byteToHex[s[u + 2]] +
      byteToHex[s[u + 3]] + "-" + byteToHex[s[u + 4]] + byteToHex[s[u + 5]] +
      "-" + byteToHex[s[u + 6]] + byteToHex[s[u + 7]] + "-" +
      byteToHex[s[u + 8]] + byteToHex[s[u + 9]] + "-" + byteToHex[s[u + 10]] +
      byteToHex[s[u + 11]] + byteToHex[s[u + 12]] + byteToHex[s[u + 13]] +
      byteToHex[s[u + 14]] + byteToHex[s[u + 15]]).toLowerCase();
  if (!validate(w)) throw TypeError("Stringified UUID is invalid");
  return w;
}
function v4(s, u, w) {
  s = s || {};
  var y = s.random || (s.rng || rng)();
  if (y[6] = y[6] & 15 | 64, y[8] = y[8] & 63 | 128, u) {
    w = w || 0;
    for (var h = 0; h < 16; ++h) u[w + h] = y[h];
    return u;
  }
  return stringify(y);
}
const v41 = () => v4();
var SHAKV, USERS, LOGS, USERKEYS, API_KEY;
let now = 0;
function log(s, u = {}) {
  now = now || Date.now();
  const [w, y] = new Date().toLocaleTimeString("en-US").split(/:| /);
  return LOGS.put(
    String(2e12 - now++),
    JSON.stringify({ message: s, time: `${w}:${y}`, data: u }),
    { expirationTtl: 86400 * 7 },
  );
}
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET,HEAD,POST,OPTIONS",
  "Access-Control-Max-Age": "86400",
};
function json(s) {
  return new Response(
    JSON.stringify(s),
    {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json;charset=UTF-8",
      },
    },
  );
}
function text(s) {
  return new Response(
    s,
    { headers: { ...corsHeaders, "Content-Type": "text/html;charset=UTF-8" } },
  );
}
function js(s) {
  return new Response(
    s,
    {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/javascript;charset=UTF-8",
      },
    },
  );
}
function handleOptions(s) {
  const u = s.headers;
  if (
    u.get("Origin") !== null &&
    u.get("Access-Control-Request-Method") !== null &&
    u.get("Access-Control-Request-Headers") !== null
  ) {
    const w = {
      ...corsHeaders,
      "Access-Control-Allow-Headers": s.headers.get(
        "Access-Control-Request-Headers",
      ),
    };
    return new Response(null, { headers: w });
  } else {
    return new Response(
      null,
      { headers: { Allow: corsHeaders["Access-Control-Allow-Methods"] } },
    );
  }
}
async function handleAdmin(s, u, w, y) {
  if (w === "/keys/") {
    const h = u.get("prefix"), S = await y.list({ prefix: h });
    return json(S);
  }
  if (w === "/keys/delete/") {
    const h = u.get("hash"), S = await y.delete(h);
    return json(S);
  }
  return json({ error: "not implemented" });
}
async function handleCloudRequest(s) {
  const { country: u, colo: w } = s.cf || { country: "", colo: "" },
    y = new URL(s.url),
    { searchParams: h, pathname: S } = y,
    N = String(s.headers.get("API_KEY") || "");
  if (
    log("request", { searchParams: h, pathname: S, country: u, colo: w }),
      s.method === "GET" && N && N == API_KEY
  ) {
    return handleAdmin(s, h, S, SHAKV);
  }
  if (s.method === "GET") {
    if (S === "/robots.txt") return text("User-agent: * Disallow: /");
    if (S === "/connect" && h.get("key")) {
      const v = h.get("key"),
        g = v.slice(0, 8),
        O = v.slice(8, 16),
        P = v.slice(16, 24),
        T = v.slice(24, 32),
        $ = await sha256(g + O);
      if (!g || !O || !P || $ !== T) return json({ error: "auth error" });
      const R = await USERKEYS.get(O);
      if (R === null) return json({ error: 401 });
      const j = await USERKEYS.get(g);
      if (j === null) return json({ error: 404, message: "token not found" });
      const W = await sha256(g + R), B = await sha256(j + R);
      return W === P
        ? (await USERS.put(
          j,
          JSON.stringify({ uuid: R, connected: O }),
          { expirationTtl: 60 },
        ),
          json({ success: !0 }))
        : B === P
        ? json({ success: !0 })
        : json({ error: 401 });
    }
    if (S === "/check") {
      const v = h.get("key");
      if (v === null) return new Response("500");
      const g = async () => {
          const P = await USERKEYS.get(v);
          if (!P) return null;
          const T = await USERS.get(P, "json");
          return !T || T.connected ? T : new Promise(($) => {
            const R = setInterval(async () => {
              const j = await USERS.get(P, "json");
              (!j || j.connected) && (clearInterval(R), $(j));
            }, 1e3);
          });
        },
        O = await g();
      return json({ expired: O === null });
    }
    if (S === "/register") {
      const v = v41(), g = await sha256(v);
      return await USERS.put(
        v,
        JSON.stringify(
          { uuid: v, uuidHash: g, registered: Date.now(), country: u, colo: w },
        ),
      ),
        await log("register", { uuidHash: g }),
        await USERKEYS.put(g, v),
        json({ uuid: v });
    }
    if (S === "/token") {
      const v = v41(), g = await sha256(v);
      return await USERS.put(
        v,
        JSON.stringify(
          { uuid: v, registered: Date.now(), country: u, colo: w },
        ),
        { expirationTtl: 60 },
      ),
        await USERKEYS.put(g, v, { expirationTtl: 60 }),
        json({ uuid: v, key: g });
    }
    if (S === "/create-project") {
      const v = s.headers.get("TOKEN"), g = v41();
      return await USERS.put(
        g,
        JSON.stringify(
          { uuid: g, registered: Date.now(), country: u, colo: w },
        ),
      ),
        json({ uuid: g });
    }
    const H = S.substr(1);
    if (H) {
      const v = getDbObj(SHAKV), g = await v.get(H);
      if (g !== null) return g.indexOf("export") === 0 ? js(g) : text(g);
    }
    return Response.redirect("https://zed.vision/code", 301);
  } else if (s.method === "POST") {
    const H = String(s.headers.get("ZKEY") || ""),
      v = H.slice(0, 8),
      g = H.slice(8, 16),
      O = H.slice(16, 24),
      P = H.slice(24, 32);
    if (!v || !g || !O || !P) {
      return json({ error: 401, message: "not matching keys" });
    }
    const T = await sha256(v + g);
    if (T !== O) {
      return json(
        { error: 401, message: "content and userkeys are not a pain" },
      );
    }
    const $ = await s.arrayBuffer(), R = await sha256($), j = R.substring(0, 8);
    if (j !== v) {
      return json(
        {
          error: 401,
          message: `body hash not matching with the sent hash: ${j} -- ${H}`,
        },
      );
    }
    const W = await USERKEYS.get(g);
    if (!W) return json({ error: 500, message: "user not found" });
    const B = await sha256(v + W);
    if (B !== P) return json({ error: 401, message: "user not verified" });
    await log("new html", { sha: v, uKey: g });
    const Q = S.substr(1);
    if (await SHAKV.put(j, $), Q) {
      const G = getDbObj(SHAKV), D = await G.put(Q, j);
    }
    return json({ hash: j });
  }
  return new Response("404");
}
addEventListener("fetch", (s) => {
  s.request.method === "OPTIONS"
    ? s.respondWith(handleOptions(s.request))
    : s.respondWith(handleCloudRequest(s.request));
});

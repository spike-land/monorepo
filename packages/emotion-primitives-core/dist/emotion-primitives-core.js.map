{"version":3,"file":"emotion-primitives-core.js","sources":["../src/css.js","../src/utils.js","../src/styled.js"],"sourcesContent":["// @flow\nimport transform from 'css-to-react-native'\nimport { interleave } from './utils'\n\n// this is for handleInterpolation\n// they're reset on every call to css\n// this is done so we don't create a new\n// handleInterpolation function on every css call\nlet styles\nlet generated = {}\nlet buffer = ''\nlet lastType\n\nfunction handleInterpolation(interpolation: *, i: number, arr: Array<*>) {\n  let type = typeof interpolation\n\n  if (type === 'string') {\n    // strip comments\n    interpolation = interpolation.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/gm, '')\n  }\n\n  if (type === 'function') {\n    if (this === undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error(\n          'Interpolating functions in css calls is not allowed.\\n' +\n            'If you want to have a css call based on props, create a function that returns a css call like this\\n' +\n            'let dynamicStyle = (props) => css`color: ${props.color}`\\n' +\n            'It can be called directly with props or interpolated in a styled call like this\\n' +\n            'let SomeComponent = styled.View`${dynamicStyle}`'\n        )\n      }\n    } else {\n      handleInterpolation.call(\n        this,\n        interpolation(\n          // $FlowFixMe\n          this\n        ),\n        i,\n        arr\n      )\n    }\n    return\n  }\n  let isIrrelevant = interpolation == null || type === 'boolean'\n  let isRnStyle =\n    (type === 'object' && !Array.isArray(interpolation)) || type === 'number'\n  if (lastType === 'string' && (isRnStyle || isIrrelevant)) {\n    let converted = convertStyles(buffer)\n    if (converted !== undefined) {\n      styles.push(converted)\n    }\n    buffer = ''\n  }\n  if (isIrrelevant) {\n    return\n  }\n\n  if (type === 'string') {\n    buffer += interpolation\n\n    if (arr.length - 1 === i) {\n      let converted = convertStyles(buffer)\n      if (converted !== undefined) {\n        styles.push(converted)\n      }\n      buffer = ''\n    }\n  }\n  if (isRnStyle) {\n    styles.push(interpolation)\n  }\n  if (Array.isArray(interpolation)) {\n    interpolation.forEach(handleInterpolation, this)\n  }\n  lastType = type\n}\n\n// Use platform specific StyleSheet method for creating the styles.\n// This enables us to use the css``/css({}) in any environment (Native | Sketch | Web)\nexport function createCss(StyleSheet: Object) {\n  return function css(...args: any) {\n    const prevBuffer = buffer\n    let vals\n\n    // these are declared earlier\n    // this is done so we don't create a new\n    // handleInterpolation function on every css call\n    styles = []\n    buffer = ''\n    lastType = undefined\n\n    if (args[0] == null || args[0].raw === undefined) {\n      vals = args\n    } else {\n      vals = interleave(args)\n    }\n\n    try {\n      vals.forEach(handleInterpolation, this)\n    } finally {\n      buffer = prevBuffer\n    }\n\n    const hash = JSON.stringify(styles)\n    if (!generated[hash]) {\n      const styleSheet = StyleSheet.create({\n        generated: StyleSheet.flatten(styles),\n      })\n      generated[hash] = styleSheet.generated\n    }\n    return generated[hash]\n  }\n}\n\nlet propertyValuePattern = /\\s*([^\\s]+)\\s*:\\s*(.+?)\\s*$/\n\nfunction convertPropertyValue(style) {\n  // Get prop name and prop value\n  let match = propertyValuePattern.exec(style)\n  // match[2] will be \" \" in cases where there is no value\n  // but there is whitespace, e.g. \"color: \"\n  if (match !== null && match[2] !== ' ') {\n    // the first value in the array will\n    // be the whole string so we remove it\n    match.shift()\n    // yes i know this looks funny\n    this.push(match)\n  }\n}\n\nfunction convertStyles(str: string) {\n  if (str.trim() === '') return\n\n  const stylePairs = []\n\n  const parsedString = str.split(';')\n\n  parsedString.forEach(convertPropertyValue, stylePairs)\n\n  try {\n    return transform(stylePairs)\n  } catch (error) {\n    const msg = error.message\n\n    if (msg.includes('Failed to parse declaration')) {\n      const values = msg\n        .replace('Failed to parse declaration ', '')\n        .replace(/\"/g, '')\n        .trim()\n        .split(':')\n\n      const errorMsg = `'${values[0]}' shorthand property requires units for example - ${values[0]}: 20px or ${values[0]}: 10px 20px 40px 50px`\n\n      console.error(errorMsg)\n    }\n  }\n}\n","// @flow\n\nexport function interleave(vals: Array<*>) {\n  let strings = vals[0]\n  let finalArray = [strings[0]]\n  for (let i = 1, len = vals.length; i < len; i++) {\n    finalArray.push(vals[i])\n    if (strings[i] !== undefined) {\n      finalArray.push(strings[i])\n    }\n  }\n  return finalArray\n}\n","// @flow\nimport * as React from 'react'\nimport { interleave } from './utils'\nimport { ThemeContext } from '@zedvision/emotion-react'\nimport { createCss } from './css'\n\nlet testOmitPropsOnComponent = (prop) => prop !== 'theme' && prop !== 'as'\n\ntype CreateStyledOptions = {\n  getShouldForwardProp: (cmp: React.ElementType) => (prop: string) => boolean,\n}\n\ntype StyledOptions = {\n  shouldForwardProp?: (prop: string) => boolean,\n}\n\nexport function createStyled(\n  StyleSheet: Object,\n  {\n    getShouldForwardProp = () => testOmitPropsOnComponent,\n  }: CreateStyledOptions = {}\n) {\n  const css = createCss(StyleSheet)\n\n  return function createEmotion(\n    component: React.ElementType,\n    options?: StyledOptions\n  ) {\n    let shouldForwardProp =\n      options && options.shouldForwardProp\n        ? options.shouldForwardProp\n        : undefined\n    let defaultShouldForwardProp =\n      shouldForwardProp || getShouldForwardProp(component)\n    let shouldUseAs = !defaultShouldForwardProp('as')\n\n    return function createStyledComponent(...rawStyles: *) {\n      let styles\n\n      if (rawStyles[0] == null || rawStyles[0].raw === undefined) {\n        styles = rawStyles\n      } else {\n        styles = interleave(rawStyles)\n      }\n\n      // do we really want to use the same infra as the web since it only really uses theming?\n      // $FlowFixMe\n      let Styled = React.forwardRef((props, ref) => {\n        const finalTag = (shouldUseAs && props.as) || component\n\n        let mergedProps = props\n        if (props.theme == null) {\n          mergedProps = {}\n          for (let key in props) {\n            mergedProps[key] = props[key]\n          }\n          mergedProps.theme = React.useContext(ThemeContext)\n        }\n\n        let finalShouldForwardProp =\n          shouldUseAs && shouldForwardProp === undefined\n            ? getShouldForwardProp(finalTag)\n            : defaultShouldForwardProp\n\n        let newProps = {}\n\n        for (let key in props) {\n          if (shouldUseAs && key === 'as') continue\n\n          if (finalShouldForwardProp(key)) {\n            newProps[key] = props[key]\n          }\n        }\n\n        newProps.style = [css.apply(mergedProps, styles), props.style]\n        newProps.ref = ref\n\n        // $FlowFixMe\n        return React.createElement(finalTag, newProps)\n      })\n      // $FlowFixMe\n      Styled.withComponent = (newComponent: React.ElementType) =>\n        createEmotion(newComponent)(...styles)\n\n      Styled.displayName = `emotion(${getDisplayName(component)})`\n\n      return Styled\n    }\n  }\n}\n\nconst getDisplayName = (primitive) =>\n  typeof primitive === 'string'\n    ? primitive\n    : primitive.displayName || primitive.name || 'Styled'\n"],"names":["styles","interleave","vals","strings","finalArray","i","len","length","push","undefined","lastType","generated","buffer","handleInterpolation","interpolation","arr","type","replace","isIrrelevant","isRnStyle","Array","isArray","converted","convertStyles","forEach","this","process","env","NODE_ENV","console","error","call","createCss","StyleSheet","args","prevBuffer","raw","hash","JSON","stringify","styleSheet","create","flatten","propertyValuePattern","convertPropertyValue","style","match","exec","shift","str","trim","stylePairs","split","transform","msg","message","includes","values","testOmitPropsOnComponent","prop","getDisplayName","primitive","displayName","name","getShouldForwardProp","css","createEmotion","component","options","shouldForwardProp","defaultShouldForwardProp","shouldUseAs","rawStyles","Styled","React","props","ref","finalTag","as","mergedProps","theme","key","ThemeContext","finalShouldForwardProp","newProps","apply","withComponent","newComponent"],"mappings":"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"}
import {
  CID,
  Circuit,
  Components,
  CustomEvent,
  DNS,
  EventEmitter,
  IPFS,
  P2P,
  PeerRecord,
  RecordEnvelope,
  TimeoutError,
  Uint8ArrayList,
  WebSockets,
  WebSocketsSecure,
  abortableDuplex,
  abortableSource,
  base32,
  base32pad,
  base32upper,
  base36,
  base58btc,
  base64,
  base64url,
  bases,
  bytes_exports,
  code,
  code2,
  codecs,
  compare,
  concat,
  concat_exports,
  config_browser_default,
  createTopology,
  decode,
  decode2,
  decodeMessage,
  encode,
  encodeMessage,
  enumeration,
  equals,
  from,
  fromNodeAddress,
  fromString,
  generateKeyPair,
  getProtocol,
  hashes,
  identity,
  importKey,
  init_concat,
  isInitializable,
  isMultiaddr,
  isPeerId,
  isStartable,
  isTopology,
  isUint8ArrayList,
  keys_exports,
  libp2pConfig,
  logger,
  marshalPrivateKey,
  marshalPublicKey,
  message,
  multiaddr,
  pDefer,
  pTimeout,
  pbkdf2,
  peerIdFromBytes,
  peerIdFromKeys,
  peerIdFromPeerId,
  peerIdFromString,
  pipe,
  pushable,
  pushableV,
  randomBytes,
  raw_exports,
  require_aes,
  require_asn1,
  require_crypto,
  require_debug,
  require_des,
  require_err_code,
  require_fast_fifo,
  require_forge,
  require_index_minimal,
  require_it_merge,
  require_md,
  require_oids,
  require_pbe,
  require_pem,
  require_random,
  require_rsa,
  require_util,
  require_varint,
  resolvers,
  routers,
  sha256,
  symbol,
  symbol2,
  toString,
  unmarshalPrivateKey,
  unmarshalPublicKey,
  xor
} from "./chunk-chunk-N4G5Z5H7.mjs";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __require,
  __toCommonJS,
  __toESM,
  define_process_default,
  init_define_process
} from "./chunk-chunk-UOA4FCKA.mjs";

// ../../../../../Users/z/.yarn/berry/cache/is-plain-obj-npm-2.1.0-8dffd7ae9c-9.zip/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/is-plain-obj-npm-2.1.0-8dffd7ae9c-9.zip/node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/merge-options-npm-3.0.4-f2ee6b8ea0-9.zip/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/merge-options-npm-3.0.4-f2ee6b8ea0-9.zip/node_modules/merge-options/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name6, value) => Object.defineProperty(object, name6, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol4 of symbols) {
          if (propertyIsEnumerable.call(value, symbol4)) {
            keys.push(symbol4);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config2) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge9(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge9(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module.exports = function(...options) {
      const config2 = merge9(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge9(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/is-electron-npm-2.2.1-71e2127025-9.zip/node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/is-electron-npm-2.2.1-71e2127025-9.zip/node_modules/is-electron/index.js"(exports, module) {
    init_define_process();
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof define_process_default !== "undefined" && typeof define_process_default.versions === "object" && !!define_process_default.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module.exports = isElectron2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/env.js"(exports, module) {
    "use strict";
    init_define_process();
    var isElectron2 = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron2();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof define_process_default !== "undefined" && typeof define_process_default.release !== "undefined" && define_process_default.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof define_process_default !== "undefined" && typeof define_process_default.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// ../../.yarn/unplugged/protobufjs-npm-7.1.2-2e50888192/node_modules/protobufjs/minimal.js
var require_minimal = __commonJS({
  "../../.yarn/unplugged/protobufjs-npm-7.1.2-2e50888192/node_modules/protobufjs/minimal.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = require_index_minimal();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/retimer-npm-3.0.0-a791f535cc-9.zip/node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/retimer-npm-3.0.0-a791f535cc-9.zip/node_modules/retimer/time-browser.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = function getTime() {
      return Date.now();
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/retimer-npm-3.0.0-a791f535cc-9.zip/node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/retimer-npm-3.0.0-a791f535cc-9.zip/node_modules/retimer/retimer.js"(exports, module) {
    "use strict";
    init_define_process();
    var getTime = require_time_browser();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer4() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module.exports = retimer4;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/timeout-abort-controller-npm-3.0.0-ae91925a11-9.zip/node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/timeout-abort-controller-npm-3.0.0-ae91925a11-9.zip/node_modules/timeout-abort-controller/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var { AbortController: AbortController2 } = globalThis;
    var retimer4 = require_retimer();
    var TimeoutController20 = class extends AbortController2 {
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer4(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController20.prototype);
      }
      abort() {
        this._timer.clear();
        return super.abort();
      }
      clear() {
        this._timer.clear();
      }
      reset() {
        this._timer.clear();
        this._timer = retimer4(() => this.abort(), this._ms);
      }
    };
    module.exports = {
      TimeoutController: TimeoutController20
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/src/url-browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var isReactNative2 = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative2) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL3 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base = defaultBase) {
        this.super = new URL3(url, base);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash3) {
        this.super.hash = hash3;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      static createObjectURL(o) {
        return URL3.createObjectURL(o);
      }
      static revokeObjectURL(o) {
        URL3.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format(obj) {
      if (typeof obj === "string") {
        const url = new URL3(obj);
        return url.toString();
      }
      if (!(obj instanceof URL3)) {
        const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash3 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path4 = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path4}${hash3}`;
      }
    }
    module.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/src/relative.js"(exports, module) {
    "use strict";
    init_define_process();
    var { URLWithLegacySupport, format } = require_url_browser();
    module.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err2) {
        urlParsed = {};
      }
      const base = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format(base)).toString();
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/iso-url-npm-1.2.1-494c3c59bc-9.zip/node_modules/iso-url/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var {
      URLWithLegacySupport,
      format,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative2 = require_relative();
    module.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format,
      relative: relative2,
      defaultBase
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/any-signal-npm-3.0.1-e7c018609b-9.zip/node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/any-signal-npm-3.0.1-e7c018609b-9.zip/node_modules/any-signal/index.js"(exports, module) {
    init_define_process();
    function anySignal14(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener)
            continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener)
          continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module.exports = anySignal14;
    module.exports.anySignal = anySignal14;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/hashlru-npm-2.3.0-8267692d49-9.zip/node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/hashlru-npm-2.3.0-8267692d49-9.zip/node_modules/hashlru/index.js"(exports, module) {
    init_define_process();
    module.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache3 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache3[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache3;
          cache3 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache3[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache3[key] !== void 0)
            cache3[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache3[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache3[key] !== void 0)
            cache3[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache3 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/eventemitter3-npm-4.0.7-7afcdd74ae-9.zip/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/eventemitter3-npm-4.0.7-7afcdd74ae-9.zip/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter6() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      var names = [], events2, name6;
      if (this._eventsCount === 0)
        return names;
      for (name6 in events2 = this._events) {
        if (has.call(events2, name6))
          names.push(prefix ? name6.slice(1) : name6);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter6.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter6.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter6.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i = 0; i < length5; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter6.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter6.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter6.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length5 = listeners.length; i < length5; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.addListener = EventEmitter6.prototype.on;
    EventEmitter6.prefixed = prefix;
    EventEmitter6.EventEmitter = EventEmitter6;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter6;
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http/error.js"(exports) {
    "use strict";
    init_define_process();
    var TimeoutError4 = class extends Error {
      constructor(message2 = "Request timed out") {
        super(message2);
        this.name = "TimeoutError";
      }
    };
    exports.TimeoutError = TimeoutError4;
    var AbortError4 = class extends Error {
      constructor(message2 = "The operation was aborted.") {
        super(message2);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError4;
    var HTTPError2 = class extends Error {
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports.HTTPError = HTTPError2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-fetch-https-3a7bba76a2-9.zip/node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-fetch-https-3a7bba76a2-9.zip/node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module.exports = exports = global2.fetch;
    if (global2.fetch) {
      exports.default = global2.fetch.bind(global2);
    }
    exports.Headers = global2.Headers;
    exports.Request = global2.Request;
    exports.Response = global2.Response;
  }
});

// ../../.yarn/__virtual__/native-fetch-virtual-2e24719d65/4/Users/z/.yarn/berry/cache/native-fetch-npm-3.0.0-9511457262-9.zip/node_modules/native-fetch/src/index.js
var require_src = __commonJS({
  "../../.yarn/__virtual__/native-fetch-virtual-2e24719d65/4/Users/z/.yarn/berry/cache/native-fetch-npm-3.0.0-9511457262-9.zip/node_modules/native-fetch/src/index.js"(exports, module) {
    "use strict";
    init_define_process();
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module.exports = {
        default: require_browser().default,
        Headers: require_browser().Headers,
        Request: require_browser().Request,
        Response: require_browser().Response
      };
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/fetch.browser.js
var require_fetch_browser = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/fetch.browser.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = require_src();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http/fetch.browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var { TimeoutError: TimeoutError4, AbortError: AbortError4 } = require_error();
    var { Response: Response2, Request, Headers, default: fetch } = require_fetch_browser();
    var fetchWithProgress = (url, options = {}) => {
      const request2 = new XMLHttpRequest();
      request2.open(options.method || "GET", url.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request2.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request2.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name6, value] of new Headers(headers)) {
          request2.setRequestHeader(name6, value);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request2.abort();
      }
      if (options.onUploadProgress) {
        request2.upload.onprogress = options.onUploadProgress;
      }
      request2.responseType = "arraybuffer";
      return new Promise((resolve7, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve7(Response2.error());
              break;
            }
            case "load": {
              resolve7(
                new ResponseWithURL(request2.responseURL, request2.response, {
                  status: request2.status,
                  statusText: request2.statusText,
                  headers: parseHeaders(request2.getAllResponseHeaders())
                })
              );
              break;
            }
            case "timeout": {
              reject(new TimeoutError4());
              break;
            }
            case "abort": {
              reject(new AbortError4());
              break;
            }
            default: {
              break;
            }
          }
        };
        request2.onerror = handleEvent;
        request2.onload = handleEvent;
        request2.ontimeout = handleEvent;
        request2.onabort = handleEvent;
        request2.send(options.body);
      });
    };
    var fetchWithStreaming = fetch;
    var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      constructor(url, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url });
      }
    };
    module.exports = {
      fetch: fetchWith,
      Request,
      Headers
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/http.js"(exports, module) {
    "use strict";
    init_define_process();
    var { fetch, Request, Headers } = require_fetch_browser2();
    var { TimeoutError: TimeoutError4, HTTPError: HTTPError2 } = require_error();
    var merge9 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL3, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal14 = require_any_signal();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve7, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError4());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError4());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve7), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP5 = class {
      constructor(options = {}) {
        this.opts = merge9(defaults, options);
      }
      async fetch(resource, options = {}) {
        const opts = merge9(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL3 || resource instanceof Request)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL3(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal14([abortController.signal, opts.signal]);
        const response = await timeout(
          fetch(
            url.toString(),
            {
              ...opts,
              signal,
              timeout: void 0,
              headers
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader2 = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value } = await reader2.read();
              if (done)
                return;
              if (value) {
                yield value;
              }
            }
          } finally {
            reader2.releaseLock();
          }
        }();
      }
      if (isAsyncIterable2(source)) {
        return source;
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value) => {
      return typeof value === "object" && value !== null && typeof value[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value) => {
      return value && typeof value.getReader === "function";
    };
    var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
    HTTP5.HTTPError = HTTPError2;
    HTTP5.TimeoutError = TimeoutError4;
    HTTP5.streamToAsyncIterator = fromStream;
    HTTP5.post = (resource, options) => new HTTP5(options).post(resource, options);
    HTTP5.get = (resource, options) => new HTTP5(options).get(resource, options);
    HTTP5.put = (resource, options) => new HTTP5(options).put(resource, options);
    HTTP5.delete = (resource, options) => new HTTP5(options).delete(resource, options);
    HTTP5.options = (resource, options) => new HTTP5(options).options(resource, options);
    module.exports = HTTP5;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-last-npm-1.0.6-03ac5e9d1b-9.zip/node_modules/it-last/index.js
var require_it_last = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-last-npm-1.0.6-03ac5e9d1b-9.zip/node_modules/it-last/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var last14 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module.exports = last14;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/timestamp-nano-npm-1.0.0-9cc2febd9d-9.zip/node_modules/timestamp-nano/timestamp.js
var require_timestamp = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/timestamp-nano-npm-1.0.0-9cc2febd9d-9.zip/node_modules/timestamp-nano/timestamp.js"(exports, module) {
    init_define_process();
    var Timestamp = function() {
      if ("undefined" !== typeof module)
        module.exports = Timestamp2;
      var SEC_DAY = 24 * 3600;
      var YEAR_SLOT = 3200;
      var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400;
      var SEC_SLOT = SEC_DAY * DAY_SLOT;
      var MSEC_SLOT = SEC_SLOT * 1e3;
      var MAX_MSEC = 1e3 * 1e4 * 1e4 * SEC_DAY;
      var BIT24 = 16777216;
      var BIT32 = 65536 * 65536;
      var DEC6 = 1e3 * 1e3;
      var DEC9 = 1e3 * 1e3 * 1e3;
      var ZERO9 = "000000000";
      var trunc = Math.trunc || Math_trunc;
      var P = Timestamp2.prototype;
      Timestamp2.fromDate = fromDate;
      Timestamp2.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
      Timestamp2.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
      Timestamp2.fromString = fromString3;
      Timestamp2.fromTimeT = fromTimeT;
      P.year = 0;
      P.time = 0;
      P.nano = 0;
      P.addNano = addNano;
      P.getNano = getNano;
      P.getTimeT = getTimeT;
      P.getYear = getYear;
      P.toDate = toDate;
      P.toJSON = toJSON;
      P.toString = toString4;
      P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
      P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);
      var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";
      var FMT_MONTH = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      var FMT_DAY = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      var FMT_STRING = {
        "%": "%",
        F: "%Y-%m-%d",
        n: "\n",
        R: "%H:%M",
        T: "%H:%M:%S",
        t: "	",
        X: "%T",
        Z: "GMT",
        z: "+0000"
      };
      return Timestamp2;
      function Timestamp2(time, nano, year) {
        var ts = this;
        if (!(ts instanceof Timestamp2))
          return new Timestamp2(time, nano, year);
        ts.time = +time || 0;
        ts.nano = +nano || 0;
        ts.year = +year || 0;
        normalize(ts);
      }
      function getYear() {
        var year = this.toDate().getUTCFullYear();
        return year + this.year;
      }
      function normalize(ts) {
        var year = ts.year;
        var time = ts.time;
        var nano = ts.nano;
        var changed;
        var slot;
        if (nano < 0 || DEC6 <= nano) {
          var n = Math.floor(nano / DEC6);
          nano -= n * DEC6;
          time += n;
          changed = 1;
        }
        var y = year % YEAR_SLOT;
        if (time < -MAX_MSEC || MAX_MSEC < time || y) {
          slot = trunc(time / MSEC_SLOT);
          if (slot) {
            year += slot * YEAR_SLOT;
            time -= slot * MSEC_SLOT;
          }
          var dt = newDate(time);
          dt.setUTCFullYear(y + dt.getUTCFullYear());
          year -= y;
          time = +dt;
          slot = trunc(year / YEAR_SLOT);
          var total = time + slot * MSEC_SLOT;
          if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
            year -= slot * YEAR_SLOT;
            time = total;
          }
          changed = 1;
        }
        if (changed) {
          ts.year = year;
          ts.time = time;
          ts.nano = nano;
        }
        return ts;
      }
      function toDate() {
        var ts = normalize(this);
        return newDate(ts.time);
      }
      function newDate(time) {
        var dt = new Date(0);
        dt.setTime(time);
        return dt;
      }
      function addNano(nano) {
        this.nano += +nano || 0;
        return this;
      }
      function getNano() {
        var ts = normalize(this);
        return (ts.time % 1e3 * DEC6 + +ts.nano + DEC9) % DEC9;
      }
      function fromString3(string) {
        var time;
        var ts = new Timestamp2();
        string += "";
        var array = string.replace(/^\s*[+\-]?\d+/, function(match) {
          var year = +match;
          var y = 1970 + (year - 1970) % 400;
          ts.year = year - y;
          return y;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour3, min) {
          if (hour3 < 0)
            min *= -1;
          time = (+hour3 * 60 + +min) * 6e4;
          return "";
        }).replace(/\.\d+$/, function(match) {
          ts.nano = +(match + ZERO9).substr(1, 9);
          return "";
        }).split(/\D+/);
        if (array.length > 1) {
          array[1]--;
        } else {
          array[1] = 0;
        }
        ts.time = time = Date.UTC.apply(Date, array) - (time || 0);
        if (isNaN(time)) {
          throw new TypeError("Invalid Date");
        }
        return normalize(ts);
      }
      function fromDate(date) {
        return new Timestamp2(+date);
      }
      function fromTimeT(time) {
        return fromTime(time, 0);
      }
      function fromTime(low, high) {
        high |= 0;
        high *= BIT32;
        low = +low || 0;
        var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);
        var second2 = high % SEC_SLOT + low % SEC_SLOT;
        var offset = trunc(second2 / SEC_SLOT);
        if (offset) {
          slot += offset;
          second2 -= offset * SEC_SLOT;
        }
        return new Timestamp2(second2 * 1e3, 0, slot * YEAR_SLOT);
      }
      function getTimeT() {
        var ts = normalize(this);
        var time = Math.floor(ts.time / 1e3);
        var year = ts.year;
        if (year)
          time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;
        return time;
      }
      function toJSON() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }
      function toString4(format) {
        var ts = this;
        var dt = ts.toDate();
        var map18 = {
          H,
          L,
          M,
          N,
          S,
          Y,
          a,
          b,
          d,
          e,
          m
        };
        return strftime(format || FMT_JSON);
        function strftime(format2) {
          return format2.replace(/%./g, function(match) {
            var m2 = match[1];
            var c = FMT_STRING[m2];
            var f = map18[m2];
            return c ? strftime(c) : f ? f() : match;
          });
        }
        function Y() {
          var year = ts.getYear();
          if (year > 999999) {
            return "+" + year;
          } else if (year > 9999) {
            return "+" + pad(year, 6);
          } else if (year >= 0) {
            return pad(year, 4);
          } else if (year >= -999999) {
            return "-" + pad(-year, 6);
          } else {
            return year;
          }
        }
        function m() {
          return pad2(dt.getUTCMonth() + 1);
        }
        function d() {
          return pad2(dt.getUTCDate());
        }
        function e() {
          return padS(dt.getUTCDate());
        }
        function H() {
          return pad2(dt.getUTCHours());
        }
        function M() {
          return pad2(dt.getUTCMinutes());
        }
        function S() {
          return pad2(dt.getUTCSeconds());
        }
        function L() {
          return pad(dt.getUTCMilliseconds(), 3);
        }
        function N() {
          return pad(ts.getNano(), 9);
        }
        function a() {
          return FMT_DAY[dt.getUTCDay()];
        }
        function b() {
          return FMT_MONTH[dt.getUTCMonth()];
        }
      }
      function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return writeInt64;
        function writeInt64(buffer2, offset) {
          var ts = normalize(this);
          if (!buffer2)
            buffer2 = new Array(8);
          checkRange(buffer2, offset |= 0);
          var second2 = Math.floor(ts.time / 1e3);
          var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
          var high = trunc(day / BIT32) + trunc(second2 / BIT32);
          var low = day % BIT32 + second2 % BIT32;
          var slot = Math.floor(low / BIT32);
          if (slot) {
            high += slot;
            low -= slot * BIT32;
          }
          writeUint32(buffer2, offset + posH, high);
          writeUint32(buffer2, offset + posL, low);
          return buffer2;
        }
        function writeUint32(buffer2, offset, value) {
          buffer2[offset + pos0] = value >> 24 & 255;
          buffer2[offset + pos1] = value >> 16 & 255;
          buffer2[offset + pos2] = value >> 8 & 255;
          buffer2[offset + pos3] = value & 255;
        }
      }
      function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return fromInt64;
        function fromInt64(buffer2, offset) {
          checkRange(buffer2, offset |= 0);
          var high = readUint322(buffer2, offset + posH);
          var low = readUint322(buffer2, offset + posL);
          return fromTime(low, high);
        }
        function readUint322(buffer2, offset) {
          return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16 | buffer2[offset + pos2] << 8 | buffer2[offset + pos3]);
        }
      }
      function checkRange(buffer2, offset) {
        var last14 = buffer2 && buffer2.length;
        if (last14 == null)
          throw new TypeError("Invalid Buffer");
        if (last14 < offset + 8)
          throw new RangeError("Out of range");
      }
      function Math_trunc(x) {
        var n = x - x % 1;
        return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;
      }
      function padS(v) {
        return (v > 9 ? "" : " ") + (v | 0);
      }
      function pad2(v) {
        return (v > 9 ? "" : "0") + (v | 0);
      }
      function pad(v, len) {
        return (ZERO9 + (v | 0)).substr(-len);
      }
    }();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-all-npm-1.0.6-123b7bd5fa-9.zip/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-all-npm-1.0.6-123b7bd5fa-9.zip/node_modules/it-all/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var all11 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module.exports = all11;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-drain-npm-1.0.5-2e683fd48a-9.zip/node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-drain-npm-1.0.5-2e683fd48a-9.zip/node_modules/it-drain/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var drain15 = async (source) => {
      for await (const _ of source) {
      }
    };
    module.exports = drain15;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-filter-npm-1.0.3-ec6af9254f-9.zip/node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-filter-npm-1.0.3-ec6af9254f-9.zip/node_modules/it-filter/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var filter15 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module.exports = filter15;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-take-npm-1.0.2-0e27f6b859-9.zip/node_modules/it-take/index.js
var require_it_take = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-take-npm-1.0.2-0e27f6b859-9.zip/node_modules/it-take/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var take6 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module.exports = take6;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/dlv-npm-1.1.3-187c903a21-9.zip/node_modules/dlv/dist/dlv.umd.js
var require_dlv_umd = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/dlv-npm-1.1.3-187c903a21-9.zip/node_modules/dlv/dist/dlv.umd.js"(exports, module) {
    init_define_process();
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      } : "function" == typeof define && define.amd ? define(function() {
        return function(t2, n2, e, i, o) {
          for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
            t2 = t2 ? t2[n2[i]] : o;
          return t2 === o ? e : t2;
        };
      }) : t.dlv = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      };
    }(exports);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-map-npm-1.0.6-4810c8e3ed-9.zip/node_modules/it-map/index.js
var require_it_map = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-map-npm-1.0.6-4810c8e3ed-9.zip/node_modules/it-map/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var map18 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module.exports = map18;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/is-domain-name-npm-1.0.1-9d8d601cb1-9.zip/node_modules/is-domain-name/index.js
var require_is_domain_name = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/is-domain-name-npm-1.0.1-9d8d601cb1-9.zip/node_modules/is-domain-name/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
    module.exports = function isDomainName(domainName, rootDot) {
      if (rootDot == null)
        rootDot = false;
      if (domainName.length < 2)
        return false;
      if (domainName.length > 255)
        return false;
      var lastChar = domainName[domainName.length - 1];
      if (rootDot) {
        if (lastChar !== ".")
          return false;
      } else {
        if (lastChar === ".")
          return false;
      }
      return domainNameRegex.test(domainName);
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/p-defer-npm-3.0.0-5c4fecb489-9.zip/node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/p-defer-npm-3.0.0-5c4fecb489-9.zip/node_modules/p-defer/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var pDefer2 = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve7, reject) => {
        deferred.resolve = resolve7;
        deferred.reject = reject;
      });
      return deferred;
    };
    module.exports = pDefer2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-parallel-npm-2.0.2-13a29bde81-9.zip/node_modules/it-parallel/index.js
var require_it_parallel = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-parallel-npm-2.0.2-13a29bde81-9.zip/node_modules/it-parallel/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var defer = require_p_defer();
    var CustomEvent2 = globalThis.CustomEvent || Event;
    async function* parallel5(source, options = {}) {
      let concurrency = options.concurrency || Infinity;
      if (concurrency < 1) {
        concurrency = Infinity;
      }
      const ordered = options.ordered == null ? false : options.ordered;
      const emitter = new EventTarget();
      const ops = [];
      let slotAvailable = defer();
      let resultAvailable = defer();
      let sourceFinished = false;
      let sourceErr;
      let opErred = false;
      emitter.addEventListener("task-complete", () => {
        resultAvailable.resolve();
      });
      Promise.resolve().then(async () => {
        try {
          for await (const task of source) {
            if (ops.length === concurrency) {
              slotAvailable = defer();
              await slotAvailable.promise;
            }
            if (opErred) {
              break;
            }
            const op = {
              done: false
            };
            ops.push(op);
            task().then((result) => {
              op.done = true;
              op.ok = true;
              op.value = result;
              emitter.dispatchEvent(new CustomEvent2("task-complete"));
            }, (err2) => {
              op.done = true;
              op.err = err2;
              emitter.dispatchEvent(new CustomEvent2("task-complete"));
            });
          }
          sourceFinished = true;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        } catch (err2) {
          sourceErr = err2;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }
      });
      function valuesAvailable() {
        if (ordered) {
          return Boolean(ops[0] && ops[0].done);
        }
        return Boolean(ops.find((op) => op.done));
      }
      function* yieldOrderedValues() {
        while (ops.length && ops[0].done) {
          const op = ops[0];
          ops.shift();
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
      function* yieldUnOrderedValues() {
        while (valuesAvailable()) {
          for (let i = 0; i < ops.length; i++) {
            if (ops[i].done) {
              const op = ops[i];
              ops.splice(i, 1);
              i--;
              if (op.ok) {
                yield op.value;
              } else {
                opErred = true;
                slotAvailable.resolve();
                throw op.err;
              }
              slotAvailable.resolve();
            }
          }
        }
      }
      while (true) {
        if (!valuesAvailable()) {
          resultAvailable = defer();
          await resultAvailable.promise;
        }
        if (sourceErr) {
          throw sourceErr;
        }
        if (ordered) {
          yield* yieldOrderedValues();
        } else {
          yield* yieldUnOrderedValues();
        }
        if (sourceFinished && ops.length === 0) {
          break;
        }
      }
    }
    module.exports = parallel5;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-readablestream-to-it-npm-1.0.3-2d21636f48-9.zip/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-readablestream-to-it-npm-1.0.3-2d21636f48-9.zip/node_modules/browser-readablestream-to-it/index.js"(exports, module) {
    "use strict";
    init_define_process();
    async function* browserReadableStreamToIt(stream, options = {}) {
      const reader2 = stream.getReader();
      try {
        while (true) {
          const result = await reader2.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader2.cancel();
        }
        reader2.releaseLock();
      }
    }
    module.exports = browserReadableStreamToIt;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/blob-to-it-npm-1.0.4-ad690f7d96-9.zip/node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/blob-to-it-npm-1.0.4-ad690f7d96-9.zip/node_modules/blob-to-it/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module.exports = blobToIt2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-peekable-npm-1.0.3-2c832304d6-9.zip/node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-peekable-npm-1.0.3-2c832304d6-9.zip/node_modules/it-peekable/index.js"(exports, module) {
    "use strict";
    init_define_process();
    function peekableIterator(iterable) {
      const [iterator, symbol4] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol4]() {
          return this;
        }
      };
    }
    module.exports = peekableIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-batch-npm-1.0.9-3821bae354-9.zip/node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-batch-npm-1.0.9-3821bae354-9.zip/node_modules/it-batch/index.js"(exports, module) {
    "use strict";
    init_define_process();
    async function* batch3(source, size = 1) {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      for await (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    module.exports = batch3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-parallel-batch-npm-1.0.11-d2582d7317-9.zip/node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-parallel-batch-npm-1.0.11-d2582d7317-9.zip/node_modules/it-parallel-batch/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var batch3 = require_it_batch();
    async function* parallelBatch4(source, size = 1) {
      for await (const tasks of batch3(source, size)) {
        const things = tasks.map(
          (p) => {
            return p().then((value) => ({ ok: true, value }), (err2) => ({ ok: false, err: err2 }));
          }
        );
        for (let i = 0; i < things.length; i++) {
          const result = await things[i];
          if (result.ok) {
            yield result.value;
          } else {
            throw result.err;
          }
        }
      }
    }
    module.exports = parallelBatch4;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/murmurhash3js-revisited-npm-3.0.0-6b19260406-9.zip/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/murmurhash3js-revisited-npm-3.0.0-6b19260406-9.zip/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports, module) {
    init_define_process();
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i = 0; i < bytes2.length; i++) {
          if (!Number.isInteger(bytes2[i]) || bytes2[i] < 0 || bytes2[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k2 = bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24;
          k3 = bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24;
          k4 = bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i + 14] << 16;
          case 14:
            k4 ^= bytes2[i + 13] << 8;
          case 13:
            k4 ^= bytes2[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i + 11] << 24;
          case 11:
            k3 ^= bytes2[i + 10] << 16;
          case 10:
            k3 ^= bytes2[i + 9] << 8;
          case 9:
            k3 ^= bytes2[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i + 7] << 24;
          case 7:
            k2 ^= bytes2[i + 6] << 16;
          case 6:
            k2 ^= bytes2[i + 5] << 8;
          case 5:
            k2 ^= bytes2[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i + 3] << 24;
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24, bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24];
          k2 = [bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24, bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library;
        }
        exports.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/murmurhash3js-revisited-npm-3.0.0-6b19260406-9.zip/node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/murmurhash3js-revisited-npm-3.0.0-6b19260406-9.zip/node_modules/murmurhash3js-revisited/index.js"(exports, module) {
    init_define_process();
    module.exports = require_murmurHash3js();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/base64-js-npm-1.5.1-b2f7275641-9.zip/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/base64-js-npm-1.5.1-b2f7275641-9.zip/node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_define_process();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code7 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code7.length; i < len; ++i) {
      lookup[i] = code7[i];
      revLookup[code7.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ieee754-npm-1.2.1-fb63b3caeb-9.zip/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ieee754-npm-1.2.1-fb63b3caeb-9.zip/node_modules/ieee754/index.js"(exports) {
    init_define_process();
    exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// js/buffer/index.js
var require_buffer = __commonJS({
  "js/buffer/index.js"(exports) {
    "use strict";
    init_define_process();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length5) {
      if (length5 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length5 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length5);
      Object.setPrototypeOf(buf2, Buffer.prototype);
      return buf2;
    }
    function Buffer(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe3(arg);
      }
      return from2(arg, encodingOrOffset, length5);
    }
    Buffer.poolSize = 8192;
    function from2(value, encodingOrOffset, length5) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length5);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length5);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length5) {
      return from2(value, encodingOrOffset, length5);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe3(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe3(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe3(size);
    };
    function fromString3(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length5 = byteLength(string, encoding) | 0;
      let buf2 = createBuffer(length5);
      const actual = buf2.write(string, encoding);
      if (actual !== length5) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length5 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length5);
      for (let i = 0; i < length5; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length5) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length5 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length5 === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length5 === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length5);
      }
      Object.setPrototypeOf(buf2, Buffer.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length5) {
      if (length5 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length5 | 0;
    }
    function SlowBuffer(length5) {
      if (+length5 != length5) {
        length5 = 0;
      }
      return Buffer.alloc(+length5);
    }
    Buffer.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare3(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat3(list, length5) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      let i;
      if (length5 === void 0) {
        length5 = 0;
        for (i = 0; i < list.length; ++i) {
          length5 += list[i].length;
        }
      }
      const buffer2 = Buffer.allocUnsafe(length5);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer.isBuffer(buf2))
              buf2 = Buffer.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString4() {
      const length5 = this.length;
      if (length5 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length5);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals2(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string, offset, length5) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length5) {
        length5 = remaining;
      } else {
        length5 = Number(length5);
        if (length5 > remaining) {
          length5 = remaining;
        }
      }
      const strLen = string.length;
      if (length5 > strLen / 2) {
        length5 = strLen / 2;
      }
      let i;
      for (i = 0; i < length5; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string, offset, length5) {
      return blitBuffer(utf8ToBytes2(string, buf2.length - offset), buf2, offset, length5);
    }
    function asciiWrite(buf2, string, offset, length5) {
      return blitBuffer(asciiToBytes(string), buf2, offset, length5);
    }
    function base64Write(buf2, string, offset, length5) {
      return blitBuffer(base64ToBytes(string), buf2, offset, length5);
    }
    function ucs2Write(buf2, string, offset, length5) {
      return blitBuffer(utf16leToBytes(string, buf2.length - offset), buf2, offset, length5);
    }
    Buffer.prototype.write = function write3(string, offset, length5, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length5 = this.length;
        offset = 0;
      } else if (length5 === void 0 && typeof offset === "string") {
        encoding = offset;
        length5 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length5)) {
          length5 = length5 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length5;
          length5 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length5 === void 0 || length5 > remaining)
        length5 = remaining;
      if (string.length > 0 && (length5 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length5);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length5);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length5);
          case "base64":
            return base64Write(this, string, offset, length5);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length5);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base642.fromByteArray(buf2);
      } else {
        return base642.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes2 = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes2.length - 1; i += 2) {
        res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length5) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length5)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first10 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last14 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first10 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last14;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last14 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first10 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first10 = this[offset];
      const last14 = this[offset + 7];
      if (first10 === void 0 || last14 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first10 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last14);
    });
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code7 = val.charCodeAt(0);
          if (encoding === "utf8" && code7 < 128 || encoding === "latin1") {
            val = code7;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes2 = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes2.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes2[i % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name6) {
        if (name6) {
          return `${name6} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name6, actual) {
        return `The "${name6}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name6) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name6, "number", value);
      }
    }
    function boundsError(value, length5, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length5 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length5}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length5 = string.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i = 0; i < length5; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i + 1 === length5) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length5) {
      let i;
      for (i = 0; i < length5; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/bl-npm-5.0.0-cd18f87fd8-9.zip/node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/bl-npm-5.0.0-cd18f87fd8-9.zip/node_modules/bl/BufferList.js"(exports, module) {
    "use strict";
    init_define_process();
    var { Buffer } = require_buffer();
    var symbol4 = Symbol.for("BufferList");
    function BufferList3(buf2) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf2);
      }
      BufferList3._init.call(this, buf2);
    }
    BufferList3._init = function _init(buf2) {
      Object.defineProperty(this, symbol4, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf2) {
        this.append(buf2);
      }
    };
    BufferList3.prototype._new = function _new(buf2) {
      return new BufferList3(buf2);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get6(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes2 = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes2 <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off[0]].slice(start, start + bytes2);
      }
      if (!copy2) {
        dst = Buffer.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes2 > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes2);
          bufoff += l;
          break;
        }
        bytes2 -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString4(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes2 >= this._bufs[0].length) {
          bytes2 -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes2);
          this.length -= bytes2;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf2) {
      if (buf2 == null) {
        return this;
      }
      if (buf2.buffer) {
        this._appendBuffer(Buffer.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      } else if (Array.isArray(buf2)) {
        for (let i = 0; i < buf2.length; i++) {
          this.append(buf2[i]);
        }
      } else if (this._isBufferList(buf2)) {
        for (let i = 0; i < buf2._bufs.length; i++) {
          this.append(buf2._bufs[i]);
        }
      } else {
        if (typeof buf2 === "number") {
          buf2 = buf2.toString();
        }
        this._appendBuffer(Buffer.from(buf2));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
      this._bufs.push(buf2);
      this.length += buf2.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer.from([search]);
      } else if (typeof search === "string") {
        search = Buffer.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer.isBuffer(search)) {
        search = Buffer.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol4];
    };
    module.exports = BufferList3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/src/rabin.js"(exports, module) {
    init_define_process();
    var Rabin = class {
      constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module.exports = Rabin;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@assemblyscript-loader-npm-0.9.4-e1857d0656-9.zip/node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@assemblyscript-loader-npm-0.9.4-e1857d0656-9.zip/node_modules/@assemblyscript/loader/index.js"(exports) {
    "use strict";
    init_define_process();
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length5 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length5 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length5));
      const parts = [];
      do {
        const last14 = U16[offset + CHUNKSIZE - 1];
        const size = last14 >= 55296 && last14 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length5 -= size;
      } while (length5 > CHUNKSIZE);
      return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length5));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table = rawExports.table;
      const alloc2 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length5 = str.length;
        const ptr = alloc2(length5 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i = 0, p = ptr >>> 1; i < length5; ++i)
          U16[p + i] = str.charCodeAt(i);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer2 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length5 = values.length;
        const buf2 = alloc2(length5 << align, ARRAYBUFFER_ID);
        const arr = alloc2(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length5 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length5;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length5; ++i)
            view[(buf2 >>> align) + i] = retain(values[i]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length5 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length5);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i = 0; i < len; i++)
          out[i] = input[i];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length5 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length5);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    async function instantiate(source, imports) {
      if (isResponse(source = await source))
        return instantiateStreaming(source, imports);
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        await WebAssembly.instantiate(
          source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
          imports
        )
      );
    }
    exports.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        new WebAssembly.Instance(
          source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
          imports
        )
      );
    }
    exports.instantiateSync = instantiateSync;
    async function instantiateStreaming(source, imports) {
      if (!WebAssembly.instantiateStreaming) {
        return instantiate(
          isResponse(source = await source) ? source.arrayBuffer() : source,
          imports
        );
      }
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        (await WebAssembly.instantiateStreaming(source, imports)).instance
      );
    }
    exports.instantiateStreaming = instantiateStreaming;
    function demangle(exports2, baseModule) {
      var module2 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports2["__argumentsLength"] ? function(length5) {
        exports2["__argumentsLength"].value = length5;
      } : exports2["__setArgumentsLength"] || exports2["__setargc"] || function() {
      };
      for (let internalName in exports2) {
        if (!Object.prototype.hasOwnProperty.call(exports2, internalName))
          continue;
        const elem = exports2[internalName];
        let parts = internalName.split(".");
        let curr = module2;
        while (parts.length > 1) {
          let part = parts.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name6 = parts[0];
        let hash3 = name6.indexOf("#");
        if (hash3 >= 0) {
          let className = name6.substring(0, hash3);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach(
                (name7) => Object.defineProperty(ctor, name7, Object.getOwnPropertyDescriptor(classElem, name7))
              );
            curr[className] = ctor;
          }
          name6 = name6.substring(hash3 + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name6)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name6 = name6.substring(4))) {
              let getter = exports2[internalName.replace("set:", "get:")];
              let setter = exports2[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name6, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value) {
                  setter(this[THIS], value);
                },
                enumerable: true
              });
            }
          } else {
            if (name6 === "constructor") {
              (curr[name6] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name6] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name6)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name6 = name6.substring(4))) {
              Object.defineProperty(curr, name6, {
                get: exports2[internalName.replace("set:", "get:")],
                set: exports2[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name6] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name6] = elem;
          }
        }
      }
      return module2;
    }
    exports.demangle = demangle;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/dist/rabin-wasm.js
var require_rabin_wasm = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/dist/rabin-wasm.js"(exports, module) {
    init_define_process();
    var { instantiate } = require_loader();
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(imp = {}) {
      if (!loadWebAssembly.supported)
        return null;
      var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
      return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
    }
    module.exports = loadWebAssembly;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/src/index.js
var require_src2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rabin-wasm-npm-0.1.5-beace71638-9.zip/node_modules/rabin-wasm/src/index.js"(exports, module) {
    init_define_process();
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm();
    var create8 = async (avg, min, max, windowSize, polynomial) => {
      const compiled = await getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    };
    module.exports = {
      Rabin,
      create: create8
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/sparse-array-npm-1.3.2-68af1fcbe5-9.zip/node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/sparse-array-npm-1.3.2-68af1fcbe5-9.zip/node_modules/sparse-array/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var BITS_PER_BYTE = 7;
    module.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last14 = this._data[this._data.length - 1];
          this._length = last14 ? last14[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last14;
        while (i < this.length && !found) {
          last14 = this.get(i);
          found = finder(last14);
          i++;
        }
        return found ? last14 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists2 = (byte & 1 << bitPos) > 0;
        if (!exists2) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes2 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes2.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes2.length - 1; i > 0; i--) {
          const value = bytes2[i];
          if (value === 0) {
            bytes2.pop();
          } else {
            break;
          }
        }
        return bytes2;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// ../../.yarn/unplugged/iso-constants-npm-0.1.2-c6917f1fbb/node_modules/iso-constants/index.browser.js
var require_index_browser = __commonJS({
  "../../.yarn/unplugged/iso-constants-npm-0.1.2-c6917f1fbb/node_modules/iso-constants/index.browser.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = {
      "RTLD_LAZY": 1,
      "RTLD_NOW": 2,
      "RTLD_GLOBAL": 8,
      "RTLD_LOCAL": 4,
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 48,
      "EADDRNOTAVAIL": 49,
      "EAFNOSUPPORT": 47,
      "EAGAIN": 35,
      "EALREADY": 37,
      "EBADF": 9,
      "EBADMSG": 94,
      "EBUSY": 16,
      "ECANCELED": 89,
      "ECHILD": 10,
      "ECONNABORTED": 53,
      "ECONNREFUSED": 61,
      "ECONNRESET": 54,
      "EDEADLK": 11,
      "EDESTADDRREQ": 39,
      "EDOM": 33,
      "EDQUOT": 69,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 65,
      "EIDRM": 90,
      "EILSEQ": 92,
      "EINPROGRESS": 36,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 56,
      "EISDIR": 21,
      "ELOOP": 62,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 40,
      "EMULTIHOP": 95,
      "ENAMETOOLONG": 63,
      "ENETDOWN": 50,
      "ENETRESET": 52,
      "ENETUNREACH": 51,
      "ENFILE": 23,
      "ENOBUFS": 55,
      "ENODATA": 96,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 77,
      "ENOLINK": 97,
      "ENOMEM": 12,
      "ENOMSG": 91,
      "ENOPROTOOPT": 42,
      "ENOSPC": 28,
      "ENOSR": 98,
      "ENOSTR": 99,
      "ENOSYS": 78,
      "ENOTCONN": 57,
      "ENOTDIR": 20,
      "ENOTEMPTY": 66,
      "ENOTSOCK": 38,
      "ENOTSUP": 45,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 102,
      "EOVERFLOW": 84,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 100,
      "EPROTONOSUPPORT": 43,
      "EPROTOTYPE": 41,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ESTALE": 70,
      "ETIME": 101,
      "ETIMEDOUT": 60,
      "ETXTBSY": 26,
      "EWOULDBLOCK": 35,
      "EXDEV": 18,
      "PRIORITY_LOW": 19,
      "PRIORITY_BELOW_NORMAL": 10,
      "PRIORITY_NORMAL": 0,
      "PRIORITY_ABOVE_NORMAL": -7,
      "PRIORITY_HIGH": -14,
      "PRIORITY_HIGHEST": -20,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGQUIT": 3,
      "SIGILL": 4,
      "SIGTRAP": 5,
      "SIGABRT": 6,
      "SIGIOT": 6,
      "SIGBUS": 10,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGUSR1": 30,
      "SIGSEGV": 11,
      "SIGUSR2": 31,
      "SIGPIPE": 13,
      "SIGALRM": 14,
      "SIGTERM": 15,
      "SIGCHLD": 20,
      "SIGCONT": 19,
      "SIGSTOP": 17,
      "SIGTSTP": 18,
      "SIGTTIN": 21,
      "SIGTTOU": 22,
      "SIGURG": 16,
      "SIGXCPU": 24,
      "SIGXFSZ": 25,
      "SIGVTALRM": 26,
      "SIGPROF": 27,
      "SIGWINCH": 28,
      "SIGIO": 23,
      "SIGINFO": 29,
      "SIGSYS": 12,
      "UV_FS_SYMLINK_DIR": 1,
      "UV_FS_SYMLINK_JUNCTION": 2,
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "UV_DIRENT_UNKNOWN": 0,
      "UV_DIRENT_FILE": 1,
      "UV_DIRENT_DIR": 2,
      "UV_DIRENT_LINK": 3,
      "UV_DIRENT_FIFO": 4,
      "UV_DIRENT_SOCKET": 5,
      "UV_DIRENT_CHAR": 6,
      "UV_DIRENT_BLOCK": 7,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFBLK": 24576,
      "S_IFIFO": 4096,
      "S_IFLNK": 40960,
      "S_IFSOCK": 49152,
      "O_CREAT": 512,
      "O_EXCL": 2048,
      "UV_FS_O_FILEMAP": 0,
      "O_NOCTTY": 131072,
      "O_TRUNC": 1024,
      "O_APPEND": 8,
      "O_DIRECTORY": 1048576,
      "O_NOFOLLOW": 256,
      "O_SYNC": 128,
      "O_DSYNC": 4194304,
      "O_SYMLINK": 2097152,
      "O_NONBLOCK": 4,
      "S_IRWXU": 448,
      "S_IRUSR": 256,
      "S_IWUSR": 128,
      "S_IXUSR": 64,
      "S_IRWXG": 56,
      "S_IRGRP": 32,
      "S_IWGRP": 16,
      "S_IXGRP": 8,
      "S_IRWXO": 7,
      "S_IROTH": 4,
      "S_IWOTH": 2,
      "S_IXOTH": 1,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_FS_COPYFILE_EXCL": 1,
      "COPYFILE_EXCL": 1,
      "UV_FS_COPYFILE_FICLONE": 2,
      "COPYFILE_FICLONE": 2,
      "UV_FS_COPYFILE_FICLONE_FORCE": 4,
      "COPYFILE_FICLONE_FORCE": 4,
      "OPENSSL_VERSION_NUMBER": 805306448,
      "SSL_OP_ALL": 2147485776,
      "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_RENEGOTIATION": 1073741824,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 0,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_NO_TLSv1_3": 536870912,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_PRIORITIZE_CHACHA": 2097152,
      "SSL_OP_SINGLE_DH_USE": 0,
      "SSL_OP_SINGLE_ECDH_USE": 0,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
      "SSL_OP_TLS_D5_BUG": 0,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_RSA": 1,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_EC": 2048,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "RSA_PSS_SALTLEN_DIGEST": -1,
      "RSA_PSS_SALTLEN_MAX_SIGN": -2,
      "RSA_PSS_SALTLEN_AUTO": -2,
      "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      "TLS1_VERSION": 769,
      "TLS1_1_VERSION": 770,
      "TLS1_2_VERSION": 771,
      "TLS1_3_VERSION": 772,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6,
      "defaultCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-to-buffer-npm-2.0.2-74be95e49e-9.zip/node_modules/it-to-buffer/index.js
var require_it_to_buffer = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-to-buffer-npm-2.0.2-74be95e49e-9.zip/node_modules/it-to-buffer/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    async function toBuffer3(stream) {
      let buffer2 = new Uint8Array(0);
      for await (const buf2 of stream) {
        buffer2 = uint8ArrayConcat([buffer2, buf2], buffer2.length + buf2.length);
      }
      return buffer2;
    }
    module.exports = toBuffer3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-first-npm-1.0.7-9da260833a-9.zip/node_modules/it-first/index.js
var require_it_first = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-first-npm-1.0.7-9da260833a-9.zip/node_modules/it-first/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var first10 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module.exports = first10;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-length-npm-1.0.4-64e9f668b3-9.zip/node_modules/it-length/index.js
var require_it_length = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-length-npm-1.0.4-64e9f668b3-9.zip/node_modules/it-length/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var length5 = async (iterator) => {
      let count = 0;
      for await (const _ of iterator) {
        count++;
      }
      return count;
    };
    module.exports = length5;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/fnv1a-npm-1.1.1-0de9ebf284-9.zip/node_modules/fnv1a/index.js
var require_fnv1a = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/fnv1a-npm-1.1.1-0de9ebf284-9.zip/node_modules/fnv1a/index.js"(exports, module) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    hash3.BASE = 2166136261;
    function hash3(s, h = hash3.BASE) {
      const l = s.length;
      for (let i = 0; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    exports.default = hash3;
    module.exports = hash3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/bytes-npm-3.1.2-28b8643004-9.zip/node_modules/bytes/index.js
var require_bytes = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/bytes-npm-3.1.2-28b8643004-9.zip/node_modules/bytes/index.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = bytes2;
    module.exports.format = format;
    module.exports.parse = parse2;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map18 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse2(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map18[unit.toLowerCase()]) {
        if (mag >= map18.pb) {
          unit = "PB";
        } else if (mag >= map18.tb) {
          unit = "TB";
        } else if (mag >= map18.gb) {
          unit = "GB";
        } else if (mag >= map18.mb) {
          unit = "MB";
        } else if (mag >= map18.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map18[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse2(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map18[unit] * floatValue);
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-sort-npm-1.0.1-ca7e5563dd-9.zip/node_modules/it-sort/index.js
var require_it_sort = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-sort-npm-1.0.1-ca7e5563dd-9.zip/node_modules/it-sort/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var all11 = require_it_all();
    var sort5 = async function* (source, sorter) {
      const arr = await all11(source);
      yield* arr.sort(sorter);
    };
    module.exports = sort5;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-supports-npm-4.0.1-78eaf0b919-9.zip/node_modules/level-supports/index.js
var require_level_supports = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-supports-npm-4.0.1-78eaf0b919-9.zip/node_modules/level-supports/index.js"(exports) {
    "use strict";
    init_define_process();
    exports.supports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: Object.assign({}, manifest.encodings),
        events: Object.assign({}, manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/module-error-npm-1.0.2-4f8221ee3c-9.zip/node_modules/module-error/index.js
var require_module_error = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/module-error-npm-1.0.2-4f8221ee3c-9.zip/node_modules/module-error/index.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = class ModuleError extends Error {
      constructor(message2, options) {
        super(message2 || "");
        if (typeof options === "object" && options !== null) {
          if (options.code)
            this.code = String(options.code);
          if (options.expected)
            this.expected = true;
          if (options.transient)
            this.transient = true;
          if (options.cause)
            this.cause = options.cause;
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/text-endec.js
var require_text_endec = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/text-endec.js"(exports, module) {
    "use strict";
    init_define_process();
    var lazy = null;
    module.exports = function() {
      if (lazy === null) {
        lazy = {
          textEncoder: new TextEncoder(),
          textDecoder: new TextDecoder()
        };
      }
      return lazy;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/encoding.js
var require_encoding = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/encoding.js"(exports) {
    "use strict";
    init_define_process();
    var ModuleError = require_module_error();
    var formats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Encoding = class {
      constructor(options) {
        this.encode = options.encode || this.encode;
        this.decode = options.decode || this.decode;
        this.name = options.name || this.name;
        this.format = options.format || this.format;
        if (typeof this.encode !== "function") {
          throw new TypeError("The 'encode' property must be a function");
        }
        if (typeof this.decode !== "function") {
          throw new TypeError("The 'decode' property must be a function");
        }
        this.encode = this.encode.bind(this);
        this.decode = this.decode.bind(this);
        if (typeof this.name !== "string" || this.name === "") {
          throw new TypeError("The 'name' property must be a string");
        }
        if (typeof this.format !== "string" || !formats.has(this.format)) {
          throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
        }
        if (options.createViewTranscoder) {
          this.createViewTranscoder = options.createViewTranscoder;
        }
        if (options.createBufferTranscoder) {
          this.createBufferTranscoder = options.createBufferTranscoder;
        }
        if (options.createUTF8Transcoder) {
          this.createUTF8Transcoder = options.createUTF8Transcoder;
        }
      }
      get commonName() {
        return this.name.split("+")[0];
      }
      createBufferTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      createViewTranscoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
      createUTF8Transcoder() {
        throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
          code: "LEVEL_ENCODING_NOT_SUPPORTED"
        });
      }
    };
    exports.Encoding = Encoding;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/formats.js
var require_formats = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/formats.js"(exports) {
    "use strict";
    init_define_process();
    var { Buffer } = require_buffer() || {};
    var { Encoding } = require_encoding();
    var textEndec = require_text_endec();
    var BufferFormat = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "buffer" });
      }
      createViewTranscoder() {
        return new ViewFormat({
          encode: this.encode,
          decode: (data) => this.decode(
            Buffer.from(data.buffer, data.byteOffset, data.byteLength)
          ),
          name: `${this.name}+view`
        });
      }
      createBufferTranscoder() {
        return this;
      }
    };
    var ViewFormat = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "view" });
      }
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => {
            const view = this.encode(data);
            return Buffer.from(view.buffer, view.byteOffset, view.byteLength);
          },
          decode: this.decode,
          name: `${this.name}+buffer`
        });
      }
      createViewTranscoder() {
        return this;
      }
    };
    var UTF8Format = class extends Encoding {
      constructor(options) {
        super({ ...options, format: "utf8" });
      }
      createBufferTranscoder() {
        return new BufferFormat({
          encode: (data) => Buffer.from(this.encode(data), "utf8"),
          decode: (data) => this.decode(data.toString("utf8")),
          name: `${this.name}+buffer`
        });
      }
      createViewTranscoder() {
        const { textEncoder: textEncoder4, textDecoder: textDecoder3 } = textEndec();
        return new ViewFormat({
          encode: (data) => textEncoder4.encode(this.encode(data)),
          decode: (data) => this.decode(textDecoder3.decode(data)),
          name: `${this.name}+view`
        });
      }
      createUTF8Transcoder() {
        return this;
      }
    };
    exports.BufferFormat = BufferFormat;
    exports.ViewFormat = ViewFormat;
    exports.UTF8Format = UTF8Format;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/encodings.js
var require_encodings = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/lib/encodings.js"(exports) {
    "use strict";
    init_define_process();
    var { Buffer } = require_buffer() || { Buffer: { isBuffer: () => false } };
    var { textEncoder: textEncoder4, textDecoder: textDecoder3 } = require_text_endec()();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var identity2 = (v) => v;
    exports.utf8 = new UTF8Format({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder3.decode(data) : String(data);
      },
      decode: identity2,
      name: "utf8",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : textEncoder4.encode(data);
          },
          decode: function(data) {
            return textDecoder3.decode(data);
          },
          name: `${this.name}+view`
        });
      },
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
          },
          decode: function(data) {
            return data.toString("utf8");
          },
          name: `${this.name}+buffer`
        });
      }
    });
    exports.json = new UTF8Format({
      encode: JSON.stringify,
      decode: JSON.parse,
      name: "json"
    });
    exports.buffer = new BufferFormat({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
      },
      decode: identity2,
      name: "buffer",
      createViewTranscoder() {
        return new ViewFormat({
          encode: function(data) {
            return ArrayBuffer.isView(data) ? data : Buffer.from(String(data), "utf8");
          },
          decode: function(data) {
            return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          },
          name: `${this.name}+view`
        });
      }
    });
    exports.view = new ViewFormat({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder4.encode(data);
      },
      decode: identity2,
      name: "view",
      createBufferTranscoder() {
        return new BufferFormat({
          encode: function(data) {
            return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
          },
          decode: identity2,
          name: `${this.name}+buffer`
        });
      }
    });
    exports.hex = new BufferFormat({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data : Buffer.from(String(data), "hex");
      },
      decode: function(buffer2) {
        return buffer2.toString("hex");
      },
      name: "hex"
    });
    exports.base64 = new BufferFormat({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data : Buffer.from(String(data), "base64");
      },
      decode: function(buffer2) {
        return buffer2.toString("base64");
      },
      name: "base64"
    });
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/index.js
var require_level_transcoder = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-transcoder-npm-1.0.1-8821d7bed1-9.zip/node_modules/level-transcoder/index.js"(exports) {
    "use strict";
    init_define_process();
    var ModuleError = require_module_error();
    var encodings = require_encodings();
    var { Encoding } = require_encoding();
    var { BufferFormat, ViewFormat, UTF8Format } = require_formats();
    var kFormats = Symbol("formats");
    var kEncodings = Symbol("encodings");
    var validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
    var Transcoder = class {
      constructor(formats) {
        if (!Array.isArray(formats)) {
          throw new TypeError("The first argument 'formats' must be an array");
        } else if (!formats.every((f) => validFormats.has(f))) {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
        this[kEncodings] = /* @__PURE__ */ new Map();
        this[kFormats] = new Set(formats);
        for (const k in encodings) {
          try {
            this.encoding(k);
          } catch (err2) {
            if (err2.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
              throw err2;
          }
        }
      }
      encodings() {
        return Array.from(new Set(this[kEncodings].values()));
      }
      encoding(encoding) {
        let resolved = this[kEncodings].get(encoding);
        if (resolved === void 0) {
          if (typeof encoding === "string" && encoding !== "") {
            resolved = lookup[encoding];
            if (!resolved) {
              throw new ModuleError(`Encoding '${encoding}' is not found`, {
                code: "LEVEL_ENCODING_NOT_FOUND"
              });
            }
          } else if (typeof encoding !== "object" || encoding === null) {
            throw new TypeError("First argument 'encoding' must be a string or object");
          } else {
            resolved = from2(encoding);
          }
          const { name: name6, format } = resolved;
          if (!this[kFormats].has(format)) {
            if (this[kFormats].has("view")) {
              resolved = resolved.createViewTranscoder();
            } else if (this[kFormats].has("buffer")) {
              resolved = resolved.createBufferTranscoder();
            } else if (this[kFormats].has("utf8")) {
              resolved = resolved.createUTF8Transcoder();
            } else {
              throw new ModuleError(`Encoding '${name6}' cannot be transcoded`, {
                code: "LEVEL_ENCODING_NOT_SUPPORTED"
              });
            }
          }
          for (const k of [encoding, name6, resolved.name, resolved.commonName]) {
            this[kEncodings].set(k, resolved);
          }
        }
        return resolved;
      }
    };
    exports.Transcoder = Transcoder;
    function from2(options) {
      if (options instanceof Encoding) {
        return options;
      }
      const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
      const name6 = options.name || maybeType || `anonymous-${anonymousCount++}`;
      switch (detectFormat(options)) {
        case "view":
          return new ViewFormat({ ...options, name: name6 });
        case "utf8":
          return new UTF8Format({ ...options, name: name6 });
        case "buffer":
          return new BufferFormat({ ...options, name: name6 });
        default: {
          throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
        }
      }
    }
    function detectFormat(options) {
      if ("format" in options && options.format !== void 0) {
        return options.format;
      } else if ("buffer" in options && typeof options.buffer === "boolean") {
        return options.buffer ? "buffer" : "utf8";
      } else if ("code" in options && Number.isInteger(options.code)) {
        return "view";
      } else {
        return "buffer";
      }
    }
    var aliases = {
      binary: encodings.buffer,
      "utf-8": encodings.utf8
    };
    var lookup = {
      ...encodings,
      ...aliases
    };
    var anonymousCount = 0;
  }
});

// js/events/events.js
var require_events = __commonJS({
  "js/events/events.js"(exports, module) {
    "use strict";
    init_define_process();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter6() {
      EventEmitter6.init.call(this);
    }
    module.exports = EventEmitter6;
    module.exports.once = once;
    EventEmitter6.EventEmitter = EventEmitter6;
    EventEmitter6.prototype._events = void 0;
    EventEmitter6.prototype._eventsCount = 0;
    EventEmitter6.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter6, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter6.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter6.prototype.setMaxListeners = function setMaxListeners13(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter6.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter6.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter6.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter6.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter6.prototype.on = EventEmitter6.prototype.addListener;
    EventEmitter6.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter6.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter6.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter6.prototype.off = EventEmitter6.prototype.removeListener;
    EventEmitter6.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap3) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter6.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter6.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter6.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter6.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter6.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name6) {
      return new Promise(function(resolve7, reject) {
        function errorListener(err2) {
          emitter.removeListener(name6, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve7([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name6, resolver, { once: true });
        if (name6 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name6, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name6, listener);
        } else {
          emitter.on(name6, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name6, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name6, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/catering-npm-2.1.1-b116dcdfef-9.zip/node_modules/catering/next-tick-browser.js
var require_next_tick_browser = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/catering-npm-2.1.1-b116dcdfef-9.zip/node_modules/catering/next-tick-browser.js"(exports, module) {
    init_define_process();
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/catering-npm-2.1.1-b116dcdfef-9.zip/node_modules/catering/index.js
var require_catering = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/catering-npm-2.1.1-b116dcdfef-9.zip/node_modules/catering/index.js"(exports) {
    "use strict";
    init_define_process();
    var nextTick = require_next_tick_browser();
    exports.fromCallback = function(callback, symbol4) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve7, reject) {
          callback = function(err2, res) {
            if (err2)
              reject(err2);
            else
              resolve7(res);
          };
        });
        callback[symbol4 !== void 0 ? symbol4 : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        nextTick(() => callback(null, res));
      }).catch(function(err2) {
        nextTick(() => callback(err2));
      });
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/common.js
var require_common = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/common.js"(exports) {
    "use strict";
    init_define_process();
    exports.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports.getOptions = function(options, def2) {
      if (typeof options === "object" && options !== null) {
        return options;
      }
      if (def2 !== void 0) {
        return def2;
      }
      return {};
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-iterator.js"(exports) {
    "use strict";
    init_define_process();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getOptions, getCallback } = require_common();
    var kPromise = Symbol("promise");
    var kCallback = Symbol("callback");
    var kWorking = Symbol("working");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kAutoClose = Symbol("autoClose");
    var kFinishWork = Symbol("finishWork");
    var kReturnMany = Symbol("returnMany");
    var kClosing = Symbol("closing");
    var kHandleClose = Symbol("handleClose");
    var kClosed = Symbol("closed");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var kAbortOnClose = Symbol("abortOnClose");
    var kLegacy = Symbol("legacy");
    var kKeys = Symbol("keys");
    var kValues = Symbol("values");
    var kLimit = Symbol("limit");
    var kCount = Symbol("count");
    var emptyOptions = Object.freeze({});
    var noop3 = () => {
    };
    var warnedEnd = false;
    var CommonIterator = class {
      constructor(db, options, legacy) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError("The second argument must be an options object");
        }
        this[kClosed] = false;
        this[kCloseCallbacks] = [];
        this[kWorking] = false;
        this[kClosing] = false;
        this[kAutoClose] = false;
        this[kCallback] = null;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kHandleClose] = this[kHandleClose].bind(this);
        this[kKeyEncoding] = options[kKeyEncoding];
        this[kValueEncoding] = options[kValueEncoding];
        this[kLegacy] = legacy;
        this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
        this[kCount] = 0;
        this[kAbortOnClose] = !!options.abortOnClose;
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get count() {
        return this[kCount];
      }
      get limit() {
        return this[kLimit];
      }
      next(callback) {
        let promise;
        if (callback === void 0) {
          promise = new Promise((resolve7, reject) => {
            callback = (err2, key, value) => {
              if (err2)
                reject(err2);
              else if (!this[kLegacy])
                resolve7(key);
              else if (key === void 0 && value === void 0)
                resolve7();
              else
                resolve7([key, value]);
            };
          });
        } else if (typeof callback !== "function") {
          throw new TypeError("Callback must be a function");
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call next() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleOne], null);
          else
            this._next(this[kHandleOne]);
        }
        return promise;
      }
      _next(callback) {
        this.nextTick(callback);
      }
      nextv(size, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (!Number.isInteger(size)) {
          this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
          return callback[kPromise];
        }
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call nextv() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          if (size < 1)
            size = 1;
          if (this[kLimit] < Infinity)
            size = Math.min(size, this[kLimit] - this[kCount]);
          this[kWorking] = true;
          this[kCallback] = callback;
          if (size <= 0)
            this.nextTick(this[kHandleMany], null, []);
          else
            this._nextv(size, options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _nextv(size, options, callback) {
        const acc = [];
        const onnext = (err2, key, value) => {
          if (err2) {
            return callback(err2);
          } else if (this[kLegacy] ? key === void 0 && value === void 0 : key === void 0) {
            return callback(null, acc);
          }
          acc.push(this[kLegacy] ? [key, value] : key);
          if (acc.length === size) {
            callback(null, acc);
          } else {
            this._next(onnext);
          }
        };
        this._next(onnext);
      }
      all(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        } else if (this[kWorking]) {
          this.nextTick(callback, new ModuleError("Iterator is busy: cannot call all() until previous call has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          }));
        } else {
          this[kWorking] = true;
          this[kCallback] = callback;
          this[kAutoClose] = true;
          if (this[kCount] >= this[kLimit])
            this.nextTick(this[kHandleMany], null, []);
          else
            this._all(options, this[kHandleMany]);
        }
        return callback[kPromise];
      }
      _all(options, callback) {
        let count = this[kCount];
        const acc = [];
        const nextv = () => {
          const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
          if (size <= 0) {
            this.nextTick(callback, null, acc);
          } else {
            this._nextv(size, emptyOptions, onnextv);
          }
        };
        const onnextv = (err2, items) => {
          if (err2) {
            callback(err2);
          } else if (items.length === 0) {
            callback(null, acc);
          } else {
            acc.push.apply(acc, items);
            count += items.length;
            nextv();
          }
        };
        nextv();
      }
      [kFinishWork]() {
        const cb = this[kCallback];
        if (this[kAbortOnClose] && cb === null)
          return noop3;
        this[kWorking] = false;
        this[kCallback] = null;
        if (this[kClosing])
          this._close(this[kHandleClose]);
        return cb;
      }
      [kReturnMany](cb, err2, items) {
        if (this[kAutoClose]) {
          this.close(cb.bind(null, err2, items));
        } else {
          cb(err2, items);
        }
      }
      seek(target, options) {
        options = getOptions(options, emptyOptions);
        if (this[kClosing]) {
        } else if (this[kWorking]) {
          throw new ModuleError("Iterator is busy: cannot call seek() until next() has completed", {
            code: "LEVEL_ITERATOR_BUSY"
          });
        } else {
          const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
          const keyFormat = keyEncoding.format;
          if (options.keyEncoding !== keyFormat) {
            options = { ...options, keyEncoding: keyFormat };
          }
          const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
          this._seek(mapped, options);
        }
      }
      _seek(target, options) {
        throw new ModuleError("Iterator does not support seek()", {
          code: "LEVEL_NOT_SUPPORTED"
        });
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kClosed]) {
          this.nextTick(callback);
        } else if (this[kClosing]) {
          this[kCloseCallbacks].push(callback);
        } else {
          this[kClosing] = true;
          this[kCloseCallbacks].push(callback);
          if (!this[kWorking]) {
            this._close(this[kHandleClose]);
          } else if (this[kAbortOnClose]) {
            const cb = this[kFinishWork]();
            cb(new ModuleError("Aborted on iterator close()", {
              code: "LEVEL_ITERATOR_NOT_OPEN"
            }));
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kHandleClose]() {
        this[kClosed] = true;
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
      async *[Symbol.asyncIterator]() {
        try {
          let item;
          while ((item = await this.next()) !== void 0) {
            yield item;
          }
        } finally {
          if (!this[kClosed])
            await this.close();
        }
      }
    };
    var AbstractIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, true);
        this[kKeys] = options.keys !== false;
        this[kValues] = options.values !== false;
      }
      [kHandleOne](err2, key, value) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          value = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("entry", err3));
        }
        if (!(key === void 0 && value === void 0)) {
          this[kCount]++;
        }
        cb(null, key, value);
      }
      [kHandleMany](err2, entries) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (const entry of entries) {
            const key = entry[0];
            const value = entry[1];
            entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
            entry[1] = this[kValues] && value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("entries", err3));
        }
        this[kCount] += entries.length;
        this[kReturnMany](cb, null, entries);
      }
      end(callback) {
        if (!warnedEnd && typeof console !== "undefined") {
          warnedEnd = true;
          console.warn(new ModuleError(
            "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
            { code: "LEVEL_LEGACY" }
          ));
        }
        return this.close(callback);
      }
    };
    var AbstractKeyIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, key) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          key = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("key", err3));
        }
        if (key !== void 0)
          this[kCount]++;
        cb(null, key);
      }
      [kHandleMany](err2, keys) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            keys[i] = key !== void 0 ? this[kKeyEncoding].decode(key) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("keys", err3));
        }
        this[kCount] += keys.length;
        this[kReturnMany](cb, null, keys);
      }
    };
    var AbstractValueIterator = class extends CommonIterator {
      constructor(db, options) {
        super(db, options, false);
      }
      [kHandleOne](err2, value) {
        const cb = this[kFinishWork]();
        if (err2)
          return cb(err2);
        try {
          value = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
        } catch (err3) {
          return cb(new IteratorDecodeError("value", err3));
        }
        if (value !== void 0)
          this[kCount]++;
        cb(null, value);
      }
      [kHandleMany](err2, values) {
        const cb = this[kFinishWork]();
        if (err2)
          return this[kReturnMany](cb, err2);
        try {
          for (let i = 0; i < values.length; i++) {
            const value = values[i];
            values[i] = value !== void 0 ? this[kValueEncoding].decode(value) : void 0;
          }
        } catch (err3) {
          return this[kReturnMany](cb, new IteratorDecodeError("values", err3));
        }
        this[kCount] += values.length;
        this[kReturnMany](cb, null, values);
      }
    };
    var IteratorDecodeError = class extends ModuleError {
      constructor(subject, cause) {
        super(`Iterator could not decode ${subject}`, {
          code: "LEVEL_DECODE_ERROR",
          cause
        });
      }
    };
    for (const k of ["_ended property", "_nexting property", "_end method"]) {
      Object.defineProperty(AbstractIterator.prototype, k.split(" ")[0], {
        get() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        },
        set() {
          throw new ModuleError(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
        }
      });
    }
    AbstractIterator.keyEncoding = kKeyEncoding;
    AbstractIterator.valueEncoding = kValueEncoding;
    exports.AbstractIterator = AbstractIterator;
    exports.AbstractKeyIterator = AbstractKeyIterator;
    exports.AbstractValueIterator = AbstractValueIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/default-kv-iterator.js
var require_default_kv_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/default-kv-iterator.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kIterator = Symbol("iterator");
    var kCallback = Symbol("callback");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var DefaultKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: true, values: false });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    var DefaultValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kIterator] = db.iterator({ ...options, keys: false, values: true });
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
      }
    };
    for (const Iterator of [DefaultKeyIterator, DefaultValueIterator]) {
      const keys = Iterator === DefaultKeyIterator;
      const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype[kHandleOne] = function(err2, key, value) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, keys ? key : value);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
      Iterator.prototype[kHandleMany] = function(err2, entries) {
        const callback = this[kCallback];
        if (err2)
          callback(err2);
        else
          callback(null, entries.map(mapEntry));
      };
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports.DefaultKeyIterator = DefaultKeyIterator;
    exports.DefaultValueIterator = DefaultValueIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/deferred-iterator.js
var require_deferred_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/deferred-iterator.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var ModuleError = require_module_error();
    var kNut = Symbol("nut");
    var kUndefer = Symbol("undefer");
    var kFactory = Symbol("factory");
    var DeferredIterator = class extends AbstractIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.iterator(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.keys(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    var DeferredValueIterator = class extends AbstractValueIterator {
      constructor(db, options) {
        super(db, options);
        this[kNut] = null;
        this[kFactory] = () => db.values(options);
        this.db.defer(() => this[kUndefer]());
      }
    };
    for (const Iterator of [DeferredIterator, DeferredKeyIterator, DeferredValueIterator]) {
      Iterator.prototype[kUndefer] = function() {
        if (this.db.status === "open") {
          this[kNut] = this[kFactory]();
        }
      };
      Iterator.prototype._next = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].next(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._next(callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call next() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        if (this[kNut] !== null) {
          this[kNut].nextv(size, options, callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._nextv(size, options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call nextv() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._all = function(options, callback) {
        if (this[kNut] !== null) {
          this[kNut].all(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._all(options, callback));
        } else {
          this.nextTick(callback, new ModuleError("Iterator is not open: cannot call all() after close()", {
            code: "LEVEL_ITERATOR_NOT_OPEN"
          }));
        }
      };
      Iterator.prototype._seek = function(target, options) {
        if (this[kNut] !== null) {
          this[kNut]._seek(target, options);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._seek(target, options));
        }
      };
      Iterator.prototype._close = function(callback) {
        if (this[kNut] !== null) {
          this[kNut].close(callback);
        } else if (this.db.status === "opening") {
          this.db.defer(() => this._close(callback));
        } else {
          this.nextTick(callback);
        }
      };
    }
    exports.DeferredIterator = DeferredIterator;
    exports.DeferredKeyIterator = DeferredKeyIterator;
    exports.DeferredValueIterator = DeferredValueIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-chained-batch.js"(exports) {
    "use strict";
    init_define_process();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { getCallback, getOptions } = require_common();
    var kPromise = Symbol("promise");
    var kStatus = Symbol("status");
    var kOperations = Symbol("operations");
    var kFinishClose = Symbol("finishClose");
    var kCloseCallbacks = Symbol("closeCallbacks");
    var AbstractChainedBatch = class {
      constructor(db) {
        if (typeof db !== "object" || db === null) {
          const hint = db === null ? "null" : typeof db;
          throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
        }
        this[kOperations] = [];
        this[kCloseCallbacks] = [];
        this[kStatus] = "open";
        this[kFinishClose] = this[kFinishClose].bind(this);
        this.db = db;
        this.db.attachResource(this);
        this.nextTick = db.nextTick;
      }
      get length() {
        return this[kOperations].length;
      }
      put(key, value, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call put() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key) || this.db._checkValue(value);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const valueEncoding = db.valueEncoding(options && options.valueEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
        if (db !== this.db) {
          options.sublevel = null;
        }
        const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value);
        this._put(mappedKey, mappedValue, options);
        this[kOperations].push({ ...original, type: "put", key, value });
        return this;
      }
      _put(key, value, options) {
      }
      del(key, options) {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call del() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        const err2 = this.db._checkKey(key);
        if (err2)
          throw err2;
        const db = options && options.sublevel != null ? options.sublevel : this.db;
        const original = options;
        const keyEncoding = db.keyEncoding(options && options.keyEncoding);
        const keyFormat = keyEncoding.format;
        options = { ...options, keyEncoding: keyFormat };
        if (db !== this.db) {
          options.sublevel = null;
        }
        this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
        this[kOperations].push({ ...original, type: "del", key });
        return this;
      }
      _del(key, options) {
      }
      clear() {
        if (this[kStatus] !== "open") {
          throw new ModuleError("Batch is not open: cannot call clear() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          });
        }
        this._clear();
        this[kOperations] = [];
        return this;
      }
      _clear() {
      }
      write(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options);
        if (this[kStatus] !== "open") {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        } else if (this.length === 0) {
          this.close(callback);
        } else {
          this[kStatus] = "writing";
          this._write(options, (err2) => {
            this[kStatus] = "closing";
            this[kCloseCallbacks].push(() => callback(err2));
            if (!err2)
              this.db.emit("batch", this[kOperations]);
            this._close(this[kFinishClose]);
          });
        }
        return callback[kPromise];
      }
      _write(options, callback) {
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        if (this[kStatus] === "closing") {
          this[kCloseCallbacks].push(callback);
        } else if (this[kStatus] === "closed") {
          this.nextTick(callback);
        } else {
          this[kCloseCallbacks].push(callback);
          if (this[kStatus] !== "writing") {
            this[kStatus] = "closing";
            this._close(this[kFinishClose]);
          }
        }
        return callback[kPromise];
      }
      _close(callback) {
        this.nextTick(callback);
      }
      [kFinishClose]() {
        this[kStatus] = "closed";
        this.db.detachResource(this);
        const callbacks = this[kCloseCallbacks];
        this[kCloseCallbacks] = [];
        for (const cb of callbacks) {
          cb();
        }
      }
    };
    exports.AbstractChainedBatch = AbstractChainedBatch;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/default-chained-batch.js
var require_default_chained_batch = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/default-chained-batch.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractChainedBatch } = require_abstract_chained_batch();
    var ModuleError = require_module_error();
    var kEncoded = Symbol("encoded");
    var DefaultChainedBatch = class extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kEncoded] = [];
      }
      _put(key, value, options) {
        this[kEncoded].push({ ...options, type: "put", key, value });
      }
      _del(key, options) {
        this[kEncoded].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kEncoded] = [];
      }
      _write(options, callback) {
        if (this.db.status === "opening") {
          this.db.defer(() => this._write(options, callback));
        } else if (this.db.status === "open") {
          if (this[kEncoded].length === 0)
            this.nextTick(callback);
          else
            this.db._batch(this[kEncoded], options, callback);
        } else {
          this.nextTick(callback, new ModuleError("Batch is not open: cannot call write() after write() or close()", {
            code: "LEVEL_BATCH_NOT_OPEN"
          }));
        }
      }
    };
    exports.DefaultChainedBatch = DefaultChainedBatch;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/range-options.js
var require_range_options = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/range-options.js"(exports, module) {
    "use strict";
    init_define_process();
    var ModuleError = require_module_error();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var rangeOptions = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
    module.exports = function(options, keyEncoding) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty.call(options, k))
          continue;
        if (k === "keyEncoding" || k === "valueEncoding")
          continue;
        if (k === "start" || k === "end") {
          throw new ModuleError(`The legacy range option '${k}' has been removed`, {
            code: "LEVEL_LEGACY"
          });
        } else if (k === "encoding") {
          throw new ModuleError("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
            code: "LEVEL_LEGACY"
          });
        }
        if (rangeOptions.has(k)) {
          result[k] = keyEncoding.encode(options[k]);
        } else {
          result[k] = options[k];
        }
      }
      result.reverse = !!result.reverse;
      result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
      return result;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/queue-microtask-npm-1.2.3-fcc98e4e2d-9.zip/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/queue-microtask-npm-1.2.3-fcc98e4e2d-9.zip/node_modules/queue-microtask/index.js"(exports, module) {
    init_define_process();
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/next-tick-browser.js
var require_next_tick_browser2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/next-tick-browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var queueMicrotask2 = require_queue_microtask();
    module.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/abstract-sublevel-iterator.js
var require_abstract_sublevel_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/abstract-sublevel-iterator.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = require_abstract_iterator();
    var kUnfix = Symbol("unfix");
    var kIterator = Symbol("iterator");
    var kHandleOne = Symbol("handleOne");
    var kHandleMany = Symbol("handleMany");
    var kCallback = Symbol("callback");
    var AbstractSublevelIterator = class extends AbstractIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key, value) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key, value);
      }
      [kHandleMany](err2, entries) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (const entry of entries) {
          const key = entry[0];
          if (key !== void 0)
            entry[0] = this[kUnfix](key);
        }
        callback(err2, entries);
      }
    };
    var AbstractSublevelKeyIterator = class extends AbstractKeyIterator {
      constructor(db, options, iterator, unfix) {
        super(db, options);
        this[kIterator] = iterator;
        this[kUnfix] = unfix;
        this[kHandleOne] = this[kHandleOne].bind(this);
        this[kHandleMany] = this[kHandleMany].bind(this);
        this[kCallback] = null;
      }
      [kHandleOne](err2, key) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        if (key !== void 0)
          key = this[kUnfix](key);
        callback(err2, key);
      }
      [kHandleMany](err2, keys) {
        const callback = this[kCallback];
        if (err2)
          return callback(err2);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== void 0)
            keys[i] = this[kUnfix](key);
        }
        callback(err2, keys);
      }
    };
    var AbstractSublevelValueIterator = class extends AbstractValueIterator {
      constructor(db, options, iterator) {
        super(db, options);
        this[kIterator] = iterator;
      }
    };
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kCallback] = callback;
        this[kIterator].next(this[kHandleOne]);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kCallback] = callback;
        this[kIterator].nextv(size, options, this[kHandleMany]);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kCallback] = callback;
        this[kIterator].all(options, this[kHandleMany]);
      };
    }
    for (const Iterator of [AbstractSublevelValueIterator]) {
      Iterator.prototype._next = function(callback) {
        this[kIterator].next(callback);
      };
      Iterator.prototype._nextv = function(size, options, callback) {
        this[kIterator].nextv(size, options, callback);
      };
      Iterator.prototype._all = function(options, callback) {
        this[kIterator].all(options, callback);
      };
    }
    for (const Iterator of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
      Iterator.prototype._seek = function(target, options) {
        this[kIterator].seek(target, options);
      };
      Iterator.prototype._close = function(callback) {
        this[kIterator].close(callback);
      };
    }
    exports.AbstractSublevelIterator = AbstractSublevelIterator;
    exports.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
    exports.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/abstract-sublevel.js
var require_abstract_sublevel = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/lib/abstract-sublevel.js"(exports, module) {
    "use strict";
    init_define_process();
    var ModuleError = require_module_error();
    var { Buffer } = require_buffer() || {};
    var {
      AbstractSublevelIterator,
      AbstractSublevelKeyIterator,
      AbstractSublevelValueIterator
    } = require_abstract_sublevel_iterator();
    var kPrefix = Symbol("prefix");
    var kUpperBound = Symbol("upperBound");
    var kPrefixRange = Symbol("prefixRange");
    var kParent = Symbol("parent");
    var kUnfix = Symbol("unfix");
    var textEncoder4 = new TextEncoder();
    var defaults = { separator: "!" };
    module.exports = function({ AbstractLevel }) {
      class AbstractSublevel extends AbstractLevel {
        static defaults(options) {
          if (typeof options === "string") {
            throw new ModuleError("The subleveldown string shorthand for { separator } has been removed", {
              code: "LEVEL_LEGACY"
            });
          } else if (options && options.open) {
            throw new ModuleError("The subleveldown open option has been removed", {
              code: "LEVEL_LEGACY"
            });
          }
          if (options == null) {
            return defaults;
          } else if (!options.separator) {
            return { ...options, separator: "!" };
          } else {
            return options;
          }
        }
        constructor(db, name6, options) {
          const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
          name6 = trim(name6, separator);
          const reserved = separator.charCodeAt(0) + 1;
          const parent2 = db[kParent] || db;
          if (!textEncoder4.encode(name6).every((x) => x > reserved && x < 127)) {
            throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {
              code: "LEVEL_INVALID_PREFIX"
            });
          }
          super(mergeManifests(parent2, manifest), forward);
          const prefix = (db.prefix || "") + separator + name6 + separator;
          const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
          this[kParent] = parent2;
          this[kPrefix] = new MultiFormat(prefix);
          this[kUpperBound] = new MultiFormat(upperBound);
          this[kUnfix] = new Unfixer();
          this.nextTick = parent2.nextTick;
        }
        prefixKey(key, keyFormat) {
          if (keyFormat === "utf8") {
            return this[kPrefix].utf8 + key;
          } else if (key.byteLength === 0) {
            return this[kPrefix][keyFormat];
          } else if (keyFormat === "view") {
            const view = this[kPrefix].view;
            const result = new Uint8Array(view.byteLength + key.byteLength);
            result.set(view, 0);
            result.set(key, view.byteLength);
            return result;
          } else {
            const buffer2 = this[kPrefix].buffer;
            return Buffer.concat([buffer2, key], buffer2.byteLength + key.byteLength);
          }
        }
        [kPrefixRange](range, keyFormat) {
          if (range.gte !== void 0) {
            range.gte = this.prefixKey(range.gte, keyFormat);
          } else if (range.gt !== void 0) {
            range.gt = this.prefixKey(range.gt, keyFormat);
          } else {
            range.gte = this[kPrefix][keyFormat];
          }
          if (range.lte !== void 0) {
            range.lte = this.prefixKey(range.lte, keyFormat);
          } else if (range.lt !== void 0) {
            range.lt = this.prefixKey(range.lt, keyFormat);
          } else {
            range.lte = this[kUpperBound][keyFormat];
          }
        }
        get prefix() {
          return this[kPrefix].utf8;
        }
        get db() {
          return this[kParent];
        }
        _open(options, callback) {
          this[kParent].open({ passive: true }, callback);
        }
        _put(key, value, options, callback) {
          this[kParent].put(key, value, options, callback);
        }
        _get(key, options, callback) {
          this[kParent].get(key, options, callback);
        }
        _getMany(keys, options, callback) {
          this[kParent].getMany(keys, options, callback);
        }
        _del(key, options, callback) {
          this[kParent].del(key, options, callback);
        }
        _batch(operations, options, callback) {
          this[kParent].batch(operations, options, callback);
        }
        _clear(options, callback) {
          this[kPrefixRange](options, options.keyEncoding);
          this[kParent].clear(options, callback);
        }
        _iterator(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].iterator(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelIterator(this, options, iterator, unfix);
        }
        _keys(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].keys(options);
          const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
          return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
        }
        _values(options) {
          this[kPrefixRange](options, options.keyEncoding);
          const iterator = this[kParent].values(options);
          return new AbstractSublevelValueIterator(this, options, iterator);
        }
      }
      return { AbstractSublevel };
    };
    var mergeManifests = function(parent2, manifest) {
      return {
        ...parent2.supports,
        createIfMissing: false,
        errorIfExists: false,
        events: {},
        additionalMethods: {},
        ...manifest,
        encodings: {
          utf8: supportsEncoding(parent2, "utf8"),
          buffer: supportsEncoding(parent2, "buffer"),
          view: supportsEncoding(parent2, "view")
        }
      };
    };
    var supportsEncoding = function(parent2, encoding) {
      return parent2.supports.encodings[encoding] ? parent2.keyEncoding(encoding).name === encoding : false;
    };
    var MultiFormat = class {
      constructor(key) {
        this.utf8 = key;
        this.view = textEncoder4.encode(key);
        this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {};
      }
    };
    var Unfixer = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(prefixLength, keyFormat) {
        let unfix = this.cache.get(keyFormat);
        if (unfix === void 0) {
          if (keyFormat === "view") {
            unfix = function(prefixLength2, key) {
              return key.subarray(prefixLength2);
            }.bind(null, prefixLength);
          } else {
            unfix = function(prefixLength2, key) {
              return key.slice(prefixLength2);
            }.bind(null, prefixLength);
          }
          this.cache.set(keyFormat, unfix);
        }
        return unfix;
      }
    };
    var trim = function(str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char)
        start++;
      while (end > start && str[end - 1] === char)
        end--;
      return str.slice(start, end);
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-level.js
var require_abstract_level = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/abstract-level.js"(exports) {
    "use strict";
    init_define_process();
    var { supports } = require_level_supports();
    var { Transcoder } = require_level_transcoder();
    var { EventEmitter: EventEmitter6 } = require_events();
    var { fromCallback } = require_catering();
    var ModuleError = require_module_error();
    var { AbstractIterator } = require_abstract_iterator();
    var { DefaultKeyIterator, DefaultValueIterator } = require_default_kv_iterator();
    var { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require_deferred_iterator();
    var { DefaultChainedBatch } = require_default_chained_batch();
    var { getCallback, getOptions } = require_common();
    var rangeOptions = require_range_options();
    var kPromise = Symbol("promise");
    var kLanded = Symbol("landed");
    var kResources = Symbol("resources");
    var kCloseResources = Symbol("closeResources");
    var kOperations = Symbol("operations");
    var kUndefer = Symbol("undefer");
    var kDeferOpen = Symbol("deferOpen");
    var kOptions = Symbol("options");
    var kStatus = Symbol("status");
    var kDefaultOptions = Symbol("defaultOptions");
    var kTranscoder = Symbol("transcoder");
    var kKeyEncoding = Symbol("keyEncoding");
    var kValueEncoding = Symbol("valueEncoding");
    var noop3 = () => {
    };
    var AbstractLevel = class extends EventEmitter6 {
      constructor(manifest, options) {
        super();
        if (typeof manifest !== "object" || manifest === null) {
          throw new TypeError("The first argument 'manifest' must be an object");
        }
        options = getOptions(options);
        const { keyEncoding, valueEncoding, passive, ...forward } = options;
        this[kResources] = /* @__PURE__ */ new Set();
        this[kOperations] = [];
        this[kDeferOpen] = true;
        this[kOptions] = forward;
        this[kStatus] = "opening";
        this.supports = supports(manifest, {
          status: true,
          promises: true,
          clear: true,
          getMany: true,
          deferredOpen: true,
          snapshots: manifest.snapshots !== false,
          permanence: manifest.permanence !== false,
          keyIterator: true,
          valueIterator: true,
          iteratorNextv: true,
          iteratorAll: true,
          encodings: manifest.encodings || {},
          events: Object.assign({}, manifest.events, {
            opening: true,
            open: true,
            closing: true,
            closed: true,
            put: true,
            del: true,
            batch: true,
            clear: true
          })
        });
        this[kTranscoder] = new Transcoder(formats(this));
        this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
        this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
        for (const encoding of this[kTranscoder].encodings()) {
          if (!this.supports.encodings[encoding.commonName]) {
            this.supports.encodings[encoding.commonName] = true;
          }
        }
        this[kDefaultOptions] = {
          empty: Object.freeze({}),
          entry: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName,
            valueEncoding: this[kValueEncoding].commonName
          }),
          key: Object.freeze({
            keyEncoding: this[kKeyEncoding].commonName
          })
        };
        this.nextTick(() => {
          if (this[kDeferOpen]) {
            this.open({ passive: false }, noop3);
          }
        });
      }
      get status() {
        return this[kStatus];
      }
      keyEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
      }
      valueEncoding(encoding) {
        return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
      }
      open(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = { ...this[kOptions], ...getOptions(options) };
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        const maybeOpened = (err2) => {
          if (this[kStatus] === "closing" || this[kStatus] === "opening") {
            this.once(kLanded, err2 ? () => maybeOpened(err2) : maybeOpened);
          } else if (this[kStatus] !== "open") {
            callback(new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (options.passive) {
          if (this[kStatus] === "opening") {
            this.once(kLanded, maybeOpened);
          } else {
            this.nextTick(maybeOpened);
          }
        } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
          this[kDeferOpen] = false;
          this[kStatus] = "opening";
          this.emit("opening");
          this._open(options, (err2) => {
            if (err2) {
              this[kStatus] = "closed";
              this[kCloseResources](() => {
                this.emit(kLanded);
                maybeOpened(err2);
              });
              this[kUndefer]();
              return;
            }
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            if (this[kStatus] === "open")
              this.emit("open");
            if (this[kStatus] === "open")
              this.emit("ready");
            maybeOpened();
          });
        } else if (this[kStatus] === "open") {
          this.nextTick(maybeOpened);
        } else {
          this.once(kLanded, () => this.open(options, callback));
        }
        return callback[kPromise];
      }
      _open(options, callback) {
        this.nextTick(callback);
      }
      close(callback) {
        callback = fromCallback(callback, kPromise);
        const maybeClosed = (err2) => {
          if (this[kStatus] === "opening" || this[kStatus] === "closing") {
            this.once(kLanded, err2 ? maybeClosed(err2) : maybeClosed);
          } else if (this[kStatus] !== "closed") {
            callback(new ModuleError("Database is not closed", {
              code: "LEVEL_DATABASE_NOT_CLOSED",
              cause: err2
            }));
          } else {
            callback();
          }
        };
        if (this[kStatus] === "open") {
          this[kStatus] = "closing";
          this.emit("closing");
          const cancel = (err2) => {
            this[kStatus] = "open";
            this[kUndefer]();
            this.emit(kLanded);
            maybeClosed(err2);
          };
          this[kCloseResources](() => {
            this._close((err2) => {
              if (err2)
                return cancel(err2);
              this[kStatus] = "closed";
              this[kUndefer]();
              this.emit(kLanded);
              if (this[kStatus] === "closed")
                this.emit("closed");
              maybeClosed();
            });
          });
        } else if (this[kStatus] === "closed") {
          this.nextTick(maybeClosed);
        } else {
          this.once(kLanded, () => this.close(callback));
        }
        return callback[kPromise];
      }
      [kCloseResources](callback) {
        if (this[kResources].size === 0) {
          return this.nextTick(callback);
        }
        let pending = this[kResources].size;
        let sync = true;
        const next = () => {
          if (--pending === 0) {
            if (sync)
              this.nextTick(callback);
            else
              callback();
          }
        };
        for (const resource of this[kResources]) {
          resource.close(next);
        }
        sync = false;
        this[kResources].clear();
      }
      _close(callback) {
        this.nextTick(callback);
      }
      get(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.get(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3, value) => {
          if (err3) {
            if (err3.code === "LEVEL_NOT_FOUND" || err3.notFound || /NotFound/i.test(err3)) {
              if (!err3.code)
                err3.code = "LEVEL_NOT_FOUND";
              if (!err3.notFound)
                err3.notFound = true;
              if (!err3.status)
                err3.status = 404;
            }
            return callback(err3);
          }
          try {
            value = valueEncoding.decode(value);
          } catch (err4) {
            return callback(new ModuleError("Could not decode value", {
              code: "LEVEL_DECODE_ERROR",
              cause: err4
            }));
          }
          callback(null, value);
        });
        return callback[kPromise];
      }
      _get(key, options, callback) {
        this.nextTick(callback, new Error("NotFound"));
      }
      getMany(keys, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.getMany(keys, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(keys)) {
          this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
          return callback[kPromise];
        }
        if (keys.length === 0) {
          this.nextTick(callback, null, []);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKeys = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const err2 = this._checkKey(key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);
        }
        this._getMany(mappedKeys, options, (err2, values) => {
          if (err2)
            return callback(err2);
          try {
            for (let i = 0; i < values.length; i++) {
              if (values[i] !== void 0) {
                values[i] = valueEncoding.decode(values[i]);
              }
            }
          } catch (err3) {
            return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
              code: "LEVEL_DECODE_ERROR",
              cause: err3
            }));
          }
          callback(null, values);
        });
        return callback[kPromise];
      }
      _getMany(keys, options, callback) {
        this.nextTick(callback, null, new Array(keys.length).fill(void 0));
      }
      put(key, value, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].entry);
        if (this[kStatus] === "opening") {
          this.defer(() => this.put(key, value, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key) || this._checkValue(value);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const valueEncoding = this.valueEncoding(options.valueEncoding);
        const keyFormat = keyEncoding.format;
        const valueFormat = valueEncoding.format;
        if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
        }
        const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
        const mappedValue = valueEncoding.encode(value);
        this._put(mappedKey, mappedValue, options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("put", key, value);
          callback();
        });
        return callback[kPromise];
      }
      _put(key, value, options, callback) {
        this.nextTick(callback);
      }
      del(key, options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].key);
        if (this[kStatus] === "opening") {
          this.defer(() => this.del(key, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const err2 = this._checkKey(key);
        if (err2) {
          this.nextTick(callback, err2);
          return callback[kPromise];
        }
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        const keyFormat = keyEncoding.format;
        if (options.keyEncoding !== keyFormat) {
          options = Object.assign({}, options, { keyEncoding: keyFormat });
        }
        this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err3) => {
          if (err3)
            return callback(err3);
          this.emit("del", key);
          callback();
        });
        return callback[kPromise];
      }
      _del(key, options, callback) {
        this.nextTick(callback);
      }
      batch(operations, options, callback) {
        if (!arguments.length) {
          if (this[kStatus] === "opening")
            return new DefaultChainedBatch(this);
          if (this[kStatus] !== "open") {
            throw new ModuleError("Database is not open", {
              code: "LEVEL_DATABASE_NOT_OPEN"
            });
          }
          return this._chainedBatch();
        }
        if (typeof operations === "function")
          callback = operations;
        else
          callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.batch(operations, options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        if (!Array.isArray(operations)) {
          this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
          return callback[kPromise];
        }
        if (operations.length === 0) {
          this.nextTick(callback);
          return callback[kPromise];
        }
        const mapped = new Array(operations.length);
        const { keyEncoding: ke, valueEncoding: ve, ...forward } = options;
        for (let i = 0; i < operations.length; i++) {
          if (typeof operations[i] !== "object" || operations[i] === null) {
            this.nextTick(callback, new TypeError("A batch operation must be an object"));
            return callback[kPromise];
          }
          const op = Object.assign({}, operations[i]);
          if (op.type !== "put" && op.type !== "del") {
            this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
            return callback[kPromise];
          }
          const err2 = this._checkKey(op.key);
          if (err2) {
            this.nextTick(callback, err2);
            return callback[kPromise];
          }
          const db = op.sublevel != null ? op.sublevel : this;
          const keyEncoding = db.keyEncoding(op.keyEncoding || ke);
          const keyFormat = keyEncoding.format;
          op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
          op.keyEncoding = keyFormat;
          if (op.type === "put") {
            const valueErr = this._checkValue(op.value);
            if (valueErr) {
              this.nextTick(callback, valueErr);
              return callback[kPromise];
            }
            const valueEncoding = db.valueEncoding(op.valueEncoding || ve);
            op.value = valueEncoding.encode(op.value);
            op.valueEncoding = valueEncoding.format;
          }
          if (db !== this) {
            op.sublevel = null;
          }
          mapped[i] = op;
        }
        this._batch(mapped, forward, (err2) => {
          if (err2)
            return callback(err2);
          this.emit("batch", operations);
          callback();
        });
        return callback[kPromise];
      }
      _batch(operations, options, callback) {
        this.nextTick(callback);
      }
      sublevel(name6, options) {
        return this._sublevel(name6, AbstractSublevel.defaults(options));
      }
      _sublevel(name6, options) {
        return new AbstractSublevel(this, name6, options);
      }
      prefixKey(key, keyFormat) {
        return key;
      }
      clear(options, callback) {
        callback = getCallback(options, callback);
        callback = fromCallback(callback, kPromise);
        options = getOptions(options, this[kDefaultOptions].empty);
        if (this[kStatus] === "opening") {
          this.defer(() => this.clear(options, callback));
          return callback[kPromise];
        }
        if (maybeError(this, callback)) {
          return callback[kPromise];
        }
        const original = options;
        const keyEncoding = this.keyEncoding(options.keyEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keyEncoding = keyEncoding.format;
        if (options.limit === 0) {
          this.nextTick(callback);
        } else {
          this._clear(options, (err2) => {
            if (err2)
              return callback(err2);
            this.emit("clear", original);
            callback();
          });
        }
        return callback[kPromise];
      }
      _clear(options, callback) {
        this.nextTick(callback);
      }
      iterator(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._iterator(options);
      }
      _iterator(options) {
        return new AbstractIterator(this, options);
      }
      keys(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredKeyIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._keys(options);
      }
      _keys(options) {
        return new DefaultKeyIterator(this, options);
      }
      values(options) {
        const keyEncoding = this.keyEncoding(options && options.keyEncoding);
        const valueEncoding = this.valueEncoding(options && options.valueEncoding);
        options = rangeOptions(options, keyEncoding);
        options[AbstractIterator.keyEncoding] = keyEncoding;
        options[AbstractIterator.valueEncoding] = valueEncoding;
        options.keyEncoding = keyEncoding.format;
        options.valueEncoding = valueEncoding.format;
        if (this[kStatus] === "opening") {
          return new DeferredValueIterator(this, options);
        } else if (this[kStatus] !== "open") {
          throw new ModuleError("Database is not open", {
            code: "LEVEL_DATABASE_NOT_OPEN"
          });
        }
        return this._values(options);
      }
      _values(options) {
        return new DefaultValueIterator(this, options);
      }
      defer(fn) {
        if (typeof fn !== "function") {
          throw new TypeError("The first argument must be a function");
        }
        this[kOperations].push(fn);
      }
      [kUndefer]() {
        if (this[kOperations].length === 0) {
          return;
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          op();
        }
      }
      attachResource(resource) {
        if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
          throw new TypeError("The first argument must be a resource object");
        }
        this[kResources].add(resource);
      }
      detachResource(resource) {
        this[kResources].delete(resource);
      }
      _chainedBatch() {
        return new DefaultChainedBatch(this);
      }
      _checkKey(key) {
        if (key === null || key === void 0) {
          return new ModuleError("Key cannot be null or undefined", {
            code: "LEVEL_INVALID_KEY"
          });
        }
      }
      _checkValue(value) {
        if (value === null || value === void 0) {
          return new ModuleError("Value cannot be null or undefined", {
            code: "LEVEL_INVALID_VALUE"
          });
        }
      }
    };
    AbstractLevel.prototype.nextTick = require_next_tick_browser2();
    var { AbstractSublevel } = require_abstract_sublevel()({ AbstractLevel });
    exports.AbstractLevel = AbstractLevel;
    exports.AbstractSublevel = AbstractSublevel;
    var maybeError = function(db, callback) {
      if (db[kStatus] !== "open") {
        db.nextTick(callback, new ModuleError("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        }));
        return true;
      }
      return false;
    };
    var formats = function(db) {
      return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/index.js
var require_abstract_level2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/abstract-level-npm-1.0.3-7a868db447-9.zip/node_modules/abstract-level/index.js"(exports) {
    "use strict";
    init_define_process();
    exports.AbstractLevel = require_abstract_level().AbstractLevel;
    exports.AbstractSublevel = require_abstract_level().AbstractSublevel;
    exports.AbstractIterator = require_abstract_iterator().AbstractIterator;
    exports.AbstractKeyIterator = require_abstract_iterator().AbstractKeyIterator;
    exports.AbstractValueIterator = require_abstract_iterator().AbstractValueIterator;
    exports.AbstractChainedBatch = require_abstract_chained_batch().AbstractChainedBatch;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/run-parallel-limit-npm-1.1.0-ac1dfd4d1f-9.zip/node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/run-parallel-limit-npm-1.1.0-ac1dfd4d1f-9.zip/node_modules/run-parallel-limit/index.js"(exports, module) {
    init_define_process();
    module.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb)
            cb(err2, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each3(i, err2, result) {
        results[i] = result;
        if (err2)
          isErrored = true;
        if (--pending === 0 || err2) {
          done(err2);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err3, result2) {
              each3(key, err3, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err3, result2) {
              each3(key, err3, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i) {
          tasks[key](function(err2, result) {
            each3(key, err2, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err2, result) {
            each3(i, err2, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/key-range.js
var require_key_range = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/key-range.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = function createKeyRange(options) {
      const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
      const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
      const lowerExclusive = options.gte === void 0;
      const upperExclusive = options.lte === void 0;
      if (lower !== void 0 && upper !== void 0) {
        return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
      } else if (lower !== void 0) {
        return IDBKeyRange.lowerBound(lower, lowerExclusive);
      } else if (upper !== void 0) {
        return IDBKeyRange.upperBound(upper, upperExclusive);
      } else {
        return null;
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/deserialize.js
var require_deserialize = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/deserialize.js"(exports, module) {
    "use strict";
    init_define_process();
    var textEncoder4 = new TextEncoder();
    module.exports = function(data) {
      if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
      } else {
        return textEncoder4.encode(data);
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/iterator.js
var require_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/iterator.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractIterator } = require_abstract_level2();
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var kCache = Symbol("cache");
    var kFinished = Symbol("finished");
    var kOptions = Symbol("options");
    var kCurrentOptions = Symbol("currentOptions");
    var kPosition = Symbol("position");
    var kLocation = Symbol("location");
    var kFirst = Symbol("first");
    var emptyOptions = {};
    var Iterator = class extends AbstractIterator {
      constructor(db, location2, options) {
        super(db, options);
        this[kCache] = [];
        this[kFinished] = this.limit === 0;
        this[kOptions] = options;
        this[kCurrentOptions] = { ...options };
        this[kPosition] = void 0;
        this[kLocation] = location2;
        this[kFirst] = true;
      }
      _nextv(size, options, callback) {
        this[kFirst] = false;
        if (this[kFinished]) {
          return this.nextTick(callback, null, []);
        } else if (this[kCache].length > 0) {
          size = Math.min(size, this[kCache].length);
          return this.nextTick(callback, null, this[kCache].splice(0, size));
        }
        if (this[kPosition] !== void 0) {
          if (this[kOptions].reverse) {
            this[kCurrentOptions].lt = this[kPosition];
            this[kCurrentOptions].lte = void 0;
          } else {
            this[kCurrentOptions].gt = this[kPosition];
            this[kCurrentOptions].gte = void 0;
          }
        }
        let keyRange;
        try {
          keyRange = createKeyRange(this[kCurrentOptions]);
        } catch (_) {
          this[kFinished] = true;
          return this.nextTick(callback, null, []);
        }
        const transaction = this.db.db.transaction([this[kLocation]], "readonly");
        const store = transaction.objectStore(this[kLocation]);
        const entries = [];
        if (!this[kOptions].reverse) {
          let keys;
          let values;
          const complete = () => {
            if (keys === void 0 || values === void 0)
              return;
            const length5 = Math.max(keys.length, values.length);
            if (length5 === 0 || size === Infinity) {
              this[kFinished] = true;
            } else {
              this[kPosition] = keys[length5 - 1];
            }
            entries.length = length5;
            for (let i = 0; i < length5; i++) {
              const key = keys[i];
              const value = values[i];
              entries[i] = [
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
              ];
            }
            maybeCommit(transaction);
          };
          if (this[kOptions].keys || size < Infinity) {
            store.getAllKeys(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              keys = ev.target.result;
              complete();
            };
          } else {
            keys = [];
            this.nextTick(complete);
          }
          if (this[kOptions].values) {
            store.getAll(keyRange, size < Infinity ? size : void 0).onsuccess = (ev) => {
              values = ev.target.result;
              complete();
            };
          } else {
            values = [];
            this.nextTick(complete);
          }
        } else {
          const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
          store[method](keyRange, "prev").onsuccess = (ev) => {
            const cursor = ev.target.result;
            if (cursor) {
              const { key, value } = cursor;
              this[kPosition] = key;
              entries.push([
                this[kOptions].keys && key !== void 0 ? deserialize(key) : void 0,
                this[kOptions].values && value !== void 0 ? deserialize(value) : void 0
              ]);
              if (entries.length < size) {
                cursor.continue();
              } else {
                maybeCommit(transaction);
              }
            } else {
              this[kFinished] = true;
            }
          };
        }
        transaction.onabort = () => {
          callback(transaction.error || new Error("aborted by user"));
          callback = null;
        };
        transaction.oncomplete = () => {
          callback(null, entries);
          callback = null;
        };
      }
      _next(callback) {
        if (this[kCache].length > 0) {
          const [key, value] = this[kCache].shift();
          this.nextTick(callback, null, key, value);
        } else if (this[kFinished]) {
          this.nextTick(callback);
        } else {
          let size = Math.min(100, this.limit - this.count);
          if (this[kFirst]) {
            this[kFirst] = false;
            size = 1;
          }
          this._nextv(size, emptyOptions, (err2, entries) => {
            if (err2)
              return callback(err2);
            this[kCache] = entries;
            this._next(callback);
          });
        }
      }
      _all(options, callback) {
        this[kFirst] = false;
        const cache3 = this[kCache].splice(0, this[kCache].length);
        const size = this.limit - this.count - cache3.length;
        if (size <= 0) {
          return this.nextTick(callback, null, cache3);
        }
        this._nextv(size, emptyOptions, (err2, entries) => {
          if (err2)
            return callback(err2);
          if (cache3.length > 0)
            entries = cache3.concat(entries);
          callback(null, entries);
        });
      }
      _seek(target, options) {
        this[kFirst] = true;
        this[kCache] = [];
        this[kFinished] = false;
        this[kPosition] = void 0;
        this[kCurrentOptions] = { ...this[kOptions] };
        let keyRange;
        try {
          keyRange = createKeyRange(this[kOptions]);
        } catch (_) {
          this[kFinished] = true;
          return;
        }
        if (keyRange !== null && !keyRange.includes(target)) {
          this[kFinished] = true;
        } else if (this[kOptions].reverse) {
          this[kCurrentOptions].lte = target;
        } else {
          this[kCurrentOptions].gte = target;
        }
      }
    };
    exports.Iterator = Iterator;
    function maybeCommit(transaction) {
      if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/clear.js
var require_clear = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/util/clear.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = function clear(db, location2, keyRange, options, callback) {
      if (options.limit === 0)
        return db.nextTick(callback);
      const transaction = db.db.transaction([location2], "readwrite");
      const store = transaction.objectStore(location2);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/index.js
var require_browser_level = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/browser-level-npm-1.0.1-f0600225ae-9.zip/node_modules/browser-level/index.js"(exports) {
    "use strict";
    init_define_process();
    var { AbstractLevel } = require_abstract_level2();
    var ModuleError = require_module_error();
    var parallel5 = require_run_parallel_limit();
    var { fromCallback } = require_catering();
    var { Iterator } = require_iterator();
    var deserialize = require_deserialize();
    var clear = require_clear();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    var kIDB = Symbol("idb");
    var kNamePrefix = Symbol("namePrefix");
    var kLocation = Symbol("location");
    var kVersion = Symbol("version");
    var kStore = Symbol("store");
    var kOnComplete = Symbol("onComplete");
    var kPromise = Symbol("promise");
    var BrowserLevel = class extends AbstractLevel {
      constructor(location2, options, _) {
        if (typeof options === "function" || typeof _ === "function") {
          throw new ModuleError("The levelup-style callback argument has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        const { prefix, version: version3, ...forward } = options || {};
        super({
          encodings: { view: true },
          snapshots: false,
          createIfMissing: false,
          errorIfExists: false,
          seek: true
        }, forward);
        if (typeof location2 !== "string") {
          throw new Error("constructor requires a location string argument");
        }
        this[kLocation] = location2;
        this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
        this[kVersion] = parseInt(version3 || 1, 10);
        this[kIDB] = null;
      }
      get location() {
        return this[kLocation];
      }
      get namePrefix() {
        return this[kNamePrefix];
      }
      get version() {
        return this[kVersion];
      }
      get db() {
        return this[kIDB];
      }
      get type() {
        return "browser-level";
      }
      _open(options, callback) {
        const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
        req.onerror = function() {
          callback(req.error || new Error("unknown error"));
        };
        req.onsuccess = () => {
          this[kIDB] = req.result;
          callback();
        };
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains(this[kLocation])) {
            db.createObjectStore(this[kLocation]);
          }
        };
      }
      [kStore](mode) {
        const transaction = this[kIDB].transaction([this[kLocation]], mode);
        return transaction.objectStore(this[kLocation]);
      }
      [kOnComplete](request2, callback) {
        const transaction = request2.transaction;
        transaction.onabort = function() {
          callback(transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback(null, request2.result);
        };
      }
      _get(key, options, callback) {
        const store = this[kStore]("readonly");
        let req;
        try {
          req = store.get(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, function(err2, value) {
          if (err2)
            return callback(err2);
          if (value === void 0) {
            return callback(new ModuleError("Entry not found", {
              code: "LEVEL_NOT_FOUND"
            }));
          }
          callback(null, deserialize(value));
        });
      }
      _getMany(keys, options, callback) {
        const store = this[kStore]("readonly");
        const tasks = keys.map((key) => (next) => {
          let request2;
          try {
            request2 = store.get(key);
          } catch (err2) {
            return next(err2);
          }
          request2.onsuccess = () => {
            const value = request2.result;
            next(null, value === void 0 ? value : deserialize(value));
          };
          request2.onerror = (ev) => {
            ev.stopPropagation();
            next(request2.error);
          };
        });
        parallel5(tasks, 16, callback);
      }
      _del(key, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.delete(key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _put(key, value, options, callback) {
        const store = this[kStore]("readwrite");
        let req;
        try {
          req = store.put(value, key);
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _iterator(options) {
        return new Iterator(this, this[kLocation], options);
      }
      _batch(operations, options, callback) {
        const store = this[kStore]("readwrite");
        const transaction = store.transaction;
        let index = 0;
        let error;
        transaction.onabort = function() {
          callback(error || transaction.error || new Error("aborted by user"));
        };
        transaction.oncomplete = function() {
          callback();
        };
        function loop() {
          const op = operations[index++];
          const key = op.key;
          let req;
          try {
            req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
          } catch (err2) {
            error = err2;
            transaction.abort();
            return;
          }
          if (index < operations.length) {
            req.onsuccess = loop;
          } else if (typeof transaction.commit === "function") {
            transaction.commit();
          }
        }
        loop();
      }
      _clear(options, callback) {
        let keyRange;
        let req;
        try {
          keyRange = createKeyRange(options);
        } catch (e) {
          return this.nextTick(callback);
        }
        if (options.limit >= 0) {
          return clear(this, this[kLocation], keyRange, options, callback);
        }
        try {
          const store = this[kStore]("readwrite");
          req = keyRange ? store.delete(keyRange) : store.clear();
        } catch (err2) {
          return this.nextTick(callback, err2);
        }
        this[kOnComplete](req, callback);
      }
      _close(callback) {
        this[kIDB].close();
        this.nextTick(callback);
      }
    };
    BrowserLevel.destroy = function(location2, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      callback = fromCallback(callback, kPromise);
      const request2 = indexedDB.deleteDatabase(prefix + location2);
      request2.onsuccess = function() {
        callback();
      };
      request2.onerror = function(err2) {
        callback(err2);
      };
      return callback[kPromise];
    };
    exports.BrowserLevel = BrowserLevel;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/level-npm-8.0.0-c35f5fe17a-9.zip/node_modules/level/browser.js
var require_browser2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/level-npm-8.0.0-c35f5fe17a-9.zip/node_modules/level/browser.js"(exports) {
    init_define_process();
    exports.Level = require_browser_level().BrowserLevel;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/stream-to-it-npm-0.2.4-798f6e3134-9.zip/node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/stream-to-it-npm-0.2.4-798f6e3134-9.zip/node_modules/stream-to-it/source.js"(exports, module) {
    init_define_process();
    module.exports = (readable) => {
      if (readable[Symbol.asyncIterator])
        return readable;
      if (readable.getReader) {
        return async function* () {
          const reader2 = readable.getReader();
          try {
            while (true) {
              const { done, value } = await reader2.read();
              if (done)
                return;
              yield value;
            }
          } finally {
            reader2.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});

// (disabled):../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "(disabled):../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/files/glob-source.js"() {
    init_define_process();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipfs-utils-npm-9.0.7-d3d052710c-9.zip/node_modules/ipfs-utils/src/files/url-source.js"(exports, module) {
    "use strict";
    init_define_process();
    var HTTP5 = require_http();
    var urlSource3 = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http = new HTTP5();
      const response = await http.get(url, options);
      yield* response.iterator();
    }
    module.exports = urlSource3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/set-delayed-interval-npm-1.0.0-ae1c3497f2-9.zip/node_modules/set-delayed-interval/src/index.js
var require_src3 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/set-delayed-interval-npm-1.0.0-ae1c3497f2-9.zip/node_modules/set-delayed-interval/src/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var intervals = /* @__PURE__ */ new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err2) {
          setTimeout(() => {
            throw err2;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve7) => {
          const _timeout = setTimeout(resolve7, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval3(task, interval, delay) {
      delay = delay || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval3(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module.exports = {
      setDelayedInterval: setDelayedInterval3,
      clearDelayedInterval: clearDelayedInterval3
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/netmask-npm-2.0.2-2299510a4d-9.zip/node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/netmask-npm-2.0.2-2299510a4d-9.zip/node_modules/netmask/lib/netmask.js"(exports) {
    init_define_process();
    (function() {
      var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base, dmax, i, n, start;
        n = 0;
        base = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base + (chr(s[i]) - chr0) >>> 0;
          } else if (base === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask = function() {
        function Netmask2(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask2.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask2(ip);
          }
          if (ip instanceof Netmask2) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask2.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask2.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask2.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask2;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask;
    }).call(exports);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ip-regex-npm-4.3.0-4ac12c6be9-9.zip/node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ip-regex-npm-4.3.0-4ac12c6be9-9.zip/node_modules/ip-regex/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module.exports = ip;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/is-ip-npm-3.1.0-7b8bc9330c-9.zip/node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/is-ip-npm-3.1.0-7b8bc9330c-9.zip/node_modules/is-ip/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var ipRegex = require_ip_regex();
    var isIp = (string) => ipRegex({ exact: true }).test(string);
    isIp.v4 = (string) => ipRegex.v4({ exact: true }).test(string);
    isIp.v6 = (string) => ipRegex.v6({ exact: true }).test(string);
    isIp.version = (string) => isIp(string) ? isIp.v4(string) ? 4 : 6 : void 0;
    module.exports = isIp;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipaddr.js-npm-2.0.1-04e97280d7-9.zip/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/ipaddr.js-npm-2.0.1-04e97280d7-9.zip/node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    init_define_process();
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string, parts) {
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          const ref = string.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first10, second2, partSize, cidrBits) {
        if (first10.length !== second2.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first10[part] >> shift !== second2[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string) {
        if (hexRegex.test(string)) {
          return parseInt(string, 16);
        }
        if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
          if (octalRegex.test(string)) {
            return parseInt(string, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        return parseInt(string, 10);
      }
      function padPart(part, length5) {
        while (part.length < length5) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv6.isValid = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
          return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes2) {
        const length5 = bytes2.length;
        if (length5 === 4) {
          return new ipaddr.IPv4(bytes2);
        } else if (length5 === 16) {
          return new ipaddr.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/private-ip-npm-2.3.4-a1b55e33d2-9.zip/node_modules/private-ip/lib/index.js
var require_lib = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/private-ip-npm-2.3.4-a1b55e33d2-9.zip/node_modules/private-ip/lib/index.js"(exports) {
    "use strict";
    init_define_process();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var netmask_1 = require_netmask();
    var ip_regex_1 = __importDefault(require_ip_regex());
    var is_ip_1 = __importDefault(require_is_ip());
    var ipaddr_js_1 = require_ipaddr();
    var PRIVATE_IP_RANGES = [
      "0.0.0.0/8",
      "10.0.0.0/8",
      "100.64.0.0/10",
      "127.0.0.0/8",
      "169.254.0.0/16",
      "172.16.0.0/12",
      "192.0.0.0/24",
      "192.0.0.0/29",
      "192.0.0.8/32",
      "192.0.0.9/32",
      "192.0.0.10/32",
      "192.0.0.170/32",
      "192.0.0.171/32",
      "192.0.2.0/24",
      "192.31.196.0/24",
      "192.52.193.0/24",
      "192.88.99.0/24",
      "192.168.0.0/16",
      "192.175.48.0/24",
      "198.18.0.0/15",
      "198.51.100.0/24",
      "203.0.113.0/24",
      "240.0.0.0/4",
      "255.255.255.255/32"
    ];
    var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
    function ipv4_check(ip_addr) {
      for (let r of NETMASK_RANGES) {
        if (r.contains(ip_addr))
          return true;
      }
      return false;
    }
    function ipv6_check(ip_addr) {
      return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
    }
    exports.default = (ip) => {
      if ((0, ipaddr_js_1.isValid)(ip)) {
        const parsed = (0, ipaddr_js_1.parse)(ip);
        if (parsed.kind() === "ipv4")
          return ipv4_check(parsed.toNormalizedString());
        else if (parsed.kind() === "ipv6")
          return ipv6_check(ip);
      } else if ((0, is_ip_1.default)(ip) && ip_regex_1.default.v6().test(ip))
        return ipv6_check(ip);
      return void 0;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/private-ip-npm-2.3.4-a1b55e33d2-9.zip/node_modules/private-ip/index.js
var require_private_ip = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/private-ip-npm-2.3.4-a1b55e33d2-9.zip/node_modules/private-ip/index.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = require_lib().default;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/truncate-utf8-bytes-npm-1.0.2-ed694c53b0-9.zip/node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/truncate-utf8-bytes-npm-1.0.2-ed694c53b0-9.zip/node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
    "use strict";
    init_define_process();
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function truncate(getLength, string, byteLength) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string.charCodeAt(i);
        segment = string[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
          i += 1;
          segment += string[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string.slice(0, i - segment.length + 1);
        }
      }
      return string;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/utf8-byte-length-npm-1.0.4-cf13f06124-9.zip/node_modules/utf8-byte-length/browser.js
var require_browser3 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/utf8-byte-length-npm-1.0.4-cf13f06124-9.zip/node_modules/utf8-byte-length/browser.js"(exports, module) {
    "use strict";
    init_define_process();
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function getByteLength(string) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/truncate-utf8-bytes-npm-1.0.2-ed694c53b0-9.zip/node_modules/truncate-utf8-bytes/browser.js
var require_browser4 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/truncate-utf8-bytes-npm-1.0.2-ed694c53b0-9.zip/node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var truncate = require_truncate();
    var getLength = require_browser3();
    module.exports = truncate.bind(null, getLength);
  }
});

// ../../../../../Users/z/.yarn/berry/cache/sanitize-filename-npm-1.6.3-cb83b2c2aa-9.zip/node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/sanitize-filename-npm-1.6.3-cb83b2c2aa-9.zip/node_modules/sanitize-filename/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var truncate = require_browser4();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge3.asn1;
    var p7v = module.exports = forge3.pkcs7asn1 = forge3.pkcs7asn1 || {};
    forge3.pkcs7 = forge3.pkcs7 || {};
    forge3.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/mgf1.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_util();
    forge3.mgf = forge3.mgf || {};
    var mgf1 = module.exports = forge3.mgf.mgf1 = forge3.mgf1 = forge3.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge3.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge3.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/mgf.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_mgf1();
    module.exports = forge3.mgf = forge3.mgf || {};
    forge3.mgf.mgf1 = forge3.mgf1;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pss.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_random();
    require_util();
    var pss = module.exports = forge3.pss = forge3.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash3 = options.md;
      var mgf = options.mgf;
      var hLen = hash3.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge3.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge3.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge3.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h = hash3.digest().getBytes();
        var ps = new forge3.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge3.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash3.start();
        hash3.update(m_.getBytes());
        var h_ = hash3.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/x509.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge3.asn1;
    var pki2 = module.exports = forge3.pki = forge3.pki || {};
    var oids = pki2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge3.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set2 = rdn.value[si];
        for (var i = 0; i < set2.value.length; ++i) {
          obj = {};
          attr = set2.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors2;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge3.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge3.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge3.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge3.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge3.md.sha512.create();
        case "RSASSA-PSS":
          return forge3.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash3, mgf;
          hash3 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash3 === void 0 || forge3.md[hash3] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge3.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge3.mgf[mgf].create(forge3.md[hash3].create());
          hash3 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash3 === void 0 || forge3.md[hash3] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash3;
            throw error;
          }
          scheme = forge3.pss.create(
            forge3.md[hash3].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki2.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge3.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificateFromAsn1(obj, computeHash);
    };
    pki2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
      };
      return forge3.pem.encode(msg, { maxline });
    };
    pki2.publicKeyFromPem = function(pem) {
      var msg = forge3.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.publicKeyFromAsn1(obj);
    };
    pki2.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
      };
      return forge3.pem.encode(msg, { maxline });
    };
    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge3.pem.encode(msg, { maxline });
    };
    pki2.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge3.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes2;
      switch (type) {
        case "RSAPublicKey":
          bytes2 = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes2 = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes2);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge3.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge3.pem.encode(msg, { maxline });
    };
    pki2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge3.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki2.getTBSCertificate(cert);
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
          var bytes2 = asn1.toDer(tbsCertificate);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i = cert.issuer;
        var s = parent2.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge3.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors2)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge3.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge3.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge3.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
      }
      var imd = forge3.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge3.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki2.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge3.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge3.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge3.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge3.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
      }
      var smd = forge3.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki2.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki2.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge3.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          var bytes2 = asn1.toDer(cri);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set2;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge3.util.encodeUtf8(value);
          }
        }
        set2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki2.oids) {
            attr.name = pki2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki2.oids) {
            attr.type = pki2.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki2.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki2.oids) {
          e.name = pki2.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki2.oids) {
          e.id = pki2.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge3.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge3.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge3.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge3.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge3.util.hexToBytes(cert.serialNumber)
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        _dnToAsn1(cert.issuer),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki2.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        _dnToAsn1(csr.subject),
        pki2.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki2.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki2.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki2.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        cri,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki2.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge3.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge3.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge3.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge3.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash3 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash3)) {
            var value = caStore.certs[hash3];
            if (!forge3.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge3.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge3.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge3.md.sha1.create();
          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki2.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first10 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge3.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki2.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki2.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first10 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge3.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first10 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/node-forge-npm-1.3.1-f31fd566cc-9.zip/node_modules/node-forge/lib/pkcs7.js"(exports, module) {
    init_define_process();
    var forge3 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge3.asn1;
    var p7 = module.exports = forge3.pkcs7 = forge3.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge3.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge3.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors2;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge3.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge3.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge3.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge3.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge3.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge3.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              signedData
            ]
          );
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge3.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge3.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge3.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge3.pki.oids.sha1:
            case forge3.pki.oids.sha256:
            case forge3.pki.oids.sha384:
            case forge3.pki.oids.sha512:
            case forge3.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge3.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge3.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge3.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge3.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge3.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge3.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge3.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge3.md[forge3.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge3.md[forge3.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes2 = asn1.toDer(content);
        bytes2.getByte();
        asn1.getBerValueLength(bytes2);
        bytes2 = bytes2.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes2);
        }
        var signingTime = new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge3.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge3.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge3.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes2 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes2);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge3.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge3.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge3.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge3.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge3.pki.oids.rsaEncryption:
              case forge3.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge3.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge3.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge3.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge3.aes.createEncryptionCipher;
                break;
              case forge3.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge3.aes.createEncryptionCipher;
                break;
              case forge3.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge3.aes.createEncryptionCipher;
                break;
              case forge3.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge3.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge3.util.createBuffer(forge3.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge3.util.createBuffer(
              forge3.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge3.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors2;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge3.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge3.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge3.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge3.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge3.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge3.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge3.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge3.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge3.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge3.pki.oids.data).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, validator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge3.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge3.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge3.util.createBuffer(capture.encParameter.value),
          content: forge3.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge3.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge3.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge3.pki.oids["aes128-CBC"]:
          case forge3.pki.oids["aes192-CBC"]:
          case forge3.pki.oids["aes256-CBC"]:
            ciph = forge3.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge3.pki.oids["desCBC"]:
          case forge3.pki.oids["des-EDE3-CBC"]:
            ciph = forge3.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/it-foreach-npm-0.1.1-140fe93738-9.zip/node_modules/it-foreach/index.js
var require_it_foreach = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/it-foreach-npm-0.1.1-140fe93738-9.zip/node_modules/it-foreach/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var each3 = async function* (source, fn) {
      for await (const thing of source) {
        await fn(thing);
        yield thing;
      }
    };
    module.exports = each3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/mutable-proxy-npm-1.0.0-4250647937-9.zip/node_modules/mutable-proxy/build/index.js
var require_build = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/mutable-proxy-npm-1.0.0-4250647937-9.zip/node_modules/mutable-proxy/build/index.js"(exports, module) {
    "use strict";
    init_define_process();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module.exports = function mutableProxyFactory(defaultTarget) {
      var mutableHandler = void 0;
      var mutableTarget = void 0;
      function setTarget(target) {
        if (!(target instanceof Object)) {
          throw new Error('Target "' + target + '" is not an object');
        }
        mutableTarget = target;
      }
      function setHandler(handler2) {
        Object.keys(handler2).forEach(function(key) {
          var value = handler2[key];
          if (typeof value !== "function") {
            throw new Error('Trap "' + key + ": " + value + '" is not a function');
          }
          if (!Reflect[key]) {
            throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
          }
        });
        mutableHandler = handler2;
      }
      setTarget(function() {
      });
      if (defaultTarget) {
        setTarget(defaultTarget);
      }
      setHandler(Reflect);
      var handler = new Proxy({}, {
        get: function get6(target, property) {
          return function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
          };
        }
      });
      return {
        setTarget,
        setHandler,
        getTarget: function getTarget() {
          return mutableTarget;
        },
        getHandler: function getHandler() {
          return mutableHandler;
        },
        proxy: new Proxy(mutableTarget, handler)
      };
    };
  }
});

// js/ms/index.js
var require_ms = __commonJS({
  "js/ms/index.js"(exports, module) {
    init_define_process();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name6) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name6 + (isPlural ? "s" : "");
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/receptacle-npm-1.3.2-0a7b786c59-9.zip/node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/receptacle-npm-1.3.2-0a7b786c59-9.zip/node_modules/receptacle/index.js"(exports, module) {
    "use strict";
    init_define_process();
    module.exports = Receptacle2;
    var toMS = require_ms();
    var cache3 = Receptacle2.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle2(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl2, i = this.items.length; i--; ) {
        item = this.items[i];
        ttl2 = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl2 > 0)
          this.expire(item.key, ttl2);
        else if (ttl2 <= 0)
          this.delete(item.key);
      }
    }
    cache3.has = function(key) {
      return key in this._lookup;
    };
    cache3.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache3.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache3.set = function(key, value, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache3.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache3.expire = function(key, ttl2) {
      var ms = ttl2 || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl2);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache3.clear = function() {
      for (var i = this.items.length; i--; )
        this.delete(this.items[i].key);
      return this;
    };
    cache3.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i = items.length; i--; ) {
        item = this.items[i];
        items[i] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/p-fifo-npm-1.0.0-70306fa5f2-9.zip/node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/p-fifo-npm-1.0.0-70306fa5f2-9.zip/node_modules/p-fifo/index.js"(exports, module) {
    init_define_process();
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve7 } = defer();
        this._buffer.push({ chunk, resolve: resolve7 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve7 } = defer();
        this._waitingConsumers.push({ resolve: resolve7 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/safe-buffer-npm-5.2.1-3481c8aa9b-9.zip/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/safe-buffer-npm-5.2.1-3481c8aa9b-9.zip/node_modules/safe-buffer/index.js"(exports, module) {
    init_define_process();
    var buffer2 = require_buffer();
    var Buffer = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length5) {
      return Buffer(arg, encodingOrOffset, length5);
    }
    SafeBuffer.prototype = Object.create(Buffer.prototype);
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer(arg, encodingOrOffset, length5);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/randombytes-npm-2.1.0-e3da76bccf-9.zip/node_modules/randombytes/browser.js
var require_browser5 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/randombytes-npm-2.1.0-e3da76bccf-9.zip/node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    init_define_process();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer = require_safe_buffer().Buffer;
    var crypto2 = globalThis.crypto || globalThis.msCrypto;
    if (crypto2 && crypto2.getRandomValues) {
      module.exports = randomBytes2;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes2 = Buffer.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto2.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto2.getRandomValues(bytes2);
        }
      }
      if (typeof cb === "function") {
        return define_process_default.nextTick(function() {
          cb(null, bytes2);
        });
      }
      return bytes2;
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/k-bucket-npm-5.1.0-cb8652a7bb-9.zip/node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/k-bucket-npm-5.1.0-cb8652a7bb-9.zip/node_modules/k-bucket/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var randomBytes2 = require_browser5();
    var { EventEmitter: EventEmitter6 } = require_events();
    function arrayEquals(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i = 0, length5 = array1.length; i < length5; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function createNode3() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name6, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name6 + " is not a Uint8Array");
      }
    }
    var KBucket = class extends EventEmitter6 {
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes2(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || KBucket.distance;
        this.arbiter = options.arbiter || KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode3();
      }
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      static distance(firstId, secondId) {
        let distance = 0;
        let i = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i < min; ++i) {
          distance = distance * 256 + (firstId[i] ^ secondId[i]);
        }
        for (; i < max; ++i)
          distance = distance * 256 + 255;
        return distance;
      }
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      _indexOf(node, id) {
        for (let i = 0; i < node.contacts.length; ++i) {
          if (arrayEquals(node.contacts[i].id, id))
            return i;
        }
        return -1;
      }
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      _split(node, bitIndex) {
        node.left = createNode3();
        node.right = createNode3();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      _update(node, index, contact) {
        if (!arrayEquals(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module.exports = KBucket;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/event-iterator-npm-2.0.0-1d704f8608-9.zip/node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/event-iterator-npm-2.0.0-1d704f8608-9.zip/node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve7, reject) => {
                this.pullQueue.push({ resolve: resolve7, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/event-iterator-npm-2.0.0-1d704f8608-9.zip/node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/event-iterator-npm-2.0.0-1d704f8608-9.zip/node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js
var require_RateLimiterAbstract = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterAbstract.js"(exports, module) {
    init_define_process();
    module.exports = class RateLimiterAbstract {
      constructor(opts = {}) {
        this.points = opts.points;
        this.duration = opts.duration;
        this.blockDuration = opts.blockDuration;
        this.execEvenly = opts.execEvenly;
        this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs;
        this.keyPrefix = opts.keyPrefix;
      }
      get points() {
        return this._points;
      }
      set points(value) {
        this._points = value >= 0 ? value : 4;
      }
      get duration() {
        return this._duration;
      }
      set duration(value) {
        this._duration = typeof value === "undefined" ? 1 : value;
      }
      get msDuration() {
        return this.duration * 1e3;
      }
      get blockDuration() {
        return this._blockDuration;
      }
      set blockDuration(value) {
        this._blockDuration = typeof value === "undefined" ? 0 : value;
      }
      get msBlockDuration() {
        return this.blockDuration * 1e3;
      }
      get execEvenly() {
        return this._execEvenly;
      }
      set execEvenly(value) {
        this._execEvenly = typeof value === "undefined" ? false : Boolean(value);
      }
      get execEvenlyMinDelayMs() {
        return this._execEvenlyMinDelayMs;
      }
      set execEvenlyMinDelayMs(value) {
        this._execEvenlyMinDelayMs = typeof value === "undefined" ? Math.ceil(this.msDuration / this.points) : value;
      }
      get keyPrefix() {
        return this._keyPrefix;
      }
      set keyPrefix(value) {
        if (typeof value === "undefined") {
          value = "rlflx";
        }
        if (typeof value !== "string") {
          throw new Error("keyPrefix must be string");
        }
        this._keyPrefix = value;
      }
      _getKeySecDuration(options = {}) {
        return options && options.customDuration >= 0 ? options.customDuration : this.duration;
      }
      getKey(key) {
        return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
      }
      parseKey(rlKey) {
        return rlKey.substring(this.keyPrefix.length);
      }
      consume() {
        throw new Error("You have to implement the method 'consume'!");
      }
      penalty() {
        throw new Error("You have to implement the method 'penalty'!");
      }
      reward() {
        throw new Error("You have to implement the method 'reward'!");
      }
      get() {
        throw new Error("You have to implement the method 'get'!");
      }
      set() {
        throw new Error("You have to implement the method 'set'!");
      }
      block() {
        throw new Error("You have to implement the method 'block'!");
      }
      delete() {
        throw new Error("You have to implement the method 'delete'!");
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js
var require_BlockedKeys = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/BlockedKeys/BlockedKeys.js"(exports, module) {
    init_define_process();
    module.exports = class BlockedKeys {
      constructor() {
        this._keys = {};
        this._addedKeysAmount = 0;
      }
      collectExpired() {
        const now = Date.now();
        Object.keys(this._keys).forEach((key) => {
          if (this._keys[key] <= now) {
            delete this._keys[key];
          }
        });
        this._addedKeysAmount = Object.keys(this._keys).length;
      }
      add(key, sec) {
        this.addMs(key, sec * 1e3);
      }
      addMs(key, ms) {
        this._keys[key] = Date.now() + ms;
        this._addedKeysAmount++;
        if (this._addedKeysAmount > 999) {
          this.collectExpired();
        }
      }
      msBeforeExpire(key) {
        const expire = this._keys[key];
        if (expire && expire >= Date.now()) {
          this.collectExpired();
          const now = Date.now();
          return expire >= now ? expire - now : 0;
        }
        return 0;
      }
      delete(key) {
        if (key) {
          delete this._keys[key];
        } else {
          Object.keys(this._keys).forEach((key2) => {
            delete this._keys[key2];
          });
        }
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js
var require_BlockedKeys2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/BlockedKeys/index.js"(exports, module) {
    init_define_process();
    var BlockedKeys = require_BlockedKeys();
    module.exports = BlockedKeys;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterRes.js
var require_RateLimiterRes = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterRes.js"(exports, module) {
    init_define_process();
    module.exports = class RateLimiterRes {
      constructor(remainingPoints, msBeforeNext, consumedPoints, isFirstInDuration) {
        this.remainingPoints = typeof remainingPoints === "undefined" ? 0 : remainingPoints;
        this.msBeforeNext = typeof msBeforeNext === "undefined" ? 0 : msBeforeNext;
        this.consumedPoints = typeof consumedPoints === "undefined" ? 0 : consumedPoints;
        this.isFirstInDuration = typeof isFirstInDuration === "undefined" ? false : isFirstInDuration;
      }
      get msBeforeNext() {
        return this._msBeforeNext;
      }
      set msBeforeNext(ms) {
        this._msBeforeNext = ms;
        return this;
      }
      get remainingPoints() {
        return this._remainingPoints;
      }
      set remainingPoints(p) {
        this._remainingPoints = p;
        return this;
      }
      get consumedPoints() {
        return this._consumedPoints;
      }
      set consumedPoints(p) {
        this._consumedPoints = p;
        return this;
      }
      get isFirstInDuration() {
        return this._isFirstInDuration;
      }
      set isFirstInDuration(value) {
        this._isFirstInDuration = Boolean(value);
      }
      _getDecoratedProperties() {
        return {
          remainingPoints: this.remainingPoints,
          msBeforeNext: this.msBeforeNext,
          consumedPoints: this.consumedPoints,
          isFirstInDuration: this.isFirstInDuration
        };
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this._getDecoratedProperties();
      }
      toString() {
        return JSON.stringify(this._getDecoratedProperties());
      }
      toJSON() {
        return this._getDecoratedProperties();
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js
var require_RateLimiterStoreAbstract = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"(exports, module) {
    init_define_process();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var BlockedKeys = require_BlockedKeys2();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;
        this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;
        this.insuranceLimiter = opts.insuranceLimiter;
        this._inMemoryBlockedKeys = new BlockedKeys();
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("storeClient is not set");
        }
        this._client = value;
      }
      _afterConsume(resolve7, reject, rlKey, changedPoints, storeResult, options = {}) {
        const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);
        if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
          this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);
          if (res.consumedPoints > this.points) {
            return reject(res);
          } else {
            return resolve7(res);
          }
        } else if (res.consumedPoints > this.points) {
          let blockPromise = Promise.resolve();
          if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {
            res.msBeforeNext = this.msBlockDuration;
            blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);
          }
          if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {
            this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);
            res.msBeforeNext = this.msInMemoryBlockDuration;
          }
          blockPromise.then(() => {
            reject(res);
          }).catch((err2) => {
            reject(err2);
          });
        } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
          let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
          if (delay < this.execEvenlyMinDelayMs) {
            delay = res.consumedPoints * this.execEvenlyMinDelayMs;
          }
          setTimeout(resolve7, delay, res);
        } else {
          resolve7(res);
        }
      }
      _handleError(err2, funcName, resolve7, reject, key, data = false, options = {}) {
        if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {
          reject(err2);
        } else {
          this.insuranceLimiter[funcName](key, data, options).then((res) => {
            resolve7(res);
          }).catch((res) => {
            reject(res);
          });
        }
      }
      get _inmemoryBlockedKeys() {
        return this._inMemoryBlockedKeys;
      }
      getInmemoryBlockMsBeforeExpire(rlKey) {
        return this.getInMemoryBlockMsBeforeExpire(rlKey);
      }
      get inmemoryBlockOnConsumed() {
        return this.inMemoryBlockOnConsumed;
      }
      set inmemoryBlockOnConsumed(value) {
        this.inMemoryBlockOnConsumed = value;
      }
      get inmemoryBlockDuration() {
        return this.inMemoryBlockDuration;
      }
      set inmemoryBlockDuration(value) {
        this.inMemoryBlockDuration = value;
      }
      get msInmemoryBlockDuration() {
        return this.inMemoryBlockDuration * 1e3;
      }
      getInMemoryBlockMsBeforeExpire(rlKey) {
        if (this.inMemoryBlockOnConsumed > 0) {
          return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);
        }
        return 0;
      }
      get inMemoryBlockOnConsumed() {
        return this._inMemoryBlockOnConsumed;
      }
      set inMemoryBlockOnConsumed(value) {
        this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;
        if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {
          throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option');
        }
      }
      get inMemoryBlockDuration() {
        return this._inMemoryBlockDuration;
      }
      set inMemoryBlockDuration(value) {
        this._inMemoryBlockDuration = value ? parseInt(value) : 0;
        if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {
          throw new Error("inMemoryBlockOnConsumed option must be set up");
        }
      }
      get msInMemoryBlockDuration() {
        return this._inMemoryBlockDuration * 1e3;
      }
      get insuranceLimiter() {
        return this._insuranceLimiter;
      }
      set insuranceLimiter(value) {
        if (typeof value !== "undefined" && !(value instanceof RateLimiterAbstract)) {
          throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");
        }
        this._insuranceLimiter = value;
        if (this._insuranceLimiter) {
          this._insuranceLimiter.blockDuration = this.blockDuration;
          this._insuranceLimiter.execEvenly = this.execEvenly;
        }
      }
      block(key, secDuration, options = {}) {
        const msDuration = secDuration * 1e3;
        return this._block(this.getKey(key), this.points + 1, msDuration, options);
      }
      set(key, points, secDuration, options = {}) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        return this._block(this.getKey(key), points, msDuration, options);
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);
          if (inMemoryBlockMsBeforeExpire > 0) {
            return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));
          }
          this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            this._afterConsume(resolve7, reject, rlKey, pointsToConsume, res);
          }).catch((err2) => {
            this._handleError(err2, "consume", resolve7, reject, key, pointsToConsume, options);
          });
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, points, res));
          }).catch((err2) => {
            this._handleError(err2, "penalty", resolve7, reject, key, points, options);
          });
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1e3, false, options).then((res) => {
            resolve7(this._getRateLimiterRes(rlKey, -points, res));
          }).catch((err2) => {
            this._handleError(err2, "reward", resolve7, reject, key, points, options);
          });
        });
      }
      get(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._get(rlKey, options).then((res) => {
            if (res === null || typeof res === "undefined") {
              resolve7(null);
            } else {
              resolve7(this._getRateLimiterRes(rlKey, 0, res));
            }
          }).catch((err2) => {
            this._handleError(err2, "get", resolve7, reject, key, options);
          });
        });
      }
      delete(key, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7, reject) => {
          this._delete(rlKey, options).then((res) => {
            this._inMemoryBlockedKeys.delete(rlKey);
            resolve7(res);
          }).catch((err2) => {
            this._handleError(err2, "delete", resolve7, reject, key, options);
          });
        });
      }
      deleteInMemoryBlockedAll() {
        this._inMemoryBlockedKeys.delete();
      }
      _getRateLimiterRes(rlKey, changedPoints, storeResult) {
        throw new Error("You have to implement the method '_getRateLimiterRes'!");
      }
      _block(rlKey, initPoints, msDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {
            resolve7(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));
          }).catch((err2) => {
            this._handleError(err2, "block", resolve7, reject, this.parseKey(rlKey), msDuration / 1e3, options);
          });
        });
      }
      _get(rlKey, options = {}) {
        throw new Error("You have to implement the method '_get'!");
      }
      _delete(rlKey, options = {}) {
        throw new Error("You have to implement the method '_delete'!");
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        throw new Error("You have to implement the method '_upsert'!");
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js
var require_RateLimiterRedis = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"(exports, module) {
    init_define_process();
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} `;
    var RateLimiterRedis = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        if (opts.redis) {
          this.client = opts.redis;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.defineCommand === "function") {
          this.client.defineCommand("rlflxIncr", {
            numberOfKeys: 1,
            lua: incrTtlLuaScript
          });
        }
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        let [consumed, resTtlMs] = result;
        if (Array.isArray(consumed)) {
          [, consumed] = consumed;
          [, resTtlMs] = resTtlMs;
        }
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(consumed);
        res.isFirstInDuration = res.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = resTtlMs;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false) {
        return new Promise((resolve7, reject) => {
          const secDuration = Math.floor(msDuration / 1e3);
          const multi = this.client.multi();
          if (forceExpire) {
            if (secDuration > 0) {
              multi.set(rlKey, points, "EX", secDuration);
            } else {
              multi.set(rlKey, points);
            }
            multi.pttl(rlKey).exec((err2, res) => {
              if (err2) {
                return reject(err2);
              }
              return resolve7(res);
            });
          } else {
            if (secDuration > 0) {
              const incrCallback = function(err2, result) {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(result);
              };
              if (typeof this.client.rlflxIncr === "function") {
                this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);
              } else {
                this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);
              }
            } else {
              multi.incrby(rlKey, points).pttl(rlKey).exec((err2, res) => {
                if (err2) {
                  return reject(err2);
                }
                return resolve7(res);
              });
            }
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.multi().get(rlKey).pttl(rlKey).exec((err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              const [points] = res;
              if (points === null) {
                return resolve7(null);
              }
              resolve7(res);
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else {
              resolve7(res > 0);
            }
          });
        });
      }
    };
    module.exports = RateLimiterRedis;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js
var require_RateLimiterMongo = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"(exports, module) {
    init_define_process();
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    function getDriverVersion(client) {
      try {
        const _client = client.client ? client.client : client;
        const { version: version3 } = _client.topology.s.options.metadata.driver;
        const _v = version3.split(".").map((v) => parseInt(v));
        return {
          major: _v[0],
          feature: _v[1],
          patch: _v[2]
        };
      } catch (err2) {
        return { major: 0, feature: 0, patch: 0 };
      }
    }
    var RateLimiterMongo = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.indexKeyPrefix = opts.indexKeyPrefix;
        if (opts.mongo) {
          this.client = opts.mongo;
        } else {
          this.client = opts.storeClient;
        }
        if (typeof this.client.then === "function") {
          this.client.then((conn) => {
            this.client = conn;
            this._initCollection();
            this._driverVersion = getDriverVersion(this.client);
          });
        } else {
          this._initCollection();
          this._driverVersion = getDriverVersion(this.client);
        }
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? RateLimiterMongo.getDbName() : value;
      }
      static getDbName() {
        return "node-rate-limiter-flexible";
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get client() {
        return this._client;
      }
      set client(value) {
        if (typeof value === "undefined") {
          throw new Error("mongo is not set");
        }
        this._client = value;
      }
      get indexKeyPrefix() {
        return this._indexKeyPrefix;
      }
      set indexKeyPrefix(obj) {
        this._indexKeyPrefix = obj || {};
      }
      _initCollection() {
        const db = typeof this.client.db === "function" ? this.client.db(this.dbName) : this.client;
        const collection = db.collection(this.tableName);
        collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });
        collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });
        this._collection = collection;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        let doc;
        if (typeof result.value === "undefined") {
          doc = result;
        } else {
          doc = result.value;
        }
        res.isFirstInDuration = doc.points === changedPoints;
        res.consumedPoints = doc.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;
        return res;
      }
      _upsert(key, points, msDuration, forceExpire = false, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        let where;
        let upsertData;
        if (forceExpire) {
          where = { key };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $set: {
              key,
              points,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            }
          };
          upsertData.$set = Object.assign(upsertData.$set, docAttrs);
        } else {
          where = {
            $or: [
              { expire: { $gt: new Date() } },
              { expire: { $eq: null } }
            ],
            key
          };
          where = Object.assign(where, docAttrs);
          upsertData = {
            $setOnInsert: {
              key,
              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
            },
            $inc: { points }
          };
          upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);
        }
        const upsertOptions = {
          upsert: true
        };
        if (this._driverVersion.major >= 4 || (this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7)) {
          upsertOptions.returnDocument = "after";
        } else {
          upsertOptions.returnOriginal = false;
        }
        return new Promise((resolve7, reject) => {
          this._collection.findOneAndUpdate(
            where,
            upsertData,
            upsertOptions
          ).then((res) => {
            resolve7(res);
          }).catch((errUpsert) => {
            if (errUpsert && errUpsert.code === 11e3) {
              const replaceWhere = Object.assign({
                $or: [
                  { expire: { $lte: new Date() } },
                  { expire: { $eq: null } }
                ],
                key
              }, docAttrs);
              const replaceTo = {
                $set: Object.assign({
                  key,
                  points,
                  expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null
                }, docAttrs)
              };
              this._collection.findOneAndUpdate(
                replaceWhere,
                replaceTo,
                upsertOptions
              ).then((res) => {
                resolve7(res);
              }).catch((errReplace) => {
                if (errReplace && errReplace.code === 11e3) {
                  this._upsert(key, points, msDuration, forceExpire).then((res) => resolve7(res)).catch((err2) => reject(err2));
                } else {
                  reject(errReplace);
                }
              });
            } else {
              reject(errUpsert);
            }
          });
        });
      }
      _get(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({
          key: rlKey,
          $or: [
            { expire: { $gt: new Date() } },
            { expire: { $eq: null } }
          ]
        }, docAttrs);
        return this._collection.findOne(where);
      }
      _delete(rlKey, options = {}) {
        if (!this._collection) {
          return Promise.reject(Error("Mongo connection is not established"));
        }
        const docAttrs = options.attrs || {};
        const where = Object.assign({ key: rlKey }, docAttrs);
        return this._collection.deleteOne(where).then((res) => res.deletedCount > 0);
      }
    };
    module.exports = RateLimiterMongo;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js
var require_RateLimiterMySQL = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMySQL.js"(exports, module) {
    init_define_process();
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMySQL = class extends RateLimiterStoreAbstract {
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.dbName = opts.dbName;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createDbAndTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (this.clearExpiredByTimeout) {
            this._clearExpiredHourAgo();
          }
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          this._getConnection().then((conn) => {
            conn.query(`DELETE FROM ??.?? WHERE expire < ?`, [this.dbName, this.tableName, expire], () => {
              this._releaseConnection(conn);
              resolve7();
            });
          }).catch(() => {
            resolve7();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return new Promise((resolve7, reject) => {
              this.client.getConnection((errConn, conn) => {
                if (errConn) {
                  return reject(errConn);
                }
                resolve7(conn);
              });
            });
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return conn.release();
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          default:
            return true;
        }
      }
      _createDbAndTable() {
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`, (errDb) => {
              if (errDb) {
                this._releaseConnection(conn);
                return reject(errDb);
              }
              conn.query(this._getCreateTableStmt(), (err2) => {
                if (err2) {
                  this._releaseConnection(conn);
                  return reject(err2);
                }
                this._releaseConnection(conn);
                resolve7();
              });
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        if (typeof value === "undefined") {
          if (this.client.constructor.name === "Connection") {
            value = "connection";
          } else if (this.client.constructor.name === "Pool") {
            value = "pool";
          } else if (this.client.constructor.name === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get dbName() {
        return this._dbName;
      }
      set dbName(value) {
        this._dbName = typeof value === "undefined" ? "rtlmtrflx" : value;
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const [row] = result;
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _upsertTransaction(conn, key, points, msDuration, forceExpire) {
        return new Promise((resolve7, reject) => {
          conn.query("BEGIN", (errBegin) => {
            if (errBegin) {
              conn.rollback();
              return reject(errBegin);
            }
            const dateNow = Date.now();
            const newExpire = msDuration > 0 ? dateNow + msDuration : null;
            let q;
            let values;
            if (forceExpire) {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                points,
                newExpire
              ];
            } else {
              q = `INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`;
              values = [
                this.dbName,
                this.tableName,
                key,
                points,
                newExpire,
                dateNow,
                points,
                points,
                dateNow,
                newExpire
              ];
            }
            conn.query(q, values, (errUpsert) => {
              if (errUpsert) {
                conn.rollback();
                return reject(errUpsert);
              }
              conn.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;", [this.dbName, this.tableName, key], (errSelect, res) => {
                if (errSelect) {
                  conn.rollback();
                  return reject(errSelect);
                }
                conn.query("COMMIT", (err2) => {
                  if (err2) {
                    conn.rollback();
                    return reject(err2);
                  }
                  resolve7(res);
                });
              });
            });
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            this._upsertTransaction(conn, key, points, msDuration, forceExpire).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",
              [this.dbName, this.tableName, rlKey, Date.now()],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else if (res.length === 0) {
                  resolve7(null);
                } else {
                  resolve7(res);
                }
                this._releaseConnection(conn);
              }
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(
              "DELETE FROM ??.?? WHERE `key` = ?",
              [this.dbName, this.tableName, rlKey],
              (err2, res) => {
                if (err2) {
                  reject(err2);
                } else {
                  resolve7(res.affectedRows > 0);
                }
                this._releaseConnection(conn);
              }
            );
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
    };
    module.exports = RateLimiterMySQL;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js
var require_RateLimiterPostgres = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"(exports, module) {
    init_define_process();
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterPostgres = class extends RateLimiterStoreAbstract {
      constructor(opts, cb = null) {
        super(opts);
        this.client = opts.storeClient;
        this.clientType = opts.storeType;
        this.tableName = opts.tableName;
        this.clearExpiredByTimeout = opts.clearExpiredByTimeout;
        this.tableCreated = opts.tableCreated;
        if (!this.tableCreated) {
          this._createTable().then(() => {
            this.tableCreated = true;
            if (this.clearExpiredByTimeout) {
              this._clearExpiredHourAgo();
            }
            if (typeof cb === "function") {
              cb();
            }
          }).catch((err2) => {
            if (typeof cb === "function") {
              cb(err2);
            } else {
              throw err2;
            }
          });
        } else {
          if (typeof cb === "function") {
            cb();
          }
        }
      }
      clearExpired(expire) {
        return new Promise((resolve7) => {
          const q = {
            name: "rlflx-clear-expired",
            text: `DELETE FROM ${this.tableName} WHERE expire < $1`,
            values: [expire]
          };
          this._query(q).then(() => {
            resolve7();
          }).catch(() => {
            resolve7();
          });
        });
      }
      _clearExpiredHourAgo() {
        if (this._clearExpiredTimeoutId) {
          clearTimeout(this._clearExpiredTimeoutId);
        }
        this._clearExpiredTimeoutId = setTimeout(() => {
          this.clearExpired(Date.now() - 36e5).then(() => {
            this._clearExpiredHourAgo();
          });
        }, 3e5);
        this._clearExpiredTimeoutId.unref();
      }
      _getConnection() {
        switch (this.clientType) {
          case "pool":
            return Promise.resolve(this.client);
          case "sequelize":
            return this.client.connectionManager.getConnection();
          case "knex":
            return this.client.client.acquireConnection();
          case "typeorm":
            return Promise.resolve(this.client.driver.master);
          default:
            return Promise.resolve(this.client);
        }
      }
      _releaseConnection(conn) {
        switch (this.clientType) {
          case "pool":
            return true;
          case "sequelize":
            return this.client.connectionManager.releaseConnection(conn);
          case "knex":
            return this.client.client.releaseConnection(conn);
          case "typeorm":
            return true;
          default:
            return true;
        }
      }
      _createTable() {
        return new Promise((resolve7, reject) => {
          this._query({
            text: this._getCreateTableStmt()
          }).then(() => {
            resolve7();
          }).catch((err2) => {
            if (err2.code === "23505") {
              resolve7();
            } else {
              reject(err2);
            }
          });
        });
      }
      _getCreateTableStmt() {
        return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`;
      }
      get clientType() {
        return this._clientType;
      }
      set clientType(value) {
        const constructorName = this.client.constructor.name;
        if (typeof value === "undefined") {
          if (constructorName === "Client") {
            value = "client";
          } else if (constructorName === "Pool" || constructorName === "BoundPool") {
            value = "pool";
          } else if (constructorName === "Sequelize") {
            value = "sequelize";
          } else {
            throw new Error("storeType is not defined");
          }
        }
        this._clientType = value.toLowerCase();
      }
      get tableName() {
        return this._tableName;
      }
      set tableName(value) {
        this._tableName = typeof value === "undefined" ? this.keyPrefix : value;
      }
      get tableCreated() {
        return this._tableCreated;
      }
      set tableCreated(value) {
        this._tableCreated = typeof value === "undefined" ? false : !!value;
      }
      get clearExpiredByTimeout() {
        return this._clearExpiredByTimeout;
      }
      set clearExpiredByTimeout(value) {
        this._clearExpiredByTimeout = typeof value === "undefined" ? true : Boolean(value);
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        const row = result.rows[0];
        res.isFirstInDuration = changedPoints === row.points;
        res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;
        return res;
      }
      _query(q) {
        const prefix = this.tableName.toLowerCase();
        const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };
        return new Promise((resolve7, reject) => {
          this._getConnection().then((conn) => {
            conn.query(queryObj).then((res) => {
              resolve7(res);
              this._releaseConnection(conn);
            }).catch((err2) => {
              reject(err2);
              this._releaseConnection(conn);
            });
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _upsert(key, points, msDuration, forceExpire = false) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        const newExpire = msDuration > 0 ? Date.now() + msDuration : null;
        const expireQ = forceExpire ? " $3 " : ` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;
        return this._query({
          name: forceExpire ? "rlflx-upsert-force" : "rlflx-upsert",
          text: `
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${expireQ}
            RETURNING points, expire;`,
          values: [key, points, newExpire, Date.now()]
        });
      }
      _get(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return new Promise((resolve7, reject) => {
          this._query({
            name: "rlflx-get",
            text: `
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,
            values: [rlKey, Date.now()]
          }).then((res) => {
            if (res.rowCount === 0) {
              res = null;
            }
            resolve7(res);
          }).catch((err2) => {
            reject(err2);
          });
        });
      }
      _delete(rlKey) {
        if (!this.tableCreated) {
          return Promise.reject(Error("Table is not created yet"));
        }
        return this._query({
          name: "rlflx-delete",
          text: `DELETE FROM ${this.tableName} WHERE key = $1`,
          values: [rlKey]
        }).then((res) => res.rowCount > 0);
      }
    };
    module.exports = RateLimiterPostgres;
  }
});

// (disabled):cluster
var require_cluster = __commonJS({
  "(disabled):cluster"() {
    init_define_process();
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js
var require_Record = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/MemoryStorage/Record.js"(exports, module) {
    init_define_process();
    module.exports = class Record {
      constructor(value, expiresAt, timeoutId = null) {
        this.value = value;
        this.expiresAt = expiresAt;
        this.timeoutId = timeoutId;
      }
      get value() {
        return this._value;
      }
      set value(value) {
        this._value = parseInt(value);
      }
      get expiresAt() {
        return this._expiresAt;
      }
      set expiresAt(value) {
        if (!(value instanceof Date) && Number.isInteger(value)) {
          value = new Date(value);
        }
        this._expiresAt = value;
      }
      get timeoutId() {
        return this._timeoutId;
      }
      set timeoutId(value) {
        this._timeoutId = value;
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js
var require_MemoryStorage = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/MemoryStorage/MemoryStorage.js"(exports, module) {
    init_define_process();
    var Record3 = require_Record();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class MemoryStorage {
      constructor() {
        this._storage = {};
      }
      incrby(key, value, durationSec) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          if (msBeforeExpires !== 0) {
            this._storage[key].value = this._storage[key].value + value;
            return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
          }
          return this.set(key, value, durationSec);
        }
        return this.set(key, value, durationSec);
      }
      set(key, value, durationSec) {
        const durationMs = durationSec * 1e3;
        if (this._storage[key] && this._storage[key].timeoutId) {
          clearTimeout(this._storage[key].timeoutId);
        }
        this._storage[key] = new Record3(
          value,
          durationMs > 0 ? new Date(Date.now() + durationMs) : null
        );
        if (durationMs > 0) {
          this._storage[key].timeoutId = setTimeout(() => {
            delete this._storage[key];
          }, durationMs);
          if (this._storage[key].timeoutId.unref) {
            this._storage[key].timeoutId.unref();
          }
        }
        return new RateLimiterRes(0, durationMs === 0 ? -1 : durationMs, this._storage[key].value, true);
      }
      get(key) {
        if (this._storage[key]) {
          const msBeforeExpires = this._storage[key].expiresAt ? this._storage[key].expiresAt.getTime() - new Date().getTime() : -1;
          return new RateLimiterRes(0, msBeforeExpires, this._storage[key].value, false);
        }
        return null;
      }
      delete(key) {
        if (this._storage[key]) {
          if (this._storage[key].timeoutId) {
            clearTimeout(this._storage[key].timeoutId);
          }
          delete this._storage[key];
          return true;
        }
        return false;
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js
var require_RateLimiterMemory = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"(exports, module) {
    init_define_process();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var MemoryStorage = require_MemoryStorage();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemory2 = class extends RateLimiterAbstract {
      constructor(opts = {}) {
        super(opts);
        this._memoryStorage = new MemoryStorage();
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const rlKey = this.getKey(key);
          const secDuration = this._getKeySecDuration(options);
          let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          if (res.consumedPoints > this.points) {
            if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
              res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
            }
            reject(res);
          } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
            let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
            if (delay < this.execEvenlyMinDelayMs) {
              delay = res.consumedPoints * this.execEvenlyMinDelayMs;
            }
            setTimeout(resolve7, delay, res);
          } else {
            resolve7(res);
          }
        });
      }
      penalty(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      reward(key, points = 1, options = {}) {
        const rlKey = this.getKey(key);
        return new Promise((resolve7) => {
          const secDuration = this._getKeySecDuration(options);
          const res = this._memoryStorage.incrby(rlKey, -points, secDuration);
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
          resolve7(res);
        });
      }
      block(key, secDuration) {
        const msDuration = secDuration * 1e3;
        const initPoints = this.points + 1;
        this._memoryStorage.set(this.getKey(key), initPoints, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)
        );
      }
      set(key, points, secDuration) {
        const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
        this._memoryStorage.set(this.getKey(key), points, secDuration);
        return Promise.resolve(
          new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)
        );
      }
      get(key) {
        const res = this._memoryStorage.get(this.getKey(key));
        if (res !== null) {
          res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        }
        return Promise.resolve(res);
      }
      delete(key) {
        return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));
      }
    };
    module.exports = RateLimiterMemory2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js
var require_RateLimiterCluster = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"(exports, module) {
    init_define_process();
    var cluster = require_cluster();
    var crypto2 = require_crypto();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    var RateLimiterMemory2 = require_RateLimiterMemory();
    var RateLimiterRes = require_RateLimiterRes();
    var channel = "rate_limiter_flexible";
    var masterInstance = null;
    var masterSendToWorker = function(worker, msg, type, res) {
      let data;
      if (res === null || res === true || res === false) {
        data = res;
      } else {
        data = {
          remainingPoints: res.remainingPoints,
          msBeforeNext: res.msBeforeNext,
          consumedPoints: res.consumedPoints,
          isFirstInDuration: res.isFirstInDuration
        };
      }
      worker.send({
        channel,
        keyPrefix: msg.keyPrefix,
        promiseId: msg.promiseId,
        type,
        data
      });
    };
    var workerWaitInit = function(payload) {
      setTimeout(() => {
        if (this._initiated) {
          define_process_default.send(payload);
        } else if (typeof this._promises[payload.promiseId] !== "undefined") {
          workerWaitInit.call(this, payload);
        }
      }, 30);
    };
    var workerSendToMaster = function(func, promiseId, key, arg, opts) {
      const payload = {
        channel,
        keyPrefix: this.keyPrefix,
        func,
        promiseId,
        data: {
          key,
          arg,
          opts
        }
      };
      if (!this._initiated) {
        workerWaitInit.call(this, payload);
      } else {
        define_process_default.send(payload);
      }
    };
    var masterProcessMsg = function(worker, msg) {
      if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === "undefined") {
        return false;
      }
      let promise;
      switch (msg.func) {
        case "consume":
          promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "penalty":
          promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "reward":
          promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "block":
          promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);
          break;
        case "get":
          promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);
          break;
        case "delete":
          promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);
          break;
        default:
          return false;
      }
      if (promise) {
        promise.then((res) => {
          masterSendToWorker(worker, msg, "resolve", res);
        }).catch((rejRes) => {
          masterSendToWorker(worker, msg, "reject", rejRes);
        });
      }
    };
    var workerProcessMsg = function(msg) {
      if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {
        return false;
      }
      if (this._promises[msg.promiseId]) {
        clearTimeout(this._promises[msg.promiseId].timeoutId);
        let res;
        if (msg.data === null || msg.data === true || msg.data === false) {
          res = msg.data;
        } else {
          res = new RateLimiterRes(
            msg.data.remainingPoints,
            msg.data.msBeforeNext,
            msg.data.consumedPoints,
            msg.data.isFirstInDuration
          );
        }
        switch (msg.type) {
          case "resolve":
            this._promises[msg.promiseId].resolve(res);
            break;
          case "reject":
            this._promises[msg.promiseId].reject(res);
            break;
          default:
            throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);
        }
        delete this._promises[msg.promiseId];
      }
    };
    var getOpts = function() {
      return {
        points: this.points,
        duration: this.duration,
        blockDuration: this.blockDuration,
        execEvenly: this.execEvenly,
        execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,
        keyPrefix: this.keyPrefix
      };
    };
    var savePromise = function(resolve7, reject) {
      const hrtime = define_process_default.hrtime();
      let promiseId = hrtime[0].toString() + hrtime[1].toString();
      if (typeof this._promises[promiseId] !== "undefined") {
        promiseId += crypto2.randomBytes(12).toString("base64");
      }
      this._promises[promiseId] = {
        resolve: resolve7,
        reject,
        timeoutId: setTimeout(() => {
          delete this._promises[promiseId];
          reject(new Error("RateLimiterCluster timeout: no answer from master in time"));
        }, this.timeoutMs)
      };
      return promiseId;
    };
    var RateLimiterClusterMaster = class {
      constructor() {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        cluster.setMaxListeners(0);
        cluster.on("message", (worker, msg) => {
          if (msg && msg.channel === channel && msg.type === "init") {
            if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
              this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory2(msg.opts);
            }
            worker.send({
              channel,
              type: "init",
              keyPrefix: msg.opts.keyPrefix
            });
          } else {
            masterProcessMsg.call(this, worker, msg);
          }
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterMasterPM2 = class {
      constructor(pm2) {
        if (masterInstance) {
          return masterInstance;
        }
        this._rateLimiters = {};
        pm2.launchBus((err2, pm2Bus) => {
          pm2Bus.on("process:msg", (packet) => {
            const msg = packet.raw;
            if (msg && msg.channel === channel && msg.type === "init") {
              if (typeof this._rateLimiters[msg.opts.keyPrefix] === "undefined") {
                this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory2(msg.opts);
              }
              pm2.sendDataToProcessId(packet.process.pm_id, {
                data: {},
                topic: channel,
                channel,
                type: "init",
                keyPrefix: msg.opts.keyPrefix
              }, (sendErr, res) => {
                if (sendErr) {
                  console.log(sendErr, res);
                }
              });
            } else {
              const worker = {
                send: (msgData) => {
                  const pm2Message = msgData;
                  pm2Message.topic = channel;
                  if (typeof pm2Message.data === "undefined") {
                    pm2Message.data = {};
                  }
                  pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {
                    if (sendErr) {
                      console.log(sendErr, res);
                    }
                  });
                }
              };
              masterProcessMsg.call(this, worker, msg);
            }
          });
        });
        masterInstance = this;
      }
    };
    var RateLimiterClusterWorker = class extends RateLimiterAbstract {
      get timeoutMs() {
        return this._timeoutMs;
      }
      set timeoutMs(value) {
        this._timeoutMs = typeof value === "undefined" ? 5e3 : Math.abs(parseInt(value));
      }
      constructor(opts = {}) {
        super(opts);
        define_process_default.setMaxListeners(0);
        this.timeoutMs = opts.timeoutMs;
        this._initiated = false;
        define_process_default.on("message", (msg) => {
          if (msg && msg.channel === channel && msg.type === "init" && msg.keyPrefix === this.keyPrefix) {
            this._initiated = true;
          } else {
            workerProcessMsg.call(this, msg);
          }
        });
        define_process_default.send({
          channel,
          type: "init",
          opts: getOpts.call(this)
        });
        this._promises = {};
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "consume", promiseId, key, pointsToConsume, options);
        });
      }
      penalty(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "penalty", promiseId, key, points, options);
        });
      }
      reward(key, points = 1, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "reward", promiseId, key, points, options);
        });
      }
      block(key, secDuration, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "block", promiseId, key, secDuration, options);
        });
      }
      get(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "get", promiseId, key, options);
        });
      }
      delete(key, options = {}) {
        return new Promise((resolve7, reject) => {
          const promiseId = savePromise.call(this, resolve7, reject);
          workerSendToMaster.call(this, "delete", promiseId, key, options);
        });
      }
    };
    module.exports = {
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster: RateLimiterClusterWorker
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js
var require_RateLimiterMemcache = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterMemcache.js"(exports, module) {
    init_define_process();
    var RateLimiterStoreAbstract = require_RateLimiterStoreAbstract();
    var RateLimiterRes = require_RateLimiterRes();
    var RateLimiterMemcache = class extends RateLimiterStoreAbstract {
      constructor(opts) {
        super(opts);
        this.client = opts.storeClient;
      }
      _getRateLimiterRes(rlKey, changedPoints, result) {
        const res = new RateLimiterRes();
        res.consumedPoints = parseInt(result.consumedPoints);
        res.isFirstInDuration = result.consumedPoints === changedPoints;
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
        res.msBeforeNext = result.msBeforeNext;
        return res;
      }
      _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          const secDuration = Math.floor(msDuration / 1e3);
          if (forceExpire) {
            this.client.set(rlKey, points, secDuration, (err2) => {
              if (!err2) {
                this.client.set(
                  `${rlKey}_expire`,
                  secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                  secDuration,
                  () => {
                    const res = {
                      consumedPoints: points,
                      msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                    };
                    resolve7(res);
                  }
                );
              } else {
                reject(err2);
              }
            });
          } else {
            this.client.incr(rlKey, points, (err2, consumedPoints) => {
              if (err2 || consumedPoints === false) {
                this.client.add(rlKey, points, secDuration, (errAddKey, createdNew) => {
                  if (errAddKey || !createdNew) {
                    if (typeof options.attemptNumber === "undefined" || options.attemptNumber < 3) {
                      const nextOptions = Object.assign({}, options);
                      nextOptions.attemptNumber = nextOptions.attemptNumber ? nextOptions.attemptNumber + 1 : 1;
                      this._upsert(rlKey, points, msDuration, forceExpire, nextOptions).then((resUpsert) => resolve7(resUpsert)).catch((errUpsert) => reject(errUpsert));
                    } else {
                      reject(new Error("Can not add key"));
                    }
                  } else {
                    this.client.add(
                      `${rlKey}_expire`,
                      secDuration > 0 ? nowMs + secDuration * 1e3 : -1,
                      secDuration,
                      () => {
                        const res = {
                          consumedPoints: points,
                          msBeforeNext: secDuration > 0 ? secDuration * 1e3 : -1
                        };
                        resolve7(res);
                      }
                    );
                  }
                });
              } else {
                this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                  if (errGetExpire) {
                    reject(errGetExpire);
                  } else {
                    const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                    const res = {
                      consumedPoints,
                      msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                    };
                    resolve7(res);
                  }
                });
              }
            });
          }
        });
      }
      _get(rlKey) {
        return new Promise((resolve7, reject) => {
          const nowMs = Date.now();
          this.client.get(rlKey, (err2, consumedPoints) => {
            if (!consumedPoints) {
              resolve7(null);
            } else {
              this.client.get(`${rlKey}_expire`, (errGetExpire, resGetExpireMs) => {
                if (errGetExpire) {
                  reject(errGetExpire);
                } else {
                  const expireMs = resGetExpireMs === false ? 0 : resGetExpireMs;
                  const res = {
                    consumedPoints,
                    msBeforeNext: expireMs >= 0 ? Math.max(expireMs - nowMs, 0) : -1
                  };
                  resolve7(res);
                }
              });
            }
          });
        });
      }
      _delete(rlKey) {
        return new Promise((resolve7, reject) => {
          this.client.del(rlKey, (err2, res) => {
            if (err2) {
              reject(err2);
            } else if (res === false) {
              resolve7(res);
            } else {
              this.client.del(`${rlKey}_expire`, (errDelExpire) => {
                if (errDelExpire) {
                  reject(errDelExpire);
                } else {
                  resolve7(res);
                }
              });
            }
          });
        });
      }
    };
    module.exports = RateLimiterMemcache;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js
var require_RLWrapperBlackAndWhite = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RLWrapperBlackAndWhite.js"(exports, module) {
    init_define_process();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class RLWrapperBlackAndWhite {
      constructor(opts = {}) {
        this.limiter = opts.limiter;
        this.blackList = opts.blackList;
        this.whiteList = opts.whiteList;
        this.isBlackListed = opts.isBlackListed;
        this.isWhiteListed = opts.isWhiteListed;
        this.runActionAnyway = opts.runActionAnyway;
      }
      get limiter() {
        return this._limiter;
      }
      set limiter(value) {
        if (typeof value === "undefined") {
          throw new Error("limiter is not set");
        }
        this._limiter = value;
      }
      get runActionAnyway() {
        return this._runActionAnyway;
      }
      set runActionAnyway(value) {
        this._runActionAnyway = typeof value === "undefined" ? false : value;
      }
      get blackList() {
        return this._blackList;
      }
      set blackList(value) {
        this._blackList = Array.isArray(value) ? value : [];
      }
      get isBlackListed() {
        return this._isBlackListed;
      }
      set isBlackListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isBlackListed must be function");
        }
        this._isBlackListed = func;
      }
      get whiteList() {
        return this._whiteList;
      }
      set whiteList(value) {
        this._whiteList = Array.isArray(value) ? value : [];
      }
      get isWhiteListed() {
        return this._isWhiteListed;
      }
      set isWhiteListed(func) {
        if (typeof func === "undefined") {
          func = () => false;
        }
        if (typeof func !== "function") {
          throw new Error("isWhiteListed must be function");
        }
        this._isWhiteListed = func;
      }
      isBlackListedSomewhere(key) {
        return this.blackList.indexOf(key) >= 0 || this.isBlackListed(key);
      }
      isWhiteListedSomewhere(key) {
        return this.whiteList.indexOf(key) >= 0 || this.isWhiteListed(key);
      }
      getBlackRes() {
        return new RateLimiterRes(0, Number.MAX_SAFE_INTEGER, 0, false);
      }
      getWhiteRes() {
        return new RateLimiterRes(Number.MAX_SAFE_INTEGER, 0, 0, false);
      }
      rejectBlack() {
        return Promise.reject(this.getBlackRes());
      }
      resolveBlack() {
        return Promise.resolve(this.getBlackRes());
      }
      resolveWhite() {
        return Promise.resolve(this.getWhiteRes());
      }
      consume(key, pointsToConsume = 1) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.rejectBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.consume(key, pointsToConsume);
        }
        if (this.runActionAnyway) {
          this.limiter.consume(key, pointsToConsume).catch(() => {
          });
        }
        return res;
      }
      block(key, secDuration) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.block(key, secDuration);
        }
        if (this.runActionAnyway) {
          this.limiter.block(key, secDuration).catch(() => {
          });
        }
        return res;
      }
      penalty(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.penalty(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.penalty(key, points).catch(() => {
          });
        }
        return res;
      }
      reward(key, points) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined") {
          return this.limiter.reward(key, points);
        }
        if (this.runActionAnyway) {
          this.limiter.reward(key, points).catch(() => {
          });
        }
        return res;
      }
      get(key) {
        let res;
        if (this.isWhiteListedSomewhere(key)) {
          res = this.resolveWhite();
        } else if (this.isBlackListedSomewhere(key)) {
          res = this.resolveBlack();
        }
        if (typeof res === "undefined" || this.runActionAnyway) {
          return this.limiter.get(key);
        }
        return res;
      }
      delete(key) {
        return this.limiter.delete(key);
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js
var require_RateLimiterUnion = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterUnion.js"(exports, module) {
    init_define_process();
    var RateLimiterAbstract = require_RateLimiterAbstract();
    module.exports = class RateLimiterUnion {
      constructor(...limiters) {
        if (limiters.length < 2) {
          throw new Error("RateLimiterUnion: at least two limiters have to be set");
        }
        limiters.forEach((limiter) => {
          if (!(limiter instanceof RateLimiterAbstract)) {
            throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract");
          }
        });
        this._limiters = limiters;
      }
      consume(key, points = 1) {
        return new Promise((resolve7, reject) => {
          const promises = [];
          this._limiters.forEach((limiter) => {
            promises.push(limiter.consume(key, points).catch((rej) => ({ rejected: true, rej })));
          });
          Promise.all(promises).then((res) => {
            const resObj = {};
            let rejected = false;
            res.forEach((item) => {
              if (item.rejected === true) {
                rejected = true;
              }
            });
            for (let i = 0; i < res.length; i++) {
              if (rejected && res[i].rejected === true) {
                resObj[this._limiters[i].keyPrefix] = res[i].rej;
              } else if (!rejected) {
                resObj[this._limiters[i].keyPrefix] = res[i];
              }
            }
            if (rejected) {
              reject(resObj);
            } else {
              resolve7(resObj);
            }
          });
        });
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js
var require_RateLimiterQueueError = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/component/RateLimiterQueueError.js"(exports, module) {
    init_define_process();
    module.exports = class RateLimiterQueueError extends Error {
      constructor(message2, extra) {
        super();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "CustomError";
        this.message = message2;
        if (extra) {
          this.extra = extra;
        }
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js
var require_RateLimiterQueue = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/RateLimiterQueue.js"(exports, module) {
    init_define_process();
    var RateLimiterQueueError = require_RateLimiterQueueError();
    var MAX_QUEUE_SIZE = 4294967295;
    var KEY_DEFAULT = "limiter";
    module.exports = class RateLimiterQueue {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE
      }) {
        this._queueLimiters = {
          KEY_DEFAULT: new RateLimiterQueueInternal(limiterFlexible, opts)
        };
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining(key = KEY_DEFAULT) {
        if (this._queueLimiters[key]) {
          return this._queueLimiters[key].getTokensRemaining();
        } else {
          return Promise.resolve(this._limiterFlexible.points);
        }
      }
      removeTokens(tokens, key = KEY_DEFAULT) {
        if (!this._queueLimiters[key]) {
          this._queueLimiters[key] = new RateLimiterQueueInternal(
            this._limiterFlexible,
            {
              key,
              maxQueueSize: this._maxQueueSize
            }
          );
        }
        return this._queueLimiters[key].removeTokens(tokens);
      }
    };
    var RateLimiterQueueInternal = class {
      constructor(limiterFlexible, opts = {
        maxQueueSize: MAX_QUEUE_SIZE,
        key: KEY_DEFAULT
      }) {
        this._key = opts.key;
        this._waitTimeout = null;
        this._queue = [];
        this._limiterFlexible = limiterFlexible;
        this._maxQueueSize = opts.maxQueueSize;
      }
      getTokensRemaining() {
        return this._limiterFlexible.get(this._key).then((rlRes) => {
          return rlRes !== null ? rlRes.remainingPoints : this._limiterFlexible.points;
        });
      }
      removeTokens(tokens) {
        const _this = this;
        return new Promise((resolve7, reject) => {
          if (tokens > _this._limiterFlexible.points) {
            reject(new RateLimiterQueueError(`Requested tokens ${tokens} exceeds maximum ${_this._limiterFlexible.points} tokens per interval`));
            return;
          }
          if (_this._queue.length > 0) {
            _this._queueRequest.call(_this, resolve7, reject, tokens);
          } else {
            _this._limiterFlexible.consume(_this._key, tokens).then((res) => {
              resolve7(res.remainingPoints);
            }).catch((rej) => {
              if (rej instanceof Error) {
                reject(rej);
              } else {
                _this._queueRequest.call(_this, resolve7, reject, tokens);
                if (_this._waitTimeout === null) {
                  _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
                }
              }
            });
          }
        });
      }
      _queueRequest(resolve7, reject, tokens) {
        const _this = this;
        if (_this._queue.length < _this._maxQueueSize) {
          _this._queue.push({ resolve: resolve7, reject, tokens });
        } else {
          reject(new RateLimiterQueueError(`Number of requests reached it's maximum ${_this._maxQueueSize}`));
        }
      }
      _processFIFO() {
        const _this = this;
        if (_this._waitTimeout !== null) {
          clearTimeout(_this._waitTimeout);
          _this._waitTimeout = null;
        }
        if (_this._queue.length === 0) {
          return;
        }
        const item = _this._queue.shift();
        _this._limiterFlexible.consume(_this._key, item.tokens).then((res) => {
          item.resolve(res.remainingPoints);
          _this._processFIFO.call(_this);
        }).catch((rej) => {
          if (rej instanceof Error) {
            item.reject(rej);
            _this._processFIFO.call(_this);
          } else {
            _this._queue.unshift(item);
            if (_this._waitTimeout === null) {
              _this._waitTimeout = setTimeout(_this._processFIFO.bind(_this), rej.msBeforeNext);
            }
          }
        });
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js
var require_BurstyRateLimiter = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/lib/BurstyRateLimiter.js"(exports, module) {
    init_define_process();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = class BurstyRateLimiter {
      constructor(rateLimiter, burstLimiter) {
        this._rateLimiter = rateLimiter;
        this._burstLimiter = burstLimiter;
      }
      _combineRes(rlRes, blRes) {
        return new RateLimiterRes(
          rlRes.remainingPoints,
          Math.min(rlRes.msBeforeNext, blRes.msBeforeNext),
          rlRes.consumedPoints,
          rlRes.isFirstInDuration
        );
      }
      consume(key, pointsToConsume = 1, options = {}) {
        return this._rateLimiter.consume(key, pointsToConsume, options).catch((rlRej) => {
          if (rlRej instanceof RateLimiterRes) {
            return this._burstLimiter.consume(key, pointsToConsume, options).then((blRes) => {
              return Promise.resolve(this._combineRes(rlRej, blRes));
            }).catch(
              (blRej) => {
                if (blRej instanceof RateLimiterRes) {
                  return Promise.reject(this._combineRes(rlRej, blRej));
                } else {
                  return Promise.reject(blRej);
                }
              }
            );
          } else {
            return Promise.reject(rlRej);
          }
        });
      }
      get(key) {
        return Promise.all([
          this._rateLimiter.get(key),
          this._burstLimiter.get(key)
        ]).then(([rlRes, blRes]) => {
          return this._combineRes(rlRes, blRes);
        });
      }
      get points() {
        return this._rateLimiter.points;
      }
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/index.js
var require_rate_limiter_flexible = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/rate-limiter-flexible-npm-2.3.11-70ca9ee8d9-9.zip/node_modules/rate-limiter-flexible/index.js"(exports, module) {
    init_define_process();
    var RateLimiterRedis = require_RateLimiterRedis();
    var RateLimiterMongo = require_RateLimiterMongo();
    var RateLimiterMySQL = require_RateLimiterMySQL();
    var RateLimiterPostgres = require_RateLimiterPostgres();
    var { RateLimiterClusterMaster, RateLimiterClusterMasterPM2, RateLimiterCluster } = require_RateLimiterCluster();
    var RateLimiterMemory2 = require_RateLimiterMemory();
    var RateLimiterMemcache = require_RateLimiterMemcache();
    var RLWrapperBlackAndWhite = require_RLWrapperBlackAndWhite();
    var RateLimiterUnion = require_RateLimiterUnion();
    var RateLimiterQueue = require_RateLimiterQueue();
    var BurstyRateLimiter = require_BurstyRateLimiter();
    var RateLimiterRes = require_RateLimiterRes();
    module.exports = {
      RateLimiterRedis,
      RateLimiterMongo,
      RateLimiterMySQL,
      RateLimiterPostgres,
      RateLimiterMemory: RateLimiterMemory2,
      RateLimiterMemcache,
      RateLimiterClusterMaster,
      RateLimiterClusterMasterPM2,
      RateLimiterCluster,
      RLWrapperBlackAndWhite,
      RateLimiterUnion,
      RateLimiterQueue,
      BurstyRateLimiter,
      RateLimiterRes
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-hash-npm-1.0.1-4a73827386-9.zip/node_modules/@stablelib/hash/lib/hash.js
var require_hash = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-hash-npm-1.0.1-4a73827386-9.zip/node_modules/@stablelib/hash/lib/hash.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializableHash(h) {
      return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
    }
    exports.isSerializableHash = isSerializableHash;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-constant-time-npm-1.0.1-47c922000e-9.zip/node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-constant-time-npm-1.0.1-47c922000e-9.zip/node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function select2(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports.select = select2;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    exports.lessOrEqual = lessOrEqual;
    function compare3(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
      }
      return 1 & result - 1 >>> 8;
    }
    exports.compare = compare3;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare3(a, b) !== 0;
    }
    exports.equal = equal;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-wipe-npm-1.0.1-3395f422e4-9.zip/node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-wipe-npm-1.0.1-3395f422e4-9.zip/node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-hmac-npm-1.0.1-5f0464fe55-9.zip/node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-hmac-npm-1.0.1-5f0464fe55-9.zip/node_modules/@stablelib/hmac/lib/hmac.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = function() {
      function HMAC2(hash3, key) {
        this._finished = false;
        this._inner = new hash3();
        this._outer = new hash3();
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          this._inner.update(key).finish(pad).clean();
        } else {
          pad.set(key);
        }
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54;
        }
        this._inner.update(pad);
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54 ^ 92;
        }
        this._outer.update(pad);
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
          this._innerKeyedState = this._inner.saveState();
          this._outerKeyedState = this._outer.saveState();
        }
        wipe_1.wipe(pad);
      }
      HMAC2.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
          this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
          this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this._inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this._finished) {
          this._outer.finish(out);
          return this;
        }
        this._inner.finish(out);
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      HMAC2.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
      };
      HMAC2.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
      };
      return HMAC2;
    }();
    exports.HMAC = HMAC;
    function hmac(hash3, key, data) {
      var h = new HMAC(hash3, key);
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hmac = hmac;
    exports.equal = constant_time_1.equal;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-hkdf-npm-1.0.1-035692b7fd-9.zip/node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-hkdf-npm-1.0.1-035692b7fd-9.zip/node_modules/@stablelib/hkdf/lib/hkdf.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hmac_1 = require_hmac();
    var wipe_1 = require_wipe();
    var HKDF2 = function() {
      function HKDF3(hash3, key, salt, info) {
        if (salt === void 0) {
          salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1);
        this._hash = hash3;
        this._info = info;
        var okm = hmac_1.hmac(this._hash, salt, key);
        this._hmac = new hmac_1.HMAC(hash3, okm);
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
      }
      HKDF3.prototype._fillBuffer = function() {
        this._counter[0]++;
        var ctr = this._counter[0];
        if (ctr === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        this._hmac.reset();
        if (ctr > 1) {
          this._hmac.update(this._buffer);
        }
        if (this._info) {
          this._hmac.update(this._info);
        }
        this._hmac.update(this._counter);
        this._hmac.finish(this._buffer);
        this._bufpos = 0;
      };
      HKDF3.prototype.expand = function(length5) {
        var out = new Uint8Array(length5);
        for (var i = 0; i < out.length; i++) {
          if (this._bufpos === this._buffer.length) {
            this._fillBuffer();
          }
          out[i] = this._buffer[this._bufpos++];
        }
        return out;
      };
      HKDF3.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
      };
      return HKDF3;
    }();
    exports.HKDF = HKDF2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/browser.js
var require_browser6 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length5) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length5);
        for (let i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length5) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length5);
        if (buffer2.length !== length5) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length5);
        for (let i = 0; i < out.length; i++) {
          out[i] = buffer2[i];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser6();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length5) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length5);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-int-npm-1.0.1-c8f9f3f48e-9.zip/node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-int-npm-1.0.1-c8f9f3f48e-9.zip/node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n) {
      return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-binary-npm-1.0.1-dbaa06d163-9.zip/node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-binary-npm-1.0.1-dbaa06d163-9.zip/node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-random-npm-1.0.2-9ec4c00173-9.zip/node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes2(length5, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length5);
    }
    exports.randomBytes = randomBytes2;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf2 = randomBytes2(4, prng);
      const result = (0, binary_1.readUint32LE)(buf2);
      (0, wipe_1.wipe)(buf2);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length5, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length5 > 0) {
        const buf2 = randomBytes2(Math.ceil(length5 * 256 / maxByte), prng);
        for (let i = 0; i < buf2.length && length5 > 0; i++) {
          const randomByte = buf2[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length5--;
          }
        }
        (0, wipe_1.wipe)(buf2);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length5 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length5, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-x25519-npm-1.0.3-5af5204b26-9.zip/node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-x25519-npm-1.0.3-5af5204b26-9.zip/node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random2();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      const r = new Float64Array(16);
      if (init) {
        for (let i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      let c = 1;
      for (let i = 0; i < 16; i++) {
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      for (let i = 0; i < 16; i++) {
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      const m = gf();
      const t = gf();
      for (let i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (let j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (let i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        const b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (let i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpack25519(o, n) {
      for (let i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    function sub(o, a, b) {
      for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    function mul(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, inp) {
      const c = gf();
      for (let i = 0; i < 16; i++) {
        c[i] = inp[i];
      }
      for (let i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
          mul(c, c, inp);
        }
      }
      for (let i = 0; i < 16; i++) {
        o[i] = c[i];
      }
    }
    function scalarMult(n, p) {
      const z = new Uint8Array(32);
      const x = new Float64Array(80);
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (let i = 0; i < 31; i++) {
        z[i] = n[i];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (let i = 0; i < 16; i++) {
        b[i] = x[i];
      }
      a[0] = d[0] = 1;
      for (let i = 254; i >= 0; --i) {
        const r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (let i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      const x32 = x.subarray(32);
      const x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i = 0; i < result.length; i++) {
          zeros |= result[i];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports.sharedKey = sharedKey2;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-sha256-npm-1.0.1-34f1983250-9.zip/node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-sha256-npm-1.0.1-34f1983250-9.zip/node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA2562 = function() {
      function SHA2563() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2563.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2563.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2563.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2563.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2563.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2563.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2563.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2563.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2563;
    }();
    exports.SHA256 = SHA2562;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K2[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash3(data) {
      var h = new SHA2562();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hash = hash3;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-chacha-npm-1.0.1-0677810101-9.zip/node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-chacha-npm-1.0.1-0677810101-9.zip/node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i = 0; i < src.length; i += 64) {
        core(block, nc, key);
        for (var j = i; j < i + 64 && j < src.length; j++) {
          dst[j] = src[j] ^ block[j - i];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-poly1305-npm-1.0.1-f2b5f57a00-9.zip/node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-poly1305-npm-1.0.1-f2b5f57a00-9.zip/node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c;
          c = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this._h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
          this._h[i] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m) {
        var mpos = 0;
        var bytes2 = m.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i = 0; i < bytes2; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    exports.equal = equal;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@stablelib-chacha20poly1305-npm-1.0.1-d772975327-9.zip/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@stablelib-chacha20poly1305-npm-1.0.1-d772975327-9.zip/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS2 = new Uint8Array(16);
    var ChaCha20Poly13052 = function() {
      function ChaCha20Poly13053(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13053.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13053.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13053.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13053.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h.update(ZEROS2.subarray(associatedData.length % 16));
          }
        }
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS2.subarray(ciphertext.length % 16));
        }
        var length5 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length5);
        }
        h.update(length5);
        binary_1.writeUint64LE(ciphertext.length, length5);
        h.update(length5);
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        }
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length5);
      };
      return ChaCha20Poly13053;
    }();
    exports.ChaCha20Poly1305 = ChaCha20Poly13052;
  }
});

// ../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/encode.js"(exports, module) {
    init_define_process();
    module.exports = encode15;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL = ~REST2;
    var INT = Math.pow(2, 31);
    function encode15(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode15.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/decode.js"(exports, module) {
    init_define_process();
    module.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/length.js
var require_length = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/length.js"(exports, module) {
    init_define_process();
    var N1 = Math.pow(2, 7);
    var N2 = Math.pow(2, 14);
    var N3 = Math.pow(2, 21);
    var N4 = Math.pow(2, 28);
    var N5 = Math.pow(2, 35);
    var N6 = Math.pow(2, 42);
    var N7 = Math.pow(2, 49);
    var N8 = Math.pow(2, 56);
    var N9 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/varint-npm-5.0.2-fcb43e79c5-9.zip/node_modules/varint/index.js"(exports, module) {
    init_define_process();
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/varint-decoder-npm-1.0.0-796708c69e-9.zip/node_modules/varint-decoder/src/index.js
var require_src4 = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/varint-decoder-npm-1.0.0-796708c69e-9.zip/node_modules/varint-decoder/src/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var varint7 = require_varint2();
    module.exports = (buf2) => {
      if (!(buf2 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf2.length > 0) {
        const num = varint7.decode(buf2);
        result.push(num);
        buf2 = buf2.slice(varint7.decode.bytes);
      }
      return result;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/@vascosantos-moving-average-npm-1.1.0-80e1957050-9.zip/node_modules/@vascosantos/moving-average/index.js
var require_moving_average = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/@vascosantos-moving-average-npm-1.1.0-80e1957050-9.zip/node_modules/@vascosantos/moving-average/index.js"(exports, module) {
    "use strict";
    init_define_process();
    var exp = Math.exp;
    exports = module.exports = function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      ret.push = function push(time, value) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value - ma;
          const incr = a * diff;
          ma = a * value + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value;
        }
        previousTime = time;
      };
      ret.movingAverage = function movingAverage() {
        return ma;
      };
      ret.variance = function variance() {
        return v;
      };
      ret.deviation = function deviation() {
        return d;
      };
      ret.forecast = function forecast() {
        return f;
      };
      return ret;
    };
  }
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-npm-0.64.2-b40814d95c-9.zip/node_modules/ipfs/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/merge-options-npm-3.0.4-f2ee6b8ea0-9.zip/node_modules/merge-options/index.mjs
init_define_process();
var import_index = __toESM(require_merge_options(), 1);
var merge_options_default = import_index.default;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/index.js
var import_env2 = __toESM(require_env(), 1);
var import_err_code125 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-npm-7.0.0-78f8b1fdbb-9.zip/node_modules/ipfs-unixfs/src/index.js
init_define_process();
var import_err_code = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-npm-7.0.0-78f8b1fdbb-9.zip/node_modules/ipfs-unixfs/src/unixfs.js
init_define_process();
var import_minimal = __toESM(require_minimal(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode15(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode13(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode15(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode13(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata4.prototype.MimeType = "";
  Metadata4.encode = function encode15(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata4.decode = function decode13(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-npm-7.0.0-78f8b1fdbb-9.zip/node_modules/ipfs-unixfs/src/index.js
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class {
  static unmarshal(marshaled) {
    const message2 = PBData.decode(marshaled);
    const decoded = PBData.toObject(message2, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = {
    type: "file"
  }) {
    const {
      type,
      data,
      blockSizes,
      hashType,
      fanout,
      mtime,
      mode
    } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-pb-npm-2.1.18-e97e9c99f1-9.zip/node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code3,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode3,
  encode: () => encode2,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-pb-npm-2.1.18-e97e9c99f1-9.zip/node_modules/@ipld/dag-pb/esm/src/pb-decode.js
init_define_process();
var textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint(bytes2, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes(bytes2, index);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-pb-npm-2.1.18-e97e9c99f1-9.zip/node_modules/@ipld/dag-pb/esm/src/pb-encode.js
init_define_process();
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes2, i, link.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes2.set(link.Hash, i);
    i = encodeVarint(bytes2, i, link.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes2.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes2, i, size2) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-pb-npm-2.1.18-e97e9c99f1-9.zip/node_modules/@ipld/dag-pb/esm/src/util.js
init_define_process();
var pbNodeProperties = [
  "Data",
  "Links"
];
var pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare({
    Data: data,
    Links: links3
  });
}
function createLink(name6, size, cid) {
  return asLink({
    Hash: cid,
    Name: name6,
    Tsize: size
  });
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-pb-npm-2.1.18-e97e9c99f1-9.zip/node_modules/@ipld/dag-pb/esm/src/index.js
var name = "dag-pb";
var code3 = 112;
function encode2(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode3(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-cbor-npm-7.0.3-6f1c52ead1-9.zip/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code4,
  decode: () => decode5,
  encode: () => encode4,
  name: () => name2
});
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/cborg.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/encode.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/is.js
init_define_process();
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/token.js
init_define_process();
var Type = class {
  constructor(major, name6, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name6;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/bl.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/byte-utils.js
init_define_process();
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder3 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (bytes2, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
} : (bytes2, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
};
var fromString2 = useBuffer ? (string) => {
  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);
} : (string) => {
  return string.length > 64 ? textEncoder3.encode(string) : utf8ToBytes(string);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes2, start, end) => {
  if (isBuffer2(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end));
  }
  return bytes2.slice(start, end);
} : (bytes2, start, end) => {
  return bytes2.slice(start, end);
};
var concat2 = useBuffer ? (chunks, length5) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length5));
} : (chunks, length5) => {
  const out = new Uint8Array(length5);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string, units = Infinity) {
  let codePoint;
  const length5 = string.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i = 0; i < length5; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length5) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/common.js
init_define_process();
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/jump.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/0uint.js
init_define_process();
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/1negint.js
init_define_process();
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/2bytes.js
init_define_process();
function toToken(data, pos, prefix, length5) {
  assertEnoughData(data, pos, prefix + length5);
  const buf2 = slice(data, pos + prefix, pos + prefix + length5);
  return new Token(Type.bytes, buf2, prefix + length5);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/3string.js
init_define_process();
function toToken2(data, pos, prefix, length5, options) {
  const totLength = prefix + length5;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/4array.js
init_define_process();
function toToken3(_data, _pos, prefix, length5) {
  return new Token(Type.array, length5, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/5map.js
init_define_process();
function toToken4(_data, _pos, prefix, length5) {
  return new Token(Type.map, length5, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/6tag.js
init_define_process();
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/7float.js
init_define_process();
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent2) {
    this.obj = obj;
    this.parent = parent2;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length5 = isMap ? obj.size : keys.length;
    if (!length5) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length5),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length5),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode3(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/decode.js
init_define_process();
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode4(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-cbor-npm-7.0.3-6f1c52ead1-9.zip/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code4 = 113;
var encode4 = (node) => encode3(node, encodeOptions);
var decode5 = (data) => decode4(data, decodeOptions);

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-json-npm-8.0.11-753657a82f-9.zip/node_modules/@ipld/dag-json/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  code: () => code5,
  decode: () => decode7,
  encode: () => encode6,
  name: () => name3
});
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/json/json.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/json/encode.js
init_define_process();
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
    }
    buf2.push(isa);
  }
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString2(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf2.push([91]);
  }
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf2.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = {
  addBreakTokens: true,
  mapSorter: mapSorter2
};
function encode5(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}

// ../../../../../Users/z/.yarn/berry/cache/cborg-npm-1.9.5-2405456c5f-9.zip/node_modules/cborg/esm/lib/json/decode.js
init_define_process();
var Tokenizer = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this.pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i = this.pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));
        this.pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
};
function decode6(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode4(data, options);
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-dag-json-npm-8.0.11-753657a82f-9.zip/node_modules/@ipld/dag-json/esm/index.js
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Uint8Array: bytesEncoder,
    Buffer: bytesEncoder,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[42] = CID.parse;
var name3 = "dag-json";
var code5 = 297;
var encode6 = (node) => encode5(node, encodeOptions2);
var decode7 = (data) => {
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(data, decodeOptions2) });
  return decode6(data, options);
};

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  code: () => code6,
  decode: () => decode10,
  encode: () => encode9,
  name: () => name4,
  toGeneral: () => toGeneral
});
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/signing.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/utils.js
init_define_process();
function toBase64url(b) {
  return base64url.encode(b).slice(1);
}
function fromBase64url(s) {
  return base64url.decode(`u${s}`);
}

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/signing.js
function fromSplit(split) {
  const [protectedHeader, payload, signature] = split;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode7(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign2 = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign2.header = encoded.header;
  if (encoded.protected)
    sign2.protected = toBase64url(encoded.protected);
  return sign2;
}
function decode8(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID.decode(new Uint8Array(encoded.payload));
  return decoded;
}

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/encryption.js
init_define_process();
function fromSplit2(split) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode8(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode9(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}

// ../../../../../Users/z/.yarn/berry/cache/dag-jose-npm-2.0.1-d44c354221-9.zip/node_modules/dag-jose/lib/index.js
var name4 = "dag-jose";
var code6 = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split = jose.split(".");
    if (split.length === 3) {
      return fromSplit(split);
    } else if (split.length === 5) {
      return fromSplit2(split);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode9(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode7(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode8(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode4(encodedJose));
}
function decode10(data) {
  let encoded;
  try {
    encoded = decode5(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode8(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode9(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/init-assets.browser.js
init_define_process();
function initAssets() {
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/errors.js
init_define_process();
var NotInitializedError = class extends Error {
  constructor(message2 = "not initialized") {
    super(message2);
    this.name = "NotInitializedError";
    this.code = NotInitializedError.code;
  }
};
NotInitializedError.code = "ERR_NOT_INITIALIZED";
var AlreadyInitializingError = class extends Error {
  constructor(message2 = "cannot initialize an initializing node") {
    super(message2);
    this.name = "AlreadyInitializingError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
var AlreadyInitializedError = class extends Error {
  constructor(message2 = "cannot re-initialize an initialized node") {
    super(message2);
    this.name = "AlreadyInitializedError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
var NotStartedError = class extends Error {
  constructor(message2 = "not started") {
    super(message2);
    this.name = "NotStartedError";
    this.code = NotStartedError.code;
  }
};
NotStartedError.code = "ERR_NOT_STARTED";
var AlreadyStartingError = class extends Error {
  constructor(message2 = "cannot start, already startin") {
    super(message2);
    this.name = "AlreadyStartingError";
    this.code = AlreadyStartingError.code;
  }
};
AlreadyStartingError.code = "ERR_ALREADY_STARTING";
var AlreadyStartedError = class extends Error {
  constructor(message2 = "cannot start, already started") {
    super(message2);
    this.name = "AlreadyStartedError";
    this.code = AlreadyStartedError.code;
  }
};
AlreadyStartedError.code = "ERR_ALREADY_STARTED";
var NotEnabledError = class extends Error {
  constructor(message2 = "not enabled") {
    super(message2);
    this.name = "NotEnabledError";
    this.code = NotEnabledError.code;
  }
};
NotEnabledError.code = "ERR_NOT_ENABLED";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/index.js
var import_timeout_abort_controller19 = __toESM(require_timeout_abort_controller(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/start.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils/service.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/is-ipfs-npm-7.0.2-cdcdc99137-9.zip/node_modules/is-ipfs/dist/src/index.js
init_define_process();
var import_iso_url = __toESM(require_iso_url(), 1);
var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
var defaultProtocolMatch = 1;
var defaultHashMath = 2;
var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isCID(hash3) {
  try {
    if (isString(hash3)) {
      return Boolean(CID.parse(hash3));
    }
    if (hash3 instanceof Uint8Array) {
      return Boolean(CID.decode(hash3));
    }
    return Boolean(CID.asCID(hash3));
  } catch {
    return false;
  }
}
function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipfs") {
    return false;
  }
  let hash3 = match[hashMatch];
  if (hash3 != null && pattern === subdomainGatewayPattern) {
    hash3 = hash3.toLowerCase();
  }
  return isCID(hash3);
}
function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
  const formatted = convertToString(input);
  if (formatted === false) {
    return false;
  }
  const match = formatted.match(pattern);
  if (match == null) {
    return false;
  }
  if (match[protocolMatch] !== "ipns") {
    return false;
  }
  let ipnsId = match[hashMatch];
  if (ipnsId != null && pattern === subdomainGatewayPattern) {
    ipnsId = ipnsId.toLowerCase();
    if (isCID(ipnsId))
      return true;
    try {
      if (!ipnsId.includes(".") && ipnsId.includes("-")) {
        ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
      }
      const { hostname } = new import_iso_url.URL(`http://${ipnsId}`);
      return fqdnWithTld.test(hostname);
    } catch (e) {
      return false;
    }
  }
  return true;
}
function isString(input) {
  return typeof input === "string";
}
function convertToString(input) {
  if (input instanceof Uint8Array) {
    return toString(input, "base58btc");
  }
  if (isString(input)) {
    return input;
  }
  return false;
}
var path = (path4) => isIpfs(path4, pathPattern) || isIpns(path4, pathPattern);
var ipfsPath = (path4) => isIpfs(path4, pathPattern);
var ipnsPath = (path4) => isIpns(path4, pathPattern);

// ../../../../../Users/z/.yarn/berry/cache/interface-datastore-npm-7.0.0-34b5866494-9.zip/node_modules/interface-datastore/dist/src/key.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-3.3.4-3d250377d6-9.zip/node_modules/nanoid/index.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-3.3.4-3d250377d6-9.zip/node_modules/nanoid/url-alphabet/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-3.3.4-3d250377d6-9.zip/node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// ../../../../../Users/z/.yarn/berry/cache/interface-datastore-npm-7.0.0-34b5866494-9.zip/node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class {
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  toString(encoding = "utf8") {
    return toString(this._buf, encoding);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(s) {
    return new Key(this.toString() + ":" + s);
  }
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils.js
var import_err_code3 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/with-timeout-option.js
init_define_process();
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal = __toESM(require_any_signal(), 1);

// ../../../../../Users/z/.yarn/berry/cache/parse-duration-npm-1.0.2-99cf19bd71-9.zip/node_modules/parse-duration/index.mjs
init_define_process();
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse.nanosecond = parse.ns = 1 / 1e6;
parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
parse.millisecond = parse.ms = parse[""] = 1;
parse.second = parse.sec = parse.s = parse.ms * 1e3;
parse.minute = parse.min = parse.m = parse.s * 60;
parse.hour = parse.hr = parse.h = parse.m * 60;
parse.day = parse.d = parse.h * 24;
parse.week = parse.wk = parse.w = parse.d * 7;
parse.month = parse.b = parse.d * (365.25 / 12);
parse.year = parse.yr = parse.y = parse.d * 365.25;
function parse(str = "", format = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format) || 1);
}
function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, "")];
}
var parse_duration_default = parse;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/errors.js
init_define_process();
var TimeoutError2 = class extends Error {
  constructor(message2 = "request timed out") {
    super(message2);
    this.name = "TimeoutError";
    this.code = TimeoutError2.code;
  }
};
TimeoutError2.code = "ERR_TIMEOUT";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/with-timeout-option.js
function withTimeoutOption(fn, optionsArgIndex) {
  return (...args) => {
    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
    if (!options || !options.timeout)
      return fn(...args);
    const timeout = typeof options.timeout === "string" ? parse_duration_default(options.timeout) : options.timeout;
    const controller = new import_timeout_abort_controller.TimeoutController(timeout);
    options.signal = (0, import_any_signal.anySignal)([options.signal, controller.signal]);
    const fnRes = fn(...args);
    const timeoutPromise = new Promise((_resolve, reject) => {
      controller.signal.addEventListener("abort", () => {
        reject(new TimeoutError2());
      });
    });
    const start = Date.now();
    const maybeThrowTimeoutError = () => {
      if (controller.signal.aborted) {
        throw new TimeoutError2();
      }
      const timeTaken = Date.now() - start;
      if (timeTaken > timeout) {
        controller.abort();
        throw new TimeoutError2();
      }
    };
    if (fnRes[Symbol.asyncIterator]) {
      return async function* () {
        const it = fnRes[Symbol.asyncIterator]();
        try {
          while (true) {
            const { value, done } = await Promise.race([it.next(), timeoutPromise]);
            if (done) {
              break;
            }
            maybeThrowTimeoutError();
            yield value;
          }
        } catch (err2) {
          maybeThrowTimeoutError();
          throw err2;
        } finally {
          controller.clear();
          if (it.return) {
            it.return();
          }
        }
      }();
    }
    return (async () => {
      try {
        const res = await Promise.race([fnRes, timeoutPromise]);
        maybeThrowTimeoutError();
        return res;
      } catch (err2) {
        maybeThrowTimeoutError();
        throw err2;
      } finally {
        controller.clear();
      }
    })();
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/to-cid-and-path.js
init_define_process();
var import_err_code2 = __toESM(require_err_code(), 1);
var IPFS_PREFIX = "/ipfs/";
function toCidAndPath(string) {
  if (string instanceof Uint8Array) {
    try {
      string = CID.decode(string);
    } catch (err2) {
      throw (0, import_err_code2.default)(err2, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string = string.toString();
  if (string.startsWith(IPFS_PREFIX)) {
    string = string.substring(IPFS_PREFIX.length);
  }
  const parts = string.split("/");
  let path4;
  try {
    cid = CID.parse(parts.shift() || "");
  } catch (err2) {
    throw (0, import_err_code2.default)(err2, "ERR_INVALID_CID");
  }
  if (parts.length) {
    path4 = `/${parts.join("/")}`;
  }
  return {
    cid,
    path: path4
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils.js
var ERR_BAD_PATH = "ERR_BAD_PATH";
var OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
var MFS_ROOT_KEY = new Key("/local/filesroot");
var MFS_MAX_CHUNK_SIZE = 262144;
var normalizePath = (pathStr) => {
  const cid = CID.asCID(pathStr);
  if (cid) {
    return `/ipfs/${pathStr}`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${CID.parse(str)}`;
  } catch {
  }
  if (path(str)) {
    return str;
  } else {
    throw (0, import_err_code3.default)(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
  }
};
var normalizeCidPath = (path4) => {
  if (path4 instanceof Uint8Array) {
    return CID.decode(path4).toString();
  }
  path4 = path4.toString();
  if (path4.indexOf("/ipfs/") === 0) {
    path4 = path4.substring("/ipfs/".length);
  }
  if (path4.charAt(path4.length - 1) === "/") {
    path4 = path4.substring(0, path4.length - 1);
  }
  return path4;
};
var resolvePath = async function(repo, codecs2, ipfsPath3, options = {}) {
  const {
    cid,
    path: path4
  } = toCidAndPath(ipfsPath3);
  if (path4) {
    options.path = path4;
  }
  let lastCid = cid;
  let lastRemainderPath = options.path || "";
  if (lastRemainderPath.startsWith("/")) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const { value, remainderPath } of resolve(cid, options.path, codecs2, repo, {
        signal: options.signal
      })) {
        if (!CID.asCID(value)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value;
      }
    } catch (err2) {
      if (err2.message.startsWith("Object has no property")) {
        err2.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
        err2.code = "ERR_NO_LINK";
      }
      throw err2;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ""
  };
};
var mapFile = (file) => {
  if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
    throw new Error(`Unknown node type '${file.type}'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: "file"
  };
  if (file.type === "directory") {
    output.type = "dir";
  }
  if (file.type === "file") {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === "file" || file.type === "directory") {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== void 0) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
var withTimeout = withTimeoutOption(
  async (promise, _options) => await promise
);
var resolve = async function* (cid, path4, codecs2, repo, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await repo.blocks.get(cid2, options);
    return codec.decode(block);
  };
  const parts = path4.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code3.default)(new Error(`Could not resolve path "${path4}"`), "ERR_INVALID_PATH");
    }
    if (cid.code === code3 && Array.isArray(value.Links)) {
      const link = value.Links.find((l) => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts.join("/")
        };
        value = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code3.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    if (CID.asCID(value)) {
      lastCid = value;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils/service.js
var Service = class {
  static create({ start, stop: stop2 }) {
    return new Service(start, stop2);
  }
  static async start(service, options) {
    const { state, activate } = service;
    switch (state.status) {
      case "stopped": {
        try {
          const promise = activate(options);
          service.state = { status: "starting", ready: promise };
          const result = await promise;
          service.state = { status: "started", value: result };
          return result;
        } catch (error) {
          service.state = { status: "stopped" };
          throw error;
        }
      }
      case "starting": {
        throw new AlreadyStartingError();
      }
      case "started": {
        throw new AlreadyStartedError();
      }
      case "stopping": {
        await state.ready;
        return await Service.start(service, options);
      }
      default: {
        return Service.panic(service);
      }
    }
  }
  static async stop(service) {
    const { state, deactivate } = service;
    switch (state.status) {
      case "stopped": {
        break;
      }
      case "starting": {
        try {
          await state.ready;
        } catch (_) {
        }
        return await Service.stop(service);
      }
      case "stopping": {
        return await state.ready;
      }
      case "started": {
        if (deactivate) {
          await deactivate(state.value);
        }
        service.state = { status: "stopped" };
        break;
      }
      default: {
        Service.panic(state);
      }
    }
  }
  static try({ state }) {
    switch (state.status) {
      case "started":
        return state.value;
      default:
        return null;
    }
  }
  static async use({ state }, options) {
    switch (state.status) {
      case "started":
        return state.value;
      case "starting":
        return await withTimeout(state.ready, options);
      default:
        throw new NotStartedError();
    }
  }
  static panic({ state }) {
    const status = JSON.stringify({ status: state.status });
    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
  }
  constructor(activate, deactivate) {
    this.activate = activate;
    this.deactivate = deactivate;
    this.state = { status: "stopped" };
  }
  async use(options) {
    return await Service.use(this, options);
  }
  try() {
    return Service.try(this);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/start.js
function createStart({ network, preload: preload2, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {
  const start = async () => {
    const { libp2p } = await Service.start(network, {
      peerId,
      repo,
      print,
      hashers,
      options
    });
    await Promise.all([
      ipns.startOnline({ keychain, libp2p, peerId, repo }),
      preload2.start(),
      mfsPreload.start()
    ]);
  };
  return start;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/stop.js
init_define_process();
function createStop({ network, preload: preload2, ipns, repo, mfsPreload }) {
  const stop2 = async () => {
    await Promise.all([
      preload2.stop(),
      ipns.stop(),
      mfsPreload.stop()
    ]);
    await Service.stop(network);
    await repo.close();
  };
  return stop2;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dns.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/dns.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/utils/tlru.js
init_define_process();
var import_hashlru = __toESM(require_hashlru(), 1);
var TLRU = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(key) {
    const value = this.lru.get(key);
    if (value) {
      if (value.expire && value.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value.value;
    }
    return void 0;
  }
  set(key, value, ttl2) {
    this.lru.set(key, { value, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value = this.get(key);
    if (value) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// ../../../../../Users/z/.yarn/berry/cache/p-queue-npm-7.3.0-ad6f2467da-9.zip/node_modules/p-queue/dist/index.js
init_define_process();
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// ../../../../../Users/z/.yarn/berry/cache/p-queue-npm-7.3.0-ad6f2467da-9.zip/node_modules/p-queue/dist/priority-queue.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/p-queue-npm-7.3.0-ad6f2467da-9.zip/node_modules/p-queue/dist/lower-bound.js
init_define_process();
function lowerBound(array, value, comparator) {
  let first10 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first10 + step;
    if (comparator(array[it], value) <= 0) {
      first10 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first10;
}

// ../../../../../Users/z/.yarn/berry/cache/p-queue-npm-7.3.0-ad6f2467da-9.zip/node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();

// ../../../../../Users/z/.yarn/berry/cache/p-queue-npm-7.3.0-ad6f2467da-9.zip/node_modules/p-queue/dist/index.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pendingCount;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_emitEvents;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_onEvent;
var timeoutError = new TimeoutError();
var AbortError = class extends Error {
};
var PQueue = class extends import_eventemitter3.default {
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pendingCount.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(fn, options = {}) {
    return new Promise((resolve7, reject) => {
      const run = async () => {
        var _a;
        var _b, _c;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
            reject(new AbortError("The task was aborted."));
            return;
          }
          const operation = this.timeout === void 0 && options.timeout === void 0 ? fn({ signal: options.signal }) : pTimeout(Promise.resolve(fn({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
            if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          const result = await operation;
          resolve7(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        }
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
      };
      __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(run, options);
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      this.emit("add");
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  start() {
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
  }
  async onIdle() {
    if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
  }
  sizeBy(options) {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
  }
  get pending() {
    return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a;
  __classPrivateFieldSet(this, _PQueue_pendingCount, (_a = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _a--, _a), "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_emitEvents = function _PQueue_emitEvents2() {
  this.emit("empty");
  if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0) {
    this.emit("idle");
  }
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
    return false;
  }
  if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter15) {
  return new Promise((resolve7) => {
    const listener = () => {
      if (filter15 && !filter15()) {
        return;
      }
      this.off(event, listener);
      resolve7();
    };
    this.on(event, listener);
  });
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/dns.browser.js
var import_http = __toESM(require_http(), 1);
var cache = new TLRU(1e3);
var ttl = 60 * 1e3;
var Queue = PQueue.default ? PQueue.default : PQueue;
var httpQueue = new Queue({ concurrency: 4 });
var ipfsPath2 = (response) => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve7 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache.has(query)) {
      const response2 = cache.get(query);
      return ipfsPath2(response2);
    }
    const response = await httpQueue.add(async () => {
      const res = await import_http.default.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache.set(query2, json, ttl);
      return json;
    });
    return ipfsPath2(response);
  };
  return resolve7(fqdn, opts);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dns.js
function fqdnFixups(domain) {
  if (domain.endsWith(".eth")) {
    domain = domain.replace(/.eth$/, ".eth.link");
  }
  return domain;
}
function createDns() {
  const resolveDNS = async (domain, options = { recursive: true }) => {
    if (typeof domain !== "string") {
      throw new Error("Invalid arguments, domain must be a string");
    }
    domain = fqdnFixups(domain);
    return resolveDnslink(domain, options);
  };
  return withTimeoutOption(resolveDNS);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/is-online.js
init_define_process();
function createIsOnline({ network }) {
  return () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/resolve.js
init_define_process();
function createResolve({ repo, codecs: codecs2, bases: bases2, name: name6 }) {
  async function resolve7(path4, opts = {}) {
    if (!path(path4)) {
      throw new Error("invalid argument " + path4);
    }
    if (ipnsPath(path4)) {
      for await (const resolvedPath of name6.resolve(path4, opts)) {
        path4 = resolvedPath;
      }
    }
    const [, schema, hash3, ...rest] = path4.split("/");
    const base = opts.cidBase ? await bases2.getBase(opts.cidBase) : void 0;
    const bytes2 = parseBytes(hash3);
    if (rest.length === 0) {
      const str = base ? base.encoder.encode(bytes2) : hash3;
      return `/${schema}/${str}`;
    }
    const cid = CID.decode(bytes2);
    path4 = rest.join("/");
    const results = resolve(cid, path4, codecs2, repo, opts);
    let value = cid;
    let remainderPath = path4;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
  }
  return withTimeoutOption(resolve7);
}
function parseBytes(str) {
  try {
    return peerIdFromString(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/add.js
init_define_process();
var import_it_last = __toESM(require_it_last(), 1);
function createAdd({ addAll }) {
  return (path4, options = {}) => {
    let iter;
    const cid = CID.asCID(path4);
    if (cid) {
      iter = addAll([{
        cid,
        ...options
      }], options);
    } else {
      iter = addAll([{
        path: path4.toString(),
        ...options
      }], options);
    }
    return (0, import_it_last.default)(iter);
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/add-all.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/pins/normalise-input.js
init_define_process();
var import_err_code4 = __toESM(require_err_code(), 1);
async function* normaliseInput(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code4.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (Symbol.iterator in input) {
    const iterator = input[Symbol.iterator]();
    const first10 = iterator.next();
    if (first10.done)
      return iterator;
    if (CID.asCID(first10.value) || first10.value instanceof String || typeof first10.value === "string") {
      yield toPin({ cid: first10.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first10.value.cid != null || first10.value.path != null) {
      yield toPin(first10.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input) {
    const iterator = input[Symbol.asyncIterator]();
    const first10 = await iterator.next();
    if (first10.done)
      return iterator;
    if (CID.asCID(first10.value) || first10.value instanceof String || typeof first10.value === "string") {
      yield toPin({ cid: first10.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first10.value.cid != null || first10.value.path != null) {
      yield toPin(first10.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path4 = input.cid || `${input.path}`;
  if (!path4) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path: path4,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/pin-types.js
init_define_process();
var PinTypes = {
  direct: "direct",
  recursive: "recursive",
  indirect: "indirect",
  all: "all"
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/add-all.js
function createAddAll({ repo, codecs: codecs2 }) {
  async function* addAll(source, options = {}) {
    const pinAdd = async function* () {
      for await (const { path: path4, recursive: recursive2, metadata } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path4);
        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);
        if (reason === "recursive" && !recursive2) {
          throw new Error(`${cid} already pinned recursively`);
        }
        if (recursive2) {
          await repo.pins.pinRecursively(cid, { metadata });
        } else {
          await repo.pins.pinDirectly(cid, { metadata });
        }
        yield cid;
      }
    };
    const lock3 = Boolean(options.lock);
    if (!lock3) {
      yield* pinAdd();
      return;
    }
    const release = await repo.gcLock.readLock();
    try {
      yield* pinAdd();
    } finally {
      release();
    }
  }
  return withTimeoutOption(addAll);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/ls.js
init_define_process();
var import_err_code5 = __toESM(require_err_code(), 1);
function toPin2(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs({ repo, codecs: codecs2 }) {
  async function* ls(options = {}) {
    let type = PinTypes.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(PinTypes).includes(type)) {
        throw (0, import_err_code5.default)(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const { path: path4 } of normaliseInput(options.paths)) {
        const { cid } = await resolvePath(repo, codecs2, path4);
        const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw (0, import_err_code5.default)(new Error(`path '${path4}' is not pinned`), "ERR_NOT_PINNED");
        }
        switch (reason) {
          case PinTypes.direct:
          case PinTypes.recursive:
            matched = true;
            yield toPin2(reason, cid, metadata);
            break;
          default:
            matched = true;
            yield toPin2(`${PinTypes.indirect} through ${parent2}`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error("No match found");
      }
      return;
    }
    if (type === PinTypes.recursive || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
        yield toPin2(PinTypes.recursive, cid, metadata);
      }
    }
    if (type === PinTypes.indirect || type === PinTypes.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin2(PinTypes.indirect, cid);
      }
    }
    if (type === PinTypes.direct || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.directKeys()) {
        yield toPin2(PinTypes.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption(ls);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/rm.js
init_define_process();
var import_it_last2 = __toESM(require_it_last(), 1);
function createRm({ rmAll }) {
  async function rm(path4, options = {}) {
    const cid = await (0, import_it_last2.default)(rmAll([{ path: path4, ...options }], options));
    if (!cid) {
      throw new Error("CID expected");
    }
    return cid;
  }
  return rm;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/rm-all.js
init_define_process();
function createRmAll({ repo, codecs: codecs2 }) {
  async function* rmAll(source, _options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      for await (const { path: path4, recursive: recursive2 } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path4);
        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes.all);
        if (!pinned) {
          throw new Error(`${cid} is not pinned`);
        }
        switch (reason) {
          case PinTypes.recursive:
            if (!recursive2) {
              throw new Error(`${cid} is pinned recursively`);
            }
            await repo.pins.unpin(cid);
            yield cid;
            break;
          case PinTypes.direct:
            await repo.pins.unpin(cid);
            yield cid;
            break;
          default:
            throw new Error(`${cid} is pinned indirectly under ${reason}`);
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(rmAll);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pin/index.js
var PinAPI = class {
  constructor({ codecs: codecs2, repo }) {
    const addAll = createAddAll({ codecs: codecs2, repo });
    this.addAll = addAll;
    this.add = createAdd({ addAll });
    const rmAll = createRmAll({ codecs: codecs2, repo });
    this.rmAll = rmAll;
    this.rm = createRm({ rmAll });
    this.ls = createLs({ codecs: codecs2, repo });
    this.remote = {
      add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
      ls: async function* (query, options = {}) {
        return Promise.reject(new Error("Not implemented"));
      },
      rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      service: {
        add: (name6, credentials) => Promise.reject(new Error("Not implemented")),
        rm: (name6, options = {}) => Promise.reject(new Error("Not implemented")),
        ls: (options = {}) => Promise.reject(new Error("Not implemented"))
      }
    };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/ipns.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/index.js
init_define_process();
var import_err_code13 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/publisher.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
init_define_process();
var import_err_code6 = __toESM(require_err_code(), 1);
function dbOpenFailedError(err2) {
  err2 = err2 || new Error("Cannot open database");
  return (0, import_err_code6.default)(err2, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err2) {
  err2 = err2 || new Error("Delete failed");
  return (0, import_err_code6.default)(err2, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err2) {
  err2 = err2 || new Error("Write failed");
  return (0, import_err_code6.default)(err2, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code6.default)(err2, "ERR_NOT_FOUND");
}
function abortedError(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code6.default)(err2, "ERR_ABORTED");
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/publisher.js
var import_err_code9 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/index.js
init_define_process();
var import_timestamp_nano = __toESM(require_timestamp(), 1);
var import_err_code8 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/utils.js
init_define_process();
var import_err_code7 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/errors.js
init_define_process();
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
var ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY";

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/pb/ipns.js
init_define_process();
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.value != null) {
          writer.uint32(10);
          writer.bytes(obj.value);
        }
        if (obj.signature != null) {
          writer.uint32(18);
          writer.bytes(obj.signature);
        }
        if (obj.validityType != null) {
          writer.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, writer);
        }
        if (obj.validity != null) {
          writer.uint32(34);
          writer.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          writer.uint32(40);
          writer.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          writer.uint32(48);
          writer.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          writer.uint32(58);
          writer.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          writer.uint32(66);
          writer.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          writer.uint32(74);
          writer.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader2.bytes();
              break;
            case 2:
              obj.signature = reader2.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader2);
              break;
            case 4:
              obj.validity = reader2.bytes();
              break;
            case 5:
              obj.sequence = reader2.uint64();
              break;
            case 6:
              obj.ttl = reader2.uint64();
              break;
            case 7:
              obj.pubKey = reader2.bytes();
              break;
            case 8:
              obj.signatureV2 = reader2.bytes();
              break;
            case 9:
              obj.data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf2) => {
    return decodeMessage(buf2, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/utils.js
init_concat();
var log = logger("ipns:utils");
var IPNS_PREFIX = fromString("/ipns/");
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute4 = parseInt(m[5], 10);
  const second2 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute4, second2, millisecond));
}
var extractPublicKey = async (peerId, entry) => {
  if (entry == null || peerId == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log.error(error);
    throw (0, import_err_code7.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey(entry.pubKey);
    } catch (err2) {
      log.error(err2);
      throw err2;
    }
    const otherId = await peerIdFromKeys(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw (0, import_err_code7.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.publicKey != null) {
    pubKey = unmarshalPublicKey(peerId.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw (0, import_err_code7.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
var ipnsEntryDataForV1Sig = (value, validityType, validity) => {
  const validityTypeBuffer = fromString(validityType);
  return concat([value, validity, validityTypeBuffer]);
};
var ipnsEntryDataForV2Sig = (data) => {
  const entryData = fromString("ipns-signature:");
  return concat([entryData, data]);
};
var marshal = (obj) => {
  return IpnsEntry.encode(obj);
};
var unmarshal = (buf2) => {
  const message2 = IpnsEntry.decode(buf2);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  return {
    value: message2.value ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    validityType: message2.validityType ?? IpnsEntry.ValidityType.EOL,
    validity: message2.validity ?? new Uint8Array(0),
    sequence: message2.sequence ?? 0n,
    pubKey: message2.pubKey,
    ttl: message2.ttl ?? void 0,
    signatureV2: message2.signatureV2,
    data: message2.data
  };
};
var peerIdToRoutingKey = (peerId) => {
  return concat([
    IPNS_PREFIX,
    peerId.toBytes()
  ]);
};
var peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX.length));
};
var createCborData = (value, validity, validityType, sequence, ttl2) => {
  let ValidityType;
  if (validityType === IpnsEntry.ValidityType.EOL) {
    ValidityType = 0;
  } else {
    throw (0, import_err_code7.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  const data = {
    Value: value,
    Validity: validity,
    ValidityType,
    Sequence: sequence,
    TTL: ttl2
  };
  return encode3(data);
};
var parseCborData = (buf2) => {
  const data = decode4(buf2);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw (0, import_err_code7.default)(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/index.js
var log2 = logger("ipns");
var ID_MULTIHASH_CODE = identity.code;
var namespace = "/ipns/";
var namespaceLength = namespace.length;
var create = async (peerId, value, seq, lifetime) => {
  const expirationDate = new import_timestamp_nano.default(Date.now() + Number(lifetime));
  const validityType = IpnsEntry.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split(".");
  const lifetimeNs = BigInt(ms) * BigInt(1e5) + BigInt(ns ?? "0");
  return await _create(peerId, value, seq, validityType, expirationDate, lifetimeNs);
};
var _create = async (peerId, value, seq, validityType, expirationDate, ttl2) => {
  seq = BigInt(seq);
  const isoValidity = fromString(expirationDate.toString());
  if (peerId.privateKey == null) {
    throw (0, import_err_code8.default)(new Error("Missing private key"), ERR_MISSING_PRIVATE_KEY);
  }
  const privateKey = await unmarshalPrivateKey(peerId.privateKey);
  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);
  const data = createCborData(value, isoValidity, validityType, seq, ttl2);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value,
    signature: signatureV1,
    validityType,
    validity: isoValidity,
    sequence: seq,
    ttl: ttl2,
    signatureV2,
    data
  };
  if (peerId.publicKey != null) {
    const digest = decode(peerId.toBytes());
    if (digest.code !== ID_MULTIHASH_CODE || !equals(peerId.publicKey, digest.digest)) {
      entry.pubKey = peerId.publicKey;
    }
  }
  log2("ipns entry for %b created", value);
  return entry;
};
var rawStdEncoding = (key) => base32upper.encode(key).slice(1);
var getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
var sign = async (privateKey, value, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
    return await privateKey.sign(dataForSignature);
  } catch (error) {
    log2.error("record signature creation failed", error);
    throw (0, import_err_code8.default)(new Error("record signature creation failed"), ERR_SIGNATURE_CREATION);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/publisher.js
var log3 = logger("ipfs:ipns:publisher");
var ERR_NOT_FOUND = notFoundError().code;
var defaultRecordLifetime = 60 * 60 * 1e3;
var IpnsPublisher = class {
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  async publishWithEOL(peerId, value, lifetime, options) {
    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options);
    return this._putRecordToRouting(record, peerId, options);
  }
  publish(peerId, value, options) {
    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options);
  }
  async _putRecordToRouting(record, peerId, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    if (peerId.publicKey == null) {
      throw (0, import_err_code9.default)(new Error("Public key was missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const routingKey = peerIdToRoutingKey(peerId);
    await this._publishEntry(routingKey, record, options);
    return record;
  }
  async _publishEntry(key, entry, options) {
    try {
      const res = await this._routing.put(key, entry, options);
      log3(`ipns record for ${toString(key, "base32")} was stored in the routing`);
      return res;
    } catch (err2) {
      const errMsg = `ipns record for ${toString(key, "base32")} could not be stored in the routing - ${err2.stack}`;
      log3.error(errMsg);
      log3.error(err2);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
    }
  }
  async _getPublished(peerId, options = {}) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      return this._unmarshalData(dsVal);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;
        log3.error(errMsg);
        throw (0, import_err_code9.default)(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
      }
      if (!checkRouting) {
        throw (0, import_err_code9.default)(err2, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
      }
      try {
        const routingKey = peerIdToRoutingKey(peerId);
        const res = await this._routing.get(routingKey);
        return this._unmarshalData(res);
      } catch (err3) {
        log3.error(err3);
        throw err3;
      }
    }
  }
  _unmarshalData(data) {
    try {
      return unmarshal(data);
    } catch (err2) {
      throw (0, import_err_code9.default)(err2, "ERR_INVALID_RECORD_DATA");
    }
  }
  async _updateOrCreateRecord(peerId, value, lifetime, options) {
    if (!isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log3.error(errMsg);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const getPublishedOptions = {
      checkRouting: true
    };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err2) {
      if (err2.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err2.stack}`;
        log3.error(errMsg);
        throw (0, import_err_code9.default)(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
      }
    }
    let seqNumber = 0n;
    if (record && record.sequence !== void 0) {
      seqNumber = equals(record.value, value) ? record.sequence : record.sequence + BigInt(1);
    }
    let entryData;
    try {
      entryData = await create(peerId, value, seqNumber, lifetime);
    } catch (err2) {
      const errMsg = `ipns record for ${value} could not be created`;
      log3.error(err2);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
    }
    try {
      const data = marshal(entryData);
      await this._datastore.put(getLocalKey(peerId.toBytes()), data, options);
      log3(`ipns record for ${toString(value, "base32")} was stored in the datastore`);
      return data;
    } catch (err2) {
      const errMsg = `ipns record for ${value} could not be stored in the datastore`;
      log3.error(errMsg);
      throw (0, import_err_code9.default)(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
    }
  }
};
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/republisher.js
init_define_process();
var import_err_code10 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller2 = __toESM(require_timeout_abort_controller(), 1);
var log4 = logger("ipfs:ipns:republisher");
var minute = 60 * 1e3;
var hour = 60 * minute;
var defaultBroadcastInterval = 4 * hour;
var defaultRecordLifetime2 = 24 * hour;
var IpnsRepublisher = class {
  constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw (0, import_err_code10.default)(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: (period) => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err2) {
            log4.error(err2);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const { pass } = this._options;
    let firstRun = true;
    republishHandle._task = async () => {
      const timeoutController = new import_timeout_abort_controller2.TimeoutController(3e4);
      try {
        await this._republishEntries(this._peerId, pass, {
          signal: timeoutController.signal
        });
      } finally {
        timeoutController.clear();
      }
    };
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw (0, import_err_code10.default)(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(peerId, pass, options) {
    try {
      await this._republishEntry(peerId, options);
    } catch (err2) {
      const errMsg = "cannot republish entry for the node's private key";
      log4.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === "self") {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await importKey(pem, pass);
          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);
          await this._republishEntry(peerIdKey, options);
        }
      } catch (err2) {
        log4.error(err2);
      }
    }
  }
  async _republishEntry(peerId, options) {
    try {
      const value = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime2, options);
    } catch (err2) {
      if (err2.code === "ERR_NO_ENTRY_FOUND") {
        return;
      }
      throw err2;
    }
  }
  async _getPreviousValue(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code10.default)(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
    }
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.toBytes()));
      if (!(dsVal instanceof Uint8Array)) {
        throw (0, import_err_code10.default)(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
      }
      try {
        const record = unmarshal(dsVal);
        return record.value;
      } catch (err2) {
        log4.error(err2);
        throw (0, import_err_code10.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
      }
    } catch (err2) {
      if (err2 && err2.notFound) {
        throw (0, import_err_code10.default)(new Error(`no previous entry for record with id: ${peerId.toString()}`), "ERR_NO_ENTRY_FOUND");
      }
      throw err2;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/resolver.js
init_define_process();
var import_err_code12 = __toESM(require_err_code(), 1);
init_concat();

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/validator.js
init_define_process();
var import_err_code11 = __toESM(require_err_code(), 1);
var log5 = logger("ipns:validator");
var validate2 = async (publicKey, entry) => {
  const { value, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 != null && entry.data != null) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    signature = entry.signature ?? new Uint8Array(0);
    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err2) {
    isValid = false;
  }
  if (!isValid) {
    log5.error("record signature verification failed");
    throw (0, import_err_code11.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339(toString(validity));
    } catch (e) {
      log5.error("unrecognized validity format (not an rfc3339 format)");
      throw (0, import_err_code11.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log5.error("record has expired");
      throw (0, import_err_code11.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType != null) {
    log5.error("unrecognized validity type");
    throw (0, import_err_code11.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log5("ipns entry for %b is valid", value);
};
var validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw (0, import_err_code11.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals(data.Value, entry.value)) {
    throw (0, import_err_code11.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals(data.Validity, entry.validity)) {
    throw (0, import_err_code11.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code11.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code11.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code11.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
var ipnsValidator = async (key, marshalledData) => {
  const peerId = peerIdFromRoutingKey(key);
  const receivedEntry = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId, receivedEntry);
  await validate2(pubKey, receivedEntry);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/resolver.js
var log6 = logger("ipfs:ipns:resolver");
var ERR_NOT_FOUND2 = notFoundError().code;
var defaultMaximumRecursiveDepth = 32;
var IpnsResolver = class {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name6, options = {}) {
    if (typeof name6 !== "string") {
      throw (0, import_err_code12.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const recursive2 = options.recursive && options.recursive.toString() === "true";
    const nameSegments = name6.split("/");
    if (nameSegments.length !== 3 || nameSegments[0] !== "") {
      throw (0, import_err_code12.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive2) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth, options);
    log6(`${name6} was locally resolved correctly`);
    return res;
  }
  async resolver(name6, depth, options) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
      log6.error(errMsg);
      throw (0, import_err_code12.default)(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
    }
    const res = await this._resolveName(name6, options);
    const nameSegments = res.split("/");
    if (nameSegments[1] === "ipfs" || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1, options);
  }
  async _resolveName(name6, options) {
    const peerId = peerIdFromString(name6);
    const routingKey = peerIdToRoutingKey(peerId);
    let record;
    try {
      record = await this._routing.get(routingKey, options);
    } catch (err2) {
      log6.error("could not get record from routing", err2);
      if (err2.code === ERR_NOT_FOUND2) {
        throw (0, import_err_code12.default)(new Error(`record requested for ${name6} was not found in the network`), "ERR_NO_RECORD_FOUND");
      }
      throw (0, import_err_code12.default)(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
    }
    return this._validateRecord(peerId, record);
  }
  async _validateRecord(peerId, record) {
    await ipnsValidator(concat([
      fromString("/ipns/"),
      peerId.toBytes()
    ]), record);
    const ipnsEntry = unmarshal(record);
    return toString(ipnsEntry.value);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/utils/tlru.js
init_define_process();
var import_hashlru2 = __toESM(require_hashlru(), 1);
var TLRU2 = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru2.default)(maxSize);
  }
  get(key) {
    const value = this.lru.get(key);
    if (value) {
      if (value.expire && value.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value.value;
    }
    return void 0;
  }
  set(key, value, ttl2) {
    this.lru.set(key, { value, expire: Date.now() + ttl2 });
  }
  has(key) {
    const value = this.get(key);
    if (value) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/index.js
var log7 = logger("ipfs:ipns");
var defaultRecordTtl = 60 * 1e3;
var IPNS = class {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU2(1e3);
    this.routing = routing;
  }
  async publish(peerId, value, lifetime = IpnsPublisher.defaultRecordLifetime, options) {
    try {
      await this.publisher.publishWithEOL(peerId, value, lifetime, options);
      log7(`IPNS value ${toString(value, "base32")} was published correctly`);
      const id = peerId.toString();
      const ttEol = parseFloat(lifetime);
      const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value, ttl2);
      log7(`IPNS value ${toString(value, "base32")} was cached correctly`);
      return {
        name: id,
        value
      };
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  async resolve(name6, options = {}) {
    if (typeof name6 !== "string") {
      throw (0, import_err_code13.default)(new Error("name received is not valid"), "ERR_INVALID_NAME");
    }
    if (!options.nocache && !options.recursive) {
      const id = name6.split("/")[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name6, options);
      log7(`IPNS record from ${name6} was resolved correctly`);
      return result;
    } catch (err2) {
      log7.error(err2);
      throw err2;
    }
  }
  async initializeKeyspace(peerId, value, options) {
    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/config.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/tiered.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/base.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/utils.js
init_define_process();
var import_it_all = __toESM(require_it_all(), 1);
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await (0, import_it_all.default)(iterable);
    yield* values.sort(sorter);
  }();
};

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/base.js
var import_it_drain = __toESM(require_it_drain(), 1);
var import_it_filter = __toESM(require_it_filter(), 1);
var import_it_take = __toESM(require_it_take(), 1);
var BaseDatastore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(
        it,
        (e) => e.key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(
        it,
        (key) => key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/tiered.js
var import_it_drain2 = __toESM(require_it_drain(), 1);
var log8 = logger("datastore:core:tiered");
var TieredDatastore = class extends BaseDatastore {
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map((store) => store.open()));
    } catch (err2) {
      throw dbOpenFailedError();
    }
  }
  async put(key, value, options) {
    try {
      await Promise.all(this.stores.map((store) => store.put(key, value, options)));
    } catch (err2) {
      throw dbWriteFailedError();
    }
  }
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err2) {
        log8.error(err2);
      }
    }
    throw notFoundError();
  }
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map((store) => store.delete(key, options)));
    } catch (err2) {
      throw dbDeleteFailedError();
    }
  }
  async *putMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      (0, import_it_drain2.default)(store.putMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const pair2 of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(pair2));
        yield pair2;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async *deleteMany(source, options = {}) {
    let error;
    const pushables = this.stores.map((store) => {
      const source2 = pushable({
        objectMode: true
      });
      (0, import_it_drain2.default)(store.deleteMany(source2, options)).catch((err2) => {
        error = err2;
      });
      return source2;
    });
    try {
      for await (const key of source) {
        if (error) {
          throw error;
        }
        pushables.forEach((p) => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach((p) => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map((store) => store.close()));
  }
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value) => {
        batches.forEach((b) => b.put(key, value));
      },
      delete: (key) => {
        batches.forEach((b) => b.delete(key));
      },
      commit: async (options) => {
        for (const batch3 of batches) {
          await batch3.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/config.js
var import_dlv = __toESM(require_dlv_umd(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipns-npm-2.0.3-98d5269c32-9.zip/node_modules/ipns/dist/src/selector.js
init_define_process();
var ipnsSelector = (key, data) => {
  const entries = data.map((buf2, index) => ({
    entry: IpnsEntry.decode(buf2),
    index
  }));
  entries.sort((a, b) => {
    if (a.entry.signatureV2 != null && b.entry.signatureV2 == null) {
      return -1;
    } else if (a.entry.signatureV2 == null && b.entry.signatureV2 != null) {
      return 1;
    }
    const aSeq = a.entry.sequence ?? 0n;
    const bSeq = b.entry.sequence ?? 0n;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    const aValidty = a.entry.validity ?? new Uint8Array(0);
    const bValidty = b.entry.validity ?? new Uint8Array(0);
    const entryAValidityDate = parseRFC3339(toString(aValidty));
    const entryBValidityDate = parseRFC3339(toString(bValidty));
    if (entryAValidityDate.getTime() > entryBValidityDate.getTime()) {
      return -1;
    }
    if (entryAValidityDate.getTime() < entryBValidityDate.getTime()) {
      return 1;
    }
    return 0;
  });
  return entries[0].index;
};

// ../../../../../Users/z/.yarn/berry/cache/datastore-pubsub-npm-4.0.2-7a7d0794c3-9.zip/node_modules/datastore-pubsub/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/interface-datastore-npm-7.0.0-34b5866494-9.zip/node_modules/interface-datastore/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/shard.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/shard-readme.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/shard.js
var SHARDING_FN = "SHARDING";
var README_FN = "_README";

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/memory.js
init_define_process();
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  async get(key) {
    const exists2 = await this.has(key);
    if (!exists2)
      throw notFoundError();
    return this.data[key.toString()];
  }
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: new Key(key), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/keytransform.js
init_define_process();
var import_it_map = __toESM(require_it_map(), 1);

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/sharding.js
init_define_process();
var shardKey = new Key(SHARDING_FN);
var shardReadmeKey = new Key(README_FN);

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/mount.js
init_define_process();
var import_it_filter2 = __toESM(require_it_filter(), 1);
var import_it_take2 = __toESM(require_it_take(), 1);
var import_it_merge = __toESM(require_it_merge(), 1);

// ../../../../../Users/z/.yarn/berry/cache/datastore-core-npm-8.0.1-4b85e422ed-9.zip/node_modules/datastore-core/src/namespace.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/datastore-pubsub-npm-4.0.2-7a7d0794c3-9.zip/node_modules/datastore-pubsub/src/utils.js
init_define_process();
var import_err_code14 = __toESM(require_err_code(), 1);
var namespace2 = "/record/";
function encodeBase32(buf2) {
  return toString(buf2, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString(key.toString());
  }
  const b64url = toString(key, "base64url");
  return `${namespace2}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace2.length) !== namespace2) {
    throw (0, import_err_code14.default)(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace2.length);
  return fromString(key, "base64url");
}

// ../../../../../Users/z/.yarn/berry/cache/datastore-pubsub-npm-4.0.2-7a7d0794c3-9.zip/node_modules/datastore-pubsub/src/index.js
var import_err_code15 = __toESM(require_err_code(), 1);
var log9 = logger("datastore-pubsub:publisher");
var PubSubDatastore = class extends BaseDatastore {
  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {
    super();
    if (!validator) {
      throw (0, import_err_code15.default)(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator !== "function") {
      throw (0, import_err_code15.default)(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof selector !== "function") {
      throw (0, import_err_code15.default)(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
      throw (0, import_err_code15.default)(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator;
    this._selector = selector;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
    this._pubsub.addEventListener("message", this._onMessage);
  }
  async put(key, val, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = "received value is not a Uint8Array";
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
    }
    const stringifiedTopic = keyToTopic(key);
    log9(`publish value for topic ${stringifiedTopic}`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key, options);
    }
    try {
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err2) {
      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
    }
    log9(`subscribed values for key ${stringifiedTopic}`);
    return this._getLocal(key);
  }
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  async _getLocal(key, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey, options);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
        log9.error(errMsg2);
        throw (0, import_err_code15.default)(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      const errMsg = `local record requested was not found for ${routingKey.toString()}`;
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_NOT_FOUND");
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = "found record that we couldn't convert to a value";
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
    }
    return dsVal;
  }
  async _onMessage(evt) {
    const msg = evt.detail;
    if (msg.type !== "signed") {
      log9.error("unsigned message received, this module can only work with signed messages");
      return;
    }
    const { data, from: from2, topic } = msg;
    let key;
    try {
      key = topicToKey(topic);
    } catch (err2) {
      log9.error(err2);
      return;
    }
    log9(`message received for topic ${topic}`);
    if (this._peerId.equals(from2)) {
      log9("message discarded as it is from the same peer");
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err2) {
        log9.error("message discarded by the subscriptionKeyFn");
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err2) {
      log9.error(err2);
    }
  }
  async _storeIfSubscriptionIsBetter(key, data, options) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err2) {
      if (err2.code !== "ERR_NOT_VALID_RECORD") {
        throw err2;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data, options);
    }
  }
  async _validateRecord(key, value) {
    return this._validator(key, value);
  }
  async _selectRecord(key, records) {
    const res = await this._selector(key, records);
    return res === 0;
  }
  async _isBetter(key, val) {
    try {
      await this._validateRecord(key, val);
    } catch (err2) {
      const errMsg = "record received through pubsub is not valid";
      log9.error(errMsg);
      throw (0, import_err_code15.default)(new Error(errMsg), "ERR_NOT_VALID_RECORD");
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err2) {
      return true;
    }
    if (equals(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [currentRecord, val]);
  }
  async _storeRecord(key, data, options) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    await this._datastore.put(routingKey, data, options);
    log9(`record for ${keyToTopic(key)} was stored in the datastore`);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js
var import_err_code16 = __toESM(require_err_code(), 1);
var log10 = logger("ipfs:ipns:pubsub");
var IpnsPubsubDatastore = class {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);
  }
  async put(key, value, options) {
    try {
      await this._pubsubDs.put(key, value, options);
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    let res;
    let err2;
    try {
      res = await this._pubsubDs.get(key, options);
    } catch (e) {
      err2 = e;
    }
    const ns = key.slice(0, namespaceLength);
    if (toString(ns) === namespace) {
      const stringifiedTopic = base58btc.encode(key).substring(1);
      const id = base58btc.encode(key.slice(namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log10(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
    }
    if (err2) {
      throw err2;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString(key, "base58btc");
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw (0, import_err_code16.default)(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
    }
    try {
      const k = peerIdToRoutingKey(peerIdFromString(subscriber));
      return k;
    } catch (err2) {
      log10.error(err2);
      throw err2;
    }
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map((sub) => `${namespace}${sub}`);
  }
  async cancel(name6) {
    if (typeof name6 !== "string") {
      throw (0, import_err_code16.default)(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
    }
    if (name6.startsWith(namespace)) {
      name6 = name6.substring(namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name6);
    if (!stringifiedTopic) {
      return {
        canceled: false
      };
    }
    const bufTopic = fromString(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log10(`unsubscribed pubsub ${stringifiedTopic}: ${name6}`);
    return {
      canceled: true
    };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/record.js
init_define_process();
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.key != null) {
          writer.uint32(10);
          writer.bytes(obj.key);
        } else {
          throw new Error('Protocol error: required field "key" was not found in object');
        }
        if (obj.value != null) {
          writer.uint32(18);
          writer.bytes(obj.value);
        } else {
          throw new Error('Protocol error: required field "value" was not found in object');
        }
        if (obj.timeReceived != null) {
          writer.uint32(42);
          writer.string(obj.timeReceived);
        } else {
          throw new Error('Protocol error: required field "timeReceived" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          key: new Uint8Array(0),
          value: new Uint8Array(0),
          timeReceived: ""
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.key == null) {
          throw new Error('Protocol error: value for required field "key" was not found in protobuf');
        }
        if (obj.value == null) {
          throw new Error('Protocol error: value for required field "value" was not found in protobuf');
        }
        if (obj.timeReceived == null) {
          throw new Error('Protocol error: value for required field "timeReceived" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record || (Record = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/utils.js
init_define_process();
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour3 = String(time.getUTCHours()).padStart(2, "0");
  const minute4 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour3}:${minute4}:${seconds}.${nanoseconds}Z`;
}
function parseRFC33392(time) {
  const rfc3339Matcher = new RegExp(
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour3 = parseInt(m[4], 10);
  const minute4 = parseInt(m[5], 10);
  const second2 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour3, minute4, second2, millisecond));
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class {
  constructor(key, value, timeReceived) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  static fromDeserialized(obj) {
    const recvtime = parseRFC33392(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js
var import_err_code17 = __toESM(require_err_code(), 1);
var log11 = logger("ipfs:ipns:offline-datastore");
var OfflineDatastore = class {
  constructor(datastore) {
    this._datastore = datastore;
    this.stores = [];
  }
  async put(key, value, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code17.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    if (!(value instanceof Uint8Array)) {
      throw (0, import_err_code17.default)(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code17.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const record = new Libp2pRecord(key, value, new Date());
    await this._datastore.put(routingKey, record.serialize(), options);
  }
  async get(key, options) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code17.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err2) {
      log11.error(err2);
      throw (0, import_err_code17.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const res = await this._datastore.get(routingKey, options);
    let record;
    try {
      record = Libp2pRecord.deserialize(res);
    } catch (err2) {
      log11.error(err2);
      throw err2;
    }
    return record.value;
  }
  _routingKey(key) {
    return new Key("/dht/record/" + toString(key, "base32"), false);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/dht-datastore.js
init_define_process();
var import_it_drain3 = __toESM(require_it_drain(), 1);
var log12 = logger("ipfs:ipns:dht-datastore");
var DHTDatastore = class {
  constructor(dht) {
    this._dht = dht;
  }
  async put(key, value, options) {
    try {
      await (0, import_it_drain3.default)(this._dht.put(key, value, options));
    } catch (err2) {
      log12.error(err2);
      throw err2;
    }
  }
  async get(key, options) {
    for await (const event of this._dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw notFoundError();
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/ipns/routing/config.js
function createRouting({ libp2p, repo, peerId, options }) {
  const ipnsStores = [];
  let pubsubDs;
  if ((0, import_dlv.default)(options, "EXPERIMENTAL.ipnsPubsub", false)) {
    pubsubDs = new IpnsPubsubDatastore(libp2p.pubsub, repo.datastore, peerId);
    ipnsStores.push(pubsubDs);
  }
  if ((0, import_dlv.default)(options, "offline", false) !== true && ["dht", "dhtclient", "dhtserver"].includes((0, import_dlv.default)(options, "config.Routing.Type", "none"))) {
    ipnsStores.push(new DHTDatastore(libp2p.dht));
  }
  if ((0, import_dlv.default)(options, "offline", false) || ipnsStores.length === 0) {
    const offlineDatastore = new OfflineDatastore(repo.datastore);
    ipnsStores.push(offlineDatastore);
  }
  return new TieredDatastore(ipnsStores);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/ipns.js
var log13 = logger("ipfs:components:ipns");
var IPNSAPI = class {
  constructor(options = { pass: "" }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  startOffline({ repo, peerId, keychain }) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log13("initializing IPNS keyspace (offline)");
    const routing = new OfflineDatastore(repo.datastore);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  async startOnline({ libp2p, repo, peerId, keychain }) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({ libp2p, repo, peerId, options: this.options });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  publish(peerId, value, lifetime, options) {
    return this.getIPNS().publish(peerId, value, lifetime, options);
  }
  resolve(name6, options) {
    return this.getIPNS().resolve(name6, options);
  }
  initializeKeyspace(peerId, value, options) {
    return this.getIPNS().initializeKeyspace(peerId, value, options);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/publish.js
init_define_process();
var import_err_code18 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/utils.js
init_define_process();
var import_it_drain4 = __toESM(require_it_drain(), 1);
async function resolvePath2({ ipns, repo, codecs: codecs2 }, name6, options) {
  if (ipnsPath(name6)) {
    return ipns.resolve(name6);
  }
  const {
    cid,
    path: path4
  } = toCidAndPath(name6);
  await (0, import_it_drain4.default)(resolve(cid, path4 || "", codecs2, repo, options));
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/publish.js
var log14 = logger("ipfs:name:publish");
function createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain }) {
  const lookupKey = async (keyName) => {
    let privateKey;
    if (keyName === "self" && peerId.privateKey != null) {
      privateKey = await unmarshalPrivateKey(peerId.privateKey);
    } else {
      try {
        const pem = await keychain.exportKey(keyName, "temp");
        privateKey = await importKey(pem, "temp");
      } catch (err2) {
        log14.error(err2);
        throw (0, import_err_code18.default)(err2, "ERR_CANNOT_GET_KEY");
      }
    }
    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);
  };
  async function publish(value, options = {}) {
    const resolve7 = !(options.resolve === false);
    const lifetime = options.lifetime || "24h";
    const key = options.key || "self";
    if (!isOnline()) {
      throw (0, import_err_code18.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    try {
      value = normalizePath(value);
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parse_duration_default(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err2) {
      log14.error(err2);
      throw err2;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve7 ? resolvePath2({ ipns, repo, codecs: codecs2 }, value) : Promise.resolve()
    ]);
    const bytes2 = fromString(value);
    const result = await ipns.publish(results[0], bytes2, pubLifetime, options);
    return {
      name: result.name,
      value: toString(result.value)
    };
  }
  return withTimeoutOption(publish);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/resolve.js
init_define_process();
var import_err_code19 = __toESM(require_err_code(), 1);
var import_is_domain_name = __toESM(require_is_domain_name(), 1);
var mergeOptions2 = merge_options_default.bind({ ignoreUndefined: true });
var log15 = logger("ipfs:name:resolve");
var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
function createResolve2({ dns, ipns, isOnline, options: { offline } }) {
  async function* resolve7(name6, options = {}) {
    options = mergeOptions2({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw (0, import_err_code19.default)(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
    }
    if (!isOnline() && !offline) {
      throw (0, import_err_code19.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    let ipnsName = name6.toString();
    if (!ipnsName.startsWith("/ipns/")) {
      ipnsName = `/ipns/${ipnsName}`;
    }
    let [namespace3, hash3, ...remainder] = ipnsName.slice(1).split("/");
    try {
      if (hash3.substring(0, 1) === "1") {
        const id = peerIdFromString(hash3);
        const digest = decode(id.toBytes());
        const libp2pKey = CID.createV1(114, digest);
        hash3 = libp2pKey.toString(base36);
      } else {
        const cid = CID.parse(hash3);
        if (cid.version === 1) {
          hash3 = cid.toString(base36);
        }
      }
    } catch (err2) {
      if ((0, import_is_domain_name.default)(hash3)) {
        yield appendRemainder(await dns(hash3, options), remainder);
        return;
      }
      log15.error(err2);
      throw (0, import_err_code19.default)(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
    }
    const value = await ipns.resolve(`/${namespace3}/${hash3}`, options);
    yield appendRemainder(value instanceof Uint8Array ? toString(value) : value, remainder);
  }
  return withTimeoutOption(resolve7);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/cancel.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/utils.js
init_define_process();
var import_err_code20 = __toESM(require_err_code(), 1);
function getPubsubRouting(ipns, options) {
  if (!ipns || !(options && options.ipnsPubsub)) {
    throw (0, import_err_code20.default)(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
  }
  if (ipns.routing instanceof IpnsPubsubDatastore) {
    return ipns.routing;
  }
  const pubsub = (ipns.routing.stores || []).find((s) => s instanceof IpnsPubsubDatastore);
  if (!pubsub) {
    throw (0, import_err_code20.default)(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
  }
  return pubsub;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/cancel.js
function createCancel({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function cancel(name6, options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.cancel(name6, options2);
  }
  return withTimeoutOption(cancel);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/state.js
init_define_process();
function createState({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function state(_options = {}) {
    try {
      return { enabled: Boolean(getPubsubRouting(ipns, experimental)) };
    } catch (err2) {
      return { enabled: false };
    }
  }
  return withTimeoutOption(state);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/subs.js
init_define_process();
function createSubs({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function subs(options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.getSubscriptions(options2);
  }
  return withTimeoutOption(subs);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/pubsub/index.js
var PubSubAPI = class {
  constructor({ ipns, options }) {
    this.cancel = createCancel({ ipns, options });
    this.state = createState({ ipns, options });
    this.subs = createSubs({ ipns, options });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/name/index.js
var NameAPI = class {
  constructor({ dns, ipns, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
    this.publish = createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain });
    this.resolve = createResolve2({ dns, ipns, isOnline, options });
    this.pubsub = new PubSubAPI({ ipns, options });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/refs/index.js
init_define_process();
var import_timeout_abort_controller3 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var ERR_NOT_FOUND3 = notFoundError().code;
var Format = {
  default: "<dst>",
  edges: "<src> -> <dst>"
};
function createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }) {
  async function* refs(ipfsPath3, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error("Cannot set edges to true and also specify format");
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== "number") {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new import_timeout_abort_controller3.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = (0, import_any_signal2.anySignal)(signals);
    }
    const rawPaths = Array.isArray(ipfsPath3) ? ipfsPath3 : [ipfsPath3];
    const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
    for (const path4 of paths) {
      try {
        yield* refsStream(resolve7, repo, codecs2, path4, options);
      } catch (err2) {
        yield {
          ref: "",
          err: err2.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload2, ipfsPath3, options) {
  const {
    cid,
    path: path4
  } = toCidAndPath(ipfsPath3);
  if (options.preload !== false) {
    preload2(cid);
  }
  return `/ipfs/${cid}${path4 || ""}`;
}
async function* refsStream(resolve7, repo, codecs2, path4, options) {
  const resPath = await resolve7(path4, options);
  const {
    cid
  } = toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs2, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield {
      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)
    };
  }
}
function formatLink(srcCid, dstCid, linkName = "", format = Format.default) {
  let out = format.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
  const seen = /* @__PURE__ */ new Set();
  async function* traverseLevel(parent2, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
        yield {
          parent: parent2,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND3) {
        err2.message = `Could not find object with CID: ${parent2.cid}`;
      }
      throw err2;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs2, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs2.getCodec(cid.code);
  const value = codec.decode(block);
  const isDagPb = cid.code === code3;
  const base = [];
  for (const [name6, cid2] of links(value, base)) {
    if (isDagPb) {
      const match = name6.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index = Number(match[1]);
        if (index < value.Links.length) {
          yield {
            name: value.Links[index].Name,
            cid: cid2
          };
          continue;
        }
      }
    }
    yield {
      name: name6,
      cid: cid2
    };
  }
}
var links = function* (source, base) {
  if (source == null) {
    return;
  }
  if (source instanceof Uint8Array) {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path4 = [...base, key];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [...path4, index];
          const cid = CID.asCID(element);
          if (cid) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [path4.join("/"), cid];
        } else {
          yield* links(value, path4);
        }
      }
    }
  }
  return [];
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/refs/local.js
init_define_process();
function createLocal({ repo }) {
  async function* refsLocal(options = {}) {
    for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
      yield { ref: cid.toString() };
    }
  }
  return withTimeoutOption(refsLocal);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/wantlist.js
init_define_process();
function createWantlist({ network }) {
  async function wantlist(options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.getWantlist();
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlist);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/wantlist-for-peer.js
init_define_process();
function createWantlistForPeer({ network }) {
  async function wantlistForPeer(peerId, options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.wantlistForPeer(peerId);
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlistForPeer);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/unwant.js
init_define_process();
function createUnwant({ network }) {
  async function unwant(cids, options = {}) {
    const { bitswap } = await network.use(options);
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    return bitswap.unwant(cids);
  }
  return withTimeoutOption(unwant);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/stat.js
init_define_process();
function createStat({ network }) {
  async function stat(options = {}) {
    const bitswap = (await network.use(options)).bitswap;
    const snapshot = bitswap.stat().snapshot;
    return {
      provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
      blocksReceived: BigInt(snapshot.blocksReceived.toString()),
      wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
      peers: bitswap.peers(),
      dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
      dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
      dataReceived: BigInt(snapshot.dataReceived.toString()),
      blocksSent: BigInt(snapshot.blocksSent.toString()),
      dataSent: BigInt(snapshot.dataSent.toString())
    };
  }
  return withTimeoutOption(stat);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bitswap/index.js
var BitswapAPI = class {
  constructor({ network }) {
    this.wantlist = createWantlist({ network });
    this.wantlistForPeer = createWantlistForPeer({ network });
    this.unwant = createUnwant({ network });
    this.stat = createStat({ network });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/add.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/utils.js
init_define_process();
function isValidMultiaddr(ma) {
  try {
    return IPFS.matches(ma);
  } catch (err2) {
    return false;
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/add.js
function createAdd2({ repo }) {
  async function add(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    const boostrappers = config2.Bootstrap || [];
    boostrappers.push(multiaddr2.toString());
    config2.Bootstrap = Array.from(
      new Set(boostrappers)
    ).sort((a, b) => a.localeCompare(b));
    await repo.config.replace(config2);
    return {
      Peers: [multiaddr2]
    };
  }
  return withTimeoutOption(add);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/clear.js
init_define_process();
function createClear({ repo }) {
  async function clear(options = {}) {
    const config2 = await repo.config.getAll(options);
    const removed = config2.Bootstrap || [];
    config2.Bootstrap = [];
    await repo.config.replace(config2);
    return { Peers: removed.map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(clear);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/list.js
init_define_process();
function createList({ repo }) {
  async function list(options = {}) {
    const peers = await repo.config.get("Bootstrap", options);
    return { Peers: (peers || []).map((ma) => multiaddr(ma)) };
  }
  return withTimeoutOption(list);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/reset.js
init_define_process();
function createReset({ repo }) {
  async function reset(options = {}) {
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = config_browser_default().Bootstrap;
    await repo.config.replace(config2);
    return {
      Peers: config_browser_default().Bootstrap.map((ma) => multiaddr(ma))
    };
  }
  return withTimeoutOption(reset);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/rm.js
init_define_process();
function createRm2({ repo }) {
  async function rm(multiaddr2, options = {}) {
    if (!isValidMultiaddr(multiaddr2)) {
      throw new Error(`${multiaddr2} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr2.toString());
    await repo.config.replace(config2);
    return { Peers: [multiaddr2] };
  }
  return withTimeoutOption(rm);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/bootstrap/index.js
var BootstrapAPI = class {
  constructor({ repo }) {
    this.add = createAdd2({ repo });
    this.list = createList({ repo });
    this.rm = createRm2({ repo });
    this.clear = createClear({ repo });
    this.reset = createReset({ repo });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/get.js
init_define_process();
function createGet({ preload: preload2, repo }) {
  async function get6(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    return repo.blocks.get(cid, options);
  }
  return withTimeoutOption(get6);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/put.js
init_define_process();
function createPut({ codecs: codecs2, hashers, repo, preload: preload2 }) {
  async function put(block, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const cidVersion = options.version != null ? options.version : 0;
      const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
      const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
      const hash3 = await hasher.digest(block);
      const codec = await codecs2.getCodec(codecName);
      const cid = CID.create(cidVersion, codec.code, hash3);
      await repo.blocks.put(cid, block, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin === true) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/rm.js
init_define_process();
var import_err_code21 = __toESM(require_err_code(), 1);
var import_it_parallel = __toESM(require_it_parallel(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
var import_it_filter3 = __toESM(require_it_filter(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/utils.js
init_define_process();
function cleanCid(cid) {
  if (cid instanceof Uint8Array) {
    return CID.decode(cid);
  }
  return CID.parse(cid.toString());
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/rm.js
var BLOCK_RM_CONCURRENCY = 8;
function createRm3({ repo }) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* pipe(
        cids,
        (source) => (0, import_it_map2.default)(source, (cid) => {
          return async () => {
            cid = cleanCid(cid);
            const result = { cid };
            try {
              const has = await repo.blocks.has(cid);
              if (!has) {
                throw (0, import_err_code21.default)(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
              }
              await repo.blocks.delete(cid);
            } catch (err2) {
              if (!options.force) {
                err2.message = `cannot remove ${cid}: ${err2.message}`;
                result.error = err2;
              }
            }
            return result;
          };
        }),
        (source) => (0, import_it_parallel.default)(source, { concurrency: BLOCK_RM_CONCURRENCY }),
        (source) => (0, import_it_filter3.default)(source, () => !options.quiet)
      );
    } finally {
      release();
    }
  }
  return withTimeoutOption(rm);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/stat.js
init_define_process();
function createStat2({ repo, preload: preload2 }) {
  async function stat(cid, options = {}) {
    cid = cleanCid(cid);
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid);
    return { cid, size: block.length };
  }
  return withTimeoutOption(stat);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/block/index.js
var BlockAPI = class {
  constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
    this.get = createGet({ preload: preload2, repo });
    this.put = createPut({ codecs: codecs2, hashers, preload: preload2, repo });
    this.rm = createRm3({ repo });
    this.stat = createStat2({ preload: preload2, repo });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/root.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/add.js
init_define_process();
var import_it_last3 = __toESM(require_it_last(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-single.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-content.js
init_define_process();
var import_err_code22 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
var import_blob_to_it = __toESM(require_blob_to_it(), 1);
var import_it_peekable = __toESM(require_it_peekable(), 1);
var import_it_all2 = __toESM(require_it_all(), 1);
var import_it_map3 = __toESM(require_it_map(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/utils.js
init_define_process();
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value) => value && typeof value.getReader === "function";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes(input)) {
    return toAsyncIterable(toBytes(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()));
  }
  if (isBlob(input)) {
    return (0, import_blob_to_it.default)(input);
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await (0, import_it_all2.default)(peekable)));
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return (0, import_it_map3.default)(peekable, toBytes);
    }
  }
  throw (0, import_err_code22.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString(chunk.toString());
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-candidate-single.js
init_define_process();
var import_err_code23 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable2 = __toESM(require_it_peekable(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code23.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input) || isBlob(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it2.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable2.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code23.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code23.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path: path4, mode, mtime, content } = input;
  const file = {
    path: path4 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path4) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-single.js
function normaliseInput2(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/add.js
function createAdd3({ addAll }) {
  async function add(entry, options = {}) {
    const result = await (0, import_it_last3.default)(addAll(normaliseInput2(entry), options));
    if (result == null) {
      throw Error("Failed to add a file, if you see this please report a bug");
    }
    return result;
  }
  return add;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/add-all/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/index.js
init_define_process();
var import_it_parallel_batch2 = __toESM(require_it_parallel_batch(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/options.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-murmur3-npm-1.1.3-ad0394d135-9.zip/node_modules/@multiformats/murmur3/esm/index.js
init_define_process();
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf(number) {
  const bytes2 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes2[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
var murmur332 = from({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/options.js
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults = merge_options_default.bind({ ignoreUndefined: true });
  return defaults(defaultOptions, options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/utils/persist.js
init_define_process();
var persist = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};
var persist_default = persist;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js
var dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode2(prepare({ Data: unixfs.marshal() }));
  const cid = await persist_default(buffer2, blockstore, options);
  const path4 = item.path;
  return {
    cid,
    path: path4,
    unixfs,
    size: buffer2.length
  };
};
var dir_default = dirBuilder;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
init_define_process();
var import_err_code24 = __toESM(require_err_code(), 1);
var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js
init_define_process();
var import_it_all3 = __toESM(require_it_all(), 1);
async function flat(source, reduce2) {
  return reduce2(await (0, import_it_all3.default)(source));
}
var flat_default = flat;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js
init_define_process();
var import_it_batch = __toESM(require_it_batch(), 1);
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots = [];
  for await (const chunked of (0, import_it_batch.default)(source, options.maxChildrenPerNode)) {
    roots.push(await reduce2(chunked));
  }
  if (roots.length > 1) {
    return reduceToParents(roots, reduce2, options);
  }
  return roots[0];
}
var balanced_default = balanced;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js
init_define_process();
var import_it_batch2 = __toESM(require_it_batch(), 1);
async function trickleStream(source, reduce2, options) {
  const root = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root;
  for await (const layer of (0, import_it_batch2.default)(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce2));
  }
  return root.reduce(reduce2);
}
var trickle_default = trickleStream;
var SubTree = class {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent2) {
    this.parent = parent2;
    const nextNode = {
      children: [],
      depth: parent2.depth + 1,
      parent: parent2,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent2.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node, reduce2) {
    let children = [];
    if (node.children.length) {
      children = await Promise.all(
        node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2))
      );
    }
    return reduce2((node.data || []).concat(children));
  }
  _findParent(node, depth) {
    const parent2 = node.parent;
    if (!parent2 || parent2.depth === 0) {
      return;
    }
    if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
      return this._findParent(parent2, depth);
    }
    return parent2;
  }
};
var Root = class extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/buffer-importer.js
init_define_process();
async function* bufferImporter(file, block, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: src_exports,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw_exports;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2
        });
        buffer2 = encode2({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist_default(buffer2, block, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
var buffer_importer_default = bufferImporter;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter2;
  if (typeof options.bufferImporter === "function") {
    bufferImporter2 = options.bufferImporter;
  } else {
    bufferImporter2 = buffer_importer_default;
  }
  for await (const entry of (0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
var reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer3 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer3
        });
        buffer3 = encode2(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist_default(buffer3, blockstore, {
          ...options,
          codec: src_exports,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer3.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links3 = leaves.filter((leaf) => {
      if (leaf.cid.code === code && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code) {
        f.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f.marshal(),
      Links: links3
    };
    const buffer2 = encode2(prepare(node));
    const cid = await persist_default(buffer2, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f,
      size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code24.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
var import_err_code27 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js
init_define_process();
var import_BufferList = __toESM(require_BufferList(), 1);
var import_rabin_wasm = __toESM(require_src2(), 1);
var import_err_code25 = __toESM(require_err_code(), 1);
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw (0, import_err_code25.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw (0, import_err_code25.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
var rabin_default = rabinChunker;
async function* rabin(source, options) {
  const r = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
  const buffers = new import_BufferList.default();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i = 0; i < sizes.length; i++) {
      const size = sizes[i];
      const buf2 = buffers.slice(0, size);
      buffers.consume(size);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js
init_define_process();
var import_BufferList2 = __toESM(require_BufferList(), 1);
async function* fixedSizeChunker(source, options) {
  let bl = new import_BufferList2.default();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    bl.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl.length) {
        bl = new import_BufferList2.default();
        currentLength = 0;
      } else {
        const newBl = new import_BufferList2.default();
        newBl.append(bl.shallowSlice(maxChunkSize));
        bl = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl.slice(0, currentLength);
  }
}
var fixed_size_default = fixedSizeChunker;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js
init_define_process();
var import_err_code26 = __toESM(require_err_code(), 1);
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw (0, import_err_code26.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw (0, import_err_code26.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
var validate_chunks_default = validateChunks;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code27.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code27.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path4) => path4 && path4 !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabin_default;
      } else {
        chunker = fixed_size_default;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validate_chunks_default;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => file_default(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dir_default(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
var dag_builder_default = dagBuilder;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/tree-builder.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dir-flat.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dir.js
init_define_process();
var Dir = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name6, value) {
  }
  get(name6) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var dir_default2 = Dir;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dir-flat.js
var DirFlat = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name6, value) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name6] = value;
  }
  get(name6) {
    return Promise.resolve(this._children[name6]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys = Object.keys(this._children);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  async *flush(block) {
    const children = Object.keys(this._children);
    const links3 = [];
    for (let i = 0; i < children.length; i++) {
      let child = this._children[children[i]];
      if (child instanceof dir_default2) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links3.push({
          Name: children[i],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = { Data: unixfs.marshal(), Links: links3 };
    const buffer2 = encode2(prepare(node));
    const cid = await persist_default(buffer2, block, this.options);
    const size = buffer2.length + node.Links.reduce(
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs,
      path: this.path,
      size
    };
  }
};
var dir_flat_default = DirFlat;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dir-sharded.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/bucket.js
init_define_process();
var import_sparse_array = __toESM(require_sparse_array(), 1);
var Bucket = class {
  constructor(options, parent2, posAtParent = 0) {
    this._options = options;
    this._popCount = 0;
    this._parent = parent2;
    this._posAtParent = posAtParent;
    this._children = new import_sparse_array.default();
    this.key = null;
  }
  async put(key, value) {
    const place = await this._findNewBucketAndPos(key);
    await place.bucket._putAt(place, key, value);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map18, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map18, reduce2));
        } else {
          acc2.push(map18(child, index));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return await asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString(key) : key);
    const index = await hashValue.take(this._options.bits);
    const child = this._children.get(index);
    if (child instanceof Bucket) {
      return await child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return await bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value) {
    this._putObjectAt(place.pos, {
      key,
      value,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash3 = onlyChild.hash;
          hash3.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash3,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index) {
    return this._children.get(index);
  }
};
function exists(o) {
  return Boolean(o);
}
function mapNode(node, _) {
  return node.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return await asyncReduce(output);
}

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/consumable-hash.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/consumable-buffer.js
init_define_process();
var START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
var STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
var ConsumableBuffer = class {
  constructor(value) {
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt(byte, start, length5) {
  const mask = maskFor(start, length5);
  return (byte & mask) >>> start;
}
function maskFor(start, length5) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length5 + start - 1, 7)];
}

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/consumable-hash.js
init_concat();
function wrapHash(hashFn2) {
  function hashing(value) {
    if (value instanceof InfiniteHash) {
      return value;
    } else {
      return new InfiniteHash(value, hashFn2);
    }
  }
  return hashing;
}
var InfiniteHash = class {
  constructor(value, hashFn2) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash3.availableBits(), pendingBits);
      const took = hash3.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash3.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash3 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash3.totalBits() - hash3.availableBits(), pendingBits);
      hash3.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash3.totalBits() === hash3.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth > 0 ? concat([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
};

// ../../../../../Users/z/.yarn/berry/cache/hamt-sharding-npm-3.0.1-b03a2029ab-9.zip/node_modules/hamt-sharding/dist/src/index.js
function createHAMT(options) {
  if (options == null || options.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options.bits ?? 8,
    hash: wrapHash(options.hashFn)
  };
  return new Bucket(bucketOptions);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/dir-sharded.js
var DirSharded = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name6, value) {
    await this._bucket.put(name6, value);
  }
  get(name6) {
    return this._bucket.get(name6);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
var dir_sharded_default = DirSharded;
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (!child) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode2(prepare(node));
  const cid = await persist_default(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
var flat_to_shard_default = flatToShard;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js
init_define_process();
var toPathComponents = (path4 = "") => {
  return (path4.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/tree-builder.js
async function addToTree(elem, tree2, options) {
  const pathElems = to_path_components_default(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i = 0; i < pathElems.length; i++) {
    const pathElem = pathElems[i];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last14 = i === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last14) {
      await parent2.put(pathElem, elem);
      tree2 = await flat_to_shard_default(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof dir_default2)) {
        dir = new dir_flat_default({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof dir_default2)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block, options) {
  let tree2 = new dir_flat_default({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
var tree_builder_default = treeBuilder;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-importer-npm-10.0.2-5a86e0dc88-9.zip/node_modules/ipfs-unixfs-importer/src/index.js
async function* importer(source, blockstore, options = {}) {
  const opts = options_default(options);
  let dagBuilder2;
  if (typeof options.dagBuilder === "function") {
    dagBuilder2 = options.dagBuilder;
  } else {
    dagBuilder2 = dag_builder_default;
  }
  let treeBuilder2;
  if (typeof options.treeBuilder === "function") {
    treeBuilder2 = options.treeBuilder;
  } else {
    treeBuilder2 = tree_builder_default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-candidate-multiple.js
init_define_process();
var import_err_code28 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable3 = __toESM(require_it_peekable(), 1);
var import_it_map4 = __toESM(require_it_map(), 1);
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
    throw (0, import_err_code28.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it3.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable3.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw (0, import_err_code28.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* (0, import_it_map4.default)(peekable, (value2) => toFileObject2({ content: value2 }, normaliseContent3));
      return;
    }
    if (isBytes(value)) {
      yield toFileObject2({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
      yield* (0, import_it_map4.default)(peekable, (value2) => toFileObject2(value2, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code28.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code28.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path: path4, mode, mtime, content } = input;
  const file = {
    path: path4 || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path4) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.js
function normaliseInput3(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/add-all/utils.js
init_define_process();
var parseChunkerString = (chunker) => {
  if (!chunker) {
    return {
      chunker: "fixed"
    };
  } else if (chunker.startsWith("size-")) {
    const sizeStr = chunker.split("-")[1];
    const size = parseInt(sizeStr);
    if (isNaN(size)) {
      throw new Error("Chunker parameter size must be an integer");
    }
    return {
      chunker: "fixed",
      maxChunkSize: size
    };
  } else if (chunker.startsWith("rabin")) {
    return {
      chunker: "rabin",
      ...parseRabinString(chunker)
    };
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`);
  }
};
var parseRabinString = (chunker) => {
  const options = {};
  const parts = chunker.split("-");
  switch (parts.length) {
    case 1:
      options.avgChunkSize = 262144;
      break;
    case 2:
      options.avgChunkSize = parseChunkSize(parts[1], "avg");
      break;
    case 4:
      options.minChunkSize = parseChunkSize(parts[1], "min");
      options.avgChunkSize = parseChunkSize(parts[2], "avg");
      options.maxChunkSize = parseChunkSize(parts[3], "max");
      break;
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
  }
  return options;
};
var parseChunkSize = (str, name6) => {
  const size = parseInt(str);
  if (isNaN(size)) {
    throw new Error(`Chunker parameter ${name6} must be an integer`);
  }
  return size;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/add-all/index.js
var mergeOptions3 = merge_options_default.bind({ ignoreUndefined: true });
function createAddAll2({ repo, preload: preload2, hashers, options }) {
  const isShardingEnabled = options && options.sharding;
  async function* addAll(source, options2 = {}) {
    const opts = mergeOptions3({
      shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
      strategy: "balanced"
    }, options2, {
      ...parseChunkerString(options2.chunker)
    });
    if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
      opts.cidVersion = 1;
    }
    if (opts.trickle) {
      opts.strategy = "trickle";
    }
    if (opts.strategy === "trickle") {
      opts.leafType = "raw";
      opts.reduceSingleLeafToSelf = false;
    }
    if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    delete opts.trickle;
    const totals = {};
    if (opts.progress) {
      const prog = opts.progress;
      opts.progress = (bytes2, path4) => {
        if (!totals[path4]) {
          totals[path4] = 0;
        }
        totals[path4] += bytes2;
        prog(totals[path4], path4);
      };
    }
    let hasher;
    if (opts.hashAlg != null) {
      hasher = await hashers.getHasher(opts.hashAlg);
    }
    const iterator = pipe(
      normaliseInput3(source),
      (source2) => importer(source2, repo.blocks, {
        ...opts,
        hasher,
        pin: false
      }),
      transformFile(opts),
      preloadFile(preload2, opts),
      pinFile(repo, opts)
    );
    const releaseLock = await repo.gcLock.readLock();
    try {
      for await (const added of iterator) {
        const path4 = added.path ?? added.cid.toString();
        delete totals[path4];
        yield {
          ...added,
          path: path4
        };
      }
    } finally {
      releaseLock();
    }
  }
  return withTimeoutOption(addAll);
}
function transformFile(opts) {
  async function* transformFile2(source) {
    for await (const file of source) {
      let cid = file.cid;
      if (opts.cidVersion === 1) {
        cid = cid.toV1();
      }
      let path4 = file.path ? file.path : cid.toString();
      if (opts.wrapWithDirectory && !file.path) {
        path4 = "";
      }
      yield {
        path: path4,
        cid,
        size: file.size,
        mode: file.unixfs && file.unixfs.mode,
        mtime: file.unixfs && file.unixfs.mtime
      };
    }
  }
  return transformFile2;
}
function preloadFile(preload2, opts) {
  async function* maybePreloadFile(source) {
    for await (const file of source) {
      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
      if (shouldPreload) {
        preload2(file.cid);
      }
      yield file;
    }
  }
  return maybePreloadFile;
}
function pinFile(repo, opts) {
  async function* maybePinFile(source) {
    for await (const file of source) {
      const isRootDir = !(file.path && file.path.includes("/"));
      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
      if (shouldPin) {
        await repo.pins.pinRecursively(file.cid);
      }
      yield file;
    }
  }
  return maybePinFile;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/cat.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/index.js
init_define_process();
var import_err_code36 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
init_define_process();
var import_err_code35 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
init_define_process();
var import_err_code31 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js
init_define_process();
var hashFn = async function(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
};
var addLinksToHamtBucket = (links3, bucket, rootBucket) => {
  return Promise.all(
    links3.map((link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    })
  );
};
var toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var toBucketPath = (position) => {
  let bucket = position.bucket;
  const path4 = [];
  while (bucket._parent) {
    path4.push(bucket);
    bucket = bucket._parent;
  }
  path4.push(bucket);
  return path4.reverse();
};
var findShardCid = async (node, name6, blockstore, context, options) => {
  if (!context) {
    const rootBucket = createHAMT({
      hashFn
    });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name6);
  let prefix = toPrefix(position.pos);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix(context.lastBucket._posAtParent);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name6) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name6) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node = decode3(block);
  return findShardCid(node, name6, blockstore, context, options);
};
var find_cid_in_shard_default = findShardCid;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js
init_define_process();
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.subarray(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.subarray(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default = extractDataFromBlock;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js
init_define_process();
var import_err_code29 = __toESM(require_err_code(), 1);
var validateOffsetAndLength = (size, offset, length5) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw (0, import_err_code29.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size) {
    throw (0, import_err_code29.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length5 && length5 !== 0) {
    length5 = size - offset;
  }
  if (length5 < 0) {
    throw (0, import_err_code29.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length5 > size) {
    length5 = size - offset;
  }
  return {
    offset,
    length: length5
  };
};
var validate_offset_and_length_default = validateOffsetAndLength;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js
var import_err_code30 = __toESM(require_err_code(), 1);
var import_it_parallel2 = __toESM(require_it_parallel(), 1);
var import_it_map5 = __toESM(require_it_map(), 1);
async function walkDAG(blockstore, node, queue, streamPosition, start, end, walkQueue, options) {
  if (node instanceof Uint8Array) {
    queue.push(extract_data_from_block_default(node, streamPosition, start, end));
    return;
  }
  if (node.Data == null) {
    throw (0, import_err_code30.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code30.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (file.data != null) {
    const data = file.data;
    const buf2 = extract_data_from_block_default(data, streamPosition, start, end);
    queue.push(buf2);
    streamPosition += buf2.byteLength;
  }
  const childOps = [];
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i];
    const childStart = streamPosition;
    const childEnd = childStart + file.blockSizes[i];
    if (start >= childStart && start < childEnd || end >= childStart && end <= childEnd || start < childStart && end > childEnd) {
      childOps.push({
        link: childLink,
        blockStart: streamPosition
      });
    }
    streamPosition = childEnd;
    if (streamPosition > end) {
      break;
    }
  }
  await pipe(
    childOps,
    (source) => (0, import_it_map5.default)(source, (op) => {
      return async () => {
        const block = await blockstore.get(op.link.Hash, {
          signal: options.signal
        });
        return {
          ...op,
          block
        };
      };
    }),
    (source) => (0, import_it_parallel2.default)(source, {
      ordered: true
    }),
    async (source) => {
      for await (const { link, block, blockStart } of source) {
        let child;
        switch (link.Hash.code) {
          case code3:
            child = decode3(block);
            break;
          case code:
            child = block;
            break;
          default:
            queue.end((0, import_err_code30.default)(new Error(`Unsupported codec: ${link.Hash.code}`), "ERR_NOT_UNIXFS"));
            return;
        }
        walkQueue.add(async () => {
          await walkDAG(blockstore, child, queue, blockStart, start, end, walkQueue, options);
        });
      }
    }
  );
}
var fileContent = (cid, node, unixfs, path4, resolve7, depth, blockstore) => {
  async function* yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const {
      offset,
      length: length5
    } = validate_offset_and_length_default(fileSize, options.offset, options.length);
    if (length5 === 0) {
      return;
    }
    const walkQueue = new PQueue({
      concurrency: 1
    });
    const queue = pushable();
    walkQueue.add(async () => {
      await walkDAG(blockstore, node, queue, 0, offset, offset + length5, walkQueue, options);
    });
    walkQueue.on("error", (error) => {
      queue.end(error);
    });
    let read2 = 0;
    for await (const buf2 of queue) {
      if (buf2 == null) {
        continue;
      }
      read2 += buf2.byteLength;
      if (read2 === length5) {
        queue.end();
      }
      yield buf2;
    }
  }
  return yieldFileContent;
};
var file_default2 = fileContent;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js
init_define_process();
var directoryContent = (cid, node, unixfs, path4, resolve7, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length5 = options.length || node.Links.length;
    const links3 = node.Links.slice(offset, length5);
    for (const link of links3) {
      const result = await resolve7(link.Hash, link.Name || "", `${path4}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
var directory_default = directoryContent;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
init_define_process();
var hamtShardedDirectoryContent = (cid, node, unixfs, path4, resolve7, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node, path4, resolve7, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path4, resolve7, depth, blockstore, options) {
  const links3 = node.Links;
  for (const link of links3) {
    const name6 = link.Name != null ? link.Name.substring(2) : null;
    if (name6) {
      const result = await resolve7(link.Hash, name6, `${path4}/${name6}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode3(block);
      for await (const file of listDirectory(node, path4, resolve7, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamt_sharded_directory_default = hamtShardedDirectoryContent;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
var findLinkCid = (node, name6) => {
  const link = node.Links.find((link2) => link2.Name === name6);
  return link && link.Hash;
};
var contentExporters = {
  raw: file_default2,
  file: file_default2,
  directory: directory_default,
  "hamt-sharded-directory": hamt_sharded_directory_default,
  metadata: (cid, node, unixfs, path4, resolve7, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs, path4, resolve7, depth, blockstore) => {
    return () => [];
  }
};
var unixFsResolver = async (cid, name6, path4, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node = decode3(block);
  let unixfs;
  let next;
  if (!name6) {
    name6 = cid.toString();
  }
  if (node.Data == null) {
    throw (0, import_err_code31.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS.unmarshal(node.Data);
  } catch (err2) {
    throw (0, import_err_code31.default)(err2, "ERR_NOT_UNIXFS");
  }
  if (!path4) {
    path4 = name6;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (!linkCid) {
      throw (0, import_err_code31.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path4}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name6,
      path: path4,
      cid,
      content: contentExporters[unixfs.type](cid, node, unixfs, path4, resolve7, depth, blockstore),
      unixfs,
      depth,
      node,
      size: unixfs.fileSize()
    },
    next
  };
};
var unixfs_v1_default = unixFsResolver;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js
init_define_process();
var import_err_code32 = __toESM(require_err_code(), 1);
var rawContent = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length5
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve2 = async (cid, name6, path4, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code32.default)(new Error(`No link named ${path4} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name6,
      path: path4,
      cid,
      content: rawContent(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
var raw_default = resolve2;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js
init_define_process();
var import_err_code33 = __toESM(require_err_code(), 1);
var resolve3 = async (cid, name6, path4, toResolve, resolve7, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode5(block);
  let subObject = object;
  let subPath = path4;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name6,
            path: path4,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw (0, import_err_code33.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name6,
      path: path4,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
var dag_cbor_default = resolve3;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/identity.js
init_define_process();
var import_err_code34 = __toESM(require_err_code(), 1);
var rawContent2 = (node) => {
  async function* contentGenerator(options = {}) {
    const {
      offset,
      length: length5
    } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve4 = async (cid, name6, path4, toResolve, resolve7, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code34.default)(new Error(`No link named ${path4} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = await decode(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name6,
      path: path4,
      cid,
      content: rawContent2(buf2.digest),
      depth,
      size: buf2.digest.length,
      node: buf2.digest
    }
  };
};
var identity_default = resolve4;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
var resolvers2 = {
  [code3]: unixfs_v1_default,
  [code]: raw_default,
  [code4]: dag_cbor_default,
  [identity.code]: identity_default
};
function resolve5(cid, name6, path4, toResolve, depth, blockstore, options) {
  const resolver = resolvers2[cid.code];
  if (!resolver) {
    throw (0, import_err_code35.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name6, path4, toResolve, resolve5, depth, blockstore, options);
}
var resolvers_default = resolve5;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-unixfs-exporter-npm-8.0.6-a164b46f1c-9.zip/node_modules/ipfs-unixfs-exporter/src/index.js
var import_it_last4 = __toESM(require_it_last(), 1);
var toPathComponents2 = (path4 = "") => {
  return (path4.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
var cidAndRest = (path4) => {
  if (path4 instanceof Uint8Array) {
    return {
      cid: CID.decode(path4),
      toResolve: []
    };
  }
  const cid = CID.asCID(path4);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path4 === "string") {
    if (path4.indexOf("/ipfs/") === 0) {
      path4 = path4.substring(6);
    }
    const output = toPathComponents2(path4);
    return {
      cid: CID.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw (0, import_err_code36.default)(new Error(`Unknown path type ${path4}`), "ERR_BAD_PATH");
};
async function* walkPath(path4, blockstore, options = {}) {
  let {
    cid,
    toResolve
  } = cidAndRest(path4);
  let name6 = cid.toString();
  let entryPath = name6;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name6, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code36.default)(new Error(`Could not resolve ${path4}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name6 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter(path4, blockstore, options = {}) {
  const result = await (0, import_it_last4.default)(walkPath(path4, blockstore, options));
  if (!result) {
    throw (0, import_err_code36.default)(new Error(`Could not resolve ${path4}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path4, blockstore, options = {}) {
  const node = await exporter(path4, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/cat.js
function createCat({ repo, preload: preload2 }) {
  async function* cat(ipfsPath3, options = {}) {
    ipfsPath3 = normalizeCidPath(ipfsPath3);
    if (options.preload !== false) {
      const pathComponents = ipfsPath3.split("/");
      preload2(CID.parse(pathComponents[0]));
    }
    const file = await exporter(ipfsPath3, repo.blocks, options);
    if (file.type === "directory") {
      throw new Error("this dag node is a directory");
    }
    if (!file.content) {
      throw new Error("this dag node has no content");
    }
    yield* file.content(options);
  }
  return withTimeoutOption(cat);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/get.js
init_define_process();
var import_err_code37 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/extract.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/extract-headers.js
init_define_process();
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR_MAGIC = fromString("ustar\0", "binary");
var GNU_MAGIC = fromString("ustar ", "binary");
var GNU_VER = fromString(" \0", "binary");

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/lte-reader.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-reader-npm-6.0.1-1dff83b6fe-9.zip/node_modules/it-reader/dist/src/index.js
init_define_process();
function reader(source) {
  const reader2 = async function* () {
    let bytes2 = yield;
    let bl = new Uint8ArrayList();
    for await (const chunk of source) {
      if (bytes2 == null) {
        bl.append(chunk);
        bytes2 = yield bl;
        bl = new Uint8ArrayList();
        continue;
      }
      bl.append(chunk);
      while (bl.length >= bytes2) {
        const data = bl.sublist(0, bytes2);
        bl.consume(bytes2);
        bytes2 = yield data;
        if (bytes2 == null) {
          if (bl.length > 0) {
            bytes2 = yield bl;
            bl = new Uint8ArrayList();
          }
          break;
        }
      }
    }
    if (bytes2 != null) {
      throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
    }
  }();
  void reader2.next();
  return reader2;
}

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/pack.js
init_define_process();
var import_iso_constants = __toESM(require_index_browser(), 1);
var import_it_to_buffer = __toESM(require_it_to_buffer(), 1);

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/pack-headers.js
init_define_process();
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET2 = "0".charCodeAt(0);
var USTAR_MAGIC2 = fromString("ustar\0", "binary");
var USTAR_VER = fromString("00", "binary");
var MASK = parseInt("7777", 8);
var MAGIC_OFFSET = 257;
var VERSION_OFFSET = 263;
var toTypeflag = function(flag) {
  switch (flag) {
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
    default:
      return 0;
  }
};
var cksum = function(block) {
  let sum = 8 * 32;
  for (let i = 0; i < 148; i++)
    sum += block[i];
  for (let j = 156; j < 512; j++)
    sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  const str = val.toString(8);
  if (str.length > n) {
    return fromString(SEVENS.slice(0, n) + " ");
  }
  return fromString(ZEROS.slice(0, n - str.length) + str + " ");
};
var addLength = function(str) {
  const len = fromString(str).byteLength;
  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) {
    digits++;
  }
  return `${len + digits}${str}`;
};
function encodePax(opts) {
  let result = "";
  if (opts.name != null) {
    result += addLength(" path=" + opts.name + "\n");
  }
  if (opts.linkname != null) {
    result += addLength(" linkpath=" + opts.linkname + "\n");
  }
  const pax = opts.pax;
  if (pax != null) {
    for (const key in pax) {
      if (Object.prototype.hasOwnProperty.call(pax, key)) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
  }
  return fromString(result);
}
function encode10(opts) {
  const buf2 = new Uint8Array(512);
  let name6 = opts.name;
  let prefix = "";
  if (opts.typeflag === 5 && name6[name6.length - 1] !== "/") {
    name6 += "/";
  }
  if (fromString(name6).byteLength !== name6.length) {
    return null;
  }
  while (fromString(name6).byteLength > 100) {
    const i = name6.indexOf("/");
    if (i === -1) {
      return null;
    }
    prefix += prefix !== "" ? "/" + name6.slice(0, i) : name6.slice(0, i);
    name6 = name6.slice(i + 1);
  }
  if (fromString(name6).byteLength > 100 || fromString(prefix).byteLength > 155) {
    return null;
  }
  if (opts.linkname != null && fromString(opts.linkname).byteLength > 100) {
    return null;
  }
  buf2.set(fromString(name6), 0);
  buf2.set(encodeOct(opts.mode & MASK, 6), 100);
  buf2.set(encodeOct(opts.uid, 6), 108);
  buf2.set(encodeOct(opts.gid, 6), 116);
  buf2.set(encodeOct(opts.size, 11), 124);
  buf2.set(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf2[156] = ZERO_OFFSET2 + toTypeflag(opts.type);
  if (opts.linkname != null) {
    buf2.set(fromString(opts.linkname), 157);
  }
  buf2.set(USTAR_MAGIC2, MAGIC_OFFSET);
  buf2.set(USTAR_VER, VERSION_OFFSET);
  if (opts.uname != null) {
    buf2.set(fromString(opts.uname), 265);
  }
  if (opts.gname != null) {
    buf2.set(fromString(opts.gname), 297);
  }
  buf2.set(encodeOct(opts.devmajor ?? 0, 6), 329);
  buf2.set(encodeOct(opts.devminor ?? 0, 6), 337);
  if (prefix != null) {
    buf2.set(fromString(prefix), 345);
  }
  buf2.set(encodeOct(cksum(buf2), 6), 148);
  return buf2;
}

// ../../../../../Users/z/.yarn/berry/cache/it-tar-npm-6.0.0-1b953f25b6-9.zip/node_modules/it-tar/dist/src/pack.js
var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = import_iso_constants.default;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = new Uint8Array(1024);
function modeToType(mode = 0) {
  switch (mode & S_IFMT) {
    case S_IFBLK:
      return "block-device";
    case S_IFCHR:
      return "character-device";
    case S_IFDIR:
      return "directory";
    case S_IFIFO:
      return "fifo";
    case S_IFLNK:
      return "symlink";
    default:
      return "file";
  }
}
function getPadding(size) {
  size &= 511;
  if (size !== 0) {
    return END_OF_TAR.subarray(0, 512 - size);
  }
  return new Uint8Array(0);
}
function encode11(header) {
  if (header.pax == null) {
    const encoded = encode10(header);
    if (encoded != null) {
      return encoded;
    }
  }
  return encodePax2(header);
}
function encodePax2(header) {
  const paxHeader = encodePax(header);
  const newHeader = {
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname,
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  return new Uint8ArrayList(encode10(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), encode10({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)).subarray();
}
function pack() {
  return async function* (source) {
    for await (let { header: partialHeader, body } of source) {
      const header = {
        ...partialHeader,
        size: partialHeader.type === "symlink" ? 0 : partialHeader.size ?? 0,
        type: partialHeader.type ?? modeToType(partialHeader.mode),
        mode: partialHeader.mode ?? (partialHeader.type === "directory" ? DMODE : FMODE),
        uid: partialHeader.uid ?? 0,
        gid: partialHeader.gid ?? 0,
        mtime: partialHeader.mtime ?? new Date()
      };
      if (typeof body === "string") {
        body = fromString(body);
      }
      if (body instanceof Uint8Array || isUint8ArrayList(body)) {
        header.size = body.length;
        yield encode11(header);
        yield isUint8ArrayList(body) ? body.subarray() : body;
        yield getPadding(header.size);
        continue;
      }
      if (header.type === "symlink" && header.linkname == null) {
        if (body == null) {
          throw new Error("type was symlink but no linkname or body specified");
        }
        header.linkname = toString(await (0, import_it_to_buffer.default)(body));
        yield encode11(header);
        continue;
      }
      yield encode11(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        continue;
      }
      let written = 0;
      for await (const chunk of body ?? []) {
        written += chunk.length;
        yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;
      }
      if (written !== header.size) {
        throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);
      }
      yield getPadding(header.size);
    }
    yield END_OF_TAR;
  };
}

// ../../../../../Users/z/.yarn/berry/cache/pako-npm-2.0.4-1d4e28f3ac-9.zip/node_modules/pako/dist/pako.esm.mjs
init_define_process();
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf2) {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length5) => {
  if (s.bi_valid > Buf_size - length5) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length5 - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length5;
  }
};
var send_code = (s, c, tree2) => {
  send_bits(s, tree2[c * 2], tree2[c * 2 + 1]);
};
var bi_reverse = (code7, len) => {
  let res = 0;
  do {
    res |= code7 & 1;
    code7 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree2[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree2[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree2[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree2[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree2[m * 2 + 1]) * tree2[m * 2];
        tree2[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree2, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code7 = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code7 = code7 + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree2[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree2[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length5;
  let code7;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length5 = 0;
  for (code7 = 0; code7 < LENGTH_CODES$1 - 1; code7++) {
    base_length[code7] = length5;
    for (n = 0; n < 1 << extra_lbits[code7]; n++) {
      _length_code[length5++] = code7;
    }
  }
  _length_code[length5 - 1] = code7;
  dist = 0;
  for (code7 = 0; code7 < 16; code7++) {
    base_dist[code7] = dist;
    for (n = 0; n < 1 << extra_dbits[code7]; n++) {
      _dist_code[dist++] = code7;
    }
  }
  dist >>= 7;
  for (; code7 < D_CODES$1; code7++) {
    base_dist[code7] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code7] - 7; n++) {
      _dist_code[256 + dist++] = code7;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var copy_block = (s, buf2, len, header) => {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  s.pending_buf.set(s.window.subarray(buf2, buf2 + len), s.pending);
  s.pending += len;
};
var smaller = (tree2, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree2, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree2, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree2, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let lx = 0;
  let code7;
  let extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code7 = _length_code[lc];
        send_code(s, code7 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code7];
        if (extra !== 0) {
          lc -= base_length[code7];
          send_bits(s, lc, extra);
        }
        dist--;
        code7 = d_code(dist);
        send_code(s, code7, dtree);
        extra = extra_dbits[code7];
        if (extra !== 0) {
          dist -= base_dist[code7];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree2 = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree2[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree2[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree2[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree2, n);
  }
  node = elems;
  do {
    n = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree2, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree2[node * 2] = tree2[n * 2] + tree2[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree2[n * 2 + 1] = tree2[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree2, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree2, max_code, s.bl_count);
};
var scan_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree2[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree2, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree2[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree2[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let black_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf2, stored_len, last14) => {
  send_bits(s, (STORED_BLOCK << 1) + (last14 ? 1 : 0), 3);
  copy_block(s, buf2, stored_len, true);
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf2, stored_len, last14) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
    _tr_stored_block$1(s, buf2, stored_len, last14);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last14 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last14 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last14) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf2, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf2[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf2, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf2[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return (f << 1) - (f > 4 ? 9 : 0);
};
var zero = (buf2) => {
  let len = buf2.length;
  while (--len >= 0) {
    buf2[len] = 0;
  }
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last14) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last14);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf2, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf2.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf2, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf2, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush3) => {
  let max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    const max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
var deflate_fast = (s, flush3) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush3) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush3) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush3 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush3) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush3 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush3 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush3) => {
  let beg, val;
  if (!strm || !strm.state || flush3 > Z_BLOCK$1 || flush3 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush3 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  s.strm = strm;
  const old_flush = s.last_flush;
  s.last_flush = flush3;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush3) <= rank(old_flush) && flush3 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush3 !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush3) : s.strategy === Z_RLE ? deflate_rle(s, flush3) : configuration_table[s.level].func(s, flush3);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush3 === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush3 !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush3 === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush3 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf2, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf2 = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf2[i++] = c;
    } else if (c < 2048) {
      buf2[i++] = 192 | c >>> 6;
      buf2[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf2[i++] = 224 | c >>> 12;
      buf2[i++] = 128 | c >>> 6 & 63;
      buf2[i++] = 128 | c & 63;
    } else {
      buf2[i++] = 240 | c >>> 18;
      buf2[i++] = 128 | c >>> 12 & 63;
      buf2[i++] = 128 | c >>> 6 & 63;
      buf2[i++] = 128 | c & 63;
    }
  }
  return buf2;
};
var buf2binstring = (buf2, len) => {
  if (len < 65534) {
    if (buf2.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf2.length === len ? buf2 : buf2.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf2[i]);
  }
  return result;
};
var buf2string = (buf2, max) => {
  const len = max || buf2.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf2.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf2[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf2[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf2, max) => {
  max = max || buf2.length;
  if (max > buf2.length) {
    max = buf2.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf2[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf2[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last14;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from2;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last14 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from2++];
                      if (len > 1) {
                        output[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from2++];
                      if (len > 1) {
                        output[_out++] = output[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last14 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last14 ? 5 + (last14 - _in) : 5 - (_in - last14);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes3, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes3; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes3; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE2 = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush3) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from2;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    next + copy
                  ),
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush3 === Z_BLOCK || flush3 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush3 === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush3 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from2 = state.wsize - copy;
            } else {
              from2 = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from2 = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from2++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE2;
        case DONE2:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush3 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush3 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString3 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString3.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/get.js
var import_it_map6 = __toESM(require_it_map(), 1);
var import_it_to_buffer2 = __toESM(require_it_to_buffer(), 1);
var DEFAULT_COMPRESSION_LEVEL = 6;
function createGet2({ repo, preload: preload2 }) {
  async function* get6(ipfsPath3, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw (0, import_err_code37.default)(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = normalizeCidPath(ipfsPath3).split("/");
      } catch (err2) {
        throw (0, import_err_code37.default)(err2, "ERR_INVALID_PATH");
      }
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(ipfsPath3) || ipfsPath3;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file" || file.type === "raw") {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push(
          [{
            header: {
              name: file.path,
              mode: file.type === "file" && file.unixfs.mode,
              mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
              size: file.size,
              type: "file"
            },
            body: file.content()
          }],
          pack(),
          (source) => (0, import_it_map6.default)(source, (buf2) => buf2.slice())
        );
      } else {
        args.push(
          file.content
        );
      }
      if (options.compress) {
        args.push(
          async function* (source) {
            const buf2 = await (0, import_it_to_buffer2.default)(source);
            yield pako.gzip(buf2, {
              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
            });
          }
        );
      }
      yield* pipe(...args);
      return;
    }
    if (file.type === "directory") {
      const args = [
        recursive(ipfsPathOrCid, repo.blocks, options),
        async function* (source) {
          for await (const entry of source) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === "file") {
              output.header.type = "file";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
              output.body = entry.content();
            } else if (entry.type === "raw") {
              output.header.type = "file";
              output.body = entry.content();
            } else if (entry.type === "directory") {
              output.header.type = "directory";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
            } else {
              throw (0, import_err_code37.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
            }
            yield output;
          }
        },
        pack(),
        (source) => (0, import_it_map6.default)(source, (buf2) => buf2.slice())
      ];
      if (options.compress) {
        if (!options.archive) {
          throw (0, import_err_code37.default)(new Error("file is not regular"), "ERR_INVALID_PATH");
        }
        if (options.compress) {
          args.push(
            async function* (source) {
              const buf2 = await (0, import_it_to_buffer2.default)(source);
              yield pako.gzip(buf2, {
                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL
              });
            }
          );
        }
      }
      yield* pipe(...args);
      return;
    }
    throw (0, import_err_code37.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
  }
  return withTimeoutOption(get6);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/ls.js
init_define_process();
var import_err_code38 = __toESM(require_err_code(), 1);
function createLs2({ repo, preload: preload2 }) {
  async function* ls(ipfsPath3, options = {}) {
    const legacyPath = normalizeCidPath(ipfsPath3);
    const pathComponents = legacyPath.split("/");
    if (options.preload !== false) {
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(legacyPath) || legacyPath;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file") {
      yield mapFile(file);
      return;
    }
    if (file.type === "directory") {
      for await (const child of file.content()) {
        yield mapFile(child);
      }
      return;
    }
    throw (0, import_err_code38.default)(new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
  }
  return withTimeoutOption(ls);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/root.js
var RootAPI = class {
  constructor({ preload: preload2, repo, hashers, options }) {
    const addAll = createAddAll2({
      preload: preload2,
      repo,
      options,
      hashers
    });
    this.addAll = addAll;
    this.add = createAdd3({ addAll });
    this.cat = createCat({ repo, preload: preload2 });
    this.get = createGet2({ repo, preload: preload2 });
    this.ls = createLs2({ repo, preload: preload2 });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/version.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/version.js
init_define_process();
var ipfsCore = "0.16.1";
var commit = "d1f1e75b2060c5c2e64d133a7a6bbabd2641e5ef";
var interfaceIpfsCore = "^0.156.1";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/version.js
function createVersion({ repo }) {
  async function version3(_options = {}) {
    const repoVersion2 = await repo.version.get();
    return {
      version: ipfsCore,
      commit,
      repo: `${repoVersion2}`,
      "ipfs-core": ipfsCore,
      "interface-ipfs-core": interfaceIpfsCore
    };
  }
  return withTimeoutOption(version3);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/id.js
init_define_process();
var import_err_code39 = __toESM(require_err_code(), 1);
var log16 = logger("ipfs:components:id");
function createId({ peerId, network }) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new NotStartedError();
      }
      if (peerId.publicKey == null) {
        throw (0, import_err_code39.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
      }
      return {
        id: peerId,
        publicKey: toString(peerId.publicKey, "base64pad"),
        addresses: [],
        agentVersion: `js-ipfs/${ipfsCore}`,
        protocolVersion: "9000",
        protocols: []
      };
    }
    const { libp2p } = net;
    const peerIdToId = options.peerId ? options.peerId : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString(peer.metadata.get("AgentVersion") || new Uint8Array());
    const protocolVersion = toString(peer.metadata.get("ProtocolVersion") || new Uint8Array());
    const idStr = peer.id.toString();
    const publicKeyStr = peer.publicKey ? toString(peer.publicKey, "base64pad") : "";
    return {
      id: peerIdToId,
      publicKey: publicKeyStr,
      addresses: (peer.addresses || []).map((ma) => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${idStr}`)) {
          return str;
        }
        return `${str}/p2p/${idStr}`;
      }).sort().map((ma) => multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);
  if (publicKey == null) {
    try {
      publicKey = await libp2p.getPublicKey(peerId, options);
    } catch (err2) {
      log16.error("Could not load public key for", peerId.toString(), err2);
    }
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || /* @__PURE__ */ new Map(),
    addresses: peer.addresses.map((addr) => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  if (libp2p.dht == null) {
    throw (0, import_err_code39.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
  }
  for await (const event of libp2p.dht.findPeer(peerId, options)) {
    if (event.name === "FINAL_PEER") {
      break;
    }
  }
  const peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    throw (0, import_err_code39.default)(new Error("Could not find peer"), "ERR_NOT_FOUND");
  }
  return peer;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/config/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/config/profiles.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/just-safe-set-npm-4.1.1-d8056608a0-9.zip/node_modules/just-safe-set/index.mjs
init_define_process();
var objectSafeSet = set;
function set(obj, propsArg, value) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/config/profiles.js
var profiles = {
  server: {
    description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      config2.Swarm = {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      };
      return config2;
    }
  },
  "local-discovery": {
    description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
    transform: (config2) => {
      objectSafeSet(config2, "Discovery.MDNS.Enabled", true);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", true);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  test: {
    description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
      objectSafeSet(config2, "Addresses.Delegates", []);
      objectSafeSet(config2, "Bootstrap", []);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", false);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", false);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      });
      return config2;
    }
  },
  "default-networking": {
    description: "Restores default network settings. Inverse profile of the `test` profile.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      objectSafeSet(config2, "Addresses.API", defaultConfig.Addresses.API);
      objectSafeSet(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
      objectSafeSet(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
      objectSafeSet(config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
      objectSafeSet(config2, "Bootstrap", defaultConfig.Bootstrap);
      objectSafeSet(config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
      objectSafeSet(config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
      objectSafeSet(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  lowpower: {
    description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
    transform: (config2) => {
      const Swarm = config2.Swarm || {};
      const ConnMgr = Swarm.ConnMgr || {};
      ConnMgr.LowWater = 20;
      ConnMgr.HighWater = 40;
      Swarm.ConnMgr = ConnMgr;
      config2.Swarm = Swarm;
      return config2;
    }
  },
  "default-power": {
    description: 'Inverse of "lowpower" profile.',
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      config2.Swarm = defaultConfig.Swarm;
      return config2;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/config/index.js
var log17 = logger("ipfs:core:config");
function createConfig({ repo }) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get6),
    set: withTimeoutOption(set2),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get6(key, options) {
    if (!key) {
      return Promise.reject(new Error("key argument is required"));
    }
    return repo.config.get(key, options);
  }
  async function set2(key, value, options) {
    return repo.config.set(key, value, options);
  }
  async function replace(value, options) {
    return repo.config.replace(value, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const { dryRun } = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${profileName}' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return { original: oldCfg, updated: newCfg };
    } catch (err2) {
      log17(err2);
      throw new Error(`Could not apply profile '${profileName}' to config: ${err2.message}`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map((name6) => ({
    name: name6,
    description: profiles[name6].description
  }));
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/export.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/multiformats-npm-9.9.0-73ec9f8079-9.zip/node_modules/multiformats/esm/src/block.js
init_define_process();
var readonly = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links2 = function* (source, base) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path4 = [
      ...base,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path4,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links2(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path4.join("/"),
            cid
          ];
        } else {
          yield* links2(value, path4);
        }
      }
    }
  }
};
var tree = function* (source, base) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path4 = [
      ...base,
      key
    ];
    yield path4.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path4,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path4);
      }
    }
  }
};
var get2 = (source, path4) => {
  let node = source;
  for (const [index, key] of path4.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path4.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path4.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links2(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path4 = "/") {
    return get2(this.value, path4.split("/").filter(Boolean));
  }
};
var createUnsafe = ({
  bytes: bytes2,
  cid,
  value: maybeValue,
  codec
}) => {
  const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    cid,
    bytes: bytes2,
    value
  });
};

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/writer-browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/encoder.js
init_define_process();
var import_varint = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode4({
    version: 1,
    roots
  });
  const varintBytes = import_varint.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    async setRoots(roots) {
      const bytes2 = createHeader(roots);
      await writer.write(bytes2);
    },
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer.write(new Uint8Array(import_varint.default.encode(cid.bytes.length + bytes2.length)));
      await writer.write(cid.bytes);
      if (bytes2.length) {
        await writer.write(bytes2);
      }
    },
    async close() {
      await writer.end();
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/iterator-channel.js
init_define_process();
function noop() {
}
function create3() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve7) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve7();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve7) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve7(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer,
    iterator
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/decoder.js
init_define_process();
var import_varint2 = __toESM(require_varint(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/header-validator.js
init_define_process();
var Kinds = {
  Null: (obj) => obj === null,
  Int: (obj) => Number.isInteger(obj),
  Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
  String: (obj) => typeof obj === "string",
  Bool: (obj) => typeof obj === "boolean",
  Bytes: (obj) => obj instanceof Uint8Array,
  Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
  List: (obj) => Array.isArray(obj),
  Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
};
var Types = {
  Int: Kinds.Int,
  "CarHeader > version": (obj) => Types.Int(obj),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
  "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
  CarHeader: (obj) => {
    const keys = obj && Object.keys(obj);
    return Kinds.Map(obj) && ["version"].every((k) => keys.includes(k)) && Object.entries(obj).every(([name6, value]) => Types["CarHeader > " + name6] && Types["CarHeader > " + name6](value));
  }
};
var CarHeader = Types.CarHeader;

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/decoder.js
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
var V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
async function readVarint(reader2) {
  const bytes2 = await reader2.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i = import_varint2.default.decode(bytes2);
  reader2.seek(import_varint2.default.decode.bytes);
  return i;
}
async function readV2Header(reader2) {
  const bytes2 = await reader2.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader2.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader(reader2, strictVersion) {
  const length5 = await readVarint(reader2);
  if (length5 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length5);
  reader2.seek(length5);
  const block = decode5(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader2);
  reader2.seek(v2Header.dataOffset - reader2.pos);
  const v1Header = await readHeader(reader2, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader2) {
  const bytes2 = await reader2.upTo(8);
  import_varint2.default.decode(bytes2);
  const codeLength = import_varint2.default.decode.bytes;
  const length5 = import_varint2.default.decode(bytes2.subarray(import_varint2.default.decode.bytes));
  const lengthLength = import_varint2.default.decode.bytes;
  const mhLength = codeLength + lengthLength + length5;
  const multihash = await reader2.exactly(mhLength);
  reader2.seek(mhLength);
  return multihash;
}
async function readCid(reader2) {
  const first10 = await reader2.exactly(2);
  if (first10[0] === CIDV0_BYTES.SHA2_256 && first10[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader2.exactly(34);
    reader2.seek(34);
    const multihash2 = decode(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version3 = await readVarint(reader2);
  if (version3 !== 1) {
    throw new Error(`Unexpected CID version (${version3})`);
  }
  const codec = await readVarint(reader2);
  const bytes2 = await readMultihash(reader2);
  const multihash = decode(bytes2);
  return CID.create(version3, codec, multihash);
}
async function readBlockHead(reader2) {
  const start = reader2.pos;
  let length5 = await readVarint(reader2);
  if (length5 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length5 += reader2.pos - start;
  const cid = await readCid(reader2);
  const blockLength = length5 - Number(reader2.pos - start);
  return {
    cid,
    length: length5,
    blockLength
  };
}
async function readBlock(reader2) {
  const { cid, blockLength } = await readBlockHead(reader2);
  const bytes2 = await reader2.exactly(blockLength);
  reader2.seek(blockLength);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader2) {
  const offset = reader2.pos;
  const { cid, length: length5, blockLength } = await readBlockHead(reader2);
  const index = {
    cid,
    length: length5,
    blockLength,
    offset,
    blockOffset: reader2.pos
  };
  reader2.seek(index.blockLength);
  return index;
}
function createDecoder(reader2) {
  const headerPromise = (async () => {
    const header = await readHeader(reader2);
    if (header.version === 2) {
      const v1length = reader2.pos - header.dataOffset;
      reader2 = limitReader(reader2, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlock(reader2);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlockIndex(reader2);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length5) {
      return bytes2.subarray(pos, pos + Math.min(length5, bytes2.length - pos));
    },
    async exactly(length5) {
      if (length5 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length5);
    },
    seek(length5) {
      pos += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length5) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length5) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length5) {
      if (currentChunk.length - offset < length5) {
        await read2(length5);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length5));
    },
    async exactly(length5) {
      if (currentChunk.length - offset < length5) {
        await read2(length5);
      }
      if (currentChunk.length - offset < length5) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length5);
    },
    seek(length5) {
      pos += length5;
      offset += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader2, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length5) {
      let bytes2 = await reader2.upTo(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length5) {
      const bytes2 = await reader2.exactly(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length5) {
      bytesRead += length5;
      reader2.seek(length5);
    },
    get pos() {
      return reader2.pos;
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class {
  constructor(roots, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots);
    this._ended = false;
  }
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer = new CarWriter(roots, encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer = new CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots) {
    const reader2 = bytesReader(bytes2);
    await readHeader(reader2);
    const newHeader = createHeader(roots);
    if (Number(reader2.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create3();
  const { writer, iterator } = iw;
  const encoder2 = createEncoder(writer);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// ../../../../../Users/z/.yarn/berry/cache/multiformats-npm-9.9.0-73ec9f8079-9.zip/node_modules/multiformats/esm/src/traversal.js
init_define_process();
var walk = async ({ cid, load, seen }) => {
  seen = seen || /* @__PURE__ */ new Set();
  const b58Cid = cid.toString(base58btc);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await load(cid);
  seen.add(b58Cid);
  if (block === null) {
    return;
  }
  for (const [, cid2] of block.links()) {
    await walk({
      cid: cid2,
      load,
      seen
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/export.js
var log18 = logger("ipfs:components:dag:import");
var NO_LINKS_CODECS = [
  code,
  code2
];
function createExport({ repo, preload: preload2, codecs: codecs2 }) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload2(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${root}`);
    }
    log18(`Exporting ${cid} as car`);
    const { writer, out } = await CarWriter.create([cid]);
    let err2 = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs2);
        await walk({ cid, load });
      } catch (e) {
        err2 = e;
      } finally {
        writer.close();
      }
    })();
    for await (const chunk of out) {
      if (err2) {
        break;
      }
      yield chunk;
    }
    if (err2) {
      throw err2;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer, options, codecs2) {
  return async (cid) => {
    const codec = await codecs2.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);
    }
    const bytes2 = await repo.blocks.get(cid, options);
    log18(`Adding block ${cid} to car`);
    await writer.put({ cid, bytes: bytes2 });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({ bytes: bytes2, cid, codec });
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/get.js
init_define_process();
var import_it_first = __toESM(require_it_first(), 1);
var import_it_last5 = __toESM(require_it_last(), 1);
var import_err_code40 = __toESM(require_err_code(), 1);
function createGet3({ codecs: codecs2, repo, preload: preload2 }) {
  const get6 = async function get7(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    if (options.path) {
      const entry = options.localResolve ? await (0, import_it_first.default)(resolve(cid, options.path, codecs2, repo, options)) : await (0, import_it_last5.default)(resolve(cid, options.path, codecs2, repo, options));
      const result = entry;
      if (!result) {
        throw (0, import_err_code40.default)(new Error("Not found"), "ERR_NOT_FOUND");
      }
      return result;
    }
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    return {
      value: node,
      remainderPath: ""
    };
  };
  return withTimeoutOption(get6);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/import.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@ipld-car-npm-4.1.5-dbaedfeb48-9.zip/node_modules/@ipld/car/esm/lib/iterator.js
init_define_process();
var CarIteratorBase = class {
  constructor(version3, roots, iterable) {
    this._version = version3;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
};
var CarBlockIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(bytes2) {
    const { version: version3, roots, iterator } = await fromBytes(bytes2);
    return new CarBlockIterator(version3, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version3, roots, iterator);
  }
};
var CarCIDIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      async next() {
        const next = await iterable.next();
        if (next.done) {
          return next;
        }
        return {
          done: false,
          value: next.value.cid
        };
      }
    };
  }
  static async fromBytes(bytes2) {
    const { version: version3, roots, iterator } = await fromBytes(bytes2);
    return new CarCIDIterator(version3, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
    return new CarCIDIterator(version3, roots, iterator);
  }
};
async function fromBytes(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader2) {
  const decoder = createDecoder(reader2);
  const { version: version3, roots } = await decoder.header();
  return {
    version: version3,
    roots,
    iterator: decoder.blocks()
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/import.js
var import_it_peekable4 = __toESM(require_it_peekable(), 1);
var import_it_drain5 = __toESM(require_it_drain(), 1);
var import_it_map7 = __toESM(require_it_map(), 1);
var log19 = logger("ipfs:components:dag:import");
function createImport({ repo }) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = { signal: options.signal, timeout: options.timeout };
      const peekable = (0, import_it_peekable4.default)(sources);
      const { value, done } = await peekable.peek();
      if (done) {
        return;
      }
      if (value) {
        peekable.push(value);
      }
      let cars;
      if (value instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots) {
            let pinErrorMsg = "";
            try {
              if (await repo.blocks.has(cid)) {
                log19(`Pinning root ${cid}`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = "blockstore: block not found";
              }
            } catch (err2) {
              pinErrorMsg = err2.message;
            }
            yield { root: { cid, pinErrorMsg } };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(dagImport);
}
async function importCar(repo, options, source) {
  const reader2 = await CarBlockIterator.fromIterable(source);
  const roots = await reader2.getRoots();
  await (0, import_it_drain5.default)(
    repo.blocks.putMany(
      (0, import_it_map7.default)(reader2, ({ cid: key, bytes: value }) => {
        log19(`Import block ${key}`);
        return { key, value };
      }),
      { signal: options.signal }
    )
  );
  return roots;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/put.js
init_define_process();
function createPut2({ repo, codecs: codecs2, hashers, preload: preload2 }) {
  async function put(dagNode, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const storeCodec = await codecs2.getCodec(options.storeCodec || "dag-cbor");
      if (!storeCodec) {
        throw new Error(`Unknown storeCodec ${options.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      }
      if (options.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        const inputCodec = await codecs2.getCodec(options.inputCodec);
        if (!inputCodec) {
          throw new Error(`Unknown inputCodec ${options.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        }
        dagNode = inputCodec.decode(dagNode);
      }
      const cidVersion = options.version != null ? options.version : 1;
      const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
      if (!hasher) {
        throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      }
      const buf2 = storeCodec.encode(dagNode);
      const hash3 = await hasher.digest(buf2);
      const cid = CID.create(cidVersion, storeCodec.code, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.pin) {
        await repo.pins.pinRecursively(cid);
      }
      if (options.preload !== false) {
        preload2(cid);
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/resolve.js
init_define_process();
function createResolve3({ repo, codecs: codecs2, preload: preload2 }) {
  async function dagResolve(ipfsPath3, options = {}) {
    const {
      cid
    } = toCidAndPath(ipfsPath3);
    if (options.preload !== false) {
      preload2(cid);
    }
    return resolvePath(repo, codecs2, ipfsPath3, options);
  }
  return withTimeoutOption(dagResolve);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dag/index.js
var DagAPI = class {
  constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
    this.export = createExport({ repo, preload: preload2, codecs: codecs2 });
    this.get = createGet3({ codecs: codecs2, repo, preload: preload2 });
    this.import = createImport({ repo });
    this.resolve = createResolve3({ repo, codecs: codecs2, preload: preload2 });
    this.put = createPut2({ repo, codecs: codecs2, hashers, preload: preload2 });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/preload.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-multiaddr-to-uri-npm-9.0.2-bade01ef40-9.zip/node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
init_define_process();
var reduceValue = (_, v) => v;
var tcpUri = (str, port, parts, opts) => {
  if (opts != null && opts.assumeHttp === false)
    return `tcp://${str}:${port}`;
  let protocol = "tcp";
  let explicitPort = `:${port}`;
  const last14 = parts[parts.length - 1];
  if (last14.protocol === "tcp") {
    protocol = port === "443" ? "https" : "http";
    explicitPort = port === "443" || port === "80" ? "" : explicitPort;
  }
  return `${protocol}://${str}${explicitPort}`;
};
var Reducers = {
  ip4: reduceValue,
  ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
  tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
  udp: (str, content) => `udp://${str}:${content}`,
  dnsaddr: reduceValue,
  dns4: reduceValue,
  dns6: reduceValue,
  ipfs: (str, content) => `${str}/ipfs/${content}`,
  p2p: (str, content) => `${str}/p2p/${content}`,
  http: (str) => `http://${str}`,
  https: (str) => `https://${str}`,
  ws: (str) => `ws://${str}`,
  wss: (str) => `wss://${str}`,
  "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
  "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
  "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.toString().split("/").slice(1);
  return ma.tuples().map((tuple) => ({
    protocol: parts.shift() ?? "",
    content: tuple[1] != null ? parts.shift() ?? "" : ""
  })).reduce((str, part, i, parts2) => {
    const reduce2 = Reducers[part.protocol];
    if (reduce2 == null) {
      throw new Error(`Unsupported protocol ${part.protocol}`);
    }
    return reduce2(str, part.content, i, parts2, opts);
  }, "");
}

// ../../../../../Users/z/.yarn/berry/cache/array-shuffle-npm-3.0.0-23d2aa76ef-9.zip/node_modules/array-shuffle/index.js
init_define_process();
function arrayShuffle(array) {
  if (!Array.isArray(array)) {
    throw new TypeError(`Expected an array, got ${typeof array}`);
  }
  array = [...array];
  for (let index = array.length - 1; index > 0; index--) {
    const newIndex = Math.floor(Math.random() * (index + 1));
    [array[index], array[newIndex]] = [array[newIndex], array[index]];
  }
  return array;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/preload.browser.js
init_define_process();
var import_http2 = __toESM(require_http(), 1);
var log20 = logger("ipfs:preload");
var Queue2 = PQueue.default ? PQueue.default : PQueue;
var httpQueue2 = new Queue2({ concurrency: 4 });
function preload(url, options = {}) {
  log20(url);
  return httpQueue2.add(async () => {
    const res = await import_http2.default.post(url, { signal: options.signal });
    const reader2 = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader2.read();
        if (done)
          return;
      }
    } finally {
      reader2.releaseLock();
    }
  });
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/preload.js
var import_hashlru3 = __toESM(require_hashlru(), 1);
var log21 = logger("ipfs:preload");
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1e3;
  if (!options.enabled || !options.addresses.length) {
    log21("preload disabled");
    const api2 = () => {
    };
    return Object.assign(api2, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map((str) => multiaddrToUri(str));
  const cache3 = (0, import_hashlru3.default)(options.cache);
  const api = async (cid) => {
    try {
      if (stopped) {
        throw new Error(`preload ${cid} but preloader is not started`);
      }
      const path4 = cid.toString();
      if (cache3.has(path4)) {
        return;
      }
      cache3.set(path4, true);
      const fallbackApiUris = arrayShuffle(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${path4}`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path4)}`, { signal: controller.signal });
          success = true;
        } catch (err2) {
          if (err2.type !== "aborted")
            log21.error(err2);
        } finally {
          requests = requests.filter((r) => r !== controller);
        }
        if (success)
          break;
      }
      log21(`${success ? "" : "un"}successfully preloaded ${path4} in ${Date.now() - now}ms`);
    } catch (err2) {
      log21.error(err2);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log21(`aborting ${requests.length} pending preload request(s)`);
    requests.forEach((r) => r.abort());
    requests = [];
  };
  return api;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/mfs-preload.js
init_define_process();
var log22 = logger("ipfs:mfs-preload");
function createMfsPreloader({ preload: preload2, files, options = {} }) {
  options.interval = options.interval || 30 * 1e3;
  if (!options.enabled) {
    log22("MFS preload disabled");
    const noop3 = async () => {
    };
    return { start: noop3, stop: noop3 };
  }
  let rootCid = "";
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat("/");
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log22(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
        await preload2(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err2) {
      log22.error("failed to preload MFS root", err2);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    async start() {
      const stats = await files.stat("/");
      rootCid = stats.cid.toString();
      log22(`monitoring MFS root ${stats.cid}`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    stop() {
      clearTimeout(timeoutId);
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/create-lock.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/mortice-npm-3.0.1-4cb9965a5c-9.zip/node_modules/mortice/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/p-timeout-npm-6.0.0-0f6cef4d38-9.zip/node_modules/p-timeout/index.js
init_define_process();
var TimeoutError3 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError2 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout2(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve7, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve7(promise);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve7(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const errorMessage = typeof message2 === "string" ? message2 : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = message2 instanceof Error ? message2 : new TimeoutError3(errorMessage);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve7(await promise);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// ../../../../../Users/z/.yarn/berry/cache/mortice-npm-3.0.1-4cb9965a5c-9.zip/node_modules/mortice/dist/src/browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-4.0.0-924f5c6312-9.zip/node_modules/nanoid/index.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-4.0.0-924f5c6312-9.zip/node_modules/nanoid/url-alphabet/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/nanoid-npm-4.0.0-924f5c6312-9.zip/node_modules/nanoid/index.browser.js
var nanoid2 = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// ../../../../../Users/z/.yarn/berry/cache/mortice-npm-3.0.1-4cb9965a5c-9.zip/node_modules/mortice/dist/src/constants.js
init_define_process();
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// ../../../../../Users/z/.yarn/berry/cache/observable-webworkers-npm-2.0.1-27ff024cfa-9.zip/node_modules/observable-webworkers/dist/src/index.js
init_define_process();
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default = observable;

// ../../../../../Users/z/.yarn/berry/cache/mortice-npm-3.0.1-4cb9965a5c-9.zip/node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve7) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve7();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name6, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid2();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name6
    });
    return await new Promise((resolve7) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve7(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name6
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions2 = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions2, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name6) => makeWorkerLockRequest(name6, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name6) => makeWorkerLockRequest(name6, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// ../../../../../Users/z/.yarn/berry/cache/mortice-npm-3.0.1-4cb9965a5c-9.zip/node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve7) => {
    res = resolve7;
  });
  void queue.add(async () => await pTimeout2((async () => {
    return await new Promise((resolve7) => {
      res(() => {
        resolve7();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name6, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name6, options),
      writeLock: implementation.writeLock(name6, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions3 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions3, options);
  if (implementation == null) {
    implementation = browser_default(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/create-lock.js
var lock;
function createLock(repoOwner = false) {
  if (lock) {
    return lock;
  }
  const mutex = createMortice({
    singleProcess: repoOwner
  });
  lock = {
    readLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.readLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    },
    writeLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.writeLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    }
  };
  return lock;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/stat.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/with-mfs-root.js
init_define_process();
var import_err_code41 = __toESM(require_err_code(), 1);
var log23 = logger("ipfs:mfs:utils:with-mfs-root");
async function loadMfsRoot(context, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code41.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  await context.repo.datastore.open();
  let cid;
  try {
    const buf2 = await context.repo.datastore.get(MFS_ROOT_KEY);
    cid = CID.decode(buf2);
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
    log23("Creating new MFS root");
    const buf2 = encode2({
      Data: new UnixFS({ type: "directory" }).marshal(),
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    cid = CID.createV0(hash3);
    await context.repo.blocks.put(cid, buf2);
    if (options && options.signal && options.signal.aborted) {
      throw (0, import_err_code41.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
    }
    await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  }
  log23(`Loaded MFS root /ipfs/${cid}`);
  return cid;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/to-path-components.js
init_define_process();
function toPathComponents3(path4 = "") {
  return (path4.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js
var import_err_code42 = __toESM(require_err_code(), 1);
var IPFS_PREFIX2 = "ipfs";
var toMfsPath = async (context, path4, options) => {
  const root = await loadMfsRoot(context, options);
  let output = {
    entryType: "file"
  };
  let ipfsPath3 = "";
  if (CID.asCID(path4)) {
    ipfsPath3 = `/ipfs/${path4}`;
  } else {
    ipfsPath3 = path4.toString();
  }
  ipfsPath3 = ipfsPath3.trim();
  ipfsPath3 = ipfsPath3.replace(/(\/\/+)/g, "/");
  if (ipfsPath3.endsWith("/") && ipfsPath3.length > 1) {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  if (!ipfsPath3) {
    throw (0, import_err_code42.default)(new Error("paths must not be empty"), "ERR_NO_PATH");
  }
  if (ipfsPath3.substring(0, 1) !== "/") {
    throw (0, import_err_code42.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (ipfsPath3.substring(ipfsPath3.length - 1) === "/") {
    ipfsPath3 = ipfsPath3.substring(0, ipfsPath3.length - 1);
  }
  const pathComponents = toPathComponents3(ipfsPath3);
  if (pathComponents[0] === IPFS_PREFIX2) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${pathComponents.join("/")}`;
    } else {
      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    }
    output = {
      type: "ipfs",
      depth: pathComponents.length - 2,
      entryType: "file",
      mfsPath: `/${pathComponents.join("/")}`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${IPFS_PREFIX2}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
    const mfsDirectory = `/${IPFS_PREFIX2}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    output = {
      type: "mfs",
      depth: pathComponents.length,
      entryType: "file",
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
  try {
    const res = await exporter(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${res.path}`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
      output.unixfs = res.unixfs;
    }
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/stat.js
var import_err_code43 = __toESM(require_err_code(), 1);
var mergeOptions4 = merge_options_default.bind({ ignoreUndefined: true });
var log24 = logger("ipfs:mfs:stat");
var defaultOptions4 = {
  withLocal: false
};
function createStat3(context) {
  async function mfsStat(path4, options = {}) {
    options = mergeOptions4(defaultOptions4, options);
    log24(`Fetching stats for ${path4}`);
    const {
      type,
      cid,
      mfsPath
    } = await toMfsPath(context, path4, options);
    const exportPath = type === "ipfs" && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter(exportPath, context.repo.blocks);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code43.default)(new Error(`${path4} does not exist`), "ERR_NOT_FOUND");
      }
      throw err2;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${file.cid.code}`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
var statters = {
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  file: (file) => {
    const stat = {
      cid: file.cid,
      type: "file",
      size: file.unixfs.fileSize(),
      cumulativeSize: encode2(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: (file) => {
    const stat = {
      cid: file.cid,
      type: "directory",
      size: 0,
      cumulativeSize: encode2(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: "file",
      blocks: 0,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  identity: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/chmod.js
init_define_process();
var import_err_code50 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/to-trail.js
init_define_process();
var log25 = logger("ipfs:mfs:utils:to-trail");
async function toTrail(context, path4) {
  log25(`Creating trail for path ${path4}`);
  const output = [];
  for await (const fsEntry of walkPath(path4, context.repo.blocks)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.size,
      type: fsEntry.type
    });
  }
  return output;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/add-link.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/dir-sharded.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/persist.js
init_define_process();
var persist2 = async (buffer2, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer2, {
      signal: options.signal
    });
  }
  return cid;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/hamt-constants.js
init_define_process();
var hamtHashCode = murmur3128.code;
var hamtBucketBits = 8;
async function hamtHashFn2(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/dir-sharded.js
var Dir2 = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name6, value) {
  }
  get(name6) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var DirSharded2 = class extends Dir2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = createHAMT({
      hashFn: hamtHashFn2,
      bits: hamtBucketBits
    });
  }
  async put(name6, value) {
    await this._bucket.put(name6, value);
  }
  get(name6) {
    return this._bucket.get(name6);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    yield* flush2(this._bucket, blockstore, this, this.options);
  }
};
async function* flush2(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (!child) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of await flush2(child, blockstore, null, options)) {
        shard = subShard;
      }
      if (!shard) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard.size,
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer2 = encode2(prepare(node));
  const cid = await persist2(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    node,
    size
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/hamt-utils.js
init_define_process();
var import_it_last6 = __toESM(require_it_last(), 1);
var log26 = logger("ipfs:mfs:core:utils:hamt-utils");
var updateHamtDirectory = async (context, links3, bucket, options) => {
  if (!options.parent.Data) {
    throw new Error("Could not update HAMT directory because parent had no data");
  }
  const data = Uint8Array.from(bucket._children.bitField().reverse());
  const node = UnixFS.unmarshal(options.parent.Data);
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mode: node.mode,
    mtime: node.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const parent2 = {
    Data: dir.marshal(),
    Links: links3.sort((a, b) => (a.Name || "").localeCompare(b.Name || ""))
  };
  const buf2 = encode2(parent2);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code3, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: parent2,
    cid,
    size: links3.reduce((sum, link) => sum + (link.Tsize || 0), buf2.length)
  };
};
var recreateHamtLevel = async (context, links3, rootBucket, parentBucket, positionAtParent) => {
  const bucket = new Bucket({
    hash: rootBucket._options.hash,
    bits: rootBucket._options.bits
  }, parentBucket, positionAtParent);
  parentBucket._putObjectAt(positionAtParent, bucket);
  await addLinksToHamtBucket2(context, links3, bucket, rootBucket);
  return bucket;
};
var recreateInitialHamtLevel = async (links3) => {
  const bucket = createHAMT({
    hashFn: hamtHashFn2,
    bits: hamtBucketBits
  });
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        const pos = parseInt(linkName, 16);
        const subBucket = new Bucket({
          hash: bucket._options.hash,
          bits: bucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        return Promise.resolve();
      }
      return bucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
  return bucket;
};
var addLinksToHamtBucket2 = async (context, links3, bucket, rootBucket) => {
  await Promise.all(
    links3.map(async (link) => {
      const linkName = link.Name || "";
      if (linkName.length === 2) {
        log26("Populating sub bucket", linkName);
        const pos = parseInt(linkName, 16);
        const block = await context.repo.blocks.get(link.Hash);
        const node = decode3(block);
        const subBucket = new Bucket({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos);
        bucket._putObjectAt(pos, subBucket);
        await addLinksToHamtBucket2(context, node.Links, subBucket, rootBucket);
        return Promise.resolve();
      }
      return rootBucket.put(linkName.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    })
  );
};
var toPrefix2 = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var generatePath = async (context, fileName, rootNode) => {
  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
  const position = await rootBucket._findNewBucketAndPos(fileName);
  const path4 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let currentBucket = position.bucket;
  while (currentBucket !== rootBucket) {
    path4.push({
      bucket: currentBucket,
      prefix: toPrefix2(currentBucket._posAtParent)
    });
    currentBucket = currentBucket._parent;
  }
  path4.reverse();
  path4[0].node = rootNode;
  for (let i = 0; i < path4.length; i++) {
    const segment = path4[i];
    if (!segment.node) {
      throw new Error("Could not generate HAMT path");
    }
    const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
    if (!link) {
      log26(`Link ${segment.prefix}${fileName} will be added`);
      continue;
    }
    if (link.Name === `${segment.prefix}${fileName}`) {
      log26(`Link ${segment.prefix}${fileName} will be replaced`);
      continue;
    }
    log26(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const node = decode3(block);
    if (!path4[i + 1]) {
      log26(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(fileName);
      path4.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node
      });
      continue;
    }
    const nextSegment = path4[i + 1];
    await addLinksToHamtBucket2(context, node.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = node;
  }
  await rootBucket.put(fileName, true);
  path4.reverse();
  return {
    rootBucket,
    path: path4
  };
};
var createShard = async (context, contents, options = {}) => {
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options.mtime,
    mode: options.mode
  }, options);
  for (let i = 0; i < contents.length; i++) {
    await shard._bucket.put(contents[i].name, {
      size: contents[i].size,
      cid: contents[i].cid
    });
  }
  const res = await (0, import_it_last6.default)(shard.flush(context.repo.blocks));
  if (!res) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/add-link.js
var import_err_code44 = __toESM(require_err_code(), 1);
var import_it_last7 = __toESM(require_it_last(), 1);
var log27 = logger("ipfs:mfs:core:utils:add-link");
async function addLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code44.default)(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (parentCid.code !== code3) {
      throw (0, import_err_code44.default)(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
    }
    log27(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode3(block);
  }
  if (!parent2) {
    throw (0, import_err_code44.default)(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
  }
  if (!options.cid) {
    throw (0, import_err_code44.default)(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
  }
  if (!options.name) {
    throw (0, import_err_code44.default)(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
  }
  if (!options.size && options.size !== 0) {
    throw (0, import_err_code44.default)(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
  }
  if (!parent2.Data) {
    throw (0, import_err_code44.default)(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log27("Adding link to sharded directory");
    return addToShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  if (parent2.Links.length >= options.shardSplitThreshold) {
    log27("Converting directory to sharded directory");
    return convertToShardedDirectory(context, {
      ...options,
      parent: parent2,
      mtime: meta.mtime,
      mode: meta.mode
    });
  }
  log27(`Adding ${options.name} (${options.cid}) to regular directory`);
  return addToDirectory(context, {
    ...options,
    parent: parent2
  });
}
var convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map((link) => ({
    name: link.Name || "",
    size: link.Tsize || 0,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options);
  log27(`Converted directory to sharded directory ${result.cid}`);
  return result;
};
var addToDirectory = async (context, options) => {
  const parentLinks = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  parentLinks.push({
    Name: options.name,
    Tsize: options.size,
    Hash: options.cid
  });
  if (!options.parent.Data) {
    throw (0, import_err_code44.default)(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
  }
  const node = UnixFS.unmarshal(options.parent.Data);
  let data;
  if (node.mtime) {
    const ms = Date.now();
    const secs = Math.floor(ms / 1e3);
    node.mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
    data = node.marshal();
  } else {
    data = options.parent.Data;
  }
  options.parent = prepare({
    Data: data,
    Links: parentLinks
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const buf2 = encode2(options.parent);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code3, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    node: options.parent,
    cid,
    size: buf2.length
  };
};
var addToShardedDirectory = async (context, options) => {
  const {
    shard,
    path: path4
  } = await addFileToShardedDirectory(context, options);
  const result = await (0, import_it_last7.default)(shard.flush(context.repo.blocks));
  if (!result) {
    throw new Error("No result from flushing shard");
  }
  const block = await context.repo.blocks.get(result.cid);
  const node = decode3(block);
  const parentLinks = options.parent.Links.filter((link) => {
    return (link.Name || "").substring(0, 2) !== path4[0].prefix;
  });
  const newLink = node.Links.find((link) => (link.Name || "").substring(0, 2) === path4[0].prefix);
  if (!newLink) {
    throw new Error(`No link found with prefix ${path4[0].prefix}`);
  }
  parentLinks.push(newLink);
  return updateHamtDirectory(context, parentLinks, path4[0].bucket, options);
};
var addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  };
  if (!options.parent.Data) {
    throw (0, import_err_code44.default)(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
  }
  const rootBucket = await recreateInitialHamtLevel(options.parent.Links);
  const node = UnixFS.unmarshal(options.parent.Data);
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mode: node.mode
  }, options);
  shard._bucket = rootBucket;
  if (node.mtime) {
    shard.mtime = {
      secs: Math.round(Date.now() / 1e3)
    };
  }
  const position = await rootBucket._findNewBucketAndPos(file.name);
  const path4 = toBucketPath2(position);
  path4[0].node = options.parent;
  let index = 0;
  while (index < path4.length) {
    const segment = path4[index];
    index++;
    const node2 = segment.node;
    if (!node2) {
      throw new Error("Segment had no node");
    }
    const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
    if (!link) {
      log27(`Link ${segment.prefix}${file.name} will be added`);
      index = path4.length;
      break;
    }
    if (link.Name === `${segment.prefix}${file.name}`) {
      log27(`Link ${segment.prefix}${file.name} will be replaced`);
      index = path4.length;
      break;
    }
    if ((link.Name || "").length > 2) {
      log27(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
      index = path4.length;
      break;
    }
    log27(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const subShard = decode3(block);
    if (!path4[index]) {
      log27(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(file.name);
      path4.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node: subShard
      });
      break;
    }
    const nextSegment = path4[index];
    await addLinksToHamtBucket2(context, subShard.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = subShard;
  }
  await shard._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  });
  return {
    shard,
    path: path4
  };
};
var toBucketPath2 = (position) => {
  const path4 = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let bucket = position.bucket._parent;
  let positionInBucket = position.bucket._posAtParent;
  while (bucket) {
    path4.push({
      bucket,
      prefix: toPrefix2(positionInBucket)
    });
    positionInBucket = bucket._posAtParent;
    bucket = bucket._parent;
  }
  path4.reverse();
  return path4;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/update-tree.js
init_define_process();
var log28 = logger("ipfs:mfs:utils:update-tree");
var defaultOptions5 = {
  shardSplitThreshold: 1e3
};
async function updateTree(context, trail, options) {
  options = Object.assign({}, defaultOptions5, options);
  log28("Trail", trail);
  trail = trail.slice().reverse();
  let index = 0;
  let child;
  for await (const block of context.repo.blocks.getMany(trail.map((node) => node.cid))) {
    const node = decode3(block);
    const cid2 = trail[index].cid;
    const name6 = trail[index].name;
    index++;
    if (!child) {
      child = {
        cid: cid2,
        name: name6,
        size: block.length
      };
      continue;
    }
    const result = await addLink(context, {
      parent: node,
      name: child.name,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    child = {
      cid: result.cid,
      name: name6,
      size: result.size
    };
  }
  const { cid } = child;
  log28(`Final CID ${cid}`);
  return cid;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/update-mfs-root.js
init_define_process();
var import_err_code45 = __toESM(require_err_code(), 1);
var log29 = logger("ipfs:mfs:utils:update-mfs-root");
async function updateMfsRoot(context, cid, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code45.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  log29(`New MFS root will be ${cid}`);
  await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  return cid;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/chmod.js
var import_it_last8 = __toESM(require_it_last(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/cp.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/mkdir.js
init_define_process();
var import_err_code46 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/create-node.js
init_define_process();
async function createNode2(context, type, options) {
  const metadata = new UnixFS({
    type,
    mode: options.mode,
    mtime: options.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const node = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf2 = encode2(node);
  const hash3 = await hasher.digest(buf2);
  const cid = CID.create(options.cidVersion, code3, hash3);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf2);
  }
  return {
    cid,
    node
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/mkdir.js
var mergeOptions5 = merge_options_default.bind({ ignoreUndefined: true });
var log30 = logger("ipfs:mfs:mkdir");
var defaultOptions6 = {
  parents: false,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3,
  flush: true
};
function createMkdir(context) {
  async function mfsMkdir(path4, options = {}) {
    const opts = mergeOptions5(defaultOptions6, options);
    if (!path4) {
      throw new Error("no path given to Mkdir");
    }
    path4 = path4.trim();
    if (path4 === "/") {
      if (opts.parents) {
        return;
      }
      throw (0, import_err_code46.default)(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
    }
    if (path4.substring(0, 1) !== "/") {
      throw (0, import_err_code46.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    log30(`Creating ${path4}`);
    const pathComponents = toPathComponents3(path4);
    if (pathComponents[0] === "ipfs") {
      throw (0, import_err_code46.default)(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
    }
    const root = await loadMfsRoot(context, opts);
    let parent2;
    const trail = [];
    const emptyDir = await createNode2(context, "directory", opts);
    for (let i = 0; i <= pathComponents.length; i++) {
      const subPathComponents = pathComponents.slice(0, i);
      const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
      try {
        parent2 = await exporter(subPath, context.repo.blocks);
        if (parent2.type !== "file" && parent2.type !== "directory") {
          throw (0, import_err_code46.default)(new Error(`${path4} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (i === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw (0, import_err_code46.default)(new Error("file already exists"), "ERR_ALREADY_EXISTS");
        }
        trail.push({
          name: parent2.name,
          cid: parent2.cid
        });
      } catch (err2) {
        if (err2.code === "ERR_NOT_FOUND") {
          if (i < pathComponents.length && !opts.parents) {
            throw (0, import_err_code46.default)(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err2;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
var addEmptyDir = async (context, childName, emptyDir, parent2, trail, options) => {
  log30(`Adding empty dir called ${childName} to ${parent2.cid}`);
  const result = await addLink(context, {
    parent: parent2.node,
    parentCid: parent2.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/cp.js
var import_err_code47 = __toESM(require_err_code(), 1);
var mergeOptions6 = merge_options_default.bind({ ignoreUndefined: true });
var log31 = logger("ipfs:mfs:cp");
var defaultOptions7 = {
  parents: false,
  flush: true,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3
};
function createCp(context) {
  async function mfsCp(from2, to, opts = {}) {
    const options = mergeOptions6(defaultOptions7, opts);
    if (!Array.isArray(from2)) {
      from2 = [from2];
    }
    const sources = await Promise.all(
      from2.map((path4) => toMfsPath(context, path4, options))
    );
    let destination = await toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw (0, import_err_code47.default)(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
    }
    const missing = sources.find((source) => !source.exists);
    if (missing) {
      throw (0, import_err_code47.default)(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log31("Destination exists");
      if (sources.length === 1 && !destinationIsDirectory) {
        throw (0, import_err_code47.default)(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
      }
    } else {
      log31("Destination does not exist");
      if (sources.length > 1) {
        if (!options.parents) {
          throw (0, import_err_code47.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
        }
        await createMkdir(context)(destination.path, options);
        destination = await toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
        try {
          await createStat3(context)(parentFolder, options);
        } catch (err2) {
          if (err2.code !== "ERR_NOT_FOUND") {
            throw err2;
          }
          if (!options.parents) {
            throw (0, import_err_code47.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await createMkdir(context)(parentFolder, options);
          destination = await toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source = sources.pop();
      if (!source) {
        throw (0, import_err_code47.default)(new Error("could not find source"), "ERR_INVALID_PARAMS");
      }
      const destinationName = destinationIsDirectory ? source.name : destination.name;
      log31(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
      return copyToFile(context, source, destinationName, trail, options);
    }
    log31("Multiple sources, wrapping in a directory");
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption(mfsCp);
}
var isDirectory = (destination) => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
};
var copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent2 = destinationTrail.pop();
  if (!parent2) {
    throw (0, import_err_code47.default)(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
  }
  parent2 = await addSourceToParent(context, source, destination, parent2, options);
  destinationTrail.push(parent2);
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    destination = await addSourceToParent(context, source, source.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var addSourceToParent = async (context, source, childName, parent2, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid);
  const {
    node,
    cid,
    size
  } = await addLink(context, {
    parentCid: parent2.cid,
    size: sourceBlock.length,
    cid: source.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.node = node;
  parent2.cid = cid;
  parent2.size = size;
  return parent2;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/rm.js
init_define_process();
var import_err_code49 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/remove-link.js
init_define_process();
var import_err_code48 = __toESM(require_err_code(), 1);
var log32 = logger("ipfs:mfs:core:utils:remove-link");
async function removeLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code48.default)(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    log32(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode3(block);
  }
  if (!parent2) {
    throw (0, import_err_code48.default)(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
  }
  if (!options.name) {
    throw (0, import_err_code48.default)(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
  }
  if (!parent2.Data) {
    throw (0, import_err_code48.default)(new Error("Parent node had no data"), "ERR_INVALID_NODE");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log32(`Removing ${options.name} from sharded directory`);
    return removeFromShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  log32(`Removing link ${options.name} regular directory`);
  return removeFromDirectory(context, {
    ...options,
    parent: parent2
  });
}
var removeFromDirectory = async (context, options) => {
  options.parent.Links = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  const parentBlock = await encode2(options.parent);
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const hash3 = await hasher.digest(parentBlock);
  const parentCid = CID.create(options.cidVersion, code3, hash3);
  await context.repo.blocks.put(parentCid, parentBlock);
  log32(`Updated regular directory ${parentCid}`);
  return {
    node: options.parent,
    cid: parentCid
  };
};
var removeFromShardedDirectory = async (context, options) => {
  const {
    rootBucket,
    path: path4
  } = await generatePath(context, options.name, options.parent);
  await rootBucket.del(options.name);
  const {
    node
  } = await updateShard(context, path4, options.name, options);
  return updateHamtDirectory(context, node.Links, rootBucket, options);
};
var updateShard = async (context, positions, name6, options) => {
  const last14 = positions.pop();
  if (!last14) {
    throw (0, import_err_code48.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const {
    bucket,
    prefix,
    node
  } = last14;
  if (!node) {
    throw (0, import_err_code48.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const link = node.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
  if (!link) {
    throw (0, import_err_code48.default)(new Error(`No link found with prefix ${prefix} for file ${name6}`), "ERR_NOT_FOUND");
  }
  if (link.Name === `${prefix}${name6}`) {
    log32(`Removing existing link ${link.Name}`);
    const links3 = node.Links.filter((nodeLink) => {
      return nodeLink.Name !== link.Name;
    });
    await bucket.del(name6);
    return updateHamtDirectory(context, links3, bucket, options);
  }
  log32(`Descending into sub-shard ${link.Name} for ${prefix}${name6}`);
  const result = await updateShard(context, positions, name6, options);
  let cid = result.cid;
  let size = result.size;
  let newName = prefix;
  if (result.node.Links.length === 1) {
    log32(`Removing subshard for ${prefix}`);
    const link2 = result.node.Links[0];
    newName = `${prefix}${(link2.Name || "").substring(2)}`;
    cid = link2.Hash;
    size = link2.Tsize || 0;
  }
  log32(`Updating shard ${prefix} with name ${newName}`);
  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);
};
var updateShardParent = (context, bucket, parent2, oldName, newName, size, cid, options) => {
  const parentLinks = parent2.Links.filter((link) => {
    return link.Name !== oldName;
  });
  parentLinks.push({
    Name: newName,
    Tsize: size,
    Hash: cid
  });
  return updateHamtDirectory(context, parentLinks, bucket, options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/rm.js
var mergeOptions7 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions8 = {
  recursive: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  flush: true,
  shardSplitThreshold: 1e3
};
function createRm4(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions7(defaultOptions8, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(
      paths.map((path4) => toMfsPath(context, path4, options))
    );
    if (!sources.length) {
      throw (0, import_err_code49.default)(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
    }
    sources.forEach((source) => {
      if (source.path === "/") {
        throw (0, import_err_code49.default)(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
      }
    });
    for (const source of sources) {
      await removePath(context, source.path, options);
    }
  }
  return withTimeoutOption(mfsRm);
}
var removePath = async (context, path4, options) => {
  const mfsPath = await toMfsPath(context, path4, options);
  const trail = await toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent2 = trail[trail.length - 1];
  if (!parent2) {
    throw (0, import_err_code49.default)(new Error(`${path4} does not exist`), "ERR_NOT_FOUND");
  }
  if (child.type === "directory" && !options.recursive) {
    throw (0, import_err_code49.default)(new Error(`${path4} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
  }
  const {
    cid
  } = await removeLink(context, {
    parentCid: parent2.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.cid = cid;
  const newRootCid = await updateTree(context, trail, options);
  await updateMfsRoot(context, newRootCid, options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/chmod.js
var mergeOptions8 = merge_options_default.bind({ ignoreUndefined: true });
var log33 = logger("ipfs:mfs:touch");
var defaultOptions9 = {
  flush: true,
  shardSplitThreshold: 1e3,
  hashAlg: "sha2-256",
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory2) {
  let modification = 0;
  if (mode.includes("x") || mode.includes("X") && (isDirectory2 || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes("w")) {
    modification += 2;
  }
  if (mode.includes("r")) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes("u")) {
    ugo += modification << 6;
  }
  if (references.includes("g")) {
    ugo += modification << 3;
  }
  if (references.includes("o")) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes("t")) {
    modification += parseInt("1000", 8);
  }
  if (mode.includes("s")) {
    if (references.includes("u")) {
      modification += parseInt("4000", 8);
    }
    if (references.includes("g")) {
      modification += parseInt("2000", 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory2) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${input}`);
  }
  let [
    ,
    references,
    operator,
    mode
  ] = match;
  if (references === "a" || !references) {
    references = "ugo";
  }
  let modification = calculateModification(mode, originalMode, isDirectory2);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === "=") {
    if (references.includes("u")) {
      originalMode = originalMode & parseInt("7077", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("g")) {
      originalMode = originalMode & parseInt("7707", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("o")) {
      originalMode = originalMode & parseInt("7770", 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === "+") {
    return modification | originalMode;
  }
  if (operator === "-") {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === "string") {
    const strMode = `${mode}`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(",").reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod(context) {
  async function mfsChmod(path4, mode, options = {}) {
    const opts = mergeOptions8(defaultOptions9, options);
    log33(`Fetching stats for ${path4}`);
    const {
      cid,
      mfsDirectory,
      name: name6
    } = await toMfsPath(context, path4, opts);
    if (cid.code !== code3) {
      throw (0, import_err_code50.default)(new Error(`${path4} was not a UnixFS node`), "ERR_NOT_UNIXFS");
    }
    if (opts.recursive) {
      const root = await pipe(
        async function* () {
          for await (const entry of recursive(cid, context.repo.blocks)) {
            if (entry.type !== "file" && entry.type !== "directory") {
              throw (0, import_err_code50.default)(new Error(`${path4} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            }
            entry.unixfs.mode = calculateMode(mode, entry.unixfs);
            const node2 = prepare({
              Data: entry.unixfs.marshal(),
              Links: entry.node.Links
            });
            yield {
              path: entry.path,
              content: node2
            };
          }
        },
        (source) => importer(source, context.repo.blocks, {
          ...opts,
          pin: false,
          dagBuilder: async function* (source2, block2, opts2) {
            for await (const entry of source2) {
              yield async function() {
                const node2 = entry.content;
                const buf2 = encode2(node2);
                const cid2 = await persist2(buf2, block2, opts2);
                if (!node2.Data) {
                  throw (0, import_err_code50.default)(new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
                }
                const unixfs = UnixFS.unmarshal(node2.Data);
                return {
                  cid: cid2,
                  size: buf2.length,
                  path: entry.path,
                  unixfs
                };
              };
            }
          }
        }),
        (nodes) => (0, import_it_last8.default)(nodes)
      );
      if (!root) {
        throw (0, import_err_code50.default)(new Error(`Could not chmod ${path4}`), "ERR_COULD_NOT_CHMOD");
      }
      await createRm4(context)(path4, opts);
      await createCp(context)(`/ipfs/${root.cid}`, path4, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid);
    const node = decode3(block);
    if (!node.Data) {
      throw (0, import_err_code50.default)(new Error(`${cid} had no data`), "ERR_INVALID_NODE");
    }
    const metadata = UnixFS.unmarshal(node.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = encode2({
      Data: metadata.marshal(),
      Links: node.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions9.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash3 = await hasher.digest(updatedBlock);
    const updatedCid = CID.create(opts.cidVersion, code3, hash3);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = CID.decode(parent2.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode3(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name6,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      hashAlg,
      cidVersion: cid.version,
      shardSplitThreshold: Infinity
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsChmod);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/flush.js
init_define_process();
var mergeOptions9 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions10 = {};
function createFlush(context) {
  async function mfsFlush(path4, options = {}) {
    options = mergeOptions9(defaultOptions10, options);
    const { cid } = await createStat3(context)(path4, options);
    return cid;
  }
  return withTimeoutOption(mfsFlush);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/mv.js
init_define_process();
var mergeOptions10 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions11 = {
  parents: false,
  flush: true,
  cidVersion: 0,
  hashAlg: "sha2-256",
  shardSplitThreshold: 1e3
};
function createMv(context) {
  async function mfsMv(from2, to, options = {}) {
    const opts = mergeOptions10(defaultOptions11, options);
    await createCp(context)(from2, to, opts);
    await createRm4(context)(from2, {
      ...opts,
      recursive: true
    });
  }
  return withTimeoutOption(mfsMv);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/touch.js
init_define_process();
var import_err_code51 = __toESM(require_err_code(), 1);
var mergeOptions11 = merge_options_default.bind({ ignoreUndefined: true });
var log34 = logger("ipfs:mfs:touch");
var defaultOptions12 = {
  flush: true,
  shardSplitThreshold: 1e3,
  cidVersion: 0,
  hashAlg: "sha2-256"
};
function createTouch(context) {
  async function mfsTouch(path4, options = {}) {
    const settings = mergeOptions11(defaultOptions12, options);
    settings.mtime = settings.mtime || new Date();
    log34(`Touching ${path4} mtime: ${settings.mtime}`);
    const {
      cid,
      mfsDirectory,
      name: name6,
      exists: exists2
    } = await toMfsPath(context, path4, settings);
    const hashAlg = options.hashAlg || defaultOptions12.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists2) {
      const metadata = new UnixFS({
        type: "file",
        mtime: settings.mtime
      });
      updatedBlock = encode2({ Data: metadata.marshal(), Links: [] });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code3, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid.code !== code3) {
        throw (0, import_err_code51.default)(new Error(`${path4} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      cidVersion = cid.version;
      const block = await context.repo.blocks.get(cid);
      const node = decode3(block);
      if (!node.Data) {
        throw (0, import_err_code51.default)(new Error(`${path4} had no data`), "ERR_INVALID_NODE");
      }
      const metadata = UnixFS.unmarshal(node.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = encode2({
        Data: metadata.marshal(),
        Links: node.Links
      });
      const hash3 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code3, hash3);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = parent2.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode3(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name6,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, settings);
    await updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption(mfsTouch);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/read.js
init_define_process();
var import_err_code52 = __toESM(require_err_code(), 1);
var mergeOptions12 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions13 = {
  offset: 0,
  length: Infinity
};
function createRead(context) {
  function mfsRead(path4, options = {}) {
    options = mergeOptions12(defaultOptions13, options);
    return {
      [Symbol.asyncIterator]: async function* read2() {
        const mfsPath = await toMfsPath(context, path4, options);
        const result = await exporter(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== "file") {
          throw (0, import_err_code52.default)(new Error(`${path4} was not a file`), "ERR_NOT_FILE");
        }
        if (!result.content) {
          throw (0, import_err_code52.default)(new Error(`Could not load content stream from ${path4}`), "ERR_NO_CONTENT");
        }
        for await (const buf2 of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf2;
        }
      }
    };
  }
  return withTimeoutOption(mfsRead);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/write.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/utils/to-async-iterator.js
init_define_process();
var import_err_code53 = __toESM(require_err_code(), 1);
var log35 = logger("ipfs:mfs:utils:to-async-iterator");
function toAsyncIterator(content) {
  if (!content) {
    throw (0, import_err_code53.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (typeof content === "string" || content instanceof String) {
    log35("Content was a string");
    content = fromString(content.toString());
  }
  if (content.length) {
    log35("Content was array-like");
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log35("Content was an async iterator");
    return content;
  }
  if (content[Symbol.iterator]) {
    log35("Content was an iterator");
    return content;
  }
  if (globalThis.Blob && content instanceof globalThis.Blob) {
    log35("Content was an HTML5 Blob");
    let index = 0;
    const iterator = {
      next: () => {
        if (index > content.size) {
          return {
            done: true
          };
        }
        return new Promise((resolve7, reject) => {
          const chunk = content.slice(index, MFS_MAX_CHUNK_SIZE);
          index += MFS_MAX_CHUNK_SIZE;
          const reader2 = new globalThis.FileReader();
          const handleLoad = (ev) => {
            reader2.removeEventListener("loadend", handleLoad, false);
            if (ev.error) {
              return reject(ev.error);
            }
            resolve7({
              done: false,
              value: new Uint8Array(reader2.result)
            });
          };
          reader2.addEventListener("loadend", handleLoad);
          reader2.readAsArrayBuffer(chunk);
        });
      }
    };
    return {
      [Symbol.asyncIterator]: () => {
        return iterator;
      }
    };
  }
  throw (0, import_err_code53.default)(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/write.js
var import_err_code54 = __toESM(require_err_code(), 1);
var import_it_last9 = __toESM(require_it_last(), 1);
var mergeOptions13 = merge_options_default.bind({ ignoreUndefined: true });
var log36 = logger("ipfs:mfs:write");
var defaultOptions14 = {
  offset: 0,
  length: Infinity,
  create: false,
  truncate: false,
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  parents: false,
  progress: (bytes2, path4) => {
  },
  strategy: "trickle",
  flush: true,
  leafType: "raw",
  shardSplitThreshold: 1e3
};
function createWrite(context) {
  async function mfsWrite(path4, content, opts = {}) {
    const options = mergeOptions13(defaultOptions14, opts);
    let source;
    let destination;
    let parent2;
    log36("Reading source, destination and parent");
    await createLock().readLock(async () => {
      source = await toAsyncIterator(content);
      destination = await toMfsPath(context, path4, options);
      parent2 = await toMfsPath(context, destination.mfsDirectory, options);
    })();
    log36("Read source, destination and parent");
    if (!options.parents && !parent2.exists) {
      throw (0, import_err_code54.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (source == null) {
      throw (0, import_err_code54.default)(new Error("could not create source"), "ERR_NO_SOURCE");
    }
    if (destination == null) {
      throw (0, import_err_code54.default)(new Error("could not create destination"), "ERR_NO_DESTINATION");
    }
    if (!options.create && !destination.exists) {
      throw (0, import_err_code54.default)(new Error("file does not exist"), "ERR_NO_EXIST");
    }
    if (destination.entryType !== "file") {
      throw (0, import_err_code54.default)(new Error("not a file"), "ERR_NOT_A_FILE");
    }
    return updateOrImport(context, path4, source, destination, options);
  }
  return withTimeoutOption(mfsWrite);
}
var updateOrImport = async (context, path4, source, destination, options) => {
  const child = await write(context, source, destination, options);
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents3(path4);
    const fileName = pathComponents.pop();
    if (fileName == null) {
      throw (0, import_err_code54.default)(new Error("source does not exist"), "ERR_NO_EXIST");
    }
    let parentExists = false;
    try {
      await createStat3(context)(`/${pathComponents.join("/")}`, options);
      parentExists = true;
    } catch (err2) {
      if (err2.code !== "ERR_NOT_FOUND") {
        throw err2;
      }
    }
    if (!parentExists) {
      await createMkdir(context)(`/${pathComponents.join("/")}`, options);
    }
    const updatedPath = await toMfsPath(context, path4, options);
    const trail = await toTrail(context, updatedPath.mfsDirectory);
    const parent2 = trail[trail.length - 1];
    if (!parent2) {
      throw (0, import_err_code54.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (!parent2.type || !parent2.type.includes("directory")) {
      throw (0, import_err_code54.default)(new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
    }
    const parentBlock = await context.repo.blocks.get(parent2.cid);
    const parentNode = decode3(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  })();
};
var write = async (context, source, destination, options) => {
  if (destination.exists) {
    log36(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
  } else {
    log36(`Writing file offset ${options.offset} length ${options.length}`);
  }
  const sources = [];
  if (options.offset > 0) {
    if (destination.unixfs) {
      log36(`Writing first ${options.offset} bytes of original file`);
      sources.push(
        () => {
          return destination.content({
            offset: 0,
            length: options.offset
          });
        }
      );
      if (destination.unixfs.fileSize() < options.offset) {
        const extra = options.offset - destination.unixfs.fileSize();
        log36(`Writing zeros for extra ${extra} bytes`);
        sources.push(
          asyncZeroes(extra)
        );
      }
    } else {
      log36(`Writing zeros for first ${options.offset} bytes`);
      sources.push(
        asyncZeroes(options.offset)
      );
    }
  }
  sources.push(
    limitAsyncStreamBytes(source, options.length)
  );
  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      const fileSize = destination.unixfs.fileSize();
      if (fileSize > bytesWritten) {
        log36(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
        return destination.content({
          offset: bytesWritten
        });
      } else {
        log36("Not writing last bytes from original file");
      }
    }
    return {
      [Symbol.asyncIterator]: async function* () {
      }
    };
  });
  let mode;
  if (options.mode !== void 0 && options.mode !== null) {
    mode = parseMode(options.mode);
  } else if (destination && destination.unixfs) {
    mode = destination.unixfs.mode;
  }
  let mtime;
  if (options.mtime != null) {
    mtime = parseMtime(options.mtime);
  } else if (destination && destination.unixfs) {
    mtime = destination.unixfs.mtime;
  }
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const result = await (0, import_it_last9.default)(importer([{
    content,
    mode,
    mtime
  }], context.repo.blocks, {
    progress: options.progress,
    hasher,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }));
  if (!result) {
    throw (0, import_err_code54.default)(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
  }
  log36(`Wrote ${result.cid}`);
  return {
    cid: result.cid,
    size: result.size
  };
};
var limitAsyncStreamBytes = (stream, limit) => {
  return async function* _limitAsyncStreamBytes() {
    let emitted = 0;
    for await (const buf2 of stream) {
      emitted += buf2.length;
      if (emitted > limit) {
        yield buf2.slice(0, limit - emitted);
        return;
      }
      yield buf2;
    }
  };
};
var asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {
  const buf2 = new Uint8Array(chunkSize);
  async function* _asyncZeroes() {
    while (true) {
      yield buf2.slice();
    }
  }
  return limitAsyncStreamBytes(_asyncZeroes(), count);
};
var catAsyncIterators = async function* (sources) {
  for (let i = 0; i < sources.length; i++) {
    yield* sources[i]();
  }
};
var countBytesStreamed = async function* (source, notify) {
  let wrote = 0;
  for await (const buf2 of source) {
    wrote += buf2.length;
    yield buf2;
  }
  for await (const buf2 of notify(wrote)) {
    wrote += buf2.length;
    yield buf2;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/ls.js
init_define_process();
var import_it_map8 = __toESM(require_it_map(), 1);
var toOutput = (fsEntry) => {
  const output = {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type: fsEntry.type === "directory" ? "directory" : "file",
    size: fsEntry.size
  };
  if (fsEntry.type === "file" || fsEntry.type === "directory") {
    output.mode = fsEntry.unixfs.mode;
    output.mtime = fsEntry.unixfs.mtime;
  }
  return output;
};
function createLs3(context) {
  async function* mfsLs(path4, options = {}) {
    const mfsPath = await toMfsPath(context, path4, options);
    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks);
    if (fsEntry.type === "directory") {
      yield* (0, import_it_map8.default)(fsEntry.content(options), toOutput);
      return;
    }
    yield toOutput(fsEntry);
  }
  return withTimeoutOption(mfsLs);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/files/index.js
var readOperations = {
  stat: createStat3
};
var writeOperations = {
  chmod: createChmod,
  cp: createCp,
  flush: createFlush,
  mkdir: createMkdir,
  mv: createMv,
  rm: createRm4,
  touch: createTouch
};
var unwrappedOperations = {
  write: createWrite,
  read: createRead,
  ls: createLs3
};
var wrap = ({
  options,
  mfs,
  operations,
  lock: lock3
}) => {
  Object.keys(operations).forEach((key) => {
    mfs[key] = lock3(operations[key](options));
  });
};
var defaultOptions15 = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {
    repoOwner
  } = Object.assign({}, defaultOptions15 || {}, options);
  const lock3 = createLock(repoOwner);
  const readLock = (operation) => {
    return lock3.readLock(operation);
  };
  const writeLock = (operation) => {
    return lock3.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach((key) => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles({ repo, preload: preload2, hashers, options: constructorOptions }) {
  const methods = createMfs({
    repo,
    repoOwner: constructorOptions.repoOwner !== false,
    hashers
  });
  const withPreload = (fn) => {
    const wrapped = (...args) => {
      const paths = args.filter((arg) => ipfsPath(arg) || isCID(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path4) => preload2(path4));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods,
    chmod: methods.chmod,
    cp: withPreload(methods.cp),
    mkdir: methods.mkdir,
    stat: withPreload(methods.stat),
    rm: methods.rm,
    read: withPreload(methods.read),
    touch: methods.touch,
    write: methods.write,
    mv: withPreload(methods.mv),
    flush: methods.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods.ls(...args)) {
        yield { ...file, size: file.size || 0 };
      }
    })
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/export.js
init_define_process();
function createExport2({ keychain }) {
  const exportKey = (name6, password) => keychain.exportKey(name6, password);
  return withTimeoutOption(exportKey);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/gen.js
init_define_process();
var DEFAULT_KEY_TYPE = "Ed25519";
var DEFAULT_KEY_SIZE = 2048;
function createGen({ keychain }) {
  const gen = (name6, options = { type: DEFAULT_KEY_TYPE, size: DEFAULT_KEY_SIZE }) => {
    return keychain.createKey(name6, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
  };
  return withTimeoutOption(gen);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/import.js
init_define_process();
function createImport2({ keychain }) {
  const importKey2 = (name6, pem, password) => {
    return keychain.importKey(name6, pem, password);
  };
  return withTimeoutOption(importKey2);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/info.js
init_define_process();
function createInfo({ keychain }) {
  const info = (name6) => keychain.findKeyByName(name6);
  return withTimeoutOption(info);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/list.js
init_define_process();
function createList2({ keychain }) {
  const list = () => keychain.listKeys();
  return withTimeoutOption(list);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/rename.js
init_define_process();
function createRename({ keychain }) {
  const rename = async (oldName, newName) => {
    const key = await keychain.renameKey(oldName, newName);
    return {
      was: oldName,
      now: key.name,
      id: key.id,
      overwrite: false
    };
  };
  return withTimeoutOption(rename);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/rm.js
init_define_process();
function createRm5({ keychain }) {
  const rm = (name6) => keychain.removeKey(name6);
  return withTimeoutOption(rm);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/key/index.js
var KeyAPI = class {
  constructor({ keychain }) {
    this.gen = createGen({ keychain });
    this.list = createList2({ keychain });
    this.rm = createRm5({ keychain });
    this.rename = createRename({ keychain });
    this.export = createExport2({ keychain });
    this.import = createImport2({ keychain });
    this.info = createInfo({ keychain });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/data.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/get.js
init_define_process();
function createGet4({ repo, preload: preload2 }) {
  async function get6(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid, options);
    return decode3(block);
  }
  return withTimeoutOption(get6);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/data.js
function createData({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  async function data(multihash, options = {}) {
    const node = await get6(multihash, options);
    return node.Data || new Uint8Array(0);
  }
  return withTimeoutOption(data);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/links.js
init_define_process();
function findLinks(node, links3 = []) {
  for (const key in node) {
    const val = node[key];
    if (key === "/" && Object.keys(node).length === 1) {
      try {
        links3.push({
          Name: "",
          Tsize: 0,
          Hash: CID.parse(val)
        });
        continue;
      } catch (_) {
      }
    }
    const cid = CID.asCID(val);
    if (cid) {
      links3.push({
        Name: "",
        Tsize: 0,
        Hash: cid
      });
      continue;
    }
    if (Array.isArray(val)) {
      findLinks(val, links3);
    }
    if (val && typeof val === "object") {
      findLinks(val, links3);
    }
  }
  return links3;
}
function createLinks({ repo, codecs: codecs2 }) {
  async function links3(cid, options = {}) {
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    switch (cid.code) {
      case code:
        return [];
      case code3:
        return node.Links;
      case code4:
      case code5:
        return findLinks(node);
      default:
        throw new Error(`Cannot resolve links from codec ${cid.code}`);
    }
  }
  return withTimeoutOption(links3);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/new.js
init_define_process();
function createNew({ repo, preload: preload2 }) {
  async function _new(options = {}) {
    let data;
    if (options.template) {
      if (options.template === "unixfs-dir") {
        data = new UnixFS({ type: "directory" }).marshal();
      } else {
        throw new Error("unknown template");
      }
    }
    const buf2 = encode2({
      Data: data,
      Links: []
    });
    const hash3 = await sha256.digest(buf2);
    const cid = CID.createV0(hash3);
    await repo.blocks.put(cid, buf2, {
      signal: options.signal
    });
    if (options.preload !== false) {
      preload2(cid);
    }
    return cid;
  }
  return withTimeoutOption(_new);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/put.js
init_define_process();
function createPut3({ repo, preload: preload2 }) {
  async function put(obj, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const buf2 = encode2(obj);
      const hash3 = await sha256.digest(buf2);
      const cid = CID.createV1(code3, hash3);
      await repo.blocks.put(cid, buf2, {
        signal: options.signal
      });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin) {
        await repo.pins.pinRecursively(cid, {
          signal: options.signal
        });
      }
      return cid;
    } finally {
      release();
    }
  }
  return withTimeoutOption(put);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/stat.js
init_define_process();
function createStat4({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  async function stat(cid, options = {}) {
    const node = await get6(cid, options);
    const serialized = encode2(node);
    const blockSize = serialized.length;
    const linkLength = node.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
    return {
      Hash: cid,
      NumLinks: node.Links.length,
      BlockSize: blockSize,
      LinksSize: blockSize - (node.Data || []).length,
      DataSize: (node.Data || []).length,
      CumulativeSize: blockSize + linkLength
    };
  }
  return withTimeoutOption(stat);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/add-link.js
init_define_process();
function createAddLink({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function addLink2(cid, link, options = {}) {
    const node = await get6(cid, options);
    return put({
      ...node,
      Links: node.Links.concat([link])
    }, options);
  }
  return withTimeoutOption(addLink2);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/append-data.js
init_define_process();
init_concat();
function createAppendData({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function appendData(cid, data, options = {}) {
    const node = await get6(cid, options);
    const newData = concat([node.Data || [], data]);
    return put({
      ...node,
      Data: newData
    }, options);
  }
  return withTimeoutOption(appendData);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/rm-link.js
init_define_process();
function createRmLink({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function rmLink(cid, link, options = {}) {
    const node = await get6(cid, options);
    const name6 = (typeof link === "string" ? link : link.Name) || "";
    node.Links = node.Links.filter((l) => l.Name !== name6);
    return put(node, options);
  }
  return withTimeoutOption(rmLink);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/set-data.js
init_define_process();
function createSetData({ repo, preload: preload2 }) {
  const get6 = createGet4({ repo, preload: preload2 });
  const put = createPut3({ repo, preload: preload2 });
  async function setData(cid, data, options = {}) {
    const node = await get6(cid, options);
    return put({
      ...node,
      Data: data
    }, options);
  }
  return withTimeoutOption(setData);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/patch/index.js
var ObjectPatchAPI = class {
  constructor({ repo, preload: preload2 }) {
    this.addLink = createAddLink({ repo, preload: preload2 });
    this.appendData = createAppendData({ repo, preload: preload2 });
    this.rmLink = createRmLink({ repo, preload: preload2 });
    this.setData = createSetData({ repo, preload: preload2 });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/object/index.js
var ObjectAPI = class {
  constructor({ repo, codecs: codecs2, preload: preload2 }) {
    this.data = createData({ repo, preload: preload2 });
    this.get = createGet4({ repo, preload: preload2 });
    this.links = createLinks({ repo, codecs: codecs2 });
    this.new = createNew({ repo, preload: preload2 });
    this.put = createPut3({ repo, preload: preload2 });
    this.stat = createStat4({ repo, preload: preload2 });
    this.patch = new ObjectPatchAPI({ repo, preload: preload2 });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/gc.js
init_define_process();
var log37 = logger("ipfs:repo:gc");
function createGc({ repo, hashers }) {
  async function* gc2(options = {}) {
    const start = Date.now();
    let mfsRootCid;
    try {
      mfsRootCid = await loadMfsRoot({
        repo,
        hashers
      }, options);
      await repo.pins.pinRecursively(mfsRootCid);
      yield* repo.gc();
    } finally {
      if (mfsRootCid) {
        await repo.pins.unpin(mfsRootCid);
      }
    }
    log37(`Complete (${Date.now() - start}ms)`);
  }
  return withTimeoutOption(gc2);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/stat.js
init_define_process();
function createStat5({ repo }) {
  async function stat(options = {}) {
    const stats = await repo.stat();
    return {
      numObjects: BigInt(stats.numObjects.toString()),
      repoSize: BigInt(stats.repoSize.toString()),
      repoPath: stats.repoPath,
      version: `${stats.version}`,
      storageMax: BigInt(stats.storageMax.toString())
    };
  }
  return withTimeoutOption(stat);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/version.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/constants.js
init_define_process();
var repoVersion = 12;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/version.js
function createVersion2({ repo }) {
  async function version3(options = {}) {
    try {
      await repo._checkInitialized(options);
    } catch (err2) {
      const match = [
        /Key not found in database \[\/version\]/,
        /ENOENT/,
        /repo is not initialized yet/
      ].some((m) => {
        return m.test(err2.message);
      });
      if (match) {
        return repoVersion;
      }
      throw err2;
    }
    return repo.version.get();
  }
  return withTimeoutOption(version3);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/repo/index.js
var RepoAPI = class {
  constructor({ repo, hashers }) {
    this.gc = createGc({ repo, hashers });
    this.stat = createStat5({ repo });
    this.version = createVersion2({ repo });
    this.setApiAddr = (addr) => repo.apiAddr.set(addr);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/stats/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/stats/bw.js
init_define_process();
var import_err_code55 = __toESM(require_err_code(), 1);
function getBandwidthStats(libp2p, opts) {
  let stats;
  if (!libp2p.metrics) {
    stats = void 0;
  } else if (opts.peer) {
    stats = libp2p.metrics.forPeer(opts.peer);
  } else if (opts.proto) {
    stats = libp2p.metrics.forProtocol(opts.proto);
  } else {
    stats = libp2p.metrics.getGlobal();
  }
  if (!stats) {
    return {
      totalIn: BigInt(0),
      totalOut: BigInt(0),
      rateIn: 0,
      rateOut: 0
    };
  }
  const movingAverages = stats.getMovingAverages();
  const snapshot = stats.getSnapshot();
  return {
    totalIn: snapshot.dataReceived,
    totalOut: snapshot.dataSent,
    rateIn: movingAverages.dataReceived[6e4].movingAverage / 60,
    rateOut: movingAverages.dataSent[6e4].movingAverage / 60
  };
}
function createBw({ network }) {
  const bw = async function* (options = {}) {
    const { libp2p } = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats(libp2p, options);
      return;
    }
    const interval = options.interval || 1e3;
    let ms = -1;
    try {
      ms = typeof interval === "string" ? parse_duration_default(interval) || -1 : interval;
      if (!ms || ms < 0)
        throw new Error("invalid duration");
    } catch (err2) {
      throw (0, import_err_code55.default)(err2, "ERR_INVALID_POLL_INTERVAL");
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise((resolve7) => {
          timeoutId = setTimeout(resolve7, ms);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption(bw);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/stats/index.js
var StatsAPI = class {
  constructor({ repo, network }) {
    this.repo = createStat5({ repo });
    this.bw = createBw({ network });
    this.bitswap = createStat({ network });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/storage.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/repo.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/just-safe-get-npm-4.1.1-fcbf923e34-9.zip/node_modules/just-safe-get/index.mjs
init_define_process();
var objectSafeGet = get3;
function get3(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/index.js
var import_debug9 = __toESM(require_debug(), 1);
var import_err_code61 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js
init_define_process();
var import_debug = __toESM(require_debug(), 1);
var import_it_length = __toESM(require_it_length(), 1);
var log38 = (0, import_debug.default)("ipfs:repo:migrator:migration-8");
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf2).multihash.bytes;
    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err2) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest = decode(buf2);
    const multihash = base32.encode(CID.createV1(code, digest).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await (0, import_it_length.default)(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log38(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var migration = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToCid);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/pin.js
init_define_process();
var import_minimal2 = __toESM(require_minimal(), 1);
var $Reader2 = import_minimal2.default.Reader;
var $Writer2 = import_minimal2.default.Writer;
var $util2 = import_minimal2.default.util;
var $root2 = import_minimal2.default.roots["default"] || (import_minimal2.default.roots["default"] = {});
var ipfs = $root2.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode15(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode13(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root2.ipfs.pin.Set)
          return d;
        var m = new $root2.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
var import_fnv1a = __toESM(require_fnv1a(), 1);
var import_varint3 = __toESM(require_varint(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/utils.js
init_define_process();
var PIN_DS_KEY = new Key("/local/pins");
var DEFAULT_FANOUT = 256;
var MAX_ITEMS = 8192;
var EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
var PinTypes2 = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey(cid) {
  return new Key(`/${base32.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
init_concat();
var PinSet = ipfs.pin.Set;
function readHeader2(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint3.default.decode(rootData);
  const vBytes = import_varint3.default.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed, true);
  const encodedKey = fromString(key.toString());
  const data = concat([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader2(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode3(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name6) {
  const link = rootNode.Links.find((l) => l.Name === name6);
  if (!link) {
    throw new Error("No link found with name " + name6);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode3(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint3.default.encode(pbHeader.length);
    const headerBuf = concat([header, pbHeader]);
    const fanoutLinks = [];
    for (let i = 0; i < DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode2(child);
      const digest = await sha256.digest(buf2);
      const cid = CID.createV0(digest);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode2(rootNode);
  const digest = await sha256.digest(buf2);
  const cid = CID.createV0(digest);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-9/index.js
var import_it_length2 = __toESM(require_it_length(), 1);
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode3(pinRootBuf);
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.recursive)) + await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.recursive)) {
    counter++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code3) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode3(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.direct)) {
    counter++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code3) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode3(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(pinstore.queryKeys({}));
  for await (const { key, value } of pinstore.query({})) {
    counter++;
    const pin = decode4(value);
    const cid2 = CID.create(
      pin.version || 0,
      pin.codec || code3,
      decode(base32.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes2.direct, directPins),
      await storeSet(blockstore, PinTypes2.recursive, recursivePins)
    ]
  };
  const buf2 = encode2(pinRoot);
  const digest = await sha256.digest(buf2);
  const cid = CID.createV0(digest);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var migration2 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDAG);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-10/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/utils.js
init_define_process();
var CONFIG_KEY = new Key("/config");
var VERSION_KEY = new Key("/version");
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get6, has, store) {
  if (await has(key)) {
    return get6(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-10/index.js
async function keysToBinary(name6, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name6} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name6}`);
  const upgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString(key), value }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name6, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name6} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name6}`);
  const downgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: toString(key), value }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap2(store) {
  if (store.child) {
    return unwrap2(store.child);
  }
  return store;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap2(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message2) => {
    onProgress(Math.round(migrated / datastores.length * 100), message2);
  };
  for (const { name: name6, store } of datastores) {
    await store.open();
    try {
      await fn(name6, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
var migration3 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch3(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err2) {
        error = err2;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve7, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err2, key, value) => {
        if (err2 || key === void 0) {
          const handleEnd = (err22) => {
            if (err22) {
              reject(err22);
              return;
            }
            resolve7();
          };
          it.end(handleEnd);
          return;
        }
        batch3(fn(key, value), next);
      };
      it.next(handleNext);
    }
  });
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-11/index.js
init_define_process();
var MFS_ROOT_KEY2 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY2)) {
    const root = await backends.root.get(MFS_ROOT_KEY2);
    await backends.datastore.put(MFS_ROOT_KEY2, root);
    await backends.root.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY2)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY2);
    await backends.root.put(MFS_ROOT_KEY2, root);
    await backends.datastore.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var migration4 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/index.js
init_define_process();
var import_minimal8 = __toESM(require_minimal(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/pb/proto-book.js
init_define_process();
var import_minimal3 = __toESM(require_minimal(), 1);
var $Reader3 = import_minimal3.default.Reader;
var $Writer3 = import_minimal3.default.Writer;
var $util3 = import_minimal3.default.util;
var $root3 = import_minimal3.default.roots["default"] || (import_minimal3.default.roots["default"] = {});
var Protocols = $root3.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Protocols2.prototype.protocols = $util3.emptyArray;
  Protocols2.encode = function encode15(m, w) {
    if (!w)
      w = $Writer3.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(10).string(m.protocols[i]);
    }
    return w;
  };
  Protocols2.decode = function decode13(r, l) {
    if (!(r instanceof $Reader3))
      r = $Reader3.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root3.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root3.Protocols)
      return d;
    var m = new $root3.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
  };
  return Protocols2;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/pb/address-book.js
init_define_process();
var import_minimal4 = __toESM(require_minimal(), 1);
var $Reader4 = import_minimal4.default.Reader;
var $Writer4 = import_minimal4.default.Writer;
var $util4 = import_minimal4.default.util;
var $root4 = import_minimal4.default.roots["default"] || (import_minimal4.default.roots["default"] = {});
var Addresses = $root4.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Addresses2.prototype.addrs = $util4.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode15(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i = 0; i < m.addrs.length; ++i)
        $root4.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root4.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode13(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root4.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root4.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Addresses)
      return d;
    var m = new $root4.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i = 0; i < d.addrs.length; ++i) {
        if (typeof d.addrs[i] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i] = $root4.Addresses.Address.fromObject(d.addrs[i]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root4.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root4.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root4.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address3(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Address3.prototype.multiaddr = $util4.newBuffer([]);
    Address3.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address3.prototype, "_isCertified", {
      get: $util4.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util4.oneOfSetter($oneOfFields)
    });
    Address3.encode = function encode15(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address3.decode = function decode13(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address3.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.Address)
        return d;
      var m = new $root4.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util4.base64.decode(d.multiaddr, m.multiaddr = $util4.newBuffer($util4.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address3.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util4.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util4.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address3.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
    };
    return Address3;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    CertifiedRecord.prototype.seq = $util4.Long ? $util4.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util4.newBuffer([]);
    CertifiedRecord.encode = function encode15(m, w) {
      if (!w)
        w = $Writer4.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode13(r, l) {
      if (!(r instanceof $Reader4))
        r = $Reader4.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root4.Addresses.CertifiedRecord)
        return d;
      var m = new $root4.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util4.Long)
          (m.seq = $util4.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util4.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util4.base64.decode(d.raw, m.raw = $util4.newBuffer($util4.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util4.Long) {
          var n = new $util4.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util4.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util4.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util4.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util4.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/pb/peer.js
init_define_process();
var import_minimal5 = __toESM(require_minimal(), 1);
var $Reader5 = import_minimal5.default.Reader;
var $Writer5 = import_minimal5.default.Writer;
var $util5 = import_minimal5.default.util;
var $root5 = import_minimal5.default.roots["default"] || (import_minimal5.default.roots["default"] = {});
var Peer = $root5.Peer = (() => {
  function Peer3(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Peer3.prototype.addresses = $util5.emptyArray;
  Peer3.prototype.protocols = $util5.emptyArray;
  Peer3.prototype.metadata = $util5.emptyArray;
  Peer3.prototype.pubKey = null;
  Peer3.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer3.prototype, "_pubKey", {
    get: $util5.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer3.prototype, "_peerRecordEnvelope", {
    get: $util5.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Peer3.encode = function encode15(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root5.Address.encode(m.addresses[i], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(18).string(m.protocols[i]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i = 0; i < m.metadata.length; ++i)
        $root5.Metadata.encode(m.metadata[i], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer3.decode = function decode13(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root5.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root5.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Peer)
      return d;
    var m = new $root5.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i] = $root5.Address.fromObject(d.addresses[i]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i = 0; i < d.metadata.length; ++i) {
        if (typeof d.metadata[i] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i] = $root5.Metadata.fromObject(d.metadata[i]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util5.base64.decode(d.pubKey, m.pubKey = $util5.newBuffer($util5.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util5.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util5.newBuffer($util5.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root5.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root5.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util5.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util5.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  return Peer3;
})();
var Address = $root5.Address = (() => {
  function Address3(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Address3.prototype.multiaddr = $util5.newBuffer([]);
  Address3.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address3.prototype, "_isCertified", {
    get: $util5.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util5.oneOfSetter($oneOfFields)
  });
  Address3.encode = function encode15(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address3.decode = function decode13(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address3.fromObject = function fromObject(d) {
    if (d instanceof $root5.Address)
      return d;
    var m = new $root5.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util5.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  return Address3;
})();
var Metadata2 = $root5.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata4.prototype.key = "";
  Metadata4.prototype.value = $util5.newBuffer([]);
  Metadata4.encode = function encode15(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata4.decode = function decode13(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root5.Metadata)
      return d;
    var m = new $root5.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util5.base64.decode(d.value, m.value = $util5.newBuffer($util5.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util5.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util5.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/pb/envelope.js
init_define_process();
var import_minimal6 = __toESM(require_minimal(), 1);
var $Reader6 = import_minimal6.default.Reader;
var $Writer6 = import_minimal6.default.Writer;
var $util6 = import_minimal6.default.util;
var $root6 = import_minimal6.default.roots["default"] || (import_minimal6.default.roots["default"] = {});
var Envelope = $root6.Envelope = (() => {
  function Envelope2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Envelope2.prototype.publicKey = $util6.newBuffer([]);
  Envelope2.prototype.payloadType = $util6.newBuffer([]);
  Envelope2.prototype.payload = $util6.newBuffer([]);
  Envelope2.prototype.signature = $util6.newBuffer([]);
  Envelope2.encode = function encode15(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope2.decode = function decode13(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope2.fromObject = function fromObject(d) {
    if (d instanceof $root6.Envelope)
      return d;
    var m = new $root6.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util6.base64.decode(d.publicKey, m.publicKey = $util6.newBuffer($util6.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util6.base64.decode(d.payloadType, m.payloadType = $util6.newBuffer($util6.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util6.base64.decode(d.payload, m.payload = $util6.newBuffer($util6.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util6.base64.decode(d.signature, m.signature = $util6.newBuffer($util6.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util6.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util6.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util6.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util6.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util6.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util6.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util6.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util6.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Envelope2;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/pb/peer-record.js
init_define_process();
var import_minimal7 = __toESM(require_minimal(), 1);
var $Reader7 = import_minimal7.default.Reader;
var $Writer7 = import_minimal7.default.Writer;
var $util7 = import_minimal7.default.util;
var $root7 = import_minimal7.default.roots["default"] || (import_minimal7.default.roots["default"] = {});
var PeerRecord2 = $root7.PeerRecord = (() => {
  function PeerRecord3(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  PeerRecord3.prototype.peerId = $util7.newBuffer([]);
  PeerRecord3.prototype.seq = $util7.Long ? $util7.Long.fromBits(0, 0, true) : 0;
  PeerRecord3.prototype.addresses = $util7.emptyArray;
  PeerRecord3.encode = function encode15(m, w) {
    if (!w)
      w = $Writer7.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root7.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord3.decode = function decode13(r, l) {
    if (!(r instanceof $Reader7))
      r = $Reader7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root7.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord3.fromObject = function fromObject(d) {
    if (d instanceof $root7.PeerRecord)
      return d;
    var m = new $root7.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util7.base64.decode(d.peerId, m.peerId = $util7.newBuffer($util7.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util7.Long)
        (m.seq = $util7.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util7.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i] = $root7.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
      }
    }
    return m;
  };
  PeerRecord3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util7.newBuffer(d.peerId);
      }
      if ($util7.Long) {
        var n = new $util7.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util7.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util7.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util7.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root7.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  PeerRecord3.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    AddressInfo.prototype.multiaddr = $util7.newBuffer([]);
    AddressInfo.encode = function encode15(m, w) {
      if (!w)
        w = $Writer7.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode13(r, l) {
      if (!(r instanceof $Reader7))
        r = $Reader7.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root7.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root7.PeerRecord.AddressInfo)
        return d;
      var m = new $root7.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util7.base64.decode(d.multiaddr, m.multiaddr = $util7.newBuffer($util7.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util7.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util7.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord3;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/migration-12/index.js
import_minimal8.default.util.Long = void 0;
import_minimal8.default.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value });
    } else if (type === "keys") {
      peers[peerId].pubKey = value;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = Peer.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, _prefix, peerId] = keyStr.split("/");
    peers[peerId] = Peer.decode(value);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord2.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
var migration5 = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/migrations/index.js
var emptyMigration = {
  description: "Empty migration.",
  migrate: () => {
  },
  revert: () => {
  },
  empty: true
};
var migrations_default = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration,
  migration2,
  migration3,
  migration4,
  migration5
];

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/repo/version.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/repo/init.js
init_define_process();
var import_debug2 = __toESM(require_debug(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/errors.js
var errors_exports3 = {};
__export(errors_exports3, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
init_define_process();
var NonReversibleMigrationError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message2;
  }
};
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
var NotInitializedRepoError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message2;
  }
};
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
var RequiredParameterError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message2;
  }
};
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
var InvalidValueError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message2;
  }
};
InvalidValueError.code = "ERR_INVALID_VALUE";
var MissingRepoOptionsError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message2;
  }
};
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/repo/init.js
var log39 = (0, import_debug2.default)("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log39(`Version entry present: ${versionCheck}`);
      log39(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log39("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/repo/version.js
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version3, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString(String(version3)));
  await store.close();
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-migrations-npm-13.0.3-efe67ca8f4-9.zip/node_modules/ipfs-repo-migrations/src/index.js
var import_debug3 = __toESM(require_debug(), 1);
var log40 = (0, import_debug3.default)("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path4, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path4) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path4);
  }
  try {
    for (const migration6 of migrations) {
      if (toVersion !== void 0 && migration6.version > toVersion) {
        break;
      }
      if (migration6.version <= currentVersion) {
        continue;
      }
      log40(`Migrating version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration6.version, percent.toFixed(2), message2);
          }
          await migration6.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration6.version - 1;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration6.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log40(`Migrating to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log40("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
async function revert(path4, backends, repoOptions, toVersion, options = {}) {
  const ignoreLock = options.ignoreLock ?? false;
  const onProgress = options.onProgress;
  const isDryRun = options.isDryRun ?? false;
  const migrations = options.migrations ?? migrations_default;
  if (!path4) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log40("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path4);
  }
  log40(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration6 of reversedMigrationArray) {
      if (migration6.version <= toVersion) {
        break;
      }
      if (migration6.version > currentVersion) {
        continue;
      }
      log40(`Reverting migration version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message2) => onProgress(migration6.version, percent.toFixed(2), message2);
          }
          await migration6.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration6.version;
        log40(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration6.version} exception was raised: ${e.message}`;
        throw e;
      }
      log40(`Reverting to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log40(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration6 of migrations) {
    if (migration6.version > toVersion) {
      break;
    }
    if (migration6.version > fromVersion) {
      if (checkReversibility && !migration6.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration6.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var errors = errors_exports3;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/index.js
var import_bytes3 = __toESM(require_bytes(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/version.js
init_define_process();
var import_debug4 = __toESM(require_debug(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/utils/level.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/errors.js
init_define_process();
var LockExistsError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
};
LockExistsError.code = "ERR_LOCK_EXISTS";
var NotFoundError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
};
NotFoundError.code = "ERR_NOT_FOUND";
var InvalidRepoVersionError = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
};
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
var ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
var ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
var ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/utils/level.js
async function hasWithFallback2(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve7(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get6, has, store) {
  if (await has(key)) {
    return get6(key);
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve7, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve7(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/version.js
var log41 = (0, import_debug4.default)("ipfs:repo:version");
var versionKey = new Key("version");
function version(store) {
  return {
    async exists() {
      return hasWithFallback2(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf2 = await getWithFallback2(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString(buf2), 10);
    },
    set(version3) {
      return store.put(versionKey, fromString(String(version3)));
    },
    async check(expected) {
      const version3 = await this.get();
      log41("comparing version: %s and %s", version3, expected);
      const compatibleVersion = version3 === 6 && expected === 7 || expected === 6 && version3 === 7;
      return version3 === expected || compatibleVersion;
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/config.js
init_define_process();
var import_err_code56 = __toESM(require_err_code(), 1);
var Queue3 = PQueue.default ? PQueue.default : PQueue;
var configKey = new Key("config");
function config(store) {
  const setQueue = new Queue3({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value = objectSafeGet(config2, key);
      if (value === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code56.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value === void 0 || value instanceof Uint8Array) {
        throw (0, import_err_code56.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw (0, import_err_code56.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value
      }, options.signal));
    },
    async exists() {
      return hasWithFallback2(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value);
      }
      return _saveAll(config2);
    }
    return _saveAll(value);
  }
  function _saveAll(config2) {
    const buf2 = fromString(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/spec.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/sort-keys-npm-5.0.0-10c1d08986-9.zip/node_modules/sort-keys/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/is-plain-obj-npm-4.1.0-a4f2a92b44-9.zip/node_modules/is-plain-obj/index.js
init_define_process();
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../../../../../Users/z/.yarn/berry/cache/sort-keys-npm-5.0.0-10c1d08986-9.zip/node_modules/sort-keys/index.js
function sortKeys(object, options = {}) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare3 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare3);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value = object2[key];
      let newValue;
      if (deep && Array.isArray(value)) {
        newValue = deepSortArray(value);
      } else {
        newValue = deep && isPlainObject(value) ? _sortKeys(value) : value;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/spec.js
var specKey = new Key("datastore_spec");
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString(buf2));
    },
    async set(spec2) {
      return store.put(specKey, fromString(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/api-addr.js
init_define_process();
var apiFile = new Key("api");
function apiAddr(store) {
  return {
    async get() {
      const value = await store.get(apiFile);
      return value && value.toString();
    },
    set(value) {
      return store.put(apiFile, fromString(value.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/idstore.js
init_define_process();
var import_it_filter4 = __toESM(require_it_filter(), 1);
var import_it_drain6 = __toESM(require_it_drain(), 1);
var import_err_code57 = __toESM(require_err_code(), 1);
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await (0, import_it_drain6.default)(store.putMany(async function* () {
            for await (const { key, value } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value };
              }
              output.push({ key, value });
            }
          }()));
          output.end();
        } catch (err2) {
          output.end(err2);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_filter4.default)(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch3 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.delete(cid);
        },
        commit: (options) => {
          return batch3.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw (0, import_err_code57.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/default-options.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/locks/memory.js
init_define_process();
var import_debug5 = __toESM(require_debug(), 1);
var log42 = (0, import_debug5.default)("ipfs:repo:lock:memory");
var lockFile = "repo.lock";
var LOCKS = {};
async function lock2(dir) {
  const file = dir + "/" + lockFile;
  log42("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log42(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
var MemoryLock = {
  lock: lock2,
  locked
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/default-options.js
var default_options_default = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/default-datastore.js
init_define_process();
var default_datastore_default = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/pin-manager.js
init_define_process();
var import_err_code59 = __toESM(require_err_code(), 1);
var import_debug7 = __toESM(require_debug(), 1);
var import_it_first2 = __toESM(require_it_first(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/utils/blockstore.js
init_define_process();
var import_err_code58 = __toESM(require_err_code(), 1);
function cidToKey2(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw (0, import_err_code58.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode(base32.decode(`b${key.toString().toLowerCase().substring(1)}`));
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/utils/walk-dag.js
init_define_process();
var import_debug6 = __toESM(require_debug(), 1);
var log43 = (0, import_debug6.default)("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err2) {
    log43("Could not walk DAG for CID", cid.toString(), err2);
    throw err2;
  }
}

// ../../../../../Users/z/.yarn/berry/cache/quick-lru-npm-6.1.1-6266dda1a4-9.zip/node_modules/quick-lru/index.js
init_define_process();
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _emitEvictions(cache3) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache3) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache3) {
    const item = cache3.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/pin-manager.js
var CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code59.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var PinManager = class {
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = (0, import_debug7.default)("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code3) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey2(cid), encode3(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey2(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code3) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey2(cid), encode3(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode4(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode4(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code3;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode4(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode4(entry.value);
      const version3 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code3;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version3, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types2 = [
          PinTypes.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types2);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types2, options) {
    if (!Array.isArray(types2)) {
      types2 = [types2];
    }
    const all11 = types2.includes(PinTypes.all);
    const direct = types2.includes(PinTypes.direct);
    const recursive2 = types2.includes(PinTypes.recursive);
    const indirect = types2.includes(PinTypes.indirect);
    if (recursive2 || direct || all11) {
      const result = await (0, import_it_first2.default)(this.pinstore.query({
        prefix: cidToKey2(cid).toString(),
        filters: [(entry) => {
          if (all11) {
            return true;
          }
          const pin = decode4(entry.value);
          return types2.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode4(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all11 || indirect) {
      const parentCid = await (0, import_it_first2.default)(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options = {}) {
    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/pinned-blockstore.js
init_define_process();
var import_it_map9 = __toESM(require_it_map(), 1);
var import_err_code60 = __toESM(require_err_code(), 1);
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_map9.default)(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw (0, import_err_code60.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/gc.js
init_define_process();
var import_debug8 = __toESM(require_debug(), 1);
var import_it_parallel_batch3 = __toESM(require_it_parallel_batch(), 1);
var import_it_merge2 = __toESM(require_it_merge(), 1);
var import_it_map10 = __toESM(require_it_map(), 1);
var import_it_filter5 = __toESM(require_it_filter(), 1);
var log44 = (0, import_debug8.default)("ipfs:repo:gc");
var ERR_NOT_FOUND4 = notFoundError().code;
var BLOCK_RM_CONCURRENCY2 = 256;
var MFS_ROOT_KEY3 = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log44("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log44(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY3);
    } catch (err2) {
      if (err2.code === ERR_NOT_FOUND4) {
        log44("No blocks in MFS");
        return;
      }
      throw err2;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = (0, import_it_merge2.default)(
    (0, import_it_map10.default)(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    (0, import_it_map10.default)(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of (0, import_it_merge2.default)(pinsSource, mfsSource)) {
    output.add(base32.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err2) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err2.message}`)
          };
        }
        return { cid };
      } catch (err2) {
        const msg = `Could delete block with CID ${cid}`;
        log44(msg, err2);
        return { err: new Error(msg + `: ${err2.message}`) };
      }
    };
  };
  yield* pipe(
    (0, import_it_parallel_batch3.default)((0, import_it_map10.default)(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY2),
    (source) => (0, import_it_filter5.default)(source, Boolean)
  );
  log44(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-repo-npm-15.0.3-39b4f65d0c-9.zip/node_modules/ipfs-repo/src/index.js
var log45 = (0, import_debug9.default)("ipfs:repo");
var noLimit = Number.MAX_SAFE_INTEGER;
var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
var Repo = class {
  constructor(path4, loadCodec, backends, options) {
    if (typeof path4 !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = merge_options_default(default_options_default, options);
    this.closed = true;
    this.path = path4;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path4,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  async init(config2) {
    log45("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err2) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw (0, import_err_code61.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log45("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log45("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log45("creating datastore");
      await this.datastore.open();
      log45("creating blocks");
      await this.blocks.open();
      log45("creating keystore");
      await this.keys.open();
      log45("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log45("all opened");
    } catch (err2) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err22) {
          log45("error removing lock", err22);
        }
      }
      throw err2;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err2) {
      if (err2.message !== "Already open") {
        throw err2;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw (0, import_err_code61.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log45("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code61.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err2;
    }
    if (!config2) {
      throw (0, import_err_code61.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  async close() {
    if (this.closed) {
      throw (0, import_err_code61.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log45("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err2) {
      if (err2.code !== ERR_REPO_NOT_INITIALIZED && !err2.message.startsWith("ENOENT")) {
        throw err2;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log45("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version3, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version3,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw (0, import_err_code61.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log45(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log45(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get("Datastore.StorageMax");
      return BigInt((0, import_bytes3.default)(max));
    } catch (err2) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size };
  }
};
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path4, loadCodec, backends, options) {
  return new Repo(path4, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}

// ../../../../../Users/z/.yarn/berry/cache/datastore-level-npm-9.0.1-cadc8d7164-9.zip/node_modules/datastore-level/src/index.js
init_define_process();
var import_it_filter6 = __toESM(require_it_filter(), 1);
var import_it_map11 = __toESM(require_it_map(), 1);
var import_it_take3 = __toESM(require_it_take(), 1);
var import_it_sort = __toESM(require_it_sort(), 1);
var import_level3 = __toESM(require_browser2(), 1);
var LevelDatastore = class extends BaseDatastore {
  constructor(path4, opts = {}) {
    super();
    this.db = typeof path4 === "string" ? new import_level3.Level(path4, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path4;
    this.opts = {
      createIfMissing: true,
      compression: false,
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err2) {
      throw errors_exports.dbOpenFailedError(err2);
    }
  }
  async put(key, value) {
    try {
      await this.db.put(key.toString(), value);
    } catch (err2) {
      throw errors_exports.dbWriteFailedError(err2);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        throw errors_exports.notFoundError(err2);
      throw errors_exports.dbWriteFailedError(err2);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err2) {
      if (err2.notFound)
        return false;
      throw err2;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err2) {
      throw errors_exports.dbDeleteFailedError(err2);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = (0, import_it_filter6.default)(it, () => i++ >= offset);
    }
    if (limit) {
      it = (0, import_it_take3.default)(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = (0, import_it_map11.default)(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = (0, import_it_filter6.default)(it, () => i++ >= offset);
    }
    if (limit) {
      it = (0, import_it_take3.default)(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    const iterator = this.db.iterator(iteratorOpts);
    if (iterator[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator);
    }
    if (iterator.next != null && iterator.end != null) {
      return oldLevelIteratorToIterator(iterator);
    }
    throw new Error("Level returned incompatible iterator");
  }
};
async function* levelIteratorToIterator(li) {
  for await (const [key, value] of li) {
    yield { key: new Key(key, false), value };
  }
  await li.close();
}
function oldLevelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve7, reject) => {
          li.next((err2, key, value) => {
            if (err2)
              return reject(err2);
            if (key == null) {
              return li.end((err3) => {
                if (err3)
                  return reject(err3);
                resolve7({ done: true, value: void 0 });
              });
            }
            resolve7({ done: false, value: { key: new Key(key, false), value } });
          });
        }),
        return: () => new Promise((resolve7, reject) => {
          li.end((err2) => {
            if (err2)
              return reject(err2);
            resolve7({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/blockstore-datastore-adapter-npm-3.0.1-1822ea7420-9.zip/node_modules/blockstore-datastore-adapter/src/index.js
init_define_process();
var import_it_drain8 = __toESM(require_it_drain(), 1);
var import_err_code62 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/blockstore-core-npm-2.0.1-ea08d5c728-9.zip/node_modules/blockstore-core/src/base.js
init_define_process();
var import_it_drain7 = __toESM(require_it_drain(), 1);
var import_it_filter7 = __toESM(require_it_filter(), 1);
var import_it_take4 = __toESM(require_it_take(), 1);
var import_it_all4 = __toESM(require_it_all(), 1);
var sortAll2 = (iterable, sorter) => {
  return async function* () {
    const values = await (0, import_it_all4.default)(iterable);
    yield* values.sort(sorter);
  }();
};
var BaseBlockstore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain7.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain7.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter7.default)(it, () => i++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter7.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/blockstore-datastore-adapter-npm-3.0.1-1822ea7420-9.zip/node_modules/blockstore-datastore-adapter/src/index.js
function cidToKey3(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw (0, import_err_code62.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID.createV1(code, decode(base32.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc.decode("z" + input);
  } else {
    decoder = (input) => base32.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes2 = decoder(prefix.substring(0, i));
    } catch (err2) {
      if (err2.message !== "Unexpected end of data") {
        throw err2;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base32.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter15) => (pair2) => {
        return filter15({ key: keyToCid2(pair2.key), value: pair2.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order({ key: keyToCid2(a.key), value: a.value }, { key: keyToCid2(b.key), value: b.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter15) => (key) => {
        return filter15(keyToCid2(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a, b) => {
        return order(keyToCid2(a), keyToCid2(b));
      }
    ) : void 0
  };
}
var BlockstoreDatastoreAdapter = class extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const { key, value } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid2(key), value };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid2(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey3(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value, options) {
    await this.child.put(cidToKey3(cid), value, options);
  }
  async *putMany(blocks, options) {
    const output = pushable({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await (0, import_it_drain8.default)(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey3(block.key);
            const exists2 = await store.has(key, options);
            if (!exists2) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err2) {
        output.end(err2);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey3(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey3(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable({
      objectMode: true
    });
    (0, import_it_drain8.default)(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey3(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err2) => {
      out.end(err2);
    });
    return out;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-config-npm-0.5.1-7167d6fd7c-9.zip/node_modules/ipfs-core-config/src/repo.browser.js
function createRepo2(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(
      new LevelDatastore(`${repoPath}/blocks`, {
        prefix: "",
        version: 2
      })
    ),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/libp2p.js
init_define_process();
var import_dlv2 = __toESM(require_dlv_umd(), 1);
var import_err_code118 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-delegated-peer-routing-npm-2.0.2-f32e7dea14-9.zip/node_modules/@libp2p/delegated-peer-routing/dist/src/index.js
init_define_process();
var import_err_code63 = __toESM(require_err_code(), 1);
var import_any_signal3 = __toESM(require_any_signal(), 1);
var log46 = logger("libp2p-delegated-peer-routing");
var DEFAULT_TIMEOUT = 3e4;
var CONCURRENT_HTTP_REQUESTS = 4;
var DelegatedPeerRouting = class {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS
    });
    const { protocol, host, port } = client.getEndpointConfig();
    log46(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async findPeer(id, options = {}) {
    log46("findPeer starts: %p", id);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findPeer(id, options)) {
        if (event.name === "FINAL_PEER") {
          const peerInfo = {
            id: event.peer.id,
            multiaddrs: event.peer.multiaddrs,
            protocols: []
          };
          return peerInfo;
        }
      }
    } catch (err2) {
      log46.error("findPeer errored: %o", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log46("findPeer finished: %p", id);
    }
    throw (0, import_err_code63.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options = {}) {
    let cidOrPeerId;
    const cid = CID.asCID(key);
    if (cid != null) {
      cidOrPeerId = cid;
    } else {
      cidOrPeerId = peerIdFromBytes(key);
    }
    log46("getClosestPeers starts: %s", cidOrPeerId);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT;
    options.signal = (0, import_any_signal3.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.query(cidOrPeerId, options)) {
        if (event.name === "PEER_RESPONSE") {
          yield* event.closer.map((closer) => ({
            id: closer.id,
            multiaddrs: closer.multiaddrs,
            protocols: []
          }));
        }
      }
    } catch (err2) {
      log46.error("getClosestPeers errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log46("getClosestPeers finished: %b", key);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-delegated-content-routing-npm-2.0.2-884cce32f9-9.zip/node_modules/@libp2p/delegated-content-routing/dist/src/index.js
init_define_process();
var import_it_drain9 = __toESM(require_it_drain(), 1);
var import_err_code64 = __toESM(require_err_code(), 1);
var import_any_signal4 = __toESM(require_any_signal(), 1);
var log47 = logger("libp2p:delegated-content-routing");
var DEFAULT_TIMEOUT2 = 3e4;
var CONCURRENT_HTTP_REQUESTS2 = 4;
var CONCURRENT_HTTP_REFS_REQUESTS = 2;
var DelegatedContentRouting = class {
  constructor(client) {
    if (client == null) {
      throw new Error("missing ipfs http client");
    }
    this.client = client;
    this.started = false;
    this.abortController = new AbortController();
    this.httpQueue = new PQueue({
      concurrency: CONCURRENT_HTTP_REQUESTS2
    });
    this.httpQueueRefs = new PQueue({
      concurrency: CONCURRENT_HTTP_REFS_REQUESTS
    });
    const { protocol, host, port } = client.getEndpointConfig();
    log47(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.httpQueueRefs.clear();
    this.abortController.abort();
    this.abortController = new AbortController();
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    log47("findProviders starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return await onFinish.promise;
    });
    try {
      await onStart.promise;
      for await (const event of this.client.dht.findProvs(key, options)) {
        if (event.name === "PROVIDER") {
          yield* event.providers.map((prov) => {
            const peerInfo = {
              id: prov.id,
              protocols: [],
              multiaddrs: prov.multiaddrs
            };
            return peerInfo;
          });
        }
      }
    } catch (err2) {
      log47.error("findProviders errored:", err2);
      throw err2;
    } finally {
      onFinish.resolve();
      log47("findProviders finished: %c", key);
    }
  }
  async provide(key, options = {}) {
    log47("provide starts: %c", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueueRefs.add(async () => {
      await this.client.block.stat(key, options);
      await (0, import_it_drain9.default)(this.client.dht.provide(key, options));
    });
    log47("provide finished: %c", key);
  }
  async put(key, value, options = {}) {
    log47("put value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    await this.httpQueue.add(async () => {
      await (0, import_it_drain9.default)(this.client.dht.put(key, value, options));
    });
    log47("put value finished: %b", key);
  }
  async get(key, options = {}) {
    log47("get value start: %b", key);
    options.timeout = options.timeout ?? DEFAULT_TIMEOUT2;
    options.signal = (0, import_any_signal4.default)([this.abortController.signal].concat(options.signal != null ? [options.signal] : []));
    return await this.httpQueue.add(async () => {
      for await (const event of this.client.dht.get(key, options)) {
        if (event.name === "VALUE") {
          log47("get value finished: %b", key);
          return event.value;
        }
      }
      throw (0, import_err_code64.default)(new Error("Not found"), "ERR_NOT_FOUND");
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/multibases.js
init_define_process();
var LOAD_BASE = (name6) => Promise.reject(new Error(`No base found for "${name6}"`));
var Multibases = class {
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base of options.bases) {
      this.addBase(base);
    }
  }
  addBase(base) {
    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {
      throw new Error(`Codec already exists for codec "${base.name}"`);
    }
    this._basesByName[base.name] = base;
    this._basesByPrefix[base.prefix] = base;
  }
  removeBase(base) {
    delete this._basesByName[base.name];
    delete this._basesByPrefix[base.prefix];
  }
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {
      this.addBase(base);
    }
    return base;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/multicodecs.js
init_define_process();
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code7) {
    const table = typeof code7 === "string" ? this._codecsByName : this._codecsByCode;
    if (table[code7]) {
      return table[code7];
    }
    const codec = await this._loadCodec(code7);
    if (table[code7] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/multihashes.js
init_define_process();
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code7) {
    const table = typeof code7 === "string" ? this._hashersByName : this._hashersByCode;
    if (table[code7]) {
      return table[code7];
    }
    const hasher = await this._loadHasher(code7);
    if (table[code7] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/wantlist.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/configure.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/core.js
init_define_process();
var import_env = __toESM(require_env(), 1);
var import_http3 = __toESM(require_http(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/to-url-string.js
init_define_process();
function toUrlString(url) {
  try {
    url = multiaddrToUri(multiaddr(url));
  } catch (err2) {
  }
  url = url.toString();
  return url;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/agent.browser.js
init_define_process();
var agent_browser_default = () => {
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/core.js
var log48 = logger("ipfs-http-client:lib:error-handler");
var merge3 = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url;
  let opts = {};
  let agent;
  if (typeof options === "string" || isMultiaddr(options)) {
    url = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url = options;
  } else if (typeof options.url === "string" || isMultiaddr(options.url)) {
    url = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url = new URL(`${protocol}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url.pathname = opts.apiPath;
  } else if (url.pathname === "/" || url.pathname === void 0) {
    url.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default(url);
    agent = opts.agent || new Agent({
      keepAlive: true,
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(":", ""),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log48(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err2) {
    log48("Failed to parse error response", err2);
    msg = err2.message;
  }
  let error = new import_http3.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http3.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http3.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http3.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value) => {
  return typeof value === "string" ? parse_duration_default(value) : value;
};
var Client = class extends import_http3.default {
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value] of search) {
          if (value !== "undefined" && value !== "null" && key !== "signal") {
            out.append(kebabCase(key), value);
          }
          if (key === "timeout" && !isNaN(value)) {
            out.append(kebabCase(key), value);
          }
        }
        return out;
      },
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch.call(this, resource, merge3(options2, {
        method: "POST"
      }));
    };
  }
};
var HTTPError = import_http3.default.HTTPError;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/configure.js
var configure = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/to-url-search-params.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/mode-to-string.js
init_define_process();
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/parse-mtime.js
init_define_process();
var import_err_code65 = __toESM(require_err_code(), 1);
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code65.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime2(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/wantlist.js
var createWantlist2 = configure((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlist;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/wantlist-for-peer.js
init_define_process();
var createWantlistForPeer2 = configure((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlistForPeer;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/stat.js
init_define_process();
var createStat6 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: (res.Peers || []).map((str) => peerIdFromString(str)),
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/unwant.js
init_define_process();
var createUnwant2 = configure((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bitswap/index.js
function createBitswap(config2) {
  return {
    wantlist: createWantlist2(config2),
    wantlistForPeer: createWantlistForPeer2(config2),
    unwant: createUnwant2(config2),
    stat: createStat6(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/get.js
init_define_process();
var createGet5 = configure((api) => {
  async function get6(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get6;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/put.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/multipart-request.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-content.browser.js
init_define_process();
var import_err_code66 = __toESM(require_err_code(), 1);
var import_it_peekable5 = __toESM(require_it_peekable(), 1);
var import_browser_readablestream_to_it4 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_all5 = __toESM(require_it_all(), 1);
async function normaliseContent2(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it4.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable5.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await (0, import_it_all5.default)(peekable))]);
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code66.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/files/normalise-input-multiple.browser.js
function normaliseInput4(input) {
  return normaliseCandidateMultiple(input, normaliseContent2, true);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/mode-to-string.js
init_define_process();
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-utils-npm-0.16.1-fc7d5e84df-9.zip/node_modules/ipfs-core-utils/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path: path4, mode, mtime } of normaliseInput4(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path4 != null ? encodeURIComponent(path4) : void 0);
      const end = total + content.size;
      parts.push({ name: path4, start: total, end });
      total = end;
    } else if (path4 != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path4), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/abort-signal.js
init_define_process();
var import_any_signal5 = __toESM(require_any_signal(), 1);
function filter8(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal5.anySignal)(filter8(signals));
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/put.js
var createPut4 = configure((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err2) {
      if (options.format === "dag-pb") {
        return put(data, { ...options, format: "protobuf" });
      } else if (options.format === "dag-cbor") {
        return put(data, { ...options, format: "cbor" });
      }
      throw err2;
    }
    return CID.parse(res.Key);
  }
  return put;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/rm.js
init_define_process();
var createRm6 = configure((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = {
    cid: CID.parse(removed.Hash)
  };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/stat.js
init_define_process();
var createStat7 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Key), size: data.Size };
  }
  return stat;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/block/index.js
function createBlock(config2) {
  return {
    get: createGet5(config2),
    put: createPut4(config2),
    rm: createRm6(config2),
    stat: createStat7(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/add.js
init_define_process();
var createAdd4 = configure((api) => {
  async function add(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return add;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/clear.js
init_define_process();
var createClear2 = configure((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return clear;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/list.js
init_define_process();
var createList3 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return list;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/reset.js
init_define_process();
var createReset2 = configure((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return reset;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/rm.js
init_define_process();
var createRm7 = configure((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => multiaddr(ma)) };
  }
  return rm;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/bootstrap/index.js
function createBootstrap(config2) {
  return {
    add: createAdd4(config2),
    clear: createClear2(config2),
    list: createList3(config2),
    reset: createReset2(config2),
    rm: createRm7(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/profiles/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/profiles/apply.js
init_define_process();
var createApply = configure((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/profiles/list.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/object-to-camel.js
init_define_process();
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/profiles/list.js
var createList4 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/profiles/index.js
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList4(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/get.js
init_define_process();
var createGet6 = configure((api) => {
  const get6 = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get6;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/get-all.js
init_define_process();
var createGetAll = configure((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/replace.js
init_define_process();
var createReplace = configure((api) => {
  const replace = async (config2, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString(JSON.stringify(config2))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/set.js
init_define_process();
var createSet = configure((api) => {
  const set2 = async (key, value, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set2;
});
var encodeParam = (key, value) => {
  switch (typeof value) {
    case "boolean":
      return { arg: [key, value.toString()], bool: true };
    case "string":
      return { arg: [key, value] };
    default:
      return { arg: [key, JSON.stringify(value)], json: true };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/config/index.js
function createConfig2(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet6(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/export.js
init_define_process();
var createExport3 = configure((api) => {
  async function* dagExport(root, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: root.toString()
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/get.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/resolve.js
init_define_process();
var import_err_code67 = __toESM(require_err_code(), 1);
async function* resolve6(cid, path4, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path4.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code67.default)(new Error(`Could not resolve path "${path4}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code67.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/get.js
var import_it_first3 = __toESM(require_it_first(), 1);
var import_it_last10 = __toESM(require_it_last(), 1);
var import_err_code68 = __toESM(require_err_code(), 1);
var createGet7 = (codecs2, options) => {
  const fn = configure((api, opts) => {
    const getBlock = createGet5(opts);
    const get6 = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await (0, import_it_first3.default)(resolve6(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last10.default)(resolve6(cid, options2.path, codecs2, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code68.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs2.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get6;
  });
  return fn(options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/import.js
init_define_process();
var createImport3 = configure((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root: Root2 } of res.ndjson()) {
      if (Root2 !== void 0) {
        const { Cid: { "/": Cid }, PinErrorMsg } = Root2;
        yield {
          root: {
            cid: CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/put.js
init_define_process();
var createPut5 = (codecs2, options) => {
  const fn = configure((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs2.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/resolve.js
init_define_process();
var createResolve4 = configure((api) => {
  const resolve7 = async (ipfsPath3, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath3}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return { cid: CID.parse(data.Cid["/"]), remainderPath: data.RemPath };
  };
  return resolve7;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dag/index.js
function createDag(codecs2, config2) {
  return {
    export: createExport3(config2),
    get: createGet7(codecs2, config2),
    import: createImport3(config2),
    put: createPut5(codecs2, config2),
    resolve: createResolve4(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/find-peer.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/map-event.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/response-types.js
init_define_process();
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/map-event.js
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: peerIdFromString(event.ID),
      name: "PEER_RESPONSE",
      type: event.Type,
      messageType: 0,
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      id: event.ID ?? peerIdFromString(event.ID),
      multiaddrs: [],
      protocols: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: peerIdFromString(event.Responses[0].ID),
        multiaddrs: event.Responses[0].Addrs.map((addr) => multiaddr(addr)),
        protocols: []
      };
    }
    return {
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map((addr) => multiaddr(addr)), protocols: [] }))
    };
  }
  if (event.Type === Value) {
    return {
      name: "VALUE",
      type: event.Type,
      value: fromString(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID));
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: peerIdFromString(event.ID)
    };
  }
  throw new Error("Unknown DHT event type");
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/find-peer.js
var createFindPeer = configure((api) => {
  async function* findPeer2(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/find-provs.js
init_define_process();
var createFindProvs = configure((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/get.js
init_define_process();
var createGet8 = configure((api) => {
  async function* get6(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get6;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/provide.js
init_define_process();
var createProvide = configure((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/put.js
init_define_process();
var createPut6 = configure((api) => {
  async function* put(key, value, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/query.js
init_define_process();
var createQuery = configure((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dht/index.js
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet8(config2),
    provide: createProvide(config2),
    put: createPut6(config2),
    query: createQuery(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/diag/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/diag/cmds.js
init_define_process();
var createCmds = configure((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/diag/net.js
init_define_process();
var createNet = configure((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/diag/sys.js
init_define_process();
var createSys = configure((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/diag/index.js
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/chmod.js
init_define_process();
var createChmod2 = configure((api) => {
  async function chmod(path4, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/cp.js
init_define_process();
var createCp2 = configure((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src) => CID.asCID(src) ? `/ipfs/${src}` : src),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/flush.js
init_define_process();
var createFlush2 = configure((api) => {
  async function flush3(path4, options = {}) {
    if (!path4 || typeof path4 !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID.parse(data.Cid);
  }
  return flush3;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/ls.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/object-to-camel-with-metadata.js
init_define_process();
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/ls.js
var createLs4 = configure((api) => {
  async function* ls(path4, options = {}) {
    if (!path4) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID.asCID(path4) ? `/ipfs/${path4}` : path4,
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/mkdir.js
init_define_process();
var createMkdir2 = configure((api) => {
  async function mkdir(path4, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/mv.js
init_define_process();
var createMv2 = configure((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/read.js
init_define_process();
var import_source = __toESM(require_source(), 1);
var createRead2 = configure((api) => {
  async function* read2(path4, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/rm.js
init_define_process();
var import_http4 = __toESM(require_http(), 1);
var createRm8 = configure((api) => {
  async function rm(path4, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http4.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/stat.js
init_define_process();
var createStat8 = configure((api) => {
  async function stat(path4, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/touch.js
init_define_process();
var createTouch2 = configure((api) => {
  async function touch(path4, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/write.js
init_define_process();
var createWrite2 = configure((api) => {
  async function write3(path4, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime2(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write3;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/files/index.js
function createFiles2(config2) {
  return {
    chmod: createChmod2(config2),
    cp: createCp2(config2),
    flush: createFlush2(config2),
    ls: createLs4(config2),
    mkdir: createMkdir2(config2),
    mv: createMv2(config2),
    read: createRead2(config2),
    rm: createRm8(config2),
    stat: createStat8(config2),
    touch: createTouch2(config2),
    write: createWrite2(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/export.js
init_define_process();
var import_err_code69 = __toESM(require_err_code(), 1);
var createExport4 = configure((api) => {
  const exportKey = async (name6, password, options = {}) => {
    throw (0, import_err_code69.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/gen.js
init_define_process();
var createGen2 = configure((api) => {
  async function gen(name6, options = { type: "Ed25519" }) {
    const res = await api.post("key/gen", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name6,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/import.js
init_define_process();
var createImport4 = configure((api) => {
  async function importKey2(name6, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name6,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/info.js
init_define_process();
var import_err_code70 = __toESM(require_err_code(), 1);
var createInfo2 = configure((api) => {
  const info = async (name6, options = {}) => {
    throw (0, import_err_code70.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/list.js
init_define_process();
var createList5 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/rename.js
init_define_process();
var createRename2 = configure((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/rm.js
init_define_process();
var createRm9 = configure((api) => {
  async function rm(name6, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name6,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/key/index.js
function createKey(config2) {
  return {
    export: createExport4(config2),
    gen: createGen2(config2),
    import: createImport4(config2),
    info: createInfo2(config2),
    list: createList5(config2),
    rename: createRename2(config2),
    rm: createRm9(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/log/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/log/level.js
init_define_process();
var createLevel = configure((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/log/ls.js
init_define_process();
var createLs5 = configure((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/log/tail.js
init_define_process();
var createTail = configure((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/log/index.js
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs5(config2),
    tail: createTail(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/publish.js
init_define_process();
var createPublish2 = configure((api) => {
  async function publish(path4, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path4}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/resolve.js
init_define_process();
var createResolve5 = configure((api) => {
  async function* resolve7(path4, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve7;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/pubsub/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/pubsub/cancel.js
init_define_process();
var createCancel2 = configure((api) => {
  async function cancel(name6, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name6,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/pubsub/state.js
init_define_process();
var createState2 = configure((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/pubsub/subs.js
init_define_process();
var createSubs2 = configure((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/pubsub/index.js
function createPubsub(config2) {
  return {
    cancel: createCancel2(config2),
    state: createState2(config2),
    subs: createSubs2(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/name/index.js
function createName(config2) {
  return {
    publish: createPublish2(config2),
    resolve: createResolve5(config2),
    pubsub: createPubsub(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/data.js
init_define_process();
var createData2 = configure((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/get.js
init_define_process();
var createGet9 = configure((api) => {
  async function get6(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get6;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/links.js
init_define_process();
var createLinks2 = configure((api) => {
  async function links3(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID.parse(l.Hash)
    }));
  }
  return links3;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/new.js
init_define_process();
var createNew2 = configure((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return newObject;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/put.js
init_define_process();
var createPut7 = (codecs2, options) => {
  const fn = configure((api) => {
    const dagPut = createPut5(codecs2, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/stat.js
init_define_process();
var createStat9 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID.parse(output.Hash)
    };
  }
  return stat;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/add-link.js
init_define_process();
var createAddLink2 = configure((api) => {
  async function addLink2(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || "",
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return addLink2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/append-data.js
init_define_process();
var createAppendData2 = configure((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return appendData;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/rm-link.js
init_define_process();
var createRmLink2 = configure((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return rmLink;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/set-data.js
init_define_process();
var createSetData2 = configure((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`
        ],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return setData;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/patch/index.js
function createPatch(config2) {
  return {
    addLink: createAddLink2(config2),
    appendData: createAppendData2(config2),
    rmLink: createRmLink2(config2),
    setData: createSetData2(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/object/index.js
function createObject(codecs2, config2) {
  return {
    data: createData2(config2),
    get: createGet9(config2),
    links: createLinks2(config2),
    new: createNew2(config2),
    put: createPut7(codecs2, config2),
    stat: createStat9(config2),
    patch: createPatch(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/add-all.js
init_define_process();
var createAddAll3 = configure((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path: path4, recursive: recursive2, metadata } of normaliseInput(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path4,
          recursive: recursive2,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID.parse(cid);
          }
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return addAll;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/add.js
init_define_process();
var import_it_last11 = __toESM(require_it_last(), 1);
function createAdd5(config2) {
  const all11 = createAddAll3(config2);
  return configure(() => {
    async function add(path4, options = {}) {
      return (0, import_it_last11.default)(all11([{
        path: path4,
        ...options
      }], options));
    }
    return add;
  })(config2);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/ls.js
init_define_process();
function toPin3(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs6 = configure((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path4) => `${path4}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin3(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin3(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/rm-all.js
init_define_process();
var createRmAll2 = configure((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path: path4, recursive: recursive2 } of normaliseInput(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path4}`);
      if (recursive2 != null)
        searchParams.set("recursive", String(recursive2));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path4}`,
          recursive: recursive2
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID.parse(cid));
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return rmAll;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/rm.js
init_define_process();
var import_it_last12 = __toESM(require_it_last(), 1);
var createRm10 = (config2) => {
  const all11 = createRmAll2(config2);
  return configure(() => {
    async function rm(path4, options = {}) {
      return (0, import_it_last12.default)(all11([{
        path: path4,
        ...options
      }], options));
    }
    return rm;
  })(config2);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/add.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/utils.js
init_define_process();
var decodePin = ({ Name: name6, Status: status, Cid: cid }) => {
  return {
    cid: CID.parse(cid),
    name: name6,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID = (cid) => {
  if (CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name6, status, all: all11 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name6,
    force: all11 ? true : void 0
  });
  if (cid) {
    for (const value of cid) {
      query.append("cid", encodeCID(value));
    }
  }
  if (status) {
    for (const value of status) {
      query.append("status", value);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name6, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID(cid),
    service: encodeService(service),
    name: name6,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/add.js
function createAdd6(client) {
  async function add(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({ cid, ...query })
    });
    return decodePin(await response.json());
  }
  return add;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/ls.js
init_define_process();
function createLs7(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/rm.js
init_define_process();
function createRm11(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/rm-all.js
init_define_process();
function createRmAll3(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/add.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/utils.js
init_define_process();
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/add.js
function createAdd7(client) {
  async function add(name6, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [name6, encodeEndpoint(endpoint), key]
      }),
      headers
    });
  }
  return add;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/ls.js
init_define_process();
function createLs8(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/rm.js
init_define_process();
function createRm12(client) {
  async function rm(name6, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({
        arg: name6
      })
    });
  }
  return rm;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/service/index.js
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd7(client),
    ls: createLs8(client),
    rm: createRm12(client)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/remote/index.js
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd6(client),
    ls: createLs7(client),
    rm: createRm11(client),
    rmAll: createRmAll3(client),
    service: createService(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pin/index.js
function createPin(config2) {
  return {
    addAll: createAddAll3(config2),
    add: createAdd5(config2),
    ls: createLs6(config2),
    rmAll: createRmAll2(config2),
    rm: createRm10(config2),
    remote: createRemote(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/ls.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/lib/http-rpc-wire-format.js
init_define_process();
var rpcArrayToTextArray = (strings2) => {
  if (Array.isArray(strings2)) {
    return strings2.map(rpcToText);
  }
  return strings2;
};
var rpcToText = (mb) => toString(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url.decode(mb);
var rpcToBigInt = (mb) => BigInt(`0x${toString(base64url.decode(mb), "base16")}`);
var textToUrlSafeRpc = (text) => base64url.encode(fromString(text));

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/ls.js
var createLs9 = configure((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/peers.js
init_define_process();
var createPeers = configure((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/publish.js
init_define_process();
var createPublish3 = configure((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/subscribe.js
init_define_process();
var log49 = logger("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve7, reject) => {
        done = resolve7;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err2) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err2);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: (message2) => {
            if (!handler) {
              return;
            }
            if (typeof handler === "function") {
              handler(message2);
              return;
            }
            if (typeof handler.handleEvent === "function") {
              handler.handleEvent(message2);
            }
          },
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log49;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        if (msg.from != null && msg.seqno != null) {
          onMessage({
            type: "signed",
            from: peerIdFromString(msg.from),
            data: rpcToBytes(msg.data),
            sequenceNumber: rpcToBigInt(msg.seqno),
            topic: rpcToText(msg.topicIDs[0]),
            key: rpcToBytes(msg.key ?? "u"),
            signature: rpcToBytes(msg.signature ?? "u")
          });
        } else {
          onMessage({
            type: "unsigned",
            data: rpcToBytes(msg.data),
            topic: rpcToText(msg.topicIDs[0])
          });
        }
      } catch (err2) {
        err2.message = `Failed to parse pubsub message: ${err2.message}`;
        onError(err2, false, msg);
      }
    }
  } catch (err2) {
    if (!isAbortError(err2)) {
      onError(err2, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/unsubscribe.js
init_define_process();
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js
init_define_process();
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{ handler, controller }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/pubsub/index.js
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs9(config2),
    peers: createPeers(config2),
    publish: createPublish3(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/refs/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/refs/local.js
init_define_process();
var createLocal2 = configure((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/refs/index.js
var createRefs2 = configure((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, {
    local: createLocal2(opts)
  });
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/repo/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/repo/gc.js
init_define_process();
var createGc2 = configure((api) => {
  async function* gc2(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/repo/stat.js
init_define_process();
var createStat10 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/repo/version.js
init_define_process();
var createVersion3 = configure((api) => {
  async function version3(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version3;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/repo/index.js
function createRepo3(config2) {
  return {
    gc: createGc2(config2),
    stat: createStat10(config2),
    version: createVersion3(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/stats/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/stats/bw.js
init_define_process();
var createBw2 = configure((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/stats/index.js
function createStats(config2) {
  return {
    bitswap: createStat6(config2),
    repo: createStat10(config2),
    bw: createBw2(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/addrs.js
init_define_process();
var createAddrs = configure((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id: peerIdFromString(id),
      addrs: (Addrs[id] || []).map((a) => multiaddr(a))
    }));
  }
  return addrs;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/connect.js
init_define_process();
var createConnect = configure((api) => {
  async function connect2(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/disconnect.js
init_define_process();
var createDisconnect = configure((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/local-addrs.js
init_define_process();
var createLocalAddrs = configure((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => multiaddr(a));
  }
  return localAddrs;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/peers.js
init_define_process();
var createPeers2 = configure((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: multiaddr(peer.Addr),
        peer: peerIdFromString(peer.Peer),
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/swarm/index.js
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/add.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/add-all.js
init_define_process();
var createAddAll4 = configure((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [void 0, void 0];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts, progress) => parts ? [void 0, createOnUploadProgress(total, parts, progress)] : [progress, void 0];
var createOnUploadProgress = (size, parts, progress) => {
  let index = 0;
  const count = parts.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const { start, end, name: name6 } = parts[index];
      if (position < end) {
        progress(position - start, name6);
        break;
      } else {
        progress(end - start, name6);
        index += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name6, hash: hash3, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name6,
    cid: CID.parse(hash3),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/add.js
var import_it_last13 = __toESM(require_it_last(), 1);
function createAdd8(options) {
  const all11 = createAddAll4(options);
  return configure(() => {
    async function add(input, options2 = {}) {
      return await (0, import_it_last13.default)(all11(normaliseInput2(input), options2));
    }
    return add;
  })(options);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/cat.js
init_define_process();
var createCat2 = configure((api) => {
  async function* cat(path4, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/commands.js
init_define_process();
var createCommands = configure((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/dns.js
init_define_process();
var createDns2 = configure((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/get-endpoint-config.js
init_define_process();
var createGetEndpointConfig = configure((api) => {
  return () => {
    const url = new URL(api.opts.base || "");
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      "api-path": url.pathname
    };
  };
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/get.js
init_define_process();
var createGet10 = configure((api) => {
  async function* get6(path4, options = {}) {
    const opts = {
      arg: `${path4 instanceof Uint8Array ? CID.decode(path4) : path4}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get6;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/id.js
init_define_process();
var createId2 = configure((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = {
      ...objectToCamel(data)
    };
    output.id = peerIdFromString(output.id);
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => multiaddr(ma));
    }
    return output;
  }
  return id;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/is-online.js
init_define_process();
var createIsOnline2 = (options) => {
  const id = createId2(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/ls.js
init_define_process();
var createLs10 = configure((api, opts) => {
  async function* ls(path4, options = {}) {
    const pathStr = `${path4 instanceof Uint8Array ? CID.decode(path4) : path4}`;
    async function mapLink(link) {
      let hash3 = link.Hash;
      if (hash3.includes("/")) {
        const ipfsPath3 = hash3.startsWith("/ipfs/") ? hash3 : `/ipfs/${hash3}`;
        const stats = await createStat8(opts)(ipfsPath3);
        hash3 = stats.cid;
      } else {
        hash3 = CID.parse(hash3);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash3,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = {
          secs: link.Mtime
        };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links3 = result.Links;
      if (!Array.isArray(links3)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links3.length) {
        yield mapLink(result);
        return;
      }
      yield* links3.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/mount.js
init_define_process();
var createMount = configure((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/ping.js
init_define_process();
var createPing = configure((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/resolve.js
init_define_process();
var createResolve6 = configure((api) => {
  async function resolve7(path4, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path4,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve7;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/start.js
init_define_process();
var import_err_code71 = __toESM(require_err_code(), 1);
var createStart2 = configure((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code71.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/stop.js
init_define_process();
var createStop2 = configure((api) => {
  async function stop2(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop2;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/version.js
init_define_process();
var createVersion4 = configure((api) => {
  async function version3(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version3;
});

// ../../../../../Users/z/.yarn/berry/cache/ipfs-http-client-npm-58.0.1-efd22edfc0-9.zip/node_modules/ipfs-http-client/src/index.js
var import_glob_source = __toESM(require_glob_source(), 1);
var import_url_source = __toESM(require_url_source(), 1);
function create4(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base) => multibaseCodecs.push(base));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [src_exports, esm_exports, esm_exports2, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd8(options),
    addAll: createAddAll4(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat2(options),
    commands: createCommands(options),
    config: createConfig2(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns2(options),
    files: createFiles2(options),
    get: createGet10(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId2(options),
    isOnline: createIsOnline2(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs10(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs2(options),
    repo: createRepo3(options),
    resolve: createResolve6(options),
    start: createStart2(options),
    stats: createStats(options),
    stop: createStop2(options),
    swarm: createSwarm(options),
    version: createVersion4(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/libp2p.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/peer-routing.js
init_define_process();
var import_err_code73 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/errors.js
init_define_process();
var messages2;
(function(messages3) {
  messages3["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages3["DHT_DISABLED"] = "DHT is not available";
  messages3["PUBSUB_DISABLED"] = "PubSub is not available";
  messages3["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages3["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages3["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages3["NOT_FOUND"] = "Not found";
})(messages2 || (messages2 = {}));
var codes;
(function(codes3) {
  codes3["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes3["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes3["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes3["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes3["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes3["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes3["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes3["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes3["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes3["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes3["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes3["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes3["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes3["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes3["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes3["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes3["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes3["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes3["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes3["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes3["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes3["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes3["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes3["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes3["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes3["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes3["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes3["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes3["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes3["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes3["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes3["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes3["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes3["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes3["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes3["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes3["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes3["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes3["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes3["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes3["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes3["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes3["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes3["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes3["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes3["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes3["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes3["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes3["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes3["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes3["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes3["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes3["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes3["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes3["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes3["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes3["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes3["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes3["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes3["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes3["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes3["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes3["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes3["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes3["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
})(codes || (codes = {}));

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/content-routing/utils.js
init_define_process();
var import_err_code72 = __toESM(require_err_code(), 1);
var import_it_filter8 = __toESM(require_it_filter(), 1);
var import_it_map12 = __toESM(require_it_map(), 1);
async function* storeAddresses(source, peerStore) {
  yield* (0, import_it_map12.default)(source, async (peer) => {
    await peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return (0, import_it_filter8.default)(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw (0, import_err_code72.default)(new Error("not found"), "NOT_FOUND");
  }
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/peer-routing.js
var import_timeout_abort_controller4 = __toESM(require_timeout_abort_controller(), 1);
var import_it_merge3 = __toESM(require_it_merge(), 1);
var import_it_first4 = __toESM(require_it_first(), 1);
var import_it_drain10 = __toESM(require_it_drain(), 1);
var import_it_filter9 = __toESM(require_it_filter(), 1);
var import_set_delayed_interval = __toESM(require_src3(), 1);
var import_events = __toESM(require_events(), 1);
var log50 = logger("libp2p:peer-routing");
var DefaultPeerRouting = class {
  constructor(components, init) {
    this.components = components;
    this.routers = init.routers;
    this.refreshManagerInit = init.refreshManager ?? {};
    this.started = false;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {
      return;
    }
    this.timeoutId = (0, import_set_delayed_interval.setDelayedInterval)(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);
    this.started = true;
  }
  async _findClosestPeersTask() {
    if (this.abortController != null) {
      return;
    }
    try {
      this.abortController = new import_timeout_abort_controller4.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
      try {
        (0, import_events.setMaxListeners)?.(Infinity, this.abortController.signal);
      } catch {
      }
      await (0, import_it_drain10.default)(this.getClosestPeers(this.components.getPeerId().toBytes(), { signal: this.abortController.signal }));
    } catch (err2) {
      log50.error(err2);
    } finally {
      this.abortController?.clear();
      this.abortController = void 0;
    }
  }
  async stop() {
    (0, import_set_delayed_interval.clearDelayedInterval)(this.timeoutId);
    this.abortController?.abort();
    this.started = false;
  }
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code73.default)(new Error("No peer routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.getPeerId().toString()) {
      throw (0, import_err_code73.default)(new Error("Should not try to find self"), codes.ERR_FIND_SELF);
    }
    const output = await pipe((0, import_it_merge3.default)(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err2) {
        log50.error(err2);
      }
    }())), (source) => (0, import_it_filter9.default)(source, Boolean), (source) => storeAddresses(source, this.components.getPeerStore()), async (source) => await (0, import_it_first4.default)(source));
    if (output != null) {
      return output;
    }
    throw (0, import_err_code73.default)(new Error(messages2.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code73.default)(new Error("No peer routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe((0, import_it_merge3.default)(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.getPeerStore()), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/content-routing/index.js
init_define_process();
var import_err_code74 = __toESM(require_err_code(), 1);
var import_it_drain11 = __toESM(require_it_drain(), 1);
var import_it_merge4 = __toESM(require_it_merge(), 1);
var CompoundContentRouting = class {
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code74.default)(new Error("No content this.routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe((0, import_it_merge4.default)(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.getPeerStore()), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code74.default)(new Error("No content routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
  }
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code74.default)(new Error(messages2.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    const dht = this.components.getDHT();
    if (dht != null) {
      await (0, import_it_drain11.default)(dht.put(key, value, options));
    }
  }
  async get(key, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code74.default)(new Error(messages2.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    const dht = this.components.getDHT();
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
    }
    throw (0, import_err_code74.default)(new Error(messages2.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getMany(key, nVals, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code74.default)(new Error(messages2.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    if (nVals == null || nVals === 0) {
      return;
    }
    let gotValues = 0;
    const dht = this.components.getDHT();
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          yield { from: event.from, val: event.value };
          gotValues++;
          if (gotValues === nVals) {
            break;
          }
        }
      }
    }
    if (gotValues === 0) {
      throw (0, import_err_code74.default)(new Error(messages2.NOT_FOUND), codes.ERR_NOT_FOUND);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/get-peer.js
init_define_process();
var import_err_code75 = __toESM(require_err_code(), 1);
function peerIdFromMultiaddr(ma) {
  const idStr = ma.getPeerId();
  if (idStr == null) {
    throw (0, import_err_code75.default)(new Error(`${ma.toString()} does not have a valid peer type`), codes.ERR_INVALID_MULTIADDR);
  }
  try {
    return peerIdFromString(idStr);
  } catch (err2) {
    throw (0, import_err_code75.default)(new Error(`${ma.toString()} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
  }
}
function getPeer(peer) {
  if (isPeerId(peer)) {
    return {
      id: peer,
      multiaddrs: [],
      protocols: []
    };
  }
  if (typeof peer === "string") {
    peer = multiaddr(peer);
  }
  let addr;
  if (isMultiaddr(peer)) {
    addr = peer;
    peer = peerIdFromMultiaddr(peer);
  }
  return {
    id: peer,
    multiaddrs: addr != null ? [addr] : [],
    protocols: []
  };
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/address-manager/index.js
init_define_process();
var defaultAddressFilter = (addrs) => addrs;
var DefaultAddressManager = class extends EventEmitter {
  constructor(components, init) {
    super();
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = new Set(listen.map((ma) => ma.toString()));
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Set();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
  }
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  getObservedAddrs() {
    return Array.from(this.observed).map((a) => multiaddr(a));
  }
  addObservedAddr(addr) {
    let ma = multiaddr(addr);
    const remotePeer = ma.getPeerId();
    if (remotePeer != null) {
      const remotePeerId = peerIdFromString(remotePeer);
      if (remotePeerId.equals(this.components.getPeerId())) {
        ma = ma.decapsulate(multiaddr(`/p2p/${this.components.getPeerId().toString()}`));
      }
    }
    const addrString = ma.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.add(addrString);
    this.dispatchEvent(new CustomEvent("change:addresses"));
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.getTransportManager().getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(this.getObservedAddrs().map((ma) => ma.toString()));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.getPeerId().toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.getPeerId().toString()}`);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/index.js
init_define_process();
var import_err_code76 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/latency-monitor.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/visibility-change-emitter.js
init_define_process();
var log51 = logger("libp2p:connection-manager:latency-monitor:visibility-change-emitter");
var VisibilityChangeEmitter = class extends EventEmitter {
  constructor() {
    super();
    this.hidden = "hidden";
    this.visibilityChange = "visibilityChange";
    if (globalThis.document != null) {
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
  }
  _initializeVisibilityVarNames() {
    let hidden = "hidden";
    let visibilityChange = "visibilitychange";
    if (typeof globalThis.document.hidden !== "undefined") {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof globalThis.document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof globalThis.document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof globalThis.document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    this.hidden = hidden;
    this.visibilityChange = visibilityChange;
  }
  _addVisibilityChangeListener() {
    if (typeof globalThis.document.addEventListener === "undefined" || typeof document[this.hidden] === "undefined") {
      log51("Checking page visibility requires a browser that supports the Page Visibility API.");
    } else {
      globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
    }
  }
  isVisible() {
    if (this.hidden === void 0 || document[this.hidden] === void 0) {
      return void 0;
    }
    return document[this.hidden] == null;
  }
  _handleVisibilityChange() {
    const visible = globalThis.document[this.hidden] === false;
    log51(visible ? "Page Visible" : "Page Hidden");
    this.dispatchEvent(new CustomEvent("visibilityChange", {
      detail: visible
    }));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/latency-monitor.js
var log52 = logger("libp2p:connection-manager:latency-monitor");
var LatencyMonitor = class extends EventEmitter {
  constructor(init = {}) {
    super();
    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init;
    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500;
    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;
    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs;
    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;
    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs ?? 5 * 1e3;
    log52("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs);
    if (this.dataEmitIntervalMs != null) {
      log52("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs);
    } else {
      log52("Not emitting summaries");
    }
    this.asyncTestFn = asyncTestFn;
    if (globalThis.process?.hrtime != null) {
      log52("Using process.hrtime for timing");
      this.now = globalThis.process.hrtime;
      this.getDeltaMS = (startTime) => {
        const hrtime = this.now(startTime);
        return hrtime[0] * 1e3 + hrtime[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance?.now != null) {
      log52("Using performance.now for timing");
      this.now = window.performance.now.bind(window.performance);
      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
    } else {
      log52("Using Date.now for timing");
      this.now = Date.now;
      this.getDeltaMS = (startTime) => this.now() - startTime;
    }
    this.latencyData = this.initLatencyData();
  }
  start() {
    if (isBrowser2()) {
      this.visibilityChangeEmitter = new VisibilityChangeEmitter();
      this.visibilityChangeEmitter.addEventListener("visibilityChange", (evt) => {
        const { detail: pageInFocus } = evt;
        if (pageInFocus) {
          this._startTimers();
        } else {
          this._emitSummary();
          this._stopTimers();
        }
      });
    }
    if (this.visibilityChangeEmitter?.isVisible() === true) {
      this._startTimers();
    }
  }
  stop() {
    this._stopTimers();
  }
  _startTimers() {
    if (this.checkLatencyID != null) {
      return;
    }
    this.checkLatency();
    if (this.dataEmitIntervalMs != null) {
      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
      if (typeof this.emitIntervalID.unref === "function") {
        this.emitIntervalID.unref();
      }
    }
  }
  _stopTimers() {
    if (this.checkLatencyID != null) {
      clearTimeout(this.checkLatencyID);
      this.checkLatencyID = void 0;
    }
    if (this.emitIntervalID != null) {
      clearInterval(this.emitIntervalID);
      this.emitIntervalID = void 0;
    }
  }
  _emitSummary() {
    const summary = this.getSummary();
    if (summary.events > 0) {
      this.dispatchEvent(new CustomEvent("data", {
        detail: summary
      }));
    }
  }
  getSummary() {
    const latency = {
      events: this.latencyData.events,
      minMs: this.latencyData.minMs,
      maxMs: this.latencyData.maxMs,
      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,
      lengthMs: this.getDeltaMS(this.latencyData.startTime)
    };
    this.latencyData = this.initLatencyData();
    log52.trace("Summary: %O", latency);
    return latency;
  }
  checkLatency() {
    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;
    const localData = {
      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),
      startTime: this.now()
    };
    const cb = () => {
      if (this.checkLatencyID == null) {
        return;
      }
      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;
      this.checkLatency();
      this.latencyData.events++;
      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);
      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);
      this.latencyData.totalMs += deltaMS;
      log52.trace("MS: %s Data: %O", deltaMS, this.latencyData);
    };
    log52.trace("localData: %O", localData);
    this.checkLatencyID = setTimeout(() => {
      if (this.asyncTestFn != null) {
        localData.deltaOffset = 0;
        localData.startTime = this.now();
        this.asyncTestFn(cb);
      } else {
        localData.deltaOffset -= 1;
        cb();
      }
    }, localData.deltaOffset);
    if (typeof this.checkLatencyID.unref === "function") {
      this.checkLatencyID.unref();
    }
  }
  initLatencyData() {
    return {
      startTime: this.now(),
      minMs: Number.POSITIVE_INFINITY,
      maxMs: Number.NEGATIVE_INFINITY,
      events: 0,
      totalMs: 0
    };
  }
};
function isBrowser2() {
  return typeof globalThis.window !== "undefined";
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/index.js
var import_retimer = __toESM(require_retimer(), 1);
var import_events6 = __toESM(require_events(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-interface-connection-npm-3.0.2-bdde13ed5c-9.zip/node_modules/@libp2p/interface-connection/dist/src/status.js
init_define_process();
var OPEN = "OPEN";
var CLOSING = "CLOSING";
var CLOSED = "CLOSED";

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/map.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/util.js
init_define_process();
function mapIterable(iter, map18) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map18(val)
      };
    }
  };
  return iterator;
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map18) {
    this.map = /* @__PURE__ */ new Map();
    if (map18 != null) {
      for (const [key, value] of map18.entries()) {
        this.map.set(key.toString(), value);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), value);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/set.js
init_define_process();
var PeerSet = class {
  constructor(set2) {
    this.set = /* @__PURE__ */ new Set();
    if (set2 != null) {
      for (const key of set2) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-collections-npm-2.2.0-c19231ee71-9.zip/node_modules/@libp2p/peer-collections/dist/src/list.js
init_define_process();
var PeerList = class {
  constructor(list) {
    this.list = [];
    if (list != null) {
      for (const value of list) {
        this.list.push(value.toString());
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return peerIdFromString(val[1]);
    });
  }
  concat(list) {
    const output = new PeerList(this);
    for (const value of list) {
      output.push(value);
    }
    return output;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], peerIdFromString(val[1])];
    });
  }
  every(predicate) {
    return this.list.every((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  filter(predicate) {
    const output = new PeerList();
    this.list.forEach((str, index) => {
      const peerId = peerIdFromString(str);
      if (predicate(peerId, index, this)) {
        output.push(peerId);
      }
    });
    return output;
  }
  find(predicate) {
    const str = this.list.find((str2, index) => {
      return predicate(peerIdFromString(str2), index, this);
    });
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  findIndex(predicate) {
    return this.list.findIndex((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((str, index) => {
      predicate(peerIdFromString(str), index, this);
    });
  }
  includes(peerId) {
    return this.list.includes(peerId.toString());
  }
  indexOf(peerId) {
    return this.list.indexOf(peerId.toString());
  }
  pop() {
    const str = this.list.pop();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  push(...peerIds) {
    for (const peerId of peerIds) {
      this.list.push(peerId.toString());
    }
  }
  shift() {
    const str = this.list.shift();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i = peerIds.length - 1; i > -1; i--) {
      len = this.list.unshift(peerIds[i].toString());
    }
    return len;
  }
  get length() {
    return this.list.length;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/index.js
var import_timeout_abort_controller5 = __toESM(require_timeout_abort_controller(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-interface-peer-store-npm-1.2.2-9ebcd3e99f-9.zip/node_modules/@libp2p/interface-peer-store/dist/src/tags.js
init_define_process();
var KEEP_ALIVE = "keep-alive";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/index.js
var log53 = logger("libp2p:connection-manager");
var defaultOptions16 = {
  maxConnections: Infinity,
  minConnections: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2e3,
  autoDialInterval: 1e4,
  movingAverageInterval: 6e4
};
var METRICS_SYSTEM = "libp2p";
var METRICS_COMPONENT = "connection-manager";
var STARTUP_RECONNECT_TIMEOUT = 6e4;
var DefaultConnectionManager = class extends EventEmitter {
  constructor(init) {
    super();
    this.components = new Components();
    this.opts = merge_options_default.call({ ignoreUndefined: true }, defaultOptions16, init);
    if (this.opts.maxConnections < this.opts.minConnections) {
      throw (0, import_err_code76.default)(new Error("Connection Manager maxConnections must be greater than minConnections"), codes.ERR_INVALID_PARAMETERS);
    }
    log53("options: %o", this.opts);
    this.connections = /* @__PURE__ */ new Map();
    this.started = false;
    this._checkMetrics = this._checkMetrics.bind(this);
    this.latencyMonitor = new LatencyMonitor({
      latencyCheckIntervalMs: init.pollInterval,
      dataEmitIntervalMs: init.pollInterval
    });
    try {
      (0, import_events6.setMaxListeners)?.(Infinity, this);
    } catch {
    }
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;
    this.dialTimeout = init.dialTimeout ?? 3e4;
  }
  init(components) {
    this.components = components;
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "connections",
      label: "direction",
      value: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-total",
      label: "protocol",
      value: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.components.getMetrics()?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-per-connection-90th-percentile",
      label: "protocol",
      value: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.components.getMetrics() != null) {
      this.timer = this.timer ?? (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
    }
    this.latencyMonitor.start();
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
    this.latencyMonitor.addEventListener("data", this._onLatencyMeasure);
    this.started = true;
    log53("started");
  }
  async afterStart() {
    this.components.getUpgrader().addEventListener("connection", this.onConnect);
    this.components.getUpgrader().addEventListener("connectionEnd", this.onDisconnect);
    void Promise.resolve().then(async () => {
      const keepAlivePeers = [];
      for (const peer of await this.components.getPeerStore().all()) {
        const tags = await this.components.getPeerStore().getTags(peer.id);
        const hasKeepAlive = tags.filter((tag) => tag.name === KEEP_ALIVE).length > 0;
        if (hasKeepAlive) {
          keepAlivePeers.push(peer.id);
        }
      }
      this.connectOnStartupController?.clear();
      this.connectOnStartupController = new import_timeout_abort_controller5.TimeoutController(this.startupReconnectTimeout);
      try {
        (0, import_events6.setMaxListeners)?.(Infinity, this.connectOnStartupController.signal);
      } catch {
      }
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer, {
          signal: this.connectOnStartupController?.signal
        }).catch((err2) => {
          log53.error(err2);
        });
      }));
    }).catch((err2) => {
      log53.error(err2);
    }).finally(() => {
      this.connectOnStartupController?.clear();
    });
  }
  async beforeStop() {
    this.connectOnStartupController?.abort();
    this.components.getUpgrader().removeEventListener("connection", this.onConnect);
    this.components.getUpgrader().removeEventListener("connectionEnd", this.onDisconnect);
  }
  async stop() {
    this.timer?.clear();
    this.latencyMonitor.removeEventListener("data", this._onLatencyMeasure);
    this.latencyMonitor.stop();
    this.started = false;
    await this._close();
    log53("stopped");
  }
  async _close() {
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err2) {
            log53.error(err2);
          }
        })());
      }
    }
    log53("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
  }
  async _checkMetrics() {
    const metrics = this.components.getMetrics();
    if (metrics != null) {
      try {
        const movingAverages = metrics.getGlobal().getMovingAverages();
        const received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxReceivedData", received);
        const sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxSentData", sent);
        const total = received + sent;
        await this._checkMaxLimit("maxData", total);
        log53.trace("metrics update", total);
      } finally {
        this.timer = (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
      }
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err2) => {
      log53.error(err2);
    });
  }
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const peerIdStr = peerId.toString();
    const storedConns = this.connections.get(peerIdStr);
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      this.connections.set(peerIdStr, [connection]);
    }
    if (peerId.publicKey != null) {
      await this.components.getPeerStore().keyBook.set(peerId, peerId.publicKey);
    }
    const numConnections = this.getConnections().length;
    const toPrune = numConnections - this.opts.maxConnections;
    await this._checkMaxLimit("maxConnections", numConnections, toPrune);
    this.dispatchEvent(new CustomEvent("peer:connect", { detail: connection }));
  }
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer.toString();
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.dispatchEvent(new CustomEvent("peer:disconnect", { detail: connection }));
      this.components.getMetrics()?.onPeerDisconnected(connection.remotePeer);
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId.toString()) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  async openConnection(peerId, options = {}) {
    log53("dial to %p", peerId);
    const existingConnections = this.getConnections(peerId);
    if (existingConnections.length > 0) {
      log53("had an existing connection to %p", peerId);
      return existingConnections[0];
    }
    let timeoutController;
    if (options?.signal == null) {
      timeoutController = new import_timeout_abort_controller5.TimeoutController(this.dialTimeout);
      options.signal = timeoutController.signal;
      try {
        (0, import_events6.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      const connection = await this.components.getDialer().dial(peerId, options);
      let peerConnections = this.connections.get(peerId.toString());
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(peerId.toString(), peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
    }
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId.toString()) ?? [];
    await Promise.all(connections.map(async (connection) => {
      return await connection.close();
    }));
  }
  getAll(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code76.default)(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
    }
    const id = peerId.toString();
    const connections = this.connections.get(id);
    if (connections != null) {
      return connections.filter((connection) => connection.stat.status === OPEN);
    }
    return [];
  }
  _onLatencyMeasure(evt) {
    const { detail: summary } = evt;
    this._checkMaxLimit("maxEventLoopDelay", summary.avgMs, 1).catch((err2) => {
      log53.error(err2);
    });
  }
  async _checkMaxLimit(name6, value, toPrune = 1) {
    const limit = this.opts[name6];
    log53.trace("checking limit of %s. current value: %d of %d", name6, value, limit);
    if (value > limit) {
      log53("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)", this.components.getPeerId(), name6, value, limit, toPrune);
      await this._maybePruneConnections(toPrune);
    }
  }
  async _maybePruneConnections(toPrune) {
    const connections = this.getConnections();
    if (connections.length <= this.opts.minConnections || toPrune < 1) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      const tags = await this.components.getPeerStore().getTags(remotePeer);
      peerValues.set(remotePeer, tags.reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log53("too many connections open - closing a connection to %p", connection.remotePeer);
      toClose.push(connection);
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err2) {
        log53.error(err2);
      }
      this.onDisconnect(new CustomEvent("connectionEnd", {
        detail: connection
      }));
    }));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
init_define_process();
var import_retimer2 = __toESM(require_retimer(), 1);
var import_it_all6 = __toESM(require_it_all(), 1);
var import_it_filter10 = __toESM(require_it_filter(), 1);
var import_it_sort2 = __toESM(require_it_sort(), 1);
var log54 = logger("libp2p:connection-manager:auto-dialler");
var defaultOptions17 = {
  enabled: true,
  minConnections: 0,
  autoDialInterval: 1e4
};
var AutoDialler = class {
  constructor(components, init) {
    this.components = components;
    this.options = merge_options_default.call({ ignoreUndefined: true }, defaultOptions17, init);
    this.running = false;
    this._autoDial = this._autoDial.bind(this);
    log54("options: %j", this.options);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.options.enabled) {
      log54("not enabled");
      return;
    }
    this.running = true;
    void this._autoDial().catch((err2) => {
      log54.error("could start autodial", err2);
    });
    log54("started");
  }
  async stop() {
    if (!this.options.enabled) {
      log54("not enabled");
      return;
    }
    this.running = false;
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    log54("stopped");
  }
  async _autoDial() {
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    const minConnections = this.options.minConnections;
    if (this.components.getConnectionManager().getConnections().length >= minConnections) {
      this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
      return;
    }
    const allPeers = await this.components.getPeerStore().all();
    const peers = await pipe(
      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),
      (source) => (0, import_it_filter10.default)(source, (peer) => !peer.id.equals(this.components.getPeerId())),
      (source) => (0, import_it_sort2.default)(source, (a, b) => {
        if (b.protocols.length > a.protocols.length) {
          return 1;
        } else if (b.id.publicKey != null && a.id.publicKey == null) {
          return 1;
        }
        return -1;
      }),
      async (source) => await (0, import_it_all6.default)(source)
    );
    for (let i = 0; this.running && i < peers.length && this.components.getConnectionManager().getConnections().length < minConnections; i++) {
      if (!this.running) {
        return;
      }
      const peer = peers[i];
      if (this.components.getConnectionManager().getConnections(peer.id).length === 0) {
        log54("connecting to a peerStore stored peer %p", peer.id);
        try {
          await this.components.getConnectionManager().openConnection(peer.id);
        } catch (err2) {
          log54.error("could not connect to peerStore stored peer", err2);
        }
      }
    }
    if (!this.running) {
      return;
    }
    this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/transport.js
init_define_process();
var import_err_code78 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/pb/index.js
init_define_process();
var CircuitRelay;
(function(CircuitRelay2) {
  let Status;
  (function(Status2) {
    Status2["SUCCESS"] = "SUCCESS";
    Status2["HOP_SRC_ADDR_TOO_LONG"] = "HOP_SRC_ADDR_TOO_LONG";
    Status2["HOP_DST_ADDR_TOO_LONG"] = "HOP_DST_ADDR_TOO_LONG";
    Status2["HOP_SRC_MULTIADDR_INVALID"] = "HOP_SRC_MULTIADDR_INVALID";
    Status2["HOP_DST_MULTIADDR_INVALID"] = "HOP_DST_MULTIADDR_INVALID";
    Status2["HOP_NO_CONN_TO_DST"] = "HOP_NO_CONN_TO_DST";
    Status2["HOP_CANT_DIAL_DST"] = "HOP_CANT_DIAL_DST";
    Status2["HOP_CANT_OPEN_DST_STREAM"] = "HOP_CANT_OPEN_DST_STREAM";
    Status2["HOP_CANT_SPEAK_RELAY"] = "HOP_CANT_SPEAK_RELAY";
    Status2["HOP_CANT_RELAY_TO_SELF"] = "HOP_CANT_RELAY_TO_SELF";
    Status2["STOP_SRC_ADDR_TOO_LONG"] = "STOP_SRC_ADDR_TOO_LONG";
    Status2["STOP_DST_ADDR_TOO_LONG"] = "STOP_DST_ADDR_TOO_LONG";
    Status2["STOP_SRC_MULTIADDR_INVALID"] = "STOP_SRC_MULTIADDR_INVALID";
    Status2["STOP_DST_MULTIADDR_INVALID"] = "STOP_DST_MULTIADDR_INVALID";
    Status2["STOP_RELAY_REFUSED"] = "STOP_RELAY_REFUSED";
    Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["SUCCESS"] = 100] = "SUCCESS";
    __StatusValues2[__StatusValues2["HOP_SRC_ADDR_TOO_LONG"] = 220] = "HOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_DST_ADDR_TOO_LONG"] = 221] = "HOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_SRC_MULTIADDR_INVALID"] = 250] = "HOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_DST_MULTIADDR_INVALID"] = 251] = "HOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_NO_CONN_TO_DST"] = 260] = "HOP_NO_CONN_TO_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_DIAL_DST"] = 261] = "HOP_CANT_DIAL_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_OPEN_DST_STREAM"] = 262] = "HOP_CANT_OPEN_DST_STREAM";
    __StatusValues2[__StatusValues2["HOP_CANT_SPEAK_RELAY"] = 270] = "HOP_CANT_SPEAK_RELAY";
    __StatusValues2[__StatusValues2["HOP_CANT_RELAY_TO_SELF"] = 280] = "HOP_CANT_RELAY_TO_SELF";
    __StatusValues2[__StatusValues2["STOP_SRC_ADDR_TOO_LONG"] = 320] = "STOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_DST_ADDR_TOO_LONG"] = 321] = "STOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_SRC_MULTIADDR_INVALID"] = 350] = "STOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_DST_MULTIADDR_INVALID"] = 351] = "STOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_RELAY_REFUSED"] = 390] = "STOP_RELAY_REFUSED";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status2) {
    Status2.codec = () => {
      return enumeration(__StatusValues);
    };
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let Type2;
  (function(Type3) {
    Type3["HOP"] = "HOP";
    Type3["STOP"] = "STOP";
    Type3["STATUS"] = "STATUS";
    Type3["CAN_HOP"] = "CAN_HOP";
  })(Type2 = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["HOP"] = 1] = "HOP";
    __TypeValues2[__TypeValues2["STOP"] = 2] = "STOP";
    __TypeValues2[__TypeValues2["STATUS"] = 3] = "STATUS";
    __TypeValues2[__TypeValues2["CAN_HOP"] = 4] = "CAN_HOP";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type2 = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let Peer3;
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, writer, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer.fork();
          }
          if (obj.id != null) {
            writer.uint32(10);
            writer.bytes(obj.id);
          } else {
            throw new Error('Protocol error: required field "id" was not found in object');
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              writer.uint32(18);
              writer.bytes(value);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (opts.lengthDelimited !== false) {
            writer.ldelim();
          }
        }, (reader2, length5) => {
          const obj = {};
          const end = length5 == null ? reader2.len : reader2.pos + length5;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs = obj.addrs ?? [];
                obj.addrs.push(reader2.bytes());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          obj.addrs = obj.addrs ?? [];
          if (obj.id == null) {
            throw new Error('Protocol error: value for required field "id" was not found in protobuf');
          }
          if (obj.addrs == null) {
            throw new Error('Protocol error: value for required field "addrs" was not found in protobuf');
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage(buf2, Peer4.codec());
    };
  })(Peer3 = CircuitRelay2.Peer || (CircuitRelay2.Peer = {}));
  let _codec;
  CircuitRelay2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.type != null) {
          writer.uint32(8);
          CircuitRelay2.Type.codec().encode(obj.type, writer);
        }
        if (obj.srcPeer != null) {
          writer.uint32(18);
          CircuitRelay2.Peer.codec().encode(obj.srcPeer, writer);
        }
        if (obj.dstPeer != null) {
          writer.uint32(26);
          CircuitRelay2.Peer.codec().encode(obj.dstPeer, writer);
        }
        if (obj.code != null) {
          writer.uint32(32);
          CircuitRelay2.Status.codec().encode(obj.code, writer);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = CircuitRelay2.Type.codec().decode(reader2);
              break;
            case 2:
              obj.srcPeer = CircuitRelay2.Peer.codec().decode(reader2, reader2.uint32());
              break;
            case 3:
              obj.dstPeer = CircuitRelay2.Peer.codec().decode(reader2, reader2.uint32());
              break;
            case 4:
              obj.code = CircuitRelay2.Status.codec().decode(reader2);
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  CircuitRelay2.encode = (obj) => {
    return encodeMessage(obj, CircuitRelay2.codec());
  };
  CircuitRelay2.decode = (buf2) => {
    return decodeMessage(buf2, CircuitRelay2.codec());
  };
})(CircuitRelay || (CircuitRelay = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
init_define_process();
var log55 = logger("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream, remoteAddr } = props;
  const { sink, source } = stream;
  const mapSource = async function* () {
    for await (const list of source) {
      yield* list;
    }
  }();
  const maConn = {
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
        await close();
      } catch (err2) {
        if (err2.type !== "aborted") {
          log55(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    return await Promise.resolve();
  }
  return maConn;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/multicodec.js
init_define_process();
var RELAY_CODEC = "/libp2p/circuit/relay/0.1.0";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/listener.js
init_define_process();
function createListener(options) {
  const listeningAddrs = /* @__PURE__ */ new Map();
  async function listen(addr) {
    const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
    const ma = multiaddr(addrString);
    const relayPeerStr = ma.getPeerId();
    if (relayPeerStr == null) {
      throw new Error("Could not determine relay peer from multiaddr");
    }
    const relayPeerId = peerIdFromString(relayPeerStr);
    await options.peerStore.addressBook.add(relayPeerId, [ma]);
    const relayConn = await options.connectionManager.openConnection(relayPeerId);
    const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);
    listener.dispatchEvent(new CustomEvent("listening"));
  }
  function getAddrs() {
    const addrs = [];
    for (const addr of listeningAddrs.values()) {
      addrs.push(addr);
    }
    return addrs;
  }
  const listener = Object.assign(new EventEmitter(), {
    close: async () => await Promise.resolve(),
    listen,
    getAddrs
  });
  options.connectionManager.addEventListener("peer:disconnect", (evt) => {
    const { detail: connection } = evt;
    const deleted = listeningAddrs.delete(connection.remotePeer.toString());
    if (deleted) {
      listener.dispatchEvent(new CustomEvent("close"));
    }
  });
  return listener;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/hop.js
init_define_process();
var import_err_code77 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/utils.js
init_define_process();
function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer?.addrs != null) {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err2;
  }
  try {
    if (msg.srcPeer?.addrs != null) {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err2) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err2;
  }
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/stream-handler.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-handshake-npm-4.1.2-3e7804c651-9.zip/node_modules/it-handshake/dist/src/index.js
init_define_process();
function handshake(stream) {
  const writer = pushable();
  const source = reader(stream.source);
  const sourcePromise = pDefer();
  let sinkErr;
  const sinkPromise = stream.sink(async function* () {
    yield* writer;
    const source2 = await sourcePromise.promise;
    yield* source2;
  }());
  sinkPromise.catch((err2) => {
    sinkErr = err2;
  });
  const rest = {
    sink: async (source2) => {
      if (sinkErr != null) {
        return await Promise.reject(sinkErr);
      }
      sourcePromise.resolve(source2);
      return await sinkPromise;
    },
    source
  };
  return {
    reader: source,
    writer,
    stream: rest,
    rest: () => writer.end(),
    write: writer.push,
    read: async () => {
      const res = await source.next();
      if (res.value != null) {
        return res.value;
      }
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/stream-handler.js
var log56 = logger("libp2p:circuit:stream-handler");
var StreamHandler = class {
  constructor(options) {
    const { stream, maxLength = 4096 } = options;
    this.stream = stream;
    this.shake = handshake(this.stream);
    this.decoder = decode2.fromReader(this.shake.reader, { maxDataLength: maxLength });
  }
  async read() {
    const msg = await this.decoder.next();
    if (msg.value != null) {
      const value = CircuitRelay.decode(msg.value);
      log56("read message type", value.type);
      return value;
    }
    log56("read received no value, closing stream");
    this.close();
  }
  write(msg) {
    log56("write message type %s", msg.type);
    this.shake.write(encode.single(CircuitRelay.encode(msg)));
  }
  rest() {
    this.shake.rest();
    return this.shake.stream;
  }
  end(msg) {
    this.write(msg);
    this.close();
  }
  close() {
    log56("closing the stream");
    void this.rest().sink([]).catch((err2) => {
      log56.error(err2);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/stop.js
init_define_process();
var log57 = logger("libp2p:circuit:stop");
function handleStop(options) {
  const { connection, request: request2, streamHandler } = options;
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log57.error("invalid stop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  log57("stop request is valid");
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  return streamHandler.rest();
}
async function stop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  log57("starting stop request to %p", connection.remotePeer);
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    streamHandler.close();
    return;
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log57("stop request to %p was successful", connection.remotePeer);
    return streamHandler.rest();
  }
  log57("stop request failed with code %d", response.code);
  streamHandler.close();
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/circuit/hop.js
var log58 = logger("libp2p:circuit:hop");
async function handleHop(hopRequest) {
  const { connection, request: request2, streamHandler, circuit, connectionManager } = hopRequest;
  if (!circuit.hopEnabled()) {
    log58("HOP request received but we are not acting as a relay");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  try {
    validateAddrs(request2, streamHandler);
  } catch (err2) {
    log58.error("invalid hop request via peer %p %o", connection.remotePeer, err2);
    return;
  }
  if (request2.dstPeer == null) {
    log58("HOP request received but we do not receive a dstPeer");
    return;
  }
  const destinationPeer = peerIdFromBytes(request2.dstPeer.id);
  const destinationConnections = connectionManager.getConnections(destinationPeer);
  if (destinationConnections.length === 0 && !circuit.hopActive()) {
    log58("HOP request received but we are not connected to the destination peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  if (destinationConnections.length === 0) {
    log58("did not have connection to remote peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  const stopRequest = {
    type: CircuitRelay.Type.STOP,
    dstPeer: request2.dstPeer,
    srcPeer: request2.srcPeer
  };
  let destinationStream;
  try {
    log58("performing STOP request");
    const result = await stop({
      connection: destinationConnections[0],
      request: stopRequest
    });
    if (result == null) {
      throw new Error("Could not stop");
    }
    destinationStream = result;
  } catch (err2) {
    log58.error(err2);
    return;
  }
  log58("hop request from %p is valid", connection.remotePeer);
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  const sourceStream = streamHandler.rest();
  log58("creating related connections");
  return await pipe(sourceStream, destinationStream, sourceStream);
}
async function hop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    throw (0, import_err_code77.default)(new Error("HOP request had no response"), codes.ERR_HOP_REQUEST_FAILED);
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log58("hop request was successful");
    return streamHandler.rest();
  }
  log58("hop request failed with code %d, closing stream", response.code);
  streamHandler.close();
  throw (0, import_err_code77.default)(new Error(`HOP request failed with code "${response.code ?? "unknown"}"`), codes.ERR_HOP_REQUEST_FAILED);
}
async function canHop(options) {
  const { connection, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write({
    type: CircuitRelay.Type.CAN_HOP
  });
  const response = await streamHandler.read();
  await streamHandler.close();
  if (response == null || response.code !== CircuitRelay.Status.SUCCESS) {
    return false;
  }
  return true;
}
function handleCanHop(options) {
  const { connection, streamHandler, circuit } = options;
  const canHop2 = circuit.hopEnabled();
  log58("can hop (%s) request from %p", canHop2, connection.remotePeer);
  streamHandler.end({
    type: CircuitRelay.Type.STATUS,
    code: canHop2 ? CircuitRelay.Status.SUCCESS : CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
  });
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/transport.js
var import_timeout_abort_controller6 = __toESM(require_timeout_abort_controller(), 1);
var import_events8 = __toESM(require_events(), 1);
var log59 = logger("libp2p:circuit");
var Circuit2 = class {
  constructor(init) {
    this.components = new Components();
    this._init = init;
  }
  init(components) {
    this.components = components;
    void this.components.getRegistrar().handle(RELAY_CODEC, (data) => {
      void this._onProtocol(data).catch((err2) => {
        log59.error(err2);
      });
    }).catch((err2) => {
      log59.error(err2);
    });
  }
  hopEnabled() {
    return true;
  }
  hopActive() {
    return true;
  }
  get [symbol]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "libp2p/circuit-relay-v1";
  }
  async _onProtocol(data) {
    const { connection, stream } = data;
    const controller = new import_timeout_abort_controller6.TimeoutController(this._init.hop.timeout);
    try {
      (0, import_events8.setMaxListeners)?.(Infinity, controller.signal);
    } catch {
    }
    try {
      const source = abortableDuplex(stream, controller.signal);
      const streamHandler = new StreamHandler({
        stream: {
          ...stream,
          ...source
        }
      });
      const request2 = await streamHandler.read();
      if (request2 == null) {
        log59("request was invalid, could not read from stream");
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: CircuitRelay.Status.MALFORMED_MESSAGE
        });
        streamHandler.close();
        return;
      }
      let virtualConnection;
      switch (request2.type) {
        case CircuitRelay.Type.CAN_HOP: {
          log59("received CAN_HOP request from %p", connection.remotePeer);
          await handleCanHop({ circuit: this, connection, streamHandler });
          break;
        }
        case CircuitRelay.Type.HOP: {
          log59("received HOP request from %p", connection.remotePeer);
          await handleHop({
            connection,
            request: request2,
            streamHandler,
            circuit: this,
            connectionManager: this.components.getConnectionManager()
          });
          break;
        }
        case CircuitRelay.Type.STOP: {
          log59("received STOP request from %p", connection.remotePeer);
          virtualConnection = await handleStop({
            connection,
            request: request2,
            streamHandler
          });
          break;
        }
        default: {
          log59("Request of type %s not supported", request2.type);
          streamHandler.write({
            type: CircuitRelay.Type.STATUS,
            code: CircuitRelay.Status.MALFORMED_MESSAGE
          });
          streamHandler.close();
          return;
        }
      }
      if (virtualConnection != null) {
        const remoteAddr = connection.remoteAddr.encapsulate("/p2p-circuit").encapsulate(multiaddr(request2.dstPeer?.addrs[0]));
        const localAddr = multiaddr(request2.srcPeer?.addrs[0]);
        const maConn = streamToMaConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request2.type === CircuitRelay.Type.HOP ? "relay" : "inbound";
        log59("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this.components.getUpgrader().upgradeInbound(maConn);
        log59("%s connection %s upgraded", type, maConn.remoteAddr);
        if (this.handler != null) {
          this.handler(conn);
        }
      }
    } finally {
      controller.clear();
    }
  }
  async dial(ma, options = {}) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = "Circuit relay dial failed as addresses did not have peer id";
      log59.error(errMsg);
      throw (0, import_err_code78.default)(new Error(errMsg), codes.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.components.getConnectionManager().getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.getPeerStore().addressBook.add(relayPeer, [relayAddr]);
      relayConnection = await this.components.getConnectionManager().openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    try {
      const virtualConnection = await hop({
        ...options,
        connection: relayConnection,
        request: {
          type: CircuitRelay.Type.HOP,
          srcPeer: {
            id: this.components.getPeerId().toBytes(),
            addrs: this.components.getAddressManager().getAddresses().map((addr) => addr.bytes)
          },
          dstPeer: {
            id: destinationPeer.toBytes(),
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }
      });
      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.getPeerId().toString()}`);
      const maConn = streamToMaConnection({
        stream: virtualConnection,
        remoteAddr: ma,
        localAddr
      });
      log59("new outbound connection %s", maConn.remoteAddr);
      return await this.components.getUpgrader().upgradeOutbound(maConn);
    } catch (err2) {
      log59.error("Circuit relay dial failed", err2);
      disconnectOnFailure && await relayConnection.close();
      throw err2;
    }
  }
  createListener(options) {
    this.handler = options.handler;
    return createListener({
      connectionManager: this.components.getConnectionManager(),
      peerStore: this.components.getPeerStore()
    });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/index.js
init_define_process();
var import_set_delayed_interval2 = __toESM(require_src3(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/auto-relay.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/utils.js
init_define_process();
async function namespaceToCid(namespace3) {
  const bytes2 = new TextEncoder().encode(namespace3);
  const hash3 = await sha256.digest(bytes2);
  return CID.createV0(hash3);
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/constants.js
init_define_process();
var minute2 = 60 * 1e3;
var ADVERTISE_BOOT_DELAY = 15 * minute2;
var ADVERTISE_TTL = 30 * minute2;
var CIRCUIT_PROTO_CODE = 290;
var HOP_METADATA_KEY = "hop_relay";
var HOP_METADATA_VALUE = "true";
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/auto-relay.js
var import_it_sort3 = __toESM(require_it_sort(), 1);
var import_it_all7 = __toESM(require_it_all(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/address-sort.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
init_define_process();
var import_private_ip = __toESM(require_private_ip(), 1);
function isPrivate(ma) {
  const { address } = ma.nodeAddress();
  return Boolean((0, import_private_ip.default)(address));
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/auto-relay.js
var log60 = logger("libp2p:auto-relay");
var noop2 = () => {
};
var AutoRelay = class {
  constructor(components, init) {
    this.components = components;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxListeners = init.maxListeners ?? 1;
    this.listenRelays = /* @__PURE__ */ new Set();
    this.onError = init.onError ?? noop2;
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    this.components.getPeerStore().addEventListener("change:protocols", (evt) => {
      void this._onProtocolChange(evt).catch((err2) => {
        log60.error(err2);
      });
    });
    this.components.getConnectionManager().addEventListener("peer:disconnect", this._onPeerDisconnected);
  }
  async _onProtocolChange(evt) {
    const { peerId, protocols } = evt.detail;
    const id = peerId.toString();
    const hasProtocol = protocols.find((protocol) => protocol === RELAY_CODEC);
    if (hasProtocol == null) {
      if (this.listenRelays.has(id)) {
        await this._removeListenRelay(id);
      }
      return;
    }
    if (this.listenRelays.has(id)) {
      return;
    }
    try {
      const connections = this.components.getConnectionManager().getConnections(peerId);
      if (connections.length === 0) {
        return;
      }
      const connection = connections[0];
      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
        log60(`relayed connection to ${id} will not be used to hop on`);
        return;
      }
      const supportsHop = await canHop({ connection });
      if (supportsHop) {
        await this.components.getPeerStore().metadataBook.setValue(peerId, HOP_METADATA_KEY, fromString(HOP_METADATA_VALUE));
        await this._addListenRelay(connection, id);
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  _onPeerDisconnected(evt) {
    const connection = evt.detail;
    const peerId = connection.remotePeer;
    const id = peerId.toString();
    if (!this.listenRelays.has(id)) {
      return;
    }
    this._removeListenRelay(id).catch((err2) => {
      log60.error(err2);
    });
  }
  async _addListenRelay(connection, id) {
    try {
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = await pipe(await this.components.getPeerStore().addressBook.get(connection.remotePeer), (source) => (0, import_it_sort3.default)(source, this.addressSorter), async (source) => await (0, import_it_all7.default)(source));
      const result = await Promise.all(remoteAddrs.map(async (addr) => {
        try {
          let multiaddr2 = addr.multiaddr;
          if (multiaddr2.getPeerId() == null) {
            multiaddr2 = multiaddr2.encapsulate(`/p2p/${connection.remotePeer.toString()}`);
          }
          multiaddr2 = multiaddr2.encapsulate("/p2p-circuit");
          await this.components.getTransportManager().listen([multiaddr2]);
          return true;
        } catch (err2) {
          log60.error("error listening on circuit address", err2);
          this.onError(err2);
        }
        return false;
      }));
      if (result.includes(true)) {
        this.listenRelays.add(id);
      }
    } catch (err2) {
      this.onError(err2);
      this.listenRelays.delete(id);
    }
  }
  async _removeListenRelay(id) {
    if (this.listenRelays.delete(id)) {
      await this._listenOnAvailableHopRelays([id]);
    }
  }
  async _listenOnAvailableHopRelays(peersToIgnore = []) {
    if (this.listenRelays.size >= this.maxListeners) {
      return;
    }
    const knownHopsToDial = [];
    const peers = await this.components.getPeerStore().all();
    for (const { id, metadata } of peers) {
      const idStr = id.toString();
      if (this.listenRelays.has(idStr)) {
        continue;
      }
      if (peersToIgnore.includes(idStr)) {
        continue;
      }
      const supportsHop = metadata.get(HOP_METADATA_KEY);
      if (supportsHop == null || toString(supportsHop) !== HOP_METADATA_VALUE) {
        continue;
      }
      const connections = this.components.getConnectionManager().getConnections(id);
      if (connections.length === 0) {
        knownHopsToDial.push(id);
        continue;
      }
      await this._addListenRelay(connections[0], idStr);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    for (const peerId of knownHopsToDial) {
      await this._tryToListenOnRelay(peerId);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      for await (const provider of this.components.getContentRouting().findProviders(cid)) {
        if (provider.multiaddrs.length === 0) {
          continue;
        }
        const peerId = provider.id;
        if (peerId.equals(this.components.getPeerId())) {
          continue;
        }
        await this.components.getPeerStore().addressBook.add(peerId, provider.multiaddrs);
        await this._tryToListenOnRelay(peerId);
        if (this.listenRelays.size >= this.maxListeners) {
          return;
        }
      }
    } catch (err2) {
      this.onError(err2);
    }
  }
  async _tryToListenOnRelay(peerId) {
    try {
      const connection = await this.components.getConnectionManager().openConnection(peerId);
      await this._addListenRelay(connection, peerId.toString());
    } catch (err2) {
      log60.error("Could not use %p as relay", peerId, err2);
      this.onError(err2, `could not connect and listen on known hop relay ${peerId.toString()}`);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/circuit/index.js
var log61 = logger("libp2p:relay");
var Relay = class {
  constructor(components, init) {
    this.components = components;
    this.autoRelay = init.autoRelay?.enabled !== false ? new AutoRelay(components, {
      addressSorter: init.addressSorter,
      ...init.autoRelay
    }) : void 0;
    this.started = false;
    this.init = init;
    this._advertiseService = this._advertiseService.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.init.hop.enabled !== false && this.init.advertise.enabled !== false) {
      this.timeout = (0, import_set_delayed_interval2.setDelayedInterval)(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay);
    }
    this.started = true;
  }
  async stop() {
    if (this.timeout != null) {
      (0, import_set_delayed_interval2.clearDelayedInterval)(this.timeout);
    }
    this.started = false;
  }
  async _advertiseService() {
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      await this.components.getContentRouting().provide(cid);
    } catch (err2) {
      if (err2.code === codes.ERR_NO_ROUTERS_AVAILABLE) {
        log61.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err2);
        await this.stop();
      } else {
        log61.error(err2);
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/keychain/index.js
init_define_process();
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/keychain/cms.js
init_define_process();
var import_pkcs7 = __toESM(require_pkcs7(), 1);
var import_pbe = __toESM(require_pbe(), 1);
var import_forge2 = __toESM(require_forge(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/keychain/util.js
init_define_process();
var import_x509 = __toESM(require_x509(), 1);
var import_forge = __toESM(require_forge(), 1);
var pki = import_forge.default.pki;
var certificateForKey = (key, privateKey) => {
  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);
  const cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = "01";
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  const attrs = [{
    name: "organizationName",
    value: "ipfs"
  }, {
    shortName: "OU",
    value: "keystore"
  }, {
    name: "commonName",
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: "basicConstraints",
    cA: true
  }, {
    name: "keyUsage",
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: "extKeyUsage",
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: "nsCertType",
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]);
  cert.sign(privateKey);
  return cert;
};
async function findAsync(array, asyncCompare) {
  const promises = array.map(asyncCompare);
  const results = await Promise.all(promises);
  const index = results.findIndex((result) => result);
  return array[index];
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/keychain/cms.js
var import_err_code79 = __toESM(require_err_code(), 1);
var log62 = logger("libp2p:keychain:cms");
var privates = /* @__PURE__ */ new WeakMap();
var CMS = class {
  constructor(keychain, dek) {
    if (keychain == null) {
      throw (0, import_err_code79.default)(new Error("keychain is required"), codes.ERR_KEYCHAIN_REQUIRED);
    }
    this.keychain = keychain;
    privates.set(this, { dek });
  }
  async encrypt(name6, plain) {
    if (!(plain instanceof Uint8Array)) {
      throw (0, import_err_code79.default)(new Error("Plain data must be a Uint8Array"), codes.ERR_INVALID_PARAMETERS);
    }
    const key = await this.keychain.findKeyByName(name6);
    const pem = await this.keychain.getPrivateKey(name6);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code79.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge2.default.pki.decryptRsaPrivateKey(pem, dek);
    const certificate = await certificateForKey(key, privateKey);
    const p7 = import_forge2.default.pkcs7.createEnvelopedData();
    p7.addRecipient(certificate);
    p7.content = import_forge2.default.util.createBuffer(plain);
    p7.encrypt();
    const der = import_forge2.default.asn1.toDer(p7.toAsn1()).getBytes();
    return fromString(der, "ascii");
  }
  async decrypt(cmsData) {
    if (!(cmsData instanceof Uint8Array)) {
      throw (0, import_err_code79.default)(new Error("CMS data is required"), codes.ERR_INVALID_PARAMETERS);
    }
    let cms;
    try {
      const buf2 = import_forge2.default.util.createBuffer(toString(cmsData, "ascii"));
      const obj = import_forge2.default.asn1.fromDer(buf2);
      cms = import_forge2.default.pkcs7.messageFromAsn1(obj);
    } catch (err2) {
      log62.error(err2);
      throw (0, import_err_code79.default)(new Error("Invalid CMS"), codes.ERR_INVALID_CMS);
    }
    const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
      return {
        recipient: r2,
        keyId: r2.issuer.find((a) => a.shortName === "CN").value
      };
    });
    const r = await findAsync(recipients, async (recipient) => {
      try {
        const key2 = await this.keychain.findKeyById(recipient.keyId);
        if (key2 != null) {
          return true;
        }
      } catch (err2) {
        return false;
      }
      return false;
    });
    if (r == null) {
      const missingKeys = recipients.map((r2) => r2.keyId);
      throw (0, import_err_code79.default)(new Error(`Decryption needs one of the key(s): ${missingKeys.join(", ")}`), codes.ERR_MISSING_KEYS, {
        missingKeys
      });
    }
    const key = await this.keychain.findKeyById(r.keyId);
    if (key == null) {
      throw (0, import_err_code79.default)(new Error("No key available to decrypto"), codes.ERR_NO_KEY);
    }
    const pem = await this.keychain.getPrivateKey(key.name);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code79.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge2.default.pki.decryptRsaPrivateKey(pem, dek);
    cms.decrypt(r.recipient, privateKey);
    return fromString(cms.content.getBytes(), "ascii");
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/keychain/index.js
var import_err_code80 = __toESM(require_err_code(), 1);
var log63 = logger("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates2 = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions18 = {
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name6) {
  if (name6 == null) {
    return false;
  }
  if (typeof name6 !== "string") {
    return false;
  }
  return name6 === (0, import_sanitize_filename.default)(name6.trim()) && name6.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay = Math.random() * (max - min) + min;
  await new Promise((resolve7) => setTimeout(resolve7, delay));
}
function DsName(name6) {
  return new Key(keyPrefix + name6);
}
function DsInfoName(name6) {
  return new Key(infoPrefix + name6);
}
var KeyChain = class {
  constructor(components, init) {
    this.components = components;
    this.init = merge_options_default(defaultOptions18, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const dsname = DsInfoName("self");
    if (!await this.components.getDatastore().has(dsname)) {
      await this.importPeer("self", this.components.getPeerId());
    }
    this.started = true;
  }
  stop() {
    this.started = false;
  }
  get cms() {
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    return new CMS(this, dek);
  }
  static generateOptions() {
    const options = Object.assign({}, defaultOptions18);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString(randomBytes(saltLength), "base64");
    return options;
  }
  static get options() {
    return defaultOptions18;
  }
  async createKey(name6, type, size = 2048) {
    if (!validateKeyName(name6) || name6 === "self") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("Invalid key name"), codes.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("Invalid key type"), codes.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name6);
    const exists2 = await this.components.getDatastore().has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("Key name already exists"), codes.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw (0, import_err_code80.default)(new Error("Invalid RSA key size"), codes.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair(type, size);
      const kid = await keypair.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name6,
        id: kid
      };
      const batch3 = this.components.getDatastore().batch();
      batch3.put(dsname, fromString(pem));
      batch3.put(DsInfoName(name6), fromString(JSON.stringify(keyInfo)));
      await batch3.commit();
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    return keyInfo;
  }
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.getDatastore().query(query)) {
      info.push(JSON.parse(toString(value.value)));
    }
    return info;
  }
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      return keys.find((k) => k.id === id);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async findKeyByName(name6) {
    if (!validateKeyName(name6)) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name6);
    try {
      const res = await this.components.getDatastore().get(dsname);
      return JSON.parse(toString(res));
    } catch (err2) {
      await randomDelay();
      log63.error(err2);
      throw (0, import_err_code80.default)(new Error(`Key '${name6}' does not exist.`), codes.ERR_KEY_NOT_FOUND);
    }
  }
  async removeKey(name6) {
    if (!validateKeyName(name6) || name6 === "self") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name6);
    const keyInfo = await this.findKeyByName(name6);
    const batch3 = this.components.getDatastore().batch();
    batch3.delete(dsname);
    batch3.delete(DsInfoName(name6));
    await batch3.commit();
    return keyInfo;
  }
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid old key name '${oldName}'`), codes.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid new key name '${newName}'`), codes.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists2 = await this.components.getDatastore().has(newDsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Key '${newName}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.getDatastore().get(oldDsname);
      const res = await this.components.getDatastore().get(oldInfoName);
      const keyInfo = JSON.parse(toString(res));
      keyInfo.name = newName;
      const batch3 = this.components.getDatastore().batch();
      batch3.put(newDsname, pem);
      batch3.put(newInfoName, fromString(JSON.stringify(keyInfo)));
      batch3.delete(oldDsname);
      batch3.delete(oldInfoName);
      await batch3.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async exportKey(name6, password) {
    if (!validateKeyName(name6)) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("Password is required"), codes.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name6);
    try {
      const res = await this.components.getDatastore().get(dsname);
      const pem = toString(res);
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      return await privateKey.export(password);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async importKey(name6, pem, password) {
    if (!validateKeyName(name6) || name6 === "self") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("PEM encoded key is required"), codes.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name6);
    const exists2 = await this.components.getDatastore().has(dsname);
    if (exists2) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Key '${name6}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err2) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error("Cannot read the key, most likely the password is wrong"), codes.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
    const keyInfo = {
      name: name6,
      id: kid
    };
    const batch3 = this.components.getDatastore().batch();
    batch3.put(dsname, fromString(pem));
    batch3.put(DsInfoName(name6), fromString(JSON.stringify(keyInfo)));
    await batch3.commit();
    return keyInfo;
  }
  async importPeer(name6, peer) {
    try {
      if (!validateKeyName(name6)) {
        throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw (0, import_err_code80.default)(new Error("PeerId is required"), codes.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw (0, import_err_code80.default)(new Error("PeerId.privKey is required"), codes.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey(peer.privateKey);
      const dsname = DsName(name6);
      const exists2 = await this.components.getDatastore().has(dsname);
      if (exists2) {
        await randomDelay();
        throw (0, import_err_code80.default)(new Error(`Key '${name6}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name6,
        id: peer.toString()
      };
      const batch3 = this.components.getDatastore().batch();
      batch3.put(dsname, fromString(pem));
      batch3.put(DsInfoName(name6), fromString(JSON.stringify(keyInfo)));
      await batch3.commit();
      return keyInfo;
    } catch (err2) {
      await randomDelay();
      throw err2;
    }
  }
  async getPrivateKey(name6) {
    if (!validateKeyName(name6)) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid key name '${name6}'`), codes.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name6);
      const res = await this.components.getDatastore().get(dsname);
      return toString(res);
    } catch (err2) {
      await randomDelay();
      log63.error(err2);
      throw (0, import_err_code80.default)(new Error(`Key '${name6}' does not exist.`), codes.ERR_KEY_NOT_FOUND);
    }
  }
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid old pass type '${typeof oldPass}'`), codes.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid new pass type '${typeof newPass}'`), codes.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw (0, import_err_code80.default)(new Error(`Invalid pass length ${newPass.length}`), codes.ERR_INVALID_PASS_LENGTH);
    }
    log63("recreating keychain");
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code80.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.getDatastore().get(DsName(key.name));
      const pem = toString(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch3 = this.components.getDatastore().batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch3.put(DsName(key.name), fromString(keyAsPEM));
      batch3.put(DsInfoName(key.name), fromString(JSON.stringify(keyInfo)));
      await batch3.commit();
    }
    log63("keychain reconstructed");
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/metrics/index.js
init_define_process();
var import_it_foreach = __toESM(require_it_foreach(), 1);
var import_hashlru4 = __toESM(require_hashlru(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/constants.js
init_define_process();
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PARALLEL_DIALS = 100;
var MAX_PER_PEER_DIALS = 4;
var MAX_ADDRS_TO_DIAL = 25;
var METRICS = {
  computeThrottleMaxQueueSize: 1e3,
  computeThrottleTimeout: 2e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ],
  maxOldPeersRetention: 50
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/metrics/stats.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/metrics/moving-average.js
init_define_process();
var DefaultMovingAverage = class {
  constructor(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(time, value) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};
function createMovingAverage(timespan) {
  return new DefaultMovingAverage(timespan);
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/metrics/stats.js
var import_retimer3 = __toESM(require_retimer(), 1);
var DefaultStats = class extends EventEmitter {
  constructor(init) {
    super();
    this.enabled = init.enabled;
    this.queue = [];
    this.stats = {
      dataReceived: 0n,
      dataSent: 0n
    };
    this.frequencyLastTime = Date.now();
    this.frequencyAccumulators = {};
    this.movingAverages = {
      dataReceived: [],
      dataSent: []
    };
    this.computeThrottleMaxQueueSize = init.computeThrottleMaxQueueSize;
    this.computeThrottleTimeout = init.computeThrottleTimeout;
    this._update = this._update.bind(this);
    this.movingAverageIntervals = init.movingAverageIntervals;
    for (let i = 0; i < init.initialCounters.length; i++) {
      const key = init.initialCounters[i];
      this.stats[key] = 0n;
      this.movingAverages[key] = [];
      for (let k = 0; k < this.movingAverageIntervals.length; k++) {
        const interval = this.movingAverageIntervals[k];
        const ma = this.movingAverages[key][interval] = createMovingAverage(interval);
        ma.push(this.frequencyLastTime, 0);
      }
    }
  }
  start() {
    if (!this.enabled) {
      return;
    }
    if (this.queue.length > 0) {
      this._resetComputeTimeout();
    }
  }
  stop() {
    if (this.timeout != null) {
      this.timeout.clear();
      this.timeout = null;
    }
  }
  getSnapshot() {
    return Object.assign({}, this.stats);
  }
  getMovingAverages() {
    return Object.assign({}, this.movingAverages);
  }
  push(counter, inc) {
    this.queue.push([counter, inc, Date.now()]);
    this._resetComputeTimeout();
  }
  _resetComputeTimeout() {
    this.timeout = (0, import_retimer3.default)(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this.queue.length / this.computeThrottleMaxQueueSize;
    const timeout = Math.max(this.computeThrottleTimeout * (1 - urgency), 0);
    return timeout;
  }
  _update() {
    this.timeout = null;
    if (this.queue.length > 0) {
      let last14 = ["", 0, 0];
      for (last14 of this.queue) {
        this._applyOp(last14);
      }
      this.queue = [];
      if (last14.length > 2 && last14[0] !== "") {
        this._updateFrequency(last14[2]);
      }
      this.dispatchEvent(new CustomEvent("update", {
        detail: this.stats
      }));
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this.frequencyLastTime;
    this._updateFrequencyFor("dataReceived", timeDiff, latestTime);
    this._updateFrequencyFor("dataSent", timeDiff, latestTime);
    this.frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this.frequencyAccumulators[key] ?? 0;
    this.frequencyAccumulators[key] = 0;
    const safeTimeDiff = timeDiffMS ?? 1;
    const hz = count / safeTimeDiff * 1e3;
    let movingAverages = this.movingAverages[key];
    if (movingAverages == null) {
      movingAverages = this.movingAverages[key] = [];
    }
    const intervals = this.movingAverageIntervals;
    for (let i = 0; i < intervals.length; i++) {
      const movingAverageInterval = intervals[i];
      let movingAverage = movingAverages[movingAverageInterval];
      if (movingAverage == null) {
        movingAverage = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    }
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error("invalid increment number");
    }
    let n;
    if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {
      n = this.stats[key] = 0n;
    } else {
      n = this.stats[key];
    }
    this.stats[key] = n + BigInt(inc);
    if (this.frequencyAccumulators[key] == null) {
      this.frequencyAccumulators[key] = 0;
    }
    this.frequencyAccumulators[key] += inc;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/metrics/index.js
var initialCounters = [
  "dataReceived",
  "dataSent"
];
var directionToEvent = {
  in: "dataReceived",
  out: "dataSent"
};
var DefaultMetrics = class {
  constructor(init) {
    this.enabled = init.enabled;
    this.statsInit = {
      ...init,
      initialCounters
    };
    this.globalStats = new DefaultStats(this.statsInit);
    this.peerStats = /* @__PURE__ */ new Map();
    this.protocolStats = /* @__PURE__ */ new Map();
    this.oldPeers = (0, import_hashlru4.default)(init.maxOldPeersRetention ?? METRICS.maxOldPeersRetention);
    this.running = false;
    this._onMessage = this._onMessage.bind(this);
    this.systems = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.enabled) {
      return;
    }
    this.running = true;
  }
  async stop() {
    if (!this.running) {
      return;
    }
    this.running = false;
    this.globalStats.stop();
    for (const stats of this.peerStats.values()) {
      stats.stop();
    }
    for (const stats of this.protocolStats.values()) {
      stats.stop();
    }
  }
  getGlobal() {
    return this.globalStats;
  }
  getPeers() {
    return Array.from(this.peerStats.keys());
  }
  getComponentMetrics() {
    return this.systems;
  }
  updateComponentMetric(update) {
    const { system = "libp2p", component, metric, value, label, help } = update;
    if (!this.systems.has(system)) {
      this.systems.set(system, /* @__PURE__ */ new Map());
    }
    const systemMetrics = this.systems.get(system);
    if (systemMetrics == null) {
      throw new Error("Unknown metric system");
    }
    if (!systemMetrics.has(component)) {
      systemMetrics.set(component, /* @__PURE__ */ new Map());
    }
    const componentMetrics = systemMetrics.get(component);
    if (componentMetrics == null) {
      throw new Error("Unknown metric component");
    }
    componentMetrics.set(metric, {
      label,
      help,
      calculate: typeof value !== "function" ? () => value : value
    });
  }
  forPeer(peerId) {
    const idString = peerId.toString();
    return this.peerStats.get(idString) ?? this.oldPeers.get(idString);
  }
  getProtocols() {
    return Array.from(this.protocolStats.keys());
  }
  forProtocol(protocol) {
    return this.protocolStats.get(protocol);
  }
  onPeerDisconnected(peerId) {
    const idString = peerId.toString();
    const peerStats = this.peerStats.get(idString);
    if (peerStats != null) {
      peerStats.stop();
      this.peerStats.delete(idString);
      this.oldPeers.set(idString, peerStats);
    }
  }
  _onMessage(opts) {
    if (!this.running) {
      return;
    }
    const { remotePeer, protocol, direction, dataLength } = opts;
    const key = directionToEvent[direction];
    let peerStats = this.forPeer(remotePeer);
    if (peerStats == null) {
      const stats = new DefaultStats(this.statsInit);
      this.peerStats.set(remotePeer.toString(), stats);
      peerStats = stats;
    }
    peerStats.push(key, dataLength);
    this.globalStats.push(key, dataLength);
    if (protocol != null) {
      let protocolStats = this.forProtocol(protocol);
      if (protocolStats == null) {
        const stats = new DefaultStats(this.statsInit);
        this.protocolStats.set(protocol, stats);
        protocolStats = stats;
      }
      protocolStats.push(key, dataLength);
    }
  }
  updatePlaceholder(placeholder, peerId) {
    if (!this.running) {
      return;
    }
    const placeholderString = placeholder.toString();
    const placeholderStats = this.peerStats.get(placeholderString) ?? this.oldPeers.get(placeholderString);
    const peerIdString = peerId.toString();
    const existingStats = this.peerStats.get(peerIdString) ?? this.oldPeers.get(peerIdString);
    let mergedStats = placeholderStats;
    if (existingStats != null) {
      mergedStats = mergeStats(existingStats, mergedStats);
      this.oldPeers.remove(peerIdString);
    }
    this.peerStats.delete(placeholder.toString());
    this.peerStats.set(peerIdString, mergedStats);
    mergedStats.start();
  }
  trackStream(opts) {
    const { stream, remotePeer, protocol } = opts;
    if (!this.running) {
      return;
    }
    const source = stream.source;
    stream.source = (0, import_it_foreach.default)(source, (chunk) => this._onMessage({
      remotePeer,
      protocol,
      direction: "in",
      dataLength: chunk.byteLength
    }));
    const sink = stream.sink;
    stream.sink = async (source2) => {
      return await pipe(source2, (source3) => (0, import_it_foreach.default)(source3, (chunk) => {
        this._onMessage({
          remotePeer,
          protocol,
          direction: "out",
          dataLength: chunk.byteLength
        });
      }), sink);
    };
  }
};
function mergeStats(target, other) {
  target.stop();
  other.stop();
  target.queue = [...target.queue, ...other.queue];
  return target;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/transport-manager.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/p-settle-npm-5.1.0-214afd1ced-9.zip/node_modules/p-settle/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/p-reflect-npm-3.1.0-34db1bfdd7-9.zip/node_modules/p-reflect/index.js
init_define_process();
async function pReflect(promise) {
  try {
    const value = await promise;
    return {
      status: "fulfilled",
      value,
      isFulfilled: true,
      isRejected: false
    };
  } catch (error) {
    return {
      status: "rejected",
      reason: error,
      isFulfilled: false,
      isRejected: true
    };
  }
}

// ../../../../../Users/z/.yarn/berry/cache/p-limit-npm-4.0.0-5dccf29b67-9.zip/node_modules/p-limit/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/yocto-queue-npm-1.0.0-7b502f1987-9.zip/node_modules/yocto-queue/index.js
init_define_process();
var Node = class {
  constructor(value) {
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue4 = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// ../../../../../Users/z/.yarn/berry/cache/p-limit-npm-4.0.0-5dccf29b67-9.zip/node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue4();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve7, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve7(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve7, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve7, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve7) => {
    enqueue(fn, resolve7, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// ../../../../../Users/z/.yarn/berry/cache/p-settle-npm-5.1.0-214afd1ced-9.zip/node_modules/p-settle/index.js
async function pSettle(array, options = {}) {
  const { concurrency = Number.POSITIVE_INFINITY } = options;
  const limit = pLimit(concurrency);
  return Promise.all(array.map((element) => {
    if (element && typeof element.then === "function") {
      return pReflect(element);
    }
    if (typeof element === "function") {
      return pReflect(limit(() => element()));
    }
    return pReflect(Promise.resolve(element));
  }));
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/transport-manager.js
var import_err_code81 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-tracked-map-npm-2.0.2-0fab335f7a-9.zip/node_modules/@libp2p/tracked-map/dist/src/index.js
init_define_process();
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    const { system, component, metric, metrics } = init;
    this.system = system ?? "libp2p";
    this.component = component;
    this.metric = metric;
    this.metrics = metrics;
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metrics.updateComponentMetric({
      system: this.system,
      component: this.component,
      metric: this.metric,
      value: this.size
    });
  }
};
function trackedMap(config2) {
  const { system, component, metric, metrics } = config2;
  let map18;
  if (metrics != null) {
    map18 = new TrackedMap({ system, component, metric, metrics });
  } else {
    map18 = /* @__PURE__ */ new Map();
  }
  return map18;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/transport-manager.js
var log64 = logger("libp2p:transports");
var DefaultTransportManager = class extends EventEmitter {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      component: "transport-manager",
      metric: "listeners",
      metrics: this.components.getMetrics()
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw (0, import_err_code81.default)(new Error("Transport must have a valid tag"), codes.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw (0, import_err_code81.default)(new Error("There is already a transport with this tag"), codes.ERR_DUPLICATE_TRANSPORT);
    }
    log64("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const addrs = this.components.getAddressManager().getListenAddrs();
    await this.listen(addrs);
    this.started = true;
  }
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log64("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log64("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw (0, import_err_code81.default)(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.getUpgrader()
      });
    } catch (err2) {
      if (err2.code == null) {
        err2.code = codes.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err2;
    }
  }
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  getTransports() {
    return Array.of(...this.transports.values());
  }
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log64("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log64("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.getUpgrader()
        });
        let listeners = this.listeners.get(key);
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.dispatchEvent(new CustomEvent("listener:listening", {
            detail: listener
          }));
        });
        listener.addEventListener("close", () => {
          this.dispatchEvent(new CustomEvent("listener:close", {
            detail: listener
          }));
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await pSettle(tasks);
      const isListening = results.find((r) => r.isFulfilled);
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw (0, import_err_code81.default)(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw (0, import_err_code81.default)(new Error(message2), codes.ERR_NO_VALID_ADDRESSES);
      }
      log64(`libp2p in dial mode only: ${message2}`);
    }
  }
  async remove(key) {
    log64("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/upgrader.js
init_define_process();
var import_err_code86 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/constants.js
init_define_process();
var PROTOCOL_ID = "/multistream/1.0.0";

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/select.js
init_define_process();
var import_err_code83 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/multistream.js
init_define_process();
var import_err_code82 = __toESM(require_err_code(), 1);
var import_it_first5 = __toESM(require_it_first(), 1);
var NewLine = fromString("\n");
function encode12(buffer2) {
  const list = new Uint8ArrayList(buffer2, NewLine);
  return encode.single(list);
}
function write2(writer, buffer2, options = {}) {
  const encoded = encode12(buffer2);
  if (options.writeBytes === true) {
    writer.push(encoded.subarray());
  } else {
    writer.push(encoded);
  }
}
function writeAll(writer, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf2 of buffers) {
    list.append(encode12(buf2));
  }
  if (options.writeBytes === true) {
    writer.push(list.subarray());
  } else {
    writer.push(list);
  }
}
async function read(reader2, options) {
  let byteLength = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => await reader2.next(byteLength)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength = l;
  };
  const buf2 = await pipe(input, decode2({ onLength }), async (source) => await (0, import_it_first5.default)(source));
  if (buf2 == null) {
    throw (0, import_err_code82.default)(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf2.get(buf2.byteLength - 1) !== NewLine[0]) {
    throw (0, import_err_code82.default)(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf2.sublist(0, -1);
}
async function readString(reader2, options) {
  const buf2 = await read(reader2, options);
  return toString(buf2.subarray());
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/select.js
var log65 = logger("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader2, writer, rest, stream: shakeStream } = handshake(stream);
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  log65('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString(PROTOCOL_ID);
  const p2 = fromString(protocol);
  writeAll(writer, [p1, p2], options);
  let response = await readString(reader2, options);
  log65('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader2, options);
    log65('select: read "%s"', response);
  }
  if (response === protocol) {
    rest();
    return { stream: shakeStream, protocol };
  }
  for (const protocol2 of protocols) {
    log65('select: write "%s"', protocol2);
    write2(writer, fromString(protocol2), options);
    const response2 = await readString(reader2, options);
    log65('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      rest();
      return { stream: shakeStream, protocol: protocol2 };
    }
  }
  rest();
  throw (0, import_err_code83.default)(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-multistream-select-npm-3.0.0-3e80f85d4a-9.zip/node_modules/@libp2p/multistream-select/dist/src/handle.js
init_define_process();
var log66 = logger("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer, reader: reader2, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol = await readString(reader2, options);
    log66('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log66('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      write2(writer, fromString(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol)) {
      write2(writer, fromString(protocol), options);
      log66('respond with "%s" for "%s"', protocol, protocol);
      rest();
      return { stream: shakeStream, protocol };
    }
    if (protocol === "ls") {
      write2(writer, new Uint8ArrayList(...protocols.map((p) => encode12(fromString(p)))), options);
      log66('respond with "%s" for %s', protocols, protocol);
      continue;
    }
    write2(writer, fromString("na"), options);
    log66('respond with "na" for "%s"', protocol);
  }
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/upgrader.js
var import_mutable_proxy = __toESM(require_build(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-connection-npm-4.0.2-a1f854471e-9.zip/node_modules/@libp2p/connection/dist/src/index.js
init_define_process();
var import_err_code84 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-interface-connection-npm-3.0.2-bdde13ed5c-9.zip/node_modules/@libp2p/interface-connection/dist/src/index.js
init_define_process();
var symbol3 = Symbol.for("@libp2p/connection");

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-connection-npm-4.0.2-a1f854471e-9.zip/node_modules/@libp2p/connection/dist/src/index.js
var log67 = logger("libp2p:connection");
var ConnectionImpl = class {
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  get [Symbol.toStringTag]() {
    return "Connection";
  }
  get [symbol3]() {
    return true;
  }
  get streams() {
    return this._getStreams();
  }
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw (0, import_err_code84.default)(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw (0, import_err_code84.default)(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream = await this._newStream(protocols, options);
    stream.stat.direction = "outbound";
    return stream;
  }
  addStream(stream) {
    stream.stat.direction = "inbound";
  }
  removeStream(id) {
  }
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s) => s.close());
    } catch (err2) {
      log67.error(err2);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/registrar.js
init_define_process();
var import_err_code85 = __toESM(require_err_code(), 1);
var log68 = logger("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var DefaultRegistrar = class {
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this.components.getConnectionManager().addEventListener("peer:disconnect", this._onDisconnect);
    this.components.getPeerStore().addEventListener("change:protocols", this._onProtocolChange);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.topologies.keys(),
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw (0, import_err_code85.default)(new Error(`No handler registered for protocol ${protocol}`), codes.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw (0, import_err_code85.default)(new Error(`Handler already registered for protocol ${protocol}`), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.getPeerStore().protoBook.add(this.components.getPeerId(), [protocol]);
  }
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.getPeerStore().protoBook.remove(this.components.getPeerId(), protocolList);
  }
  async register(protocol, topology) {
    if (!isTopology(topology)) {
      log68.error("topology must be an instance of interfaces/topology");
      throw (0, import_err_code85.default)(new Error("topology must be an instance of interfaces/topology"), codes.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  _onDisconnect(evt) {
    const connection = evt.detail;
    void this.components.getPeerStore().protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol of peerProtocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(connection.remotePeer);
        }
      }
    }).catch((err2) => {
      log68.error(err2);
    });
  }
  _onProtocolChange(evt) {
    const { peerId, protocols, oldProtocols } = evt.detail;
    const removed = oldProtocols.filter((protocol) => !protocols.includes(protocol));
    const added = protocols.filter((protocol) => !oldProtocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peerId);
      }
    }
    for (const protocol of added) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.getConnectionManager().getConnections(peerId)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peerId, connection);
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/upgrader.js
var import_timeout_abort_controller7 = __toESM(require_timeout_abort_controller(), 1);
var import_events12 = __toESM(require_events(), 1);
var log69 = logger("libp2p:upgrader");
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err2) {
    if (err2.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxOutboundStreams;
  } catch (err2) {
    if (err2.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err2;
    }
  }
  return DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var DefaultUpgrader = class extends EventEmitter {
  constructor(components, init) {
    super();
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;
  }
  async upgradeInbound(maConn) {
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.getMetrics();
    const timeoutController = new import_timeout_abort_controller7.TimeoutController(this.inboundUpgradeTimeout);
    try {
      (0, import_events12.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, timeoutController.signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.getConnectionGater().denyInboundConnection(maConn)) {
        throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
        const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
        setPeer({ toString: () => idString });
        metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
      }
      log69("starting the inbound connection upgrade");
      let protectedConn = maConn;
      const protector = this.components.getConnectionProtector();
      if (protector != null) {
        log69("protecting the inbound connection");
        protectedConn = await protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptInbound(protectedConn));
        if (await this.components.getConnectionGater().denyInboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err2) {
        log69.error("Failed to upgrade inbound connection", err2);
        await maConn.close(err2);
        throw err2;
      }
      if (await this.components.getConnectionGater().denyInboundUpgradedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log69("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      timeoutController.clear();
    }
  }
  async upgradeOutbound(maConn) {
    const idStr = maConn.remoteAddr.getPeerId();
    if (idStr == null) {
      throw (0, import_err_code86.default)(new Error("outbound connection must have a peer id"), codes.ERR_INVALID_MULTIADDR);
    }
    const remotePeerId = peerIdFromString(idStr);
    if (await this.components.getConnectionGater().denyOutboundConnection(remotePeerId, maConn)) {
      throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes.ERR_CONNECTION_INTERCEPTED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.getMetrics();
    if (metrics != null) {
      ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
      const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      setPeer({ toB58String: () => idString });
      metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
    }
    log69("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    const protector = this.components.getConnectionProtector();
    if (protector != null) {
      protectedConn = await protector.protect(maConn);
    }
    try {
      ({
        conn: encryptedConn,
        remotePeer,
        protocol: cryptoProtocol
      } = await this._encryptOutbound(protectedConn, remotePeerId));
      if (await this.components.getConnectionGater().denyOutboundEncryptedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
      }
      if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      } else {
        upgradedConn = encryptedConn;
      }
    } catch (err2) {
      log69.error("Failed to upgrade outbound connection", err2);
      await maConn.close(err2);
      throw err2;
    }
    if (await this.components.getConnectionGater().denyOutboundUpgradedConnection(remotePeer, {
      ...protectedConn,
      ...encryptedConn
    })) {
      throw (0, import_err_code86.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
    }
    if (metrics != null) {
      metrics.updatePlaceholder(proxyPeer, remotePeer);
      setPeer(remotePeer);
    }
    log69("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.getRegistrar().getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols);
            log69("%s: incoming stream opened on %s", direction, protocol);
            const metrics = this.components.getMetrics();
            if (metrics != null) {
              metrics.trackStream({ stream, remotePeer, protocol });
            }
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.getRegistrar());
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              muxedStream.abort((0, import_err_code86.default)(new Error(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));
              return;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.stat.protocol = protocol;
            this.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch((err2) => log69.error(err2));
            connection.addStream(muxedStream);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch((err2) => {
            log69.error(err2);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      if (isInitializable(muxer)) {
        muxer.init(this.components);
      }
      newStream = async (protocols, options = {}) => {
        if (muxer == null) {
          throw (0, import_err_code86.default)(new Error("Stream is not multiplexed"), codes.ERR_MUXER_UNAVAILABLE);
        }
        log69("%s: starting new stream on %s", direction, protocols);
        const muxedStream = muxer.newStream();
        const metrics = this.components.getMetrics();
        let controller;
        try {
          if (options.signal == null) {
            log69("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            controller = new import_timeout_abort_controller7.TimeoutController(3e4);
            options.signal = controller.signal;
            try {
              (0, import_events12.setMaxListeners)?.(Infinity, controller.signal);
            } catch {
            }
          }
          const { stream, protocol } = await select(muxedStream, protocols, options);
          if (metrics != null) {
            metrics.trackStream({ stream, remotePeer, protocol });
          }
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.getRegistrar());
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount === outgoingLimit) {
            const err2 = (0, import_err_code86.default)(new Error(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err2);
            throw err2;
          }
          this.components.getPeerStore().protoBook.add(remotePeer, [protocol]).catch((err2) => log69.error(err2));
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.stat.protocol = protocol;
          return muxedStream;
        } catch (err2) {
          log69.error("could not create new stream", err2);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err2.code != null) {
            throw err2;
          }
          throw (0, import_err_code86.default)(err2, codes.ERR_UNSUPPORTED_PROTOCOL);
        } finally {
          if (controller != null) {
            controller.clear();
          }
        }
      };
      pipe(upgradedConn, muxer, upgradedConn).catch(log69.error);
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err2) {
              log69.error(err2);
            } finally {
              this.dispatchEvent(new CustomEvent("connectionEnd", {
                detail: connection
              }));
            }
          })().catch((err2) => {
            log69.error(err2);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw (0, import_err_code86.default)(new Error("connection is not multiplexed"), codes.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.dispatchEvent(new CustomEvent("connection", {
      detail: connection
    }));
    return connection;
  }
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler } = this.components.getRegistrar().getHandler(protocol);
    handler({ connection, stream });
  }
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log69("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log69("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.getPeerId(), stream),
        protocol
      };
    } catch (err2) {
      throw (0, import_err_code86.default)(err2, codes.ERR_ENCRYPTION_FAILED);
    }
  }
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log69("selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log69("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.getPeerId(), stream, remotePeerId),
        protocol
      };
    } catch (err2) {
      throw (0, import_err_code86.default)(err2, codes.ERR_ENCRYPTION_FAILED);
    }
  }
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log69("outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      log69("%s selected as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err2) {
      log69.error("error multiplexing outbound stream", err2);
      throw (0, import_err_code86.default)(err2, codes.ERR_MUXER_UNAVAILABLE);
    }
  }
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log69("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err2) {
      log69.error("error multiplexing inbound stream", err2);
      throw (0, import_err_code86.default)(err2, codes.ERR_MUXER_UNAVAILABLE);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/identify/index.js
init_define_process();
var import_err_code87 = __toESM(require_err_code(), 1);
var import_it_drain12 = __toESM(require_it_drain(), 1);
var import_it_first6 = __toESM(require_it_first(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/identify/pb/message.js
init_define_process();
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.protocolVersion != null) {
          writer.uint32(42);
          writer.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          writer.uint32(50);
          writer.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          writer.uint32(10);
          writer.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            writer.uint32(18);
            writer.bytes(value);
          }
        } else {
          throw new Error('Protocol error: required field "listenAddrs" was not found in object');
        }
        if (obj.observedAddr != null) {
          writer.uint32(34);
          writer.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            writer.uint32(26);
            writer.string(value);
          }
        } else {
          throw new Error('Protocol error: required field "protocols" was not found in object');
        }
        if (obj.signedPeerRecord != null) {
          writer.uint32(66);
          writer.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader2.string();
              break;
            case 6:
              obj.agentVersion = reader2.string();
              break;
            case 1:
              obj.publicKey = reader2.bytes();
              break;
            case 2:
              obj.listenAddrs = obj.listenAddrs ?? [];
              obj.listenAddrs.push(reader2.bytes());
              break;
            case 4:
              obj.observedAddr = reader2.bytes();
              break;
            case 3:
              obj.protocols = obj.protocols ?? [];
              obj.protocols.push(reader2.string());
              break;
            case 8:
              obj.signedPeerRecord = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        obj.listenAddrs = obj.listenAddrs ?? [];
        obj.protocols = obj.protocols ?? [];
        if (obj.listenAddrs == null) {
          throw new Error('Protocol error: value for required field "listenAddrs" was not found in protobuf');
        }
        if (obj.protocols == null) {
          throw new Error('Protocol error: value for required field "protocols" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf2) => {
    return decodeMessage(buf2, Identify2.codec());
  };
})(Identify || (Identify = {}));

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/identify/consts.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/version.js
init_define_process();
var version2 = "0.0.0";
var name5 = "libp2p";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/identify/consts.js
var AGENT_VERSION = `js-libp2p/${version2}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/identify/index.js
var import_timeout_abort_controller8 = __toESM(require_timeout_abort_controller(), 1);
var import_events13 = __toESM(require_events(), 1);
var log70 = logger("libp2p:identify");
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var IdentifyService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.init = init;
    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.host = {
      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      ...init.host
    };
    this.components.getConnectionManager().addEventListener("peer:connect", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch(log70.error);
    });
    this.components.getPeerStore().addEventListener("change:multiaddrs", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.getPeerId().equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log70.error(err2));
      }
    });
    this.components.getPeerStore().addEventListener("change:protocols", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.getPeerId().equals(peerId)) {
        void this.pushToPeerStore().catch((err2) => log70.error(err2));
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "AgentVersion", fromString(this.host.agentVersion));
    await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "ProtocolVersion", fromString(this.host.protocolVersion));
    await this.components.getRegistrar().handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err2) => {
        log70.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    await this.components.getRegistrar().handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err2) => {
        log70.error(err2);
      });
    }, {
      maxInboundStreams: this.init.maxPushIncomingStreams,
      maxOutboundStreams: this.init.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.identifyProtocolStr);
    await this.components.getRegistrar().unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  async push(connections) {
    const signedPeerRecord = await this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId());
    const listenAddrs = this.components.getAddressManager().getAddresses().map((ma) => ma.bytes);
    const protocols = await this.components.getPeerStore().protoBook.get(this.components.getPeerId());
    const pushes = connections.map(async (connection) => {
      let stream;
      const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal: timeoutController.signal
        });
        const source = abortableDuplex(stream, timeoutController.signal);
        await pipe([Identify.encode({
          listenAddrs,
          signedPeerRecord,
          protocols
        })], encode(), source, import_it_drain12.default);
      } catch (err2) {
        log70.error("could not push identify update to peer", err2);
      } finally {
        if (stream != null) {
          stream.close();
        }
        timeoutController.clear();
      }
    });
    await Promise.all(pushes);
  }
  async pushToPeerStore() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    for (const conn of this.components.getConnectionManager().getConnections()) {
      const peerId = conn.remotePeer;
      const peer = await this.components.getPeerStore().get(peerId);
      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
        continue;
      }
      connections.push(conn);
    }
    await this.push(connections);
  }
  async _identify(connection, options = {}) {
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const data = await pipe([], source, decode2({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await (0, import_it_first6.default)(source2));
      if (data == null) {
        throw (0, import_err_code87.default)(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err2) {
        throw (0, import_err_code87.default)(err2, codes.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, agentVersion, protocolVersion } = message2;
    if (publicKey == null) {
      throw (0, import_err_code87.default)(new Error("public key was missing from identify message"), codes.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw (0, import_err_code87.default)(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
    }
    if (this.components.getPeerId().equals(id)) {
      throw (0, import_err_code87.default)(new Error("identified peer is our own peer id?"), codes.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
    if (signedPeerRecord != null) {
      log70("received signed peer record from %p", id);
      try {
        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);
        if (!envelope.peerId.equals(id)) {
          throw (0, import_err_code87.default)(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
        }
        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          await this.components.getPeerStore().protoBook.set(id, protocols);
          if (agentVersion != null) {
            await this.components.getPeerStore().metadataBook.setValue(id, "AgentVersion", fromString(agentVersion));
          }
          if (protocolVersion != null) {
            await this.components.getPeerStore().metadataBook.setValue(id, "ProtocolVersion", fromString(protocolVersion));
          }
          log70("identify completed for peer %p and protocols %o", id, protocols);
          return;
        }
      } catch (err2) {
        log70("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log70("no signed peer record received from %p", id);
    }
    log70("falling back to legacy addresses from %p", id);
    try {
      await this.components.getPeerStore().addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log70.error("received invalid addrs", err2);
    }
    await this.components.getPeerStore().protoBook.set(id, protocols);
    if (agentVersion != null) {
      await this.components.getPeerStore().metadataBook.setValue(id, "AgentVersion", fromString(agentVersion));
    }
    if (protocolVersion != null) {
      await this.components.getPeerStore().metadataBook.setValue(id, "ProtocolVersion", fromString(protocolVersion));
    }
    log70("identify completed for peer %p and protocols %o", id, protocols);
    log70("received observed address of %s", cleanObservedAddr?.toString());
  }
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const publicKey = this.components.getPeerId().publicKey ?? new Uint8Array(0);
      const peerData = await this.components.getPeerStore().get(this.components.getPeerId());
      const multiaddrs = this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord({
          peerId: this.components.getPeerId(),
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId());
        await this.components.getPeerStore().addressBook.consumePeerRecord(envelope);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message2 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source = abortableDuplex(stream, timeoutController.signal);
      await pipe([message2], encode(), source, import_it_drain12.default);
    } catch (err2) {
      log70.error("could not respond to identify request", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
  }
  async _handlePush(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.init.timeout);
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    let message2;
    try {
      const source = abortableDuplex(stream, timeoutController.signal);
      const data2 = await pipe([], source, decode2({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await (0, import_it_first6.default)(source2));
      if (data2 != null) {
        message2 = Identify.decode(data2);
      }
    } catch (err2) {
      return log70.error("received invalid message", err2);
    } finally {
      stream.close();
      timeoutController.clear();
    }
    if (message2 == null) {
      return log70.error("received invalid message");
    }
    const id = connection.remotePeer;
    if (this.components.getPeerId().equals(id)) {
      log70("received push from ourselves?");
      return;
    }
    log70("received push from %p", id);
    if (message2.signedPeerRecord != null) {
      log70("received signedPeerRecord in push");
      try {
        const envelope = await RecordEnvelope.openAndCertify(message2.signedPeerRecord, PeerRecord.DOMAIN);
        if (await this.components.getPeerStore().addressBook.consumePeerRecord(envelope)) {
          log70("consumed signedPeerRecord sent in push");
          await this.components.getPeerStore().protoBook.set(id, message2.protocols);
          return;
        } else {
          log70("failed to consume signedPeerRecord sent in push");
        }
      } catch (err2) {
        log70("received invalid envelope, discard it and fallback to listenAddrs is available", err2);
      }
    } else {
      log70("did not receive signedPeerRecord in push");
    }
    try {
      await this.components.getPeerStore().addressBook.set(id, message2.listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err2) {
      log70.error("received invalid addrs", err2);
    }
    try {
      await this.components.getPeerStore().protoBook.set(id, message2.protocols);
    } catch (err2) {
      log70.error("received invalid protocols", err2);
    }
    log70("handled push from %p", id);
  }
  static getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/fetch/index.js
init_define_process();
var import_err_code88 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/fetch/pb/proto.js
init_define_process();
var FetchRequest;
(function(FetchRequest2) {
  let _codec;
  FetchRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.identifier != null) {
          writer.uint32(10);
          writer.string(obj.identifier);
        } else {
          throw new Error('Protocol error: required field "identifier" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identifier = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.identifier == null) {
          throw new Error('Protocol error: value for required field "identifier" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchRequest2.encode = (obj) => {
    return encodeMessage(obj, FetchRequest2.codec());
  };
  FetchRequest2.decode = (buf2) => {
    return decodeMessage(buf2, FetchRequest2.codec());
  };
})(FetchRequest || (FetchRequest = {}));
var FetchResponse;
(function(FetchResponse2) {
  let StatusCode;
  (function(StatusCode2) {
    StatusCode2["OK"] = "OK";
    StatusCode2["NOT_FOUND"] = "NOT_FOUND";
    StatusCode2["ERROR"] = "ERROR";
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let __StatusCodeValues;
  (function(__StatusCodeValues2) {
    __StatusCodeValues2[__StatusCodeValues2["OK"] = 0] = "OK";
    __StatusCodeValues2[__StatusCodeValues2["NOT_FOUND"] = 1] = "NOT_FOUND";
    __StatusCodeValues2[__StatusCodeValues2["ERROR"] = 2] = "ERROR";
  })(__StatusCodeValues || (__StatusCodeValues = {}));
  (function(StatusCode2) {
    StatusCode2.codec = () => {
      return enumeration(__StatusCodeValues);
    };
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let _codec;
  FetchResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.status != null) {
          writer.uint32(8);
          FetchResponse2.StatusCode.codec().encode(obj.status, writer);
        } else {
          throw new Error('Protocol error: required field "status" was not found in object');
        }
        if (obj.data != null) {
          writer.uint32(18);
          writer.bytes(obj.data);
        } else {
          throw new Error('Protocol error: required field "data" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.status = FetchResponse2.StatusCode.codec().decode(reader2);
              break;
            case 2:
              obj.data = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.status == null) {
          throw new Error('Protocol error: value for required field "status" was not found in protobuf');
        }
        if (obj.data == null) {
          throw new Error('Protocol error: value for required field "data" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchResponse2.encode = (obj) => {
    return encodeMessage(obj, FetchResponse2.codec());
  };
  FetchResponse2.decode = (buf2) => {
    return decodeMessage(buf2, FetchResponse2.codec());
  };
})(FetchResponse || (FetchResponse = {}));

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/fetch/constants.js
init_define_process();
var PROTOCOL_VERSION = "0.0.1";
var PROTOCOL_NAME = "fetch";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/fetch/index.js
var import_it_first7 = __toESM(require_it_first(), 1);
var import_timeout_abort_controller9 = __toESM(require_timeout_abort_controller(), 1);
var import_events14 = __toESM(require_events(), 1);
var log71 = logger("libp2p:fetch");
var FetchService = class {
  constructor(components, init) {
    this.started = false;
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? "libp2p"}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.lookupFunctions = /* @__PURE__ */ new Map();
    this.handleMessage = this.handleMessage.bind(this);
    this.init = init;
  }
  async start() {
    await this.components.getRegistrar().handle(this.protocol, (data) => {
      void this.handleMessage(data).catch((err2) => {
        log71.error(err2);
      }).finally(() => {
        data.stream.close();
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async fetch(peer, key, options = {}) {
    log71("dialing %s to %p", this.protocol, peer);
    const connection = await this.components.getConnectionManager().openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller9.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events14.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([FetchRequest.encode({ identifier: key })], encode(), source, decode2(), async function(source2) {
        const buf2 = await (0, import_it_first7.default)(source2);
        if (buf2 == null) {
          throw (0, import_err_code88.default)(new Error("No data received"), codes.ERR_INVALID_MESSAGE);
        }
        const response = FetchResponse.decode(buf2);
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            const errmsg = new TextDecoder().decode(response.data);
            throw (0, import_err_code88.default)(new Error("Error in fetch protocol response: " + errmsg), codes.ERR_INVALID_PARAMETERS);
          }
          default: {
            throw (0, import_err_code88.default)(new Error("Unknown response status"), codes.ERR_INVALID_MESSAGE);
          }
        }
      });
      return result ?? null;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async handleMessage(data) {
    const { stream } = data;
    const self2 = this;
    await pipe(stream, decode2(), async function* (source) {
      const buf2 = await (0, import_it_first7.default)(source);
      if (buf2 == null) {
        throw (0, import_err_code88.default)(new Error("No data received"), codes.ERR_INVALID_MESSAGE);
      }
      const request2 = FetchRequest.decode(buf2);
      let response;
      const lookup = self2._getLookupFunction(request2.identifier);
      if (lookup != null) {
        const data2 = await lookup(request2.identifier);
        if (data2 != null) {
          response = { status: FetchResponse.StatusCode.OK, data: data2 };
        } else {
          response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
        }
      } else {
        const errmsg = new TextEncoder().encode("No lookup function registered for key: " + request2.identifier);
        response = { status: FetchResponse.StatusCode.ERROR, data: errmsg };
      }
      yield FetchResponse.encode(response);
    }, encode(), stream);
  }
  _getLookupFunction(key) {
    for (const prefix of this.lookupFunctions.keys()) {
      if (key.startsWith(prefix)) {
        return this.lookupFunctions.get(prefix);
      }
    }
  }
  registerLookupFunction(prefix, lookup) {
    if (this.lookupFunctions.has(prefix)) {
      throw (0, import_err_code88.default)(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes.ERR_KEY_ALREADY_EXISTS);
    }
    this.lookupFunctions.set(prefix, lookup);
  }
  unregisterLookupFunction(prefix, lookup) {
    if (lookup != null) {
      const existingLookup = this.lookupFunctions.get(prefix);
      if (existingLookup !== lookup) {
        return;
      }
    }
    this.lookupFunctions.delete(prefix);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/ping/index.js
init_define_process();
var import_err_code89 = __toESM(require_err_code(), 1);
var import_it_first8 = __toESM(require_it_first(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/ping/constants.js
init_define_process();
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/ping/index.js
var import_timeout_abort_controller10 = __toESM(require_timeout_abort_controller(), 1);
var import_events15 = __toESM(require_events(), 1);
var log72 = logger("libp2p:ping");
var PingService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.init = init;
  }
  async start() {
    await this.components.getRegistrar().handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.getRegistrar().unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  handleMessage(data) {
    const { stream } = data;
    void pipe(stream, stream).catch((err2) => {
      log72.error(err2);
    });
  }
  async ping(peer, options = {}) {
    log72("dialing %s to %p", this.protocol, peer);
    const start = Date.now();
    const data = randomBytes(PING_LENGTH);
    const connection = await this.components.getConnectionManager().openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller10.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events15.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([data], source, async (source2) => await (0, import_it_first8.default)(source2));
      const end = Date.now();
      if (result == null || !equals(data, result.subarray())) {
        throw (0, import_err_code89.default)(new Error("Received wrong ping ack"), codes.ERR_WRONG_PING_ACK);
      }
      return end - start;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/nat-manager.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@achingbrain-nat-port-mapper-npm-1.0.7-1c6c581927-9.zip/node_modules/@achingbrain/nat-port-mapper/dist/src/browser.js
init_define_process();
async function upnpNat() {
  throw new Error("Not supported in browsers");
}

// ../../../../../Users/z/.yarn/berry/cache/wherearewe-npm-2.0.1-1c830a2fe6-9.zip/node_modules/wherearewe/src/index.js
init_define_process();
var import_is_electron = __toESM(require_is_electron(), 1);
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser3 = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode2 = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker2 = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/nat-manager.js
var import_private_ip2 = __toESM(require_private_ip(), 1);
var import_err_code90 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/is-loopback-addr-npm-2.0.1-faa8483b1d-9.zip/node_modules/is-loopback-addr/dist/src/index.js
init_define_process();
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-utils-npm-3.0.2-864f4e9d6c-9.zip/node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/nat-manager.js
var log73 = logger("libp2p:nat");
var DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
var NatManager = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.enabled = init.enabled;
    this.externalAddress = init.externalAddress;
    this.localAddress = init.localAddress;
    this.description = init.description ?? `${name5}@${version2} ${this.components.getPeerId().toString()}`;
    this.ttl = init.ttl ?? DEFAULT_TTL;
    this.keepAlive = init.keepAlive ?? true;
    this.gateway = init.gateway;
    if (this.ttl < DEFAULT_TTL) {
      throw (0, import_err_code90.default)(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes.ERR_INVALID_PARAMETERS);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
  }
  afterStart() {
    if (isBrowser3 || !this.enabled || this.started) {
      return;
    }
    this.started = true;
    void this._start().catch((err2) => {
      log73.error(err2);
    });
  }
  async _start() {
    const addrs = this.components.getTransportManager().getAddrs();
    for (const addr of addrs) {
      const { family, host, port, transport } = addr.toOptions();
      if (!addr.isThinWaistAddress() || transport !== "tcp") {
        continue;
      }
      if (isLoopback(addr)) {
        continue;
      }
      if (family !== 4) {
        continue;
      }
      const client = await this._getClient();
      const publicIp = this.externalAddress ?? await client.externalIp();
      if ((0, import_private_ip2.default)(publicIp)) {
        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
      }
      const publicPort = highPort();
      log73(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
      await client.map({
        publicPort,
        localPort: port,
        localAddress: this.localAddress,
        protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
      });
      this.components.getAddressManager().addObservedAddr(fromNodeAddress({
        family: 4,
        address: publicIp,
        port: publicPort
      }, transport));
    }
  }
  async _getClient() {
    if (this.client != null) {
      return this.client;
    }
    this.client = await upnpNat({
      description: this.description,
      ttl: this.ttl,
      keepAlive: this.keepAlive,
      gateway: this.gateway
    });
    return this.client;
  }
  async stop() {
    if (isBrowser3 || this.client == null) {
      return;
    }
    try {
      await this.client.close();
      this.client = void 0;
    } catch (err2) {
      log73.error(err2);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/peer-record-updater.js
init_define_process();
var log74 = logger("libp2p:peer-record-updater");
var PeerRecordUpdater = class {
  constructor(components) {
    this.components = components;
    this.started = false;
    this.update = this.update.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
    this.components.getTransportManager().addEventListener("listener:listening", this.update);
    this.components.getTransportManager().addEventListener("listener:close", this.update);
    this.components.getAddressManager().addEventListener("change:addresses", this.update);
  }
  async stop() {
    this.started = false;
    this.components.getTransportManager().removeEventListener("listener:listening", this.update);
    this.components.getTransportManager().removeEventListener("listener:close", this.update);
    this.components.getAddressManager().removeEventListener("change:addresses", this.update);
  }
  update() {
    Promise.resolve().then(async () => {
      const peerRecord = new PeerRecord({
        peerId: this.components.getPeerId(),
        multiaddrs: this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.getPeerId());
      await this.components.getPeerStore().addressBook.consumePeerRecord(envelope);
    }).catch((err2) => {
      log74.error("Could not update self peer record: %o", err2);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/dht/dht-peer-routing.js
init_define_process();
var import_err_code91 = __toESM(require_err_code(), 1);
var DHTPeerRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw (0, import_err_code91.default)(new Error(messages2.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/address-book.js
init_define_process();
var import_err_code92 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/errors.js
init_define_process();
var codes2 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
  ERR_NOT_FOUND: "ERR_NOT_FOUND"
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/address-book.js
var import_it_all8 = __toESM(require_it_all(), 1);
var import_it_filter11 = __toESM(require_it_filter(), 1);
var import_it_map13 = __toESM(require_it_map(), 1);
var import_it_foreach2 = __toESM(require_it_foreach(), 1);
var log75 = logger("libp2p:peer-store:address-book");
var EVENT_NAME = "change:multiaddrs";
async function allowAll() {
  return true;
}
var PeerStoreAddressBook = class {
  constructor(dispatchEvent, store, addressFilter) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
    this.addressFilter = addressFilter ?? allowAll;
  }
  async consumePeerRecord(envelope) {
    log75.trace("consumePeerRecord await write lock");
    const release = await this.store.lock.writeLock();
    log75.trace("consumePeerRecord got write lock");
    let peerId;
    let peer;
    let updatedPeer;
    try {
      let peerRecord;
      try {
        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      } catch (err2) {
        log75.error("invalid peer record received");
        return false;
      }
      peerId = peerRecord.peerId;
      const multiaddrs = peerRecord.multiaddrs;
      if (!peerId.equals(envelope.peerId)) {
        log75("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (multiaddrs == null || multiaddrs.length === 0) {
        return false;
      }
      if (await this.store.has(peerId)) {
        peer = await this.store.load(peerId);
        if (peer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log75("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            return false;
          }
        }
      }
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);
      updatedPeer = await this.store.patchOrCreate(peerId, {
        addresses,
        peerRecordEnvelope: envelope.marshal().subarray()
      });
      log75("stored provided peer record for %p", peerRecord.peerId);
    } finally {
      log75.trace("consumePeerRecord release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    return true;
  }
  async getRawEnvelope(peerId) {
    log75.trace("getRawEnvelope await read lock");
    const release = await this.store.lock.readLock();
    log75.trace("getRawEnvelope got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.peerRecordEnvelope;
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log75.trace("getRawEnvelope release read lock");
      release();
    }
  }
  async getPeerRecord(peerId) {
    const raw = await this.getRawEnvelope(peerId);
    if (raw == null) {
      return void 0;
    }
    return await RecordEnvelope.createFromProtobuf(raw);
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log75.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log75.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.addresses;
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log75.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log75.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code92.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes2.ERR_INVALID_PARAMETERS);
    }
    log75.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log75.trace("set got write lock");
    let hasPeer = false;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, { addresses });
      log75("set multiaddrs for %p", peerId);
    } finally {
      log75.trace("set multiaddrs for %p", peerId);
      log75("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (!hasPeer) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async add(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log75.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code92.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes2.ERR_INVALID_PARAMETERS);
    }
    log75.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log75.trace("add got write lock");
    let hasPeer;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses });
      log75("added multiaddrs for %p", peerId);
    } finally {
      log75.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (hasPeer === true) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log75.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log75.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        addresses: []
      });
    } finally {
      log75.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME, {
        detail: {
          peerId,
          multiaddrs: [],
          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        }
      }));
    }
  }
};
async function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
  return await pipe(multiaddrs, (source) => (0, import_it_foreach2.default)(source, (multiaddr2) => {
    if (!isMultiaddr(multiaddr2)) {
      log75.error("multiaddr must be an instance of Multiaddr");
      throw (0, import_err_code92.default)(new Error("multiaddr must be an instance of Multiaddr"), codes2.ERR_INVALID_PARAMETERS);
    }
  }), (source) => (0, import_it_filter11.default)(source, async (multiaddr2) => await addressFilter(peerId, multiaddr2)), (source) => (0, import_it_map13.default)(source, (multiaddr2) => {
    return {
      multiaddr: multiaddr2,
      isCertified
    };
  }), async (source) => await (0, import_it_all8.default)(source));
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/key-book.js
init_define_process();
var import_err_code93 = __toESM(require_err_code(), 1);
var log76 = logger("libp2p:peer-store:key-book");
var EVENT_NAME2 = "change:pubkey";
var PeerStoreKeyBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async set(peerId, publicKey) {
    peerId = peerIdFromPeerId(peerId);
    if (!(publicKey instanceof Uint8Array)) {
      log76.error("publicKey must be an instance of Uint8Array to store data");
      throw (0, import_err_code93.default)(new Error("publicKey must be an instance of PublicKey"), codes2.ERR_INVALID_PARAMETERS);
    }
    log76.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log76.trace("set got write lock");
    let updatedKey = false;
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
        if (peer.pubKey != null && equals(peer.pubKey, publicKey)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: publicKey
      });
      updatedKey = true;
    } finally {
      log76.trace("set release write lock");
      release();
    }
    if (updatedKey) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
        detail: {
          peerId,
          publicKey,
          oldPublicKey: peer == null ? void 0 : peer.pubKey
        }
      }));
    }
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log76.trace("get await write lock");
    const release = await this.store.lock.readLock();
    log76.trace("get got write lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.pubKey;
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log76("get release write lock");
      release();
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log76.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log76.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: void 0
      });
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log76.trace("delete release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
      detail: {
        peerId,
        publicKey: void 0,
        oldPublicKey: peer == null ? void 0 : peer.pubKey
      }
    }));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/metadata-book.js
init_define_process();
var import_err_code94 = __toESM(require_err_code(), 1);
var log77 = logger("libp2p:peer-store:metadata-book");
var EVENT_NAME3 = "change:metadata";
var PeerStoreMetadataBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log77.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log77.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata;
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log77.trace("get release read lock");
      release();
    }
    return /* @__PURE__ */ new Map();
  }
  async getValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log77.trace("getValue await read lock");
    const release = await this.store.lock.readLock();
    log77.trace("getValue got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata.get(key);
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log77.trace("getValue release write lock");
      release();
    }
  }
  async set(peerId, metadata) {
    peerId = peerIdFromPeerId(peerId);
    if (!(metadata instanceof Map)) {
      log77.error("valid metadata must be provided to store data");
      throw (0, import_err_code94.default)(new Error("valid metadata must be provided"), codes2.ERR_INVALID_PARAMETERS);
    }
    log77.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log77.trace("set got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.mergeOrCreate(peerId, {
        metadata
      });
    } finally {
      log77.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async setValue(peerId, key, value) {
    peerId = peerIdFromPeerId(peerId);
    if (typeof key !== "string" || !(value instanceof Uint8Array)) {
      log77.error("valid key and value must be provided to store data");
      throw (0, import_err_code94.default)(new Error("valid key and value must be provided"), codes2.ERR_INVALID_PARAMETERS);
    }
    log77.trace("setValue await write lock");
    const release = await this.store.lock.writeLock();
    log77.trace("setValue got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const existingValue = peer.metadata.get(key);
        if (existingValue != null && equals(value, existingValue)) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        metadata: /* @__PURE__ */ new Map([[key, value]])
      });
    } finally {
      log77.trace("setValue release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata: updatedPeer.metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log77.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log77.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      if (peer != null) {
        await this.store.patch(peerId, {
          metadata: /* @__PURE__ */ new Map()
        });
      }
    } finally {
      log77.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata: /* @__PURE__ */ new Map(),
          oldMetadata: peer.metadata
        }
      }));
    }
  }
  async deleteValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log77.trace("deleteValue await write lock");
    const release = await this.store.lock.writeLock();
    log77.trace("deleteValue got write lock");
    let metadata;
    let peer;
    try {
      peer = await this.store.load(peerId);
      metadata = peer.metadata;
      metadata.delete(key);
      await this.store.patch(peerId, {
        metadata
      });
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log77.trace("deleteValue release write lock");
      release();
    }
    if (metadata != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata,
          oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
        }
      }));
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/proto-book.js
init_define_process();
var import_err_code95 = __toESM(require_err_code(), 1);
var log78 = logger("libp2p:peer-store:proto-book");
var EVENT_NAME4 = "change:protocols";
var PeerStoreProtoBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    log78.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log78.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.protocols;
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
    } finally {
      log78.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log78.error("protocols must be provided to store data");
      throw (0, import_err_code95.default)(new Error("protocols must be provided"), codes2.ERR_INVALID_PARAMETERS);
    }
    log78.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log78.trace("set got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
      log78("stored provided protocols for %p", peerId);
    } finally {
      log78.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async add(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log78.error("protocols must be provided to store data");
      throw (0, import_err_code95.default)(new Error("protocols must be provided"), codes2.ERR_INVALID_PARAMETERS);
    }
    log78.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log78.trace("add got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...peer.protocols,
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        protocols
      });
      log78("added provided protocols for %p", peerId);
    } finally {
      log78.trace("add release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async remove(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log78.error("protocols must be provided to store data");
      throw (0, import_err_code95.default)(new Error("protocols must be provided"), codes2.ERR_INVALID_PARAMETERS);
    }
    log78.trace("remove await write lock");
    const release = await this.store.lock.writeLock();
    log78.trace("remove got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const protocolSet = new Set(peer.protocols);
        for (const protocol of protocols) {
          protocolSet.delete(protocol);
        }
        if (peer.protocols.length === protocolSet.size) {
          return;
        }
        protocols = Array.from(protocolSet);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
    } finally {
      log78.trace("remove release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log78.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log78.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err2) {
        if (err2.code !== codes2.ERR_NOT_FOUND) {
          throw err2;
        }
      }
      await this.store.patchOrCreate(peerId, {
        protocols: []
      });
    } finally {
      log78.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
        detail: {
          peerId,
          protocols: [],
          oldProtocols: peer.protocols
        }
      }));
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/store.js
init_define_process();
var import_err_code96 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/pb/peer.js
init_define_process();
var Peer2;
(function(Peer3) {
  let _codec;
  Peer3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            writer.uint32(10);
            Address2.codec().encode(value, writer);
          }
        } else {
          throw new Error('Protocol error: required field "addresses" was not found in object');
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            writer.uint32(18);
            writer.string(value);
          }
        } else {
          throw new Error('Protocol error: required field "protocols" was not found in object');
        }
        if (obj.metadata != null) {
          for (const value of obj.metadata) {
            writer.uint32(26);
            Metadata3.codec().encode(value, writer);
          }
        } else {
          throw new Error('Protocol error: required field "metadata" was not found in object');
        }
        if (obj.pubKey != null) {
          writer.uint32(34);
          writer.bytes(obj.pubKey);
        }
        if (obj.peerRecordEnvelope != null) {
          writer.uint32(42);
          writer.bytes(obj.peerRecordEnvelope);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: []
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address2.codec().decode(reader2, reader2.uint32()));
              break;
            case 2:
              obj.protocols.push(reader2.string());
              break;
            case 3:
              obj.metadata.push(Metadata3.codec().decode(reader2, reader2.uint32()));
              break;
            case 4:
              obj.pubKey = reader2.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer3.encode = (obj) => {
    return encodeMessage(obj, Peer3.codec());
  };
  Peer3.decode = (buf2) => {
    return decodeMessage(buf2, Peer3.codec());
  };
})(Peer2 || (Peer2 = {}));
var Address2;
(function(Address3) {
  let _codec;
  Address3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.multiaddr != null) {
          writer.uint32(10);
          writer.bytes(obj.multiaddr);
        } else {
          throw new Error('Protocol error: required field "multiaddr" was not found in object');
        }
        if (obj.isCertified != null) {
          writer.uint32(16);
          writer.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader2.bytes();
              break;
            case 2:
              obj.isCertified = reader2.bool();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.multiaddr == null) {
          throw new Error('Protocol error: value for required field "multiaddr" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Address3.encode = (obj) => {
    return encodeMessage(obj, Address3.codec());
  };
  Address3.decode = (buf2) => {
    return decodeMessage(buf2, Address3.codec());
  };
})(Address2 || (Address2 = {}));
var Metadata3;
(function(Metadata4) {
  let _codec;
  Metadata4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.key != null) {
          writer.uint32(10);
          writer.string(obj.key);
        } else {
          throw new Error('Protocol error: required field "key" was not found in object');
        }
        if (obj.value != null) {
          writer.uint32(18);
          writer.bytes(obj.value);
        } else {
          throw new Error('Protocol error: required field "value" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          key: "",
          value: new Uint8Array(0)
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.string();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.key == null) {
          throw new Error('Protocol error: value for required field "key" was not found in protobuf');
        }
        if (obj.value == null) {
          throw new Error('Protocol error: value for required field "value" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata4.encode = (obj) => {
    return encodeMessage(obj, Metadata4.codec());
  };
  Metadata4.decode = (buf2) => {
    return decodeMessage(buf2, Metadata4.codec());
  };
})(Metadata3 || (Metadata3 = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/store.js
var log79 = logger("libp2p:peer-store:store");
var NAMESPACE_COMMON = "/peers/";
var PersistentStore = class {
  constructor() {
    this.components = new Components();
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  init(components) {
    this.components = components;
  }
  _peerIdToDatastoreKey(peerId) {
    if (peerId.type == null) {
      log79.error("peerId must be an instance of peer-id to store data");
      throw (0, import_err_code96.default)(new Error("peerId must be an instance of peer-id"), codes2.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }
  async has(peerId) {
    return await this.components.getDatastore().has(this._peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    await this.components.getDatastore().delete(this._peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf2 = await this.components.getDatastore().get(this._peerIdToDatastoreKey(peerId));
    const peer = Peer2.decode(buf2);
    const metadata = /* @__PURE__ */ new Map();
    for (const meta of peer.metadata) {
      metadata.set(meta.key, meta.value);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata,
      pubKey: peer.pubKey ?? void 0,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0
    };
  }
  async save(peer) {
    if (peer.pubKey != null && peer.id.publicKey != null && !equals(peer.pubKey, peer.id.publicKey)) {
      log79.error("peer publicKey bytes do not match peer id publicKey bytes");
      throw (0, import_err_code96.default)(new Error("publicKey bytes do not match peer id publicKey bytes"), codes2.ERR_INVALID_PARAMETERS);
    }
    const addressSet = /* @__PURE__ */ new Set();
    const addresses = peer.addresses.filter((address) => {
      if (addressSet.has(address.multiaddr.toString())) {
        return false;
      }
      addressSet.add(address.multiaddr.toString());
      return true;
    }).sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ multiaddr: multiaddr2, isCertified }) => ({
      multiaddr: multiaddr2.bytes,
      isCertified
    }));
    const metadata = [];
    [...peer.metadata.keys()].sort().forEach((key) => {
      const value = peer.metadata.get(key);
      if (value != null) {
        metadata.push({ key, value });
      }
    });
    const buf2 = Peer2.encode({
      addresses,
      protocols: peer.protocols.sort(),
      pubKey: peer.pubKey,
      metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope
    });
    await this.components.getDatastore().put(this._peerIdToDatastoreKey(peer.id), buf2.subarray());
    return await this.load(peer.id);
  }
  async patch(peerId, data) {
    const peer = await this.load(peerId);
    return await this._patch(peerId, data, peer);
  }
  async patchOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._patch(peerId, data, peer);
  }
  async _patch(peerId, data, peer) {
    return await this.save({
      ...peer,
      ...data,
      id: peerId
    });
  }
  async merge(peerId, data) {
    const peer = await this.load(peerId);
    return await this._merge(peerId, data, peer);
  }
  async mergeOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err2) {
      if (err2.code !== codes2.ERR_NOT_FOUND) {
        throw err2;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._merge(peerId, data, peer);
  }
  async _merge(peerId, data, peer) {
    const addresses = /* @__PURE__ */ new Map();
    peer.addresses.forEach((addr) => {
      addresses.set(addr.multiaddr.toString(), addr.isCertified);
    });
    (data.addresses ?? []).forEach((addr) => {
      const addrString = addr.multiaddr.toString();
      const isAlreadyCertified = Boolean(addresses.get(addrString));
      const isCertified = isAlreadyCertified || addr.isCertified;
      addresses.set(addrString, isCertified);
    });
    return await this.save({
      id: peerId,
      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
        return {
          multiaddr: multiaddr(addrStr),
          isCertified
        };
      }),
      protocols: Array.from(/* @__PURE__ */ new Set([
        ...peer.protocols ?? [],
        ...data.protocols ?? []
      ])),
      metadata: new Map([
        ...peer.metadata?.entries() ?? [],
        ...data.metadata?.entries() ?? []
      ]),
      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : void 0),
      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : void 0)
    });
  }
  async *all() {
    for await (const key of this.components.getDatastore().queryKeys({
      prefix: NAMESPACE_COMMON
    })) {
      const base32Str = key.toString().split("/")[2];
      const buf2 = base32.decode(base32Str);
      yield this.load(peerIdFromBytes(buf2));
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/index.js
var import_err_code97 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/pb/tags.js
init_define_process();
var Tags;
(function(Tags2) {
  let _codec;
  Tags2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.tags != null) {
          for (const value of obj.tags) {
            writer.uint32(10);
            Tag.codec().encode(value, writer);
          }
        } else {
          throw new Error('Protocol error: required field "tags" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          tags: []
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.tags.push(Tag.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tags2.encode = (obj) => {
    return encodeMessage(obj, Tags2.codec());
  };
  Tags2.decode = (buf2) => {
    return decodeMessage(buf2, Tags2.codec());
  };
})(Tags || (Tags = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.name != null) {
          writer.uint32(10);
          writer.string(obj.name);
        } else {
          throw new Error('Protocol error: required field "name" was not found in object');
        }
        if (obj.value != null) {
          writer.uint32(16);
          writer.uint32(obj.value);
        }
        if (obj.expiry != null) {
          writer.uint32(24);
          writer.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          name: ""
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.name = reader2.string();
              break;
            case 2:
              obj.value = reader2.uint32();
              break;
            case 3:
              obj.expiry = reader2.uint64();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.name == null) {
          throw new Error('Protocol error: value for required field "name" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf2) => {
    return decodeMessage(buf2, Tag2.codec());
  };
})(Tag || (Tag = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-store-npm-3.1.5-8cf79989af-9.zip/node_modules/@libp2p/peer-store/dist/src/index.js
var log80 = logger("libp2p:peer-store");
var PersistentPeerStore = class extends EventEmitter {
  constructor(init = {}) {
    super();
    this.components = new Components();
    this.store = new PersistentStore();
    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter);
    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);
    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);
    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);
  }
  init(components) {
    this.components = components;
    this.store.init(components);
  }
  async forEach(fn) {
    log80.trace("getPeers await read lock");
    const release = await this.store.lock.readLock();
    log80.trace("getPeers got read lock");
    try {
      for await (const peer of this.store.all()) {
        if (peer.id.equals(this.components.getPeerId())) {
          continue;
        }
        fn(peer);
      }
    } finally {
      log80.trace("getPeers release read lock");
      release();
    }
  }
  async all() {
    const output = [];
    await this.forEach((peer) => {
      output.push(peer);
    });
    return output;
  }
  async delete(peerId) {
    log80.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log80.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log80.trace("delete release write lock");
      release();
    }
  }
  async get(peerId) {
    log80.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log80.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log80.trace("get release read lock");
      release();
    }
  }
  async has(peerId) {
    log80.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log80.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log80.trace("has release read lock");
      release();
    }
  }
  async tagPeer(peerId, tag, options = {}) {
    const providedValue = options.value ?? 0;
    const value = Math.round(providedValue);
    const ttl2 = options.ttl ?? void 0;
    if (value !== providedValue || value < 0 || value > 100) {
      throw (0, import_err_code97.default)(new Error("Tag value must be between 0-100"), "ERR_TAG_VALUE_OUT_OF_BOUNDS");
    }
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    for (const t of tags) {
      if (t.name === tag) {
        throw (0, import_err_code97.default)(new Error("Peer already tagged"), "ERR_DUPLICATE_TAG");
      }
    }
    tags.push({
      name: tag,
      value,
      expiry: ttl2 == null ? void 0 : BigInt(Date.now() + ttl2)
    });
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async unTagPeer(peerId, tag) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    tags = tags.filter((t) => t.name !== tag);
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async getTags(peerId) {
    const buf2 = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf2 != null) {
      tags = Tags.decode(buf2).tags;
    }
    const now = BigInt(Date.now());
    const unexpiredTags = tags.filter((tag) => tag.expiry == null || tag.expiry > now);
    if (unexpiredTags.length !== tags.length) {
      await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags: unexpiredTags }).subarray());
    }
    return unexpiredTags.map((t) => ({
      name: t.name,
      value: t.value ?? 0
    }));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/dht/dht-content-routing.js
init_define_process();
var import_it_drain13 = __toESM(require_it_drain(), 1);
var import_err_code98 = __toESM(require_err_code(), 1);
var DHTContentRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid) {
    await (0, import_it_drain13.default)(this.dht.provide(cid));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value, options) {
    await (0, import_it_drain13.default)(this.dht.put(key, value, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw (0, import_err_code98.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/dialer/auto-dialer.js
init_define_process();
var import_timeout_abort_controller11 = __toESM(require_timeout_abort_controller(), 1);
var import_events21 = __toESM(require_events(), 1);
var log81 = logger("libp2p:dialer:auto-dialer");
var AutoDialer = class {
  constructor(components, init) {
    this.components = components;
    this.enabled = init.enabled;
    this.minConnections = init.minConnections;
    this.dialTimeout = init.dialTimeout;
  }
  handle(evt) {
    const { detail: peer } = evt;
    if (!this.enabled) {
      return;
    }
    const connections = this.components.getConnectionManager().getConnections(peer.id);
    if (connections.length === 0) {
      const minConnections = this.minConnections ?? 0;
      const allConnections = this.components.getConnectionManager().getConnections();
      if (minConnections > allConnections.length) {
        log81("auto-dialing discovered peer %p with timeout %d", peer.id, this.dialTimeout);
        const controller = new import_timeout_abort_controller11.TimeoutController(this.dialTimeout);
        try {
          (0, import_events21.setMaxListeners)?.(Infinity, controller.signal);
        } catch {
        }
        void this.components.getConnectionManager().openConnection(peer.id, {
          signal: controller.signal
        }).catch((err2) => {
          log81.error("could not connect to discovered peer %p with %o", peer.id, err2);
        }).finally(() => {
          controller.clear();
        });
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/config.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-multiaddr-npm-11.0.3-0fa7e4026b-9.zip/node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-multiaddr-npm-11.0.3-0fa7e4026b-9.zip/node_modules/@multiformats/multiaddr/dist/src/resolvers/dns.browser.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/dns-over-http-resolver-npm-2.1.0-6524b3ee97-9.zip/node_modules/dns-over-http-resolver/dist/src/index.js
init_define_process();
var import_debug10 = __toESM(require_debug(), 1);
var import_receptacle = __toESM(require_receptacle(), 1);

// ../../../../../Users/z/.yarn/berry/cache/dns-over-http-resolver-npm-2.1.0-6524b3ee97-9.zip/node_modules/dns-over-http-resolver/dist/src/utils.js
init_define_process();

// ../../.yarn/__virtual__/native-fetch-virtual-c7fbad2e77/4/Users/z/.yarn/berry/cache/native-fetch-npm-4.0.2-ffee0cac69-9.zip/node_modules/native-fetch/esm/src/index.js
init_define_process();
var globalFetch = globalThis.fetch;
var globalHeaders = globalThis.Headers;
var globalRequest = globalThis.Request;
var globalResponse = globalThis.Response;

// ../../../../../Users/z/.yarn/berry/cache/dns-over-http-resolver-npm-2.1.0-6524b3ee97-9.zip/node_modules/dns-over-http-resolver/dist/src/utils.js
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await globalFetch(resource, {
    headers: new globalHeaders({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}

// ../../../../../Users/z/.yarn/berry/cache/dns-over-http-resolver-npm-2.1.0-6524b3ee97-9.zip/node_modules/dns-over-http-resolver/dist/src/index.js
var log82 = Object.assign((0, import_debug10.default)("dns-over-http-resolver"), {
  error: (0, import_debug10.default)("dns-over-http-resolver:error")
});
var Resolver = class {
  constructor(options = {}) {
    this._cache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._TXTcache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  cancel() {
    this._abortControllers.forEach((controller) => controller.abort());
  }
  getServers() {
    return this._servers;
  }
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i = newServers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * i);
      const temp = newServers[i];
      newServers[i] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return await this.resolve4(hostname);
      case "AAAA":
        return await this.resolve6(hostname);
      case "TXT":
        return await this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log82.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log82.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl2 = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl: ttl2 });
        return data;
      } catch (err2) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log82.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default2 = Resolver;

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-multiaddr-npm-11.0.3-0fa7e4026b-9.zip/node_modules/@multiformats/multiaddr/dist/src/resolvers/dns.browser.js
var dns_browser_default = src_default2;

// ../../../../../Users/z/.yarn/berry/cache/@multiformats-multiaddr-npm-11.0.3-0fa7e4026b-9.zip/node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
var { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new dns_browser_default();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]);
  if (peerId != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId));
  }
  return addresses;
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/config.js
var import_err_code99 = __toESM(require_err_code(), 1);
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    maxConnections: 300,
    minConnections: 50,
    autoDial: true,
    autoDialInterval: 1e4,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialsPerPeer: MAX_PER_PEER_DIALS,
    dialTimeout: DIAL_TIMEOUT,
    inboundUpgradeTimeout: INBOUND_UPGRADE_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  connectionGater: {},
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  metrics: {
    enabled: false,
    computeThrottleMaxQueueSize: 1e3,
    computeThrottleTimeout: 2e3,
    movingAverageIntervals: [
      60 * 1e3,
      5 * 60 * 1e3,
      15 * 60 * 1e3
    ],
    maxOldPeersRetention: 50
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 1e4
    }
  },
  nat: {
    enabled: true,
    ttl: 7200,
    keepAlive: true
  },
  relay: {
    enabled: true,
    advertise: {
      bootDelay: ADVERTISE_BOOT_DELAY,
      enabled: false,
      ttl: ADVERTISE_TTL
    },
    hop: {
      enabled: false,
      active: false,
      timeout: 3e4
    },
    autoRelay: {
      enabled: false,
      maxListeners: 2
    }
  },
  identify: {
    protocolPrefix: "ipfs",
    host: {
      agentVersion: AGENT_VERSION
    },
    timeout: 6e4,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1
  },
  ping: {
    protocolPrefix: "ipfs",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  },
  fetch: {
    protocolPrefix: "libp2p",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  }
};
function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw (0, import_err_code99.default)(new Error(messages2.ERR_TRANSPORTS_REQUIRED), codes.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionEncryption == null || resultingOptions.connectionEncryption.length === 0) {
    throw (0, import_err_code99.default)(new Error(messages2.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw (0, import_err_code99.default)(new Error(messages2.ERR_PROTECTOR_REQUIRED), codes.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.identify.host.agentVersion === AGENT_VERSION) {
    if (isNode2 || isElectronMain) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
    } else if (isBrowser3 || isWebWorker2 || isElectronRenderer || isReactNative) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
    }
  }
  return resultingOptions;
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-id-factory-npm-1.0.18-a06654f1aa-9.zip/node_modules/@libp2p/peer-id-factory/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-id-factory-npm-1.0.18-a06654f1aa-9.zip/node_modules/@libp2p/peer-id-factory/dist/src/proto.js
init_define_process();
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.id != null) {
          writer.uint32(10);
          writer.bytes(obj.id);
        } else {
          throw new Error('Protocol error: required field "id" was not found in object');
        }
        if (obj.pubKey != null) {
          writer.uint32(18);
          writer.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          writer.uint32(26);
          writer.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          id: new Uint8Array(0)
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader2.bytes();
              break;
            case 2:
              obj.pubKey = reader2.bytes();
              break;
            case 3:
              obj.privKey = reader2.bytes();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        if (obj.id == null) {
          throw new Error('Protocol error: value for required field "id" was not found in protobuf');
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf2) => {
    return decodeMessage(buf2, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-peer-id-factory-npm-1.0.18-a06654f1aa-9.zip/node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = async () => {
  const key = await generateKeyPair("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
var createRSAPeerId = async (opts) => {
  const key = await generateKeyPair("RSA", opts?.bits ?? 2048);
  const id = await createFromPrivKey(key);
  if (id.type === "RSA") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/libp2p.js
init_concat();
var import_err_code104 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/dht/dummy-dht.js
init_define_process();
var import_err_code100 = __toESM(require_err_code(), 1);
var DummyDHT = class extends EventEmitter {
  get [symbol2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dummy-dht";
  }
  get wan() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  get lan() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  get() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  findProviders() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  findPeer() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  getClosestPeers() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  provide() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  put() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async getMode() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async setMode() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async refreshRoutingTable() {
    throw (0, import_err_code100.default)(new Error(messages2.DHT_DISABLED), codes.DHT_DISABLED);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/pubsub/dummy-pubsub.js
init_define_process();
var import_err_code101 = __toESM(require_err_code(), 1);
var DummyPubSub = class extends EventEmitter {
  isStarted() {
    return false;
  }
  start() {
  }
  stop() {
  }
  get globalSignaturePolicy() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  get multicodecs() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getPeers() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getTopics() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  subscribe() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  unsubscribe() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getSubscribers() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  async publish() {
    throw (0, import_err_code101.default)(new Error(messages2.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
init_define_process();
var import_it_all9 = __toESM(require_it_all(), 1);
var import_it_filter12 = __toESM(require_it_filter(), 1);
var import_err_code103 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller12 = __toESM(require_timeout_abort_controller(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-interfaces-npm-3.0.3-dd39d566f6-9.zip/node_modules/@libp2p/interfaces/dist/src/errors.js
init_define_process();
var AbortError3 = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.code = AbortError3.code;
    this.type = AbortError3.type;
  }
  static get code() {
    return "ABORT_ERR";
  }
  static get type() {
    return "aborted";
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var import_any_signal7 = __toESM(require_any_signal(), 1);
var import_events25 = __toESM(require_events(), 1);

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/dialer/dial-request.js
init_define_process();
var import_err_code102 = __toESM(require_err_code(), 1);
var import_any_signal6 = __toESM(require_any_signal(), 1);
var import_p_fifo = __toESM(require_p_fifo(), 1);
var import_events24 = __toESM(require_events(), 1);
var log83 = logger("libp2p:dialer:dial-request");
var DialRequest = class {
  constructor(options) {
    const { addrs, dialAction, dialer } = options;
    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  async run(options = {}) {
    const tokens = this.dialer.getTokens(this.addrs.length);
    if (tokens.length < 1) {
      throw (0, import_err_code102.default)(new Error("No dial tokens available"), codes.ERR_NO_DIAL_TOKENS);
    }
    const tokenHolder = new import_p_fifo.default();
    for (const token of tokens) {
      void tokenHolder.push(token).catch((err2) => {
        log83.error(err2);
      });
    }
    const dialAbortControllers = this.addrs.map(() => {
      const controller = new AbortController();
      try {
        (0, import_events24.setMaxListeners)?.(Infinity, controller.signal);
      } catch {
      }
      return controller;
    });
    if (options.signal != null) {
      try {
        (0, import_events24.setMaxListeners)?.(Infinity, options.signal);
      } catch {
      }
    }
    let completedDials = 0;
    let done = false;
    try {
      return await Promise.any(this.addrs.map(async (addr, i) => {
        const token = await tokenHolder.shift();
        if (done) {
          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          throw (0, import_err_code102.default)(new Error("dialAction already succeeded"), codes.ERR_ALREADY_SUCCEEDED);
        }
        const controller = dialAbortControllers[i];
        if (controller == null) {
          throw (0, import_err_code102.default)(new Error("dialAction did not come with an AbortController"), codes.ERR_INVALID_PARAMETERS);
        }
        let conn;
        try {
          const signal = controller.signal;
          conn = await this.dialAction(addr, { ...options, signal: options.signal != null ? (0, import_any_signal6.anySignal)([signal, options.signal]) : signal });
          dialAbortControllers[i] = void 0;
        } finally {
          completedDials++;
          if (this.addrs.length - completedDials >= tokens.length) {
            void tokenHolder.push(token).catch((err2) => {
              log83.error(err2);
            });
          } else {
            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          }
        }
        if (conn == null) {
          throw (0, import_err_code102.default)(new Error("dialAction led to empty object"), codes.ERR_TRANSPORT_DIAL_FAILED);
        } else {
          done = true;
        }
        return conn;
      }));
    } finally {
      dialAbortControllers.forEach((c) => {
        if (c !== void 0) {
          c.abort();
        }
      });
      tokens.forEach((token) => this.dialer.releaseToken(token));
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var import_it_sort4 = __toESM(require_it_sort(), 1);
var import_it_map14 = __toESM(require_it_map(), 1);
var log84 = logger("libp2p:dialer");
var METRICS_COMPONENT2 = "dialler";
var METRICS_PENDING_DIALS = "pending-dials";
var METRICS_PENDING_DIAL_TARGETS = "pending-dial-targets";
var DefaultDialer = class {
  constructor(components, init = {}) {
    this.started = false;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;
    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;
    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;
    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);
    this.components = components;
    this.pendingDials = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIALS,
      metrics: init.metrics
    });
    this.pendingDialTargets = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIAL_TARGETS,
      metrics: components.getMetrics()
    });
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
    for (const dial of this.pendingDials.values()) {
      try {
        dial.controller.abort();
      } catch (err2) {
        log84.error(err2);
      }
    }
    this.pendingDials.clear();
    for (const pendingTarget of this.pendingDialTargets.values()) {
      pendingTarget.reject(new AbortError3("Dialer was destroyed"));
    }
    this.pendingDialTargets.clear();
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (this.components.getPeerId().equals(id)) {
      throw (0, import_err_code103.default)(new Error("Tried to dial self"), codes.ERR_DIALED_SELF);
    }
    log84("check multiaddrs %p", id);
    if (multiaddrs != null && multiaddrs.length > 0) {
      log84("storing multiaddrs %p", id, multiaddrs);
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    if (await this.components.getConnectionGater().denyDialPeer(id)) {
      throw (0, import_err_code103.default)(new Error("The dial request is blocked by gater.allowDialPeer"), codes.ERR_PEER_DIAL_INTERCEPTED);
    }
    log84("creating dial target for %p", id);
    const dialTarget = await this._createCancellableDialTarget(id, options);
    if (dialTarget.addrs.length === 0) {
      throw (0, import_err_code103.default)(new Error("The dial request has no valid addresses"), codes.ERR_NO_VALID_ADDRESSES);
    }
    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);
    try {
      const connection = await pendingDial.promise;
      log84("dial succeeded to %s", dialTarget.id);
      return connection;
    } catch (err2) {
      log84("dial failed to %s", dialTarget.id, err2);
      if (pendingDial.controller.signal.aborted) {
        err2.code = codes.ERR_TIMEOUT;
      }
      log84.error(err2);
      throw err2;
    } finally {
      pendingDial.destroy();
    }
  }
  async _createCancellableDialTarget(peer, options) {
    const id = `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    const cancellablePromise = new Promise((resolve7, reject) => {
      this.pendingDialTargets.set(id, { resolve: resolve7, reject });
    });
    try {
      const dialTarget = await Promise.race([
        this._createDialTarget(peer, options),
        cancellablePromise
      ]);
      return dialTarget;
    } finally {
      this.pendingDialTargets.delete(id);
    }
  }
  async _createDialTarget(peer, options) {
    const _resolve = this._resolve.bind(this);
    const addrs = await pipe(
      await this.components.getPeerStore().addressBook.get(peer),
      (source) => (0, import_it_filter12.default)(source, async (address) => {
        return !await this.components.getConnectionGater().denyDialMultiaddr(peer, address.multiaddr);
      }),
      (source) => (0, import_it_sort4.default)(source, this.addressSorter),
      async function* resolve7(source) {
        for await (const a of source) {
          yield* await _resolve(a.multiaddr, options);
        }
      },
      (source) => (0, import_it_filter12.default)(source, (ma) => Boolean(this.components.getTransportManager().transportForMultiaddr(ma))),
      (source) => (0, import_it_map14.default)(source, (ma) => {
        if (peer.toString() === ma.getPeerId()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${peer.toString()}`);
      }),
      async (source) => await (0, import_it_all9.default)(source)
    );
    if (addrs.length > this.maxAddrsToDial) {
      await this.components.getPeerStore().delete(peer);
      throw (0, import_err_code103.default)(new Error("dial with more addresses than allowed"), codes.ERR_TOO_MANY_ADDRESSES);
    }
    return {
      id: peer.toString(),
      addrs
    };
  }
  _createPendingDial(dialTarget, options = {}) {
    const dialAction = async (addr, options2 = {}) => {
      if (options2.signal?.aborted === true) {
        throw (0, import_err_code103.default)(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
      }
      return await this.components.getTransportManager().dial(addr, options2).catch((err2) => {
        log84.error("dial to %s failed", addr, err2);
        throw err2;
      });
    };
    const dialRequest = new DialRequest({
      addrs: dialTarget.addrs,
      dialAction,
      dialer: this
    });
    const timeoutController = new import_timeout_abort_controller12.TimeoutController(this.timeout);
    const signals = [timeoutController.signal];
    options.signal != null && signals.push(options.signal);
    const signal = (0, import_any_signal7.anySignal)(signals);
    try {
      (0, import_events25.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const pendingDial = {
      dialRequest,
      controller: timeoutController,
      promise: dialRequest.run({ ...options, signal }),
      destroy: () => {
        timeoutController.clear();
        this.pendingDials.delete(dialTarget.id);
      }
    };
    this.pendingDials.set(dialTarget.id, pendingDial);
    return pendingDial;
  }
  getTokens(num) {
    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
    const tokens = this.tokens.splice(0, total);
    log84("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
    return tokens;
  }
  releaseToken(token) {
    if (this.tokens.includes(token)) {
      return;
    }
    log84("token %d released", token);
    this.tokens.push(token);
  }
  async _resolve(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await this._resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return await this._resolve(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    return addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
  }
  async _resolveRecord(ma, options) {
    try {
      ma = multiaddr(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err2) {
      log84.error(`multiaddr ${ma.toString()} could not be resolved`, err2);
      return [];
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/libp2p.js
var log85 = logger("libp2p");
var Libp2pNode = class extends EventEmitter {
  constructor(init) {
    super();
    this.initializables = [];
    this.started = false;
    this.peerId = init.peerId;
    this.components = new Components({
      peerId: init.peerId,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: {
        denyDialPeer: async () => await Promise.resolve(false),
        denyDialMultiaddr: async () => await Promise.resolve(false),
        denyInboundConnection: async () => await Promise.resolve(false),
        denyOutboundConnection: async () => await Promise.resolve(false),
        denyInboundEncryptedConnection: async () => await Promise.resolve(false),
        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),
        denyInboundUpgradedConnection: async () => await Promise.resolve(false),
        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),
        filterMultiaddrForPeer: async () => await Promise.resolve(true),
        ...init.connectionGater
      }
    });
    this.components.setPeerStore(new PersistentPeerStore({
      addressFilter: this.components.getConnectionGater().filterMultiaddrForPeer,
      ...init.peerStore
    }));
    this.services = [
      this.components
    ];
    if (init.metrics.enabled) {
      this.metrics = this.components.setMetrics(new DefaultMetrics(init.metrics));
    }
    this.peerStore = this.components.getPeerStore();
    this.peerStore.addEventListener("peer", (evt) => {
      const { detail: peerData } = evt;
      this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peerData }));
    });
    if (init.connectionProtector != null) {
      this.components.setConnectionProtector(init.connectionProtector);
    }
    this.components.setUpgrader(new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((component) => this.configureComponent(component)),
      muxers: (init.streamMuxers ?? []).map((component) => this.configureComponent(component)),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    }));
    this.components.setDialer(new DefaultDialer(this.components, init.connectionManager));
    this.connectionManager = this.components.setConnectionManager(new DefaultConnectionManager(init.connectionManager));
    this.registrar = this.components.setRegistrar(new DefaultRegistrar(this.components));
    this.components.setTransportManager(new DefaultTransportManager(this.components, init.transportManager));
    this.components.setAddressManager(new DefaultAddressManager(this.components, init.addresses));
    this.configureComponent(new PeerRecordUpdater(this.components));
    this.configureComponent(new AutoDialler(this.components, {
      enabled: init.connectionManager.autoDial,
      minConnections: init.connectionManager.minConnections,
      autoDialInterval: init.connectionManager.autoDialInterval
    }));
    const keychainOpts = KeyChain.generateOptions();
    this.keychain = this.configureComponent(new KeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    this.services.push(new NatManager(this.components, init.nat));
    init.transports.forEach((transport) => {
      this.components.getTransportManager().add(this.configureComponent(transport));
    });
    if (init.streamMuxers != null && init.streamMuxers.length > 0) {
      this.identifyService = new IdentifyService(this.components, {
        ...init.identify
      });
      this.configureComponent(this.identifyService);
    }
    if (init.dht != null) {
      this.dht = this.components.setDHT(init.dht);
    } else {
      this.dht = new DummyDHT();
    }
    if (init.pubsub != null) {
      this.pubsub = this.components.setPubSub(init.pubsub);
    } else {
      this.pubsub = new DummyPubSub();
    }
    const peerRouters = (init.peerRouters ?? []).map((component) => this.configureComponent(component));
    if (init.dht != null) {
      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)));
      this.dht.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
    this.peerRouting = this.components.setPeerRouting(this.configureComponent(new DefaultPeerRouting(this.components, {
      ...init.peerRouting,
      routers: peerRouters
    })));
    const contentRouters = (init.contentRouters ?? []).map((component) => this.configureComponent(component));
    if (init.dht != null) {
      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));
    }
    this.contentRouting = this.components.setContentRouting(this.configureComponent(new CompoundContentRouting(this.components, {
      routers: contentRouters
    })));
    if (init.relay.enabled) {
      this.components.getTransportManager().add(this.configureComponent(new Circuit2(init.relay)));
      this.configureComponent(new Relay(this.components, {
        addressSorter: init.connectionManager.addressSorter,
        ...init.relay
      }));
    }
    this.fetchService = this.configureComponent(new FetchService(this.components, {
      ...init.fetch
    }));
    this.pingService = this.configureComponent(new PingService(this.components, {
      ...init.ping
    }));
    const autoDialer = this.configureComponent(new AutoDialer(this.components, {
      enabled: init.connectionManager.autoDial !== false,
      minConnections: init.connectionManager.minConnections,
      dialTimeout: init.connectionManager.dialTimeout ?? 3e4
    }));
    this.addEventListener("peer:discovery", (evt) => {
      if (!this.isStarted()) {
        return;
      }
      autoDialer.handle(evt);
    });
    for (const service of init.peerDiscovery ?? []) {
      this.configureComponent(service);
      service.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
  }
  configureComponent(component) {
    if (isStartable(component)) {
      this.services.push(component);
    }
    if (isInitializable(component)) {
      this.initializables.push(component);
    }
    return component;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    log85("libp2p is starting");
    try {
      this.initializables.forEach((obj) => {
        obj.init(this.components);
      });
      await Promise.all(this.services.map(async (service) => {
        if (service.beforeStart != null) {
          await service.beforeStart();
        }
      }));
      await Promise.all(this.services.map((service) => service.start()));
      await Promise.all(this.services.map(async (service) => {
        if (service.afterStart != null) {
          await service.afterStart();
        }
      }));
      log85("libp2p has started");
    } catch (err2) {
      log85.error("An error occurred starting libp2p", err2);
      await this.stop();
      throw err2;
    }
  }
  async stop() {
    if (!this.started) {
      return;
    }
    log85("libp2p is stopping");
    this.started = false;
    await Promise.all(this.services.map(async (service) => {
      if (service.beforeStop != null) {
        await service.beforeStop();
      }
    }));
    await Promise.all(this.services.map((service) => service.stop()));
    await Promise.all(this.services.map(async (service) => {
      if (service.afterStop != null) {
        await service.afterStop();
      }
    }));
    log85("libp2p has stopped");
  }
  isStarted() {
    return this.started;
  }
  getConnections(peerId) {
    return this.components.getConnectionManager().getConnections(peerId);
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.getConnectionManager().getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    return await this.components.getConnectionManager().openConnection(id, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw (0, import_err_code104.default)(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw (0, import_err_code104.default)(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return await connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.getAddressManager().getAddresses();
  }
  async hangUp(peer) {
    const { id } = getPeer(peer);
    await this.components.getConnectionManager().closeConnections(id);
  }
  async getPublicKey(peer, options = {}) {
    log85("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.pubKey != null) {
      return peerInfo.pubKey;
    }
    if (this.dht == null) {
      throw (0, import_err_code104.default)(new Error("Public key was not in the peer store and the DHT is not enabled"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.multihash.digest
    ]);
    for await (const event of this.dht.get(peerKey, options)) {
      if (event.name === "VALUE") {
        const key = unmarshalPublicKey(event.value);
        await this.peerStore.keyBook.set(peer, event.value);
        return key.bytes;
      }
    }
    throw (0, import_err_code104.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), codes.ERR_INVALID_RECORD);
  }
  async fetch(peer, key, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs != null) {
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    return await this.fetchService.fetch(id, key, options);
  }
  async ping(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs.length > 0) {
      await this.components.getPeerStore().addressBook.add(id, multiaddrs);
    }
    return await this.pingService.ping(id, options);
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.getRegistrar().handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.getRegistrar().unhandle(protocol);
    }));
  }
  onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log85.error(new Error(codes.ERR_DISCOVERED_SELF));
      return;
    }
    if (peer.multiaddrs.length > 0) {
      void this.components.getPeerStore().addressBook.add(peer.id, peer.multiaddrs).catch((err2) => log85.error(err2));
    }
    if (peer.protocols.length > 0) {
      void this.components.getPeerStore().protoBook.set(peer.id, peer.protocols).catch((err2) => log85.error(err2));
    }
    this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peer }));
  }
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}

// ../../../../../Users/z/.yarn/berry/cache/libp2p-npm-0.39.4-5ef232a8dd-9.zip/node_modules/libp2p/dist/src/index.js
async function createLibp2p(options) {
  return await createLibp2pNode(options);
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
init_define_process();
var import_k_bucket = __toESM(require_k_bucket(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/utils.js
init_define_process();
init_concat();
var import_private_ip3 = __toESM(require_private_ip(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/constants.js
init_define_process();
var second = 1e3;
var minute3 = 60 * second;
var hour2 = 60 * minute3;
var MAX_RECORD_AGE = 36 * hour2;
var LAN_PREFIX = "/lan";
var PROTOCOL_PREFIX = "/ipfs";
var PROTOCOL_DHT = "/kad/1.0.0";
var RECORD_KEY_PREFIX = "/dht/record";
var PROVIDER_KEY_PREFIX = "/dht/provider";
var PROVIDERS_LRU_CACHE_SIZE = 256;
var PROVIDERS_VALIDITY = 24 * hour2;
var PROVIDERS_CLEANUP_INTERVAL = hour2;
var READ_MESSAGE_TIMEOUT = 10 * second;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = Number(5 * minute3);
var QUERY_SELF_TIMEOUT = Number(30 * second);
var TABLE_REFRESH_INTERVAL = Number(5 * minute3);
var TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second);
var DEFAULT_QUERY_TIMEOUT = Number(30 * second);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString("/pk/");
function removePrivateAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return !(0, import_private_ip3.default)(addr);
    })
  };
}
function removePublicAddresses(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      return (0, import_private_ip3.default)(addr);
    })
  };
}
async function convertBuffer(buf2) {
  const multihash = await sha256.digest(buf2);
  return multihash.digest;
}
async function convertPeerId(peerId) {
  return await convertBuffer(peerId.toBytes());
}
function bufferToRecordKey(buf2) {
  return new Key(`${RECORD_KEY_PREFIX}/${toString(buf2, "base32")}`, false);
}
function keyForPublicKey(peer) {
  return concat([
    PK_PREFIX,
    peer.toBytes()
  ]);
}
function isPublicKeyKey(key) {
  return toString(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  return peerIdFromBytes(key.subarray(4));
}
function createPutRecord(key, value) {
  const timeReceived = new Date();
  const rec = new Libp2pRecord(key, value, timeReceived);
  return rec.serialize();
}
function debounce(callback, wait = 100) {
  let timeout;
  return () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => callback(), wait);
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var import_timeout_abort_controller13 = __toESM(require_timeout_abort_controller(), 1);
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var KBUCKET_SIZE = 20;
var PING_TIMEOUT = 1e4;
var PING_CONCURRENCY = 10;
var METRIC_ROUTING_TABLE_SIZE = "routing-table-size";
var METRIC_PING_QUEUE_SIZE = "ping-queue-size";
var METRIC_PING_RUNNING = "ping-running";
var RoutingTable = class {
  constructor(init) {
    this.components = new Components();
    const { kBucketSize, pingTimeout, lan, pingConcurrency, protocol, tagName, tagValue } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
    this.kBucketSize = kBucketSize ?? KBUCKET_SIZE;
    this.pingTimeout = pingTimeout ?? PING_TIMEOUT;
    this.pingConcurrency = pingConcurrency ?? PING_CONCURRENCY;
    this.lan = lan;
    this.running = false;
    this.protocol = protocol;
    this.tagName = tagName ?? KAD_CLOSE_TAG_NAME;
    this.tagValue = tagValue ?? KAD_CLOSE_TAG_VALUE;
    const updatePingQueueSizeMetric = () => {
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_QUEUE_SIZE,
        value: this.pingQueue.size
      });
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_PING_RUNNING,
        value: this.pingQueue.pending
      });
    };
    this.pingQueue = new PQueue({ concurrency: this.pingConcurrency });
    this.pingQueue.addListener("add", updatePingQueueSizeMetric);
    this.pingQueue.addListener("next", updatePingQueueSizeMetric);
    this._onPing = this._onPing.bind(this);
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
    const kBuck = new import_k_bucket.default({
      localNodeId: await convertPeerId(this.components.getPeerId()),
      numberOfNodesPerKBucket: this.kBucketSize,
      numberOfNodesToPing: 1
    });
    this.kb = kBuck;
    kBuck.on("ping", this._onPing);
    this._tagPeers(kBuck);
  }
  async stop() {
    this.running = false;
    this.pingQueue.clear();
    this.kb = void 0;
  }
  _tagPeers(kBuck) {
    let kClosest = new PeerSet();
    const updatePeerTags = debounce(() => {
      const newClosest = new PeerSet(kBuck.closest(kBuck.localNodeId, KBUCKET_SIZE).map((contact) => contact.peer));
      const addedPeers = newClosest.difference(kClosest);
      const removedPeers = kClosest.difference(newClosest);
      Promise.resolve().then(async () => {
        for (const peer of addedPeers) {
          await this.components.getPeerStore().tagPeer(peer, this.tagName, {
            value: this.tagValue
          });
        }
        for (const peer of removedPeers) {
          await this.components.getPeerStore().unTagPeer(peer, this.tagName);
        }
      }).catch((err2) => {
        this.log.error("Could not update peer tags", err2);
      });
      kClosest = newClosest;
    });
    kBuck.on("added", () => {
      updatePeerTags();
    });
    kBuck.on("removed", () => {
      updatePeerTags();
    });
  }
  _onPing(oldContacts, newContact) {
    this.pingQueue.add(async () => {
      if (!this.running) {
        return;
      }
      let responded = 0;
      try {
        await Promise.all(oldContacts.map(async (oldContact) => {
          let timeoutController;
          try {
            timeoutController = new import_timeout_abort_controller13.TimeoutController(this.pingTimeout);
            const options = {
              signal: timeoutController.signal
            };
            this.log("pinging old contact %p", oldContact.peer);
            const connection = await this.components.getConnectionManager().openConnection(oldContact.peer, options);
            const stream = await connection.newStream(this.protocol, options);
            stream.close();
            responded++;
          } catch (err2) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peer, err2);
              this.log("evicting old contact after ping failed %p", oldContact);
              this.kb.remove(oldContact.id);
            }
          } finally {
            if (timeoutController != null) {
              timeoutController.clear();
            }
            this.components.getMetrics()?.updateComponentMetric({
              system: "libp2p",
              component: `kad-dht-${this.lan ? "lan" : "wan"}`,
              metric: METRIC_ROUTING_TABLE_SIZE,
              value: this.size
            });
          }
        }));
        if (this.running && responded < oldContacts.length && this.kb != null) {
          this.log("adding new contact %p", newContact.peer);
          this.kb.add(newContact);
        }
      } catch (err2) {
        this.log.error("could not process k-bucket ping event", err2);
      }
    }).catch((err2) => {
      this.log.error("could not process k-bucket ping event", err2);
    });
  }
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  async find(peer) {
    const key = await convertPeerId(peer);
    const closest = this.closestPeer(key);
    if (closest != null && peer.equals(closest)) {
      return closest;
    }
    return void 0;
  }
  closestPeer(key) {
    const res = this.closestPeers(key, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  closestPeers(key, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    const closest = this.kb.closest(key, count);
    return closest.map((p) => p.peer);
  }
  async add(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.add({ id, peer });
    this.log("added %p with kad id %b", peer, id);
    this.components.getMetrics()?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const id = await convertPeerId(peer);
    this.kb.remove(id);
    this.components.getMetrics()?.updateComponentMetric({
      system: "libp2p",
      component: `kad-dht-${this.lan ? "lan" : "wan"}`,
      metric: METRIC_ROUTING_TABLE_SIZE,
      value: this.size
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
init_define_process();
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var import_it_length3 = __toESM(require_it_length(), 1);
var import_timeout_abort_controller14 = __toESM(require_timeout_abort_controller(), 1);
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  constructor(init) {
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  init(components) {
  }
  async start() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err2) {
              this.log.error(err2);
            }
          }
        }
      } catch (err2) {
        this.log.error(err2);
      }
    })).catch((err2) => {
      this.log.error(err2);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const controller = new import_timeout_abort_controller14.TimeoutController(this.refreshQueryTimeout);
    try {
      const peers = await (0, import_it_length3.default)(this.peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
    } finally {
      controller.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i = 0; i <= maxCommonPrefix; i++) {
      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    const randomData = randomBytes(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
    return peerIdFromBytes(key);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length5 of this._prefixLengths()) {
      if (length5 > prefixLength) {
        prefixLength = length5;
      }
    }
    return prefixLength;
  }
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length5 of this._prefixLengths()) {
      if (length5 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  *_prefixLengths() {
    if (this.routingTable.kb == null) {
      return;
    }
    for (const { id } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localNodeId, id);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/network.js
init_define_process();
var import_err_code105 = __toESM(require_err_code(), 1);
var import_it_drain14 = __toESM(require_it_drain(), 1);
var import_it_first9 = __toESM(require_it_first(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/message/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/message/dht.js
init_define_process();
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.key != null) {
          writer.uint32(10);
          writer.bytes(obj.key);
        }
        if (obj.value != null) {
          writer.uint32(18);
          writer.bytes(obj.value);
        }
        if (obj.author != null) {
          writer.uint32(26);
          writer.bytes(obj.author);
        }
        if (obj.signature != null) {
          writer.uint32(34);
          writer.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          writer.uint32(42);
          writer.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {};
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader2.bytes();
              break;
            case 2:
              obj.value = reader2.bytes();
              break;
            case 3:
              obj.author = reader2.bytes();
              break;
            case 4:
              obj.signature = reader2.bytes();
              break;
            case 5:
              obj.timeReceived = reader2.string();
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2) => {
    return decodeMessage(buf2, Record3.codec());
  };
})(Record2 || (Record2 = {}));
var Message;
(function(Message4) {
  let MessageType;
  (function(MessageType2) {
    MessageType2["PUT_VALUE"] = "PUT_VALUE";
    MessageType2["GET_VALUE"] = "GET_VALUE";
    MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType2["FIND_NODE"] = "FIND_NODE";
    MessageType2["PING"] = "PING";
  })(MessageType = Message4.MessageType || (Message4.MessageType = {}));
  let __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType2) {
    MessageType2.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(MessageType = Message4.MessageType || (Message4.MessageType = {}));
  let ConnectionType;
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(ConnectionType = Message4.ConnectionType || (Message4.ConnectionType = {}));
  let __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(ConnectionType = Message4.ConnectionType || (Message4.ConnectionType = {}));
  let Peer3;
  (function(Peer4) {
    let _codec2;
    Peer4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, writer, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer.fork();
          }
          if (obj.id != null) {
            writer.uint32(10);
            writer.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              writer.uint32(18);
              writer.bytes(value);
            }
          } else {
            throw new Error('Protocol error: required field "addrs" was not found in object');
          }
          if (obj.connection != null) {
            writer.uint32(24);
            Message4.ConnectionType.codec().encode(obj.connection, writer);
          }
          if (opts.lengthDelimited !== false) {
            writer.ldelim();
          }
        }, (reader2, length5) => {
          const obj = {
            addrs: []
          };
          const end = length5 == null ? reader2.len : reader2.pos + length5;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader2.bytes();
                break;
              case 2:
                obj.addrs.push(reader2.bytes());
                break;
              case 3:
                obj.connection = Message4.ConnectionType.codec().decode(reader2);
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer4.encode = (obj) => {
      return encodeMessage(obj, Peer4.codec());
    };
    Peer4.decode = (buf2) => {
      return decodeMessage(buf2, Peer4.codec());
    };
  })(Peer3 = Message4.Peer || (Message4.Peer = {}));
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, writer, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          writer.fork();
        }
        if (obj.type != null) {
          writer.uint32(8);
          Message4.MessageType.codec().encode(obj.type, writer);
        }
        if (obj.clusterLevelRaw != null) {
          writer.uint32(80);
          writer.int32(obj.clusterLevelRaw);
        }
        if (obj.key != null) {
          writer.uint32(18);
          writer.bytes(obj.key);
        }
        if (obj.record != null) {
          writer.uint32(26);
          writer.bytes(obj.record);
        }
        if (obj.closerPeers != null) {
          for (const value of obj.closerPeers) {
            writer.uint32(66);
            Message4.Peer.codec().encode(value, writer);
          }
        } else {
          throw new Error('Protocol error: required field "closerPeers" was not found in object');
        }
        if (obj.providerPeers != null) {
          for (const value of obj.providerPeers) {
            writer.uint32(74);
            Message4.Peer.codec().encode(value, writer);
          }
        } else {
          throw new Error('Protocol error: required field "providerPeers" was not found in object');
        }
        if (opts.lengthDelimited !== false) {
          writer.ldelim();
        }
      }, (reader2, length5) => {
        const obj = {
          closerPeers: [],
          providerPeers: []
        };
        const end = length5 == null ? reader2.len : reader2.pos + length5;
        while (reader2.pos < end) {
          const tag = reader2.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = Message4.MessageType.codec().decode(reader2);
              break;
            case 10:
              obj.clusterLevelRaw = reader2.int32();
              break;
            case 2:
              obj.key = reader2.bytes();
              break;
            case 3:
              obj.record = reader2.bytes();
              break;
            case 8:
              obj.closerPeers.push(Message4.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            case 9:
              obj.providerPeers.push(Message4.Peer.codec().decode(reader2, reader2.uint32()));
              break;
            default:
              reader2.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage(obj, Message4.codec());
  };
  Message4.decode = (buf2) => {
    return decodeMessage(buf2, Message4.codec());
  };
})(Message || (Message = {}));

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/message/index.js
var MESSAGE_TYPE = Message.MessageType;
var CONNECTION_TYPE = Message.ConnectionType;
var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
var Message2 = class {
  constructor(type, key, level) {
    if (!(key instanceof Uint8Array)) {
      throw new Error("Key must be a Uint8Array");
    }
    this.type = type;
    this.key = key;
    this.clusterLevelRaw = level;
    this.closerPeers = [];
    this.providerPeers = [];
    this.record = void 0;
  }
  get clusterLevel() {
    const level = this.clusterLevelRaw - 1;
    if (level < 0) {
      return 0;
    }
    return level;
  }
  set clusterLevel(level) {
    this.clusterLevelRaw = level;
  }
  serialize() {
    return Message.encode({
      key: this.key,
      type: this.type,
      clusterLevelRaw: this.clusterLevelRaw,
      closerPeers: this.closerPeers.map(toPbPeer),
      providerPeers: this.providerPeers.map(toPbPeer),
      record: this.record == null ? void 0 : this.record.serialize().subarray()
    });
  }
  static deserialize(raw) {
    const dec = Message.decode(raw);
    const msg = new Message2(dec.type ?? Message.MessageType.PUT_VALUE, dec.key ?? Uint8Array.from([]), dec.clusterLevelRaw ?? 0);
    msg.closerPeers = dec.closerPeers.map(fromPbPeer);
    msg.providerPeers = dec.providerPeers.map(fromPbPeer);
    if (dec.record?.length != null) {
      msg.record = Libp2pRecord.deserialize(dec.record);
    }
    return msg;
  }
};
function toPbPeer(peer) {
  const output = {
    id: peer.id.toBytes(),
    addrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection: CONNECTION_TYPE.CONNECTED
  };
  return output;
}
function fromPbPeer(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  return {
    id: peerIdFromBytes(peer.id),
    multiaddrs: (peer.addrs ?? []).map((a) => multiaddr(a)),
    protocols: []
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/query/events.js
init_define_process();
function sendingQueryEvent(fields) {
  return {
    ...fields,
    name: "SENDING_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: MESSAGE_TYPE_LOOKUP.indexOf(fields.type.toString())
  };
}
function peerResponseEvent(fields) {
  return {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer != null ? fields.closer : [],
    providers: fields.providers != null ? fields.providers : []
  };
}
function finalPeerEvent(fields) {
  return {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
}
function queryErrorEvent(fields) {
  return {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
}
function providerEvent(fields) {
  return {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
}
function valueEvent(fields) {
  return {
    ...fields,
    name: "VALUE",
    type: 5
  };
}
function dialingPeerEvent(fields) {
  return {
    ...fields,
    name: "DIALING_PEER",
    type: 7
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/network.js
var Network = class extends EventEmitter {
  constructor(init) {
    super();
    this.components = new Components();
    const { protocol, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
    this.running = false;
    this.protocol = protocol;
  }
  init(components) {
    this.components = components;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  async stop() {
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  async *sendRequest(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    let stream;
    try {
      const connection = await this.components.getConnectionManager().openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      const response = await this._writeReadMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closerPeers,
        providers: response.providerPeers,
        record: response.record
      });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  async *sendMessage(to, msg, options = {}) {
    if (!this.running) {
      return;
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialingPeerEvent({ peer: to });
    yield sendingQueryEvent({ to, type: msg.type });
    let stream;
    try {
      const connection = await this.components.getConnectionManager().openConnection(to, options);
      const stream2 = await connection.newStream(this.protocol, options);
      await this._writeMessage(stream2, msg.serialize(), options);
      yield peerResponseEvent({ from: to, messageType: msg.type });
    } catch (err2) {
      yield queryErrorEvent({ from: to, error: err2 });
    } finally {
      if (stream != null) {
        stream.close();
      }
    }
  }
  async _writeMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    await pipe([msg], encode(), stream, import_it_drain14.default);
  }
  async _writeReadMessage(stream, msg, options) {
    if (options.signal != null) {
      stream = abortableDuplex(stream, options.signal);
    }
    const res = await pipe([msg], encode(), stream, decode2(), async (source) => {
      const buf2 = await (0, import_it_first9.default)(source);
      if (buf2 != null) {
        return buf2;
      }
      throw (0, import_err_code105.default)(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
    });
    const message2 = Message2.deserialize(res);
    message2.closerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    message2.providerPeers.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    return message2;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
init_define_process();
var import_err_code108 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/validators.js
init_define_process();
var import_err_code106 = __toESM(require_err_code(), 1);
function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    const errMsg = "Invalid record keytype";
    throw (0, import_err_code106.default)(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
  }
  return validator(key, record.value);
}
var validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw (0, import_err_code106.default)(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
  }
  if (key.byteLength < 5) {
    throw (0, import_err_code106.default)(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
  }
  const prefix = toString(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw (0, import_err_code106.default)(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
  }
  const keyhash = key.slice(4);
  const publicKeyHash = await sha256.digest(publicKey);
  if (!equals(keyhash, publicKeyHash.bytes)) {
    throw (0, import_err_code106.default)(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-record-npm-2.0.2-2f2760953a-9.zip/node_modules/@libp2p/record/dist/src/selectors.js
init_define_process();
var import_err_code107 = __toESM(require_err_code(), 1);
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    const errMsg = "No records given";
    throw (0, import_err_code107.default)(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
  }
  const kStr = toString(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    const errMsg = "Record key does not have a selector function";
    throw (0, import_err_code107.default)(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    const errMsg = `Unrecognized key prefix: ${parts[1]}`;
    throw (0, import_err_code107.default)(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
var selectors = {
  pk: publickKey
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var import_it_parallel3 = __toESM(require_it_parallel(), 1);
var import_it_map15 = __toESM(require_it_map(), 1);
var ContentFetching = class {
  constructor(init) {
    this.components = new Components();
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, routingTable, network, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.network = network;
  }
  init(components) {
    this.components = components;
  }
  async putLocal(key, rec) {
    const dsKey = bufferToRecordKey(key);
    await this.components.getDatastore().put(dsKey, rec);
  }
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.getDatastore().get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  async *sendCorrectionRecord(key, vals, best, options = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = await createPutRecord(key, best);
    for (const { value, from: from2 } of vals) {
      if (equals(value, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.getPeerId().equals(from2)) {
        try {
          const dsKey = bufferToRecordKey(key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.getDatastore().put(dsKey, fixupRec.subarray());
        } catch (err2) {
          this.log.error("Failed error correcting self", err2);
        }
        continue;
      }
      let sentCorrection = false;
      const request2 = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
      request2.record = Libp2pRecord.deserialize(fixupRec);
      for await (const event of this.network.sendRequest(from2, request2, options)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from: from2, error: (0, import_err_code108.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") });
      }
      this.log.error("Failed error correcting entry");
    }
  }
  async *put(key, value, options = {}) {
    this.log("put key %b value %b", key, value);
    const record = await createPutRecord(key, value);
    const dsKey = bufferToRecordKey(key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.getDatastore().put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => (0, import_it_map15.default)(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        const msg = new Message2(MESSAGE_TYPE.PUT_VALUE, key, 0);
        msg.record = Libp2pRecord.deserialize(record);
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
          events2.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events2.push(queryErrorEvent({ from: event.peer.id, error: (0, import_err_code108.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") }));
          }
        }
        return events2;
      };
    }), (source) => (0, import_it_parallel3.default)(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
  }
  async *get(key, options = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i = 0;
    try {
      i = bestRecord(this.selectors, key, records);
    } catch (err2) {
      if (err2.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
        throw err2;
      }
    }
    const best = records[i];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw (0, import_err_code108.default)(new Error("best value was not found"), "ERR_NOT_FOUND");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options);
    yield vals[i];
  }
  async *getMany(key, options = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.getPeerId()
      });
    } catch (err2) {
      this.log("error getting local value for %b", key, err2);
    }
    const id = await convertBuffer(key);
    const rtp = this.routingTable.closestPeers(id);
    this.log("found %d peers in routing table", rtp.length);
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value });
        }
      }
    };
    yield* this.queryManager.run(key, rtp, getValueQuery, options);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
init_define_process();
var import_it_parallel4 = __toESM(require_it_parallel(), 1);
var import_it_map16 = __toESM(require_it_map(), 1);
var ContentRouting = class {
  constructor(init) {
    this.components = new Components();
    const { network, peerRouting, queryManager, routingTable, providers, lan } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
  }
  init(components) {
    this.components = components;
  }
  async *provide(key, multiaddrs, options = {}) {
    this.log("provide %s", key);
    await this.providers.addProvider(key, this.components.getPeerId());
    const msg = new Message2(MESSAGE_TYPE.ADD_PROVIDER, key.bytes, 0);
    msg.providerPeers = [{
      id: this.components.getPeerId(),
      multiaddrs,
      protocols: []
    }];
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events2 = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events2.push(sendEvent);
          }
        } catch (err2) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err2);
          events2.push(queryErrorEvent({ from: event.peer.id, error: err2 }));
        }
        return events2;
      };
    };
    yield* pipe(this.peerRouting.getClosestPeers(key.multihash.bytes, options), (source) => (0, import_it_map16.default)(source, (event) => maybeNotifyPeer(event)), (source) => (0, import_it_parallel4.default)(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events2 of source) {
        yield* events2;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  async *findProviders(key, options) {
    const toFind = this.routingTable.kBucketSize;
    const target = key.multihash.bytes;
    const id = await convertBuffer(target);
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        providers2.push({
          id: peerId,
          multiaddrs: (await this.components.getPeerStore().addressBook.get(peerId) ?? []).map((address) => address.multiaddr),
          protocols: []
        });
      }
      yield peerResponseEvent({ from: this.components.getPeerId(), messageType: MESSAGE_TYPE.GET_PROVIDERS, providers: providers2 });
      yield providerEvent({ from: this.components.getPeerId(), providers: providers2 });
    }
    if (provs.length >= toFind) {
      return;
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.GET_PROVIDERS, target, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    const providers = new Set(provs.map((p) => p.toString()));
    for await (const event of this.queryManager.run(target, this.routingTable.closestPeers(id), findProvidersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id.toString())) {
            continue;
          }
          providers.add(peer.id.toString());
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders });
        }
        if (providers.size === toFind) {
          return;
        }
      }
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
init_define_process();
var import_err_code109 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
init_define_process();
var PeerDistanceList = class {
  constructor(originDhtKey, capacity) {
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  get length() {
    return this.peerDistances.length;
  }
  get peers() {
    return this.peerDistances.map((pd) => pd.peerId);
  }
  async add(peerId) {
    if (this.peerDistances.find((pd) => pd.peerId.equals(peerId)) != null) {
      return;
    }
    const dhtKey = await convertPeerId(peerId);
    const el = {
      peerId,
      distance: xor(this.originDhtKey, dhtKey)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => compare(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    if (this.length === 0) {
      return true;
    }
    const dhtKeys = await Promise.all(peerIds.map(convertPeerId));
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    for (const dhtKey of dhtKeys) {
      const keyDistance = xor(this.originDhtKey, dhtKey);
      if (compare(keyDistance, furthestDistance) < 0) {
        return true;
      }
    }
    return false;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  constructor(init) {
    this.components = new Components();
    const { routingTable, network, validators: validators2, queryManager, lan } = init;
    this.routingTable = routingTable;
    this.network = network;
    this.validators = validators2;
    this.queryManager = queryManager;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
  }
  init(components) {
    this.components = components;
  }
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.getPeerStore().get(p);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.getPeerStore().get(peer);
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr),
        protocols: []
      };
    }
    return void 0;
  }
  async *_getValueSingle(peer, key, options = {}) {
    const msg = new Message2(MESSAGE_TYPE.GET_VALUE, key, 0);
    yield* this.network.sendRequest(peer, msg, options);
  }
  async *getPublicKeyFromNode(peer, options = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const recPeer = await peerIdFromKeys(keys_exports.marshalPublicKey({ bytes: event.record.value }));
        if (!recPeer.equals(peer)) {
          throw (0, import_err_code109.default)(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        if (recPeer.publicKey == null) {
          throw (0, import_err_code109.default)(new Error("public key missing"), "ERR_PUBLIC_KEY_MISSING");
        }
        yield valueEvent({ from: peer, value: recPeer.publicKey });
      }
    }
    throw (0, import_err_code109.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), "ERR_INVALID_RECORD");
  }
  async *findPeer(id, options = {}) {
    this.log("findPeer %p", id);
    const pi = await this.findPeerLocal(id);
    if (pi != null) {
      this.log("found local");
      yield finalPeerEvent({
        from: this.components.getPeerId(),
        peer: pi
      });
      return;
    }
    const key = await convertPeerId(id);
    const peers = this.routingTable.closestPeers(key);
    const match = peers.find((p) => p.equals(id));
    if (match != null) {
      try {
        const peer = await this.components.getPeerStore().get(id);
        this.log("found in peerStore");
        yield finalPeerEvent({
          from: this.components.getPeerId(),
          peer: {
            id: peer.id,
            multiaddrs: peer.addresses.map((address) => address.multiaddr),
            protocols: []
          }
        });
        return;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    const self2 = this;
    const findPeerQuery = async function* ({ peer, signal }) {
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, id.toBytes(), 0);
      for await (const event of self2.network.sendRequest(peer, request2, { signal })) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          const match2 = event.closer.find((p) => p.id.equals(id));
          if (match2 != null) {
            yield finalPeerEvent({ from: event.from, peer: match2 });
          }
        }
      }
    };
    let foundPeer = false;
    for await (const event of this.queryManager.run(id.toBytes(), peers, findPeerQuery, options)) {
      if (event.name === "FINAL_PEER") {
        foundPeer = true;
      }
      yield event;
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.components.getPeerId(), error: (0, import_err_code109.default)(new Error("Not found"), "ERR_NOT_FOUND") });
    }
  }
  async *getClosestPeers(key, options = {}) {
    this.log("getClosestPeers to %b", key);
    const id = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(id);
    const self2 = this;
    const peers = new PeerDistanceList(id, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => await peers.add(peer)));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString(key, "base32"), peer);
      const request2 = new Message2(MESSAGE_TYPE.FIND_NODE, key, 0);
      yield* self2.network.sendRequest(peer, request2, { signal });
    };
    for await (const event of this.queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => await peers.add(peerData.id)));
      }
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.components.getPeerId(),
        peer: {
          id: peer,
          multiaddrs: (await this.components.getPeerStore().addressBook.get(peer) ?? []).map((addr) => addr.multiaddr),
          protocols: []
        }
      });
    }
  }
  async *getValueOrPeers(peer, key, options = {}) {
    for await (const event of this._getValueSingle(peer, key, options)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err2) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: (0, import_err_code109.default)(new Error(errMsg), "ERR_INVALID_RECORD") });
            continue;
          }
        }
      }
      yield event;
    }
  }
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw (0, import_err_code109.default)(new Error("invalid record received"), "ERR_INVALID_RECORD");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  async getCloserPeersOffline(key, closerThan) {
    const id = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(id);
    const output = [];
    for (const peerId of ids) {
      if (peerId.equals(closerThan)) {
        continue;
      }
      try {
        const addresses = await this.components.getPeerStore().addressBook.get(peerId);
        const protocols = await this.components.getPeerStore().protoBook.get(peerId);
        output.push({
          id: peerId,
          multiaddrs: addresses.map((address) => address.multiaddr),
          protocols
        });
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
    }
    if (output.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
    }
    return output;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/providers.js
init_define_process();
var import_hashlru5 = __toESM(require_hashlru(), 1);
var import_varint4 = __toESM(require_varint(), 1);
var log86 = logger("libp2p:kad-dht:providers");
var Providers = class {
  constructor(init = {}) {
    this.components = new Components();
    const { cacheSize, cleanupInterval, provideValidity } = init;
    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
    this.cache = (0, import_hashlru5.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
    this.syncQueue = new PQueue({ concurrency: 1 });
    this.started = false;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    this.cleaner = setInterval(() => {
      this._cleanup().catch((err2) => {
        log86.error(err2);
      });
    }, this.cleanupInterval);
  }
  async stop() {
    this.started = false;
    if (this.cleaner != null) {
      clearInterval(this.cleaner);
      this.cleaner = void 0;
    }
  }
  async _cleanup() {
    return await this.syncQueue.add(async () => {
      const start = Date.now();
      let count = 0;
      let deleteCount = 0;
      const deleted = /* @__PURE__ */ new Map();
      const batch3 = this.components.getDatastore().batch();
      const query = this.components.getDatastore().query({ prefix: PROVIDER_KEY_PREFIX });
      for await (const entry of query) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const time = readTime(entry.value).getTime();
          const now = Date.now();
          const delta = now - time;
          const expired = delta > this.provideValidity;
          log86("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
          if (expired) {
            deleteCount++;
            batch3.delete(entry.key);
            const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
            peers.add(peerId);
            deleted.set(cid, peers);
          }
          count++;
        } catch (err2) {
          log86.error(err2.message);
        }
      }
      if (deleted.size > 0) {
        log86("deleting %d / %d entries", deleteCount, count);
        await batch3.commit();
      } else {
        log86("nothing to delete");
      }
      for (const [cid, peers] of deleted) {
        const key = makeProviderKey(cid);
        const provs = this.cache.get(key);
        if (provs != null) {
          for (const peerId of peers) {
            provs.delete(peerId);
          }
          if (provs.size === 0) {
            this.cache.remove(key);
          } else {
            this.cache.set(key, provs);
          }
        }
      }
      log86("Cleanup successful (%dms)", Date.now() - start);
    });
  }
  async _getProvidersMap(cid) {
    const cacheKey = makeProviderKey(cid);
    let provs = this.cache.get(cacheKey);
    if (provs == null) {
      provs = await loadProviders(this.components.getDatastore(), cid);
      this.cache.set(cacheKey, provs);
    }
    return provs;
  }
  async addProvider(cid, provider) {
    return await this.syncQueue.add(async () => {
      log86("%p provides %s", provider, cid);
      const provs = await this._getProvidersMap(cid);
      log86("loaded %s provs", provs.size);
      const now = new Date();
      provs.set(provider.toString(), now);
      const dsKey = makeProviderKey(cid);
      this.cache.set(dsKey, provs);
      await writeProviderEntry(this.components.getDatastore(), cid, provider, now);
    });
  }
  async getProviders(cid) {
    return await this.syncQueue.add(async () => {
      log86("get providers for %s", cid);
      const provs = await this._getProvidersMap(cid);
      return [...provs.keys()].map((peerIdStr) => {
        return peerIdFromString(peerIdStr);
      });
    });
  }
};
function makeProviderKey(cid) {
  const cidStr = typeof cid === "string" ? cid : toString(cid.multihash.bytes, "base32");
  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
}
async function writeProviderEntry(store, cid, peer, time) {
  const dsKey = [
    makeProviderKey(cid),
    "/",
    peer.toString()
  ].join("");
  const key = new Key(dsKey);
  const buffer2 = Uint8Array.from(import_varint4.default.encode(time.getTime()));
  return await store.put(key, buffer2);
}
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  if (parts.length !== 5) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: parts[3],
    peerId: parts[4]
  };
}
async function loadProviders(store, cid) {
  const providers = /* @__PURE__ */ new Map();
  const query = store.query({ prefix: makeProviderKey(cid) });
  for await (const entry of query) {
    const { peerId } = parseProviderKey(entry.key);
    providers.set(peerId, readTime(entry.value));
  }
  return providers;
}
function readTime(buf2) {
  return new Date(import_varint4.default.decode(buf2));
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/query/manager.js
init_define_process();
var import_timeout_abort_controller16 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal9 = __toESM(require_any_signal(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
init_define_process();
var import_err_code110 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller15 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal8 = __toESM(require_any_signal(), 1);
var MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
async function* queryPath(options) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log101, peersSeen } = options;
  const queue = new PQueue({
    concurrency: alpha
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = BigInt("0x" + toString(xor(peerKadId, kadId), "base16"));
    queue.add(async () => {
      let timeout;
      const signals = [signal];
      if (queryFuncTimeout != null) {
        timeout = new import_timeout_abort_controller15.TimeoutController(queryFuncTimeout);
        signals.push(timeout.signal);
      }
      const compoundSignal = (0, import_any_signal8.anySignal)(signals);
      try {
        for await (const event of query({
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log101("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log101("not querying ourselves");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = BigInt("0x" + toString(xor(closerPeerKadId, kadId), "base16"));
              if (closerPeerXor > peerXor) {
                log101("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log101("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.emit("completed", event);
        }
        timeout?.clear();
      } catch (err2) {
        if (signal.aborted) {
          queue.emit("error", err2);
        } else {
          queue.emit("completed", queryErrorEvent({
            from: peer,
            error: err2
          }));
        }
      } finally {
        timeout?.clear();
      }
    }, {
      priority: MAX_XOR - peerXor
    }).catch((err2) => {
      log101.error(err2);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  yield* toGenerator(queue, signal, cleanUp, log101);
}
async function* toGenerator(queue, signal, cleanUp, log101) {
  let deferred = pDefer();
  let running = true;
  const results = [];
  const cleanup = () => {
    if (!running) {
      return;
    }
    log101("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
    running = false;
    queue.clear();
    results.splice(0, results.length);
  };
  queue.on("completed", (result) => {
    results.push(result);
    deferred.resolve();
  });
  queue.on("error", (err2) => {
    log101("queue error", err2);
    cleanup();
    deferred.reject(err2);
  });
  queue.on("idle", () => {
    log101("queue idle");
    running = false;
    deferred.resolve();
  });
  signal.addEventListener("abort", () => {
    log101("abort queue");
    const wasRunning = running;
    cleanup();
    if (wasRunning) {
      deferred.reject((0, import_err_code110.default)(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
    }
  });
  cleanUp.addEventListener("cleanup", () => {
    cleanup();
    deferred.resolve();
  });
  while (running) {
    await deferred.promise;
    deferred = pDefer();
    while (results.length > 0) {
      const result = results.shift();
      if (result != null) {
        yield result;
      }
    }
  }
  yield* results;
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var import_it_merge5 = __toESM(require_it_merge(), 1);
var import_events33 = __toESM(require_events(), 1);
var METRIC_RUNNING_QUERIES = "running-queries";
var QueryManager = class {
  constructor(init) {
    this.components = new Components();
    const { lan = false, disjointPaths = K, alpha = ALPHA } = init;
    this.disjointPaths = disjointPaths ?? K;
    this.controllers = /* @__PURE__ */ new Set();
    this.running = false;
    this.alpha = alpha ?? ALPHA;
    this.lan = lan;
    this.queries = 0;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    this.running = true;
  }
  async stop() {
    this.running = false;
    for (const controller of this.controllers) {
      controller.abort();
    }
    this.controllers.clear();
  }
  async *run(key, peers, queryFunc, options = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    let timeoutController;
    if (options.signal == null) {
      timeoutController = new import_timeout_abort_controller16.TimeoutController(DEFAULT_QUERY_TIMEOUT);
      options.signal = timeoutController.signal;
      try {
        if (import_events33.setMaxListeners != null) {
          (0, import_events33.setMaxListeners)(Infinity, timeoutController.signal);
        }
      } catch {
      }
    }
    const abortController = new AbortController();
    this.controllers.add(abortController);
    const signals = [abortController.signal];
    if (options.signal != null) {
      signals.push(options.signal);
    }
    const signal = (0, import_any_signal9.anySignal)(signals);
    try {
      if (import_events33.setMaxListeners != null) {
        (0, import_events33.setMaxListeners)(Infinity, signal);
      }
    } catch {
    }
    const log101 = logger(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + toString(key, "base58btc"));
    const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
    const startTime = Date.now();
    const cleanUp = new EventEmitter();
    try {
      log101("query:start");
      this.queries++;
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      if (peers.length === 0) {
        log101.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          key,
          startingPeer: peer,
          ourPeerId: this.components.getPeerId(),
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          cleanUp,
          queryFuncTimeout: options.queryFuncTimeout,
          log: log101,
          peersSeen
        });
      });
      for await (const event of (0, import_it_merge5.default)(...paths)) {
        yield event;
        if (event.name === "QUERY_ERROR") {
          log101("error", event.error);
        }
      }
    } catch (err2) {
      if (!this.running && err2.code === "ERR_QUERY_ABORTED") {
      } else {
        throw err2;
      }
    } finally {
      this.controllers.delete(abortController);
      if (timeoutController != null) {
        timeoutController.clear();
      }
      this.queries--;
      this.components.getMetrics()?.updateComponentMetric({
        system: "libp2p",
        component: `kad-dht-${this.lan ? "lan" : "wan"}`,
        metric: METRIC_RUNNING_QUERIES,
        value: this.queries
      });
      cleanUp.dispatchEvent(new CustomEvent("cleanup"));
      log101("query:done in %dms", Date.now() - startTime);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
init_define_process();
var import_err_code111 = __toESM(require_err_code(), 1);
var log87 = logger("libp2p:kad-dht:rpc:handlers:add-provider");
var AddProviderHandler = class {
  constructor(init) {
    const { providers } = init;
    this.providers = providers;
  }
  init() {
  }
  async handle(peerId, msg) {
    log87("start");
    if (msg.key == null || msg.key.length === 0) {
      throw (0, import_err_code111.default)(new Error("Missing key"), "ERR_MISSING_KEY");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code111.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    if (msg.providerPeers == null || msg.providerPeers.length === 0) {
      log87.error("no providers found in message");
    }
    await Promise.all(msg.providerPeers.map(async (pi) => {
      if (!pi.id.equals(peerId)) {
        log87("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        log87("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      log87("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m) => m.toString()));
      await this.providers.addProvider(cid, pi.id);
    }));
    return void 0;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
init_define_process();
var log88 = logger("libp2p:kad-dht:rpc:handlers:find-node");
var FindNodeHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, lan } = init;
    this.peerRouting = peerRouting;
    this.lan = Boolean(lan);
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    log88("incoming request from %p for peers closer to %b", peerId, msg.key);
    let closer = [];
    if (equals(this.components.getPeerId().toBytes(), msg.key)) {
      closer = [{
        id: this.components.getPeerId(),
        multiaddrs: this.components.getAddressManager().getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code)),
        protocols: []
      }];
    } else {
      closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    }
    closer = closer.map(this.lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
    const response = new Message2(msg.type, new Uint8Array(0), msg.clusterLevel);
    if (closer.length > 0) {
      response.closerPeers = closer;
    } else {
      log88("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
init_define_process();
var import_err_code112 = __toESM(require_err_code(), 1);
var log89 = logger("libp2p:kad-dht:rpc:handlers:get-providers");
var GetProvidersHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, providers, lan } = init;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.lan = Boolean(lan);
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err2) {
      throw (0, import_err_code112.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
    }
    log89("%p asking for providers for %s", peerId, cid);
    const [peers, closer] = await Promise.all([
      this.providers.getProviders(cid),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    const providerPeers = await this._getPeers(peers);
    const closerPeers = await this._getPeers(closer.map(({ id }) => id));
    const response = new Message2(msg.type, msg.key, msg.clusterLevel);
    if (providerPeers.length > 0) {
      response.providerPeers = providerPeers;
    }
    if (closerPeers.length > 0) {
      response.closerPeers = closerPeers;
    }
    log89("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
    return response;
  }
  async _getAddresses(peerId) {
    const addrs = await this.components.getPeerStore().addressBook.get(peerId);
    return addrs.map((address) => address.multiaddr);
  }
  async _getPeers(peerIds) {
    const output = [];
    const addrFilter = this.lan ? removePublicAddresses : removePrivateAddresses;
    for (const peerId of peerIds) {
      const peer = addrFilter({
        id: peerId,
        multiaddrs: await this._getAddresses(peerId),
        protocols: []
      });
      if (peer.multiaddrs.length > 0) {
        output.push(peer);
      }
    }
    return output;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
init_define_process();
var import_err_code113 = __toESM(require_err_code(), 1);
var log90 = logger("libp2p:kad-dht:rpc:handlers:get-value");
var GetValueHandler = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting } = init;
    this.peerRouting = peerRouting;
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    log90("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw (0, import_err_code113.default)(new Error("Invalid key"), "ERR_INVALID_KEY");
    }
    const response = new Message2(MESSAGE_TYPE.GET_VALUE, key, msg.clusterLevel);
    if (isPublicKeyKey(key)) {
      log90("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const key2 = await this.components.getPeerStore().keyBook.get(idFromKey);
        if (key2 == null) {
          throw (0, import_err_code113.default)(new Error("No public key found in key book"), "ERR_NOT_FOUND");
        }
        pubKey = key2;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
      }
      if (pubKey != null) {
        log90("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, new Date());
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(msg.key, peerId)
    ]);
    if (record != null) {
      log90("had record for %b in local datastore", key);
      response.record = record;
    }
    if (closer.length > 0) {
      log90("had %s closer peers in routing table", closer.length);
      response.closerPeers = closer;
    }
    return response;
  }
  async _checkLocalDatastore(key) {
    log90("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(key);
    let rawRecord;
    try {
      rawRecord = await this.components.getDatastore().get(dsKey);
    } catch (err2) {
      if (err2.code === "ERR_NOT_FOUND") {
        return void 0;
      }
      throw err2;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record == null) {
      throw (0, import_err_code113.default)(new Error("Invalid record"), "ERR_INVALID_RECORD");
    }
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.components.getDatastore().delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
init_define_process();
var log91 = logger("libp2p:kad-dht:rpc:handlers:ping");
var PingHandler = class {
  async handle(peerId, msg) {
    log91("ping from %p", peerId);
    return msg;
  }
  init() {
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
init_define_process();
var import_err_code114 = __toESM(require_err_code(), 1);
var PutValueHandler = class {
  constructor(init) {
    this.components = new Components();
    const { validators: validators2 } = init;
    this.log = logger("libp2p:kad-dht:rpc:handlers:put-value");
    this.validators = validators2;
  }
  init(components) {
    this.components = components;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    const record = msg.record;
    if (record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw (0, import_err_code114.default)(new Error(errMsg), "ERR_EMPTY_RECORD");
    }
    try {
      await verifyRecord(this.validators, record);
      record.timeReceived = new Date();
      const recordKey = bufferToRecordKey(record.key);
      await this.components.getDatastore().put(recordKey, record.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err2) {
      this.log("did not put record for key %b into datastore %o", key, err2);
    }
    return msg;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC = class {
  constructor(init) {
    const { providers, peerRouting, validators: validators2, lan } = init;
    this.log = logger("libp2p:kad-dht:rpc");
    this.routingTable = init.routingTable;
    this.handlers = {
      [MESSAGE_TYPE.GET_VALUE]: new GetValueHandler({ peerRouting }),
      [MESSAGE_TYPE.PUT_VALUE]: new PutValueHandler({ validators: validators2 }),
      [MESSAGE_TYPE.FIND_NODE]: new FindNodeHandler({ peerRouting, lan }),
      [MESSAGE_TYPE.ADD_PROVIDER]: new AddProviderHandler({ providers }),
      [MESSAGE_TYPE.GET_PROVIDERS]: new GetProvidersHandler({ peerRouting, providers, lan }),
      [MESSAGE_TYPE.PING]: new PingHandler()
    };
  }
  init(components) {
    for (const handler of Object.values(this.handlers)) {
      handler.init(components);
    }
  }
  async handleMessage(peerId, msg) {
    try {
      await this.routingTable.add(peerId);
    } catch (err2) {
      this.log.error("Failed to update the kbucket store", err2);
    }
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    return await handler.handle(peerId, msg);
  }
  onIncomingStream(data) {
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId = connection.remotePeer;
      try {
        await this.routingTable.add(peerId);
      } catch (err2) {
        this.log.error(err2);
      }
      const self2 = this;
      await pipe(stream, decode2(), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message2.deserialize(msg);
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield res.serialize();
          }
        }
      }, encode(), stream);
    }).catch((err2) => {
      this.log.error(err2);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
init_define_process();
var TopologyListener = class extends EventEmitter {
  constructor(init) {
    super();
    this.components = new Components();
    const { protocol, lan } = init;
    this.log = logger(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}`);
    this.running = false;
    this.protocol = protocol;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const topology = createTopology({
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
    this.registrarId = await this.components.getRegistrar().register(this.protocol, topology);
  }
  stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.getRegistrar().unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/query-self.js
init_define_process();
var import_events36 = __toESM(require_events(), 1);
var import_it_take5 = __toESM(require_it_take(), 1);
var import_it_length4 = __toESM(require_it_length(), 1);
var import_timeout_abort_controller17 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal10 = __toESM(require_any_signal(), 1);
var QuerySelf = class {
  constructor(init) {
    this.components = new Components();
    const { peerRouting, lan, count, interval, queryTimeout } = init;
    this.log = logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
    this.running = false;
    this.peerRouting = peerRouting;
    this.count = count ?? K;
    this.interval = interval ?? QUERY_SELF_INTERVAL;
    this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
  }
  init(components) {
    this.components = components;
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this._querySelf();
  }
  async stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  _querySelf() {
    Promise.resolve().then(async () => {
      const timeoutController = new import_timeout_abort_controller17.TimeoutController(this.queryTimeout);
      try {
        this.controller = new AbortController();
        const signal = (0, import_any_signal10.anySignal)([this.controller.signal, timeoutController.signal]);
        try {
          if (import_events36.setMaxListeners != null) {
            (0, import_events36.setMaxListeners)(Infinity, signal);
          }
        } catch {
        }
        const found = await pipe(this.peerRouting.getClosestPeers(this.components.getPeerId().toBytes(), {
          signal
        }), (source) => (0, import_it_take5.default)(source, this.count), async (source) => await (0, import_it_length4.default)(source));
        this.log("query ran successfully - found %d peers", found);
      } catch (err2) {
        this.log("query error", err2);
      } finally {
        this.timeoutId = setTimeout(this._querySelf.bind(this), this.interval);
        timeoutController.clear();
      }
    }).catch((err2) => {
      this.log("query error", err2);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var KadDHT = class extends EventEmitter {
  constructor(init) {
    super();
    this.components = new Components();
    const { kBucketSize, clientMode, validators: validators2, selectors: selectors2, querySelfInterval, lan, protocolPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams } = init;
    this.running = false;
    this.lan = Boolean(lan);
    this.log = logger(`libp2p:kad-dht:${lan === true ? "lan" : "wan"}`);
    this.protocol = `${protocolPrefix ?? PROTOCOL_PREFIX}${lan === true ? LAN_PREFIX : ""}${PROTOCOL_DHT}`;
    this.kBucketSize = kBucketSize ?? 20;
    this.clientMode = clientMode ?? true;
    this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
    this.routingTable = new RoutingTable({
      kBucketSize,
      lan: this.lan,
      pingTimeout,
      pingConcurrency,
      protocol: this.protocol
    });
    this.providers = new Providers();
    this.validators = {
      ...validators,
      ...validators2
    };
    this.selectors = {
      ...selectors,
      ...selectors2
    };
    this.network = new Network({
      protocol: this.protocol,
      lan: this.lan
    });
    this.queryManager = new QueryManager({
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      lan
    });
    this.peerRouting = new PeerRouting({
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      lan: this.lan
    });
    this.contentFetching = new ContentFetching({
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      network: this.network,
      lan: this.lan
    });
    this.contentRouting = new ContentRouting({
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      lan: this.lan
    });
    this.routingTableRefresh = new RoutingTableRefresh({
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      lan: this.lan
    });
    this.rpc = new RPC({
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      lan: this.lan
    });
    this.topologyListener = new TopologyListener({
      protocol: this.protocol,
      lan: this.lan
    });
    this.querySelf = new QuerySelf({
      peerRouting: this.peerRouting,
      interval: querySelfInterval,
      lan: this.lan
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err2) => {
        this.log.error("could not add %p to routing table", peerData.id, err2);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const multiaddrs = await this.components.getPeerStore().addressBook.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: multiaddrs.map((addr) => addr.multiaddr),
          protocols: []
        };
        await this.onPeerConnect(peerData);
      }).catch((err2) => {
        this.log.error("could not add %p to routing table", peerId, err2);
      });
    });
  }
  get [symbol2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/kad-dht";
  }
  init(components) {
    this.components = components;
    this.routingTable.init(components);
    this.providers.init(components);
    this.network.init(components);
    this.queryManager.init(components);
    this.peerRouting.init(components);
    this.contentFetching.init(components);
    this.contentRouting.init(components);
    this.routingTableRefresh.init(components);
    this.rpc.init(components);
    this.topologyListener.init(components);
    this.querySelf.init(components);
  }
  async onPeerConnect(peerData) {
    this.log("peer %p connected with protocols %s", peerData.id, peerData.protocols);
    if (this.lan) {
      peerData = removePublicAddresses(peerData);
    } else {
      peerData = removePrivateAddresses(peerData);
    }
    if (peerData.multiaddrs.length === 0) {
      this.log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this.lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err2) {
      this.log.error("could not add %p to routing table", peerData.id, err2);
    }
  }
  isStarted() {
    return this.running;
  }
  async getMode() {
    return this.clientMode ? "client" : "server";
  }
  async setMode(mode) {
    await this.components.getRegistrar().unhandle(this.protocol);
    if (mode === "client") {
      this.log("enabling client mode");
      this.clientMode = true;
    } else {
      this.log("enabling server mode");
      this.clientMode = false;
      await this.components.getRegistrar().handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  async start() {
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server");
    await Promise.all([
      this.providers.start(),
      this.queryManager.start(),
      this.network.start(),
      this.routingTable.start(),
      this.topologyListener.start(),
      this.querySelf.start()
    ]);
    await this.routingTableRefresh.start();
  }
  async stop() {
    this.running = false;
    await Promise.all([
      this.providers.stop(),
      this.queryManager.stop(),
      this.network.stop(),
      this.routingTable.stop(),
      this.routingTableRefresh.stop(),
      this.topologyListener.stop(),
      this.querySelf.stop()
    ]);
  }
  async *put(key, value, options = {}) {
    yield* this.contentFetching.put(key, value, options);
  }
  async *get(key, options = {}) {
    yield* this.contentFetching.get(key, options);
  }
  async *provide(key, options = {}) {
    yield* this.contentRouting.provide(key, this.components.getAddressManager().getAddresses(), options);
  }
  async *findProviders(key, options = {}) {
    yield* this.contentRouting.findProviders(key, options);
  }
  async *findPeer(id, options = {}) {
    yield* this.peerRouting.findPeer(id, options);
  }
  async *getClosestPeers(key, options = {}) {
    yield* this.peerRouting.getClosestPeers(key, options);
  }
  async refreshRoutingTable() {
    await this.routingTableRefresh.refreshTable(true);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/dual-kad-dht.js
init_define_process();
var import_err_code115 = __toESM(require_err_code(), 1);
var import_it_merge6 = __toESM(require_it_merge(), 1);
var log92 = logger("libp2p:kad-dht");
var DualKadDHT = class extends EventEmitter {
  constructor(wan, lan) {
    super();
    this.components = new Components();
    this.wan = wan;
    this.lan = lan;
    this.wan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
    this.lan.addEventListener("peer", (evt) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: evt.detail
      }));
    });
  }
  get [symbol2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dual-kad-dht";
  }
  init(components) {
    this.components = components;
    this.wan.init(components);
    this.lan.init(components);
  }
  isStarted() {
    return this.wan.isStarted() && this.lan.isStarted();
  }
  async getMode() {
    return await this.wan.getMode();
  }
  async setMode(mode) {
    await this.wan.setMode(mode);
  }
  async start() {
    await Promise.all([
      this.lan.start(),
      this.wan.start()
    ]);
  }
  async stop() {
    await Promise.all([
      this.lan.stop(),
      this.wan.stop()
    ]);
  }
  async *put(key, value, options = {}) {
    for await (const event of (0, import_it_merge6.default)(this.lan.put(key, value, options), this.wan.put(key, value, options))) {
      yield event;
    }
  }
  async *get(key, options = {}) {
    let queriedPeers = false;
    let foundValue = false;
    for await (const event of (0, import_it_merge6.default)(this.lan.get(key, options), this.wan.get(key, options))) {
      yield event;
      if (event.name === "DIALING_PEER") {
        queriedPeers = true;
      }
      if (event.name === "VALUE") {
        queriedPeers = true;
        if (event.value != null) {
          foundValue = true;
        }
      }
      if (event.name === "SENDING_QUERY") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code115.default)(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
    }
    if (!foundValue) {
      yield queryErrorEvent({
        from: this.components.getPeerId(),
        error: (0, import_err_code115.default)(new Error("Not found"), "ERR_NOT_FOUND")
      });
    }
  }
  async *provide(key, options = {}) {
    let sent = 0;
    let success = 0;
    const errors2 = [];
    const dhts = [this.lan];
    if (await this.wan.getMode() === "server") {
      dhts.push(this.wan);
    }
    for await (const event of (0, import_it_merge6.default)(...dhts.map((dht) => dht.provide(key, options)))) {
      yield event;
      if (event.name === "SENDING_QUERY") {
        sent++;
      }
      if (event.name === "QUERY_ERROR") {
        errors2.push(event.error);
      }
      if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
        log92("sent provider record for %s to %p", key, event.from);
        success++;
      }
    }
    if (success === 0) {
      if (errors2.length > 0) {
        throw (0, import_err_code115.default)(new Error(`Failed to provide to ${errors2.length} of ${sent} peers`), "ERR_PROVIDES_FAILED", { errors: errors2 });
      }
      throw (0, import_err_code115.default)(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
    }
  }
  async *findProviders(key, options = {}) {
    yield* (0, import_it_merge6.default)(this.lan.findProviders(key, options), this.wan.findProviders(key, options));
  }
  async *findPeer(id, options = {}) {
    let queriedPeers = false;
    for await (const event of (0, import_it_merge6.default)(this.lan.findPeer(id, options), this.wan.findPeer(id, options))) {
      yield event;
      if (event.name === "SENDING_QUERY" || event.name === "FINAL_PEER") {
        queriedPeers = true;
      }
    }
    if (!queriedPeers) {
      throw (0, import_err_code115.default)(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
    }
  }
  async *getClosestPeers(key, options = {}) {
    yield* (0, import_it_merge6.default)(this.lan.getClosestPeers(key, options), this.wan.getClosestPeers(key, options));
  }
  async refreshRoutingTable() {
    await Promise.all([
      this.lan.refreshRoutingTable(),
      this.wan.refreshRoutingTable()
    ]);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-kad-dht-npm-3.1.0-59fbe8e144-9.zip/node_modules/@libp2p/kad-dht/dist/src/index.js
var KadDHT2 = class extends DualKadDHT {
  constructor(init) {
    super(new KadDHT({
      protocolPrefix: "/ipfs",
      ...init,
      lan: false
    }), new KadDHT({
      protocolPrefix: "/ipfs",
      ...init,
      clientMode: false,
      lan: true
    }));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-bootstrap-npm-2.0.1-9dc71845b4-9.zip/node_modules/@libp2p/bootstrap/dist/src/index.js
init_define_process();
var log93 = logger("libp2p:bootstrap");
var Bootstrap = class extends EventEmitter {
  constructor(options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.interval = options.interval ?? 1e4;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        log93.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        log93.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma],
        protocols: []
      };
      this.list.push(peerData);
    }
  }
  get [symbol2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/bootstrap";
  }
  isStarted() {
    return Boolean(this.timer);
  }
  start() {
    if (this.timer != null) {
      return;
    }
    this.timer = setInterval(() => this._discoverBootstrapPeers(), this.interval);
    log93("Starting bootstrap node discovery");
    this._discoverBootstrapPeers();
  }
  _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    this.list.forEach((peerData) => {
      this.dispatchEvent(new CustomEvent("peer", { detail: peerData }));
    });
  }
  stop() {
    if (this.timer != null) {
      clearInterval(this.timer);
    }
    this.timer = void 0;
  }
};
Bootstrap.tag = "bootstrap";

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/client.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/web-socket.browser.js
init_define_process();
var web_socket_browser_default = WebSocket;

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/duplex.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/source.js
init_define_process();
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer || obj?.constructor?.name === "ArrayBuffer" && typeof obj?.byteLength === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => await new Promise((resolve7, reject) => {
    if (isConnected) {
      return resolve7();
    }
    if (connError != null) {
      return reject(connError);
    }
    const cleanUp = (cont) => {
      socket.removeEventListener("open", onOpen);
      socket.removeEventListener("error", onError);
      cont();
    };
    const onOpen = () => cleanUp(resolve7);
    const onError = (event) => {
      cleanUp(() => reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)));
    };
    socket.addEventListener("open", onOpen);
    socket.addEventListener("error", onError);
  });
  const source = async function* () {
    const messages3 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => fail(event.error ?? new Error("Socket error"));
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop2);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop2);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages3) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/sink.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/ready.js
init_define_process();
var ready_default = (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  return new Promise((resolve7, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve7();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err2) {
        if (err2.message === "socket closed")
          break;
        throw err2;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      return await new Promise((resolve7, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve7();
          } else {
            const err2 = Object.assign(new Error("ws error"), { event });
            reject(err2);
          }
        });
        setTimeout(() => socket.close());
      });
    }
  };
  return sink;
};

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => await connectedSource.connected(),
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve7) => {
          socket.addEventListener("close", () => {
            resolve7();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/ws-url.js
init_define_process();
var import_iso_url2 = __toESM(require_iso_url(), 1);
var map17 = { http: "ws", https: "wss" };
var def = "ws";
var ws_url_default = (url, location2) => (0, import_iso_url2.relative)(url, location2, map17, def);

// ../../../../../Users/z/.yarn/berry/cache/it-ws-npm-5.0.2-e86b828db5-9.zip/node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location2 = typeof window === "undefined" ? "" : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location2.toString());
  const socket = new web_socket_browser_default(url, opts.websocket);
  return duplex_default(socket, opts);
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/listener.browser.js
init_define_process();
function createListener2() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/constants.js
init_define_process();
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CODE_TCP = 6;
var CODE_WSS = 478;
var CLOSE_TIMEOUT = 2e3;

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
var log94 = logger("libp2p:websockets:socket");
function socketToMaConn(stream, remoteAddr, options) {
  options = options ?? {};
  const maConn = {
    async sink(source) {
      if (options?.signal != null) {
        source = abortableSource(source, options.signal);
      }
      try {
        await stream.sink(source);
      } catch (err2) {
        if (err2.type !== "aborted") {
          log94.error(err2);
        }
      }
    },
    source: options.signal != null ? abortableSource(stream.source, options.signal) : stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close() {
      const start = Date.now();
      try {
        await pTimeout2(stream.close(), {
          milliseconds: CLOSE_TIMEOUT
        });
      } catch (err2) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log94("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        stream.destroy();
      } finally {
        maConn.timeline.close = Date.now();
      }
    }
  };
  stream.socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/filters.js
init_define_process();
function all10(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function dnsWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-websockets-npm-3.0.4-333820c03f-9.zip/node_modules/@libp2p/websockets/dist/src/index.js
var log95 = logger("libp2p:websockets");
var WebSockets2 = class {
  constructor(init) {
    this.init = init;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/websockets";
  }
  get [symbol]() {
    return true;
  }
  async dial(ma, options) {
    log95("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma);
    log95("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log95("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    if (options?.signal?.aborted === true) {
      throw new AbortError3();
    }
    const cOpts = ma.toOptions();
    log95("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const errfn = (err2) => {
      log95.error("connection error:", err2);
      errorPromise.reject(err2);
    };
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    if (rawSocket.socket.on != null) {
      rawSocket.socket.on("error", errfn);
    } else {
      rawSocket.socket.onerror = errfn;
    }
    if (options.signal == null) {
      await Promise.race([rawSocket.connected(), errorPromise.promise]);
      log95("connected %s", ma);
      return rawSocket;
    }
    let onAbort;
    const abort = new Promise((resolve7, reject) => {
      onAbort = () => {
        reject(new AbortError3());
        rawSocket.close().catch((err2) => {
          log95.error("error closing raw socket", err2);
        });
      };
      if (options?.signal?.aborted === true) {
        return onAbort();
      }
      options?.signal?.addEventListener("abort", onAbort);
    });
    try {
      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
    } finally {
      if (onAbort != null) {
        options?.signal?.removeEventListener("abort", onAbort);
      }
    }
    log95("connected %s", ma);
    return rawSocket;
  }
  createListener(options) {
    return createListener2({ ...this.init, ...options });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (this.init?.filter != null) {
      return this.init?.filter(multiaddrs);
    }
    if (isBrowser3 || isWebWorker2) {
      return dnsWss(multiaddrs);
    }
    return all10(multiaddrs);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/mplex.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/encode.js
init_define_process();
var import_varint5 = __toESM(require_varint(), 1);

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js
init_define_process();
function allocUnsafe(size) {
  return new Uint8Array(size);
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/message-types.js
init_define_process();
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder = class {
  constructor() {
    this._pool = allocUnsafe(POOL_SIZE);
    this._poolOffset = 0;
  }
  write(msg) {
    const pool = this._pool;
    let offset = this._poolOffset;
    import_varint5.default.encode(msg.id << 3 | msg.type, pool, offset);
    offset += import_varint5.default.encode.bytes;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      import_varint5.default.encode(msg.data.length, pool, offset);
    } else {
      import_varint5.default.encode(0, pool, offset);
    }
    offset += import_varint5.default.encode.bytes;
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      return [
        header,
        ...msg.data instanceof Uint8Array ? [msg.data] : msg.data
      ];
    }
    return [
      header
    ];
  }
};
var encoder = new Encoder();
async function* encode13(source) {
  for await (const msg of source) {
    if (Array.isArray(msg)) {
      for (const m of msg) {
        yield* encoder.write(m);
      }
    } else {
      yield* encoder.write(msg);
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/decode.js
init_define_process();
var Decoder = class {
  constructor() {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (_) {
          break;
        }
      }
      const { id, type, length: length5, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length5) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length5);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length5);
      this._headerInfo = null;
    }
    return msgs;
  }
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length5, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    return { id: h >> 3, type, offset: offset + end, length: length5 };
  }
};
var MSB = 128;
var REST = 127;
function readVarInt(buf2, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf2.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2.get(counter++);
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}
async function* decode12(source) {
  const decoder = new Decoder();
  for await (const chunk of source) {
    const msgs = decoder.write(chunk);
    if (msgs.length > 0) {
      yield msgs;
    }
  }
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/restrict-size.js
init_define_process();
var MAX_MSG_SIZE = 1 << 20;
function restrictSize(max) {
  const maxSize = max ?? MAX_MSG_SIZE;
  const checkSize = (msg) => {
    if (msg.type !== MessageTypes.NEW_STREAM && msg.type !== MessageTypes.MESSAGE_INITIATOR && msg.type !== MessageTypes.MESSAGE_RECEIVER) {
      return;
    }
    if (msg.data.byteLength > maxSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
  };
  return (source) => {
    return async function* restrictSize2() {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          msg.forEach(checkSize);
          yield* msg;
        } else {
          checkSize(msg);
          yield msg;
        }
      }
    }();
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/stream.js
init_define_process();
var import_err_code116 = __toESM(require_err_code(), 1);
var import_any_signal11 = __toESM(require_any_signal(), 1);
var log96 = logger("libp2p:mplex:stream");
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_SINK_ENDED = "ERR_SINK_ENDED";
var ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function createStream(options) {
  const { id, name: name6, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  const abortController = new AbortController();
  const resetController = new AbortController();
  const closeController = new AbortController();
  const Types2 = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
  const externalId = type === "initiator" ? `i${id}` : `r${id}`;
  const streamName = `${name6 == null ? id : name6}`;
  let sourceEnded = false;
  let sinkEnded = false;
  let sinkSunk = false;
  let endErr;
  const timeline = {
    open: Date.now()
  };
  const onSourceEnd = (err2) => {
    if (sourceEnded) {
      return;
    }
    sourceEnded = true;
    log96.trace("%s stream %s source end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sinkEnded) {
      stream.stat.timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const onSinkEnd = (err2) => {
    if (sinkEnded) {
      return;
    }
    sinkEnded = true;
    log96.trace("%s stream %s sink end - err: %o", type, streamName, err2);
    if (err2 != null && endErr == null) {
      endErr = err2;
    }
    if (sourceEnded) {
      timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const streamSource = pushable({
    onEnd: onSourceEnd
  });
  const stream = {
    close: () => {
      log96.trace("%s stream %s close", type, streamName);
      stream.closeRead();
      stream.closeWrite();
    },
    closeRead: () => {
      log96.trace("%s stream %s closeRead", type, streamName);
      if (sourceEnded) {
        return;
      }
      streamSource.end();
    },
    closeWrite: () => {
      log96.trace("%s stream %s closeWrite", type, streamName);
      if (sinkEnded) {
        return;
      }
      closeController.abort();
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log96.trace("%s stream %s error sending close", type, name6, err2);
      }
      onSinkEnd();
    },
    abort: (err2) => {
      log96.trace("%s stream %s abort", type, streamName, err2);
      streamSource.end(err2);
      abortController.abort();
      onSinkEnd(err2);
    },
    reset: () => {
      const err2 = (0, import_err_code116.default)(new Error("stream reset"), ERR_STREAM_RESET);
      resetController.abort();
      streamSource.end(err2);
      onSinkEnd(err2);
    },
    sink: async (source) => {
      if (sinkSunk) {
        throw (0, import_err_code116.default)(new Error("sink already called on stream"), ERR_DOUBLE_SINK);
      }
      sinkSunk = true;
      if (sinkEnded) {
        throw (0, import_err_code116.default)(new Error("stream closed for writing"), ERR_SINK_ENDED);
      }
      source = abortableSource(source, (0, import_any_signal11.anySignal)([
        abortController.signal,
        resetController.signal,
        closeController.signal
      ]));
      try {
        if (type === "initiator") {
          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString(streamName)) });
        }
        const uint8ArrayList = new Uint8ArrayList();
        for await (const data of source) {
          if (data.length <= maxMsgSize) {
            send({ id, type: Types2.MESSAGE, data: data instanceof Uint8ArrayList ? data : new Uint8ArrayList(data) });
          } else {
            uint8ArrayList.append(data);
            while (uint8ArrayList.length !== 0) {
              if (uint8ArrayList.length <= maxMsgSize) {
                send({ id, type: Types2.MESSAGE, data: uint8ArrayList.sublist() });
                uint8ArrayList.consume(uint8ArrayList.length);
                break;
              }
              send({ id, type: Types2.MESSAGE, data: uint8ArrayList.sublist(0, maxMsgSize) });
              uint8ArrayList.consume(maxMsgSize);
            }
          }
        }
      } catch (err2) {
        if (err2.type === "aborted" && err2.message === "The operation was aborted") {
          if (closeController.signal.aborted) {
            return;
          }
          if (resetController.signal.aborted) {
            err2.message = "stream reset";
            err2.code = ERR_STREAM_RESET;
          }
          if (abortController.signal.aborted) {
            err2.message = "stream aborted";
            err2.code = ERR_STREAM_ABORT;
          }
        }
        if (err2.code === ERR_STREAM_RESET) {
          log96.trace("%s stream %s reset", type, name6);
        } else {
          log96.trace("%s stream %s error", type, name6, err2);
          try {
            send({ id, type: Types2.RESET });
          } catch (err3) {
            log96.trace("%s stream %s error sending reset", type, name6, err3);
          }
        }
        streamSource.end(err2);
        onSinkEnd(err2);
        return;
      }
      try {
        send({ id, type: Types2.CLOSE });
      } catch (err2) {
        log96.trace("%s stream %s error sending close", type, name6, err2);
      }
      onSinkEnd();
    },
    source: streamSource,
    sourcePush: (data) => {
      streamSource.push(data);
    },
    sourceReadableLength() {
      return streamSource.readableLength;
    },
    stat: {
      direction: type === "initiator" ? "outbound" : "inbound",
      timeline
    },
    metadata: {},
    id: externalId
  };
  return stream;
}

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/mplex.js
var import_err_code117 = __toESM(require_err_code(), 1);
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);
var import_any_signal12 = __toESM(require_any_signal(), 1);
var log97 = logger("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(components, init) {
    this.protocol = "/mplex/6.7.0";
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      initiators: /* @__PURE__ */ new Map(),
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.sink = this._createSink();
    const source = this._createSource();
    this._source = source;
    this.source = source;
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  init(components) {
  }
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  newStream(name6) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name6 = name6 == null ? id.toString() : name6.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name6, type: "initiator", registry });
  }
  close(err2) {
    if (this.closeController.signal.aborted)
      return;
    if (err2 != null) {
      this.streams.forEach((s) => s.abort(err2));
    } else {
      this.streams.forEach((s) => s.close());
    }
    this.closeController.abort();
  }
  _newReceiverStream(options) {
    const { id, name: name6 } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name6, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name: name6, type, registry } = options;
    log97("new %s stream %s %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw (0, import_err_code117.default)(new Error("Too many outbound streams open"), "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = (msg) => {
      if (log97.enabled) {
        log97.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log97("%s stream with id %s and protocol %s ended", type, id, stream.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name6, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  _createSink() {
    const sink = async (source) => {
      const abortSignals = [this.closeController.signal];
      if (this._init.signal != null) {
        abortSignals.push(this._init.signal);
      }
      source = abortableSource(source, (0, import_any_signal12.default)(abortSignals));
      try {
        await pipe(source, decode12, restrictSize(this._init.maxMsgSize), async (source2) => {
          for await (const msg of source2) {
            await this._handleIncoming(msg);
          }
        });
        this._source.end();
      } catch (err2) {
        log97("error in sink", err2);
        this._source.end(err2);
      }
    };
    return sink;
  }
  _createSource() {
    const onEnd = (err2) => {
      this.close(err2);
    };
    const source = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode13(source), {
      push: source.push,
      end: source.end,
      return: source.return
    });
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (log97.enabled) {
      log97.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log97("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log97("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log97("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message2.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error = (0, import_err_code117.default)(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
          stream.abort(error);
          return;
        }
        stream.sourcePush(message2.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset();
        break;
      default:
        log97("unknown message type %s", type);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-mplex-npm-5.2.4-06ed98a208-9.zip/node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  constructor(init = {}) {
    this.protocol = "/mplex/6.7.0";
    this.components = new Components();
    this._init = init;
  }
  init(components) {
    this.components = components;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/crypto/stablelib.js
init_define_process();
var import_hkdf = __toESM(require_hkdf(), 1);
var x25519 = __toESM(require_x25519(), 1);
var import_sha256 = __toESM(require_sha256(), 1);
var import_chacha20poly1305 = __toESM(require_chacha20poly1305(), 1);
var stablelib = {
  hashSHA256(data) {
    return (0, import_sha256.hash)(data);
  },
  getHKDF(ck, ikm) {
    const hkdf = new import_hkdf.HKDF(import_sha256.SHA256, ikm, ck);
    const okmU8Array = hkdf.expand(96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const keypair = x25519.generateKeyPair();
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const keypair = x25519.generateKeyPairFromSeed(seed);
    return {
      publicKey: keypair.publicKey,
      privateKey: keypair.secretKey
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.sharedKey(privateKey, publicKey);
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.seal(nonce, plaintext, ad);
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k) {
    const ctx = new import_chacha20poly1305.ChaCha20Poly1305(k);
    return ctx.open(nonce, ciphertext, ad);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-pb-stream-npm-2.0.2-76f144f1e6-9.zip/node_modules/it-pb-stream/dist/src/index.js
init_define_process();
function pbStream(duplex, opts = {}) {
  const shake = handshake(duplex);
  const lpReader = decode2.fromReader(shake.reader, opts);
  const W = {
    read: async (bytes2) => {
      const { value } = await shake.reader.next(bytes2);
      if (value == null) {
        throw new Error("Value is null");
      }
      return value;
    },
    readLP: async () => {
      const { value } = await lpReader.next();
      if (value == null) {
        throw new Error("Value is null");
      }
      return value;
    },
    readPB: async (proto) => {
      const value = await W.readLP();
      if (value == null) {
        throw new Error("Value is null");
      }
      const buf2 = value instanceof Uint8Array ? value : value.slice();
      return proto.decode(buf2);
    },
    write: (data) => {
      if (data instanceof Uint8Array) {
        shake.writer.push(data);
      } else {
        shake.writer.push(data.slice());
      }
    },
    writeLP: (data) => {
      W.write(encode.single(data, opts));
    },
    writePB: (data, proto) => {
      W.writeLP(proto.encode(data));
    },
    pb: (proto) => {
      return {
        read: async () => await W.readPB(proto),
        write: (d) => W.writePB(d, proto)
      };
    },
    unwrap: () => {
      shake.rest();
      return shake.stream;
    }
  };
  return W;
}

// ../../../../../Users/z/.yarn/berry/cache/it-pair-npm-2.0.3-5fb2c1aa3c-9.zip/node_modules/it-pair/dist/src/duplex.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/it-pair-npm-2.0.3-5fb2c1aa3c-9.zip/node_modules/it-pair/dist/src/index.js
init_define_process();
function pair() {
  const deferred = pDefer();
  let piped = false;
  return {
    sink: async (source) => {
      if (piped) {
        throw new Error("already piped");
      }
      piped = true;
      deferred.resolve(source);
    },
    source: async function* () {
      const source = await deferred.promise;
      yield* source;
    }()
  };
}

// ../../../../../Users/z/.yarn/berry/cache/it-pair-npm-2.0.3-5fb2c1aa3c-9.zip/node_modules/it-pair/dist/src/duplex.js
function duplexPair() {
  const a = pair();
  const b = pair();
  return [
    {
      source: a.source,
      sink: b.sink
    },
    {
      source: b.source,
      sink: a.sink
    }
  ];
}

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
init_define_process();
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/crypto/streaming.js
init_define_process();
function encryptStream(handshake2) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const data = handshake2.encrypt(chunk.subarray(i, end), handshake2.session);
        yield data;
      }
    }
  };
}
function decryptStream(handshake2) {
  return async function* (source) {
    for await (const chunk of source) {
      for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.length) {
          end = chunk.length;
        }
        const { plaintext: decrypted, valid } = await handshake2.decrypt(chunk.subarray(i, end), handshake2.session);
        if (!valid) {
          throw new Error("Failed to validate decrypted chunk");
        }
        yield decrypted;
      }
    }
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
init_define_process();
init_concat();
var allocUnsafe2 = (len) => {
  if (globalThis.Buffer) {
    return globalThis.Buffer.allocUnsafe(len);
  }
  return new Uint8Array(len);
};
var uint16BEEncode = (value) => {
  const target = allocUnsafe2(2);
  new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(0, value, false);
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2)
    throw RangeError("Could not decode int16BE");
  if (data instanceof Uint8Array) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function encode0(message2) {
  return concat([message2.ne, message2.ciphertext], message2.ne.length + message2.ciphertext.length);
}
function encode1(message2) {
  return concat([message2.ne, message2.ns, message2.ciphertext], message2.ne.length + message2.ns.length + message2.ciphertext.length);
}
function encode22(message2) {
  return concat([message2.ns, message2.ciphertext], message2.ns.length + message2.ciphertext.length);
}
function decode0(input) {
  if (input.length < 32) {
    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ciphertext: input.subarray(32, input.length),
    ns: new Uint8Array(0)
  };
}
function decode1(input) {
  if (input.length < 80) {
    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
  }
  return {
    ne: input.subarray(0, 32),
    ns: input.subarray(32, 80),
    ciphertext: input.subarray(80, input.length)
  };
}
function decode22(input) {
  if (input.length < 48) {
    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
  }
  return {
    ne: new Uint8Array(0),
    ns: input.subarray(0, 48),
    ciphertext: input.subarray(48, input.length)
  };
}

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@libp2p-interface-connection-encrypter-npm-2.0.2-2b28afc72b-9.zip/node_modules/@libp2p/interface-connection-encrypter/dist/src/errors.js
init_define_process();
var UnexpectedPeerError = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.code = UnexpectedPeerError.code;
  }
  static get code() {
    return "ERR_UNEXPECTED_PEER";
  }
};
var InvalidCryptoExchangeError = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = InvalidCryptoExchangeError.code;
  }
  static get code() {
    return "ERR_INVALID_CRYPTO_EXCHANGE";
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
init_define_process();
init_concat();

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
init_define_process();
var pb;
(function(pb2) {
  let NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, writer, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            writer.fork();
          }
          if (obj.identityKey != null) {
            writer.uint32(10);
            writer.bytes(obj.identityKey);
          } else {
            throw new Error('Protocol error: required field "identityKey" was not found in object');
          }
          if (obj.identitySig != null) {
            writer.uint32(18);
            writer.bytes(obj.identitySig);
          } else {
            throw new Error('Protocol error: required field "identitySig" was not found in object');
          }
          if (obj.data != null) {
            writer.uint32(26);
            writer.bytes(obj.data);
          } else {
            throw new Error('Protocol error: required field "data" was not found in object');
          }
          if (opts.lengthDelimited !== false) {
            writer.ldelim();
          }
        }, (reader2, length5) => {
          const obj = {
            identityKey: new Uint8Array(0),
            identitySig: new Uint8Array(0),
            data: new Uint8Array(0)
          };
          const end = length5 == null ? reader2.len : reader2.pos + length5;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.identityKey = reader2.bytes();
                break;
              case 2:
                obj.identitySig = reader2.bytes();
                break;
              case 3:
                obj.data = reader2.bytes();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          if (obj.identityKey == null) {
            throw new Error('Protocol error: value for required field "identityKey" was not found in protobuf');
          }
          if (obj.identitySig == null) {
            throw new Error('Protocol error: value for required field "identitySig" was not found in protobuf');
          }
          if (obj.data == null) {
            throw new Error('Protocol error: value for required field "data" was not found in protobuf');
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf2) => {
      return decodeMessage(buf2, NoiseHandshakePayload2.codec());
    };
  })(NoiseHandshakePayload = pb2.NoiseHandshakePayload || (pb2.NoiseHandshakePayload = {}));
})(pb || (pb = {}));

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
var NoiseHandshakePayloadProto = pb.NoiseHandshakePayload;
async function getPayload(localPeer, staticPublicKey, earlyData) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
  const earlyDataPayload = earlyData ?? new Uint8Array(0);
  if (localPeer.publicKey == null) {
    throw new Error("PublicKey was missing from local PeerId");
  }
  return createHandshakePayload(localPeer.publicKey, signedPayload, earlyDataPayload);
}
function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
  return NoiseHandshakePayloadProto.encode({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    data: earlyData ?? new Uint8Array(0)
  }).subarray();
}
async function signPayload(peerId, payload) {
  if (peerId.privateKey == null) {
    throw new Error("PrivateKey was missing from PeerId");
  }
  const privateKey = await unmarshalPrivateKey(peerId.privateKey);
  return await privateKey.sign(payload);
}
async function getPeerIdFromPayload(payload) {
  return await peerIdFromKeys(payload.identityKey);
}
function decodePayload(payload) {
  return NoiseHandshakePayloadProto.decode(payload);
}
function getHandshakePayload(publicKey) {
  const prefix = fromString("noise-libp2p-static-key:");
  return concat([prefix, publicKey], prefix.length + publicKey.length);
}
async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const payloadPeerId = await peerIdFromKeys(payload.identityKey);
  if (!payloadPeerId.equals(remotePeer)) {
    throw new Error("Peer ID doesn't match libp2p public key.");
  }
  const generatedPayload = getHandshakePayload(noiseStaticKey);
  if (payloadPeerId.publicKey == null) {
    throw new Error("PublicKey was missing from PeerId");
  }
  if (payload.identitySig == null) {
    throw new Error("Signature was missing from message");
  }
  const publicKey = unmarshalPublicKey(payloadPeerId.publicKey);
  const valid = await publicKey.verify(generatedPayload, payload.identitySig);
  if (!valid) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }
  return payloadPeerId;
}
function isValidPublicKey(pk) {
  if (!(pk instanceof Uint8Array)) {
    return false;
  }
  if (pk.length !== 32) {
    return false;
  }
  return true;
}

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
init_define_process();
init_concat();

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
init_define_process();
var log98 = logger("libp2p:noise");
var keyLogger;
if (DUMP_SESSION_KEYS) {
  keyLogger = log98;
} else {
  keyLogger = Object.assign(() => {
  }, {
    enabled: false,
    trace: () => {
    },
    error: () => {
    }
  });
}
function logLocalStaticKeys(s) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString(s.publicKey, "hex")}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString(s.privateKey, "hex")}`);
}
function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString(e.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString(e.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString(rs, "hex")}`);
}
function logRemoteEphemeralKey(re) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString(re, "hex")}`);
}
function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n.getUint64()} ${toString(session.cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n.getUint64()} ${toString(session.cs2.k, "hex")}`);
  } else {
    keyLogger("Missing cipher state.");
  }
}

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
init_define_process();
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n = MIN_NONCE) {
    this.n = n;
    this.bytes = new Uint8Array(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var AbstractHandshake = class {
  constructor(crypto2) {
    this.crypto = crypto2;
  }
  encryptWithAd(cs, ad, plaintext) {
    const e = this.encrypt(cs.k, cs.n, ad, plaintext);
    cs.n.increment();
    return e;
  }
  decryptWithAd(cs, ad, ciphertext) {
    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
    if (valid)
      cs.n.increment();
    return { plaintext, valid };
  }
  hasKey(cs) {
    return !this.isEmptyKey(cs.k);
  }
  createEmptyKey() {
    return new Uint8Array(32);
  }
  isEmptyKey(k) {
    const emptyKey = this.createEmptyKey();
    return equals(emptyKey, k);
  }
  encrypt(k, n, ad, plaintext) {
    n.assertValue();
    return this.crypto.chaCha20Poly1305Encrypt(plaintext, n.getBytes(), ad, k);
  }
  encryptAndHash(ss, plaintext) {
    let ciphertext;
    if (this.hasKey(ss.cs)) {
      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
    } else {
      ciphertext = plaintext;
    }
    this.mixHash(ss, ciphertext);
    return ciphertext;
  }
  decrypt(k, n, ad, ciphertext) {
    n.assertValue();
    const encryptedMessage = this.crypto.chaCha20Poly1305Decrypt(ciphertext, n.getBytes(), ad, k);
    if (encryptedMessage) {
      return {
        plaintext: encryptedMessage,
        valid: true
      };
    } else {
      return {
        plaintext: new Uint8Array(0),
        valid: false
      };
    }
  }
  decryptAndHash(ss, ciphertext) {
    let plaintext;
    let valid = true;
    if (this.hasKey(ss.cs)) {
      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
    } else {
      plaintext = ciphertext;
    }
    this.mixHash(ss, ciphertext);
    return { plaintext, valid };
  }
  dh(privateKey, publicKey) {
    try {
      const derivedU8 = this.crypto.generateX25519SharedKey(privateKey, publicKey);
      if (derivedU8.length === 32) {
        return derivedU8;
      }
      return derivedU8.subarray(0, 32);
    } catch (e) {
      const err2 = e;
      log98(err2.message);
      return new Uint8Array(32);
    }
  }
  mixHash(ss, data) {
    ss.h = this.getHash(ss.h, data);
  }
  getHash(a, b) {
    const u = this.crypto.hashSHA256(concat([a, b], a.length + b.length));
    return u;
  }
  mixKey(ss, ikm) {
    const [ck, tempK] = this.crypto.getHKDF(ss.ck, ikm);
    ss.cs = this.initializeKey(tempK);
    ss.ck = ck;
  }
  initializeKey(k) {
    return { k, n: new Nonce() };
  }
  initializeSymmetric(protocolName) {
    const protocolNameBytes = fromString(protocolName, "utf-8");
    const h = this.hashProtocolName(protocolNameBytes);
    const ck = h;
    const key = this.createEmptyKey();
    const cs = this.initializeKey(key);
    return { cs, ck, h };
  }
  hashProtocolName(protocolName) {
    if (protocolName.length <= 32) {
      const h = new Uint8Array(32);
      h.set(protocolName);
      return h;
    } else {
      return this.getHash(protocolName, new Uint8Array(0));
    }
  }
  split(ss) {
    const [tempk1, tempk2] = this.crypto.getHKDF(ss.ck, new Uint8Array(0));
    const cs1 = this.initializeKey(tempk1);
    const cs2 = this.initializeKey(tempk2);
    return { cs1, cs2 };
  }
  writeMessageRegular(cs, payload) {
    const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
    const ne = this.createEmptyKey();
    const ns = new Uint8Array(0);
    return { ne, ns, ciphertext };
  }
  readMessageRegular(cs, message2) {
    return this.decryptWithAd(cs, new Uint8Array(0), message2.ciphertext);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var XX = class extends AbstractHandshake {
  initializeInitiator(prologue, s, rs, psk) {
    const name6 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name6);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s, rs, psk, re };
  }
  initializeResponder(prologue, s, rs, psk) {
    const name6 = "Noise_XX_25519_ChaChaPoly_SHA256";
    const ss = this.initializeSymmetric(name6);
    this.mixHash(ss, prologue);
    const re = new Uint8Array(32);
    return { ss, s, rs, psk, re };
  }
  writeMessageA(hs, payload, e) {
    const ns = new Uint8Array(0);
    if (e !== void 0) {
      hs.e = e;
    } else {
      hs.e = this.crypto.generateX25519KeyPair();
    }
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageB(hs, payload) {
    hs.e = this.crypto.generateX25519KeyPair();
    const ne = hs.e.publicKey;
    this.mixHash(hs.ss, ne);
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    return { ne, ns, ciphertext };
  }
  writeMessageC(hs, payload) {
    const spk = hs.s.publicKey;
    const ns = this.encryptAndHash(hs.ss, spk);
    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
    const ciphertext = this.encryptAndHash(hs.ss, payload);
    const ne = this.createEmptyKey();
    const messageBuffer = { ne, ns, ciphertext };
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, messageBuffer, cs1, cs2 };
  }
  readMessageA(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    return this.decryptAndHash(hs.ss, message2.ciphertext);
  }
  readMessageB(hs, message2) {
    if (isValidPublicKey(message2.ne)) {
      hs.re = message2.ne;
    }
    this.mixHash(hs.ss, hs.re);
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    return { plaintext, valid: valid1 && valid2 };
  }
  readMessageC(hs, message2) {
    const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message2.ns);
    if (valid1 && isValidPublicKey(ns)) {
      hs.rs = ns;
    }
    if (!hs.e) {
      throw new Error("Handshake state `e` param is missing.");
    }
    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
    const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message2.ciphertext);
    const { cs1, cs2 } = this.split(hs.ss);
    return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
  }
  initSession(initiator, prologue, s) {
    const psk = this.createEmptyKey();
    const rs = new Uint8Array(32);
    let hs;
    if (initiator) {
      hs = this.initializeInitiator(prologue, s, rs, psk);
    } else {
      hs = this.initializeResponder(prologue, s, rs, psk);
    }
    return {
      hs,
      i: initiator,
      mc: 0
    };
  }
  sendMessage(session, message2, ephemeral) {
    let messageBuffer;
    if (session.mc === 0) {
      messageBuffer = this.writeMessageA(session.hs, message2, ephemeral);
    } else if (session.mc === 1) {
      messageBuffer = this.writeMessageB(session.hs, message2);
    } else if (session.mc === 2) {
      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message2);
      messageBuffer = resultingBuffer;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    } else if (session.mc > 2) {
      if (session.i) {
        if (!session.cs1) {
          throw new Error("CS1 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs1, message2);
      } else {
        if (!session.cs2) {
          throw new Error("CS2 (cipher state) is not defined");
        }
        messageBuffer = this.writeMessageRegular(session.cs2, message2);
      }
    } else {
      throw new Error("Session invalid.");
    }
    session.mc++;
    return messageBuffer;
  }
  recvMessage(session, message2) {
    let plaintext = new Uint8Array(0);
    let valid = false;
    if (session.mc === 0) {
      ({ plaintext, valid } = this.readMessageA(session.hs, message2));
    } else if (session.mc === 1) {
      ({ plaintext, valid } = this.readMessageB(session.hs, message2));
    } else if (session.mc === 2) {
      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message2);
      plaintext = resultingPlaintext;
      valid = resultingValid;
      session.h = h;
      session.cs1 = cs1;
      session.cs2 = cs2;
    }
    session.mc++;
    return { plaintext, valid };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var XXHandshake = class {
  constructor(isInitiator, payload, prologue, crypto2, staticKeypair, connection, remotePeer, handshake2) {
    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;
    if (remotePeer) {
      this.remotePeer = remotePeer;
    }
    this.xx = handshake2 ?? new XX(crypto2);
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
    this.remoteEarlyData = new Uint8Array(0);
  }
  async propose() {
    logLocalStaticKeys(this.session.hs.s);
    if (this.isInitiator) {
      log98("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
      this.connection.writeLP(encode0(messageBuffer));
      log98("Stage 0 - Initiator finished sending first message.");
      logLocalEphemeralKeys(this.session.hs.e);
    } else {
      log98("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = decode0((await this.connection.readLP()).subarray());
      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");
      }
      log98("Stage 0 - Responder received first message.");
      logRemoteEphemeralKey(this.session.hs.re);
    }
  }
  async exchange() {
    if (this.isInitiator) {
      log98("Stage 1 - Initiator waiting to receive first message from responder...");
      const receivedMessageBuffer = decode1((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");
      }
      log98("Stage 1 - Initiator received the message.");
      logRemoteEphemeralKey(this.session.hs.re);
      logRemoteStaticKey(this.session.hs.rs);
      log98("Initiator going to check remote's signature...");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
      log98("All good with the signature!");
    } else {
      log98("Stage 1 - Responder sending out first message with signed payload and static key.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode1(messageBuffer));
      log98("Stage 1 - Responder sent the second handshake message with signed payload.");
      logLocalEphemeralKeys(this.session.hs.e);
    }
  }
  async finish() {
    if (this.isInitiator) {
      log98("Stage 2 - Initiator sending third handshake message.");
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP(encode22(messageBuffer));
      log98("Stage 2 - Initiator sent message with signed payload.");
    } else {
      log98("Stage 2 - Responder waiting for third handshake message...");
      const receivedMessageBuffer = decode22((await this.connection.readLP()).subarray());
      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
      if (!valid) {
        throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");
      }
      log98("Stage 2 - Responder received the message, finished handshake.");
      try {
        const decodedPayload = decodePayload(plaintext);
        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);
        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        const err2 = e;
        throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${err2.message}`);
      }
    }
    logCipherState(this.session);
  }
  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
  }
  decrypt(ciphertext, session) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext);
  }
  getRemoteStaticKey() {
    return this.session.hs.rs;
  }
  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");
    }
    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }
  setRemoteEarlyData(data) {
    if (data) {
      this.remoteEarlyData = data;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/@chainsafe-libp2p-noise-npm-8.0.2-493cbccecd-9.zip/node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var Noise = class {
  constructor(staticNoiseKey, earlyData, crypto2 = stablelib, prologueBytes) {
    this.protocol = "/noise";
    this.earlyData = earlyData ?? new Uint8Array(0);
    this.crypto = crypto2;
    if (staticNoiseKey) {
      this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKeys = this.crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? new Uint8Array(0);
  }
  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteEarlyData: handshake2.remoteEarlyData,
      remotePeer: handshake2.remotePeer
    };
  }
  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = pbStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake2 = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake2);
    return {
      conn,
      remoteEarlyData: handshake2.remoteEarlyData,
      remotePeer: handshake2.remotePeer
    };
  }
  async performHandshake(params) {
    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
    return await this.performXXHandshake(params, payload);
  }
  async performXXHandshake(params, payload) {
    const { isInitiator, remotePeer, connection } = params;
    const handshake2 = new XXHandshake(isInitiator, payload, this.prologue, this.crypto, this.staticKeys, connection, remotePeer);
    try {
      await handshake2.propose();
      await handshake2.exchange();
      await handshake2.finish();
    } catch (e) {
      if (e instanceof Error) {
        e.message = `Error occurred during XX handshake: ${e.message}`;
        throw e;
      }
    }
    return handshake2;
  }
  async createSecureConnection(connection, handshake2) {
    const [secure, user] = duplexPair();
    const network = connection.unwrap();
    await pipe(
      secure,
      encryptStream(handshake2),
      encode({ lengthEncoder: uint16BEEncode }),
      network,
      decode2({ lengthDecoder: uint16BEDecode }),
      decryptStream(handshake2),
      secure
    );
    return user;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/libp2p.js
var mergeOptions14 = merge_options_default.bind({ ignoreUndefined: true, concatArrays: true });
function createLibp2p2({
  options = {},
  peerId,
  multiaddrs = [],
  repo,
  keychainConfig = {},
  config: config2 = {}
}) {
  const { datastore } = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config: config2,
    datastore,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === "function") {
    return options.libp2p({ libp2pOptions, options, config: config2, datastore, peerId });
  }
  return createLibp2p(libp2pOptions);
}
function getLibp2pOptions({ options, config: config2, datastore, keychainConfig, peerId, multiaddrs }) {
  const getPubsubRouter = () => {
    const router = (0, import_dlv2.default)(config2, "Pubsub.Router") || "gossipsub";
    const availableRouters = routers();
    if (!availableRouters[router]) {
      throw (0, import_err_code118.default)(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
    }
    return availableRouters[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId
  };
  const libp2pOptions = {
    addresses: {
      listen: multiaddrs.map((ma) => ma.toString()),
      announce: (0, import_dlv2.default)(options, "addresses.announce", (0, import_dlv2.default)(config2, "Addresses.Announce", [])),
      noAnnounce: (0, import_dlv2.default)(options, "addresses.noAnnounce", (0, import_dlv2.default)(config2, "Addresses.NoAnnounce", []))
    },
    connectionManager: (0, import_dlv2.default)(options, "connectionManager", {
      maxConnections: (0, import_dlv2.default)(options, "config.Swarm.ConnMgr.HighWater", (0, import_dlv2.default)(config2, "Swarm.ConnMgr.HighWater")),
      minConnections: (0, import_dlv2.default)(options, "config.Swarm.ConnMgr.LowWater", (0, import_dlv2.default)(config2, "Swarm.ConnMgr.LowWater"))
    }),
    keychain: keychainConfig,
    identify: {
      host: {
        agentVersion: `js-ipfs/${ipfsCore}`
      }
    },
    contentRouters: [],
    peerRouters: [],
    peerDiscovery: [],
    transports: [],
    streamMuxers: [
      new Mplex({
        maxInboundStreams: 256,
        maxOutboundStreams: 1024
      })
    ],
    connectionEncryption: [
      new Noise()
    ],
    relay: {
      enabled: (0, import_dlv2.default)(options, "relay.enabled", (0, import_dlv2.default)(config2, "relay.enabled", true)),
      hop: {
        enabled: (0, import_dlv2.default)(options, "relay.hop.enabled", (0, import_dlv2.default)(config2, "relay.hop.enabled", false)),
        active: (0, import_dlv2.default)(options, "relay.hop.active", (0, import_dlv2.default)(config2, "relay.hop.active", false))
      }
    },
    nat: {
      enabled: !(0, import_dlv2.default)(config2, "Swarm.DisableNatPortMap", false)
    }
  };
  if ((0, import_dlv2.default)(options, "config.Pubsub.Enabled", (0, import_dlv2.default)(config2, "Pubsub.Enabled", true))) {
    libp2pOptions.pubsub = getPubsubRouter();
  }
  if ((0, import_dlv2.default)(config2, "Routing.Type", "dhtclient") !== "none") {
    libp2pOptions.dht = new KadDHT2({
      clientMode: (0, import_dlv2.default)(config2, "Routing.Type", "dht") !== "dhtserver",
      kBucketSize: (0, import_dlv2.default)(options, "dht.kBucketSize", 20),
      validators: {
        ipns: ipnsValidator
      },
      selectors: {
        ipns: ipnsSelector
      }
    });
  }
  const boostrapNodes = (0, import_dlv2.default)(options, "config.Bootstrap", (0, import_dlv2.default)(config2, "Bootstrap", []));
  if (boostrapNodes.length > 0) {
    libp2pOptions.peerDiscovery?.push(
      new Bootstrap({
        list: boostrapNodes
      })
    );
  }
  let constructorOptions = (0, import_dlv2.default)(options, "libp2p", void 0);
  if (typeof constructorOptions === "function") {
    constructorOptions = void 0;
  }
  const libp2pFinalConfig = mergeOptions14(
    libp2pDefaults,
    libp2pConfig(),
    libp2pOptions,
    constructorOptions
  );
  const delegateHosts = (0, import_dlv2.default)(
    options,
    "config.Addresses.Delegates",
    (0, import_dlv2.default)(config2, "Addresses.Delegates", [])
  );
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
      port: delegateAddr.port
    };
    const delegateHttpClient = create4(delegateApiOptions);
    libp2pFinalConfig.contentRouters?.push(new DelegatedContentRouting(delegateHttpClient));
    libp2pFinalConfig.peerRouters?.push(new DelegatedPeerRouting(delegateHttpClient));
  }
  if (!(0, import_dlv2.default)(options, "config.Discovery.MDNS.Enabled", (0, import_dlv2.default)(config2, "Discovery.MDNS.Enabled", true))) {
    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter((d) => {
      return d != null && d[Symbol.toStringTag] !== "@libp2p/mdns";
    });
  }
  if (libp2pFinalConfig.transports == null) {
    libp2pFinalConfig.transports = [];
  }
  if (libp2pFinalConfig.transports.find((t) => t[Symbol.toStringTag] === "@libp2p/websockets") == null) {
    libp2pFinalConfig.transports.push(new WebSockets2());
  }
  return libp2pFinalConfig;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/storage.js
var import_err_code119 = __toESM(require_err_code(), 1);
var mergeOptions15 = merge_options_default.bind({ ignoreUndefined: true });
var log99 = logger("ipfs:components:peer:storage");
var Storage = class {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs2, options) {
    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options;
    const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo2(print, codecs2, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress
    }) : inputRepo;
    const { peerId, keychain, isNew } = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
};
var loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return { ...await configureRepo(repo, options), isNew: false };
  }
  try {
    await repo.open();
    return { ...await configureRepo(repo, options), isNew: false };
  } catch (err2) {
    if (err2.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err2;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
    }
    return { ...await initRepo(print, repo, options), isNew: true };
  }
};
var initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists2 = await repo.exists();
  log99("repo exists?", exists2);
  if (exists2 === true) {
    throw new Error("repo already exists");
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity2 = peerIdToIdentity(peerId);
  log99("peer identity: %s", identity2.PeerID);
  const config2 = {
    ...mergeOptions15(applyProfiles(config_browser_default(), initOptions.profiles), options.config),
    Identity: identity2
  };
  await repo.init(config2);
  await repo.open();
  log99("repo opened");
  const keychainConfig = {
    pass: options.pass
  };
  try {
    keychainConfig.dek = await repo.config.get("Keychain.DEK");
  } catch (err2) {
    if (err2.code !== "ERR_NOT_FOUND") {
      throw err2;
    }
  }
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: config2,
    keychainConfig
  });
  if (!await repo.datastore.has(new Key("/info/self"))) {
    await libp2p.keychain.importPeer("self", peerId);
  }
  await repo.config.set("Keychain", {
    DEK: libp2p.keychain.init.dek
  });
  return { peerId, keychain: libp2p.keychain };
};
var decodePeerId = async (peerId) => {
  log99("using user-supplied private-key");
  if (isPeerId(peerId)) {
    return peerId;
  }
  const rawPrivateKey = fromString(peerId, "base64pad");
  const key = await unmarshalPrivateKey(rawPrivateKey);
  return await peerIdFromKeys(key.public.bytes, key.bytes);
};
var initPeerId = (print, { algorithm = "Ed25519", bits = 2048 }) => {
  print("generating %s keypair...", algorithm);
  if (algorithm === "Ed25519") {
    return createEd25519PeerId();
  }
  if (algorithm === "RSA") {
    return createRSAPeerId({ bits });
  }
  throw (0, import_err_code119.default)(new Error("Unknown PeerId algorithm"), "ERR_UNKNOWN_PEER_ID_ALGORITHM");
};
var peerIdToIdentity = (peerId) => {
  if (peerId.privateKey == null) {
    throw (0, import_err_code119.default)(new Error("Private key missing"), "ERR_MISSING_PRIVATE_KEY");
  }
  return {
    PeerID: peerId.toString(),
    PrivKey: toString(peerId.privateKey, "base64pad")
  };
};
var configureRepo = async (repo, options) => {
  const config2 = options.config;
  const profiles2 = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError("No private key was found in the config, please intialize the repo");
  }
  const buf2 = fromString(changed.Identity.PrivKey, "base64pad");
  const key = await unmarshalPrivateKey(buf2);
  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);
  const libp2p = await createLibp2p2({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  return { peerId, keychain: libp2p.keychain };
};
var mergeConfigs = (config2, changes) => changes ? mergeOptions15(config2, changes) : config2;
var applyProfiles = (config2, profiles2) => {
  return (profiles2 || []).reduce((config3, name6) => {
    const profile = profiles[name6];
    if (!profile) {
      throw new Error(`Could not find profile with name '${name6}'`);
    }
    log99("applying profile %s", name6);
    return profile.transform(config3);
  }, config2);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/network.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/bitswap.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/want-manager/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/message/index.js
init_define_process();
var import_varint_decoder = __toESM(require_src4(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/utils/varint-encoder.js
init_define_process();
var varint6 = __toESM(require_varint(), 1);
function varintEncoder(buf2) {
  let out = new Uint8Array(buf2.reduce((acc, curr) => {
    return acc + varint6.default.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf2) {
    out = varint6.encode(num, out, offset);
    offset += varint6.default.encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/utils/index.js
init_define_process();
var import_debug11 = __toESM(require_debug(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/message/entry.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/wantlist/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/wantlist/entry.js
init_define_process();
var WantListEntry = class {
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority || 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/message/message.js
init_define_process();
var import_minimal9 = __toESM(require_minimal(), 1);
var $Reader8 = import_minimal9.default.Reader;
var $Writer8 = import_minimal9.default.Writer;
var $util8 = import_minimal9.default.util;
var $root8 = import_minimal9.default.roots["ipfs-bitswap"] || (import_minimal9.default.roots["ipfs-bitswap"] = {});
var Message3 = $root8.Message = (() => {
  function Message4(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Message4.prototype.wantlist = null;
  Message4.prototype.blocks = $util8.emptyArray;
  Message4.prototype.payload = $util8.emptyArray;
  Message4.prototype.blockPresences = $util8.emptyArray;
  Message4.prototype.pendingBytes = 0;
  Message4.encode = function encode15(m, w) {
    if (!w)
      w = $Writer8.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
      $root8.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i = 0; i < m.blocks.length; ++i)
        w.uint32(18).bytes(m.blocks[i]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i = 0; i < m.payload.length; ++i)
        $root8.Message.Block.encode(m.payload[i], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i = 0; i < m.blockPresences.length; ++i)
        $root8.Message.BlockPresence.encode(m.blockPresences[i], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message4.decode = function decode13(r, l) {
    if (!(r instanceof $Reader8))
      r = $Reader8.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1: {
          m.wantlist = $root8.Message.Wantlist.decode(r, r.uint32());
          break;
        }
        case 2: {
          if (!(m.blocks && m.blocks.length))
            m.blocks = [];
          m.blocks.push(r.bytes());
          break;
        }
        case 3: {
          if (!(m.payload && m.payload.length))
            m.payload = [];
          m.payload.push($root8.Message.Block.decode(r, r.uint32()));
          break;
        }
        case 4: {
          if (!(m.blockPresences && m.blockPresences.length))
            m.blockPresences = [];
          m.blockPresences.push($root8.Message.BlockPresence.decode(r, r.uint32()));
          break;
        }
        case 5: {
          m.pendingBytes = r.int32();
          break;
        }
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Message4.fromObject = function fromObject(d) {
    if (d instanceof $root8.Message)
      return d;
    var m = new $root8.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== "object")
        throw TypeError(".Message.wantlist: object expected");
      m.wantlist = $root8.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError(".Message.blocks: array expected");
      m.blocks = [];
      for (var i = 0; i < d.blocks.length; ++i) {
        if (typeof d.blocks[i] === "string")
          $util8.base64.decode(d.blocks[i], m.blocks[i] = $util8.newBuffer($util8.base64.length(d.blocks[i])), 0);
        else if (d.blocks[i].length >= 0)
          m.blocks[i] = d.blocks[i];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError(".Message.payload: array expected");
      m.payload = [];
      for (var i = 0; i < d.payload.length; ++i) {
        if (typeof d.payload[i] !== "object")
          throw TypeError(".Message.payload: object expected");
        m.payload[i] = $root8.Message.Block.fromObject(d.payload[i]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError(".Message.blockPresences: array expected");
      m.blockPresences = [];
      for (var i = 0; i < d.blockPresences.length; ++i) {
        if (typeof d.blockPresences[i] !== "object")
          throw TypeError(".Message.blockPresences: object expected");
        m.blockPresences[i] = $root8.Message.BlockPresence.fromObject(d.blockPresences[i]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
      d.wantlist = $root8.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util8.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root8.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root8.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
  };
  Message4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
    if (typeUrlPrefix === void 0) {
      typeUrlPrefix = "type.googleapis.com";
    }
    return typeUrlPrefix + "/Message";
  };
  Message4.Wantlist = function() {
    function Wantlist2(p) {
      this.entries = [];
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Wantlist2.prototype.entries = $util8.emptyArray;
    Wantlist2.prototype.full = false;
    Wantlist2.encode = function encode15(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.entries != null && m.entries.length) {
        for (var i = 0; i < m.entries.length; ++i)
          $root8.Message.Wantlist.Entry.encode(m.entries[i], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, "full"))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist2.decode = function decode13(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            if (!(m.entries && m.entries.length))
              m.entries = [];
            m.entries.push($root8.Message.Wantlist.Entry.decode(r, r.uint32()));
            break;
          }
          case 2: {
            m.full = r.bool();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Wantlist2.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Wantlist)
        return d;
      var m = new $root8.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError(".Message.Wantlist.entries: array expected");
        m.entries = [];
        for (var i = 0; i < d.entries.length; ++i) {
          if (typeof d.entries[i] !== "object")
            throw TypeError(".Message.Wantlist.entries: object expected");
          m.entries[i] = $root8.Message.Wantlist.Entry.fromObject(d.entries[i]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root8.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty("full")) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
    };
    Wantlist2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Wantlist";
    };
    Wantlist2.WantType = function() {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Block"] = 0;
      values[valuesById[1] = "Have"] = 1;
      return values;
    }();
    Wantlist2.Entry = function() {
      function Entry(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Entry.prototype.block = $util8.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode15(m, w) {
        if (!w)
          w = $Writer8.create();
        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode13(r, l) {
        if (!(r instanceof $Reader8))
          r = $Reader8.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1: {
              m.block = r.bytes();
              break;
            }
            case 2: {
              m.priority = r.int32();
              break;
            }
            case 3: {
              m.cancel = r.bool();
              break;
            }
            case 4: {
              m.wantType = r.int32();
              break;
            }
            case 5: {
              m.sendDontHave = r.bool();
              break;
            }
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root8.Message.Wantlist.Entry)
          return d;
        var m = new $root8.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === "string")
            $util8.base64.decode(d.block, m.block = $util8.newBuffer($util8.base64.length(d.block)), 0);
          else if (d.block.length >= 0)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
          case "Block":
          case 0:
            m.wantType = 0;
            break;
          case "Have":
          case 1:
            m.wantType = 1;
            break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = "";
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util8.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? "Block" : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty("block")) {
          d.block = o.bytes === String ? $util8.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty("priority")) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty("cancel")) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty("wantType")) {
          d.wantType = o.enums === String ? $root8.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
      };
      Entry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === void 0) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Message.Wantlist.Entry";
      };
      return Entry;
    }();
    return Wantlist2;
  }();
  Message4.Block = function() {
    function Block2(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Block2.prototype.prefix = $util8.newBuffer([]);
    Block2.prototype.data = $util8.newBuffer([]);
    Block2.encode = function encode15(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, "data"))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block2.decode = function decode13(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.prefix = r.bytes();
            break;
          }
          case 2: {
            m.data = r.bytes();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Block2.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.Block)
        return d;
      var m = new $root8.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === "string")
          $util8.base64.decode(d.prefix, m.prefix = $util8.newBuffer($util8.base64.length(d.prefix)), 0);
        else if (d.prefix.length >= 0)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === "string")
          $util8.base64.decode(d.data, m.data = $util8.newBuffer($util8.base64.length(d.data)), 0);
        else if (d.data.length >= 0)
          m.data = d.data;
      }
      return m;
    };
    Block2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = "";
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util8.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = "";
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util8.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty("prefix")) {
        d.prefix = o.bytes === String ? $util8.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty("data")) {
        d.data = o.bytes === String ? $util8.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
    };
    Block2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.Block";
    };
    return Block2;
  }();
  Message4.BlockPresenceType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Have"] = 0;
    values[valuesById[1] = "DontHave"] = 1;
    return values;
  }();
  Message4.BlockPresence = function() {
    function BlockPresence(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    BlockPresence.prototype.cid = $util8.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode15(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, "type"))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode13(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1: {
            m.cid = r.bytes();
            break;
          }
          case 2: {
            m.type = r.int32();
            break;
          }
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root8.Message.BlockPresence)
        return d;
      var m = new $root8.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === "string")
          $util8.base64.decode(d.cid, m.cid = $util8.newBuffer($util8.base64.length(d.cid)), 0);
        else if (d.cid.length >= 0)
          m.cid = d.cid;
      }
      switch (d.type) {
        case "Have":
        case 0:
          m.type = 0;
          break;
        case "DontHave":
        case 1:
          m.type = 1;
          break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = "";
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util8.newBuffer(d.cid);
        }
        d.type = o.enums === String ? "Have" : 0;
      }
      if (m.cid != null && m.hasOwnProperty("cid")) {
        d.cid = o.bytes === String ? $util8.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty("type")) {
        d.type = o.enums === String ? $root8.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal9.default.util.toJSONOptions);
    };
    BlockPresence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Message.BlockPresence";
    };
    return BlockPresence;
  }();
  return Message4;
})();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/wantlist/index.js
var WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
var sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a);
    const bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
};
var Wantlist = class {
  constructor(stats, libp2p) {
    this.set = libp2p ? trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (entry) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType.Have && wantType === WantType.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats) {
        this._stats.push(null, "wantListSize", 1);
      }
    }
  }
  remove(cid) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (!entry) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats) {
      this._stats.push(null, "wantListSize", -1);
    }
  }
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  forEach(fn) {
    return this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  contains(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.has(cidStr);
  }
  get(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.get(cidStr);
  }
};
Wantlist.Entry = WantListEntry;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/message/entry.js
var WantlistEntry = Wantlist.Entry;
var BitswapMessageEntry = class {
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantlistEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/utils/index.js
var logger2 = (id, subsystem) => {
  const name6 = ["bitswap"];
  if (subsystem) {
    name6.push(subsystem);
  }
  if (id) {
    name6.push(`${id.toString().slice(0, 8)}`);
  }
  return Object.assign((0, import_debug11.default)(name6.join(":")), {
    error: (0, import_debug11.default)(name6.concat(["error"]).join(":"))
  });
};
var isMapEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/message/index.js
var import_err_code120 = __toESM(require_err_code(), 1);
var BitswapMessage = class {
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc);
    const entry = this.wantlist.get(cidStr);
    if (entry) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58btc);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : void 0
      },
      blocks: Array.from(this.blocks.values())
    };
    return Message3.encode(msg).finish();
  }
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : void 0
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID.parse(cidStr);
      const version3 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varint_encoder_default([
        version3,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(
        new Message3.Block({
          prefix,
          data
        })
      );
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new Message3.BlockPresence({
        cid: CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message3.encode(msg).finish();
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
};
BitswapMessage.deserialize = async (raw, hashLoader) => {
  const decoded = Message3.decode(raw);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach((entry) => {
      if (!entry.block) {
        return;
      }
      const cid = CID.decode(entry.block);
      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach((blockPresence) => {
      if (!blockPresence.cid) {
        return;
      }
      const cid = CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async (b) => {
      const hash3 = await sha256.digest(b);
      const cid = CID.createV0(hash3);
      msg.addBlock(cid, b);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async (p) => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values = (0, import_varint_decoder.default)(p.prefix);
      const cidVersion = values[0];
      const multicodec = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw (0, import_err_code120.default)(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
      }
      const hash3 = await hasher.digest(p.data);
      const cid = CID.create(cidVersion, multicodec, hash3);
      msg.addBlock(cid, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = (cid) => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: Message3.Wantlist.WantType.Block,
  Have: Message3.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: Message3.BlockPresenceType.Have,
  DontHave: Message3.BlockPresenceType.DontHave
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/constants.js
init_define_process();
var SECOND = 1e3;
var maxProvidersPerRequest = 3;
var providerRequestTimeout = 10 * SECOND;
var hasBlockTimeout = 15 * SECOND;
var provideTimeout = 15 * SECOND;
var kMaxPriority = Math.pow(2, 31) - 1;
var maxListeners = 1e3;
var wantlistSendDebounceMs = 1;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/just-debounce-it-npm-3.1.1-896695133b-9.zip/node_modules/just-debounce-it/index.mjs
init_define_process();
var functionDebounce = debounce2;
function debounce2(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush3 = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush3;
  return debounceWrapper;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/want-manager/msg-queue.js
var MsgQueue = class {
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger2(selfPeerId, "msgqueue");
    this.sendEntries = functionDebounce(this._sendEntries.bind(this), wantlistSendDebounceMs);
  }
  addMessage(msg) {
    if (msg.empty) {
      return;
    }
    this.send(msg);
  }
  addEntries(entries) {
    this._entries = this._entries.concat(entries);
    this.sendEntries();
  }
  _sendEntries() {
    if (!this._entries.length) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg);
  }
  async send(msg) {
    try {
      await this.network.connectTo(this.peerId);
    } catch (err2) {
      this._log.error("cant connect to peer %s: %s", this.peerId.toString(), err2.message);
      return;
    }
    this._log("sending message to peer %s", this.peerId.toString());
    this.network.sendMessage(this.peerId, msg).catch((err2) => {
      this._log.error("send error: %s", err2.message);
    });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/want-manager/index.js
var WantManager = class {
  constructor(peerId, network, stats, libp2p) {
    this.peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "want-manager-peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._stats = stats;
    this._peerId = peerId;
    this._log = logger2(peerId, "want");
  }
  _addEntries(cids, cancel, force) {
    const entries = cids.map((cid, i) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i, BitswapMessage.WantType.Block, cancel);
    });
    entries.forEach((e) => {
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid.toString(base58btc));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wl");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries);
    }
  }
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toString());
    if (mq) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toString(), mq);
    return mq;
  }
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toString());
    if (!mq) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toString());
  }
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false);
    if (options && options.signal) {
      options.signal.addEventListener("abort", () => {
        this.cancelWants(cids);
      });
    }
  }
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => this.disconnected(mq.peerId));
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/network.js
init_define_process();
var import_timeout_abort_controller18 = __toESM(require_timeout_abort_controller(), 1);
var BITSWAP100 = "/ipfs/bitswap/1.0.0";
var BITSWAP110 = "/ipfs/bitswap/1.1.0";
var BITSWAP120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS3 = 128;
var DEFAULT_INCOMING_STREAM_TIMEOUT = 3e4;
var Network2 = class {
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger2(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection, {
      maxInboundStreams: this._maxInboundStreams,
      maxOutboundStreams: this._maxOutboundStreams
    });
    const topology = createTopology({
      onConnect: this._onPeerConnect,
      onDisconnect: this._onPeerDisconnect
    });
    this._registrarIds = [];
    for (const protocol of this._protocols) {
      this._registrarIds.push(await this._libp2p.registrar.register(protocol, topology));
    }
    this._libp2p.getConnections().forEach((conn) => {
      this._onPeerConnect(conn.remotePeer);
    });
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarIds != null) {
      for (const id of this._registrarIds) {
        this._libp2p.registrar.unregister(id);
      }
      this._registrarIds = [];
    }
  }
  _onConnection({ stream, connection }) {
    if (!this._running) {
      return;
    }
    const controller = new import_timeout_abort_controller18.TimeoutController(this._incomingStreamTimeout);
    Promise.resolve().then(async () => {
      this._log("incoming new bitswap %s connection from %p", stream.stat.protocol, connection.remotePeer);
      await pipe(
        abortableSource(stream.source, controller.signal),
        decode2(),
        async (source) => {
          for await (const data of source) {
            try {
              const message2 = await BitswapMessage.deserialize(data.subarray(), this._hashLoader);
              await this._bitswap._receiveMessage(connection.remotePeer, message2);
            } catch (err2) {
              this._bitswap._receiveError(err2);
              break;
            }
            controller.reset();
          }
        }
      );
    }).catch((err2) => {
      this._log(err2);
      stream.abort(err2);
    }).finally(() => {
      controller.clear();
      stream.close();
    });
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  findProviders(cid, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, options);
  }
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    let found = 0;
    for await (const provider of this.findProviders(cid, options)) {
      this._log(`connecting to provider ${provider.id}`);
      connectAttempts.push(
        this.connectTo(provider.id, options).catch((err2) => {
          this._log.error(err2);
        })
      );
      found++;
      if (found === maxProvidersPerRequest) {
        break;
      }
    }
    await Promise.all(connectAttempts);
  }
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toString();
    this._log("sendMessage to %s", stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);
    await writeMessage(stream, msg, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toString();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
};
async function writeMessage(stream, msg, log101) {
  try {
    let serialized;
    switch (stream.stat.protocol) {
      case BITSWAP100:
        serialized = msg.serializeToBitswap100();
        break;
      case BITSWAP110:
      case BITSWAP120:
        serialized = msg.serializeToBitswap110();
        break;
      default:
        throw new Error("Unknown protocol: " + stream.stat.protocol);
    }
    await pipe(
      [serialized],
      encode(),
      stream
    );
  } catch (err2) {
    log101(err2);
  } finally {
    stream.close();
  }
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/ledger.js
init_define_process();
var Ledger = class {
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.sentToPeer = /* @__PURE__ */ new Map();
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesRecv += n;
  }
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/req-queue.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/utils/sorted-map.js
init_define_process();
var SortedMap = class extends Map {
  constructor(entries, cmp) {
    super();
    this._cmp = cmp || this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries || []) {
      this.set(k, v);
    }
  }
  update(i) {
    if (i < 0 || i >= this._keys.length) {
      return;
    }
    const k = this._keys[i];
    this._keys.splice(i, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  set(k, v) {
    if (this.has(k)) {
      const i2 = this.indexOf(k);
      this._keys.splice(i2, 1);
    }
    super.set(k, v);
    const i = this._find(k);
    this._keys.splice(i, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i = this.indexOf(k);
    this._keys.splice(i, 1);
    return super.delete(k);
  }
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i = this._find(k);
    if (this._keys[i] === k) {
      return i;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i + j] === k)
        return i + j;
      if (this._keys[i - j] === k)
        return i - j;
    }
    return -1;
  }
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  *entries() {
    for (const k of this._keys) {
      yield [k, this.get(k)];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  forEach(cb, thisArg) {
    if (!cb) {
      return;
    }
    for (const k of this._keys) {
      cb.apply(thisArg, [[k, this.get(k)]]);
    }
  }
  _defaultSort(a, b) {
    if (a[0] < b[0])
      return -1;
    if (b[0] < a[0])
      return 1;
    return 0;
  }
  _kCmp(a, b) {
    return this._cmp(
      [a, this.get(a)],
      [b, this.get(b)]
    );
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/req-queue.js
var DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
var RequestQueue = class {
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toString(), peerTasks);
  }
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return { tasks: [], pendingSize: 0 };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return { tasks, pendingSize };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toString());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toString());
    peerTasks && peerTasks.remove(topic);
  }
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toString());
    if (!peerTasks) {
      return;
    }
    const i = this._byPeer.indexOf(peerId.toString());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i);
  }
};
var PeerTasks = class {
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  popTasks(targetMinBytes) {
    let size = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {
      const task = pendingTasks[i];
      tasks.push(task);
      size += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  remove(topic) {
    this._pending.delete(topic);
  }
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  static compare(a, b) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
      return b[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b[1]._activeTotalSize;
  }
};
var PendingTasks = class {
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  get(topic) {
    return (this._tasks.get(topic) || {}).task;
  }
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  delete(topic) {
    this._tasks.delete(topic);
  }
  tasks() {
    return [...this._tasks.values()].map((i) => i.task);
  }
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (!obj) {
      return;
    }
    const i = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i);
  }
  _compare(a, b) {
    if (a[1].task.priority === b[1].task.priority) {
      return a[1].created - b[1].created;
    }
    return b[1].task.priority - a[1].task.priority;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/task-merger.js
init_define_process();
var TaskMerger = {
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/decision-engine/index.js
var WantType2 = BitswapMessage.WantType;
var TARGET_MESSAGE_SIZE = 16 * 1024;
var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DecisionEngine = class {
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger2(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "ledger-map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(TaskMerger);
  }
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks();
    });
  }
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID.parse(topic);
      const blk = blocks.get(topic);
      if (blk) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId && this.messageSent(peerId, CID.parse(cidStr), block);
      }
    } catch (err2) {
      this._log.error(err2);
    }
    peerId && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (!ledger) {
      return null;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  receivedBlocks(blocks) {
    if (!blocks.length) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const block of blocks) {
        const want = ledger.wantlistContains(block.cid);
        if (!want) {
          continue;
        }
        const blockSize = block.data.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc), peerId);
    }
  }
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType2.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [k, v.length]));
  }
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc), block);
      } catch (e) {
        if (e.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, e);
        }
      }
    }));
    return res;
  }
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toString());
  }
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toString();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/notifications.js
init_define_process();
var import_events41 = __toESM(require_events(), 1);
var unwantEvent = (cid) => `unwant:${toString(cid.multihash.bytes, "base64")}`;
var blockEvent = (cid) => `block:${toString(cid.multihash.bytes, "base64")}`;
var Notifications = class extends import_events41.EventEmitter {
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger2(peerId, "notif");
  }
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  wantBlock(cid, options = {}) {
    if (!cid) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve7, reject) => {
      const onUnwant = () => {
        this.removeListener(blockEvt, onBlock);
        reject(new Error(`Block for ${cid} unwanted`));
      };
      const onBlock = (data) => {
        this.removeListener(unwantEvt, onUnwant);
        resolve7(data);
      };
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.removeListener(blockEvt, onBlock);
          this.removeListener(unwantEvt, onUnwant);
          reject(new Error(`Want for ${cid} aborted`));
        });
      }
    });
  }
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/stats/index.js
init_define_process();
var import_events43 = __toESM(require_events(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/stats/stat.js
init_define_process();
var import_events42 = __toESM(require_events(), 1);
var import_moving_average2 = __toESM(require_moving_average(), 1);
var Stat = class extends import_events42.EventEmitter {
  constructor(initialCounters2, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters2.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = (0, import_moving_average2.default)(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._disabled = true;
  }
  stop() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  push(counter, inc) {
    if (this._enabled) {
      this._queue.push([counter, inc, Date.now()]);
      this._resetComputeTimeout();
    }
  }
  _resetComputeTimeout() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  _update() {
    this._timeout = null;
    if (this._queue.length) {
      let last14;
      while (this._queue.length) {
        const op = last14 = this._queue.shift();
        op && this._applyOp(op);
      }
      last14 && this._updateFrequency(last14[2]);
      this.emit("update", this._stats);
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval];
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average2.default)(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    });
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/stats/index.js
var defaultOptions19 = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ]
};
var Stats = class extends import_events43.EventEmitter {
  constructor(libp2p, initialCounters2 = [], _options = defaultOptions19) {
    super();
    const options = Object.assign({}, defaultOptions19, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters2;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters2, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = trackedMap({
      system: "ipfs",
      component: "bitswap",
      metric: "stats-peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  forPeer(peerId) {
    const peerIdStr = typeof peerId !== "string" && peerId.toString ? peerId.toString() : `${peerId}`;
    return this._peers.get(peerIdStr);
  }
  push(peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc);
      if (peer) {
        let peerStats = this._peers.get(peer);
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter, inc);
      }
    }
  }
  disconnected(peer) {
    const peerId = peer.toString();
    const peerStats = this._peers.get(peerId);
    if (peerStats) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/bitswap.js
var import_any_signal13 = __toESM(require_any_signal(), 1);
var defaultOptions20 = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
var statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
var Bitswap = class extends BaseBlockstore {
  constructor(libp2p, blockstore, options = {}) {
    super();
    this._libp2p = libp2p;
    this._log = logger2(this.peerId);
    this._options = Object.assign({}, defaultOptions20, options);
    this._stats = new Stats(libp2p, statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network2(libp2p, this, this._stats, {
      hashLoader: options.hashLoader,
      maxInboundStreams: options.maxInboundStreams,
      maxOutboundStreams: options.maxOutboundStreams,
      incomingStreamTimeout: options.incomingStreamTimeout
    });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  get peerId() {
    return this._libp2p.peerId;
  }
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err2) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(
      received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid)
    );
    await Promise.all(
      received.map(
        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)
      )
    );
  }
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toString(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  _updateReceiveCounters(peerIdStr, cid, data, exists2) {
    this._stats.push(peerIdStr, "blocksReceived", 1);
    this._stats.push(peerIdStr, "dataReceived", data.length);
    if (exists2) {
      this._stats.push(peerIdStr, "dupBlksReceived", 1);
      this._stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  _receiveError(err2) {
    this._log.error("ReceiveError: %s", err2.message);
  }
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this._stats.disconnected(peerId);
  }
  enableStats() {
    this._stats.enable();
  }
  disableStats() {
    this._stats.disable();
  }
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  async get(cid, options = {}) {
    const fetchFromNetwork = (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    };
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = async (cid2, options2) => {
      try {
        const block = await this.blockstore.get(cid2, options2);
        return block;
      } catch (err2) {
        if (err2.code !== "ERR_NOT_FOUND") {
          throw err2;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2, options2).catch((err3) => this._log.error(err3));
        }
        return fetchFromNetwork(cid2, options2);
      }
    };
    const controller = new AbortController();
    const signal = options.signal ? (0, import_any_signal13.anySignal)([options.signal, controller.signal]) : controller.signal;
    try {
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          signal
        })
      ]);
      return block;
    } finally {
      controller.abort();
    }
  }
  async *getMany(cids, options = {}) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
  }
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this._sendHaveBlockNotifications(cid, block);
  }
  async *putMany(source, options) {
    for await (const { key, value } of this.blockstore.putMany(source, options)) {
      this._sendHaveBlockNotifications(key, value);
      yield { key, value };
    }
  }
  _sendHaveBlockNotifications(cid, data) {
    this.notifications.hasBlock(cid, data);
    this.engine.receivedBlocks([{ cid, data }]);
    this.network.provide(cid).catch((err2) => {
      this._log.error("Failed to provide: %s", err2.message);
    });
  }
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  peers() {
    return this.engine.peers();
  }
  stat() {
    return this._stats;
  }
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  async stop() {
    this._stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
  unwrap() {
    return this.blockstore;
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-bitswap-npm-12.0.6-aae4a6477d-9.zip/node_modules/ipfs-bitswap/src/index.js
var createBitswap2 = (libp2p, blockstore, options = {}) => {
  return new Bitswap(libp2p, blockstore, options);
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/network.js
var import_err_code122 = __toESM(require_err_code(), 1);

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/block-storage.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/blockstore-core-npm-2.0.1-ea08d5c728-9.zip/node_modules/blockstore-core/src/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/blockstore-core-npm-2.0.1-ea08d5c728-9.zip/node_modules/blockstore-core/src/errors.js
var errors_exports5 = {};
__export(errors_exports5, {
  abortedError: () => abortedError2,
  notFoundError: () => notFoundError2
});
init_define_process();
var import_err_code121 = __toESM(require_err_code(), 1);
function notFoundError2(err2) {
  err2 = err2 || new Error("Not Found");
  return (0, import_err_code121.default)(err2, "ERR_NOT_FOUND");
}
function abortedError2(err2) {
  err2 = err2 || new Error("Aborted");
  return (0, import_err_code121.default)(err2, "ERR_ABORTED");
}

// ../../../../../Users/z/.yarn/berry/cache/blockstore-core-npm-2.0.1-ea08d5c728-9.zip/node_modules/blockstore-core/src/memory.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/blockstore-core-npm-2.0.1-ea08d5c728-9.zip/node_modules/blockstore-core/src/index.js
var Errors = {
  ...errors_exports5
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/block-storage.js
var import_it_merge7 = __toESM(require_it_merge(), 1);
var import_it_filter13 = __toESM(require_it_filter(), 1);
var BlockStorage = class extends BaseBlockstore {
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  async *putMany(blocks, options = {}) {
    const missingBlocks = (0, import_it_filter13.default)(blocks, async ({ key }) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  async *getMany(cids, options = {}) {
    const getFromBitswap = pushable({ objectMode: true });
    const getFromChild = pushable({ objectMode: true });
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* (0, import_it_merge7.default)(
      this.bitswap.getMany(getFromBitswap, options),
      this.child.getMany(getFromChild, options)
    );
  }
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/network.js
var Network3 = class {
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  static async start({ peerId, repo, print, hashers, options }) {
    if (repo.closed) {
      await repo.open();
    }
    const config2 = await repo.config.getAll();
    const libp2p = await createLibp2p2({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config2),
      config: config2,
      keychainConfig: void 0
    });
    await libp2p.start();
    for (const ma of libp2p.getMultiaddrs()) {
      print(`Swarm listening on ${ma.toString()}`);
    }
    const bitswap = createBitswap2(libp2p, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers,
      maxInboundStreams: 1024,
      maxOutboundStreams: 1024
    });
    await bitswap.start();
    const blockstore = new BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network3(peerId, libp2p, bitswap, repo, blockstore);
  }
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await network.bitswap.stop();
    await network.libp2p.stop();
  }
};
var readAddrs = (peerId, config2) => {
  const peerIdStr = peerId.toString();
  const addrs = [];
  const swarm = config2.Addresses && config2.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw (0, import_err_code122.default)(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${peerIdStr}`);
    }
    addrs.push(ma);
  }
  return addrs;
};
var WEBSOCKET_STAR_PROTO_CODE = 479;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/index.js
init_define_process();

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/addrs.js
init_define_process();
function createAddrs2({ network }) {
  async function addrs(options = {}) {
    const peers = [];
    const { libp2p } = await network.use(options);
    await libp2p.peerStore.forEach((peer) => {
      peers.push({
        id: peer.id,
        addrs: peer.addresses.map((mi) => mi.multiaddr)
      });
    });
    return peers;
  }
  return withTimeoutOption(addrs);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/connect.js
init_define_process();
function createConnect2({ network }) {
  async function connect2(multiaddrOrPeerId, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.dial(multiaddrOrPeerId, options);
  }
  return withTimeoutOption(connect2);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/disconnect.js
init_define_process();
function createDisconnect2({ network }) {
  async function disconnect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.hangUp(addr);
  }
  return withTimeoutOption(disconnect);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/local-addrs.js
init_define_process();
function createLocalAddrs2({ network }) {
  async function localAddrs(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.getMultiaddrs();
  }
  return withTimeoutOption(localAddrs);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/peers.js
init_define_process();
function createPeers3({ network }) {
  async function peers(options = {}) {
    const { libp2p } = await network.use(options);
    if (options.verbose) {
      const peers3 = [];
      for (const connection of libp2p.getConnections()) {
        const peer = {
          addr: connection.remoteAddr,
          peer: connection.remotePeer
        };
        if (options.verbose || options.direction) {
          peer.direction = connection.stat.direction;
        }
        if (options.verbose) {
          peer.muxer = connection.stat.multiplexer;
          peer.latency = "n/a";
          peer.streams = [];
        }
        peers3.push(peer);
      }
      return peers3;
    }
    const peers2 = /* @__PURE__ */ new Map();
    for (const connection of libp2p.getConnections()) {
      const peer = {
        addr: connection.remoteAddr,
        peer: connection.remotePeer
      };
      peers2.set(connection.remotePeer.toString(), peer);
    }
    return Array.from(peers2.values());
  }
  return withTimeoutOption(peers);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/swarm/index.js
var SwarmAPI = class {
  constructor({ network }) {
    this.addrs = createAddrs2({ network });
    this.connect = createConnect2({ network });
    this.disconnect = createDisconnect2({ network });
    this.localAddrs = createLocalAddrs2({ network });
    this.peers = createPeers3({ network });
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/ping.js
init_define_process();
var basePacket = { success: true, time: 0, text: "" };
function createPing2({ network }) {
  async function* ping(peerId, options = {}) {
    const { libp2p } = await network.use();
    options.count = options.count || 10;
    const storedPeer = await libp2p.peerStore.get(peerId);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield { ...basePacket, text: `Looking up peer ${peerId}` };
      const remotePeer = await libp2p.peerRouting.findPeer(peerId);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error("Peer was not found");
    }
    yield { ...basePacket, text: `PING ${id.toString()}` };
    let packetCount = 0;
    let totalTime = 0;
    for (let i = 0; i < options.count; i++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield { ...basePacket, time };
      } catch (err2) {
        yield { ...basePacket, success: false, text: err2.toString() };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield { ...basePacket, text: `Average latency: ${average}ms` };
    }
  }
  return withTimeoutOption(ping);
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/dht.js
init_define_process();
var import_err_code123 = __toESM(require_err_code(), 1);
init_concat();
var IPNS_PREFIX2 = "/ipns/";
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX2)) {
    str = str.substring(IPNS_PREFIX2.length);
  }
  let buf2;
  if (str[0] === "1" || str[0] === "Q") {
    str = `z${str}`;
  }
  if (str[0] === "z") {
    buf2 = base58btc.decode(str);
  }
  if (str[0] === "k") {
    buf2 = base36.decode(str);
  }
  if (!buf2) {
    throw new Error("Could not parse string");
  }
  if (buf2[0] !== 1 && buf2[1] !== 114) {
    buf2 = concat([
      [1, 114],
      buf2
    ]);
  }
  if (buf2.length !== 40) {
    throw new Error("Incorrect length " + buf2.length);
  }
  return concat([
    fromString(IPNS_PREFIX2),
    buf2.subarray(2)
  ]);
}
function createDht2({ network, repo, peerId }) {
  const { get: get6, put, findProvs, findPeer: findPeer2, provide, query } = {
    async *get(key, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.get(dhtKey, options);
    },
    async *put(key, value, options) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.put(dhtKey, value, options);
    },
    async *findProvs(cid, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findProviders(cid, {
        signal: options.signal
      });
    },
    async *findPeer(peerIdToFind, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.findPeer(peerIdToFind, {
        signal: options.signal
      });
    },
    async *provide(cid, options = { recursive: false }) {
      const { libp2p } = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw (0, import_err_code123.default)(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
      }
      if (options.recursive) {
        throw (0, import_err_code123.default)(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.provide(cid);
    },
    async *query(peerIdToQuery, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      let bytes2;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes2 = asCid.multihash.bytes;
      } else {
        bytes2 = peerIdFromString(peerIdToQuery.toString()).toBytes();
      }
      if (libp2p.dht == null) {
        throw (0, import_err_code123.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
      }
      yield* libp2p.dht.getClosestPeers(bytes2, options);
    }
  };
  return {
    get: withTimeoutOption(get6),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer2),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
var use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (net.libp2p.dht != null) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: "QUERY_ERROR",
        type: 3,
        error: new NotEnabledError("dht not enabled")
      };
    };
    return {
      libp2p: {
        dht: {
          get: fn,
          put: fn,
          findProviders: fn,
          findPeer: fn,
          provide: fn,
          getClosestPeers: fn
        }
      }
    };
  }
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/pubsub.js
init_define_process();
var import_err_code124 = __toESM(require_err_code(), 1);
var import_dlv3 = __toESM(require_dlv_umd(), 1);
function createPubsub3({ network, config: config2 }) {
  const isEnabled = (0, import_dlv3.default)(config2 || {}, "Pubsub.Enabled", true);
  const handlers = {};
  let onMessage;
  return {
    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,
    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
    peers: isEnabled ? withTimeoutOption(peers) : notEnabled
  };
  async function subscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    libp2p.pubsub.subscribe(topic);
    if (onMessage == null) {
      onMessage = (evt) => {
        const msg = evt.detail;
        if (handlers[msg.topic]) {
          handlers[msg.topic].forEach((handler2) => {
            if (typeof handler2 === "function") {
              handler2(msg);
              return;
            }
            if (handler2 != null && handler2.handleEvent != null) {
              handler2.handleEvent(msg);
            }
          });
        }
      };
      libp2p.pubsub.addEventListener("message", onMessage);
    }
    if (handler != null) {
      if (handlers[topic] == null) {
        handlers[topic] = [];
      }
      handlers[topic].push(handler);
    }
  }
  async function unsubscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    if (handler != null && handlers[topic] != null) {
      handlers[topic] = handlers[topic].filter((h) => h !== handler);
      if (handlers[topic].length === 0) {
        delete handlers[topic];
      }
    }
    if (typeof handler !== "function") {
      delete handlers[topic];
    }
    if (handlers[topic] == null) {
      libp2p.pubsub.unsubscribe(topic);
    }
    if (Object.keys(handlers).length === 0) {
      libp2p.pubsub.removeEventListener("message", onMessage);
      onMessage = void 0;
    }
  }
  async function publish(topic, data, options = {}) {
    const { libp2p } = await network.use(options);
    if (!data) {
      throw (0, import_err_code124.default)(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
    }
    await libp2p.pubsub.publish(topic, data);
  }
  async function ls(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getTopics();
  }
  async function peers(topic, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getSubscribers(topic);
  }
}
var notEnabled = async () => {
  throw new NotEnabledError("pubsub not enabled");
};

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/components/index.js
var mergeOptions16 = merge_options_default.bind({ ignoreUndefined: true });
var log100 = logger("ipfs");
var IPNS_INIT_KEYSPACE_TIMEOUT = 3e4;
var IPFS2 = class {
  constructor({ print, storage, codecs: codecs2, options }) {
    const { peerId, repo, keychain } = storage;
    const network = Service.create(Network3);
    const preload2 = createPreloader(options.preload);
    const dns = createDns();
    const isOnline = createIsOnline({ network });
    const ipns = new IPNSAPI(options);
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    this.hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(bases);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base) => multibaseCodecs.push(base));
    this.bases = new Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new PinAPI({ repo, codecs: codecs2 });
    const block = new BlockAPI({ codecs: codecs2, hashers: this.hashers, preload: preload2, repo });
    const name6 = new NameAPI({
      dns,
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain,
      options
    });
    const resolve7 = createResolve({ repo, codecs: codecs2, bases: this.bases, name: name6 });
    const dag = new DagAPI({ repo, codecs: codecs2, hashers: this.hashers, preload: preload2 });
    const refs = Object.assign(createRefs({ repo, codecs: codecs2, resolve: resolve7, preload: preload2 }), {
      local: createLocal({ repo: storage.repo })
    });
    const { add, addAll, cat, get: get6, ls } = new RootAPI({
      preload: preload2,
      repo,
      options: options.EXPERIMENTAL,
      hashers: this.hashers
    });
    const files = createFiles({
      repo,
      preload: preload2,
      hashers: this.hashers,
      options
    });
    const mfsPreload = createMfsPreloader({
      files,
      preload: preload2,
      options: options.preload
    });
    this.preload = preload2;
    this.name = name6;
    this.ipns = ipns;
    this.pin = pin;
    this.resolve = resolve7;
    this.block = block;
    this.refs = refs;
    this.start = createStart({
      network,
      peerId,
      repo,
      preload: preload2,
      ipns,
      mfsPreload,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = createStop({
      network,
      preload: preload2,
      mfsPreload,
      ipns,
      repo
    });
    this.dht = createDht2({ network, repo, peerId });
    this.pubsub = createPubsub3({ network, config: options.config });
    this.dns = dns;
    this.isOnline = isOnline;
    this.id = createId({ network, peerId });
    this.version = createVersion({ repo });
    this.bitswap = new BitswapAPI({ network });
    this.bootstrap = new BootstrapAPI({ repo });
    this.config = createConfig({ repo });
    this.ping = createPing2({ network });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get6;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new KeyAPI({ keychain });
    this.object = new ObjectAPI({ preload: preload2, codecs: codecs2, repo });
    this.repo = new RepoAPI({ repo, hashers: this.hashers });
    this.stats = new StatsAPI({ repo, network });
    this.swarm = new SwarmAPI({ network });
    Object.defineProperty(this, "libp2p", {
      get() {
        const net = network.try();
        return net ? net.libp2p : void 0;
      }
    });
    const notImplemented = () => Promise.reject((0, import_err_code125.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
    const notImplementedIter = async function* () {
      throw (0, import_err_code125.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs2;
  }
  async init() {
    throw new AlreadyInitializedError();
  }
};
var addEmptyDir2 = async (ipfs2) => {
  const buf2 = encode2({
    Data: new UnixFS({ type: "directory" }).marshal(),
    Links: []
  });
  const cid = await ipfs2.block.put(buf2, {
    mhtype: "sha2-256",
    format: "dag-pb"
  });
  await ipfs2.pin.add(cid);
  return cid;
};
var getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !import_env2.isTest,
    addresses: [
      "/dns4/node0.preload.ipfs.io/https",
      "/dns4/node1.preload.ipfs.io/https",
      "/dns4/node2.preload.ipfs.io/https",
      "/dns4/node3.preload.ipfs.io/https"
    ]
  }
});
async function create5(options = {}) {
  options = mergeOptions16(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [src_exports, esm_exports, esm_exports2, lib_exports, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log100 : console.log;
  log100("creating repo");
  const storage = await Storage.start(print, multicodecs, options);
  log100("getting repo config");
  const config2 = await storage.repo.config.getAll();
  const ipfs2 = new IPFS2({
    storage,
    print,
    codecs: multicodecs,
    options: { ...options, config: config2 }
  });
  log100("starting preload");
  await ipfs2.preload.start();
  log100("starting storage");
  ipfs2.ipns.startOffline(storage);
  if (storage.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir2(ipfs2);
    log100("adding default assets");
    await initAssets({ addAll: ipfs2.addAll, print });
    log100("initializing IPNS keyspace");
    if (storage.peerId.publicKey == null) {
      throw (0, import_err_code125.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
    }
    const timeoutController = new import_timeout_abort_controller19.TimeoutController(IPNS_INIT_KEYSPACE_TIMEOUT);
    try {
      await ipfs2.ipns.initializeKeyspace(storage.peerId, fromString(`/ipfs/${cid}`), {
        signal: timeoutController.signal
      });
    } finally {
      timeoutController.clear();
    }
  }
  if (options.start !== false) {
    log100("starting node");
    await ipfs2.start();
  }
  return ipfs2;
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-core-npm-0.16.1-d7fc9f9232-9.zip/node_modules/ipfs-core/src/index.js
var import_glob_source2 = __toESM(require_glob_source(), 1);
var import_url_source2 = __toESM(require_url_source(), 1);
var create6 = create5;
var globSource = import_glob_source2.default;
var urlSource = import_url_source2.default;

// ../../../../../Users/z/.yarn/berry/cache/ipfs-npm-0.64.2-b40814d95c-9.zip/node_modules/ipfs/src/path.browser.js
init_define_process();
function path2() {
  throw new Error("Not supported in browsers");
}

// ../../../../../Users/z/.yarn/berry/cache/ipfs-npm-0.64.2-b40814d95c-9.zip/node_modules/ipfs/src/index.js
var create7 = create6;
var globSource2 = globSource;
var urlSource2 = urlSource;
var path3 = path2;
export {
  create7 as create,
  globSource2 as globSource,
  path3 as path,
  urlSource2 as urlSource
};

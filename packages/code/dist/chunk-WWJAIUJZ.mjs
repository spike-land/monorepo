import {
  __commonJS,
  __esm,
  __export,
  __name,
  __publicField,
  __toCommonJS,
  __toESM,
  define_process_default,
  init_define_process
} from "./chunk-FRA32HOA.mjs";

// dist/chunk-chunk-NCAFBSNA.mjs
var require_diff = __commonJS({
  "../../../../.yarn/global/cache/fast-diff-npm-1.2.0-5ba4171bb6-9c9.zip/node_modules/fast-diff/diff.js"(exports, module) {
    init_define_process();
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    __name(diff_main, "diff_main");
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i4 = longtext.indexOf(shorttext);
      if (i4 !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i4)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i4 + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    __name(diff_compute_, "diff_compute_");
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v22 = new Array(v_length);
      for (var x5 = 0; x5 < v_length; x5++) {
        v1[x5] = -1;
        v22[x5] = -1;
      }
      v1[v_offset + 1] = 0;
      v22[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d4 = 0; d4 < max_d; d4++) {
        for (var k1 = -d4 + k1start; k1 <= d4 - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d4 || k1 !== d4 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v22[k2_offset] !== -1) {
              var x22 = text1_length - v22[k2_offset];
              if (x1 >= x22) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k22 = -d4 + k2start; k22 <= d4 - k2end; k22 += 2) {
          var k2_offset = v_offset + k22;
          var x22;
          if (k22 === -d4 || k22 !== d4 && v22[k2_offset - 1] < v22[k2_offset + 1]) {
            x22 = v22[k2_offset + 1];
          } else {
            x22 = v22[k2_offset - 1] + 1;
          }
          var y22 = x22 - k22;
          while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) === text2.charAt(text2_length - y22 - 1)) {
            x22++;
            y22++;
          }
          v22[k2_offset] = x22;
          if (x22 > text1_length) {
            k2end += 2;
          } else if (y22 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k22;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x22 = text1_length - x22;
              if (x1 >= x22) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    __name(diff_bisect_, "diff_bisect_");
    function diff_bisectSplit_(text1, text2, x5, y4) {
      var text1a = text1.substring(0, x5);
      var text2a = text2.substring(0, y4);
      var text1b = text1.substring(x5);
      var text2b = text2.substring(y4);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    __name(diff_bisectSplit_, "diff_bisectSplit_");
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    __name(diff_commonPrefix, "diff_commonPrefix");
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    __name(diff_commonSuffix, "diff_commonSuffix");
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i4) {
        var seed = longtext2.substring(i4, i4 + Math.floor(longtext2.length / 4));
        var j4 = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j4 = shorttext2.indexOf(seed, j4 + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i4),
            shorttext2.substring(j4)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i4),
            shorttext2.substring(0, j4)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(
              j4 - suffixLength,
              j4
            ) + shorttext2.substring(j4, j4 + prefixLength);
            best_longtext_a = longtext2.substring(0, i4 - suffixLength);
            best_longtext_b = longtext2.substring(i4 + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j4 - suffixLength);
            best_shorttext_b = shorttext2.substring(j4 + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      __name(diff_halfMatchI_, "diff_halfMatchI_");
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    __name(diff_halfMatch_, "diff_halfMatch_");
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k5 = previous_equality - 1;
                  if (diffs[k5] && diffs[k5][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k5][1] + text_insert;
                    k5--;
                  }
                  if (diffs[k5] && diffs[k5][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k5][1] + text_delete;
                    k5--;
                  }
                  previous_equality = k5;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n3 = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n3, n3);
                pointer = pointer - n3;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n3, n3, [DIFF_INSERT, text_insert]);
                pointer = pointer - n3 + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n3, n3, [DIFF_DELETE, text_delete]);
                pointer = pointer - n3 + 1;
              } else {
                diffs.splice(pointer - n3, n3, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n3 + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    __name(diff_cleanupMerge, "diff_cleanupMerge");
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    __name(is_surrogate_pair_start, "is_surrogate_pair_start");
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    __name(is_surrogate_pair_end, "is_surrogate_pair_end");
    function starts_with_pair_end(str2) {
      return is_surrogate_pair_end(str2.charCodeAt(0));
    }
    __name(starts_with_pair_end, "starts_with_pair_end");
    function ends_with_pair_start(str2) {
      return is_surrogate_pair_start(str2.charCodeAt(str2.length - 1));
    }
    __name(ends_with_pair_start, "ends_with_pair_start");
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i4 = 0; i4 < tuples.length; i4++) {
        if (tuples[i4][1].length > 0) {
          ret.push(tuples[i4]);
        }
      }
      return ret;
    }
    __name(remove_empty_tuples, "remove_empty_tuples");
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    __name(make_edit_splice, "make_edit_splice");
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    __name(find_cursor_edit_diff, "find_cursor_edit_diff");
    function diff2(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    __name(diff2, "diff");
    diff2.INSERT = DIFF_INSERT;
    diff2.DELETE = DIFF_DELETE;
    diff2.EQUAL = DIFF_EQUAL;
    module.exports = diff2;
  }
});
init_define_process();
init_define_process();
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
__name(MakeRef, "MakeRef");
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
__name(SetRef, "SetRef");
function OwnerID() {
}
__name(OwnerID, "OwnerID");
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
__name(ensureSize, "ensureSize");
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
__name(wrapIndex, "wrapIndex");
function returnTrue() {
  return true;
}
__name(returnTrue, "returnTrue");
function wholeSlice(begin, end2, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end2 === void 0 || size !== void 0 && end2 >= size);
}
__name(wholeSlice, "wholeSlice");
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
__name(resolveBegin, "resolveBegin");
function resolveEnd(end2, size) {
  return resolveIndex(end2, size, size);
}
__name(resolveEnd, "resolveEnd");
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
__name(resolveIndex, "resolveIndex");
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
__name(isNeg, "isNeg");
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
__name(isCollection, "isCollection");
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
__name(isKeyed, "isKeyed");
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
__name(isIndexed, "isIndexed");
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
__name(isAssociative, "isAssociative");
var Collection = __name(function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
}, "Collection");
var KeyedCollection = function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  __name(KeyedCollection2, "KeyedCollection");
  if (Collection3)
    KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
}(Collection);
var IndexedCollection = function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  __name(IndexedCollection2, "IndexedCollection");
  if (Collection3)
    IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
}(Collection);
var SetCollection = function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  __name(SetCollection2, "SetCollection");
  if (Collection3)
    SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
}(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
__name(isSeq, "isSeq");
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
__name(isRecord, "isRecord");
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
__name(isImmutable, "isImmutable");
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
__name(isOrdered, "isOrdered");
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = __name(function Iterator2(next) {
  this.next = next;
}, "Iterator");
Iterator.prototype.toString = __name(function toString() {
  return "[Iterator]";
}, "toString");
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k5, v5, iteratorResult) {
  var value = type === 0 ? k5 : type === 1 ? v5 : [k5, v5];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
__name(iteratorValue, "iteratorValue");
function iteratorDone() {
  return { value: void 0, done: true };
}
__name(iteratorDone, "iteratorDone");
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
__name(hasIterator, "hasIterator");
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
__name(isIterator, "isIterator");
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
__name(getIterator, "getIterator");
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
__name(getIteratorFn, "getIteratorFn");
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
__name(isEntriesIterable, "isEntriesIterable");
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
__name(isKeysIterable, "isKeysIterable");
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : value.hasOwnProperty(value.length - 1));
}
__name(isArrayLike, "isArrayLike");
var Seq = function(Collection3) {
  function Seq2(value) {
    return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }
  __name(Seq2, "Seq");
  if (Collection3)
    Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = __name(function toSeq3() {
    return this;
  }, "toSeq");
  Seq2.prototype.toString = __name(function toString5() {
    return this.__toString("Seq {", "}");
  }, "toString");
  Seq2.prototype.cacheResult = __name(function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  }, "cacheResult");
  Seq2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var cache2 = this._cache;
    if (cache2) {
      var size = cache2.length;
      var i4 = 0;
      while (i4 !== size) {
        var entry = cache2[reverse3 ? size - ++i4 : i4++];
        if (fn2(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i4;
    }
    return this.__iterateUncached(fn2, reverse3);
  }, "__iterate");
  Seq2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var cache2 = this._cache;
    if (cache2) {
      var size = cache2.length;
      var i4 = 0;
      return new Iterator(function() {
        if (i4 === size) {
          return iteratorDone();
        }
        var entry = cache2[reverse3 ? size - ++i4 : i4++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse3);
  }, "__iterator");
  return Seq2;
}(Collection);
var KeyedSeq = function(Seq2) {
  function KeyedSeq2(value) {
    return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  __name(KeyedSeq2, "KeyedSeq");
  if (Seq2)
    KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = __name(function toKeyedSeq3() {
    return this;
  }, "toKeyedSeq");
  return KeyedSeq2;
}(Seq);
var IndexedSeq = function(Seq2) {
  function IndexedSeq2(value) {
    return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  __name(IndexedSeq2, "IndexedSeq");
  if (Seq2)
    IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = __name(function of() {
    return IndexedSeq2(arguments);
  }, "of");
  IndexedSeq2.prototype.toIndexedSeq = __name(function toIndexedSeq2() {
    return this;
  }, "toIndexedSeq");
  IndexedSeq2.prototype.toString = __name(function toString5() {
    return this.__toString("Seq [", "]");
  }, "toString");
  return IndexedSeq2;
}(Seq);
var SetSeq = function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  __name(SetSeq2, "SetSeq");
  if (Seq2)
    SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = __name(function of() {
    return SetSeq2(arguments);
  }, "of");
  SetSeq2.prototype.toSetSeq = __name(function toSetSeq2() {
    return this;
  }, "toSetSeq");
  return SetSeq2;
}(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = function(IndexedSeq2) {
  function ArraySeq2(array) {
    this._array = array;
    this.size = array.length;
  }
  __name(ArraySeq2, "ArraySeq");
  if (IndexedSeq2)
    ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = __name(function get11(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  }, "get");
  ArraySeq2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var array = this._array;
    var size = array.length;
    var i4 = 0;
    while (i4 !== size) {
      var ii = reverse3 ? size - ++i4 : i4++;
      if (fn2(array[ii], ii, this) === false) {
        break;
      }
    }
    return i4;
  }, "__iterate");
  ArraySeq2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var array = this._array;
    var size = array.length;
    var i4 = 0;
    return new Iterator(function() {
      if (i4 === size) {
        return iteratorDone();
      }
      var ii = reverse3 ? size - ++i4 : i4++;
      return iteratorValue(type, ii, array[ii]);
    });
  }, "__iterator");
  return ArraySeq2;
}(IndexedSeq);
var ObjectSeq = function(KeyedSeq2) {
  function ObjectSeq2(object) {
    var keys22 = Object.keys(object).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
    );
    this._object = object;
    this._keys = keys22;
    this.size = keys22.length;
  }
  __name(ObjectSeq2, "ObjectSeq");
  if (KeyedSeq2)
    ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = __name(function get11(key, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  }, "get");
  ObjectSeq2.prototype.has = __name(function has5(key) {
    return hasOwnProperty.call(this._object, key);
  }, "has");
  ObjectSeq2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var object = this._object;
    var keys22 = this._keys;
    var size = keys22.length;
    var i4 = 0;
    while (i4 !== size) {
      var key = keys22[reverse3 ? size - ++i4 : i4++];
      if (fn2(object[key], key, this) === false) {
        break;
      }
    }
    return i4;
  }, "__iterate");
  ObjectSeq2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var object = this._object;
    var keys22 = this._keys;
    var size = keys22.length;
    var i4 = 0;
    return new Iterator(function() {
      if (i4 === size) {
        return iteratorDone();
      }
      var key = keys22[reverse3 ? size - ++i4 : i4++];
      return iteratorValue(type, key, object[key]);
    });
  }, "__iterator");
  return ObjectSeq2;
}(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  __name(CollectionSeq2, "CollectionSeq");
  if (IndexedSeq2)
    CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = __name(function __iterateUncached(fn2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn2(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  }, "__iterateUncached");
  CollectionSeq2.prototype.__iteratorUncached = __name(function __iteratorUncached(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  }, "__iteratorUncached");
  return CollectionSeq2;
}(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
__name(emptySequence, "emptySequence");
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
__name(keyedSeqFromValue, "keyedSeqFromValue");
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
__name(indexedSeqFromValue, "indexedSeqFromValue");
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
__name(seqFromValue, "seqFromValue");
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
__name(maybeIndexedSeqFromValue, "maybeIndexedSeqFromValue");
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
__name(isMap, "isMap");
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
__name(isOrderedMap, "isOrderedMap");
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
__name(isValueObject, "isValueObject");
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
__name(is, "is");
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : __name(function imul2(a5, b5) {
  a5 |= 0;
  b5 |= 0;
  var c5 = a5 & 65535;
  var d4 = b5 & 65535;
  return c5 * d4 + ((a5 >>> 16) * d4 + c5 * (b5 >>> 16) << 16 >>> 0) | 0;
}, "imul");
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
__name(smi, "smi");
var defaultValueOf = Object.prototype.valueOf;
function hash(o5) {
  if (o5 == null) {
    return hashNullish(o5);
  }
  if (typeof o5.hashCode === "function") {
    return smi(o5.hashCode(o5));
  }
  var v5 = valueOf(o5);
  if (v5 == null) {
    return hashNullish(v5);
  }
  switch (typeof v5) {
    case "boolean":
      return v5 ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v5);
    case "string":
      return v5.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v5) : hashString(v5);
    case "object":
    case "function":
      return hashJSObj(v5);
    case "symbol":
      return hashSymbol(v5);
    default:
      if (typeof v5.toString === "function") {
        return hashString(v5.toString());
      }
      throw new Error("Value type " + typeof v5 + " cannot be hashed.");
  }
}
__name(hash, "hash");
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : 1108378659;
}
__name(hashNullish, "hashNullish");
function hashNumber(n3) {
  if (n3 !== n3 || n3 === Infinity) {
    return 0;
  }
  var hash23 = n3 | 0;
  if (hash23 !== n3) {
    hash23 ^= n3 * 4294967295;
  }
  while (n3 > 4294967295) {
    n3 /= 4294967295;
    hash23 ^= n3;
  }
  return smi(hash23);
}
__name(hashNumber, "hashNumber");
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
__name(cachedHashString, "cachedHashString");
function hashString(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
__name(hashString, "hashString");
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
__name(hashSymbol, "hashSymbol");
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
__name(hashJSObj, "hashJSObj");
var isExtensible = Object.isExtensible;
var canDefineProperty = function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e4) {
    return false;
  }
}();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
__name(getIENodeHash, "getIENodeHash");
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
__name(valueOf, "valueOf");
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
__name(nextHash, "nextHash");
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = /* @__PURE__ */ new WeakMap();
}
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  __name(ToKeyedSequence2, "ToKeyedSequence");
  if (KeyedSeq2)
    ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = __name(function get11(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  }, "get");
  ToKeyedSequence2.prototype.has = __name(function has5(key) {
    return this._iter.has(key);
  }, "has");
  ToKeyedSequence2.prototype.valueSeq = __name(function valueSeq2() {
    return this._iter.valueSeq();
  }, "valueSeq");
  ToKeyedSequence2.prototype.reverse = __name(function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  }, "reverse");
  ToKeyedSequence2.prototype.map = __name(function map2(mapper, context) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context);
      };
    }
    return mappedSequence;
  }, "map");
  ToKeyedSequence2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v5, k5) {
      return fn2(v5, k5, this$1$1);
    }, reverse3);
  }, "__iterate");
  ToKeyedSequence2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    return this._iter.__iterator(type, reverse3);
  }, "__iterator");
  return ToKeyedSequence2;
}(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  __name(ToIndexedSequence2, "ToIndexedSequence");
  if (IndexedSeq2)
    ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = __name(function includes3(value) {
    return this._iter.includes(value);
  }, "includes");
  ToIndexedSequence2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    var i4 = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(
      function(v5) {
        return fn2(v5, reverse3 ? this$1$1.size - ++i4 : i4++, this$1$1);
      },
      reverse3
    );
  }, "__iterate");
  ToIndexedSequence2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i4 = 0;
    reverse3 && ensureSize(this);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(
        type,
        reverse3 ? this$1$1.size - ++i4 : i4++,
        step.value,
        step
      );
    });
  }, "__iterator");
  return ToIndexedSequence2;
}(IndexedSeq);
var ToSetSequence = function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  __name(ToSetSequence2, "ToSetSequence");
  if (SetSeq2)
    ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = __name(function has5(key) {
    return this._iter.includes(key);
  }, "has");
  ToSetSequence2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v5) {
      return fn2(v5, v5, this$1$1);
    }, reverse3);
  }, "__iterate");
  ToSetSequence2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  }, "__iterator");
  return ToSetSequence2;
}(SetSeq);
var FromEntriesSequence = function(KeyedSeq2) {
  function FromEntriesSequence2(entries3) {
    this._iter = entries3;
    this.size = entries3.size;
  }
  __name(FromEntriesSequence2, "FromEntriesSequence");
  if (KeyedSeq2)
    FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = __name(function entrySeq2() {
    return this._iter.toSeq();
  }, "entrySeq");
  FromEntriesSequence2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn2(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1$1
        );
      }
    }, reverse3);
  }, "__iterate");
  FromEntriesSequence2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  }, "__iterator");
  return FromEntriesSequence2;
}(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v5, k5) {
      return fn2(k5, v5, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k5 = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k5;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
__name(flipFactory, "flipFactory");
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v5 = collection.get(key, NOT_SET);
    return v5 === NOT_SET ? notSetValue : mapper.call(context, v5, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v5, k5, c5) {
        return fn2(mapper.call(context, v5, k5, c5), k5, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
__name(mapFactory, "mapFactory");
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn2, reverse3) {
    var this$1$12 = this;
    var i4 = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v5, k5) {
        return fn2(v5, useKeys ? k5 : reverse3 ? this$1$12.size - ++i4 : i4++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i4 = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i4 : i4++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
__name(reverseFactory, "reverseFactory");
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v5 = collection.get(key, NOT_SET);
      return v5 !== NOT_SET && !!predicate.call(context, v5, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v5 = collection.get(key, NOT_SET);
      return v5 !== NOT_SET && predicate.call(context, v5, key, collection) ? v5 : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v5, k5, c5) {
      if (predicate.call(context, v5, k5, c5)) {
        iterations++;
        return fn2(v5, useKeys ? k5 : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
__name(filterFactory, "filterFactory");
function countByFactory(collection, grouper, context) {
  var groups = Map2().asMutable();
  collection.__iterate(function(v5, k5) {
    groups.update(grouper.call(context, v5, k5, collection), 0, function(a5) {
      return a5 + 1;
    });
  });
  return groups.asImmutable();
}
__name(countByFactory, "countByFactory");
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map2()).asMutable();
  collection.__iterate(function(v5, k5) {
    groups.update(
      grouper.call(context, v5, k5, collection),
      function(a5) {
        return a5 = a5 || [], a5.push(isKeyedIter ? [k5, v5] : v5), a5;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
__name(groupByFactory, "groupByFactory");
function sliceFactory(collection, begin, end2, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end2, originalSize)) {
    return collection;
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end2, originalSize);
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end2, useKeys);
  }
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v5, k5) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn2(v5, useKeys ? k5 : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
__name(sliceFactory, "sliceFactory");
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v5, k5, c5) {
        return predicate.call(context, v5, k5, c5) && ++iterations && fn2(v5, k5, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k5 = entry[0];
      var v5 = entry[1];
      if (!predicate.call(context, v5, k5, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k5, v5, step);
    });
  };
  return takeSequence;
}
__name(takeWhileFactory, "takeWhileFactory");
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v5, k5, c5) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v5, k5, c5)))) {
        iterations++;
        return fn2(v5, useKeys ? k5 : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k5;
      var v5;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k5 = entry[0];
        v5 = entry[1];
        skipping && (skipping = predicate.call(context, v5, k5, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k5, v5, step);
    });
  };
  return skipSequence;
}
__name(skipWhileFactory, "skipWhileFactory");
function concatFactory(collection, values23) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values23).map(function(v5) {
    if (!isCollection(v5)) {
      v5 = isKeyedCollection ? keyedSeqFromValue(v5) : indexedSeqFromValue(Array.isArray(v5) ? v5 : [v5]);
    } else if (isKeyedCollection) {
      v5 = KeyedCollection(v5);
    }
    return v5;
  }).filter(function(v5) {
    return v5.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
__name(concatFactory, "concatFactory");
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn2, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn2, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v5, k5) {
        if ((!depth || currentDepth < depth) && isCollection(v5)) {
          flatDeep(v5, currentDepth + 1);
        } else {
          iterations++;
          if (fn2(v5, useKeys ? k5 : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    __name(flatDeep, "flatDeep");
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v5 = step.value;
        if (type === ITERATE_ENTRIES) {
          v5 = v5[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v5)) {
          stack.push(iterator);
          iterator = v5.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v5, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
__name(flattenFactory, "flattenFactory");
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v5, k5) {
    return coerce(mapper.call(context, v5, k5, collection));
  }).flatten(true);
}
__name(flatMapFactory, "flatMapFactory");
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v5) {
        return (!iterations || fn2(separator, iterations++, this$1$1) !== false) && fn2(v5, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
__name(interposeFactory, "interposeFactory");
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v5, k5) {
    return [k5, v5, index++, mapper ? mapper(v5, k5, collection) : v5];
  }).valueSeq().toArray();
  entries3.sort(function(a5, b5) {
    return comparator(a5[3], b5[3]) || a5[2] - b5[2];
  }).forEach(
    isKeyedCollection ? function(v5, i4) {
      entries3[i4].length = 2;
    } : function(v5, i4) {
      entries3[i4] = v5[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
__name(sortFactory, "sortFactory");
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v5, k5) {
      return [v5, mapper(v5, k5, collection)];
    }).reduce(function(a5, b5) {
      return maxCompare(comparator, a5[1], b5[1]) ? b5 : a5;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a5, b5) {
    return maxCompare(comparator, a5, b5) ? b5 : a5;
  });
}
__name(maxFactory, "maxFactory");
function maxCompare(comparator, a5, b5) {
  var comp = comparator(b5, a5);
  return comp === 0 && b5 !== a5 && (b5 === void 0 || b5 === null || b5 !== b5) || comp > 0;
}
__name(maxCompare, "maxCompare");
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes2 = new ArraySeq(iters).map(function(i4) {
    return i4.size;
  });
  zipSequence.size = zipAll2 ? sizes2.max() : sizes2.min();
  zipSequence.__iterate = function(fn2, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn2(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i4) {
        return i4 = Collection(i4), getIterator(reverse3 ? i4.reverse() : i4);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps2;
      if (!isDone) {
        steps2 = iterators.map(function(i4) {
          return i4.next();
        });
        isDone = zipAll2 ? steps2.every(function(s4) {
          return s4.done;
        }) : steps2.some(function(s4) {
          return s4.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps2.map(function(s4) {
            return s4.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
__name(zipWithFactory, "zipWithFactory");
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
__name(reify, "reify");
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
__name(validateEntry, "validateEntry");
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
__name(collectionClass, "collectionClass");
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
__name(makeSequence, "makeSequence");
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
__name(cacheResultThrough, "cacheResultThrough");
function defaultComparator(a5, b5) {
  if (a5 === void 0 && b5 === void 0) {
    return 0;
  }
  if (a5 === void 0) {
    return 1;
  }
  if (b5 === void 0) {
    return -1;
  }
  return a5 > b5 ? 1 : a5 < b5 ? -1 : 0;
}
__name(defaultComparator, "defaultComparator");
function arrCopy(arr, offset2) {
  offset2 = offset2 || 0;
  var len = Math.max(0, arr.length - offset2);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset2];
  }
  return newArr;
}
__name(arrCopy, "arrCopy");
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
__name(invariant, "invariant");
function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
__name(assertNotInfinite, "assertNotInfinite");
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
__name(coerceKeyPath, "coerceKeyPath");
var toString2 = Object.prototype.toString;
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
__name(isPlainObject, "isPlainObject");
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
__name(isDataStructure, "isDataStructure");
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
__name(quoteString, "quoteString");
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
__name(has, "has");
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
__name(get, "get");
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
__name(shallowCopy, "shallowCopy");
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
__name(remove, "remove");
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
__name(set, "set");
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
__name(updateIn$1, "updateIn$1");
function updateInDeeply(inImmutable, existing, keyPath, i4, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i4 === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i4).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i4];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i4 + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
__name(updateInDeeply, "updateInDeeply");
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
__name(setIn$1, "setIn$1");
function setIn(keyPath, v5) {
  return setIn$1(this, keyPath, v5);
}
__name(setIn, "setIn");
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
__name(removeIn, "removeIn");
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
__name(deleteIn, "deleteIn");
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
__name(update$1, "update$1");
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
__name(update, "update");
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
__name(updateIn, "updateIn");
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
__name(merge$1, "merge$1");
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
__name(mergeWith$1, "mergeWith$1");
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
__name(mergeIntoKeyedWith, "mergeIntoKeyedWith");
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
__name(mergeDeepWithSources, "mergeDeepWithSources");
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i4 = 0; i4 < sources.length; i4++) {
    Collection3(sources[i4]).forEach(mergeItem);
  }
  return merged;
}
__name(mergeWithSources, "mergeWithSources");
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  __name(deepMerger, "deepMerger");
  return deepMerger;
}
__name(deepMergerWith, "deepMergerWith");
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
__name(areMergeable, "areMergeable");
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
__name(mergeDeep, "mergeDeep");
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
__name(mergeDeepWith, "mergeDeepWith");
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m5) {
    return mergeWithSources(m5, iters);
  });
}
__name(mergeIn, "mergeIn");
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m5) {
      return mergeDeepWithSources(m5, iters);
    }
  );
}
__name(mergeDeepIn, "mergeDeepIn");
function withMutations(fn2) {
  var mutable = this.asMutable();
  fn2(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
__name(withMutations, "withMutations");
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
__name(asMutable, "asMutable");
function asImmutable() {
  return this.__ensureOwner();
}
__name(asImmutable, "asImmutable");
function wasAltered() {
  return this.__altered;
}
__name(wasAltered, "wasAltered");
var Map2 = function(KeyedCollection2) {
  function Map22(value) {
    return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map2) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v5, k5) {
        return map2.set(k5, v5);
      });
    });
  }
  __name(Map22, "Map");
  if (KeyedCollection2)
    Map22.__proto__ = KeyedCollection2;
  Map22.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map22.prototype.constructor = Map22;
  Map22.of = __name(function of() {
    var keyValues = [], len = arguments.length;
    while (len--)
      keyValues[len] = arguments[len];
    return emptyMap().withMutations(function(map2) {
      for (var i4 = 0; i4 < keyValues.length; i4 += 2) {
        if (i4 + 1 >= keyValues.length) {
          throw new Error("Missing value for key: " + keyValues[i4]);
        }
        map2.set(keyValues[i4], keyValues[i4 + 1]);
      }
    });
  }, "of");
  Map22.prototype.toString = __name(function toString5() {
    return this.__toString("Map {", "}");
  }, "toString");
  Map22.prototype.get = __name(function get11(k5, notSetValue) {
    return this._root ? this._root.get(0, void 0, k5, notSetValue) : notSetValue;
  }, "get");
  Map22.prototype.set = __name(function set3(k5, v5) {
    return updateMap(this, k5, v5);
  }, "set");
  Map22.prototype.remove = __name(function remove3(k5) {
    return updateMap(this, k5, NOT_SET);
  }, "remove");
  Map22.prototype.deleteAll = __name(function deleteAll(keys22) {
    var collection = Collection(keys22);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map2) {
      collection.forEach(function(key) {
        return map2.remove(key);
      });
    });
  }, "deleteAll");
  Map22.prototype.clear = __name(function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  }, "clear");
  Map22.prototype.sort = __name(function sort2(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  }, "sort");
  Map22.prototype.sortBy = __name(function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  }, "sortBy");
  Map22.prototype.map = __name(function map2(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(map3) {
      map3.forEach(function(value, key) {
        map3.set(key, mapper.call(context, value, key, this$1$1));
      });
    });
  }, "map");
  Map22.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    return new MapIterator(this, type, reverse3);
  }, "__iterator");
  Map22.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn2(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  }, "__iterate");
  Map22.prototype.__ensureOwner = __name(function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  }, "__ensureOwner");
  return Map22;
}(KeyedCollection);
Map2.isMap = isMap;
var MapPrototype = Map2.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update;
MapPrototype.updateIn = updateIn;
MapPrototype.merge = MapPrototype.concat = merge$1;
MapPrototype.mergeWith = mergeWith$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = __name(function ArrayMapNode2(ownerID, entries3) {
  this.ownerID = ownerID;
  this.entries = entries3;
}, "ArrayMapNode");
ArrayMapNode.prototype.get = __name(function get2(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
}, "get");
ArrayMapNode.prototype.update = __name(function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries3.length === 1) {
    return;
  }
  if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries3, key, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
}, "update");
var BitmapIndexedNode = __name(function BitmapIndexedNode2(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
}, "BitmapIndexedNode");
BitmapIndexedNode.prototype.get = __name(function get3(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
    shift + SHIFT,
    keyHash,
    key,
    notSetValue
  );
}, "get");
BitmapIndexedNode.prototype.update = __name(function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : void 0;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }
  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
}, "update");
var HashArrayMapNode = __name(function HashArrayMapNode2(ownerID, count2, nodes) {
  this.ownerID = ownerID;
  this.count = count2;
  this.nodes = nodes;
}, "HashArrayMapNode");
HashArrayMapNode.prototype.get = __name(function get4(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
}, "get");
HashArrayMapNode.prototype.update = __name(function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
}, "update");
var HashCollisionNode = __name(function HashCollisionNode2(ownerID, keyHash, entries3) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries3;
}, "HashCollisionNode");
HashCollisionNode.prototype.get = __name(function get5(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
}, "get");
HashCollisionNode.prototype.update = __name(function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
}, "update");
var ValueNode = __name(function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
}, "ValueNode");
ValueNode.prototype.get = __name(function get6(shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
}, "get");
ValueNode.prototype.update = __name(function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
}, "update");
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn2, reverse3) {
  var entries3 = this.entries;
  for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
    if (fn2(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn2, reverse3) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn2, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn2, reverse3) {
  return fn2(this.entry);
};
var MapIterator = function(Iterator3) {
  function MapIterator2(map2, type, reverse3) {
    this._type = type;
    this._reverse = reverse3;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  __name(MapIterator2, "MapIterator");
  if (Iterator3)
    MapIterator2.__proto__ = Iterator3;
  MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = __name(function next() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }, "next");
  return MapIterator2;
}(Iterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
__name(mapIteratorValue, "mapIteratorValue");
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
__name(mapIteratorFrame, "mapIteratorFrame");
function makeMap(size, root, ownerID, hash23) {
  var map2 = Object.create(MapPrototype);
  map2.size = size;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash23;
  map2.__altered = false;
  return map2;
}
__name(makeMap, "makeMap");
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
__name(emptyMap, "emptyMap");
function updateMap(map2, k5, v5) {
  var newRoot;
  var newSize;
  if (!map2._root) {
    if (v5 === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k5, v5]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map2._root,
      map2.__ownerID,
      0,
      void 0,
      k5,
      v5,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v5 === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
__name(updateMap, "updateMap");
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
__name(updateNode, "updateNode");
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
__name(isLeafNode, "isLeafNode");
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
__name(mergeIntoNode, "mergeIntoNode");
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
__name(createNodes, "createNodes");
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
__name(packNodes, "packNodes");
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
__name(expandNodes, "expandNodes");
function popCount(x5) {
  x5 -= x5 >> 1 & 1431655765;
  x5 = (x5 & 858993459) + (x5 >> 2 & 858993459);
  x5 = x5 + (x5 >> 4) & 252645135;
  x5 += x5 >> 8;
  x5 += x5 >> 16;
  return x5 & 127;
}
__name(popCount, "popCount");
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
__name(setAt, "setAt");
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
__name(spliceIn, "spliceIn");
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
__name(spliceOut, "spliceOut");
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
__name(isList, "isList");
var List = function(IndexedCollection2) {
  function List2(value) {
    var empty = emptyList();
    if (value === void 0 || value === null) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function(list) {
      list.setSize(size);
      iter.forEach(function(v5, i4) {
        return list.set(i4, v5);
      });
    });
  }
  __name(List2, "List");
  if (IndexedCollection2)
    List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = __name(function of() {
    return this(arguments);
  }, "of");
  List2.prototype.toString = __name(function toString5() {
    return this.__toString("List [", "]");
  }, "toString");
  List2.prototype.get = __name(function get11(index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  }, "get");
  List2.prototype.set = __name(function set3(index, value) {
    return updateList(this, index, value);
  }, "set");
  List2.prototype.remove = __name(function remove3(index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  }, "remove");
  List2.prototype.insert = __name(function insert(index, value) {
    return this.splice(index, 0, value);
  }, "insert");
  List2.prototype.clear = __name(function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  }, "clear");
  List2.prototype.push = __name(function push() {
    var values23 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list) {
      setListBounds(list, 0, oldSize + values23.length);
      for (var ii = 0; ii < values23.length; ii++) {
        list.set(oldSize + ii, values23[ii]);
      }
    });
  }, "push");
  List2.prototype.pop = __name(function pop() {
    return setListBounds(this, 0, -1);
  }, "pop");
  List2.prototype.unshift = __name(function unshift() {
    var values23 = arguments;
    return this.withMutations(function(list) {
      setListBounds(list, -values23.length);
      for (var ii = 0; ii < values23.length; ii++) {
        list.set(ii, values23[ii]);
      }
    });
  }, "unshift");
  List2.prototype.shift = __name(function shift() {
    return setListBounds(this, 1);
  }, "shift");
  List2.prototype.concat = __name(function concat2() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      var argument = arguments$1[i4];
      var seq = IndexedCollection2(
        typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list.push(value);
        });
      });
    });
  }, "concat");
  List2.prototype.setSize = __name(function setSize(size) {
    return setListBounds(this, 0, size);
  }, "setSize");
  List2.prototype.map = __name(function map2(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(list) {
      for (var i4 = 0; i4 < this$1$1.size; i4++) {
        list.set(i4, mapper.call(context, list.get(i4), i4, this$1$1));
      }
    });
  }, "map");
  List2.prototype.slice = __name(function slice3(begin, end2) {
    var size = this.size;
    if (wholeSlice(begin, end2, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end2, size)
    );
  }, "slice");
  List2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values23 = iterateList(this, reverse3);
    return new Iterator(function() {
      var value = values23();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
    });
  }, "__iterator");
  List2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values23 = iterateList(this, reverse3);
    var value;
    while ((value = values23()) !== DONE) {
      if (fn2(value, reverse3 ? --index : index++, this) === false) {
        break;
      }
    }
    return index;
  }, "__iterate");
  List2.prototype.__ensureOwner = __name(function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  }, "__ensureOwner");
  return List2;
}(IndexedCollection);
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update;
ListPrototype.updateIn = updateIn;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr) {
  return result.push(arr);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = __name(function VNode2(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
}, "VNode");
VNode.prototype.removeBefore = __name(function removeBefore(ownerID, level, index) {
  if (index === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = index >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
}, "removeBefore");
VNode.prototype.removeAfter = __name(function removeAfter(ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
}, "removeAfter");
var DONE = {};
function iterateList(list, reverse3) {
  var left3 = list._origin;
  var right3 = list._capacity;
  var tailPos = getTailOffset(right3);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset2) {
    return level === 0 ? iterateLeaf(node, offset2) : iterateNode(node, level, offset2);
  }
  __name(iterateNodeOrLeaf, "iterateNodeOrLeaf");
  function iterateLeaf(node, offset2) {
    var array = offset2 === tailPos ? tail && tail.array : node && node.array;
    var from = offset2 > left3 ? 0 : left3 - offset2;
    var to = right3 - offset2;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from++;
      return array && array[idx];
    };
  }
  __name(iterateLeaf, "iterateLeaf");
  function iterateNode(node, level, offset2) {
    var values23;
    var array = node && node.array;
    var from = offset2 > left3 ? 0 : left3 - offset2 >> level;
    var to = (right3 - offset2 >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values23) {
          var value = values23();
          if (value !== DONE) {
            return value;
          }
          values23 = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from++;
        values23 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset2 + (idx << level)
        );
      }
    };
  }
  __name(iterateNode, "iterateNode");
}
__name(iterateList, "iterateList");
function makeList(origin, capacity, level, root, tail, ownerID, hash23) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash23;
  list.__altered = false;
  return list;
}
__name(makeList, "makeList");
var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
__name(emptyList, "emptyList");
function updateList(list, index, value) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
__name(updateList, "updateList");
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
__name(updateVNode, "updateVNode");
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
__name(editableVNode, "editableVNode");
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
__name(listNodeFor, "listNodeFor");
function setListBounds(list, begin, end2) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end2 !== void 0) {
    end2 |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end2 === void 0 ? oldCapacity : end2 < 0 ? oldCapacity + end2 : oldOrigin + end2;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
__name(setListBounds, "setListBounds");
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
__name(getTailOffset, "getTailOffset");
var OrderedMap = function(Map22) {
  function OrderedMap2(value) {
    return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map2) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v5, k5) {
        return map2.set(k5, v5);
      });
    });
  }
  __name(OrderedMap2, "OrderedMap");
  if (Map22)
    OrderedMap2.__proto__ = Map22;
  OrderedMap2.prototype = Object.create(Map22 && Map22.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = __name(function of() {
    return this(arguments);
  }, "of");
  OrderedMap2.prototype.toString = __name(function toString5() {
    return this.__toString("OrderedMap {", "}");
  }, "toString");
  OrderedMap2.prototype.get = __name(function get11(k5, notSetValue) {
    var index = this._map.get(k5);
    return index !== void 0 ? this._list.get(index)[1] : notSetValue;
  }, "get");
  OrderedMap2.prototype.clear = __name(function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  }, "clear");
  OrderedMap2.prototype.set = __name(function set3(k5, v5) {
    return updateOrderedMap(this, k5, v5);
  }, "set");
  OrderedMap2.prototype.remove = __name(function remove3(k5) {
    return updateOrderedMap(this, k5, NOT_SET);
  }, "remove");
  OrderedMap2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(
      function(entry) {
        return entry && fn2(entry[1], entry[0], this$1$1);
      },
      reverse3
    );
  }, "__iterate");
  OrderedMap2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    return this._list.fromEntrySeq().__iterator(type, reverse3);
  }, "__iterator");
  OrderedMap2.prototype.__ensureOwner = __name(function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  }, "__ensureOwner");
  return OrderedMap2;
}(Map2);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map2, list, ownerID, hash23) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map2 ? map2.size : 0;
  omap._map = map2;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash23;
  omap.__altered = false;
  return omap;
}
__name(makeOrderedMap, "makeOrderedMap");
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
__name(emptyOrderedMap, "emptyOrderedMap");
function updateOrderedMap(omap, k5, v5) {
  var map2 = omap._map;
  var list = omap._list;
  var i4 = map2.get(k5);
  var has5 = i4 !== void 0;
  var newMap;
  var newList;
  if (v5 === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map2.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i4 !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map2.remove(k5);
      newList = i4 === list.size - 1 ? list.pop() : list.set(i4, void 0);
    }
  } else if (has5) {
    if (v5 === list.get(i4)[1]) {
      return omap;
    }
    newMap = map2;
    newList = list.set(i4, [k5, v5]);
  } else {
    newMap = map2.set(k5, list.size);
    newList = list.set(list.size, [k5, v5]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
__name(updateOrderedMap, "updateOrderedMap");
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
__name(isStack, "isStack");
var Stack = function(IndexedCollection2) {
  function Stack22(value) {
    return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  __name(Stack22, "Stack");
  if (IndexedCollection2)
    Stack22.__proto__ = IndexedCollection2;
  Stack22.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack22.prototype.constructor = Stack22;
  Stack22.of = __name(function of() {
    return this(arguments);
  }, "of");
  Stack22.prototype.toString = __name(function toString5() {
    return this.__toString("Stack [", "]");
  }, "toString");
  Stack22.prototype.get = __name(function get11(index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  }, "get");
  Stack22.prototype.peek = __name(function peek() {
    return this._head && this._head.value;
  }, "peek");
  Stack22.prototype.push = __name(function push() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  }, "push");
  Stack22.prototype.pushAll = __name(function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(function(value) {
      newSize++;
      head = {
        value,
        next: head
      };
    }, true);
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  }, "pushAll");
  Stack22.prototype.pop = __name(function pop() {
    return this.slice(1);
  }, "pop");
  Stack22.prototype.clear = __name(function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  }, "clear");
  Stack22.prototype.slice = __name(function slice3(begin, end2) {
    if (wholeSlice(begin, end2, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end2, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end2);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  }, "slice");
  Stack22.prototype.__ensureOwner = __name(function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  }, "__ensureOwner");
  Stack22.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(
        function(v5, k5) {
          return fn2(v5, k5, this$1$1);
        },
        reverse3
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn2(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  }, "__iterate");
  Stack22.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  }, "__iterator");
  return Stack22;
}(IndexedCollection);
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash23) {
  var map2 = Object.create(StackPrototype);
  map2.size = size;
  map2._head = head;
  map2.__ownerID = ownerID;
  map2.__hash = hash23;
  map2.__altered = false;
  return map2;
}
__name(makeStack, "makeStack");
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
__name(emptyStack, "emptyStack");
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
__name(isSet, "isSet");
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
__name(isOrderedSet, "isOrderedSet");
function deepEqual(a5, b5) {
  if (a5 === b5) {
    return true;
  }
  if (!isCollection(b5) || a5.size !== void 0 && b5.size !== void 0 && a5.size !== b5.size || a5.__hash !== void 0 && b5.__hash !== void 0 && a5.__hash !== b5.__hash || isKeyed(a5) !== isKeyed(b5) || isIndexed(a5) !== isIndexed(b5) || isOrdered(a5) !== isOrdered(b5)) {
    return false;
  }
  if (a5.size === 0 && b5.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a5);
  if (isOrdered(a5)) {
    var entries3 = a5.entries();
    return b5.every(function(v5, k5) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v5) && (notAssociative || is(entry[0], k5));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a5.size === void 0) {
    if (b5.size === void 0) {
      if (typeof a5.cacheResult === "function") {
        a5.cacheResult();
      }
    } else {
      flipped = true;
      var _5 = a5;
      a5 = b5;
      b5 = _5;
    }
  }
  var allEqual = true;
  var bSize = b5.__iterate(function(v5, k5) {
    if (notAssociative ? !a5.has(v5) : flipped ? !is(v5, a5.get(k5, NOT_SET)) : !is(a5.get(k5, NOT_SET), v5)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a5.size === bSize;
}
__name(deepEqual, "deepEqual");
function mixin(ctor, methods) {
  var keyCopier = __name(function(key) {
    ctor.prototype[key] = methods[key];
  }, "keyCopier");
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
__name(mixin, "mixin");
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v5, k5) {
      result$1[k5] = toJS(v5);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v5) {
    result.push(toJS(v5));
  });
  return result;
}
__name(toJS, "toJS");
var Set2 = function(SetCollection2) {
  function Set22(value) {
    return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v5) {
        return set3.add(v5);
      });
    });
  }
  __name(Set22, "Set");
  if (SetCollection2)
    Set22.__proto__ = SetCollection2;
  Set22.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set22.prototype.constructor = Set22;
  Set22.of = __name(function of() {
    return this(arguments);
  }, "of");
  Set22.fromKeys = __name(function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  }, "fromKeys");
  Set22.intersect = __name(function intersect(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.intersect.apply(Set22(sets.pop()), sets) : emptySet();
  }, "intersect");
  Set22.union = __name(function union(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.union.apply(Set22(sets.pop()), sets) : emptySet();
  }, "union");
  Set22.prototype.toString = __name(function toString5() {
    return this.__toString("Set {", "}");
  }, "toString");
  Set22.prototype.has = __name(function has5(value) {
    return this._map.has(value);
  }, "has");
  Set22.prototype.add = __name(function add(value) {
    return updateSet(this, this._map.set(value, value));
  }, "add");
  Set22.prototype.remove = __name(function remove3(value) {
    return updateSet(this, this._map.remove(value));
  }, "remove");
  Set22.prototype.clear = __name(function clear2() {
    return updateSet(this, this._map.clear());
  }, "clear");
  Set22.prototype.map = __name(function map2(mapper, context) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(
      this,
      this._map.mapEntries(function(ref) {
        var v5 = ref[1];
        var mapped = mapper.call(context, v5, v5, this$1$1);
        if (mapped !== v5) {
          didChanges = true;
        }
        return [mapped, mapped];
      }, context)
    );
    return didChanges ? newMap : this;
  }, "map");
  Set22.prototype.union = __name(function union() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    iters = iters.filter(function(x5) {
      return x5.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set3) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection2(iters[ii]).forEach(function(value) {
          return set3.add(value);
        });
      }
    });
  }, "union");
  Set22.prototype.intersect = __name(function intersect() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  }, "intersect");
  Set22.prototype.subtract = __name(function subtract() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  }, "subtract");
  Set22.prototype.sort = __name(function sort2(comparator) {
    return OrderedSet(sortFactory(this, comparator));
  }, "sort");
  Set22.prototype.sortBy = __name(function sortBy2(mapper, comparator) {
    return OrderedSet(sortFactory(this, comparator, mapper));
  }, "sortBy");
  Set22.prototype.wasAltered = __name(function wasAltered3() {
    return this._map.wasAltered();
  }, "wasAltered");
  Set22.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k5) {
      return fn2(k5, k5, this$1$1);
    }, reverse3);
  }, "__iterate");
  Set22.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    return this._map.__iterator(type, reverse3);
  }, "__iterator");
  Set22.prototype.__ensureOwner = __name(function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  }, "__ensureOwner");
  return Set22;
}(SetCollection);
Set2.isSet = isSet;
var SetPrototype = Set2.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr) {
  return result.add(arr);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
__name(updateSet, "updateSet");
function makeSet(map2, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
__name(makeSet, "makeSet");
var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
__name(emptySet, "emptySet");
var Range = function(IndexedSeq2) {
  function Range2(start2, end2, step) {
    if (!(this instanceof Range2)) {
      return new Range2(start2, end2, step);
    }
    invariant(step !== 0, "Cannot step a Range by 0");
    start2 = start2 || 0;
    if (end2 === void 0) {
      end2 = Infinity;
    }
    step = step === void 0 ? 1 : Math.abs(step);
    if (end2 < start2) {
      step = -step;
    }
    this._start = start2;
    this._end = end2;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end2 - start2) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  __name(Range2, "Range");
  if (IndexedSeq2)
    Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = __name(function toString5() {
    if (this.size === 0) {
      return "Range []";
    }
    return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  }, "toString");
  Range2.prototype.get = __name(function get11(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  }, "get");
  Range2.prototype.includes = __name(function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  }, "includes");
  Range2.prototype.slice = __name(function slice3(begin, end2) {
    if (wholeSlice(begin, end2, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end2 = resolveEnd(end2, this.size);
    if (end2 <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(
      this.get(begin, this._end),
      this.get(end2, this._end),
      this._step
    );
  }, "slice");
  Range2.prototype.indexOf = __name(function indexOf2(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  }, "indexOf");
  Range2.prototype.lastIndexOf = __name(function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  }, "lastIndexOf");
  Range2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i4 = 0;
    while (i4 !== size) {
      if (fn2(value, reverse3 ? size - ++i4 : i4++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i4;
  }, "__iterate");
  Range2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i4 = 0;
    return new Iterator(function() {
      if (i4 === size) {
        return iteratorDone();
      }
      var v5 = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type, reverse3 ? size - ++i4 : i4++, v5);
    });
  }, "__iterator");
  Range2.prototype.equals = __name(function equals3(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  }, "equals");
  return Range2;
}(IndexedSeq);
var EMPTY_RANGE;
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i4 = 0;
  while (i4 !== keyPath.length) {
    collection = get(collection, keyPath[i4++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
__name(getIn$1, "getIn$1");
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
__name(getIn, "getIn");
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
__name(hasIn$1, "hasIn$1");
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
__name(hasIn, "hasIn");
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v5, k5) {
    object[k5] = v5;
  });
  return object;
}
__name(toObject, "toObject");
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  toArray: __name(function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i4 = 0;
    this.__iterate(function(v5, k5) {
      array[i4++] = useTuples ? [k5, v5] : v5;
    });
    return array;
  }, "toArray"),
  toIndexedSeq: __name(function toIndexedSeq() {
    return new ToIndexedSequence(this);
  }, "toIndexedSeq"),
  toJS: __name(function toJS$1() {
    return toJS(this);
  }, "toJS$1"),
  toKeyedSeq: __name(function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  }, "toKeyedSeq"),
  toMap: __name(function toMap() {
    return Map2(this.toKeyedSeq());
  }, "toMap"),
  toObject,
  toOrderedMap: __name(function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  }, "toOrderedMap"),
  toOrderedSet: __name(function toOrderedSet() {
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  }, "toOrderedSet"),
  toSet: __name(function toSet() {
    return Set2(isKeyed(this) ? this.valueSeq() : this);
  }, "toSet"),
  toSetSeq: __name(function toSetSeq() {
    return new ToSetSequence(this);
  }, "toSetSeq"),
  toSeq: __name(function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  }, "toSeq"),
  toStack: __name(function toStack() {
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  }, "toStack"),
  toList: __name(function toList() {
    return List(isKeyed(this) ? this.valueSeq() : this);
  }, "toList"),
  toString: __name(function toString3() {
    return "[Collection]";
  }, "toString"),
  __toString: __name(function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  }, "__toString"),
  concat: __name(function concat() {
    var values23 = [], len = arguments.length;
    while (len--)
      values23[len] = arguments[len];
    return reify(this, concatFactory(this, values23));
  }, "concat"),
  includes: __name(function includes(searchValue) {
    return this.some(function(value) {
      return is(value, searchValue);
    });
  }, "includes"),
  entries: __name(function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  }, "entries"),
  every: __name(function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v5, k5, c5) {
      if (!predicate.call(context, v5, k5, c5)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  }, "every"),
  filter: __name(function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  }, "filter"),
  find: __name(function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  }, "find"),
  forEach: __name(function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  }, "forEach"),
  join: __name(function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v5) {
      isFirst ? isFirst = false : joined += separator;
      joined += v5 !== null && v5 !== void 0 ? v5.toString() : "";
    });
    return joined;
  }, "join"),
  keys: __name(function keys() {
    return this.__iterator(ITERATE_KEYS);
  }, "keys"),
  map: __name(function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  }, "map"),
  reduce: __name(function reduce$1(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      false
    );
  }, "reduce$1"),
  reduceRight: __name(function reduceRight(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      true
    );
  }, "reduceRight"),
  reverse: __name(function reverse() {
    return reify(this, reverseFactory(this, true));
  }, "reverse"),
  slice: __name(function slice(begin, end2) {
    return reify(this, sliceFactory(this, begin, end2, true));
  }, "slice"),
  some: __name(function some(predicate, context) {
    return !this.every(not(predicate), context);
  }, "some"),
  sort: __name(function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  }, "sort"),
  values: __name(function values() {
    return this.__iterator(ITERATE_VALUES);
  }, "values"),
  butLast: __name(function butLast() {
    return this.slice(0, -1);
  }, "butLast"),
  isEmpty: __name(function isEmpty() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  }, "isEmpty"),
  count: __name(function count(predicate, context) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context) : this
    );
  }, "count"),
  countBy: __name(function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  }, "countBy"),
  equals: __name(function equals(other) {
    return deepEqual(this, other);
  }, "equals"),
  entrySeq: __name(function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  }, "entrySeq"),
  filterNot: __name(function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  }, "filterNot"),
  findEntry: __name(function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v5, k5, c5) {
      if (predicate.call(context, v5, k5, c5)) {
        found = [k5, v5];
        return false;
      }
    });
    return found;
  }, "findEntry"),
  findKey: __name(function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  }, "findKey"),
  findLast: __name(function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  }, "findLast"),
  findLastEntry: __name(function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
  }, "findLastEntry"),
  findLastKey: __name(function findLastKey(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  }, "findLastKey"),
  first: __name(function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  }, "first"),
  flatMap: __name(function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  }, "flatMap"),
  flatten: __name(function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  }, "flatten"),
  fromEntrySeq: __name(function fromEntrySeq() {
    return new FromEntriesSequence(this);
  }, "fromEntrySeq"),
  get: __name(function get7(searchKey, notSetValue) {
    return this.find(function(_5, key) {
      return is(key, searchKey);
    }, void 0, notSetValue);
  }, "get"),
  getIn,
  groupBy: __name(function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  }, "groupBy"),
  has: __name(function has2(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  }, "has"),
  hasIn,
  isSubset: __name(function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  }, "isSubset"),
  isSuperset: __name(function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  }, "isSuperset"),
  keyOf: __name(function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is(value, searchValue);
    });
  }, "keyOf"),
  keySeq: __name(function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  }, "keySeq"),
  last: __name(function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  }, "last"),
  lastKeyOf: __name(function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  }, "lastKeyOf"),
  max: __name(function max(comparator) {
    return maxFactory(this, comparator);
  }, "max"),
  maxBy: __name(function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  }, "maxBy"),
  min: __name(function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  }, "min"),
  minBy: __name(function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  }, "minBy"),
  rest: __name(function rest() {
    return this.slice(1);
  }, "rest"),
  skip: __name(function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  }, "skip"),
  skipLast: __name(function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  }, "skipLast"),
  skipWhile: __name(function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  }, "skipWhile"),
  skipUntil: __name(function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  }, "skipUntil"),
  sortBy: __name(function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  }, "sortBy"),
  take: __name(function take(amount) {
    return this.slice(0, Math.max(0, amount));
  }, "take"),
  takeLast: __name(function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  }, "takeLast"),
  takeWhile: __name(function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  }, "takeWhile"),
  takeUntil: __name(function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  }, "takeUntil"),
  update: __name(function update7(fn2) {
    return fn2(this);
  }, "update"),
  valueSeq: __name(function valueSeq() {
    return this.toIndexedSeq();
  }, "valueSeq"),
  hashCode: __name(function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }, "hashCode")
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  flip: __name(function flip() {
    return reify(this, flipFactory(this));
  }, "flip"),
  mapEntries: __name(function mapEntries(mapper, context) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(
      this,
      this.toSeq().map(function(v5, k5) {
        return mapper.call(context, [k5, v5], iterations++, this$1$1);
      }).fromEntrySeq()
    );
  }, "mapEntries"),
  mapKeys: __name(function mapKeys(mapper, context) {
    var this$1$1 = this;
    return reify(
      this,
      this.toSeq().flip().map(function(k5, v5) {
        return mapper.call(context, k5, v5, this$1$1);
      }).flip()
    );
  }, "mapKeys")
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v5, k5) {
  return quoteString(k5) + ": " + quoteString(v5);
};
mixin(IndexedCollection, {
  toKeyedSeq: __name(function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  }, "toKeyedSeq"),
  filter: __name(function filter2(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  }, "filter"),
  findIndex: __name(function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  }, "findIndex"),
  indexOf: __name(function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === void 0 ? -1 : key;
  }, "indexOf"),
  lastIndexOf: __name(function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === void 0 ? -1 : key;
  }, "lastIndexOf"),
  reverse: __name(function reverse2() {
    return reify(this, reverseFactory(this, false));
  }, "reverse"),
  slice: __name(function slice2(begin, end2) {
    return reify(this, sliceFactory(this, begin, end2, false));
  }, "slice"),
  splice: __name(function splice(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  }, "splice"),
  findLastIndex: __name(function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  }, "findLastIndex"),
  first: __name(function first2(notSetValue) {
    return this.get(0, notSetValue);
  }, "first"),
  flatten: __name(function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, false));
  }, "flatten"),
  get: __name(function get8(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_5, key) {
      return key === index;
    }, void 0, notSetValue);
  }, "get"),
  has: __name(function has3(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
  }, "has"),
  interpose: __name(function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  }, "interpose"),
  interleave: __name(function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  }, "interleave"),
  keySeq: __name(function keySeq2() {
    return Range(0, this.size);
  }, "keySeq"),
  last: __name(function last2(notSetValue) {
    return this.get(-1, notSetValue);
  }, "last"),
  skipWhile: __name(function skipWhile2(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  }, "skipWhile"),
  zip: __name(function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  }, "zip"),
  zipAll: __name(function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  }, "zipAll"),
  zipWith: __name(function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }, "zipWith")
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  get: __name(function get9(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  }, "get"),
  includes: __name(function includes2(value) {
    return this.has(value);
  }, "includes"),
  keySeq: __name(function keySeq3() {
    return this.valueSeq();
  }, "keySeq")
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function reduce(collection, reducer, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v5, k5, c5) {
    if (useFirst) {
      useFirst = false;
      reduction = v5;
    } else {
      reduction = reducer.call(context, reduction, v5, k5, c5);
    }
  }, reverse3);
  return reduction;
}
__name(reduce, "reduce");
function keyMapper(v5, k5) {
  return k5;
}
__name(keyMapper, "keyMapper");
function entryMapper(v5, k5) {
  return [k5, v5];
}
__name(entryMapper, "entryMapper");
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
__name(not, "not");
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
__name(neg, "neg");
function defaultZipper() {
  return arrCopy(arguments);
}
__name(defaultZipper, "defaultZipper");
function defaultNegComparator(a5, b5) {
  return a5 < b5 ? 1 : a5 > b5 ? -1 : 0;
}
__name(defaultNegComparator, "defaultNegComparator");
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h4 = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed ? ordered ? function(v5, k5) {
      h4 = 31 * h4 + hashMerge(hash(v5), hash(k5)) | 0;
    } : function(v5, k5) {
      h4 = h4 + hashMerge(hash(v5), hash(k5)) | 0;
    } : ordered ? function(v5) {
      h4 = 31 * h4 + hash(v5) | 0;
    } : function(v5) {
      h4 = h4 + hash(v5) | 0;
    }
  );
  return murmurHashOfSize(size, h4);
}
__name(hashCollection, "hashCollection");
function murmurHashOfSize(size, h4) {
  h4 = imul(h4, 3432918353);
  h4 = imul(h4 << 15 | h4 >>> -15, 461845907);
  h4 = imul(h4 << 13 | h4 >>> -13, 5);
  h4 = (h4 + 3864292196 | 0) ^ size;
  h4 = imul(h4 ^ h4 >>> 16, 2246822507);
  h4 = imul(h4 ^ h4 >>> 13, 3266489909);
  h4 = smi(h4 ^ h4 >>> 16);
  return h4;
}
__name(murmurHashOfSize, "murmurHashOfSize");
function hashMerge(a5, b5) {
  return a5 ^ b5 + 2654435769 + (a5 << 6) + (a5 >> 2) | 0;
}
__name(hashMerge, "hashMerge");
var OrderedSet = function(Set22) {
  function OrderedSet2(value) {
    return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v5) {
        return set3.add(v5);
      });
    });
  }
  __name(OrderedSet2, "OrderedSet");
  if (Set22)
    OrderedSet2.__proto__ = Set22;
  OrderedSet2.prototype = Object.create(Set22 && Set22.prototype);
  OrderedSet2.prototype.constructor = OrderedSet2;
  OrderedSet2.of = __name(function of() {
    return this(arguments);
  }, "of");
  OrderedSet2.fromKeys = __name(function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  }, "fromKeys");
  OrderedSet2.prototype.toString = __name(function toString5() {
    return this.__toString("OrderedSet {", "}");
  }, "toString");
  return OrderedSet2;
}(Set2);
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map2, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
__name(makeOrderedSet, "makeOrderedSet");
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
__name(emptyOrderedSet, "emptyOrderedSet");
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
__name(throwOnInvalidDefaultValues, "throwOnInvalidDefaultValues");
var Record = __name(function Record2(defaultValues, name) {
  var hasInitialized;
  throwOnInvalidDefaultValues(defaultValues);
  var RecordType = __name(function Record3(values23) {
    var this$1$1 = this;
    if (values23 instanceof RecordType) {
      return values23;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values23);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys22 = Object.keys(defaultValues);
      var indices = RecordTypePrototype._indices = {};
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys22;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i4 = 0; i4 < keys22.length; i4++) {
        var propName = keys22[i4];
        indices[propName] = i4;
        if (RecordTypePrototype[propName]) {
          typeof console === "object" && console.warn && console.warn(
            "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
          );
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = void 0;
    this._values = List().withMutations(function(l4) {
      l4.setSize(this$1$1._keys.length);
      KeyedCollection(values23).forEach(function(v5, k5) {
        l4.set(this$1$1._indices[k5], v5 === this$1$1._defaultValues[k5] ? void 0 : v5);
      });
    });
    return this;
  }, "Record");
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  if (name) {
    RecordType.displayName = name;
  }
  return RecordType;
}, "Record");
Record.prototype.toString = __name(function toString4() {
  var str2 = recordName(this) + " { ";
  var keys22 = this._keys;
  var k5;
  for (var i4 = 0, l4 = keys22.length; i4 !== l4; i4++) {
    k5 = keys22[i4];
    str2 += (i4 ? ", " : "") + k5 + ": " + quoteString(this.get(k5));
  }
  return str2 + " }";
}, "toString");
Record.prototype.equals = __name(function equals2(other) {
  return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
}, "equals");
Record.prototype.hashCode = __name(function hashCode2() {
  return recordSeq(this).hashCode();
}, "hashCode");
Record.prototype.has = __name(function has4(k5) {
  return this._indices.hasOwnProperty(k5);
}, "has");
Record.prototype.get = __name(function get10(k5, notSetValue) {
  if (!this.has(k5)) {
    return notSetValue;
  }
  var index = this._indices[k5];
  var value = this._values.get(index);
  return value === void 0 ? this._defaultValues[k5] : value;
}, "get");
Record.prototype.set = __name(function set2(k5, v5) {
  if (this.has(k5)) {
    var newValues = this._values.set(
      this._indices[k5],
      v5 === this._defaultValues[k5] ? void 0 : v5
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
}, "set");
Record.prototype.remove = __name(function remove2(k5) {
  return this.set(k5);
}, "remove");
Record.prototype.clear = __name(function clear() {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
}, "clear");
Record.prototype.wasAltered = __name(function wasAltered2() {
  return this._values.wasAltered();
}, "wasAltered");
Record.prototype.toSeq = __name(function toSeq2() {
  return recordSeq(this);
}, "toSeq");
Record.prototype.toJS = __name(function toJS$12() {
  return toJS(this);
}, "toJS$1");
Record.prototype.entries = __name(function entries2() {
  return this.__iterator(ITERATE_ENTRIES);
}, "entries");
Record.prototype.__iterator = __name(function __iterator(type, reverse3) {
  return recordSeq(this).__iterator(type, reverse3);
}, "__iterator");
Record.prototype.__iterate = __name(function __iterate(fn2, reverse3) {
  return recordSeq(this).__iterate(fn2, reverse3);
}, "__iterate");
Record.prototype.__ensureOwner = __name(function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
}, "__ensureOwner");
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge$1;
RecordPrototype.mergeWith = mergeWith$1;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn;
RecordPrototype.update = update;
RecordPrototype.updateIn = updateIn;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};
function makeRecord(likeRecord, values23, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values23;
  record.__ownerID = ownerID;
  return record;
}
__name(makeRecord, "makeRecord");
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
__name(recordName, "recordName");
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k5) {
    return [k5, record.get(k5)];
  }));
}
__name(recordSeq, "recordSeq");
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value);
      }
    });
  } catch (error) {
  }
}
__name(setProp, "setProp");
var Repeat = function(IndexedSeq2) {
  function Repeat2(value, times) {
    if (!(this instanceof Repeat2)) {
      return new Repeat2(value, times);
    }
    this._value = value;
    this.size = times === void 0 ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }
  __name(Repeat2, "Repeat");
  if (IndexedSeq2)
    Repeat2.__proto__ = IndexedSeq2;
  Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Repeat2.prototype.constructor = Repeat2;
  Repeat2.prototype.toString = __name(function toString5() {
    if (this.size === 0) {
      return "Repeat []";
    }
    return "Repeat [ " + this._value + " " + this.size + " times ]";
  }, "toString");
  Repeat2.prototype.get = __name(function get11(index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  }, "get");
  Repeat2.prototype.includes = __name(function includes3(searchValue) {
    return is(this._value, searchValue);
  }, "includes");
  Repeat2.prototype.slice = __name(function slice3(begin, end2) {
    var size = this.size;
    return wholeSlice(begin, end2, size) ? this : new Repeat2(
      this._value,
      resolveEnd(end2, size) - resolveBegin(begin, size)
    );
  }, "slice");
  Repeat2.prototype.reverse = __name(function reverse3() {
    return this;
  }, "reverse");
  Repeat2.prototype.indexOf = __name(function indexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  }, "indexOf");
  Repeat2.prototype.lastIndexOf = __name(function lastIndexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  }, "lastIndexOf");
  Repeat2.prototype.__iterate = __name(function __iterate2(fn2, reverse3) {
    var size = this.size;
    var i4 = 0;
    while (i4 !== size) {
      if (fn2(this._value, reverse3 ? size - ++i4 : i4++, this) === false) {
        break;
      }
    }
    return i4;
  }, "__iterate");
  Repeat2.prototype.__iterator = __name(function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var size = this.size;
    var i4 = 0;
    return new Iterator(
      function() {
        return i4 === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i4 : i4++, this$1$1._value);
      }
    );
  }, "__iterator");
  Repeat2.prototype.equals = __name(function equals3(other) {
    return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual(other);
  }, "equals");
  return Repeat2;
}(IndexedSeq);
var EMPTY_REPEAT;
init_define_process();
var import_fast_diff = __toESM(require_diff(), 1);
function createDelta(original, revision) {
  var result = (0, import_fast_diff.default)(original, revision);
  const delta = result.map(
    (r5) => r5[0] === 1 ? r5 : [r5[0], r5[1].length]
  );
  return delta;
}
__name(createDelta, "createDelta");
function applyPatch(original, delta) {
  var result = "", index = 0;
  for (var i4 = 0; i4 < delta.length; i4++) {
    var item = delta[i4], operation = item[0], value = item[1];
    if (item[0] === -1 && typeof value === "number") {
      index += value;
    } else if (operation == 0 && typeof value === "number") {
      result += original.slice(index, index += value);
    } else {
      result += value;
    }
  }
  return result;
}
__name(applyPatch, "applyPatch");
function initSession(room, u4) {
  return Record({ ...u4, room, state: Record(u4.state)() });
}
__name(initSession, "initSession");
var session = null;
var hashStore = {};
var CodeSession = class {
  constructor(room, user2) {
    __publicField(this, "session");
    __publicField(this, "cb", {});
    __publicField(this, "hashCodeSession", 0);
    __publicField(this, "room");
    __publicField(this, "created", new Date().toISOString());
    __publicField(this, "hashOfState", __name(() => {
      const state = this.session.get("state");
      const hashCode4 = state.hashCode();
      hashStore[hashCode4] = state;
      return hashCode4;
    }, "hashOfState"));
    __publicField(this, "createPatchFromHashCode", __name(async (oldHash, state) => {
      const s4 = JSON.parse(str(state));
      if (!hashStore[oldHash]) {
        const resp = await fetch(
          `/live/${this.room}
        `
        );
        const { mST: mST2, hashCode: hashCode4 } = await resp.json();
        hashStore[hashCode4] = this.session.get("state").merge(mST2);
      }
      const oldRec = hashStore[oldHash];
      const oldStr = str(oldRec.toJSON());
      const newRec = oldRec.merge(s4);
      const newStr = str(newRec.toJSON());
      const newHash = newRec.hashCode();
      hashStore[newHash] = newRec;
      const patch = createPatch(oldStr, newStr);
      return {
        oldHash,
        newHash,
        patch
      };
    }, "createPatchFromHashCode"));
    __publicField(this, "patchSync", __name((sess) => {
      this.session = this.session.set(
        "state",
        this.session.get("state").merge(sess)
      );
      this.update();
    }, "patchSync"));
    __publicField(this, "applyPatch", __name(async ({
      oldHash,
      newHash,
      patch
    }) => {
      const codeSpace2 = this.room || "";
      if (!Object.keys(hashStore).map((x5) => Number(x5)).includes(
        Number(oldHash)
      ) && codeSpace2) {
        console.log(Object.keys(hashStore));
        const resp = await fetch(
          `/live/${codeSpace2}/mST`
        );
        if (resp.ok) {
          const s4 = await resp.json();
          const serverRecord = this.session.get("state").merge(
            JSON.parse(str(s4.mST))
          );
          hashStore[serverRecord.hashCode()] = serverRecord;
        } else {
          const { mST: mST2 } = await import(
            /* @vite-ignore */
            location.origin + `/live/${this.room}/mst.mjs?${Date.now()}`
          );
          const latestRec = this.session.get("state").merge(
            JSON.parse(str(mST2))
          );
          hashStore[latestRec.hashCode()] = latestRec;
        }
      }
      const oldStr = str(hashStore[oldHash].toJSON());
      const applied = applyPatch(oldStr, patch);
      const newState = JSON.parse(applied);
      const newRec = this.session.get("state").merge(
        newState
      );
      const newRecord = this.session.get("state").merge(newRec);
      const newHashCheck = newRecord.hashCode();
      if (newHashCheck === newHash) {
        this.session = this.session.set("state", newRecord);
      } else {
        new Error("Wrong patch");
        return;
      }
    }, "applyPatch"));
    session = this;
    this.room = room;
    const savedState = null;
    this.session = initSession(room, {
      ...user2,
      state: savedState ? savedState : JSON.parse(str(user2.state))
    })();
  }
  update() {
    Object.keys(this.cb).map((k5) => this.cb[k5]).map((x5) => {
      try {
        x5(true);
      } catch (err) {
        console.error("error calling callback", { err });
      }
    });
  }
  onUpdate(fn2, regId) {
    this.cb[regId] = fn2;
  }
  json() {
    const user2 = this.session.toJSON();
    const state = user2.state.toJSON();
    return { ...user2, state };
  }
  setRoom(codeSpace2) {
    const user2 = this.session.set("room", codeSpace2);
    this.session = user2;
  }
};
__name(CodeSession, "CodeSession");
var hashCode3 = __name(() => session ? session.hashOfState() : 0, "hashCode");
var mST = __name(() => {
  if (!session) {
    return {
      i: 0,
      transpiled: "",
      code: "",
      html: "",
      css: ""
    };
  }
  const { i: i4, transpiled, code, html, css } = session.json().state;
  return { i: i4, transpiled, code, html, css };
}, "mST");
function addOrigin(s4, originStr) {
  const { i: i4, transpiled, code, html, css } = s4;
  const mst = { i: i4, transpiled, code, html, css };
  mst.code = mst.code.replace(`from '/live`, `from '${originStr}/live`);
  mst.code = mst.code.replace(`from './`, `from '${originStr}/live/`);
  mst.transpiled = mst.transpiled.replace(
    `from "/live`,
    `from "${originStr}/live`
  );
  mst.transpiled = mst.transpiled.replace(
    `from "./`,
    `from "${originStr}/live/`
  );
  return mst;
}
__name(addOrigin, "addOrigin");
function str(s4) {
  const { i: i4, transpiled, code, html, css } = s4;
  return JSON.stringify({ i: i4, transpiled, code, html, css });
}
__name(str, "str");
var applyPatch2 = __name(async (x5) => {
  await session?.applyPatch(x5);
  session?.update();
}, "applyPatch");
var onSessionUpdate = __name((fn2, regId = "default") => session?.onUpdate(fn2, regId), "onSessionUpdate");
var makePatchFrom = __name((n3, st) => session.createPatchFromHashCode(n3, st), "makePatchFrom");
var makePatch = __name((st) => makePatchFrom(hashCode3(), st), "makePatch");
var startSession = __name((room, u4, originStr) => session || new CodeSession(room, { name: u4.name, state: addOrigin(u4.state, originStr) }), "startSession");
function createPatch(oldCode, newCode) {
  return createDelta(oldCode, newCode);
}
__name(createPatch, "createPatch");
var patchSync = __name((sess) => session?.patchSync(sess), "patchSync");

// dist/chunk-chunk-BKZY7FJ5.mjs
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => d,
  Fragment: () => p,
  cloneElement: () => q,
  createContext: () => B,
  createElement: () => h,
  createRef: () => y,
  h: () => h,
  hydrate: () => S,
  isValidElement: () => i,
  options: () => l,
  render: () => P,
  toChildArray: () => x
});
function s(n3, l4) {
  for (var u4 in l4)
    n3[u4] = l4[u4];
  return n3;
}
function a(n3) {
  var l4 = n3.parentNode;
  l4 && l4.removeChild(n3);
}
function h(l4, u4, i4) {
  var t3, o5, r42, f4 = {};
  for (r42 in u4)
    "key" == r42 ? t3 = u4[r42] : "ref" == r42 ? o5 = u4[r42] : f4[r42] = u4[r42];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), "function" == typeof l4 && null != l4.defaultProps)
    for (r42 in l4.defaultProps)
      void 0 === f4[r42] && (f4[r42] = l4.defaultProps[r42]);
  return v(l4, f4, t3, o5, null);
}
function v(n3, i4, t3, o5, r42) {
  var f4 = { type: n3, props: i4, key: t3, ref: o5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r42 ? ++u : r42 };
  return null == r42 && null != l.vnode && l.vnode(f4), f4;
}
function y() {
  return { current: null };
}
function p(n3) {
  return n3.children;
}
function d(n3, l4) {
  this.props = n3, this.context = l4;
}
function _(n3, l4) {
  if (null == l4)
    return n3.__ ? _(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u4; l4 < n3.__k.length; l4++)
    if (null != (u4 = n3.__k[l4]) && null != u4.__e)
      return u4.__e;
  return "function" == typeof n3.type ? _(n3) : null;
}
function k(n3) {
  var l4, u4;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++)
      if (null != (u4 = n3.__k[l4]) && null != u4.__e) {
        n3.__e = n3.__c.base = u4.__e;
        break;
      }
    return k(n3);
  }
}
function b(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
  for (var n3; g.__r = t.length; )
    n3 = t.sort(function(n4, l4) {
      return n4.__v.__b - l4.__v.__b;
    }), t = [], n3.some(function(n4) {
      var l4, u4, i4, t3, o5, r42;
      n4.__d && (o5 = (t3 = (l4 = n4).__v).__e, (r42 = l4.__P) && (u4 = [], (i4 = s({}, t3)).__v = t3.__v + 1, j(r42, t3, i4, l4.__n, void 0 !== r42.ownerSVGElement, null != t3.__h ? [o5] : null, u4, null == o5 ? _(t3) : o5, t3.__h), z(u4, t3), t3.__e != o5 && k(t3)));
    });
}
function w(n3, l4, u4, i4, t3, o5, r42, c42, s4, a42) {
  var h4, y4, d4, k5, b42, g5, w4, x5 = i4 && i4.__k || e, C3 = x5.length;
  for (u4.__k = [], h4 = 0; h4 < l4.length; h4++)
    if (null != (k5 = u4.__k[h4] = null == (k5 = l4[h4]) || "boolean" == typeof k5 ? null : "string" == typeof k5 || "number" == typeof k5 || "bigint" == typeof k5 ? v(null, k5, null, null, k5) : Array.isArray(k5) ? v(p, { children: k5 }, null, null, null) : k5.__b > 0 ? v(k5.type, k5.props, k5.key, null, k5.__v) : k5)) {
      if (k5.__ = u4, k5.__b = u4.__b + 1, null === (d4 = x5[h4]) || d4 && k5.key == d4.key && k5.type === d4.type)
        x5[h4] = void 0;
      else
        for (y4 = 0; y4 < C3; y4++) {
          if ((d4 = x5[y4]) && k5.key == d4.key && k5.type === d4.type) {
            x5[y4] = void 0;
            break;
          }
          d4 = null;
        }
      j(n3, k5, d4 = d4 || f, t3, o5, r42, c42, s4, a42), b42 = k5.__e, (y4 = k5.ref) && d4.ref != y4 && (w4 || (w4 = []), d4.ref && w4.push(d4.ref, null, k5), w4.push(y4, k5.__c || b42, k5)), null != b42 ? (null == g5 && (g5 = b42), "function" == typeof k5.type && k5.__k === d4.__k ? k5.__d = s4 = m(k5, s4, n3) : s4 = A(n3, k5, d4, x5, b42, s4), "function" == typeof u4.type && (u4.__d = s4)) : s4 && d4.__e == s4 && s4.parentNode != n3 && (s4 = _(d4));
    }
  for (u4.__e = g5, h4 = C3; h4--; )
    null != x5[h4] && ("function" == typeof u4.type && null != x5[h4].__e && x5[h4].__e == u4.__d && (u4.__d = _(i4, h4 + 1)), N(x5[h4], x5[h4]));
  if (w4)
    for (h4 = 0; h4 < w4.length; h4++)
      M(w4[h4], w4[++h4], w4[++h4]);
}
function m(n3, l4, u4) {
  for (var i4, t3 = n3.__k, o5 = 0; t3 && o5 < t3.length; o5++)
    (i4 = t3[o5]) && (i4.__ = n3, l4 = "function" == typeof i4.type ? m(i4, l4, u4) : A(u4, i4, i4, t3, i4.__e, l4));
  return l4;
}
function x(n3, l4) {
  return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (Array.isArray(n3) ? n3.some(function(n4) {
    x(n4, l4);
  }) : l4.push(n3)), l4;
}
function A(n3, l4, u4, i4, t3, o5) {
  var r42, f4, e4;
  if (void 0 !== l4.__d)
    r42 = l4.__d, l4.__d = void 0;
  else if (null == u4 || t3 != o5 || null == t3.parentNode)
    n:
      if (null == o5 || o5.parentNode !== n3)
        n3.appendChild(t3), r42 = null;
      else {
        for (f4 = o5, e4 = 0; (f4 = f4.nextSibling) && e4 < i4.length; e4 += 2)
          if (f4 == t3)
            break n;
        n3.insertBefore(t3, o5), r42 = o5;
      }
  return void 0 !== r42 ? r42 : t3.nextSibling;
}
function C(n3, l4, u4, i4, t3) {
  var o5;
  for (o5 in u4)
    "children" === o5 || "key" === o5 || o5 in l4 || H(n3, o5, null, u4[o5], i4);
  for (o5 in l4)
    t3 && "function" != typeof l4[o5] || "children" === o5 || "key" === o5 || "value" === o5 || "checked" === o5 || u4[o5] === l4[o5] || H(n3, o5, l4[o5], u4[o5], i4);
}
function $(n3, l4, u4) {
  "-" === l4[0] ? n3.setProperty(l4, u4) : n3[l4] = null == u4 ? "" : "number" != typeof u4 || c.test(l4) ? u4 : u4 + "px";
}
function H(n3, l4, u4, i4, t3) {
  var o5;
  n:
    if ("style" === l4)
      if ("string" == typeof u4)
        n3.style.cssText = u4;
      else {
        if ("string" == typeof i4 && (n3.style.cssText = i4 = ""), i4)
          for (l4 in i4)
            u4 && l4 in u4 || $(n3.style, l4, "");
        if (u4)
          for (l4 in u4)
            i4 && u4[l4] === i4[l4] || $(n3.style, l4, u4[l4]);
      }
    else if ("o" === l4[0] && "n" === l4[1])
      o5 = l4 !== (l4 = l4.replace(/Capture$/, "")), l4 = l4.toLowerCase() in n3 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + o5] = u4, u4 ? i4 || n3.addEventListener(l4, o5 ? T : I, o5) : n3.removeEventListener(l4, o5 ? T : I, o5);
    else if ("dangerouslySetInnerHTML" !== l4) {
      if (t3)
        l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && l4 in n3)
        try {
          n3[l4] = null == u4 ? "" : u4;
          break n;
        } catch (n4) {
        }
      "function" == typeof u4 || (null != u4 && (false !== u4 || "a" === l4[0] && "r" === l4[1]) ? n3.setAttribute(l4, u4) : n3.removeAttribute(l4));
    }
}
function I(n3) {
  this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function T(n3) {
  this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function j(n3, u4, i4, t3, o5, r42, f4, e4, c42) {
  var a42, h4, v42, y4, _42, k5, b42, g5, m42, x5, A4, C3, $3, H3 = u4.type;
  if (void 0 !== u4.constructor)
    return null;
  null != i4.__h && (c42 = i4.__h, e4 = u4.__e = i4.__e, u4.__h = null, r42 = [e4]), (a42 = l.__b) && a42(u4);
  try {
    n:
      if ("function" == typeof H3) {
        if (g5 = u4.props, m42 = (a42 = H3.contextType) && t3[a42.__c], x5 = a42 ? m42 ? m42.props.value : a42.__ : t3, i4.__c ? b42 = (h4 = u4.__c = i4.__c).__ = h4.__E : ("prototype" in H3 && H3.prototype.render ? u4.__c = h4 = new H3(g5, x5) : (u4.__c = h4 = new d(g5, x5), h4.constructor = H3, h4.render = O), m42 && m42.sub(h4), h4.props = g5, h4.state || (h4.state = {}), h4.context = x5, h4.__n = t3, v42 = h4.__d = true, h4.__h = []), null == h4.__s && (h4.__s = h4.state), null != H3.getDerivedStateFromProps && (h4.__s == h4.state && (h4.__s = s({}, h4.__s)), s(h4.__s, H3.getDerivedStateFromProps(g5, h4.__s))), y4 = h4.props, _42 = h4.state, v42)
          null == H3.getDerivedStateFromProps && null != h4.componentWillMount && h4.componentWillMount(), null != h4.componentDidMount && h4.__h.push(h4.componentDidMount);
        else {
          if (null == H3.getDerivedStateFromProps && g5 !== y4 && null != h4.componentWillReceiveProps && h4.componentWillReceiveProps(g5, x5), !h4.__e && null != h4.shouldComponentUpdate && false === h4.shouldComponentUpdate(g5, h4.__s, x5) || u4.__v === i4.__v) {
            h4.props = g5, h4.state = h4.__s, u4.__v !== i4.__v && (h4.__d = false), h4.__v = u4, u4.__e = i4.__e, u4.__k = i4.__k, u4.__k.forEach(function(n4) {
              n4 && (n4.__ = u4);
            }), h4.__h.length && f4.push(h4);
            break n;
          }
          null != h4.componentWillUpdate && h4.componentWillUpdate(g5, h4.__s, x5), null != h4.componentDidUpdate && h4.__h.push(function() {
            h4.componentDidUpdate(y4, _42, k5);
          });
        }
        if (h4.context = x5, h4.props = g5, h4.__v = u4, h4.__P = n3, A4 = l.__r, C3 = 0, "prototype" in H3 && H3.prototype.render)
          h4.state = h4.__s, h4.__d = false, A4 && A4(u4), a42 = h4.render(h4.props, h4.state, h4.context);
        else
          do {
            h4.__d = false, A4 && A4(u4), a42 = h4.render(h4.props, h4.state, h4.context), h4.state = h4.__s;
          } while (h4.__d && ++C3 < 25);
        h4.state = h4.__s, null != h4.getChildContext && (t3 = s(s({}, t3), h4.getChildContext())), v42 || null == h4.getSnapshotBeforeUpdate || (k5 = h4.getSnapshotBeforeUpdate(y4, _42)), $3 = null != a42 && a42.type === p && null == a42.key ? a42.props.children : a42, w(n3, Array.isArray($3) ? $3 : [$3], u4, i4, t3, o5, r42, f4, e4, c42), h4.base = u4.__e, u4.__h = null, h4.__h.length && f4.push(h4), b42 && (h4.__E = h4.__ = null), h4.__e = false;
      } else
        null == r42 && u4.__v === i4.__v ? (u4.__k = i4.__k, u4.__e = i4.__e) : u4.__e = L(i4.__e, u4, i4, t3, o5, r42, f4, c42);
    (a42 = l.diffed) && a42(u4);
  } catch (n4) {
    u4.__v = null, (c42 || null != r42) && (u4.__e = e4, u4.__h = !!c42, r42[r42.indexOf(e4)] = null), l.__e(n4, u4, i4);
  }
}
function z(n3, u4) {
  l.__c && l.__c(u4, n3), n3.some(function(u5) {
    try {
      n3 = u5.__h, u5.__h = [], n3.some(function(n4) {
        n4.call(u5);
      });
    } catch (n4) {
      l.__e(n4, u5.__v);
    }
  });
}
function L(l4, u4, i4, t3, o5, r42, e4, c42) {
  var s4, h4, v42, y4 = i4.props, p4 = u4.props, d4 = u4.type, k5 = 0;
  if ("svg" === d4 && (o5 = true), null != r42) {
    for (; k5 < r42.length; k5++)
      if ((s4 = r42[k5]) && "setAttribute" in s4 == !!d4 && (d4 ? s4.localName === d4 : 3 === s4.nodeType)) {
        l4 = s4, r42[k5] = null;
        break;
      }
  }
  if (null == l4) {
    if (null === d4)
      return document.createTextNode(p4);
    l4 = o5 ? document.createElementNS("http://www.w3.org/2000/svg", d4) : document.createElement(d4, p4.is && p4), r42 = null, c42 = false;
  }
  if (null === d4)
    y4 === p4 || c42 && l4.data === p4 || (l4.data = p4);
  else {
    if (r42 = r42 && n.call(l4.childNodes), h4 = (y4 = i4.props || f).dangerouslySetInnerHTML, v42 = p4.dangerouslySetInnerHTML, !c42) {
      if (null != r42)
        for (y4 = {}, k5 = 0; k5 < l4.attributes.length; k5++)
          y4[l4.attributes[k5].name] = l4.attributes[k5].value;
      (v42 || h4) && (v42 && (h4 && v42.__html == h4.__html || v42.__html === l4.innerHTML) || (l4.innerHTML = v42 && v42.__html || ""));
    }
    if (C(l4, p4, y4, o5, c42), v42)
      u4.__k = [];
    else if (k5 = u4.props.children, w(l4, Array.isArray(k5) ? k5 : [k5], u4, i4, t3, o5 && "foreignObject" !== d4, r42, e4, r42 ? r42[0] : i4.__k && _(i4, 0), c42), null != r42)
      for (k5 = r42.length; k5--; )
        null != r42[k5] && a(r42[k5]);
    c42 || ("value" in p4 && void 0 !== (k5 = p4.value) && (k5 !== l4.value || "progress" === d4 && !k5 || "option" === d4 && k5 !== y4.value) && H(l4, "value", k5, y4.value, false), "checked" in p4 && void 0 !== (k5 = p4.checked) && k5 !== l4.checked && H(l4, "checked", k5, y4.checked, false));
  }
  return l4;
}
function M(n3, u4, i4) {
  try {
    "function" == typeof n3 ? n3(u4) : n3.current = u4;
  } catch (n4) {
    l.__e(n4, i4);
  }
}
function N(n3, u4, i4) {
  var t3, o5;
  if (l.unmount && l.unmount(n3), (t3 = n3.ref) && (t3.current && t3.current !== n3.__e || M(t3, null, u4)), null != (t3 = n3.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n4) {
        l.__e(n4, u4);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = n3.__k)
    for (o5 = 0; o5 < t3.length; o5++)
      t3[o5] && N(t3[o5], u4, "function" != typeof n3.type);
  i4 || null == n3.__e || a(n3.__e), n3.__e = n3.__d = void 0;
}
function O(n3, l4, u4) {
  return this.constructor(n3, u4);
}
function P(u4, i4, t3) {
  var o5, r42, e4;
  l.__ && l.__(u4, i4), r42 = (o5 = "function" == typeof t3) ? null : t3 && t3.__k || i4.__k, e4 = [], j(i4, u4 = (!o5 && t3 || i4).__k = h(p, null, [u4]), r42 || f, f, void 0 !== i4.ownerSVGElement, !o5 && t3 ? [t3] : r42 ? null : i4.firstChild ? n.call(i4.childNodes) : null, e4, !o5 && t3 ? t3 : r42 ? r42.__e : i4.firstChild, o5), z(e4, u4);
}
function S(n3, l4) {
  P(n3, l4, S);
}
function q(l4, u4, i4) {
  var t3, o5, r42, f4 = s({}, l4.props);
  for (r42 in u4)
    "key" == r42 ? t3 = u4[r42] : "ref" == r42 ? o5 = u4[r42] : f4[r42] = u4[r42];
  return arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), v(l4.type, f4, t3 || l4.key, o5 || l4.ref, null);
}
function B(n3, l4) {
  var u4 = { __c: l4 = "__cC" + r++, __: n3, Consumer: function(n4, l5) {
    return n4.children(l5);
  }, Provider: function(n4) {
    var u5, i4;
    return this.getChildContext || (u5 = [], (i4 = {})[l4] = this, this.getChildContext = function() {
      return i4;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u5.some(b);
    }, this.sub = function(n5) {
      u5.push(n5);
      var l5 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u5.splice(u5.indexOf(n5), 1), l5 && l5.call(n5);
      };
    }), n4.children;
  } };
  return u4.Provider.__ = u4.Consumer.contextType = u4;
}
var n;
var l;
var u;
var i;
var t;
var o;
var r;
var f;
var e;
var c;
var init_preact_module = __esm({
  "../../../../.yarn/global/cache/preact-npm-10.10.6-e3746adb94-9c9.zip/node_modules/preact/dist/preact.module.js"() {
    init_define_process();
    f = {};
    e = [];
    c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    __name(s, "s");
    __name(a, "a");
    __name(h, "h");
    __name(v, "v");
    __name(y, "y");
    __name(p, "p");
    __name(d, "d");
    __name(_, "_");
    __name(k, "k");
    __name(b, "b");
    __name(g, "g");
    __name(w, "w");
    __name(m, "m");
    __name(x, "x");
    __name(A, "A");
    __name(C, "C");
    __name($, "$");
    __name(H, "H");
    __name(I, "I");
    __name(T, "T");
    __name(j, "j");
    __name(z, "z");
    __name(L, "L");
    __name(M, "M");
    __name(N, "N");
    __name(O, "O");
    __name(P, "P");
    __name(S, "S");
    __name(q, "q");
    __name(B, "B");
    n = e.slice, l = { __e: function(n3, l4, u4, i4) {
      for (var t3, o5, r42; l4 = l4.__; )
        if ((t3 = l4.__c) && !t3.__)
          try {
            if ((o5 = t3.constructor) && null != o5.getDerivedStateFromError && (t3.setState(o5.getDerivedStateFromError(n3)), r42 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n3, i4 || {}), r42 = t3.__d), r42)
              return t3.__E = t3;
          } catch (l5) {
            n3 = l5;
          }
      throw n3;
    } }, u = 0, i = __name(function(n3) {
      return null != n3 && void 0 === n3.constructor;
    }, "i"), d.prototype.setState = function(n3, l4) {
      var u4;
      u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n3 && (n3 = n3(s({}, u4), this.props)), n3 && s(u4, n3), null != n3 && this.__v && (l4 && this.__h.push(l4), b(this));
    }, d.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), b(this));
    }, d.prototype.render = p, t = [], g.__r = 0, r = 0;
  }
});
function d2(t3, u4) {
  l.__h && l.__h(r2, t3, o2 || u4), o2 = 0;
  var i4 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t3 >= i4.__.length && i4.__.push({ __V: f2 }), i4.__[t3];
}
function p2(n3) {
  return o2 = 1, y2(z2, n3);
}
function y2(n3, u4, i4) {
  var o5 = d2(t2++, 2);
  if (o5.t = n3, !o5.__c && (o5.__ = [i4 ? i4(u4) : z2(void 0, u4), function(n4) {
    var t3 = o5.__N ? o5.__N[0] : o5.__[0], r42 = o5.t(t3, n4);
    t3 !== r42 && (o5.__N = [r42, o5.__[1]], o5.__c.setState({}));
  }], o5.__c = r2, !r2.u)) {
    r2.u = true;
    var c42 = r2.shouldComponentUpdate;
    r2.shouldComponentUpdate = function(n4, t3, r42) {
      if (!o5.__c.__H)
        return true;
      var u5 = o5.__c.__H.__.filter(function(n5) {
        return n5.__c;
      });
      if (u5.every(function(n5) {
        return !n5.__N;
      }))
        return !c42 || c42.call(this, n4, t3, r42);
      var i5 = false;
      return u5.forEach(function(n5) {
        if (n5.__N) {
          var t4 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t4 !== n5.__[0] && (i5 = true);
        }
      }), !!i5 && (!c42 || c42.call(this, n4, t3, r42));
    };
  }
  return o5.__N || o5.__;
}
function h2(u4, i4) {
  var o5 = d2(t2++, 3);
  !l.__s && w2(o5.__H, i4) && (o5.__ = u4, o5.i = i4, r2.__H.__h.push(o5));
}
function s2(u4, i4) {
  var o5 = d2(t2++, 4);
  !l.__s && w2(o5.__H, i4) && (o5.__ = u4, o5.i = i4, r2.__h.push(o5));
}
function _2(n3) {
  return o2 = 5, F(function() {
    return { current: n3 };
  }, []);
}
function A2(n3, t3, r42) {
  o2 = 6, s2(function() {
    return "function" == typeof n3 ? (n3(t3()), function() {
      return n3(null);
    }) : n3 ? (n3.current = t3(), function() {
      return n3.current = null;
    }) : void 0;
  }, null == r42 ? r42 : r42.concat(n3));
}
function F(n3, r42) {
  var u4 = d2(t2++, 7);
  return w2(u4.__H, r42) ? (u4.__V = n3(), u4.i = r42, u4.__h = n3, u4.__V) : u4.__;
}
function T2(n3, t3) {
  return o2 = 8, F(function() {
    return n3;
  }, t3);
}
function q2(n3) {
  var u4 = r2.context[n3.__c], i4 = d2(t2++, 9);
  return i4.c = n3, u4 ? (null == i4.__ && (i4.__ = true, u4.sub(r2)), u4.props.value) : n3.__;
}
function x2(t3, r42) {
  l.useDebugValue && l.useDebugValue(r42 ? r42(t3) : t3);
}
function b2() {
  for (var t3; t3 = c2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(j2), t3.__H.__h.forEach(k2), t3.__H.__h = [];
      } catch (r42) {
        t3.__H.__h = [], l.__e(r42, t3.__v);
      }
}
function j2(n3) {
  var t3 = r2, u4 = n3.__c;
  "function" == typeof u4 && (n3.__c = void 0, u4()), r2 = t3;
}
function k2(n3) {
  var t3 = r2;
  n3.__c = n3.__(), r2 = t3;
}
function w2(n3, t3) {
  return !n3 || n3.length !== t3.length || t3.some(function(t4, r42) {
    return t4 !== n3[r42];
  });
}
function z2(n3, t3) {
  return "function" == typeof t3 ? t3(n3) : t3;
}
var t2;
var r2;
var u2;
var i2;
var o2;
var c2;
var f2;
var e2;
var a2;
var v2;
var l2;
var m2;
var g2;
var init_hooks_module = __esm({
  "../../../../.yarn/global/cache/preact-npm-10.10.6-e3746adb94-9c9.zip/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_define_process();
    init_preact_module();
    o2 = 0;
    c2 = [];
    f2 = [];
    e2 = l.__b;
    a2 = l.__r;
    v2 = l.diffed;
    l2 = l.__c;
    m2 = l.unmount;
    __name(d2, "d");
    __name(p2, "p");
    __name(y2, "y");
    __name(h2, "h");
    __name(s2, "s");
    __name(_2, "_");
    __name(A2, "A");
    __name(F, "F");
    __name(T2, "T");
    __name(q2, "q");
    __name(x2, "x");
    __name(b2, "b");
    l.__b = function(n3) {
      r2 = null, e2 && e2(n3);
    }, l.__r = function(n3) {
      a2 && a2(n3), t2 = 0;
      var i4 = (r2 = n3.__c).__H;
      i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
        n4.__N && (n4.__ = n4.__N), n4.__V = f2, n4.__N = n4.i = void 0;
      })) : (i4.__h.forEach(j2), i4.__h.forEach(k2), i4.__h = [])), u2 = r2;
    }, l.diffed = function(t3) {
      v2 && v2(t3);
      var o5 = t3.__c;
      o5 && o5.__H && (o5.__H.__h.length && (1 !== c2.push(o5) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || function(n3) {
        var t4, r42 = __name(function() {
          clearTimeout(u4), g2 && cancelAnimationFrame(t4), setTimeout(n3);
        }, "r"), u4 = setTimeout(r42, 100);
        g2 && (t4 = requestAnimationFrame(r42));
      })(b2)), o5.__H.__.forEach(function(n3) {
        n3.i && (n3.__H = n3.i), n3.__V !== f2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = f2;
      })), u2 = r2 = null;
    }, l.__c = function(t3, r42) {
      r42.some(function(t4) {
        try {
          t4.__h.forEach(j2), t4.__h = t4.__h.filter(function(n3) {
            return !n3.__ || k2(n3);
          });
        } catch (u4) {
          r42.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), r42 = [], l.__e(u4, t4.__v);
        }
      }), l2 && l2(t3, r42);
    }, l.unmount = function(t3) {
      m2 && m2(t3);
      var r42, u4 = t3.__c;
      u4 && u4.__H && (u4.__H.__.forEach(function(n3) {
        try {
          j2(n3);
        } catch (n4) {
          r42 = n4;
        }
      }), r42 && l.__e(r42, u4.__v));
    };
    g2 = "function" == typeof requestAnimationFrame;
    __name(j2, "j");
    __name(k2, "k");
    __name(w2, "w");
    __name(z2, "z");
  }
});
function S2(n3, t3) {
  for (var e4 in t3)
    n3[e4] = t3[e4];
  return n3;
}
function g3(n3, t3) {
  for (var e4 in n3)
    if ("__source" !== e4 && !(e4 in t3))
      return true;
  for (var r42 in t3)
    if ("__source" !== r42 && n3[r42] !== t3[r42])
      return true;
  return false;
}
function C2(n3) {
  this.props = n3;
}
function E(n3, t3) {
  function e4(n4) {
    var e5 = this.props.ref, r5 = e5 == n4.ref;
    return !r5 && e5 && (e5.call ? e5(null) : e5.current = null), t3 ? !t3(this.props, n4) || !r5 : g3(this.props, n4);
  }
  __name(e4, "e");
  function r42(t4) {
    return this.shouldComponentUpdate = e4, h(n3, t4);
  }
  __name(r42, "r");
  return r42.displayName = "Memo(" + (n3.displayName || n3.name) + ")", r42.prototype.isReactComponent = true, r42.__f = true, r42;
}
function R(n3) {
  function t3(t4) {
    var e4 = S2({}, t4);
    return delete e4.ref, n3(e4, t4.ref || null);
  }
  __name(t3, "t");
  return t3.$$typeof = x3, t3.render = t3, t3.prototype.isReactComponent = t3.__f = true, t3.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t3;
}
function T3() {
  this.__u = 0, this.t = null, this.__b = null;
}
function L2(n3) {
  var t3 = n3.__.__c;
  return t3 && t3.__a && t3.__a(n3);
}
function U(n3) {
  var t3, e4, r42;
  function u4(u5) {
    if (t3 || (t3 = n3()).then(function(n4) {
      e4 = n4.default || n4;
    }, function(n4) {
      r42 = n4;
    }), r42)
      throw r42;
    if (!e4)
      throw t3;
    return h(e4, u5);
  }
  __name(u4, "u");
  return u4.displayName = "Lazy", u4.__f = true, u4;
}
function D() {
  this.u = null, this.o = null;
}
function I2(n3) {
  return this.getChildContext = function() {
    return n3.context;
  }, n3.children;
}
function M2(n3) {
  var t3 = this, e4 = n3.i;
  t3.componentWillUnmount = function() {
    P(null, t3.l), t3.l = null, t3.i = null;
  }, t3.i && t3.i !== e4 && t3.componentWillUnmount(), n3.__v ? (t3.l || (t3.i = e4, t3.l = { nodeType: 1, parentNode: e4, childNodes: [], appendChild: function(n4) {
    this.childNodes.push(n4), t3.i.appendChild(n4);
  }, insertBefore: function(n4, e5) {
    this.childNodes.push(n4), t3.i.appendChild(n4);
  }, removeChild: function(n4) {
    this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), t3.i.removeChild(n4);
  } }), P(h(I2, { context: t3.context }, n3.__v), t3.l)) : t3.l && t3.componentWillUnmount();
}
function V(n3, t3) {
  var e4 = h(M2, { __v: n3, i: t3 });
  return e4.containerInfo = t3, e4;
}
function z3(n3, t3, e4) {
  return null == t3.__k && (t3.textContent = ""), P(n3, t3), "function" == typeof e4 && e4(), n3 ? n3.__c : null;
}
function B2(n3, t3, e4) {
  return S(n3, t3), "function" == typeof e4 && e4(), n3 ? n3.__c : null;
}
function Z() {
}
function Y() {
  return this.cancelBubble;
}
function q3() {
  return this.defaultPrevented;
}
function tn(n3) {
  return h.bind(null, n3);
}
function en(n3) {
  return !!n3 && n3.$$typeof === W;
}
function rn(n3) {
  return en(n3) ? q.apply(null, arguments) : n3;
}
function un(n3) {
  return !!n3.__k && (P(null, n3), true);
}
function on(n3) {
  return n3 && (n3.base || 1 === n3.nodeType && n3) || null;
}
function an(n3) {
  n3();
}
function sn(n3) {
  return n3;
}
function hn() {
  return [false, an];
}
function dn(t3, u4) {
  var o5 = u4(), i4 = p2({ s: { __: o5, h: u4 } }), l4 = i4[0].s, c42 = i4[1];
  return s2(function() {
    l4.__ = o5, l4.h = u4, l4.__ !== u4() && c42({ s: l4 });
  }, [t3, o5, u4]), h2(function() {
    return l4.__ !== l4.h() && c42({ s: l4 }), t3(function() {
      l4.__ !== l4.h() && c42({ s: l4 });
    });
  }, [t3]), o5;
}
var w3;
var x3;
var N2;
var k3;
var A3;
var O2;
var F2;
var W;
var P2;
var $2;
var j3;
var H2;
var G;
var J;
var K;
var Q;
var X;
var ln;
var cn;
var compat_module_default;
var init_compat_module = __esm({
  "../../../../.yarn/global/cache/preact-npm-10.10.6-e3746adb94-9c9.zip/node_modules/preact/compat/dist/compat.module.js"() {
    init_define_process();
    init_hooks_module();
    init_hooks_module();
    init_preact_module();
    init_preact_module();
    __name(S2, "S");
    __name(g3, "g");
    __name(C2, "C");
    __name(E, "E");
    (C2.prototype = new d()).isPureReactComponent = true, C2.prototype.shouldComponentUpdate = function(n3, t3) {
      return g3(this.props, n3) || g3(this.state, t3);
    };
    w3 = l.__b;
    l.__b = function(n3) {
      n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), w3 && w3(n3);
    };
    x3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
    __name(R, "R");
    N2 = __name(function(n3, t3) {
      return null == n3 ? null : x(x(n3).map(t3));
    }, "N");
    k3 = { map: N2, forEach: N2, count: function(n3) {
      return n3 ? x(n3).length : 0;
    }, only: function(n3) {
      var t3 = x(n3);
      if (1 !== t3.length)
        throw "Children.only";
      return t3[0];
    }, toArray: x };
    A3 = l.__e;
    l.__e = function(n3, t3, e4, r42) {
      if (n3.then) {
        for (var u4, o5 = t3; o5 = o5.__; )
          if ((u4 = o5.__c) && u4.__c)
            return null == t3.__e && (t3.__e = e4.__e, t3.__k = e4.__k), u4.__c(n3, t3);
      }
      A3(n3, t3, e4, r42);
    };
    O2 = l.unmount;
    __name(T3, "T");
    __name(L2, "L");
    __name(U, "U");
    __name(D, "D");
    l.unmount = function(n3) {
      var t3 = n3.__c;
      t3 && t3.__R && t3.__R(), t3 && true === n3.__h && (n3.type = null), O2 && O2(n3);
    }, (T3.prototype = new d()).__c = function(n3, t3) {
      var e4 = t3.__c, r42 = this;
      null == r42.t && (r42.t = []), r42.t.push(e4);
      var u4 = L2(r42.__v), o5 = false, i4 = __name(function() {
        o5 || (o5 = true, e4.__R = null, u4 ? u4(l4) : l4());
      }, "i");
      e4.__R = i4;
      var l4 = __name(function() {
        if (!--r42.__u) {
          if (r42.state.__a) {
            var n4 = r42.state.__a;
            r42.__v.__k[0] = __name(function n5(t5, e5, r5) {
              return t5 && (t5.__v = null, t5.__k = t5.__k && t5.__k.map(function(t6) {
                return n5(t6, e5, r5);
              }), t5.__c && t5.__c.__P === e5 && (t5.__e && r5.insertBefore(t5.__e, t5.__d), t5.__c.__e = true, t5.__c.__P = r5)), t5;
            }, "n")(n4, n4.__c.__P, n4.__c.__O);
          }
          var t4;
          for (r42.setState({ __a: r42.__b = null }); t4 = r42.t.pop(); )
            t4.forceUpdate();
        }
      }, "l"), c42 = true === t3.__h;
      r42.__u++ || c42 || r42.setState({ __a: r42.__b = r42.__v.__k[0] }), n3.then(i4, i4);
    }, T3.prototype.componentWillUnmount = function() {
      this.t = [];
    }, T3.prototype.render = function(n3, t3) {
      if (this.__b) {
        if (this.__v.__k) {
          var e4 = document.createElement("div"), r42 = this.__v.__k[0].__c;
          this.__v.__k[0] = __name(function n4(t4, e5, r5) {
            return t4 && (t4.__c && t4.__c.__H && (t4.__c.__H.__.forEach(function(n5) {
              "function" == typeof n5.__c && n5.__c();
            }), t4.__c.__H = null), null != (t4 = S2({}, t4)).__c && (t4.__c.__P === r5 && (t4.__c.__P = e5), t4.__c = null), t4.__k = t4.__k && t4.__k.map(function(t5) {
              return n4(t5, e5, r5);
            })), t4;
          }, "n")(this.__b, e4, r42.__O = r42.__P);
        }
        this.__b = null;
      }
      var u4 = t3.__a && h(p, null, n3.fallback);
      return u4 && (u4.__h = null), [h(p, null, t3.__a ? null : n3.children), u4];
    };
    F2 = __name(function(n3, t3, e4) {
      if (++e4[1] === e4[0] && n3.o.delete(t3), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size))
        for (e4 = n3.u; e4; ) {
          for (; e4.length > 3; )
            e4.pop()();
          if (e4[1] < e4[0])
            break;
          n3.u = e4 = e4[2];
        }
    }, "F");
    __name(I2, "I");
    __name(M2, "M");
    __name(V, "V");
    (D.prototype = new d()).__a = function(n3) {
      var t3 = this, e4 = L2(t3.__v), r42 = t3.o.get(n3);
      return r42[0]++, function(u4) {
        var o5 = __name(function() {
          t3.props.revealOrder ? (r42.push(u4), F2(t3, n3, r42)) : u4();
        }, "o");
        e4 ? e4(o5) : o5();
      };
    }, D.prototype.render = function(n3) {
      this.u = null, this.o = /* @__PURE__ */ new Map();
      var t3 = x(n3.children);
      n3.revealOrder && "b" === n3.revealOrder[0] && t3.reverse();
      for (var e4 = t3.length; e4--; )
        this.o.set(t3[e4], this.u = [1, 0, this.u]);
      return n3.children;
    }, D.prototype.componentDidUpdate = D.prototype.componentDidMount = function() {
      var n3 = this;
      this.o.forEach(function(t3, e4) {
        F2(n3, e4, t3);
      });
    };
    W = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    P2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    $2 = "undefined" != typeof document;
    j3 = __name(function(n3) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n3);
    }, "j");
    __name(z3, "z");
    __name(B2, "B");
    d.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(n3) {
      Object.defineProperty(d.prototype, n3, { configurable: true, get: function() {
        return this["UNSAFE_" + n3];
      }, set: function(t3) {
        Object.defineProperty(this, n3, { configurable: true, writable: true, value: t3 });
      } });
    });
    H2 = l.event;
    __name(Z, "Z");
    __name(Y, "Y");
    __name(q3, "q");
    l.event = function(n3) {
      return H2 && (n3 = H2(n3)), n3.persist = Z, n3.isPropagationStopped = Y, n3.isDefaultPrevented = q3, n3.nativeEvent = n3;
    };
    J = { configurable: true, get: function() {
      return this.class;
    } };
    K = l.vnode;
    l.vnode = function(n3) {
      var t3 = n3.type, e4 = n3.props, r42 = e4;
      if ("string" == typeof t3) {
        var u4 = -1 === t3.indexOf("-");
        for (var o5 in r42 = {}, e4) {
          var i4 = e4[o5];
          $2 && "children" === o5 && "noscript" === t3 || "value" === o5 && "defaultValue" in e4 && null == i4 || ("defaultValue" === o5 && "value" in e4 && null == e4.value ? o5 = "value" : "download" === o5 && true === i4 ? i4 = "" : /ondoubleclick/i.test(o5) ? o5 = "ondblclick" : /^onchange(textarea|input)/i.test(o5 + t3) && !j3(e4.type) ? o5 = "oninput" : /^onfocus$/i.test(o5) ? o5 = "onfocusin" : /^onblur$/i.test(o5) ? o5 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o5) ? o5 = o5.toLowerCase() : u4 && P2.test(o5) ? o5 = o5.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === i4 && (i4 = void 0), /^oninput$/i.test(o5) && (o5 = o5.toLowerCase(), r42[o5] && (o5 = "oninputCapture")), r42[o5] = i4);
        }
        "select" == t3 && r42.multiple && Array.isArray(r42.value) && (r42.value = x(e4.children).forEach(function(n4) {
          n4.props.selected = -1 != r42.value.indexOf(n4.props.value);
        })), "select" == t3 && null != r42.defaultValue && (r42.value = x(e4.children).forEach(function(n4) {
          n4.props.selected = r42.multiple ? -1 != r42.defaultValue.indexOf(n4.props.value) : r42.defaultValue == n4.props.value;
        })), n3.props = r42, e4.class != e4.className && (J.enumerable = "className" in e4, null != e4.className && (r42.class = e4.className), Object.defineProperty(r42, "className", J));
      }
      n3.$$typeof = W, K && K(n3);
    };
    Q = l.__r;
    l.__r = function(n3) {
      Q && Q(n3), G = n3.__c;
    };
    X = { ReactCurrentDispatcher: { current: { readContext: function(n3) {
      return G.__n[n3.__c].props.value;
    } } } };
    __name(tn, "tn");
    __name(en, "en");
    __name(rn, "rn");
    __name(un, "un");
    __name(on, "on");
    ln = __name(function(n3, t3) {
      return n3(t3);
    }, "ln");
    cn = __name(function(n3, t3) {
      return n3(t3);
    }, "cn");
    __name(an, "an");
    __name(sn, "sn");
    __name(hn, "hn");
    __name(dn, "dn");
    compat_module_default = { useState: p2, useReducer: y2, useEffect: h2, useLayoutEffect: s2, useInsertionEffect: s2, useTransition: hn, useDeferredValue: sn, useSyncExternalStore: dn, startTransition: an, useRef: _2, useImperativeHandle: A2, useMemo: F, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: k3, render: z3, hydrate: B2, unmountComponentAtNode: un, createPortal: V, createElement: h, createContext: B, createFactory: tn, cloneElement: rn, createRef: y, Fragment: p, isValidElement: en, findDOMNode: on, Component: d, PureComponent: C2, memo: E, forwardRef: R, flushSync: cn, unstable_batchedUpdates: ln, StrictMode: p, Suspense: T3, SuspenseList: D, lazy: U, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: X };
  }
});
function createRoot(container) {
  return {
    render(children2) {
      z3(children2, container);
    },
    unmount() {
      un(container);
    }
  };
}
var init_client = __esm({
  "../../../../.yarn/global/cache/preact-npm-10.10.6-e3746adb94-9c9.zip/node_modules/preact/compat/client.mjs"() {
    init_define_process();
    init_compat_module();
    __name(createRoot, "createRoot");
  }
});
function o3(e4) {
  if (false === n2.test(e4 += ""))
    return e4;
  for (var t3 = 0, r42 = 0, o5 = "", i4 = ""; r42 < e4.length; r42++) {
    switch (e4.charCodeAt(r42)) {
      case 60:
        i4 = "&lt;";
        break;
      case 62:
        i4 = "&gt;";
        break;
      case 34:
        i4 = "&quot;";
        break;
      case 38:
        i4 = "&amp;";
        break;
      default:
        continue;
    }
    r42 > t3 && (o5 += e4.slice(t3, r42)), o5 += i4, t3 = r42 + 1;
  }
  return o5 + e4.slice(t3, r42);
}
function s3(e4) {
  var t3 = "";
  for (var n3 in e4) {
    var o5 = e4[n3];
    null != o5 && "" !== o5 && (t3 && (t3 += " "), t3 += "-" == n3[0] ? n3 : l3[n3] || (l3[n3] = n3.replace(/([A-Z])/g, "-$1").toLowerCase()), t3 += ": ", t3 += o5, "number" == typeof o5 && false === r3.test(n3) && (t3 += "px"), t3 += ";");
  }
  return t3 || void 0;
}
function f3(e4, t3) {
  return Array.isArray(t3) ? t3.reduce(f3, e4) : null != t3 && false !== t3 && e4.push(t3), e4;
}
function v3() {
  this.__d = true;
}
function y3(t3, r42, n3) {
  r42 = r42 || {}, n3 = n3 || {};
  var o5, i4 = l.__s;
  return l.__s = true, o5 = n3.pretty || n3.sortAttributes ? S3(t3, r42, n3) : x4(t3, r42, n3), l.__c && l.__c(t3, g4), g4.length = 0, l.__s = i4, o5;
}
function m3(e4, t3) {
  return { __v: e4, context: t3, props: e4.props, setState: v3, forceUpdate: v3, __d: true, __h: [] };
}
function b3(e4, t3) {
  var r42 = e4.contextType, n3 = r42 && t3[r42.__c];
  return null != r42 ? n3 ? n3.props.value : r42.__ : t3;
}
function x4(r42, n3, i4, a42, l4, c42) {
  if (null == r42 || "boolean" == typeof r42)
    return "";
  if ("object" != typeof r42)
    return o3(r42);
  if (Array.isArray(r42)) {
    for (var u4 = [], v42 = 0; v42 < r42.length; v42++)
      u4.push(x4(r42[v42], n3, i4, a42, l4, c42));
    return u4.join("");
  }
  var h4 = r42.type, g5 = r42.props, y4 = false;
  if ("function" == typeof h4) {
    if (y4 = true, !i4.shallow || !a42 && false !== i4.renderRootComponent) {
      if (h4 === p) {
        var S4 = [];
        return f3(S4, r42.props.children), x4(S4, n3, i4, false !== i4.shallowHighOrder, l4, c42);
      }
      var w4, C3 = r42.__c = m3(r42, n3);
      l.__b && l.__b(r42);
      var O3 = l.__r;
      if (h4.prototype && "function" == typeof h4.prototype.render) {
        var j4 = b3(h4, n3);
        (C3 = r42.__c = new h4(g5, j4)).__v = r42, C3._dirty = C3.__d = true, C3.props = g5, null == C3.state && (C3.state = {}), null == C3._nextState && null == C3.__s && (C3._nextState = C3.__s = C3.state), C3.context = j4, h4.getDerivedStateFromProps ? C3.state = Object.assign({}, C3.state, h4.getDerivedStateFromProps(C3.props, C3.state)) : C3.componentWillMount && (C3.componentWillMount(), C3.state = C3._nextState !== C3.state ? C3._nextState : C3.__s !== C3.state ? C3.__s : C3.state), O3 && O3(r42), w4 = C3.render(C3.props, C3.state, C3.context);
      } else
        for (var A4 = b3(h4, n3), H3 = 0; C3.__d && H3++ < 25; )
          C3.__d = false, O3 && O3(r42), w4 = h4.call(r42.__c, g5, A4);
      return C3.getChildContext && (n3 = Object.assign({}, n3, C3.getChildContext())), l.diffed && l.diffed(r42), x4(w4, n3, i4, false !== i4.shallowHighOrder, l4, c42);
    }
    h4 = k4(h4);
  }
  var M3, F3, L3 = "<" + h4;
  if (g5)
    for (var E2 in g5) {
      var T4 = g5[E2];
      if ("children" !== E2) {
        if (!p3.test(E2) && (i4 && i4.allAttributes || "key" !== E2 && "ref" !== E2 && "__self" !== E2 && "__source" !== E2)) {
          if ("defaultValue" === E2)
            E2 = "value";
          else if ("defaultChecked" === E2)
            E2 = "checked";
          else if ("defaultSelected" === E2)
            E2 = "selected";
          else if ("className" === E2) {
            if (void 0 !== g5.class)
              continue;
            E2 = "class";
          } else
            l4 && d3.test(E2) && (E2 = E2.toLowerCase().replace(/^xlink:?/, "xlink:"));
          if ("htmlFor" === E2) {
            if (g5.for)
              continue;
            E2 = "for";
          }
          "style" === E2 && T4 && "object" == typeof T4 && (T4 = s3(T4)), "a" === E2[0] && "r" === E2[1] && "boolean" == typeof T4 && (T4 = String(T4));
          var $3 = i4.attributeHook && i4.attributeHook(E2, T4, n3, i4, y4);
          if ($3 || "" === $3)
            L3 += $3;
          else if ("dangerouslySetInnerHTML" === E2)
            F3 = T4 && T4.__html;
          else if ("textarea" === h4 && "value" === E2)
            M3 = T4;
          else if ((T4 || 0 === T4 || "" === T4) && "function" != typeof T4) {
            if (!(true !== T4 && "" !== T4 || (T4 = E2, i4 && i4.xml))) {
              L3 = L3 + " " + E2;
              continue;
            }
            if ("value" === E2) {
              if ("select" === h4) {
                c42 = T4;
                continue;
              }
              "option" === h4 && c42 == T4 && void 0 === g5.selected && (L3 += " selected");
            }
            L3 = L3 + " " + E2 + '="' + o3(T4) + '"';
          }
        }
      } else
        M3 = T4;
    }
  if (L3 += ">", p3.test(h4))
    throw new Error(h4 + " is not a valid HTML tag name in " + L3);
  var D2, P3 = _3.test(h4) || i4.voidElements && i4.voidElements.test(h4), W2 = "";
  if (F3)
    L3 += F3;
  else if (null != M3 && f3(D2 = [], M3).length)
    for (var N3 = 0; N3 < D2.length; N3++) {
      var R2 = D2[N3];
      if (null != R2 && false !== R2) {
        var I3 = x4(R2, n3, i4, true, "svg" === h4 || "foreignObject" !== h4 && l4, c42);
        I3 && (W2 += I3);
      }
    }
  if (W2.length || F3)
    L3 += W2;
  else if (i4 && i4.xml)
    return L3.substring(0, L3.length - 1) + " />";
  return !P3 || D2 || F3 ? L3 + "</" + h4 + ">" : L3.replace(/>$/, " />");
}
function S3(r42, n3, l4, c42, u4, v42) {
  if (null == r42 || "boolean" == typeof r42)
    return "";
  if ("object" != typeof r42)
    return o3(r42);
  var h4 = l4.pretty, g5 = h4 && "string" == typeof h4 ? h4 : "	";
  if (Array.isArray(r42)) {
    for (var y4 = "", x5 = 0; x5 < r42.length; x5++)
      h4 && x5 > 0 && (y4 += "\n"), y4 += S3(r42[x5], n3, l4, c42, u4, v42);
    return y4;
  }
  var w4 = r42.type, C3 = r42.props, O3 = false;
  if ("function" == typeof w4) {
    if (O3 = true, !l4.shallow || !c42 && false !== l4.renderRootComponent) {
      if (w4 === p) {
        var j4 = [];
        return f3(j4, r42.props.children), S3(j4, n3, l4, false !== l4.shallowHighOrder, u4, v42);
      }
      var A4, H3 = r42.__c = m3(r42, n3);
      l.__b && l.__b(r42);
      var M3 = l.__r;
      if (w4.prototype && "function" == typeof w4.prototype.render) {
        var F3 = b3(w4, n3);
        (H3 = r42.__c = new w4(C3, F3)).__v = r42, H3._dirty = H3.__d = true, H3.props = C3, null == H3.state && (H3.state = {}), null == H3._nextState && null == H3.__s && (H3._nextState = H3.__s = H3.state), H3.context = F3, w4.getDerivedStateFromProps ? H3.state = Object.assign({}, H3.state, w4.getDerivedStateFromProps(H3.props, H3.state)) : H3.componentWillMount && (H3.componentWillMount(), H3.state = H3._nextState !== H3.state ? H3._nextState : H3.__s !== H3.state ? H3.__s : H3.state), M3 && M3(r42), A4 = H3.render(H3.props, H3.state, H3.context);
      } else
        for (var L3 = b3(w4, n3), E2 = 0; H3.__d && E2++ < 25; )
          H3.__d = false, M3 && M3(r42), A4 = w4.call(r42.__c, C3, L3);
      return H3.getChildContext && (n3 = Object.assign({}, n3, H3.getChildContext())), l.diffed && l.diffed(r42), S3(A4, n3, l4, false !== l4.shallowHighOrder, u4, v42);
    }
    w4 = k4(w4);
  }
  var T4, $3, D2 = "<" + w4;
  if (C3) {
    var P3 = Object.keys(C3);
    l4 && true === l4.sortAttributes && P3.sort();
    for (var W2 = 0; W2 < P3.length; W2++) {
      var N3 = P3[W2], R2 = C3[N3];
      if ("children" !== N3) {
        if (!p3.test(N3) && (l4 && l4.allAttributes || "key" !== N3 && "ref" !== N3 && "__self" !== N3 && "__source" !== N3)) {
          if ("defaultValue" === N3)
            N3 = "value";
          else if ("defaultChecked" === N3)
            N3 = "checked";
          else if ("defaultSelected" === N3)
            N3 = "selected";
          else if ("className" === N3) {
            if (void 0 !== C3.class)
              continue;
            N3 = "class";
          } else
            u4 && d3.test(N3) && (N3 = N3.toLowerCase().replace(/^xlink:?/, "xlink:"));
          if ("htmlFor" === N3) {
            if (C3.for)
              continue;
            N3 = "for";
          }
          "style" === N3 && R2 && "object" == typeof R2 && (R2 = s3(R2)), "a" === N3[0] && "r" === N3[1] && "boolean" == typeof R2 && (R2 = String(R2));
          var I3 = l4.attributeHook && l4.attributeHook(N3, R2, n3, l4, O3);
          if (I3 || "" === I3)
            D2 += I3;
          else if ("dangerouslySetInnerHTML" === N3)
            $3 = R2 && R2.__html;
          else if ("textarea" === w4 && "value" === N3)
            T4 = R2;
          else if ((R2 || 0 === R2 || "" === R2) && "function" != typeof R2) {
            if (!(true !== R2 && "" !== R2 || (R2 = N3, l4 && l4.xml))) {
              D2 = D2 + " " + N3;
              continue;
            }
            if ("value" === N3) {
              if ("select" === w4) {
                v42 = R2;
                continue;
              }
              "option" === w4 && v42 == R2 && void 0 === C3.selected && (D2 += " selected");
            }
            D2 = D2 + " " + N3 + '="' + o3(R2) + '"';
          }
        }
      } else
        T4 = R2;
    }
  }
  if (h4) {
    var U2 = D2.replace(/\n\s*/, " ");
    U2 === D2 || ~U2.indexOf("\n") ? h4 && ~D2.indexOf("\n") && (D2 += "\n") : D2 = U2;
  }
  if (D2 += ">", p3.test(w4))
    throw new Error(w4 + " is not a valid HTML tag name in " + D2);
  var V2, q4 = _3.test(w4) || l4.voidElements && l4.voidElements.test(w4), z4 = [];
  if ($3)
    h4 && a3($3) && ($3 = "\n" + g5 + i3($3, g5)), D2 += $3;
  else if (null != T4 && f3(V2 = [], T4).length) {
    for (var Z2 = h4 && ~D2.indexOf("\n"), B3 = false, G2 = 0; G2 < V2.length; G2++) {
      var J2 = V2[G2];
      if (null != J2 && false !== J2) {
        var K2 = S3(J2, n3, l4, true, "svg" === w4 || "foreignObject" !== w4 && u4, v42);
        if (h4 && !Z2 && a3(K2) && (Z2 = true), K2)
          if (h4) {
            var Q2 = K2.length > 0 && "<" != K2[0];
            B3 && Q2 ? z4[z4.length - 1] += K2 : z4.push(K2), B3 = Q2;
          } else
            z4.push(K2);
      }
    }
    if (h4 && Z2)
      for (var X2 = z4.length; X2--; )
        z4[X2] = "\n" + g5 + i3(z4[X2], g5);
  }
  if (z4.length || $3)
    D2 += z4.join("");
  else if (l4 && l4.xml)
    return D2.substring(0, D2.length - 1) + " />";
  return !q4 || V2 || $3 ? (h4 && ~D2.indexOf("\n") && (D2 += "\n"), D2 = D2 + "</" + w4 + ">") : D2 = D2.replace(/>$/, " />"), D2;
}
function k4(e4) {
  return e4.displayName || e4 !== Function && e4.name || function(e5) {
    var t3 = (Function.prototype.toString.call(e5).match(/^\s*function\s+([^( ]+)/) || "")[1];
    if (!t3) {
      for (var r42 = -1, n3 = u3.length; n3--; )
        if (u3[n3] === e5) {
          r42 = n3;
          break;
        }
      r42 < 0 && (r42 = u3.push(e5) - 1), t3 = "UnnamedComponent" + r42;
    }
    return t3;
  }(e4);
}
var r3;
var n2;
var i3;
var a3;
var l3;
var c3;
var u3;
var _3;
var p3;
var d3;
var h3;
var g4;
var init_dist = __esm({
  ".yarn/__virtual__/preact-render-to-string-virtual-01f41805c5/5/.yarn/global/cache/preact-render-to-string-npm-5.2.2-b8f2c0c74e-9c9.zip/node_modules/preact-render-to-string/dist/index.mjs"() {
    init_define_process();
    init_preact_module();
    r3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;
    n2 = /[&<>"]/;
    __name(o3, "o");
    i3 = __name(function(e4, t3) {
      return String(e4).replace(/(\n+)/g, "$1" + (t3 || "	"));
    }, "i");
    a3 = __name(function(e4, t3, r42) {
      return String(e4).length > (t3 || 40) || !r42 && -1 !== String(e4).indexOf("\n") || -1 !== String(e4).indexOf("<");
    }, "a");
    l3 = {};
    __name(s3, "s");
    __name(f3, "f");
    c3 = { shallow: true };
    u3 = [];
    _3 = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;
    p3 = /[\s\n\\/='"\0<>]/;
    d3 = /^xlink:?./;
    __name(v3, "v");
    y3.render = y3;
    h3 = __name(function(e4, t3) {
      return y3(e4, t3, c3);
    }, "h");
    g4 = [];
    __name(y3, "y");
    __name(m3, "m");
    __name(b3, "b");
    __name(x4, "x");
    __name(S3, "S");
    __name(k4, "k");
    y3.shallowRender = h3;
  }
});
function e3(_42, e4, n3, t3, f4) {
  var l4, s4, u4 = {};
  for (s4 in e4)
    "ref" == s4 ? l4 = e4[s4] : u4[s4] = e4[s4];
  var a42 = { type: _42, props: u4, key: n3, ref: l4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: --o4, __source: f4, __self: t3 };
  if ("function" == typeof _42 && (l4 = _42.defaultProps))
    for (s4 in l4)
      void 0 === u4[s4] && (u4[s4] = l4[s4]);
  return l.vnode && l.vnode(a42), a42;
}
var o4;
var init_jsxRuntime_module = __esm({
  "../../../../.yarn/global/cache/preact-npm-10.10.6-e3746adb94-9c9.zip/node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js"() {
    init_define_process();
    init_preact_module();
    init_preact_module();
    o4 = 0;
    __name(e3, "e");
  }
});
var react_preact_exports = {};
__export(react_preact_exports, {
  Children: () => Children,
  Component: () => Component,
  Fragment: () => p,
  PureComponent: () => PureComponent,
  StrictMode: () => StrictMode,
  Suspense: () => Suspense,
  SuspenseList: () => D,
  cloneElement: () => cloneElement,
  createContext: () => createContext,
  createElement: () => h,
  createFactory: () => createFactory,
  createPortal: () => V,
  createRef: () => createRef,
  createRoot: () => createRoot,
  default: () => react_preact_default,
  findDOMNode: () => on,
  flushSync: () => flushSync,
  forwardRef: () => forwardRef,
  hydrate: () => hydrate,
  isValidElement: () => isValidElement,
  jsx: () => e3,
  jsxDEV: () => e3,
  jsxs: () => e3,
  lazy: () => lazy,
  memo: () => memo,
  render: () => render,
  renderToString: () => y3,
  unmountComponentAtNode: () => unmountComponentAtNode,
  unstable_batchedUpdates: () => unstable_batchedUpdates,
  useCallback: () => useCallback,
  useContext: () => useContext,
  useDebugValue: () => useDebugValue,
  useEffect: () => useEffect,
  useId: () => useId,
  useImperativeHandle: () => useImperativeHandle,
  useInsertionEffect: () => useInsertionEffect,
  useLayoutEffect: () => useLayoutEffect,
  useMemo: () => useMemo,
  useReducer: () => useReducer,
  useRef: () => useRef,
  useState: () => useState,
  version: () => version
});
function hash2(str2) {
  let i4 = 0, out = 11;
  while (i4 < str2.length)
    out = 101 * out + str2.charCodeAt(i4++) >>> 0;
  return out;
}
function getHookState(index, type) {
  if (l._hook) {
    l._hook(currentComponent, index, currentHook || type);
  }
  currentHook = 0;
  const hooks = currentComponent.__hooks || (currentComponent.__hooks = {
    _list: [],
    _pendingEffects: []
  });
  if (index >= hooks._list.length) {
    hooks._list.push({ _pendingValue: EMPTY });
  }
  return hooks._list[index];
}
function useId() {
  const state = getHookState(currentIndex++, 11);
  if (!state._value) {
    state._value = "P" + hash2(currentComponent._vnode._mask + currentIndex);
  }
  return state._value;
}
var currentIndex;
var currentComponent;
var currentHook;
var EMPTY;
var oldBeforeDiff;
var oldBeforeRender;
var oldAfterDiff;
var oldCommit;
var oldBeforeUnmount;
var React;
var createContext;
var hydrate;
var render;
var unmountComponentAtNode;
var react_preact_default;
var cloneElement;
var createFactory;
var useInsertionEffect;
var unstable_batchedUpdates;
var createRef;
var useCallback;
var useContext;
var useDebugValue;
var isValidElement;
var useEffect;
var useImperativeHandle;
var useLayoutEffect;
var useMemo;
var useReducer;
var useRef;
var useState;
var lazy;
var Suspense;
var StrictMode;
var flushSync;
var forwardRef;
var memo;
var Children;
var PureComponent;
var Component;
var version;
var init_react_preact = __esm({
  "js/react-preact.ts"() {
    init_define_process();
    init_client();
    init_preact_module();
    init_preact_module();
    init_compat_module();
    init_compat_module();
    init_dist();
    init_jsxRuntime_module();
    currentHook = 0;
    EMPTY = [];
    oldBeforeDiff = l._diff;
    oldBeforeRender = l._render;
    oldAfterDiff = l.diffed;
    oldCommit = l._commit;
    oldBeforeUnmount = l.unmount;
    l._diff = (vnode) => {
      if (vnode.type === p) {
        vnode._mask = "";
      } else if (typeof vnode.type === "function" && !vnode._mask) {
        const parentMask = vnode._parent && vnode._parent._mask ? vnode._parent._mask : "";
        const position2 = vnode._parent && vnode._parent._children ? vnode._parent._children.indexOf(vnode) : 0;
        vnode._mask = parentMask + position2;
      } else if (!vnode._mask) {
        vnode._mask = vnode._parent._mask;
      }
      currentComponent = null;
      if (oldBeforeDiff)
        oldBeforeDiff(vnode);
    };
    __name(hash2, "hash");
    __name(getHookState, "getHookState");
    __name(useId, "useId");
    React = window.React = window.React || { ...preact_module_exports, ...compat_module_default, createPortal: V, SuspenseList: D, findDOMNode: on };
    ({ createContext } = React);
    ({ hydrate, render, unmountComponentAtNode } = React);
    react_preact_default = React;
    ({
      cloneElement,
      createFactory,
      useInsertionEffect,
      unstable_batchedUpdates,
      createRef,
      useCallback,
      useContext,
      useDebugValue,
      isValidElement,
      useEffect,
      useImperativeHandle,
      useLayoutEffect,
      useMemo,
      useReducer,
      useRef,
      useState,
      lazy,
      Suspense,
      StrictMode,
      flushSync,
      forwardRef,
      memo,
      Children,
      PureComponent,
      Component,
      version
    } = React);
  }
});

// dist/chunk-chunk-JOKQY4IE.mjs
var require_memoize_browser_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-memoize-npm-0.7.4-5648cf11b8-9c9.zip/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoize2(fn2) {
      var cache2 = {};
      return function(arg) {
        if (cache2[arg] === void 0)
          cache2[arg] = fn2(arg);
        return cache2[arg];
      };
    }
    __name(memoize2, "memoize");
    exports.default = memoize2;
  }
});
var require_is_prop_valid_browser_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-is-prop-valid-npm-0.8.8-261a0f2426-9c9.zip/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    __name(_interopDefault, "_interopDefault");
    var memoize2 = _interopDefault(require_memoize_browser_cjs());
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var index = memoize2(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    exports.default = index;
  }
});
var require_tslib = __commonJS({
  "../../../../.yarn/global/cache/tslib-npm-2.4.0-9cb6dc5030-9c9.zip/node_modules/tslib/tslib.js"(exports, module) {
    init_define_process();
    var __extends22;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof window === "object" ? window : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id3, v5) {
          return exports2[id3] = previous ? previous(id3, v5) : v5;
        };
      }
      __name(createExporter, "createExporter");
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b22) {
        d4.__proto__ = b22;
      } || function(d4, b22) {
        for (var p22 in b22)
          if (Object.prototype.hasOwnProperty.call(b22, p22))
            d4[p22] = b22[p22];
      };
      __extends22 = __name(function(d4, b22) {
        if (typeof b22 !== "function" && b22 !== null)
          throw new TypeError("Class extends value " + String(b22) + " is not a constructor or null");
        extendStatics(d4, b22);
        function __() {
          this.constructor = d4;
        }
        __name(__, "__");
        d4.prototype = b22 === null ? Object.create(b22) : (__.prototype = b22.prototype, new __());
      }, "__extends");
      __assign2 = Object.assign || function(t3) {
        for (var s4, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
          s4 = arguments[i4];
          for (var p22 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p22))
              t3[p22] = s4[p22];
        }
        return t3;
      };
      __rest2 = __name(function(s4, e4) {
        var t3 = {};
        for (var p22 in s4)
          if (Object.prototype.hasOwnProperty.call(s4, p22) && e4.indexOf(p22) < 0)
            t3[p22] = s4[p22];
        if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i4 = 0, p22 = Object.getOwnPropertySymbols(s4); i4 < p22.length; i4++) {
            if (e4.indexOf(p22[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p22[i4]))
              t3[p22[i4]] = s4[p22[i4]];
          }
        return t3;
      }, "__rest");
      __decorate2 = __name(function(decorators, target, key, desc) {
        var c22 = arguments.length, r5 = c22 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r5 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i4 = decorators.length - 1; i4 >= 0; i4--)
            if (d4 = decorators[i4])
              r5 = (c22 < 3 ? d4(r5) : c22 > 3 ? d4(target, key, r5) : d4(target, key)) || r5;
        return c22 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
      }, "__decorate");
      __param2 = __name(function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }, "__param");
      __metadata2 = __name(function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      }, "__metadata");
      __awaiter2 = __name(function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        __name(adopt, "adopt");
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e4) {
              reject(e4);
            }
          }
          __name(fulfilled, "fulfilled");
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e4) {
              reject(e4);
            }
          }
          __name(rejected, "rejected");
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          __name(step, "step");
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }, "__awaiter");
      __generator2 = __name(function(thisArg, body) {
        var _5 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f4, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n3) {
          return function(v5) {
            return step([n3, v5]);
          };
        }
        __name(verb, "verb");
        function step(op) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (_5)
            try {
              if (f4 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _5.label++;
                  return { value: op[1], done: false };
                case 5:
                  _5.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _5.ops.pop();
                  _5.trys.pop();
                  continue;
                default:
                  if (!(t3 = _5.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _5 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _5.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _5.label < t3[1]) {
                    _5.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _5.label < t3[2]) {
                    _5.label = t3[2];
                    _5.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _5.ops.pop();
                  _5.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _5);
            } catch (e4) {
              op = [6, e4];
              y4 = 0;
            } finally {
              f4 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
        __name(step, "step");
      }, "__generator");
      __exportStar2 = __name(function(m22, o5) {
        for (var p22 in m22)
          if (p22 !== "default" && !Object.prototype.hasOwnProperty.call(o5, p22))
            __createBinding2(o5, m22, p22);
      }, "__exportStar");
      __createBinding2 = Object.create ? function(o5, m22, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        var desc = Object.getOwnPropertyDescriptor(m22, k5);
        if (!desc || ("get" in desc ? !m22.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m22[k5];
          } };
        }
        Object.defineProperty(o5, k22, desc);
      } : function(o5, m22, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o5[k22] = m22[k5];
      };
      __values2 = __name(function(o5) {
        var s4 = typeof Symbol === "function" && Symbol.iterator, m22 = s4 && o5[s4], i4 = 0;
        if (m22)
          return m22.call(o5);
        if (o5 && typeof o5.length === "number")
          return {
            next: function() {
              if (o5 && i4 >= o5.length)
                o5 = void 0;
              return { value: o5 && o5[i4++], done: !o5 };
            }
          };
        throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }, "__values");
      __read2 = __name(function(o5, n3) {
        var m22 = typeof Symbol === "function" && o5[Symbol.iterator];
        if (!m22)
          return o5;
        var i4 = m22.call(o5), r5, ar = [], e4;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r5 = i4.next()).done)
            ar.push(r5.value);
        } catch (error) {
          e4 = { error };
        } finally {
          try {
            if (r5 && !r5.done && (m22 = i4["return"]))
              m22.call(i4);
          } finally {
            if (e4)
              throw e4.error;
          }
        }
        return ar;
      }, "__read");
      __spread2 = __name(function() {
        for (var ar = [], i4 = 0; i4 < arguments.length; i4++)
          ar = ar.concat(__read2(arguments[i4]));
        return ar;
      }, "__spread");
      __spreadArrays2 = __name(function() {
        for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
          s4 += arguments[i4].length;
        for (var r5 = Array(s4), k5 = 0, i4 = 0; i4 < il; i4++)
          for (var a22 = arguments[i4], j4 = 0, jl = a22.length; j4 < jl; j4++, k5++)
            r5[k5] = a22[j4];
        return r5;
      }, "__spreadArrays");
      __spreadArray2 = __name(function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i4 = 0, l4 = from.length, ar; i4 < l4; i4++) {
            if (ar || !(i4 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i4);
              ar[i4] = from[i4];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      }, "__spreadArray");
      __await2 = __name(function(v5) {
        return this instanceof __await2 ? (this.v = v5, this) : new __await2(v5);
      }, "__await");
      __asyncGenerator2 = __name(function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g5 = generator.apply(thisArg, _arguments || []), i4, q4 = [];
        return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4;
        function verb(n3) {
          if (g5[n3])
            i4[n3] = function(v5) {
              return new Promise(function(a22, b22) {
                q4.push([n3, v5, a22, b22]) > 1 || resume(n3, v5);
              });
            };
        }
        __name(verb, "verb");
        function resume(n3, v5) {
          try {
            step(g5[n3](v5));
          } catch (e4) {
            settle(q4[0][3], e4);
          }
        }
        __name(resume, "resume");
        function step(r5) {
          r5.value instanceof __await2 ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q4[0][2], r5);
        }
        __name(step, "step");
        function fulfill(value) {
          resume("next", value);
        }
        __name(fulfill, "fulfill");
        function reject(value) {
          resume("throw", value);
        }
        __name(reject, "reject");
        function settle(f4, v5) {
          if (f4(v5), q4.shift(), q4.length)
            resume(q4[0][0], q4[0][1]);
        }
        __name(settle, "settle");
      }, "__asyncGenerator");
      __asyncDelegator2 = __name(function(o5) {
        var i4, p22;
        return i4 = {}, verb("next"), verb("throw", function(e4) {
          throw e4;
        }), verb("return"), i4[Symbol.iterator] = function() {
          return this;
        }, i4;
        function verb(n3, f4) {
          i4[n3] = o5[n3] ? function(v5) {
            return (p22 = !p22) ? { value: __await2(o5[n3](v5)), done: n3 === "return" } : f4 ? f4(v5) : v5;
          } : f4;
        }
        __name(verb, "verb");
      }, "__asyncDelegator");
      __asyncValues2 = __name(function(o5) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m22 = o5[Symbol.asyncIterator], i4;
        return m22 ? m22.call(o5) : (o5 = typeof __values2 === "function" ? __values2(o5) : o5[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4);
        function verb(n3) {
          i4[n3] = o5[n3] && function(v5) {
            return new Promise(function(resolve, reject) {
              v5 = o5[n3](v5), settle(resolve, reject, v5.done, v5.value);
            });
          };
        }
        __name(verb, "verb");
        function settle(resolve, reject, d4, v5) {
          Promise.resolve(v5).then(function(v22) {
            resolve({ value: v22, done: d4 });
          }, reject);
        }
        __name(settle, "settle");
      }, "__asyncValues");
      __makeTemplateObject2 = __name(function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }, "__makeTemplateObject");
      var __setModuleDefault = Object.create ? function(o5, v5) {
        Object.defineProperty(o5, "default", { enumerable: true, value: v5 });
      } : function(o5, v5) {
        o5["default"] = v5;
      };
      __importStar2 = __name(function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k5 in mod2)
            if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k5))
              __createBinding2(result, mod2, k5);
        }
        __setModuleDefault(result, mod2);
        return result;
      }, "__importStar");
      __importDefault2 = __name(function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      }, "__importDefault");
      __classPrivateFieldGet2 = __name(function(receiver, state, kind, f4) {
        if (kind === "a" && !f4)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
      }, "__classPrivateFieldGet");
      __classPrivateFieldSet2 = __name(function(receiver, state, value, kind, f4) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f4)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
      }, "__classPrivateFieldSet");
      __classPrivateFieldIn2 = __name(function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      }, "__classPrivateFieldIn");
      exporter("__extends", __extends22);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});
init_define_process();
init_react_preact();
var MotionConfigContext = createContext({
  transformPagePoint: (p22) => p22,
  isStatic: false,
  reducedMotion: "never"
});
init_define_process();
init_react_preact();
var MotionContext = createContext({});
function useVisualElementContext() {
  return useContext(MotionContext).visualElement;
}
__name(useVisualElementContext, "useVisualElementContext");
init_define_process();
init_react_preact();
var PresenceContext = createContext(null);
init_define_process();
var isBrowser = typeof document !== "undefined";
init_define_process();
init_react_preact();
var useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;
init_define_process();
init_react_preact();
var LayoutGroupContext = createContext({});
init_define_process();
init_react_preact();
var SwitchLayoutGroupContext = createContext({});
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
init_react_preact();
init_define_process();
init_react_preact();
var LazyContext = createContext({ strict: false });
function useVisualElement(Component2, visualState, props, createVisualElement) {
  const parent = useVisualElementContext();
  const lazyContext = useContext(LazyContext);
  const presenceContext = useContext(PresenceContext);
  const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = useRef(void 0);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent,
      props,
      presenceId: presenceContext ? presenceContext.id : void 0,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(() => {
    visualElement2 && visualElement2.syncRender();
  });
  useEffect(() => {
    if (visualElement2 && visualElement2.animationState) {
      visualElement2.animationState.animateChanges();
    }
  });
  useIsomorphicLayoutEffect(() => () => visualElement2 && visualElement2.notifyUnmount(), []);
  return visualElement2;
}
__name(useVisualElement, "useVisualElement");
init_define_process();
init_react_preact();
init_define_process();
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
__name(isRefObject, "isRefObject");
function useMotionRef(visualState, visualElement2, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement2) {
        instance ? visualElement2.mount(instance) : visualElement2.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    [visualElement2]
  );
}
__name(useMotionRef, "useMotionRef");
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
function isVariantLabel(v5) {
  return typeof v5 === "string" || Array.isArray(v5);
}
__name(isVariantLabel, "isVariantLabel");
init_define_process();
init_define_process();
function isAnimationControls(v5) {
  return typeof v5 === "object" && typeof v5.start === "function";
}
__name(isAnimationControls, "isAnimationControls");
var variantProps = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
__name(isControllingVariants, "isControllingVariants");
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
__name(isVariantNode, "isVariantNode");
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate4 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate4) ? animate4 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
__name(getCurrentTreeVariants, "getCurrentTreeVariants");
function useCreateMotionContext(props) {
  const { initial, animate: animate4 } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate: animate4 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate4)]);
}
__name(useCreateMotionContext, "useCreateMotionContext");
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
__name(variantLabelsAsDependency, "variantLabelsAsDependency");
init_define_process();
var createDefinition = __name((propNames) => ({
  isEnabled: (props) => propNames.some((name) => !!props[name])
}), "createDefinition");
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
init_define_process();
function loadFeatures(features) {
  for (const key in features) {
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}
__name(loadFeatures, "loadFeatures");
init_define_process();
init_define_process();
init_react_preact();
function useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
__name(useConstant, "useConstant");
init_define_process();
var globalProjectionState = {
  hasAnimatedSinceResize: true,
  hasEverUpdated: false
};
var id = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}
__name(useProjectionId, "useProjectionId");
init_define_process();
init_react_preact();
var VisualElementHandler = class extends react_preact_default.Component {
  getSnapshotBeforeUpdate() {
    const { visualElement: visualElement2, props } = this.props;
    if (visualElement2)
      visualElement2.setProps(props);
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
__name(VisualElementHandler, "VisualElementHandler");
function createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState: useVisualState2, Component: Component2 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    let features = null;
    const context = useCreateMotionContext(props);
    const projectionId = isStatic ? void 0 : useProjectionId();
    const visualState = useVisualState2(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement);
      const lazyStrictMode = useContext(LazyContext).strict;
      const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
      if (context.visualElement) {
        features = context.visualElement.loadFeatures(props, lazyStrictMode, preloadedFeatures, projectionId, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor, initialLayoutGroupConfig);
      }
    }
    return h(
      VisualElementHandler,
      { visualElement: context.visualElement, props: configAndProps },
      features,
      h(MotionContext.Provider, { value: context }, useRender(Component2, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))
    );
  }
  __name(MotionComponent, "MotionComponent");
  return forwardRef(MotionComponent);
}
__name(createMotionComponent, "createMotionComponent");
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
__name(useLayoutId, "useLayoutId");
init_define_process();
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
__name(addScaleCorrector, "addScaleCorrector");
init_define_process();
var isMotionValue = __name((value) => value === void 0 ? false : !!value.getVelocity, "isMotionValue");
init_define_process();
var animationProps = [
  "animate",
  "exit",
  "variants",
  "whileHover",
  "whileTap",
  "whileFocus",
  "whileDrag",
  "whileInView"
];
var tapProps = ["whileTap", "onTap", "onTapStart", "onTapCancel"];
var panProps = ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"];
var inViewProps = [
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
];
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "onHoverStart",
  "onHoverEnd",
  "layoutScroll",
  ...inViewProps,
  ...tapProps,
  ...animationProps,
  ...panProps
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}
__name(isValidMotionProp, "isValidMotionProp");
init_define_process();
var shouldForward = __name((key) => !isValidMotionProp(key), "shouldForward");
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = __name((key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key), "shouldForward");
}
__name(loadExternalIsValidProp, "loadExternalIsValidProp");
try {
  loadExternalIsValidProp(require_is_prop_valid_browser_cjs().default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
__name(filterProps, "filterProps");
init_define_process();
init_define_process();
init_define_process();
var isKeyframesTarget = __name((v5) => {
  return Array.isArray(v5);
}, "isKeyframesTarget");
var isCustomValue = __name((v5) => {
  return Boolean(v5 && typeof v5 === "object" && v5.mix && v5.toValue);
}, "isCustomValue");
var resolveFinalValueInKeyframes = __name((v5) => {
  return isKeyframesTarget(v5) ? v5[v5.length - 1] || 0 : v5;
}, "resolveFinalValueInKeyframes");
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
__name(resolveMotionValue, "resolveMotionValue");
init_define_process();
init_react_preact();
init_define_process();
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
__name(resolveVariantFromProps, "resolveVariantFromProps");
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
__name(makeState, "makeState");
var makeUseVisualState = __name((config) => (props, isStatic) => {
  const context = useContext(MotionContext);
  const presenceContext = useContext(PresenceContext);
  const make = __name(() => makeState(config, props, context, presenceContext), "make");
  return isStatic ? make() : useConstant(make);
}, "makeUseVisualState");
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values3 = {};
  const motionValues = scrapeMotionValues(props);
  for (const key in motionValues) {
    values3[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate4 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate4 === void 0)
      animate4 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate4 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values3[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values3[key] = transitionEnd[key];
    });
  }
  return values3;
}
__name(makeLatestValues, "makeLatestValues");
init_define_process();
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
init_define_process();
init_react_preact();
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
__name(addDomEvent, "addDomEvent");
function useDomEvent(ref, eventName, handler, options) {
  useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
__name(useDomEvent, "useDomEvent");
init_define_process();
init_define_process();
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
__name(isMouseEvent, "isMouseEvent");
function isTouchEvent(event) {
  const hasTouches = !!event.touches;
  return hasTouches;
}
__name(isTouchEvent, "isTouchEvent");
function filterPrimaryPointer(eventHandler) {
  return (event) => {
    const isMouseEvent2 = event instanceof MouseEvent;
    const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
__name(filterPrimaryPointer, "filterPrimaryPointer");
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e4, pointType = "page") {
  const primaryTouch = e4.touches[0] || e4.changedTouches[0];
  const point2 = primaryTouch || defaultPagePoint;
  return {
    x: point2[pointType + "X"],
    y: point2[pointType + "Y"]
  };
}
__name(pointFromTouch, "pointFromTouch");
function pointFromMouse(point2, pointType = "page") {
  return {
    x: point2[pointType + "X"],
    y: point2[pointType + "Y"]
  };
}
__name(pointFromMouse, "pointFromMouse");
function extractEventInfo(event, pointType = "page") {
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
__name(extractEventInfo, "extractEventInfo");
var wrapHandler = __name((handler, shouldFilterPrimaryPointer = false) => {
  const listener = __name((event) => handler(event, extractEventInfo(event)), "listener");
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
}, "wrapHandler");
init_define_process();
init_define_process();
var supportsPointerEvents = __name(() => isBrowser && window.onpointerdown === null, "supportsPointerEvents");
var supportsTouchEvents = __name(() => isBrowser && window.ontouchstart === null, "supportsTouchEvents");
var supportsMouseEvents = __name(() => isBrowser && window.onmousedown === null, "supportsMouseEvents");
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
__name(getPointerEventName, "getPointerEventName");
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
__name(addPointerEvent, "addPointerEvent");
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}
__name(usePointerEvent, "usePointerEvent");
init_define_process();
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = __name(() => {
      lock = null;
    }, "openLock");
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
__name(createLock, "createLock");
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = __name(() => {
        openHorizontal();
        openVertical();
      }, "lock");
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
__name(getGlobalLock, "getGlobalLock");
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
__name(isDragActive, "isDragActive");
init_define_process();
init_react_preact();
function useUnmountEffect(callback) {
  return useEffect(() => () => callback(), []);
}
__name(useUnmountEffect, "useUnmountEffect");
init_define_process();
init_react_preact();
function usePresence() {
  const context = useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent: isPresent2, onExitComplete, register } = context;
  const id3 = useId();
  useEffect(() => register(id3), []);
  const safeToRemove = __name(() => onExitComplete && onExitComplete(id3), "safeToRemove");
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
__name(usePresence, "usePresence");
function useIsPresent() {
  return isPresent(useContext(PresenceContext));
}
__name(useIsPresent, "useIsPresent");
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
__name(isPresent, "isPresent");
init_define_process();
init_define_process();
init_define_process();
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
init_define_process();
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i4 = 0; i4 < numToRun; i4++) {
          const callback = toRun[i4];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
__name(createRenderStep, "createRenderStep");
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync2 = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = __name((stepId) => steps[stepId].process(frame), "processStep");
var processFrame = __name((timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
}, "processFrame");
var startLoop = __name(() => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
}, "startLoop");
var getFrameData = __name(() => frame, "getFrameData");
var es_default = sync;
init_define_process();
init_define_process();
init_define_process();
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var warning = __name(function() {
}, "warning");
var invariant2 = __name(function() {
}, "invariant");
if (false) {
  warning = __name(function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  }, "warning");
  invariant2 = __name(function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  }, "invariant");
}
init_define_process();
var clamp = __name((min3, max3, v5) => Math.min(Math.max(v5, min3), max3), "clamp");
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration: duration2 = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration2 <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration2 = clamp(minDuration, maxDuration, duration2 / 1e3);
  if (dampingRatio < 1) {
    envelope = __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const a22 = exponentialDecay - velocity;
      const b22 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c22 = Math.exp(-delta);
      return safeMin - a22 / b22 * c22;
    }, "envelope");
    derivative = __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const d4 = delta * velocity + velocity;
      const e4 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
      const f4 = Math.exp(-delta);
      const g5 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d4 - e4) * f4) / g5;
    }, "derivative");
  } else {
    envelope = __name((undampedFreq2) => {
      const a22 = Math.exp(-undampedFreq2 * duration2);
      const b22 = (undampedFreq2 - velocity) * duration2 + 1;
      return -safeMin + a22 * b22;
    }, "envelope");
    derivative = __name((undampedFreq2) => {
      const a22 = Math.exp(-undampedFreq2 * duration2);
      const b22 = (velocity - undampedFreq2) * (duration2 * duration2);
      return a22 * b22;
    }, "derivative");
  }
  const initialGuess = 5 / duration2;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration2 = duration2 * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration: duration2
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration: duration2
    };
  }
}
__name(findSpring, "findSpring");
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i4 = 1; i4 < rootIterations; i4++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
__name(approximateRoot, "approximateRoot");
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
__name(calcAngularFreq, "calcAngularFreq");
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys22) {
  return keys22.some((key) => options[key] !== void 0);
}
__name(isSpringType, "isSpringType");
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
__name(getSpringOptions, "getSpringOptions");
function spring(_a) {
  var { from = 0, to = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from };
  let { stiffness, damping, mass, velocity, duration: duration2, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to - from;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = __name((t3) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t3) + initialDelta * Math.cos(angularFreq * t3));
      }, "resolveSpring");
      resolveVelocity = __name((t3) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t3) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t3)) - envelope * (Math.cos(angularFreq * t3) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t3));
      }, "resolveVelocity");
    } else if (dampingRatio === 1) {
      resolveSpring = __name((t3) => to - Math.exp(-undampedAngularFreq * t3) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t3), "resolveSpring");
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = __name((t3) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
        const freqForT = Math.min(dampedAngularFreq * t3, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      }, "resolveSpring");
    }
  }
  __name(createSpring, "createSpring");
  createSpring();
  return {
    next: (t3) => {
      const current = resolveSpring(t3);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t3) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t3 >= duration2;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from, to] = [to, from];
      createSpring();
    }
  };
}
__name(spring, "spring");
spring.needsInterpolation = (a22, b22) => typeof a22 === "string" || typeof b22 === "string";
var zero = __name((_t5) => 0, "zero");
init_define_process();
init_define_process();
init_define_process();
var progress = __name((from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
}, "progress");
init_define_process();
var mix = __name((from, to, progress3) => -progress3 * from + progress3 * to + from, "mix");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var clamp2 = __name((min3, max3) => (v5) => Math.max(Math.min(v5, max3), min3), "clamp");
var sanitize = __name((v5) => v5 % 1 ? Number(v5.toFixed(5)) : v5, "sanitize");
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v5) {
  return typeof v5 === "string";
}
__name(isString, "isString");
var number = {
  test: (v5) => typeof v5 === "number",
  parse: parseFloat,
  transform: (v5) => v5
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp2(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });
init_define_process();
var createUnitType = __name((unit) => ({
  test: (v5) => isString(v5) && v5.endsWith(unit) && v5.split(" ").length === 1,
  parse: parseFloat,
  transform: (v5) => `${v5}${unit}`
}), "createUnitType");
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v5) => percent.parse(v5) / 100, transform: (v5) => percent.transform(v5 * 100) });
init_define_process();
init_define_process();
var isColorString = __name((type, testProp) => (v5) => {
  return Boolean(isString(v5) && singleColorRegex.test(v5) && v5.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v5, testProp));
}, "isColorString");
var splitColor = __name((aName, bName, cName) => (v5) => {
  if (!isString(v5))
    return v5;
  const [a22, b22, c22, alpha22] = v5.match(floatRegex);
  return {
    [aName]: parseFloat(a22),
    [bName]: parseFloat(b22),
    [cName]: parseFloat(c22),
    alpha: alpha22 !== void 0 ? parseFloat(alpha22) : 1
  };
}, "splitColor");
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
init_define_process();
var clampRgbUnit = clamp2(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v5) => Math.round(clampRgbUnit(v5)) });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
init_define_process();
function parseHex(v5) {
  let r5 = "";
  let g5 = "";
  let b22 = "";
  let a22 = "";
  if (v5.length > 5) {
    r5 = v5.substr(1, 2);
    g5 = v5.substr(3, 2);
    b22 = v5.substr(5, 2);
    a22 = v5.substr(7, 2);
  } else {
    r5 = v5.substr(1, 1);
    g5 = v5.substr(2, 1);
    b22 = v5.substr(3, 1);
    a22 = v5.substr(4, 1);
    r5 += r5;
    g5 += g5;
    b22 += b22;
    a22 += a22;
  }
  return {
    red: parseInt(r5, 16),
    green: parseInt(g5, 16),
    blue: parseInt(b22, 16),
    alpha: a22 ? parseInt(a22, 16) / 255 : 1
  };
}
__name(parseHex, "parseHex");
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
init_define_process();
var color = {
  test: (v5) => rgba.test(v5) || hex.test(v5) || hsla.test(v5),
  parse: (v5) => {
    if (rgba.test(v5)) {
      return rgba.parse(v5);
    } else if (hsla.test(v5)) {
      return hsla.parse(v5);
    } else {
      return hex.parse(v5);
    }
  },
  transform: (v5) => {
    return isString(v5) ? v5 : v5.hasOwnProperty("red") ? rgba.transform(v5) : hsla.transform(v5);
  }
};
init_define_process();
var colorToken = "${c}";
var numberToken = "${n}";
function test(v5) {
  var _a, _b, _c, _d;
  return isNaN(v5) && isString(v5) && ((_b = (_a = v5.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v5.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
__name(test, "test");
function analyse(v5) {
  if (typeof v5 === "number")
    v5 = `${v5}`;
  const values3 = [];
  let numColors = 0;
  const colors = v5.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v5 = v5.replace(colorRegex, colorToken);
    values3.push(...colors.map(color.parse));
  }
  const numbers = v5.match(floatRegex);
  if (numbers) {
    v5 = v5.replace(floatRegex, numberToken);
    values3.push(...numbers.map(number.parse));
  }
  return { values: values3, numColors, tokenised: v5 };
}
__name(analyse, "analyse");
function parse(v5) {
  return analyse(v5).values;
}
__name(parse, "parse");
function createTransformer(v5) {
  const { values: values3, numColors, tokenised } = analyse(v5);
  const numValues = values3.length;
  return (v22) => {
    let output = tokenised;
    for (let i4 = 0; i4 < numValues; i4++) {
      output = output.replace(i4 < numColors ? colorToken : numberToken, i4 < numColors ? color.transform(v22[i4]) : sanitize(v22[i4]));
    }
    return output;
  };
}
__name(createTransformer, "createTransformer");
var convertNumbersToZero = __name((v5) => typeof v5 === "number" ? 0 : v5, "convertNumbersToZero");
function getAnimatableNone(v5) {
  const parsed = parse(v5);
  const transformer = createTransformer(v5);
  return transformer(parsed.map(convertNumbersToZero));
}
__name(getAnimatableNone, "getAnimatableNone");
var complex = { test, parse, createTransformer, getAnimatableNone };
init_define_process();
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v5) {
  let [name, value] = v5.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v5;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v5;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
__name(applyDefaultFilter, "applyDefaultFilter");
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter3 = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v5) => {
  const functions = v5.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v5;
} });
init_define_process();
function hueToRgb(p22, q4, t3) {
  if (t3 < 0)
    t3 += 1;
  if (t3 > 1)
    t3 -= 1;
  if (t3 < 1 / 6)
    return p22 + (q4 - p22) * 6 * t3;
  if (t3 < 1 / 2)
    return q4;
  if (t3 < 2 / 3)
    return p22 + (q4 - p22) * (2 / 3 - t3) * 6;
  return p22;
}
__name(hueToRgb, "hueToRgb");
function hslaToRgba({ hue, saturation, lightness, alpha: alpha22 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q4 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p22 = 2 * lightness - q4;
    red2 = hueToRgb(p22, q4, hue + 1 / 3);
    green2 = hueToRgb(p22, q4, hue);
    blue2 = hueToRgb(p22, q4, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha22
  };
}
__name(hslaToRgba, "hslaToRgba");
var mixLinearColor = __name((from, to, v5) => {
  const fromExpo = from * from;
  const toExpo = to * to;
  return Math.sqrt(Math.max(0, v5 * (toExpo - fromExpo) + fromExpo));
}, "mixLinearColor");
var colorTypes = [hex, rgba, hsla];
var getColorType = __name((v5) => colorTypes.find((type) => type.test(v5)), "getColorType");
var notAnimatable = __name((color22) => `'${color22}' is not an animatable color. Use the equivalent color code instead.`, "notAnimatable");
var mixColor = __name((from, to) => {
  let fromColorType = getColorType(from);
  let toColorType = getColorType(to);
  invariant2(!!fromColorType, notAnimatable(from));
  invariant2(!!toColorType, notAnimatable(to));
  let fromColor = fromColorType.parse(from);
  let toColor = toColorType.parse(to);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v5) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v5);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v5);
    return fromColorType.transform(blended);
  };
}, "mixColor");
init_define_process();
init_define_process();
var isNum = __name((v5) => typeof v5 === "number", "isNum");
init_define_process();
var combineFunctions = __name((a22, b22) => (v5) => b22(a22(v5)), "combineFunctions");
var pipe = __name((...transformers) => transformers.reduce(combineFunctions), "pipe");
function getMixer(origin, target) {
  if (isNum(origin)) {
    return (v5) => mix(origin, target, v5);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
__name(getMixer, "getMixer");
var mixArray = __name((from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i4) => getMixer(fromThis, to[i4]));
  return (v5) => {
    for (let i4 = 0; i4 < numValues; i4++) {
      output[i4] = blendValue[i4](v5);
    }
    return output;
  };
}, "mixArray");
var mixObject = __name((origin, target) => {
  const output = Object.assign(Object.assign({}, origin), target);
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v5) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v5);
    }
    return output;
  };
}, "mixObject");
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i4 = 0; i4 < numValues; i4++) {
    if (numNumbers || typeof parsed[i4] === "number") {
      numNumbers++;
    } else {
      if (parsed[i4].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
__name(analyse2, "analyse");
var mixComplex = __name((origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p22) => `${p22 > 0 ? target : origin}`;
  }
}, "mixComplex");
var mixNumber = __name((from, to) => (p22) => mix(from, to, p22), "mixNumber");
function detectMixerFactory(v5) {
  if (typeof v5 === "number") {
    return mixNumber;
  } else if (typeof v5 === "string") {
    if (color.test(v5)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v5)) {
    return mixArray;
  } else if (typeof v5 === "object") {
    return mixObject;
  }
}
__name(detectMixerFactory, "detectMixerFactory");
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i4 = 0; i4 < numMixers; i4++) {
    let mixer = mixerFactory(output[i4], output[i4 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i4] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
__name(createMixers, "createMixers");
function fastInterpolate([from, to], [mixer]) {
  return (v5) => mixer(progress(from, to, v5));
}
__name(fastInterpolate, "fastInterpolate");
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v5) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v5 <= input[0]) {
      foundMixerIndex = true;
    } else if (v5 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i4 = 1;
      for (; i4 < inputLength; i4++) {
        if (input[i4] > v5 || i4 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i4 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v5);
    return mixers[mixerIndex](progressInRange);
  };
}
__name(slowInterpolate, "slowInterpolate");
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant2(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant2(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v5) => interpolator(clamp(input[0], input[inputLength - 1], v5)) : interpolator;
}
__name(interpolate, "interpolate");
init_define_process();
init_define_process();
var reverseEasing = __name((easing2) => (p22) => 1 - easing2(1 - p22), "reverseEasing");
var mirrorEasing = __name((easing2) => (p22) => p22 <= 0.5 ? easing2(2 * p22) / 2 : (2 - easing2(2 * (1 - p22))) / 2, "mirrorEasing");
var createExpoIn = __name((power) => (p22) => Math.pow(p22, power), "createExpoIn");
var createBackIn = __name((power) => (p22) => p22 * p22 * ((power + 1) * p22 - power), "createBackIn");
var createAnticipate = __name((power) => {
  const backEasing = createBackIn(power);
  return (p22) => (p22 *= 2) < 1 ? 0.5 * backEasing(p22) : 0.5 * (2 - Math.pow(2, -10 * (p22 - 1)));
}, "createAnticipate");
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = __name((p22) => p22, "linear");
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = __name((p22) => 1 - Math.sin(Math.acos(p22)), "circIn");
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = __name((p22) => {
  if (p22 === 1 || p22 === 0)
    return p22;
  const p222 = p22 * p22;
  return p22 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p222 : p22 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p222 - 9.9 * p22 + 3.4 : p22 < BOUNCE_THIRD_THRESHOLD ? ca * p222 - cb * p22 + cc : 10.8 * p22 * p22 - 20.52 * p22 + 10.72;
}, "bounceOut");
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = __name((p22) => p22 < 0.5 ? 0.5 * (1 - bounceOut(1 - p22 * 2)) : 0.5 * bounceOut(p22 * 2 - 1) + 0.5, "bounceInOut");
function defaultEasing(values3, easing2) {
  return values3.map(() => easing2 || easeInOut).splice(0, values3.length - 1);
}
__name(defaultEasing, "defaultEasing");
function defaultOffset(values3) {
  const numValues = values3.length;
  return values3.map((_value, i4) => i4 !== 0 ? i4 / (numValues - 1) : 0);
}
__name(defaultOffset, "defaultOffset");
function convertOffsetToTimes(offset2, duration2) {
  return offset2.map((o5) => o5 * duration2);
}
__name(convertOffsetToTimes, "convertOffsetToTimes");
function keyframes({ from = 0, to = 1, ease, offset: offset2, duration: duration2 = 300 }) {
  const state = { done: false, value: from };
  const values3 = Array.isArray(to) ? to : [from, to];
  const times = convertOffsetToTimes(offset2 && offset2.length === values3.length ? offset2 : defaultOffset(values3), duration2);
  function createInterpolator() {
    return interpolate(times, values3, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values3, ease)
    });
  }
  __name(createInterpolator, "createInterpolator");
  let interpolator = createInterpolator();
  return {
    next: (t3) => {
      state.value = interpolator(t3);
      state.done = t3 >= duration2;
      return state;
    },
    flipTarget: () => {
      values3.reverse();
      interpolator = createInterpolator();
    }
  };
}
__name(keyframes, "keyframes");
init_define_process();
function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from;
  return {
    next: (t3) => {
      const delta = -amplitude * Math.exp(-t3 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}
__name(decay, "decay");
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys22 = new Set(Object.keys(config));
  if (keys22.has("ease") || keys22.has("duration") && !keys22.has("dampingRatio")) {
    return keyframes;
  } else if (keys22.has("dampingRatio") || keys22.has("stiffness") || keys22.has("mass") || keys22.has("damping") || keys22.has("restSpeed") || keys22.has("restDelta")) {
    return spring;
  }
  return keyframes;
}
__name(detectAnimationFromOptions, "detectAnimationFromOptions");
init_define_process();
function loopElapsed(elapsed, duration2, delay = 0) {
  return elapsed - duration2 - delay;
}
__name(loopElapsed, "loopElapsed");
function reverseElapsed(elapsed, duration2, delay = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration2 + -elapsed, duration2, delay) : duration2 - (elapsed - duration2) + delay;
}
__name(reverseElapsed, "reverseElapsed");
function hasRepeatDelayElapsed(elapsed, duration2, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration2 + delay : elapsed <= -delay;
}
__name(hasRepeatDelayElapsed, "hasRepeatDelayElapsed");
var framesync = __name((update8) => {
  const passTimestamp = __name(({ delta }) => update8(delta), "passTimestamp");
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
}, "framesync");
function animate(_a) {
  var _b, _c;
  var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  __name(repeat, "repeat");
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  __name(complete, "complete");
  function update8(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  __name(update8, "update");
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update8);
    driverControls.start();
  }
  __name(play, "play");
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
__name(animate, "animate");
init_define_process();
init_define_process();
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
__name(velocityPerSecond, "velocityPerSecond");
function inertia({ from = 0, velocity = 0, min: min3, max: max3, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v5) {
    return min3 !== void 0 && v5 < min3 || max3 !== void 0 && v5 > max3;
  }
  __name(isOutOfBounds, "isOutOfBounds");
  function boundaryNearest(v5) {
    if (min3 === void 0)
      return max3;
    if (max3 === void 0)
      return min3;
    return Math.abs(min3 - v5) < Math.abs(max3 - v5) ? min3 : max3;
  }
  __name(boundaryNearest, "boundaryNearest");
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: (v5) => {
        var _a;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v5);
        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v5);
      },
      onComplete,
      onStop
    }));
  }
  __name(startAnimation2, "startAnimation");
  function startSpring(options) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  __name(startSpring, "startSpring");
  if (isOutOfBounds(from)) {
    startSpring({ from, velocity, to: boundaryNearest(from) });
  } else {
    let target = power * velocity + from;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min3 ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = __name((v5) => {
      prev = current;
      current = v5;
      velocity = velocityPerSecond(v5 - prev, getFrameData().delta);
      if (heading === 1 && v5 > boundary || heading === -1 && v5 < boundary) {
        startSpring({ from: v5, to: boundary, velocity });
      }
    }, "checkBoundary");
    startAnimation2({
      type: "decay",
      from,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
__name(inertia, "inertia");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var identity = __name((v5) => v5, "identity");
var createAttractor = __name((alterDisplacement = identity) => (constant, origin, v5) => {
  const displacement = origin - v5;
  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
  return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
}, "createAttractor");
var attract = createAttractor();
var attractExpo = createAttractor(Math.sqrt);
init_define_process();
init_define_process();
init_define_process();
var isPoint = __name((point2) => point2.hasOwnProperty("x") && point2.hasOwnProperty("y"), "isPoint");
init_define_process();
var isPoint3D = __name((point2) => isPoint(point2) && point2.hasOwnProperty("z"), "isPoint3D");
var distance1D = __name((a22, b22) => Math.abs(a22 - b22), "distance1D");
function distance(a22, b22) {
  if (isNum(a22) && isNum(b22)) {
    return distance1D(a22, b22);
  } else if (isPoint(a22) && isPoint(b22)) {
    const xDelta = distance1D(a22.x, b22.x);
    const yDelta = distance1D(a22.y, b22.y);
    const zDelta = isPoint3D(a22) && isPoint3D(b22) ? distance1D(a22.z, b22.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}
__name(distance, "distance");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var wrap = __name((min3, max3, v5) => {
  const rangeSize = max3 - min3;
  return ((v5 - min3) % rangeSize + rangeSize) % rangeSize + min3;
}, "wrap");
init_define_process();
var a4 = __name((a1, a22) => 1 - 3 * a22 + 3 * a1, "a");
var b4 = __name((a1, a22) => 3 * a22 - 6 * a1, "b");
var c4 = __name((a1) => 3 * a1, "c");
var calcBezier = __name((t3, a1, a22) => ((a4(a1, a22) * t3 + b4(a1, a22)) * t3 + c4(a1)) * t3, "calcBezier");
var getSlope = __name((t3, a1, a22) => 3 * a4(a1, a22) * t3 * t3 + 2 * b4(a1, a22) * t3 + c4(a1), "getSlope");
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i4 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i4 < subdivisionMaxIterations);
  return currentT;
}
__name(binarySubdivide, "binarySubdivide");
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i4 = 0; i4 < newtonIterations; ++i4) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
__name(newtonRaphsonIterate, "newtonRaphsonIterate");
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i4 = 0; i4 < kSplineTableSize; ++i4) {
    sampleValues[i4] = calcBezier(i4 * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  __name(getTForX, "getTForX");
  return (t3) => t3 === 0 || t3 === 1 ? t3 : calcBezier(getTForX(t3), mY1, mY2);
}
__name(cubicBezier, "cubicBezier");
init_define_process();
init_define_process();
init_define_process();
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
__name(addUniqueItem, "addUniqueItem");
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
__name(removeItem, "removeItem");
function moveItem([...arr], fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item] = arr.splice(fromIndex, 1);
    arr.splice(endIndex, 0, item);
  }
  return arr;
}
__name(moveItem, "moveItem");
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a22, b22, c22) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a22, b22, c22);
    } else {
      for (let i4 = 0; i4 < numSubscriptions; i4++) {
        const handler = this.subscriptions[i4];
        handler && handler(a22, b22, c22);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
__name(SubscriptionManager, "SubscriptionManager");
var isFloat = __name((value) => {
  return !isNaN(parseFloat(value));
}, "isFloat");
var MotionValue = class {
  constructor(init) {
    this.version = "7.2.1";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.updateSubscribers = new SubscriptionManager();
    this.velocityUpdateSubscribers = new SubscriptionManager();
    this.renderSubscribers = new SubscriptionManager();
    this.canTrackVelocity = false;
    this.updateAndNotify = (v5, render2 = true) => {
      this.prev = this.current;
      this.current = v5;
      const { delta, timestamp } = getFrameData();
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        es_default.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current) {
        this.updateSubscribers.notify(this.current);
      }
      if (this.velocityUpdateSubscribers.getSize()) {
        this.velocityUpdateSubscribers.notify(this.getVelocity());
      }
      if (render2) {
        this.renderSubscribers.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => es_default.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        this.velocityUpdateSubscribers.notify(this.getVelocity());
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
  }
  onChange(subscription) {
    return this.updateSubscribers.add(subscription);
  }
  clearListeners() {
    this.updateSubscribers.clear();
  }
  onRenderRequest(subscription) {
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  }
  attach(passiveEffect) {
    this.passiveEffect = passiveEffect;
  }
  set(v5, render2 = true) {
    if (!render2 || !this.passiveEffect) {
      this.updateAndNotify(v5, render2);
    } else {
      this.passiveEffect(v5, this.updateAndNotify);
    }
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  }
  start(animation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.stopAnimation = animation(resolve);
    }).then(() => this.clearAnimation());
  }
  stop() {
    if (this.stopAnimation)
      this.stopAnimation();
    this.clearAnimation();
  }
  isAnimating() {
    return !!this.stopAnimation;
  }
  clearAnimation() {
    this.stopAnimation = null;
  }
  destroy() {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  }
};
__name(MotionValue, "MotionValue");
function motionValue(init) {
  return new MotionValue(init);
}
__name(motionValue, "motionValue");
init_define_process();
init_define_process();
var isNumericalString = __name((v5) => /^\-?\d*\.?\d+$/.test(v5), "isNumericalString");
init_define_process();
var isZeroValueString = __name((v5) => /^0[^.\s]+$/.test(v5), "isZeroValueString");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var int = {
  ...number,
  transform: Math.round
};
var numberValueTypes = {
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
var defaultValueTypes = {
  ...numberValueTypes,
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter3,
  WebkitFilter: filter3
};
var getDefaultValueType = __name((key) => defaultValueTypes[key], "getDefaultValueType");
function getAnimatableNone2(key, value) {
  var _a;
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter3)
    defaultValueType = complex;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}
__name(getAnimatableNone2, "getAnimatableNone");
init_define_process();
init_define_process();
init_define_process();
var testValueType = __name((v5) => (type) => type.test(v5), "testValueType");
init_define_process();
var auto = {
  test: (v5) => v5 === "auto",
  parse: (v5) => v5
};
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = __name((v5) => dimensionValueTypes.find(testValueType(v5)), "findDimensionValueType");
var valueTypes = [...dimensionValueTypes, color, complex];
var findValueType = __name((v5) => valueTypes.find(testValueType(v5)), "findValueType");
init_define_process();
function getCurrent(visualElement2) {
  const current = {};
  visualElement2.forEachValue((value, key) => current[key] = value.get());
  return current;
}
__name(getCurrent, "getCurrent");
function getVelocity(visualElement2) {
  const velocity = {};
  visualElement2.forEachValue((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
__name(getVelocity, "getVelocity");
function resolveVariant(visualElement2, definition, custom) {
  const props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
__name(resolveVariant, "resolveVariant");
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
__name(setMotionValue, "setMotionValue");
function setTarget(visualElement2, definition) {
  const resolved = resolveVariant(visualElement2, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
__name(setTarget, "setTarget");
function setVariants(visualElement2, variantLabels) {
  const reversedLabels = [...variantLabels].reverse();
  reversedLabels.forEach((key) => {
    var _a;
    const variant = visualElement2.getVariant(key);
    variant && setTarget(visualElement2, variant);
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      setVariants(child, variantLabels);
    });
  });
}
__name(setVariants, "setVariants");
function setValues(visualElement2, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement2, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement2, [definition]);
  } else {
    setTarget(visualElement2, definition);
  }
}
__name(setValues, "setValues");
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement2.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i4 = 0; i4 < numNewValues; i4++) {
    const key = newValueKeys[i4];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    visualElement2.setBaseTarget(key, value);
  }
}
__name(checkTargetForNewValues, "checkTargetForNewValues");
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
__name(getOriginFromTransition, "getOriginFromTransition");
function getOrigin(target, transition, visualElement2) {
  var _a;
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition);
    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement2.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();
  }
  return origin;
}
__name(getOrigin, "getOrigin");
init_define_process();
init_define_process();
init_define_process();
var secondsToMilliseconds = __name((seconds) => seconds * 1e3, "secondsToMilliseconds");
init_define_process();
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = __name((definition) => {
  if (Array.isArray(definition)) {
    invariant2(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x22, y22] = definition;
    return cubicBezier(x1, y1, x22, y22);
  } else if (typeof definition === "string") {
    invariant2(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
}, "easingDefinitionToFunction");
var isEasingArray = __name((ease) => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
}, "isEasingArray");
init_define_process();
var isAnimatable = __name((key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
    return true;
  }
  return false;
}, "isAnimatable");
init_define_process();
var underDampedSpring = __name(() => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}), "underDampedSpring");
var criticallyDampedSpring = __name((to) => ({
  type: "spring",
  stiffness: 550,
  damping: to === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), "criticallyDampedSpring");
var linearTween = __name(() => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
}), "linearTween");
var keyframes2 = __name((values3) => ({
  type: "keyframes",
  duration: 0.8,
  values: values3
}), "keyframes");
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = __name((valueKey, to) => {
  let transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes2;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return { to, ...transitionFactory(to) };
}, "getDefaultTransition");
init_define_process();
var instantAnimationState = {
  current: false
};
function isTransitionDefined({ when, delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, ...transition }) {
  return !!Object.keys(transition).length;
}
__name(isTransitionDefined, "isTransitionDefined");
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions({ ease, times, yoyo, flip: flip3, loop, ...transition }) {
  const options = { ...transition };
  if (times)
    options["offset"] = times;
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop || flip3) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop) {
      options.repeatType = "loop";
    } else if (flip3) {
      options.repeatType = "mirror";
    }
    options.repeat = loop || yoyo || flip3 || transition.repeat;
  }
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
__name(convertTransitionToAnimationOptions, "convertTransitionToAnimationOptions");
function getDelayFromTransition(transition, key) {
  var _a, _b;
  const valueTransition = getValueTransition(transition, key) || {};
  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;
}
__name(getDelayFromTransition, "getDelayFromTransition");
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = [...options.to];
    options.to[0] = options.from;
  }
  return options;
}
__name(hydrateKeyframes, "hydrateKeyframes");
function getPopmotionAnimationOptions(transition, options, key) {
  if (Array.isArray(options.to) && transition.duration === void 0) {
    transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = {
      ...transition,
      ...getDefaultTransition(key, options.to)
    };
  }
  return {
    ...options,
    ...convertTransitionToAnimationOptions(transition)
  };
}
__name(getPopmotionAnimationOptions, "getPopmotionAnimationOptions");
function getAnimation(key, value, target, transition, onComplete) {
  const valueTransition = getValueTransition(transition, key) || {};
  let origin = valueTransition.from !== void 0 ? valueTransition.from : value.get();
  const isTargetAnimatable = isAnimatable(key, target);
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone2(key, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  const isOriginAnimatable = isAnimatable(key, origin);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from "${origin}" to "${target}". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \`style\` property.`);
  function start2() {
    const options = {
      from: origin,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: (v5) => value.set(v5)
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia({ ...options, ...valueTransition }) : animate({
      ...getPopmotionAnimationOptions(valueTransition, options, key),
      onUpdate: (v5) => {
        options.onUpdate(v5);
        valueTransition.onUpdate && valueTransition.onUpdate(v5);
      },
      onComplete: () => {
        options.onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    });
  }
  __name(start2, "start");
  function set3() {
    const finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    valueTransition.onUpdate && valueTransition.onUpdate(finalTarget);
    valueTransition.onComplete && valueTransition.onComplete();
    return { stop: () => {
    } };
  }
  __name(set3, "set");
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set3 : start2;
}
__name(getAnimation, "getAnimation");
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
__name(isZero, "isZero");
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
__name(getZeroUnit, "getZeroUnit");
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
__name(getValueTransition, "getValueTransition");
function startAnimation(key, value, target, transition = {}) {
  if (instantAnimationState.current) {
    transition = { type: false };
  }
  return value.start((onComplete) => {
    let delayTimer;
    let controls;
    const animation = getAnimation(key, value, target, transition, onComplete);
    const delay = getDelayFromTransition(transition, key);
    const start2 = __name(() => controls = animation(), "start");
    if (delay) {
      delayTimer = window.setTimeout(start2, secondsToMilliseconds(delay));
    } else {
      start2();
    }
    return () => {
      clearTimeout(delayTimer);
      controls && controls.stop();
    };
  });
}
__name(startAnimation, "startAnimation");
init_define_process();
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = new Set(transformPropOrder);
init_define_process();
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
__name(isWillChangeMotionValue, "isWillChangeMotionValue");
function animateVisualElement(visualElement2, definition, options = {}) {
  visualElement2.notifyAnimationStart(definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement2, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(() => visualElement2.notifyAnimationComplete(definition));
}
__name(animateVisualElement, "animateVisualElement");
function animateVariant(visualElement2, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement2, variant, options.custom);
  let { transition = visualElement2.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation2 = resolved ? () => animateTarget(visualElement2, resolved, options) : () => Promise.resolve();
  const getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first3, last3] = when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2];
    return first3().then(last3);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
__name(animateVariant, "animateVariant");
function animateTarget(visualElement2, definition, { delay = 0, transitionOverride, type } = {}) {
  var _a;
  let { transition = visualElement2.getDefaultTransition(), transitionEnd, ...target } = visualElement2.makeTargetAnimatable(definition);
  const willChange = visualElement2.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && ((_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);
  for (const key in target) {
    const value = visualElement2.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    let valueTransition = { delay, ...transition };
    if (visualElement2.shouldReduceMotion && transformProps.has(key)) {
      valueTransition = {
        ...valueTransition,
        type: false,
        delay: 0
      };
    }
    let animation = startAnimation(key, value, valueTarget, valueTransition);
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation = animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  return Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
__name(animateTarget, "animateTarget");
function animateChildren(visualElement2, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i4 = 0) => i4 * staggerChildren : (i4 = 0) => maxStaggerDuration - i4 * staggerChildren;
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach((child, i4) => {
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i4)
    }).then(() => child.notifyAnimationComplete(variant)));
  });
  return Promise.all(animations2);
}
__name(animateChildren, "animateChildren");
function stopAnimation(visualElement2) {
  visualElement2.forEachValue((value) => value.stop());
}
__name(stopAnimation, "stopAnimation");
function sortByTreeOrder(a22, b22) {
  return a22.sortNodePosition(b22);
}
__name(sortByTreeOrder, "sortByTreeOrder");
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
__name(shouldBlockAnimation, "shouldBlockAnimation");
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i4 = 0; i4 < prevLength; i4++) {
    if (prev[i4] !== next[i4])
      return false;
  }
  return true;
}
__name(shallowCompare, "shallowCompare");
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
var reversePriorityOrder = [...variantPriorityOrder].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement2, animation, options)));
}
__name(animateList, "animateList");
function createAnimationState(visualElement2) {
  let animate4 = animateList(visualElement2);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = __name((acc, definition) => {
    const resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  }, "buildResolvedTypeValues");
  function setAnimateFunction(makeAnimator) {
    animate4 = makeAnimator(visualElement2);
  }
  __name(setAnimateFunction, "setAnimateFunction");
  function animateChanges(options, changedActiveType) {
    var _a;
    const props = visualElement2.getProps();
    const context = visualElement2.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i4 = 0; i4 < numAnimationTypes; i4++) {
      const type = reversePriorityOrder[i4];
      const typeState = state[type];
      const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i4;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i4 > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = __name((key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      }, "markToAnimate");
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate4(animations2) : Promise.resolve();
  }
  __name(animateChanges, "animateChanges");
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  __name(setActive, "setActive");
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
__name(createAnimationState, "createAnimationState");
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
__name(checkVariantsDidChange, "checkVariantsDidChange");
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
__name(createTypeState, "createTypeState");
function createState() {
  return {
    [AnimationType.Animate]: createTypeState(true),
    [AnimationType.InView]: createTypeState(),
    [AnimationType.Hover]: createTypeState(),
    [AnimationType.Tap]: createTypeState(),
    [AnimationType.Drag]: createTypeState(),
    [AnimationType.Focus]: createTypeState(),
    [AnimationType.Exit]: createTypeState()
  };
}
__name(createState, "createState");
init_define_process();
var makeRenderlessComponent = __name((hook) => (props) => {
  hook(props);
  return null;
}, "makeRenderlessComponent");
var animations = {
  animation: makeRenderlessComponent(({ visualElement: visualElement2, animate: animate4 }) => {
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate4)) {
      useEffect(() => animate4.subscribe(visualElement2), [animate4]);
    }
  }),
  exit: makeRenderlessComponent((props) => {
    const { custom, visualElement: visualElement2 } = props;
    const [isPresent2, safeToRemove] = usePresence();
    const presenceContext = useContext(PresenceContext);
    useEffect(() => {
      visualElement2.isPresent = isPresent2;
      const animation = visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Exit, !isPresent2, {
        custom: presenceContext && presenceContext.custom || custom
      });
      if (animation && !isPresent2) {
        animation.then(safeToRemove);
      }
    }, [isPresent2]);
  })
};
init_define_process();
function calcLength(axis) {
  return axis.max - axis.min;
}
__name(calcLength, "calcLength");
function isNear(value, target = 0, maxDistance = 0.01) {
  return distance(value, target) < maxDistance;
}
__name(isNear, "isNear");
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
__name(calcAxisDelta, "calcAxisDelta");
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
__name(calcBoxDelta, "calcBoxDelta");
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
__name(calcRelativeAxis, "calcRelativeAxis");
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
__name(calcRelativeBox, "calcRelativeBox");
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
__name(calcRelativeAxisPosition, "calcRelativeAxisPosition");
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}
__name(calcRelativePosition, "calcRelativePosition");
init_define_process();
var createAxisDelta = __name(() => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), "createAxisDelta");
var createDelta2 = __name(() => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), "createDelta");
var createAxis = __name(() => ({ min: 0, max: 0 }), "createAxis");
var createBox = __name(() => ({
  x: createAxis(),
  y: createAxis()
}), "createBox");
init_define_process();
init_define_process();
init_define_process();
var prefersReducedMotion = { current: null };
var hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = __name(() => prefersReducedMotion.current = motionMediaQuery.matches, "setReducedMotionPreferences");
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
__name(initPrefersReducedMotion, "initPrefersReducedMotion");
init_define_process();
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "LayoutAnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  const managers = names.map(() => new SubscriptionManager());
  const propSubscriptions = {};
  const lifecycles = {
    clearAllListeners: () => managers.forEach((manager) => manager.clear()),
    updatePropListeners: (props) => {
      names.forEach((name) => {
        var _a;
        const on2 = "on" + name;
        const propListener = props[on2];
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name] = lifecycles[on2](propListener);
        }
      });
    }
  };
  managers.forEach((manager, i4) => {
    lifecycles["on" + names[i4]] = (handler) => manager.add(handler);
    lifecycles["notify" + names[i4]] = (...args) => manager.notify(...args);
  });
  return lifecycles;
}
__name(createLifecycles, "createLifecycles");
init_define_process();
init_define_process();
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}
__name(warnOnce, "warnOnce");
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
      if (false) {
        warnOnce(nextValue.version === "7.2.1", `Attempting to mix Framer Motion versions ${nextValue.version} with 7.2.1 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
__name(updateMotionValuesFromProps, "updateMotionValuesFromProps");
init_define_process();
var defaultEnvironment = "production";
var env = typeof define_process_default === "undefined" || define_process_default.env === void 0 ? defaultEnvironment : "production";
init_react_preact();
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
var visualElement = __name(({ treeType = "", build, getBaseTarget, makeTargetAnimatable, measureViewportBox: measureViewportBox2, render: renderInstance, readValueFromInstance, removeValueFromRenderState, sortNodePosition, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3 }) => ({ parent, props, presenceId, blockInitialAnimation, visualState, reducedMotionConfig }, options = {}) => {
  let isMounted = false;
  const { latestValues, renderState } = visualState;
  let instance;
  const lifecycles = createLifecycles();
  const values3 = /* @__PURE__ */ new Map();
  const valueSubscriptions = /* @__PURE__ */ new Map();
  let prevMotionValues = {};
  const baseTarget = {
    ...latestValues
  };
  let removeFromVariantTree;
  function render2() {
    if (!instance || !isMounted)
      return;
    triggerBuild();
    renderInstance(instance, renderState, props.style, element.projection);
  }
  __name(render2, "render");
  function triggerBuild() {
    build(element, renderState, latestValues, options, props);
  }
  __name(triggerBuild, "triggerBuild");
  function update8() {
    lifecycles.notifyUpdate(latestValues);
  }
  __name(update8, "update");
  function bindToMotionValue(key, value) {
    const removeOnChange = value.onChange((latestValue) => {
      latestValues[key] = latestValue;
      props.onUpdate && es_default.update(update8, false, true);
    });
    const removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);
    valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  __name(bindToMotionValue, "bindToMotionValue");
  const { willChange, ...initialMotionValues } = scrapeMotionValuesFromProps3(props);
  for (const key in initialMotionValues) {
    const value = initialMotionValues[key];
    if (latestValues[key] !== void 0 && isMotionValue(value)) {
      value.set(latestValues[key], false);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    }
  }
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  const element = {
    treeType,
    current: null,
    depth: parent ? parent.depth + 1 : 0,
    parent,
    children: /* @__PURE__ */ new Set(),
    presenceId,
    shouldReduceMotion: null,
    variantChildren: isVariantNode$1 ? /* @__PURE__ */ new Set() : void 0,
    isVisible: void 0,
    manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
    blockInitialAnimation,
    isMounted: () => Boolean(instance),
    mount(newInstance) {
      isMounted = true;
      instance = element.current = newInstance;
      if (element.projection) {
        element.projection.mount(newInstance);
      }
      if (isVariantNode$1 && parent && !isControllingVariants$1) {
        removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
      }
      values3.forEach((value, key) => bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      element.shouldReduceMotion = reducedMotionConfig === "never" ? false : reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      parent === null || parent === void 0 ? void 0 : parent.children.add(element);
      element.setProps(props);
    },
    unmount() {
      var _a;
      (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();
      cancelSync.update(update8);
      cancelSync.render(render2);
      valueSubscriptions.forEach((remove3) => remove3());
      removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
      parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
      lifecycles.clearAllListeners();
      instance = void 0;
      isMounted = false;
    },
    loadFeatures(renderedProps, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {
      const features = [];
      if (env !== "production" && preloadedFeatures && isStrict) {
        invariant2(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
      }
      for (let i4 = 0; i4 < numFeatures; i4++) {
        const name = featureNames[i4];
        const { isEnabled, Component: Component2 } = featureDefinitions[name];
        if (isEnabled(props) && Component2) {
          features.push(h(Component2, {
            key: name,
            ...renderedProps,
            visualElement: element
          }));
        }
      }
      if (!element.projection && ProjectionNodeConstructor) {
        element.projection = new ProjectionNodeConstructor(projectionId, element.getLatestValues(), parent && parent.projection);
        const { layoutId, layout, drag: drag2, dragConstraints, layoutScroll } = renderedProps;
        element.projection.setOptions({
          layoutId,
          layout,
          alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
          visualElement: element,
          scheduleRender: () => element.scheduleRender(),
          animationType: typeof layout === "string" ? layout : "both",
          initialPromotionConfig: initialLayoutGroupConfig,
          layoutScroll
        });
      }
      return features;
    },
    addVariantChild(child) {
      var _a;
      const closestVariantNode = element.getClosestVariantNode();
      if (closestVariantNode) {
        (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    },
    sortNodePosition(other) {
      if (!sortNodePosition || treeType !== other.treeType)
        return 0;
      return sortNodePosition(element.getInstance(), other.getInstance());
    },
    getClosestVariantNode: () => isVariantNode$1 ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode(),
    getLayoutId: () => props.layoutId,
    getInstance: () => instance,
    getStaticValue: (key) => latestValues[key],
    setStaticValue: (key, value) => latestValues[key] = value,
    getLatestValues: () => latestValues,
    setVisibility(visibility2) {
      if (element.isVisible === visibility2)
        return;
      element.isVisible = visibility2;
      element.scheduleRender();
    },
    makeTargetAnimatable(target, canMutate = true) {
      return makeTargetAnimatable(element, target, props, canMutate);
    },
    measureViewportBox() {
      return measureViewportBox2(instance, props);
    },
    addValue(key, value) {
      if (element.hasValue(key))
        element.removeValue(key);
      values3.set(key, value);
      latestValues[key] = value.get();
      bindToMotionValue(key, value);
    },
    removeValue(key) {
      var _a;
      values3.delete(key);
      (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();
      valueSubscriptions.delete(key);
      delete latestValues[key];
      removeValueFromRenderState(key, renderState);
    },
    hasValue: (key) => values3.has(key),
    getValue(key, defaultValue) {
      let value = values3.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue);
        element.addValue(key, value);
      }
      return value;
    },
    forEachValue: (callback) => values3.forEach(callback),
    readValue: (key) => latestValues[key] !== void 0 ? latestValues[key] : readValueFromInstance(instance, key, options),
    setBaseTarget(key, value) {
      baseTarget[key] = value;
    },
    getBaseTarget(key) {
      if (getBaseTarget) {
        const target = getBaseTarget(props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
      }
      return baseTarget[key];
    },
    ...lifecycles,
    build() {
      triggerBuild();
      return renderState;
    },
    scheduleRender() {
      es_default.render(render2, false, true);
    },
    syncRender: render2,
    setProps(newProps) {
      if (newProps.transformTemplate || props.transformTemplate) {
        element.scheduleRender();
      }
      props = newProps;
      lifecycles.updatePropListeners(newProps);
      prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
    },
    getProps: () => props,
    getVariant: (name) => {
      var _a;
      return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];
    },
    getDefaultTransition: () => props.transition,
    getTransformPagePoint: () => {
      return props.transformPagePoint;
    },
    getVariantContext(startAtParent = false) {
      if (startAtParent)
        return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
      if (!isControllingVariants$1) {
        const context2 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
        if (props.initial !== void 0) {
          context2.initial = props.initial;
        }
        return context2;
      }
      const context = {};
      for (let i4 = 0; i4 < numVariantProps; i4++) {
        const name = variantProps2[i4];
        const prop = props[name];
        if (isVariantLabel(prop) || prop === false) {
          context[name] = prop;
        }
      }
      return context;
    }
  };
  return element;
}, "visualElement");
var variantProps2 = ["initial", ...variantPriorityOrder];
var numVariantProps = variantProps2.length;
init_define_process();
function animate2(from, to, transition = {}) {
  const value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: () => value.stop(),
    isAnimating: () => value.isAnimating()
  };
}
__name(animate2, "animate");
init_define_process();
init_define_process();
var compareByDepth = __name((a22, b22) => a22.depth - b22.depth, "compareByDepth");
var FlatTree = class {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};
__name(FlatTree, "FlatTree");
init_define_process();
init_define_process();
function createMotionProxy(createConfig) {
  function custom(Component2, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component2, customMotionComponentConfig));
  }
  __name(custom, "custom");
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
__name(createMotionProxy, "createMotionProxy");
init_define_process();
init_define_process();
init_define_process();
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (typeof Component2 !== "string" || Component2.includes("-")) {
    return false;
  } else if (lowercaseSVGElements.indexOf(Component2) > -1 || /[A-Z]/.test(Component2)) {
    return true;
  }
  return false;
}
__name(isSVGComponent, "isSVGComponent");
init_define_process();
init_react_preact();
init_define_process();
init_react_preact();
init_define_process();
function isForcedMotionValue(key, { layout, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
__name(isForcedMotionValue, "isForcedMotionValue");
init_define_process();
init_define_process();
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var sortTransformProps = __name((a22, b22) => transformPropOrder.indexOf(a22) - transformPropOrder.indexOf(b22), "sortTransformProps");
function buildTransform({ transform: transform22, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  transformKeys2.sort(sortTransformProps);
  for (const key of transformKeys2) {
    transformString += `${translateAlias[key] || key}(${transform22[key]}) `;
  }
  if (enableHardwareAcceleration && !transform22.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform22, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
__name(buildTransform, "buildTransform");
init_define_process();
function isCSSVariable(key) {
  return key.startsWith("--");
}
__name(isCSSVariable, "isCSSVariable");
init_define_process();
var getValueAsType = __name((value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
}, "getValueAsType");
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style: style22, vars, transform: transform22, transformKeys: transformKeys2, transformOrigin } = state;
  transformKeys2.length = 0;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform22[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin[key] = valueAsType;
    } else {
      style22[key] = valueAsType;
    }
  }
  if (hasTransform2 || transformTemplate) {
    style22.transform = buildTransform(state, options, transformIsNone, transformTemplate);
  } else if (!latestValues.transform && style22.transform) {
    style22.transform = "none";
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style22.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
__name(buildHTMLStyles, "buildHTMLStyles");
init_define_process();
var createHtmlRenderState = __name(() => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
}), "createHtmlRenderState");
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
__name(copyRawValuesOnly, "copyRawValuesOnly");
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
__name(useInitialMotionValues, "useInitialMotionValues");
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style22 = {};
  copyRawValuesOnly(style22, styleProp, props);
  Object.assign(style22, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style22) : style22;
}
__name(useStyle, "useStyle");
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style22 = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style22.userSelect = style22.WebkitUserSelect = style22.WebkitTouchCallout = "none";
    style22.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  htmlProps.style = style22;
  return htmlProps;
}
__name(useHTMLProps, "useHTMLProps");
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
function calcOrigin(origin, offset2, size) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size * origin);
}
__name(calcOrigin, "calcOrigin");
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
__name(calcSVGTransformOrigin, "calcSVGTransformOrigin");
init_define_process();
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing2 = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys22 = useDashCase ? dashKeys : camelKeys;
  attrs[keys22.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing2);
  attrs[keys22.array] = `${pathLength} ${pathSpacing}`;
}
__name(buildSVGPath, "buildSVGPath");
function buildSVGAttrs(state, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  ...latest
}, options, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  const { attrs, style: style22, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style22.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style22.transform)) {
    style22.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
__name(buildSVGAttrs, "buildSVGAttrs");
init_define_process();
var createSvgRenderState = __name(() => ({
  ...createHtmlRenderState(),
  attrs: {}
}), "createSvgRenderState");
function useSVGProps(props, visualState) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
__name(useSVGProps, "useSVGProps");
function createUseRender(forwardMotionProps = false) {
  const useRender = __name((Component2, props, projectionId, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic);
    const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return h(Component2, elementProps);
  }, "useRender");
  return useRender;
}
__name(createUseRender, "createUseRender");
init_define_process();
init_define_process();
init_define_process();
var camelToDash = __name((str2) => str2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), "camelToDash");
init_define_process();
function renderHTML(element, { style: style22, vars }, styleProp, projection) {
  Object.assign(element.style, style22, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
__name(renderHTML, "renderHTML");
init_define_process();
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
__name(renderSVG, "renderSVG");
init_define_process();
init_define_process();
function scrapeMotionValuesFromProps(props) {
  const { style: style22 } = props;
  const newValues = {};
  for (const key in style22) {
    if (isMotionValue(style22[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style22[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps, "scrapeMotionValuesFromProps");
function scrapeMotionValuesFromProps2(props) {
  const newValues = scrapeMotionValuesFromProps(props);
  for (const key in props) {
    if (isMotionValue(props[key])) {
      const targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps2, "scrapeMotionValuesFromProps");
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e4) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
init_define_process();
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    projectionNodeConstructor,
    Component: Component2
  };
}
__name(createDomMotionConfig, "createDomMotionConfig");
init_define_process();
init_define_process();
function useFocusGesture({ whileFocus, visualElement: visualElement2 }) {
  const { animationState } = visualElement2;
  const onFocus = __name(() => {
    animationState && animationState.setActive(AnimationType.Focus, true);
  }, "onFocus");
  const onBlur = __name(() => {
    animationState && animationState.setActive(AnimationType.Focus, false);
  }, "onBlur");
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}
__name(useFocusGesture, "useFocusGesture");
init_define_process();
function createHoverEvent(visualElement2, isActive, callback) {
  return (event, info) => {
    if (!isMouseEvent(event) || isDragActive())
      return;
    if (visualElement2.animationState) {
      visualElement2.animationState.setActive(AnimationType.Hover, isActive);
    }
    callback && callback(event, info);
  };
}
__name(createHoverEvent, "createHoverEvent");
function useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement: visualElement2 }) {
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
}
__name(useHoverGesture, "useHoverGesture");
init_define_process();
init_react_preact();
init_define_process();
var isNodeOrChild = __name((parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
}, "isNodeOrChild");
function useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement: visualElement2 }) {
  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  const isPressing = useRef(false);
  const cancelPointerEndListeners = useRef(null);
  const eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    cancelPointerEndListeners.current && cancelPointerEndListeners.current();
    cancelPointerEndListeners.current = null;
  }
  __name(removePointerEndListener, "removePointerEndListener");
  function checkPointerEnd() {
    removePointerEndListener();
    isPressing.current = false;
    visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  __name(checkPointerEnd, "checkPointerEnd");
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel && onTapCancel(event, info) : onTap && onTap(event, info);
  }
  __name(onPointerUp, "onPointerUp");
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel && onTapCancel(event, info);
  }
  __name(onPointerCancel, "onPointerCancel");
  function onPointerDown(event, info) {
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    visualElement2.animationState && visualElement2.animationState.setActive(AnimationType.Tap, true);
    onTapStart && onTapStart(event, info);
  }
  __name(onPointerDown, "onPointerDown");
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
__name(useTapGesture, "useTapGesture");
init_define_process();
init_react_preact();
init_define_process();
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = __name((entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, "fireObserverCallback");
var fireAllObserverCallbacks = __name((entries3) => {
  entries3.forEach(fireObserverCallback);
}, "fireAllObserverCallbacks");
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
__name(initIntersectionObserver, "initIntersectionObserver");
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
__name(observeIntersection, "observeIntersection");
function useViewport({ visualElement: visualElement2, whileInView, onViewportEnter, onViewportLeave, viewport: viewport2 = {} }) {
  const state = useRef({
    hasEnteredView: false,
    isInView: false
  });
  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport2.once && state.current.hasEnteredView)
    shouldObserve = false;
  const useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement2, viewport2);
}
__name(useViewport, "useViewport");
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement2, { root, margin: rootMargin, amount = "some", once }) {
  useEffect(() => {
    if (!shouldObserve)
      return;
    const options = {
      root: root === null || root === void 0 ? void 0 : root.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const intersectionCallback = __name((entry) => {
      const { isIntersecting } = entry;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      if (visualElement2.animationState) {
        visualElement2.animationState.setActive(AnimationType.InView, isIntersecting);
      }
      const props = visualElement2.getProps();
      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback && callback(entry);
    }, "intersectionCallback");
    return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root, rootMargin, amount]);
}
__name(useIntersectionObserver, "useIntersectionObserver");
function useMissingIntersectionObserver(shouldObserve, state, visualElement2, { fallback = true }) {
  useEffect(() => {
    if (!shouldObserve || !fallback)
      return;
    if (env !== "production") {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(() => {
      state.hasEnteredView = true;
      const { onViewportEnter } = visualElement2.getProps();
      onViewportEnter && onViewportEnter(null);
      if (visualElement2.animationState) {
        visualElement2.animationState.setActive(AnimationType.InView, true);
      }
    });
  }, [shouldObserve]);
}
__name(useMissingIntersectionObserver, "useMissingIntersectionObserver");
var gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
var PanSession = class {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2;
      const { timestamp: timestamp2 } = getFrameData();
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      if (isMouseEvent(event2) && event2.buttons === 0) {
        this.handlePointerUp(event2, info2);
        return;
      }
      es_default.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (isTouchEvent(event) && event.touches.length > 1)
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point2 } = initialInfo;
    const { timestamp } = getFrameData();
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  }
};
__name(PanSession, "PanSession");
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
__name(transformPoint, "transformPoint");
function subtractPoint(a22, b22) {
  return { x: a22.x - b22.x, y: a22.y - b22.y };
}
__name(subtractPoint, "subtractPoint");
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
__name(getPanInfo, "getPanInfo");
function startDevicePoint(history) {
  return history[0];
}
__name(startDevicePoint, "startDevicePoint");
function lastDevicePoint(history) {
  return history[history.length - 1];
}
__name(lastDevicePoint, "lastDevicePoint");
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i4 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i4 >= 0) {
    timestampedPoint = history[i4];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i4--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
__name(getVelocity2, "getVelocity");
init_define_process();
function applyConstraints(point2, { min: min3, max: max3 }, elastic) {
  if (min3 !== void 0 && point2 < min3) {
    point2 = elastic ? mix(min3, point2, elastic.min) : Math.max(point2, min3);
  } else if (max3 !== void 0 && point2 > max3) {
    point2 = elastic ? mix(max3, point2, elastic.max) : Math.min(point2, max3);
  }
  return point2;
}
__name(applyConstraints, "applyConstraints");
function calcRelativeAxisConstraints(axis, min3, max3) {
  return {
    min: min3 !== void 0 ? axis.min + min3 : void 0,
    max: max3 !== void 0 ? axis.max + max3 - (axis.max - axis.min) : void 0
  };
}
__name(calcRelativeAxisConstraints, "calcRelativeAxisConstraints");
function calcRelativeConstraints(layoutBox, { top: top3, left: left3, bottom: bottom3, right: right3 }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left3, right3),
    y: calcRelativeAxisConstraints(layoutBox.y, top3, bottom3)
  };
}
__name(calcRelativeConstraints, "calcRelativeConstraints");
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min3 = constraintsAxis.min - layoutAxis.min;
  let max3 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min3, max3] = [max3, min3];
  }
  return { min: min3, max: max3 };
}
__name(calcViewportAxisConstraints, "calcViewportAxisConstraints");
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
__name(calcViewportConstraints, "calcViewportConstraints");
function calcOrigin2(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
__name(calcOrigin2, "calcOrigin");
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
__name(rebaseAxisConstraints, "rebaseAxisConstraints");
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
__name(resolveDragElastic, "resolveDragElastic");
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
__name(resolveAxisElastic, "resolveAxisElastic");
function resolvePointElastic(dragElastic, label) {
  var _a;
  return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
}
__name(resolvePointElastic, "resolvePointElastic");
init_define_process();
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
__name(eachAxis, "eachAxis");
init_define_process();
init_define_process();
function convertBoundingBoxToBox({ top: top3, left: left3, right: right3, bottom: bottom3 }) {
  return {
    x: { min: left3, max: right3 },
    y: { min: top3, max: bottom3 }
  };
}
__name(convertBoundingBoxToBox, "convertBoundingBoxToBox");
function convertBoxToBoundingBox({ x: x5, y: y4 }) {
  return { top: y4.min, right: x5.max, bottom: y4.max, left: x5.min };
}
__name(convertBoxToBoundingBox, "convertBoxToBoundingBox");
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top });
  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
__name(transformBoxPoints, "transformBoxPoints");
init_define_process();
init_define_process();
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
__name(isIdentityScale, "isIdentityScale");
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
__name(hasScale, "hasScale");
function hasTransform(values3) {
  return hasScale(values3) || hasTranslate(values3.x) || hasTranslate(values3.y) || values3.z || values3.rotate || values3.rotateX || values3.rotateY;
}
__name(hasTransform, "hasTransform");
function hasTranslate(value) {
  return value && value !== "0%";
}
__name(hasTranslate, "hasTranslate");
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
__name(scalePoint, "scalePoint");
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, boxScale, originPoint);
  }
  return scalePoint(point2, scale2, originPoint) + translate;
}
__name(applyPointDelta, "applyPointDelta");
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(applyAxisDelta, "applyAxisDelta");
function applyBoxDelta(box, { x: x5, y: y4 }) {
  applyAxisDelta(box.x, x5.translate, x5.scale, x5.originPoint);
  applyAxisDelta(box.y, y4.translate, y4.scale, y4.originPoint);
}
__name(applyBoxDelta, "applyBoxDelta");
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  var _a, _b;
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i4 = 0; i4 < treeLength; i4++) {
    node = treePath[i4];
    delta = node.projectionDelta;
    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
}
__name(applyTreeDeltas, "applyTreeDeltas");
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
__name(translateAxis, "translateAxis");
function transformAxis(axis, transforms2, [key, scaleKey, originKey]) {
  const axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key], transforms2[scaleKey], originPoint, transforms2.scale);
}
__name(transformAxis, "transformAxis");
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform22) {
  transformAxis(box.x, transform22, xKeys);
  transformAxis(box.y, transform22, yKeys);
}
__name(transformBox, "transformBox");
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
__name(measureViewportBox, "measureViewportBox");
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.x);
    translateAxis(viewportBox.y, scroll2.y);
  }
  return viewportBox;
}
__name(measurePageBox, "measurePageBox");
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = class {
  constructor(visualElement2) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement2;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const onSessionStart = __name((event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    }, "onSessionStart");
    const onStart = __name((event, info) => {
      var _a;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        var _a2, _b;
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];
          if (measuredAxis) {
            const length2 = calcLength(measuredAxis);
            current = length2 * (parseFloat(current) / 100);
          }
        }
        this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);
    }, "onStart");
    const onMove = __name((event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.syncRender();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    }, "onMove");
    const onSessionEnd = __name((event, info) => this.stop(event, info), "onSessionEnd");
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  }
  cancel() {
    var _a, _b;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant2(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      var _a;
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return startAnimation(axis, axisValue, 0, transition);
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  getAxisMotionValue(axis) {
    var _a, _b;
    const dragKey = "_drag" + axis.toUpperCase();
    const externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min3, max: max3 } = projection.layout.actual[axis];
        axisValue.set(point2[axis] - mix(min3, max3, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    var _a;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min3, max: max3 } = this.constraints[axis];
      axisValue.set(mix(min3, max3, boxProgress[axis]));
    });
  }
  addListeners() {
    var _a;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.getInstance();
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = __name(() => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    }, "measureDragConstraints");
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.syncRender();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
__name(VisualElementDragControls, "VisualElementDragControls");
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
__name(shouldDrag, "shouldDrag");
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
__name(getCurrentDirection, "getCurrentDirection");
function useDrag(props) {
  const { dragControls: groupDragControls, visualElement: visualElement2 } = props;
  const dragControls = useConstant(() => new VisualElementDragControls(visualElement2));
  useEffect(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);
  useEffect(() => dragControls.addListeners(), [dragControls]);
}
__name(useDrag, "useDrag");
init_define_process();
init_react_preact();
function usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement: visualElement2 }) {
  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  const panSession = useRef(null);
  const { transformPagePoint } = useContext(MotionConfigContext);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  useEffect(() => {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  __name(onPointerDown, "onPointerDown");
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(() => panSession.current && panSession.current.end());
}
__name(usePanGesture, "usePanGesture");
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
__name(isCSSVariable2, "isCSSVariable");
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
}
__name(parseCSSVariable, "parseCSSVariable");
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant2(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
__name(getVariableValue, "getVariableValue");
function resolveCSSVariables(visualElement2, { ...target }, transitionEnd) {
  const element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement2.forEachValue((value) => {
    const current = value.get();
    if (!isCSSVariable2(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariable2(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd && transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
__name(resolveCSSVariables, "resolveCSSVariables");
init_define_process();
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = __name((key) => positionalKeys.has(key), "isPositionalKey");
var hasPositionalKey = __name((target) => {
  return Object.keys(target).some(isPositionalKey);
}, "hasPositionalKey");
var setAndResetVelocity = __name((value, to) => {
  value.set(to, false);
  value.set(to);
}, "setAndResetVelocity");
var isNumOrPxType = __name((v5) => v5 === number || v5 === px, "isNumOrPxType");
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = __name((matrix, pos) => parseFloat(matrix.split(", ")[pos]), "getPosFromMatrix");
var getTranslateFromMatrix = __name((pos2, pos3) => (_bbox, { transform: transform22 }) => {
  if (transform22 === "none" || !transform22)
    return 0;
  const matrix3d = transform22.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform22.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
}, "getTranslateFromMatrix");
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement2) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
__name(removeNonTranslationalTransform, "removeNonTranslationalTransform");
var positionalValues = {
  width: ({ x: x5 }, { paddingLeft = "0", paddingRight = "0" }) => x5.max - x5.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y4 }, { paddingTop = "0", paddingBottom = "0" }) => y4.max - y4.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top3 }) => parseFloat(top3),
  left: (_bbox, { left: left3 }) => parseFloat(left3),
  bottom: ({ y: y4 }, { top: top3 }) => parseFloat(top3) + (y4.max - y4.min),
  right: ({ x: x5 }, { left: left3 }) => parseFloat(left3) + (x5.max - x5.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = __name((target, visualElement2, changedKeys) => {
  const originBbox = visualElement2.measureViewportBox();
  const element = visualElement2.getInstance();
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  const targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
}, "convertChangedValueTypes");
var checkAndConvertChangedValueTypes = __name((visualElement2, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    let from = origin[key];
    let fromType = findDimensionValueType(from);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i4 = fromIndex; i4 < numKeyframes; i4++) {
        if (!toType) {
          toType = findDimensionValueType(to[i4]);
          invariant2(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant2(findDimensionValueType(to[i4]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
}, "checkAndConvertChangedValueTypes");
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}
__name(unitConversion, "unitConversion");
var parseDomVariant = __name((visualElement2, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
}, "parseDomVariant");
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
__name(getComputedStyle2, "getComputedStyle");
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance(domElement, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle2(domElement);
      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  },
  sortNodePosition(a22, b22) {
    return a22.compareDocumentPosition(b22) & 2 ? 1 : -1;
  },
  getBaseTarget(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox(element, { transformPagePoint }) {
    return measureViewportBox(element, transformPagePoint);
  },
  resetTransform(element, domElement, props) {
    const { transformTemplate } = props;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState(key, { vars, style: style22 }) {
    delete vars[key];
    delete style22[key];
  },
  makeTargetAnimatable(element, { transition, transitionEnd, ...target }, { transformValues }, isMounted = true) {
    let origin = getOrigin(target, transition || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      const parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  },
  scrapeMotionValuesFromProps,
  build(element, renderState, latestValues, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);
init_define_process();
var svgVisualElement = visualElement({
  ...htmlConfig,
  getBaseTarget(props, key) {
    return props[key];
  },
  readValueFromInstance(domElement, key) {
    var _a;
    if (transformProps.has(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  build(_element, renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderSVG
});
var createDomVisualElement = __name((Component2, options) => {
  return isSVGComponent(Component2) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
}, "createDomVisualElement");
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
__name(pixelsToPercent, "pixelsToPercent");
var correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x5 = pixelsToPercent(latest, node.target.x);
    const y4 = pixelsToPercent(latest, node.target.y);
    return `${x5}% ${y4}%`;
  }
};
init_define_process();
var varToken = "_$css";
var correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const containsCSSVariables = latest.includes("var(");
    const cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, (match) => {
        cssVariables.push(match);
        return varToken;
      });
    }
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    let output = template(shadow);
    if (containsCSSVariables) {
      let i4 = 0;
      output = output.replace(varToken, () => {
        const cssVariable = cssVariables[i4];
        i4++;
        return cssVariable;
      });
    }
    return output;
  }
};
var MeasureLayoutWithContext = class extends react_preact_default.Component {
  componentDidMount() {
    const { visualElement: visualElement2, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement2;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement: visualElement2, drag: drag2, isPresent: isPresent2 } = this.props;
    const projection = visualElement2.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        es_default.postRender(() => {
          var _a;
          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  }
  componentWillUnmount() {
    const { visualElement: visualElement2, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement2;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  }
  render() {
    return null;
  }
};
__name(MeasureLayoutWithContext, "MeasureLayoutWithContext");
function MeasureLayout(props) {
  const [isPresent2, safeToRemove] = usePresence();
  const layoutGroup = useContext(LayoutGroupContext);
  return react_preact_default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
}
__name(MeasureLayout, "MeasureLayout");
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
var layoutFeatures = {
  measureLayout: MeasureLayout
};
init_define_process();
init_define_process();
init_define_process();
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = __name((value) => typeof value === "string" ? parseFloat(value) : value, "asNumber");
var isPx = __name((value) => typeof value === "number" || px.test(value), "isPx");
function mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {
  var _a, _b, _c, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,
      easeCrossfadeIn(progress3)
    );
    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));
  } else if (isOnlyMember) {
    target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);
  }
  for (let i4 = 0; i4 < numBorders; i4++) {
    const borderLabel = `border${borders[i4]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);
  }
}
__name(mixValues, "mixValues");
function getRadius(values3, radiusName) {
  var _a;
  return (_a = values3[radiusName]) !== null && _a !== void 0 ? _a : values3.borderRadius;
}
__name(getRadius, "getRadius");
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min3, max3, easing2) {
  return (p22) => {
    if (p22 < min3)
      return 0;
    if (p22 > max3)
      return 1;
    return easing2(progress(min3, max3, p22));
  };
}
__name(compress, "compress");
init_define_process();
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
__name(copyAxisInto, "copyAxisInto");
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
__name(copyBoxInto, "copyBoxInto");
init_define_process();
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  point2 -= translate;
  point2 = scalePoint(point2, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, 1 / boxScale, originPoint);
  }
  return point2;
}
__name(removePointDelta, "removePointDelta");
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(removeAxisDelta, "removeAxisDelta");
function removeAxisTransforms(axis, transforms2, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
__name(removeAxisTransforms, "removeAxisTransforms");
var xKeys2 = ["x", "scaleX", "originX"];
var yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms2, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
__name(removeBoxTransforms, "removeBoxTransforms");
init_define_process();
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
__name(isAxisDeltaZero, "isAxisDeltaZero");
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
__name(isDeltaZero, "isDeltaZero");
function boxEquals(a22, b22) {
  return a22.x.min === b22.x.min && a22.x.max === b22.x.max && a22.y.min === b22.y.min && a22.y.max === b22.y.max;
}
__name(boxEquals, "boxEquals");
init_define_process();
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i4 = indexOfNode; i4 >= 0; i4--) {
      const member = this.members[i4];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    var _a;
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        node.snapshot.isShared = true;
      }
      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      var _a, _b, _c, _d, _e;
      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};
__name(NodeStack, "NodeStack");
init_define_process();
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  let transform22 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  transform22 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform22 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform22 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform22 += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  transform22 += `scale(${elementScaleX}, ${elementScaleY})`;
  return transform22 === identityProjection ? "none" : transform22;
}
__name(buildProjectionTransform, "buildProjectionTransform");
var transformAxes = ["", "X", "Y", "Z"];
var animationTarget = 1e3;
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return __name(class ProjectionNode {
    constructor(id3, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.potentialNodes = /* @__PURE__ */ new Map();
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.id = id3;
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      id3 && this.root.registerPotentialNode(id3, this);
      for (let i4 = 0; i4 < this.path.length; i4++) {
        this.path[i4].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    registerPotentialNode(id3, node) {
      this.potentialNodes.set(id3, node);
    }
    mount(instance, isLayoutDirty = false) {
      var _a;
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      const { layoutId, layout, visualElement: visualElement2 } = this.options;
      if (visualElement2 && !visualElement2.getInstance()) {
        visualElement2.mount(instance);
      }
      this.root.nodes.add(this);
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);
      this.id && this.root.potentialNodes.delete(this.id);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let unblockTimeout;
        const resizeUnblockUpdate = __name(() => this.root.updateBlockedByResize = false, "resizeUnblockUpdate");
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          clearTimeout(unblockTimeout);
          unblockTimeout = window.setTimeout(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          var _a2, _b, _c, _d, _e;
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement2.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement2.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement2.shouldReduceMotion) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && this.animationProgress === 0) {
              this.finishAnimation();
            }
            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      var _a, _b;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);
      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var _a;
      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;
    }
    startUpdate() {
      var _a;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);
    }
    willUpdate(shouldNotifyListeners = true) {
      var _a, _b, _c;
      if (this.root.isUpdateBlocked()) {
        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i4 = 0; i4 < this.path.length; i4++) {
        const node = this.path[i4];
        node.shouldResetTransform = true;
        node.updateScroll();
      }
      const { layoutId, layout } = this.options;
      if (layoutId === void 0 && !layout)
        return;
      const transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
      this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    didUpdate() {
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync2.update();
      flushSync2.preRender();
      flushSync2.render();
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      es_default.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      es_default.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      const measured = this.measure();
      const layout = this.removeTransform(this.removeElementScroll(measured));
      roundBox(layout);
      this.snapshot = {
        measured,
        layout,
        latestValues: {}
      };
    }
    updateLayout() {
      var _a;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i4 = 0; i4 < this.path.length; i4++) {
          const node = this.path[i4];
          node.updateScroll();
        }
      }
      const measured = this.measure();
      roundBox(measured);
      const prevLayout = this.layout;
      this.layout = {
        measured,
        actual: this.removeElementScroll(measured)
      };
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.actual);
      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
    }
    updateScroll() {
      if (this.options.layoutScroll && this.instance) {
        this.isScrollRoot = checkIsScrollRoot(this.instance);
        this.scroll = measureScroll(this.instance);
      }
    }
    resetTransform() {
      var _a;
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;
      const transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure() {
      const { visualElement: visualElement2 } = this.options;
      if (!visualElement2)
        return createBox();
      const box = visualElement2.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.x);
        translateAxis(box.y, scroll2.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i4 = 0; i4 < this.path.length; i4++) {
        const node = this.path[i4];
        const { scroll: scroll2, options, isScrollRoot } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (isScrollRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.x);
          translateAxis(boxWithoutScroll.y, scroll2.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i4 = 0; i4 < this.path.length; i4++) {
        const node = this.path[i4];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.x,
            y: -node.scroll.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      var _a;
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i4 = 0; i4 < this.path.length; i4++) {
        const node = this.path[i4];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measure();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    resolveTargetDelta() {
      var _a;
      const { layout, layoutId } = this.options;
      if (!this.layout || !(layout || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && this.relativeParent.layout) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.actual);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.actual);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        this.relativeParent = this.getClosestProjectingParent();
        if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasTransform(this.parent.latestValues))
        return void 0;
      if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    calcProjection() {
      var _a;
      const { layout, layoutId } = this.options;
      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      const lead = this.getLead();
      copyBoxInto(this.layoutCorrected, this.layout.actual);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
      const { target } = lead;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta2();
        this.projectionDeltaWithTransform = createDelta2();
      }
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll2 = true) {
      var _a, _b, _c;
      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);
      notifyAll2 && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      var _a;
      const snapshot = this.snapshot;
      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta2();
      this.relativeTarget = this.relativeTargetOrigin = void 0;
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;
      const isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = (latest) => {
        var _a2;
        const progress3 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress3);
        mixAxisDelta(targetDelta.y, delta.y, progress3);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {
          calcRelativePosition(relativeLayout, this.layout.actual, this.relativeParent.layout.actual);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress3);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress3;
      };
      this.mixTargetDelta(0);
    }
    startAnimation(options) {
      var _a, _b;
      this.notifyListeners("animationStart");
      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      if (this.resumingFrom) {
        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = es_default.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animate2(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            var _a2;
            this.mixTargetDelta(latest);
            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);
          },
          onComplete: () => {
            var _a2;
            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var _a;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var _a;
      if (this.currentAnimation) {
        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const { targetWithTransforms, target, layout, latestValues } = this.getLead();
      if (!targetWithTransforms || !target || !layout)
        return;
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      var _a, _b, _c;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,
        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement: visualElement2 } = this.options;
      if (!visualElement2)
        return;
      let hasRotate = false;
      const resetValues = {};
      for (let i4 = 0; i4 < transformAxes.length; i4++) {
        const axis = transformAxes[i4];
        const key = "rotate" + axis;
        if (!visualElement2.getStaticValue(key)) {
          continue;
        }
        hasRotate = true;
        resetValues[key] = visualElement2.getStaticValue(key);
        visualElement2.setStaticValue(key, 0);
      }
      if (!hasRotate)
        return;
      visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
      for (const key in resetValues) {
        visualElement2.setStaticValue(key, resetValues[key]);
      }
      visualElement2.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a, _b, _c;
      const styles2 = {};
      if (!this.instance || this.isSVG)
        return styles2;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles2.visibility = "";
      }
      const transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles2.transform = transformTemplate(valuesToRender, styles2.transform);
      }
      const { x: x5, y: y4 } = this.projectionDelta;
      styles2.transformOrigin = `${x5.origin * 100}% ${y4.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_c = (_b = valuesToRender.opacity) !== null && _b !== void 0 ? _b : this.latestValues.opacity) !== null && _c !== void 0 ? _c : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i4 = 0; i4 < num; i4++) {
            styles2[applyTo[i4]] = corrected;
          }
        } else {
          styles2[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  }, "ProjectionNode");
}
__name(createProjectionNode, "createProjectionNode");
function updateLayout(node) {
  node.updateLayout();
}
__name(updateLayout, "updateLayout");
function notifyLayoutUpdate(node) {
  var _a, _b, _c;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { actual: layout, measured: measuredLayout } = node.layout;
    if (node.options.animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (node.options.animationType === "position") {
      eachAxis((axis) => {
        const axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];
        const length2 = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    }
    const layoutDelta = createDelta2();
    calcBoxDelta(layoutDelta, layout, snapshot.layout);
    const visualDelta = createDelta2();
    if (snapshot.isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layout);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      node.relativeParent = node.getClosestProjectingParent();
      if (node.relativeParent && !node.relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = node.relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);
  }
  node.options.transition = void 0;
}
__name(notifyLayoutUpdate, "notifyLayoutUpdate");
function clearSnapshot(node) {
  node.clearSnapshot();
}
__name(clearSnapshot, "clearSnapshot");
function clearMeasurements(node) {
  node.clearMeasurements();
}
__name(clearMeasurements, "clearMeasurements");
function resetTransformStyle(node) {
  const { visualElement: visualElement2 } = node.options;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node.resetTransform();
}
__name(resetTransformStyle, "resetTransformStyle");
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
__name(finishAnimation, "finishAnimation");
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
__name(resolveTargetDelta, "resolveTargetDelta");
function calcProjection(node) {
  node.calcProjection();
}
__name(calcProjection, "calcProjection");
function resetRotation(node) {
  node.resetRotation();
}
__name(resetRotation, "resetRotation");
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
__name(removeLeadSnapshots, "removeLeadSnapshots");
function mixAxisDelta(output, delta, p22) {
  output.translate = mix(delta.translate, 0, p22);
  output.scale = mix(delta.scale, 1, p22);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
__name(mixAxisDelta, "mixAxisDelta");
function mixAxis(output, from, to, p22) {
  output.min = mix(from.min, to.min, p22);
  output.max = mix(from.max, to.max, p22);
}
__name(mixAxis, "mixAxis");
function mixBox(output, from, to, p22) {
  mixAxis(output.x, from.x, to.x, p22);
  mixAxis(output.y, from.y, to.y, p22);
}
__name(mixBox, "mixBox");
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
__name(hasOpacityCrossfade, "hasOpacityCrossfade");
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, id3) {
  let searchNode = node.root;
  for (let i4 = node.path.length - 1; i4 >= 0; i4--) {
    if (Boolean(node.path[i4].instance)) {
      searchNode = node.path[i4];
      break;
    }
  }
  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  const element = searchElement.querySelector(`[data-projection-id="${id3}"]`);
  if (element)
    node.mount(element, true);
}
__name(mountNodeEarly, "mountNodeEarly");
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
__name(roundAxis, "roundAxis");
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
__name(roundBox, "roundBox");
init_define_process();
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
var featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutFeatures
};
var motion = createMotionProxy((Component2, config) => createDomMotionConfig(Component2, config, featureBundle, createDomVisualElement, HTMLProjectionNode));
function createDomMotionComponent(key) {
  return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement, HTMLProjectionNode));
}
__name(createDomMotionComponent, "createDomMotionComponent");
init_define_process();
var m4 = createMotionProxy(createDomMotionConfig);
init_define_process();
init_react_preact();
init_define_process();
init_react_preact();
function useIsMounted() {
  const isMounted = useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
__name(useIsMounted, "useIsMounted");
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = useState(0);
  const forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = useCallback(() => es_default.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
__name(useForceUpdate, "useForceUpdate");
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
init_react_preact();
init_react_preact();
var PopChildMeasure = class extends Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
__name(PopChildMeasure, "PopChildMeasure");
function PopChild({ children: children2, isPresent: isPresent2 }) {
  const id3 = useId();
  const ref = useRef(null);
  const size = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  useInsertionEffect(() => {
    const { width: width2, height: height2, top: top3, left: left3 } = size.current;
    if (isPresent2 || !ref.current || !width2 || !height2)
      return;
    ref.current.dataset.motionPopId = id3;
    const style22 = document.createElement("style");
    document.head.appendChild(style22);
    if (style22.sheet) {
      style22.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width2}px !important;
            height: ${height2}px !important;
            top: ${top3}px !important;
            left: ${left3}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style22);
    };
  }, [isPresent2]);
  return h(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size }, cloneElement(children2, { ref }));
}
__name(PopChild, "PopChild");
var PresenceChild = __name(({ children: children2, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id3 = useId();
  const context = useMemo(
    () => ({
      id: id3,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  useMemo(() => {
    presenceChildren.forEach((_5, key) => presenceChildren.set(key, false));
  }, [isPresent2]);
  useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2]);
  if (mode === "popLayout") {
    children2 = h(PopChild, { isPresent: isPresent2 }, children2);
  }
  return h(PresenceContext.Provider, { value: context }, children2);
}, "PresenceChild");
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
__name(newChildrenMap, "newChildrenMap");
var getChildKey = __name((child) => child.key || "", "getChildKey");
function updateChildLookup(children2, allChildren) {
  children2.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
__name(updateChildLookup, "updateChildLookup");
function onlyElements(children2) {
  const filtered = [];
  Children.forEach(children2, (child) => {
    if (isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
__name(onlyElements, "onlyElements");
var AnimatePresence = __name(({ children: children2, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  if (exitBeforeEnter) {
    mode = "wait";
    warnOnce(false, "Replace exitBeforeEnter with mode='wait'");
  }
  let [forceRender] = useForceUpdate();
  const forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children2);
  let childrenToRender = filteredChildren;
  const exiting = /* @__PURE__ */ new Set();
  const presentChildren = useRef(childrenToRender);
  const allChildren = useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = useRef(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return h(p, null, childrenToRender.map((child) => h(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i4 = 0; i4 < numPresent; i4++) {
    const key = presentKeys[i4];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (mode === "wait" && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    const onExit = __name(() => {
      allChildren.delete(key);
      exiting.delete(key);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    }, "onExit");
    childrenToRender.splice(insertionIndex, 0, h(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child));
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exiting.has(key) ? child : h(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  if (env !== "production" && mode === "wait" && childrenToRender.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  return h(p, null, exiting.size ? childrenToRender : childrenToRender.map((child) => cloneElement(child)));
}, "AnimatePresence");
init_define_process();
init_react_preact();
var DeprecatedLayoutGroupContext = createContext(null);
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
var notify = __name((node) => !node.isLayoutDirty && node.willUpdate(false), "notify");
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new WeakMap();
  const dirtyAll = __name(() => nodes.forEach(notify), "dirtyAll");
  return {
    add: (node) => {
      nodes.add(node);
      subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node) => {
      var _a;
      nodes.delete(node);
      (_a = subscriptions.get(node)) === null || _a === void 0 ? void 0 : _a();
      subscriptions.delete(node);
      dirtyAll();
    },
    dirty: dirtyAll
  };
}
__name(nodeGroup, "nodeGroup");
var shouldInheritGroup = __name((inherit) => inherit === true, "shouldInheritGroup");
var shouldInheritId = __name((inherit) => shouldInheritGroup(inherit === true) || inherit === "id", "shouldInheritId");
var LayoutGroup = __name(({ children: children2, id: id3, inheritId, inherit = true }) => {
  if (inheritId !== void 0)
    inherit = inheritId;
  const layoutGroupContext = useContext(LayoutGroupContext);
  const deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext);
  const [forceRender, key] = useForceUpdate();
  const context = useRef(null);
  const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  if (context.current === null) {
    if (shouldInheritId(inherit) && upstreamId) {
      id3 = id3 ? upstreamId + "-" + id3 : upstreamId;
    }
    context.current = {
      id: id3,
      group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()
    };
  }
  const memoizedContext = useMemo(() => ({ ...context.current, forceRender }), [key]);
  return h(LayoutGroupContext.Provider, { value: memoizedContext }, children2);
}, "LayoutGroup");
init_define_process();
init_react_preact();
var id2 = 0;
var AnimateSharedLayout = __name(({ children: children2 }) => {
  useEffect(() => {
    warning(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
  }, []);
  return h(LayoutGroup, { id: useConstant(() => `asl-${id2++}`) }, children2);
}, "AnimateSharedLayout");
init_define_process();
init_react_preact();
init_react_preact();
function MotionConfig({ children: children2, isValidProp, ...config }) {
  isValidProp && loadExternalIsValidProp(isValidProp);
  config = { ...useContext(MotionConfigContext), ...config };
  config.isStatic = useConstant(() => config.isStatic);
  const context = useMemo(() => config, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
  return h(MotionConfigContext.Provider, { value: context }, children2);
}
__name(MotionConfig, "MotionConfig");
init_define_process();
init_react_preact();
init_react_preact();
function LazyMotion({ children: children2, features, strict = false }) {
  const [, setIsLoaded] = useState(!isLazyBundle(features));
  const loadedRenderer = useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures);
  }
  useEffect(() => {
    if (isLazyBundle(features)) {
      features().then(({ renderer, ...loadedFeatures }) => {
        loadFeatures(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(true);
      });
    }
  }, []);
  return h(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children2);
}
__name(LazyMotion, "LazyMotion");
function isLazyBundle(features) {
  return typeof features === "function";
}
__name(isLazyBundle, "isLazyBundle");
init_define_process();
init_react_preact();
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  const { isStatic } = useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState(initial);
    useEffect(() => value.onChange(setLatest), []);
  }
  return value;
}
__name(useMotionValue, "useMotionValue");
init_define_process();
var isCustomValueType = __name((v5) => {
  return typeof v5 === "object" && v5.mix;
}, "isCustomValueType");
var getMixer2 = __name((v5) => isCustomValueType(v5) ? v5.mix : void 0, "getMixer");
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, {
    mixer: getMixer2(outputRange[0]),
    ...options
  });
  return useImmediate ? interpolator(inputValue) : interpolator;
}
__name(transform, "transform");
init_define_process();
init_define_process();
init_define_process();
function useOnChange(value, callback) {
  useIsomorphicLayoutEffect(() => {
    if (isMotionValue(value))
      return value.onChange(callback);
  }, [callback]);
}
__name(useOnChange, "useOnChange");
function useMultiOnChange(values3, handler) {
  useIsomorphicLayoutEffect(() => {
    const subscriptions = values3.map((value) => value.onChange(handler));
    return () => subscriptions.forEach((unsubscribe) => unsubscribe());
  });
}
__name(useMultiOnChange, "useMultiOnChange");
function useCombineMotionValues(values3, combineValues) {
  const value = useMotionValue(combineValues());
  const updateValue = __name(() => value.set(combineValues()), "updateValue");
  updateValue();
  useMultiOnChange(values3, () => es_default.update(updateValue, false, true));
  return value;
}
__name(useCombineMotionValues, "useCombineMotionValues");
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
__name(useTransform, "useTransform");
function useListTransform(values3, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values3, () => {
    latest.length = 0;
    const numValues = values3.length;
    for (let i4 = 0; i4 < numValues; i4++) {
      latest[i4] = values3[i4].get();
    }
    return transformer(latest);
  });
}
__name(useListTransform, "useListTransform");
init_define_process();
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
init_react_preact();
var ReorderContext = createContext(null);
init_define_process();
function checkReorder(order23, value, offset2, velocity) {
  if (!velocity)
    return order23;
  const index = order23.findIndex((item2) => item2.value === value);
  if (index === -1)
    return order23;
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem2 = order23[index + nextOffset];
  if (!nextItem2)
    return order23;
  const item = order23[index];
  const nextLayout = nextItem2.layout;
  const nextItemCenter = mix(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset2 > nextItemCenter || nextOffset === -1 && item.layout.min + offset2 < nextItemCenter) {
    return moveItem(order23, index, index + nextOffset);
  }
  return order23;
}
__name(checkReorder, "checkReorder");
function ReorderGroup({ children: children2, as = "ul", axis = "y", onReorder, values: values3, ...props }, externalRef) {
  const Component2 = useConstant(() => motion(as));
  const order23 = [];
  const isReordering = useRef(false);
  invariant2(Boolean(values3), "Reorder.Group must be provided a values prop");
  const context = {
    axis,
    registerItem: (value, layout) => {
      if (layout && order23.findIndex((entry) => value === entry.value) === -1) {
        order23.push({ value, layout: layout[axis] });
        order23.sort(compareMin);
      }
    },
    updateOrder: (id3, offset2, velocity) => {
      if (isReordering.current)
        return;
      const newOrder = checkReorder(order23, id3, offset2, velocity);
      if (order23 !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter((value) => values3.indexOf(value) !== -1));
      }
    }
  };
  useEffect(() => {
    isReordering.current = false;
  });
  return h(
    Component2,
    { ...props, ref: externalRef },
    h(ReorderContext.Provider, { value: context }, children2)
  );
}
__name(ReorderGroup, "ReorderGroup");
var Group = forwardRef(ReorderGroup);
function getValue(item) {
  return item.value;
}
__name(getValue, "getValue");
function compareMin(a22, b22) {
  return a22.layout.min - b22.layout.min;
}
__name(compareMin, "compareMin");
init_define_process();
init_react_preact();
init_react_preact();
function useDefaultMotionValue(value, defaultValue = 0) {
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
__name(useDefaultMotionValue, "useDefaultMotionValue");
function ReorderItem({ children: children2, style: style22 = {}, value, as = "li", onDrag, layout = true, ...props }, externalRef) {
  const Component2 = useConstant(() => motion(as));
  const context = useContext(ReorderContext);
  const point2 = {
    x: useDefaultMotionValue(style22.x),
    y: useDefaultMotionValue(style22.y)
  };
  const zIndex3 = useTransform([point2.x, point2.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
  const measuredLayout = useRef(null);
  invariant2(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  const { axis, registerItem, updateOrder } = context;
  useEffect(() => {
    registerItem(value, measuredLayout.current);
  }, [context]);
  return h(Component2, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style22, x: point2.x, y: point2.y, zIndex: zIndex3 }, layout, onDrag: (event, gesturePoint) => {
    const { velocity } = gesturePoint;
    velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis]);
    onDrag && onDrag(event, gesturePoint);
  }, onLayoutMeasure: (measured) => {
    measuredLayout.current = measured;
  }, ref: externalRef }, children2);
}
__name(ReorderItem, "ReorderItem");
var Item = forwardRef(ReorderItem);
init_define_process();
var domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
};
init_define_process();
var domMax = {
  ...domAnimation,
  ...drag,
  ...layoutFeatures,
  projectionNodeConstructor: HTMLProjectionNode
};
init_define_process();
function useMotionTemplate(fragments, ...values3) {
  const numFragments = fragments.length;
  function buildValue() {
    let output = ``;
    for (let i4 = 0; i4 < numFragments; i4++) {
      output += fragments[i4];
      const value = values3[i4];
      if (value)
        output += values3[i4].get();
    }
    return output;
  }
  __name(buildValue, "buildValue");
  return useCombineMotionValues(values3, buildValue);
}
__name(useMotionTemplate, "useMotionTemplate");
init_define_process();
init_react_preact();
function useSpring(source, config = {}) {
  const { isStatic } = useContext(MotionConfigContext);
  const activeSpringAnimation = useRef(null);
  const value = useMotionValue(isMotionValue(source) ? source.get() : source);
  useMemo(() => {
    return value.attach((v5, set3) => {
      if (isStatic)
        return set3(v5);
      if (activeSpringAnimation.current) {
        activeSpringAnimation.current.stop();
      }
      activeSpringAnimation.current = animate({
        from: value.get(),
        to: v5,
        velocity: value.getVelocity(),
        ...config,
        onUpdate: set3
      });
      return value.get();
    });
  }, [JSON.stringify(config)]);
  useOnChange(source, (v5) => value.set(parseFloat(v5)));
  return value;
}
__name(useSpring, "useSpring");
init_define_process();
init_react_preact();
function useVelocity(value) {
  const velocity = useMotionValue(value.getVelocity());
  useEffect(() => {
    return value.velocityUpdateSubscribers.add((newVelocity) => {
      velocity.set(newVelocity);
    });
  }, [value]);
  return velocity;
}
__name(useVelocity, "useVelocity");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var clamp3 = __name((min3, max3, v5) => Math.min(Math.max(v5, min3), max3), "clamp");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var isNumber = __name((value) => typeof value === "number", "isNumber");
var isEasingList = __name((easing2) => Array.isArray(easing2) && !isNumber(easing2[0]), "isEasingList");
init_define_process();
var wrap2 = __name((min3, max3, v5) => {
  const rangeSize = max3 - min3;
  return ((v5 - min3) % rangeSize + rangeSize) % rangeSize + min3;
}, "wrap");
function getEasingForSegment(easing2, i4) {
  return isEasingList(easing2) ? easing2[wrap2(0, easing2.length, i4)] : easing2;
}
__name(getEasingForSegment, "getEasingForSegment");
init_define_process();
init_define_process();
var mix2 = __name((min3, max3, progress3) => -progress3 * min3 + progress3 * max3 + min3, "mix");
init_define_process();
var noopReturn = __name((v5) => v5, "noopReturn");
init_define_process();
init_define_process();
var progress2 = __name((min3, max3, value) => max3 - min3 === 0 ? 1 : (value - min3) / (max3 - min3), "progress");
function fillOffset(offset2, remaining) {
  const min3 = offset2[offset2.length - 1];
  for (let i4 = 1; i4 <= remaining; i4++) {
    const offsetProgress = progress2(0, remaining, i4);
    offset2.push(mix2(min3, 1, offsetProgress));
  }
}
__name(fillOffset, "fillOffset");
function defaultOffset2(length2) {
  const offset2 = [0];
  fillOffset(offset2, length2 - 1);
  return offset2;
}
__name(defaultOffset2, "defaultOffset");
function interpolate2(output, input = defaultOffset2(output.length), easing2 = noopReturn) {
  const length2 = output.length;
  const remainder = length2 - input.length;
  remainder > 0 && fillOffset(input, remainder);
  return (t3) => {
    let i4 = 0;
    for (; i4 < length2 - 2; i4++) {
      if (t3 < input[i4 + 1])
        break;
    }
    let progressInRange = clamp3(0, 1, progress2(input[i4], input[i4 + 1], t3));
    const segmentEasing = getEasingForSegment(easing2, i4);
    progressInRange = segmentEasing(progressInRange);
    return mix2(output[i4], output[i4 + 1], progressInRange);
  };
}
__name(interpolate2, "interpolate");
init_define_process();
init_define_process();
init_define_process();
var isFunction = __name((value) => typeof value === "function", "isFunction");
init_define_process();
var isString2 = __name((value) => typeof value === "string", "isString");
init_define_process();
var time = {
  ms: (seconds) => seconds * 1e3,
  s: (milliseconds) => milliseconds / 1e3
};
init_define_process();
function velocityPerSecond2(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
__name(velocityPerSecond2, "velocityPerSecond");
var axes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: (v5) => v5 + "deg"
};
var baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: (v5) => v5 + "px"
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: noopReturn
  },
  skew: rotation
};
var transformDefinitions = /* @__PURE__ */ new Map();
var asTransformCssVar = __name((name) => `--motion-${name}`, "asTransformCssVar");
var transforms = ["x", "y", "z"];
order.forEach((name) => {
  axes.forEach((axis) => {
    transforms.push(name + axis);
    transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);
  });
});
var transformLookup = new Set(transforms);
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var calcBezier2 = __name((t3, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t3 + (3 * a22 - 6 * a1)) * t3 + 3 * a1) * t3, "calcBezier");
var subdivisionPrecision2 = 1e-7;
var subdivisionMaxIterations2 = 12;
function binarySubdivide2(x5, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i4 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier2(currentT, mX1, mX2) - x5;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision2 && ++i4 < subdivisionMaxIterations2);
  return currentT;
}
__name(binarySubdivide2, "binarySubdivide");
function cubicBezier2(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noopReturn;
  const getTForX = __name((aX) => binarySubdivide2(aX, 0, 1, mX1, mX2), "getTForX");
  return (t3) => t3 === 0 || t3 === 1 ? t3 : calcBezier2(getTForX(t3), mY1, mY2);
}
__name(cubicBezier2, "cubicBezier");
init_define_process();
var namedEasings = {
  ease: cubicBezier2(0.25, 0.1, 0.25, 1),
  "ease-in": cubicBezier2(0.42, 0, 1, 1),
  "ease-in-out": cubicBezier2(0.42, 0, 0.58, 1),
  "ease-out": cubicBezier2(0, 0, 0.58, 1)
};
init_define_process();
init_define_process();
var testAnimation = __name((keyframes3, options) => document.createElement("div").animate(keyframes3, options), "testAnimation");
var featureTests = {
  cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  partialKeyframes: () => {
    try {
      testAnimation({ opacity: [1] });
    } catch (e4) {
      return false;
    }
    return true;
  },
  finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 1e-3 }).finished),
  linearEasing: () => {
    try {
      testAnimation({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e4) {
      return false;
    }
    return true;
  }
};
var results = {};
var supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function resolveElements(elements, selectorCache) {
  var _a;
  if (typeof elements === "string") {
    if (selectorCache) {
      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = document.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}
__name(resolveElements, "resolveElements");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var sampleT = 5;
function calcGeneratorVelocity(resolveValue, t3, current) {
  const prevT = Math.max(t3 - sampleT, 0);
  return velocityPerSecond2(current - resolveValue(prevT), t3 - prevT);
}
__name(calcGeneratorVelocity, "calcGeneratorVelocity");
init_define_process();
init_define_process();
var defaults2 = {
  stiffness: 100,
  damping: 10,
  mass: 1
};
init_define_process();
var calcDampingRatio = __name((stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass) => damping / (2 * Math.sqrt(stiffness * mass)), "calcDampingRatio");
init_define_process();
function hasReachedTarget(origin, target, current) {
  return origin < target && current >= target || origin > target && current <= target;
}
__name(hasReachedTarget, "hasReachedTarget");
var spring2 = __name(({ stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass, from = 0, to = 1, velocity = 0, restSpeed = 2, restDistance = 0.5 } = {}) => {
  velocity = velocity ? time.s(velocity) : 0;
  const state = {
    done: false,
    hasReachedTarget: false,
    current: from,
    target: to
  };
  const initialDelta = to - from;
  const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
  const dampingRatio = calcDampingRatio(stiffness, damping, mass);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    resolveSpring = __name((t3) => to - Math.exp(-dampingRatio * undampedAngularFreq * t3) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t3) + initialDelta * Math.cos(angularFreq * t3)), "resolveSpring");
  } else {
    resolveSpring = __name((t3) => {
      return to - Math.exp(-undampedAngularFreq * t3) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t3);
    }, "resolveSpring");
  }
  return (t3) => {
    state.current = resolveSpring(t3);
    const currentVelocity = t3 === 0 ? velocity : calcGeneratorVelocity(resolveSpring, t3, state.current);
    const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
    const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;
    state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
    state.hasReachedTarget = hasReachedTarget(from, to, state.current);
    return state;
  };
}, "spring");
var glide = __name(({ from = 0, velocity = 0, power = 0.8, decay: decay2 = 0.325, bounceDamping, bounceStiffness, changeTarget, min: min3, max: max3, restDistance = 0.5, restSpeed }) => {
  decay2 = time.ms(decay2);
  const state = {
    hasReachedTarget: false,
    done: false,
    current: from,
    target: from
  };
  const isOutOfBounds = __name((v5) => min3 !== void 0 && v5 < min3 || max3 !== void 0 && v5 > max3, "isOutOfBounds");
  const nearestBoundary = __name((v5) => {
    if (min3 === void 0)
      return max3;
    if (max3 === void 0)
      return min3;
    return Math.abs(min3 - v5) < Math.abs(max3 - v5) ? min3 : max3;
  }, "nearestBoundary");
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = changeTarget === void 0 ? ideal : changeTarget(ideal);
  state.target = target;
  if (target !== ideal)
    amplitude = target - from;
  const calcDelta = __name((t3) => -amplitude * Math.exp(-t3 / decay2), "calcDelta");
  const calcLatest = __name((t3) => target + calcDelta(t3), "calcLatest");
  const applyFriction = __name((t3) => {
    const delta = calcDelta(t3);
    const latest = calcLatest(t3);
    state.done = Math.abs(delta) <= restDistance;
    state.current = state.done ? target : latest;
  }, "applyFriction");
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = __name((t3) => {
    if (!isOutOfBounds(state.current))
      return;
    timeReachedBoundary = t3;
    spring$1 = spring2({
      from: state.current,
      to: nearestBoundary(state.current),
      velocity: calcGeneratorVelocity(calcLatest, t3, state.current),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDistance,
      restSpeed
    });
  }, "checkCatchBoundary");
  checkCatchBoundary(0);
  return (t3) => {
    let hasUpdatedFrame = false;
    if (!spring$1 && timeReachedBoundary === void 0) {
      hasUpdatedFrame = true;
      applyFriction(t3);
      checkCatchBoundary(t3);
    }
    if (timeReachedBoundary !== void 0 && t3 > timeReachedBoundary) {
      state.hasReachedTarget = true;
      return spring$1(t3 - timeReachedBoundary);
    } else {
      state.hasReachedTarget = false;
      !hasUpdatedFrame && applyFriction(t3);
      return state;
    }
  };
}, "glide");
init_define_process();
var timeStep = 10;
var maxDuration2 = 1e4;
function pregenerateKeyframes(generator, toUnit = noopReturn) {
  let overshootDuration = void 0;
  let timestamp = timeStep;
  let state = generator(0);
  const keyframes3 = [toUnit(state.current)];
  while (!state.done && timestamp < maxDuration2) {
    state = generator(timestamp);
    keyframes3.push(toUnit(state.done ? state.target : state.current));
    if (overshootDuration === void 0 && state.hasReachedTarget) {
      overshootDuration = timestamp;
    }
    timestamp += timeStep;
  }
  const duration2 = timestamp - timeStep;
  if (keyframes3.length === 1)
    keyframes3.push(state.current);
  return {
    keyframes: keyframes3,
    duration: duration2 / 1e3,
    overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration2) / 1e3
  };
}
__name(pregenerateKeyframes, "pregenerateKeyframes");
init_define_process();
function createGeneratorEasing(createGenerator) {
  const keyframesCache = /* @__PURE__ */ new WeakMap();
  return (options = {}) => {
    const generatorCache = /* @__PURE__ */ new Map();
    const getGenerator = __name((from = 0, to = 100, velocity = 0, isScale = false) => {
      const key = `${from}-${to}-${velocity}-${isScale}`;
      if (!generatorCache.has(key)) {
        generatorCache.set(key, createGenerator(Object.assign({
          from,
          to,
          velocity,
          restSpeed: isScale ? 0.05 : 2,
          restDistance: isScale ? 0.01 : 0.5
        }, options)));
      }
      return generatorCache.get(key);
    }, "getGenerator");
    const getKeyframes = __name((generator) => {
      if (!keyframesCache.has(generator)) {
        keyframesCache.set(generator, pregenerateKeyframes(generator));
      }
      return keyframesCache.get(generator);
    }, "getKeyframes");
    return {
      createAnimation: (keyframes3, getOrigin2, canUseGenerator, name, motionValue2) => {
        var _a, _b;
        let settings;
        const numKeyframes = keyframes3.length;
        let shouldUseGenerator = canUseGenerator && numKeyframes <= 2 && keyframes3.every(isNumberOrNull);
        if (shouldUseGenerator) {
          const target = keyframes3[numKeyframes - 1];
          const unresolvedOrigin = numKeyframes === 1 ? null : keyframes3[0];
          let velocity = 0;
          let origin = 0;
          const prevGenerator = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.generator;
          if (prevGenerator) {
            const { animation, generatorStartTime } = motionValue2;
            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;
            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;
            const prevGeneratorCurrent = prevGenerator(currentTime).current;
            origin = (_a = unresolvedOrigin) !== null && _a !== void 0 ? _a : prevGeneratorCurrent;
            if (numKeyframes === 1 || numKeyframes === 2 && keyframes3[0] === null) {
              velocity = calcGeneratorVelocity((t3) => prevGenerator(t3).current, currentTime, prevGeneratorCurrent);
            }
          } else {
            origin = (_b = unresolvedOrigin) !== null && _b !== void 0 ? _b : parseFloat(getOrigin2());
          }
          const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes("scale"));
          const keyframesMetadata = getKeyframes(generator);
          settings = Object.assign(Object.assign({}, keyframesMetadata), { easing: "linear" });
          if (motionValue2) {
            motionValue2.generator = generator;
            motionValue2.generatorStartTime = performance.now();
          }
        } else {
          const keyframesMetadata = getKeyframes(getGenerator(0, 100));
          settings = {
            easing: "ease",
            duration: keyframesMetadata.overshootDuration
          };
        }
        return settings;
      }
    };
  };
}
__name(createGeneratorEasing, "createGeneratorEasing");
var isNumberOrNull = __name((value) => typeof value !== "string", "isNumberOrNull");
var spring3 = createGeneratorEasing(spring2);
init_define_process();
var glide2 = createGeneratorEasing(glide);
init_define_process();
var thresholds = {
  any: 0,
  all: 1
};
function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "any" } = {}) {
  if (typeof IntersectionObserver === "undefined") {
    return () => {
    };
  }
  const elements = resolveElements(elementOrSelector);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = __name((entries3) => {
    entries3.forEach((entry) => {
      const onEnd = activeIntersections.get(entry.target);
      if (entry.isIntersecting === Boolean(onEnd))
        return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (isFunction(newOnEnd)) {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer2.unobserve(entry.target);
        }
      } else if (onEnd) {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  }, "onIntersectionChange");
  const observer2 = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach((element) => observer2.observe(element));
  return () => observer2.disconnect();
}
__name(inView, "inView");
init_define_process();
init_define_process();
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var observer;
function getElementSize(target, borderBoxSize) {
  if (borderBoxSize) {
    const { inlineSize, blockSize } = borderBoxSize[0];
    return { width: inlineSize, height: blockSize };
  } else if (target instanceof SVGElement && "getBBox" in target) {
    return target.getBBox();
  } else {
    return {
      width: target.offsetWidth,
      height: target.offsetHeight
    };
  }
}
__name(getElementSize, "getElementSize");
function notifyTarget({ target, contentRect, borderBoxSize }) {
  var _a;
  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {
    handler({
      target,
      contentSize: contentRect,
      get size() {
        return getElementSize(target, borderBoxSize);
      }
    });
  });
}
__name(notifyTarget, "notifyTarget");
function notifyAll(entries3) {
  entries3.forEach(notifyTarget);
}
__name(notifyAll, "notifyAll");
function createResizeObserver() {
  if (typeof ResizeObserver === "undefined")
    return;
  observer = new ResizeObserver(notifyAll);
}
__name(createResizeObserver, "createResizeObserver");
function resizeElement(target, handler) {
  if (!observer)
    createResizeObserver();
  const elements = resolveElements(target);
  elements.forEach((element) => {
    let elementHandlers = resizeHandlers.get(element);
    if (!elementHandlers) {
      elementHandlers = /* @__PURE__ */ new Set();
      resizeHandlers.set(element, elementHandlers);
    }
    elementHandlers.add(handler);
    observer === null || observer === void 0 ? void 0 : observer.observe(element);
  });
  return () => {
    elements.forEach((element) => {
      const elementHandlers = resizeHandlers.get(element);
      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
      }
    });
  };
}
__name(resizeElement, "resizeElement");
init_define_process();
var windowCallbacks = /* @__PURE__ */ new Set();
var windowResizeHandler;
function createWindowResizeHandler() {
  windowResizeHandler = __name(() => {
    const size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    const info = {
      target: window,
      size,
      contentSize: size
    };
    windowCallbacks.forEach((callback) => callback(info));
  }, "windowResizeHandler");
  window.addEventListener("resize", windowResizeHandler);
}
__name(createWindowResizeHandler, "createWindowResizeHandler");
function resizeWindow(callback) {
  windowCallbacks.add(callback);
  if (!windowResizeHandler)
    createWindowResizeHandler();
  return () => {
    windowCallbacks.delete(callback);
    if (!windowCallbacks.size && windowResizeHandler) {
      windowResizeHandler = void 0;
    }
  };
}
__name(resizeWindow, "resizeWindow");
function resize(a22, b22) {
  return isFunction(a22) ? resizeWindow(a22) : resizeElement(a22, b22);
}
__name(resize, "resize");
init_define_process();
init_define_process();
var maxElapsed2 = 50;
var createAxisInfo = __name(() => ({
  current: 0,
  offset: [],
  progress: 0,
  scrollLength: 0,
  targetOffset: 0,
  targetLength: 0,
  containerLength: 0,
  velocity: 0
}), "createAxisInfo");
var createScrollInfo = __name(() => ({
  time: 0,
  x: createAxisInfo(),
  y: createAxisInfo()
}), "createScrollInfo");
var keys2 = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
function updateAxisInfo(element, axisName, info, time2) {
  const axis = info[axisName];
  const { length: length2, position: position2 } = keys2[axisName];
  const prev = axis.current;
  const prevTime = info.time;
  axis.current = element["scroll" + position2];
  axis.scrollLength = element["scroll" + length2] - element["client" + length2];
  axis.offset.length = 0;
  axis.offset[0] = 0;
  axis.offset[1] = axis.scrollLength;
  axis.progress = progress2(0, axis.scrollLength, axis.current);
  const elapsed = time2 - prevTime;
  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond2(axis.current - prev, elapsed);
}
__name(updateAxisInfo, "updateAxisInfo");
function updateScrollInfo(element, info, time2) {
  updateAxisInfo(element, "x", info, time2);
  updateAxisInfo(element, "y", info, time2);
  info.time = time2;
}
__name(updateScrollInfo, "updateScrollInfo");
init_define_process();
init_define_process();
init_define_process();
function calcInset(element, container) {
  let inset = { x: 0, y: 0 };
  let current = element;
  while (current && current !== container) {
    if (current instanceof HTMLElement) {
      inset.x += current.offsetLeft;
      inset.y += current.offsetTop;
      current = current.offsetParent;
    } else if (current instanceof SVGGraphicsElement && "getBBox" in current) {
      const { top: top3, left: left3 } = current.getBBox();
      inset.x += left3;
      inset.y += top3;
      while (current && current.tagName !== "svg") {
        current = current.parentNode;
      }
    }
  }
  return inset;
}
__name(calcInset, "calcInset");
init_define_process();
var ScrollOffset = {
  Enter: [
    [0, 1],
    [1, 1]
  ],
  Exit: [
    [0, 0],
    [1, 0]
  ],
  Any: [
    [1, 0],
    [0, 1]
  ],
  All: [
    [0, 0],
    [1, 1]
  ]
};
init_define_process();
init_define_process();
var namedEdges = {
  start: 0,
  center: 0.5,
  end: 1
};
function resolveEdge(edge, length2, inset = 0) {
  let delta = 0;
  if (namedEdges[edge] !== void 0) {
    edge = namedEdges[edge];
  }
  if (isString2(edge)) {
    const asNumber2 = parseFloat(edge);
    if (edge.endsWith("px")) {
      delta = asNumber2;
    } else if (edge.endsWith("%")) {
      edge = asNumber2 / 100;
    } else if (edge.endsWith("vw")) {
      delta = asNumber2 / 100 * document.documentElement.clientWidth;
    } else if (edge.endsWith("vh")) {
      delta = asNumber2 / 100 * document.documentElement.clientHeight;
    } else {
      edge = asNumber2;
    }
  }
  if (isNumber(edge)) {
    delta = length2 * edge;
  }
  return inset + delta;
}
__name(resolveEdge, "resolveEdge");
var defaultOffset3 = [0, 0];
function resolveOffset(offset2, containerLength, targetLength, targetInset) {
  let offsetDefinition = Array.isArray(offset2) ? offset2 : defaultOffset3;
  let targetPoint = 0;
  let containerPoint = 0;
  if (isNumber(offset2)) {
    offsetDefinition = [offset2, offset2];
  } else if (isString2(offset2)) {
    offset2 = offset2.trim();
    if (offset2.includes(" ")) {
      offsetDefinition = offset2.split(" ");
    } else {
      offsetDefinition = [offset2, namedEdges[offset2] ? offset2 : `0`];
    }
  }
  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
  containerPoint = resolveEdge(offsetDefinition[1], containerLength);
  return targetPoint - containerPoint;
}
__name(resolveOffset, "resolveOffset");
var point = { x: 0, y: 0 };
function resolveOffsets(container, info, options) {
  let { offset: offsetDefinition = ScrollOffset.All } = options;
  const { target = container, axis = "y" } = options;
  const lengthLabel = axis === "y" ? "height" : "width";
  const inset = target !== container ? calcInset(target, container) : point;
  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };
  const containerSize = {
    width: container.clientWidth,
    height: container.clientHeight
  };
  info[axis].offset.length = 0;
  let hasChanged2 = !info[axis].interpolate;
  const numOffsets = offsetDefinition.length;
  for (let i4 = 0; i4 < numOffsets; i4++) {
    const offset2 = resolveOffset(offsetDefinition[i4], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
    if (!hasChanged2 && offset2 !== info[axis].interpolatorOffsets[i4]) {
      hasChanged2 = true;
    }
    info[axis].offset[i4] = offset2;
  }
  if (hasChanged2) {
    info[axis].interpolate = interpolate2(defaultOffset2(numOffsets), info[axis].offset);
    info[axis].interpolatorOffsets = [...info[axis].offset];
  }
  info[axis].progress = info[axis].interpolate(info[axis].current);
}
__name(resolveOffsets, "resolveOffsets");
function measure(container, target = container, info) {
  info.x.targetOffset = 0;
  info.y.targetOffset = 0;
  if (target !== container) {
    let node = target;
    while (node && node != container) {
      info.x.targetOffset += node.offsetLeft;
      info.y.targetOffset += node.offsetTop;
      node = node.offsetParent;
    }
  }
  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
  info.x.containerLength = container.clientWidth;
  info.y.containerLength = container.clientHeight;
}
__name(measure, "measure");
function createOnScrollHandler(element, onScroll, info, options = {}) {
  const axis = options.axis || "y";
  return {
    measure: () => measure(element, options.target, info),
    update: (time2) => {
      updateScrollInfo(element, info, time2);
      if (options.offset || options.target) {
        resolveOffsets(element, info, options);
      }
    },
    notify: isFunction(onScroll) ? () => onScroll(info) : scrubAnimation(onScroll, info[axis])
  };
}
__name(createOnScrollHandler, "createOnScrollHandler");
function scrubAnimation(controls, axisInfo) {
  controls.pause();
  controls.forEachNative((animation, { easing: easing2 }) => {
    var _a, _b;
    if (animation.updateDuration) {
      if (!easing2)
        animation.easing = noopReturn;
      animation.updateDuration(1);
    } else {
      const timingOptions = { duration: 1e3 };
      if (!easing2)
        timingOptions.easing = "linear";
      (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);
    }
  });
  return () => {
    controls.currentTime = axisInfo.progress;
  };
}
__name(scrubAnimation, "scrubAnimation");
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getEventTarget = __name((element) => element === document.documentElement ? window : element, "getEventTarget");
function scroll(onScroll, _a = {}) {
  var { container = document.documentElement } = _a, options = __rest(_a, ["container"]);
  let containerHandlers = onScrollHandlers.get(container);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  const info = createScrollInfo();
  const containerHandler = createOnScrollHandler(container, onScroll, info, options);
  containerHandlers.add(containerHandler);
  if (!scrollListeners.has(container)) {
    const listener2 = __name(() => {
      const time2 = performance.now();
      for (const handler of containerHandlers)
        handler.measure();
      for (const handler of containerHandlers)
        handler.update(time2);
      for (const handler of containerHandlers)
        handler.notify();
    }, "listener");
    scrollListeners.set(container, listener2);
    const target = getEventTarget(container);
    window.addEventListener("resize", listener2, { passive: true });
    if (container !== document.documentElement) {
      resizeListeners.set(container, resize(container, listener2));
    }
    target.addEventListener("scroll", listener2, { passive: true });
  }
  const listener = scrollListeners.get(container);
  const onLoadProcesss = requestAnimationFrame(listener);
  return () => {
    var _a2;
    if (typeof onScroll !== "function")
      onScroll.stop();
    cancelAnimationFrame(onLoadProcesss);
    const containerHandlers2 = onScrollHandlers.get(container);
    if (!containerHandlers2)
      return;
    containerHandlers2.delete(containerHandler);
    if (containerHandlers2.size)
      return;
    const listener2 = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (listener2) {
      getEventTarget(container).removeEventListener("scroll", listener2);
      (_a2 = resizeListeners.get(container)) === null || _a2 === void 0 ? void 0 : _a2();
      window.removeEventListener("resize", listener2);
    }
  };
}
__name(scroll, "scroll");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function dispatchPointerEvent(element, name, event) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));
}
__name(dispatchPointerEvent, "dispatchPointerEvent");
function dispatchViewEvent(element, name, entry) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));
}
__name(dispatchViewEvent, "dispatchViewEvent");
var inView2 = {
  isActive: (options) => Boolean(options.inView),
  subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {
    const { once } = inViewOptions, viewOptions = __rest(inViewOptions, ["once"]);
    return inView(element, (enterEntry) => {
      enable();
      dispatchViewEvent(element, "viewenter", enterEntry);
      if (!once) {
        return (leaveEntry) => {
          disable();
          dispatchViewEvent(element, "viewleave", leaveEntry);
        };
      }
    }, viewOptions);
  }
};
init_define_process();
var mouseEvent = __name((element, name, action) => (event) => {
  if (event.pointerType && event.pointerType !== "mouse")
    return;
  action();
  dispatchPointerEvent(element, name, event);
}, "mouseEvent");
var hover = {
  isActive: (options) => Boolean(options.hover),
  subscribe: (element, { enable, disable }) => {
    const onEnter = mouseEvent(element, "hoverstart", enable);
    const onLeave = mouseEvent(element, "hoverend", disable);
    element.addEventListener("pointerenter", onEnter);
    element.addEventListener("pointerleave", onLeave);
    return () => {
      element.removeEventListener("pointerenter", onEnter);
      element.removeEventListener("pointerleave", onLeave);
    };
  }
};
init_define_process();
var press = {
  isActive: (options) => Boolean(options.press),
  subscribe: (element, { enable, disable }) => {
    const onPointerUp = __name((event) => {
      disable();
      dispatchPointerEvent(element, "pressend", event);
      window.removeEventListener("pointerup", onPointerUp);
    }, "onPointerUp");
    const onPointerDown = __name((event) => {
      enable();
      dispatchPointerEvent(element, "pressstart", event);
      window.addEventListener("pointerup", onPointerUp);
    }, "onPointerDown");
    element.addEventListener("pointerdown", onPointerDown);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }
};
var gestures = { inView: inView2, hover, press };
var stateTypes = ["initial", "animate", ...Object.keys(gestures), "exit"];
init_define_process();
init_define_process();
var createScrollMotionValues = __name(() => ({
  scrollX: motionValue(0),
  scrollY: motionValue(0),
  scrollXProgress: motionValue(0),
  scrollYProgress: motionValue(0)
}), "createScrollMotionValues");
function useScroll({ container, target, ...options } = {}) {
  const values3 = useConstant(createScrollMotionValues);
  useIsomorphicLayoutEffect(() => {
    return scroll(({ x: x5, y: y4 }) => {
      values3.scrollX.set(x5.current);
      values3.scrollXProgress.set(x5.progress);
      values3.scrollY.set(y4.current);
      values3.scrollYProgress.set(y4.progress);
    }, {
      ...options,
      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,
      target: (target === null || target === void 0 ? void 0 : target.current) || void 0
    });
  }, []);
  return values3;
}
__name(useScroll, "useScroll");
init_define_process();
function useElementScroll(ref) {
  warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
  return useScroll({ container: ref });
}
__name(useElementScroll, "useElementScroll");
init_define_process();
function useViewportScroll() {
  warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");
  return useScroll();
}
__name(useViewportScroll, "useViewportScroll");
init_define_process();
init_react_preact();
function useAnimationFrame(callback) {
  const initialTimestamp = useRef(0);
  const { isStatic } = useContext(MotionConfigContext);
  useEffect(() => {
    if (isStatic)
      return;
    const provideTimeSinceStart = __name(({ timestamp }) => {
      if (!initialTimestamp.current)
        initialTimestamp.current = timestamp;
      callback(timestamp - initialTimestamp.current);
    }, "provideTimeSinceStart");
    es_default.update(provideTimeSinceStart, true);
    return () => cancelSync.update(provideTimeSinceStart);
  }, [callback]);
}
__name(useAnimationFrame, "useAnimationFrame");
init_define_process();
function useTime() {
  const time2 = useMotionValue(0);
  useAnimationFrame((t3) => time2.set(t3));
  return time2;
}
__name(useTime, "useTime");
init_define_process();
var WillChangeMotionValue = class extends MotionValue {
  constructor() {
    super(...arguments);
    this.members = [];
    this.transforms = /* @__PURE__ */ new Set();
  }
  add(name) {
    let memberName;
    if (transformProps.has(name)) {
      this.transforms.add(name);
      memberName = "transform";
    } else if (!name.startsWith("origin") && !isCSSVariable(name) && name !== "willChange") {
      memberName = camelToDash(name);
    }
    if (memberName) {
      addUniqueItem(this.members, memberName);
      this.update();
    }
  }
  remove(name) {
    if (transformProps.has(name)) {
      this.transforms.delete(name);
      if (!this.transforms.size) {
        removeItem(this.members, "transform");
      }
    } else {
      removeItem(this.members, camelToDash(name));
    }
    this.update();
  }
  update() {
    this.set(this.members.length ? this.members.join(", ") : "auto");
  }
};
__name(WillChangeMotionValue, "WillChangeMotionValue");
function useWillChange() {
  return useConstant(() => new WillChangeMotionValue("auto"));
}
__name(useWillChange, "useWillChange");
init_define_process();
init_react_preact();
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = useState(prefersReducedMotion.current);
  return shouldReduceMotion;
}
__name(useReducedMotion, "useReducedMotion");
init_define_process();
init_react_preact();
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion();
  const { reducedMotion } = useContext(MotionConfigContext);
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}
__name(useReducedMotionConfig, "useReducedMotionConfig");
init_define_process();
function animationControls() {
  let hasMounted = false;
  const pendingAnimations = [];
  const subscribers = /* @__PURE__ */ new Set();
  const controls = {
    subscribe(visualElement2) {
      subscribers.add(visualElement2);
      return () => void subscribers.delete(visualElement2);
    },
    start(definition, transitionOverride) {
      if (hasMounted) {
        const animations2 = [];
        subscribers.forEach((visualElement2) => {
          animations2.push(animateVisualElement(visualElement2, definition, {
            transitionOverride
          }));
        });
        return Promise.all(animations2);
      } else {
        return new Promise((resolve) => {
          pendingAnimations.push({
            animation: [definition, transitionOverride],
            resolve
          });
        });
      }
    },
    set(definition) {
      invariant2(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach((visualElement2) => {
        setValues(visualElement2, definition);
      });
    },
    stop() {
      subscribers.forEach((visualElement2) => {
        stopAnimation(visualElement2);
      });
    },
    mount() {
      hasMounted = true;
      pendingAnimations.forEach(({ animation, resolve }) => {
        controls.start(...animation).then(resolve);
      });
      return () => {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}
__name(animationControls, "animationControls");
init_define_process();
init_react_preact();
function useAnimationControls() {
  const controls = useConstant(animationControls);
  useEffect(controls.mount, []);
  return controls;
}
__name(useAnimationControls, "useAnimationControls");
init_define_process();
init_react_preact();
function useCycle(...items) {
  const index = useRef(0);
  const [item, setItem] = useState(items[index.current]);
  const runCycle = useCallback(
    (next) => {
      index.current = typeof next !== "number" ? wrap(0, items.length, index.current + 1) : next;
      setItem(items[index.current]);
    },
    [items.length, ...items]
  );
  return [item, runCycle];
}
__name(useCycle, "useCycle");
init_define_process();
init_react_preact();
function useInView(ref, { root, margin: margin2, amount, once = false } = {}) {
  const [isInView, setInView] = useState(false);
  useEffect(() => {
    if (!ref.current || once && isInView)
      return;
    const onEnter = __name(() => {
      setInView(true);
      return once ? void 0 : () => setInView(false);
    }, "onEnter");
    const options = {
      root: root && root.current || void 0,
      margin: margin2,
      amount: amount === "some" ? "any" : amount
    };
    return inView(ref.current, onEnter, options);
  }, [root, ref, margin2, once]);
  return isInView;
}
__name(useInView, "useInView");
init_define_process();
var DragControls = class {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  subscribe(controls) {
    this.componentControls.add(controls);
    return () => this.componentControls.delete(controls);
  }
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
};
__name(DragControls, "DragControls");
var createDragControls = __name(() => new DragControls(), "createDragControls");
function useDragControls() {
  return useConstant(createDragControls);
}
__name(useDragControls, "useDragControls");
init_define_process();
function useInstantLayoutTransition() {
  return startTransition;
}
__name(useInstantLayoutTransition, "useInstantLayoutTransition");
function startTransition(callback) {
  if (!rootProjectionNode.current)
    return;
  rootProjectionNode.current.isUpdating = false;
  rootProjectionNode.current.blockUpdate();
  callback && callback();
}
__name(startTransition, "startTransition");
init_define_process();
init_react_preact();
function useInstantTransition() {
  const [forceUpdate, forcedRenderCount] = useForceUpdate();
  const startInstantLayoutTransition = useInstantLayoutTransition();
  useEffect(() => {
    es_default.postRender(() => es_default.postRender(() => instantAnimationState.current = false));
  }, [forcedRenderCount]);
  return (callback) => {
    startInstantLayoutTransition(() => {
      instantAnimationState.current = true;
      forceUpdate();
      callback();
    });
  };
}
__name(useInstantTransition, "useInstantTransition");
init_define_process();
init_react_preact();
function useResetProjection() {
  const reset = useCallback(() => {
    const root = rootProjectionNode.current;
    if (!root)
      return;
    root.resetTree();
  }, []);
  return reset;
}
__name(useResetProjection, "useResetProjection");
init_define_process();
init_react_preact();
var createObject = __name(() => ({}), "createObject");
var stateVisualElement = visualElement({
  build() {
  },
  measureViewportBox: createBox,
  resetTransform() {
  },
  restoreTransform() {
  },
  removeValueFromRenderState() {
  },
  render() {
  },
  scrapeMotionValuesFromProps: createObject,
  readValueFromInstance(_state, key, options) {
    return options.initialState[key] || 0;
  },
  makeTargetAnimatable(element, { transition, transitionEnd, ...target }) {
    const origin = getOrigin(target, transition || {}, element);
    checkTargetForNewValues(element, target, origin);
    return { transition, transitionEnd, ...target };
  }
});
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});
function useAnimatedState(initialState) {
  const [animationState, setAnimationState] = useState(initialState);
  const visualState = useVisualState({}, false);
  const element = useConstant(() => stateVisualElement({ props: {}, visualState }, { initialState }));
  useEffect(() => {
    element.mount({});
    return element.unmount;
  }, [element]);
  useEffect(() => {
    element.setProps({
      onUpdate: (v5) => {
        setAnimationState({ ...v5 });
      }
    });
  }, [setAnimationState, element]);
  const startAnimation2 = useConstant(() => (animationDefinition) => {
    return animateVisualElement(element, animationDefinition);
  });
  return [animationState, startAnimation2];
}
__name(useAnimatedState, "useAnimatedState");
init_define_process();
var maxScale = 1e5;
var invertScale = __name((scale2) => scale2 > 1e-3 ? 1 / scale2 : maxScale, "invertScale");
var hasWarned = false;
function useInvertedScale(scale2) {
  let parentScaleX = useMotionValue(1);
  let parentScaleY = useMotionValue(1);
  const visualElement2 = useVisualElementContext();
  invariant2(!!(scale2 || visualElement2), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale2) {
    parentScaleX = scale2.scaleX || parentScaleX;
    parentScaleY = scale2.scaleY || parentScaleY;
  } else if (visualElement2) {
    parentScaleX = visualElement2.getValue("scaleX", 1);
    parentScaleY = visualElement2.getValue("scaleY", 1);
  }
  const scaleX = useTransform(parentScaleX, invertScale);
  const scaleY = useTransform(parentScaleY, invertScale);
  return { scaleX, scaleY };
}
__name(useInvertedScale, "useInvertedScale");
init_define_process();

// dist/chunk-chunk-OIKVK376.mjs
var require_emotion_sheet_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-sheet-npm-1.2.0-3bb8dd5fba-9c9.zip/node_modules/@emotion/sheet/dist/emotion-sheet.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
        if (document.styleSheets[i4].ownerNode === tag) {
          return document.styleSheets[i4];
        }
      }
    }
    __name(sheetForTag, "sheetForTag");
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    __name(createStyleElement, "createStyleElement");
    var StyleSheet = function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      __name(StyleSheet2, "StyleSheet");
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = __name(function hydrate2(nodes) {
        nodes.forEach(this._insertTag);
      }, "hydrate");
      _proto.insert = __name(function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e4) {
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      }, "insert");
      _proto.flush = __name(function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      }, "flush");
      return StyleSheet2;
    }();
    exports.StyleSheet = StyleSheet;
  }
});
var require_emotion_sheet_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-sheet-npm-1.2.0-3bb8dd5fba-9c9.zip/node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_sheet_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_stylis = __commonJS({
  "../../../../.yarn/global/cache/stylis-npm-4.0.13-3f245d840f-9c9.zip/node_modules/stylis/dist/umd/stylis.js"(exports, module) {
    init_define_process();
    (function(e4, r5) {
      typeof exports === "object" && typeof module !== "undefined" ? r5(exports) : typeof define === "function" && define.amd ? define(["exports"], r5) : (e4 = e4 || self, r5(e4.stylis = {}));
    })(exports, function(e4) {
      "use strict";
      var r5 = "-ms-";
      var a5 = "-moz-";
      var c5 = "-webkit-";
      var t3 = "comm";
      var n3 = "rule";
      var s4 = "decl";
      var i4 = "@page";
      var u4 = "@media";
      var o5 = "@import";
      var f4 = "@charset";
      var l4 = "@viewport";
      var h4 = "@supports";
      var p4 = "@document";
      var v5 = "@namespace";
      var b5 = "@keyframes";
      var d4 = "@font-face";
      var m5 = "@counter-style";
      var w4 = "@font-feature-values";
      var k5 = Math.abs;
      var $3 = String.fromCharCode;
      var g5 = Object.assign;
      function x5(e22, r22) {
        return (((r22 << 2 ^ O3(e22, 0)) << 2 ^ O3(e22, 1)) << 2 ^ O3(e22, 2)) << 2 ^ O3(e22, 3);
      }
      __name(x5, "x");
      function E2(e22) {
        return e22.trim();
      }
      __name(E2, "E");
      function y4(e22, r22) {
        return (e22 = r22.exec(e22)) ? e22[0] : e22;
      }
      __name(y4, "y");
      function T4(e22, r22, a22) {
        return e22.replace(r22, a22);
      }
      __name(T4, "T");
      function A4(e22, r22) {
        return e22.indexOf(r22);
      }
      __name(A4, "A");
      function O3(e22, r22) {
        return e22.charCodeAt(r22) | 0;
      }
      __name(O3, "O");
      function C3(e22, r22, a22) {
        return e22.slice(r22, a22);
      }
      __name(C3, "C");
      function M3(e22) {
        return e22.length;
      }
      __name(M3, "M");
      function S4(e22) {
        return e22.length;
      }
      __name(S4, "S");
      function R2(e22, r22) {
        return r22.push(e22), e22;
      }
      __name(R2, "R");
      function z4(e22, r22) {
        return e22.map(r22).join("");
      }
      __name(z4, "z");
      e4.line = 1;
      e4.column = 1;
      e4.length = 0;
      e4.position = 0;
      e4.character = 0;
      e4.characters = "";
      function N3(r22, a22, c22, t22, n22, s22, i22) {
        return { value: r22, root: a22, parent: c22, type: t22, props: n22, children: s22, line: e4.line, column: e4.column, length: i22, return: "" };
      }
      __name(N3, "N");
      function P3(e22, r22) {
        return g5(N3("", null, null, "", null, null, 0), e22, { length: -e22.length }, r22);
      }
      __name(P3, "P");
      function j4() {
        return e4.character;
      }
      __name(j4, "j");
      function U2() {
        e4.character = e4.position > 0 ? O3(e4.characters, --e4.position) : 0;
        if (e4.column--, e4.character === 10)
          e4.column = 1, e4.line--;
        return e4.character;
      }
      __name(U2, "U");
      function _5() {
        e4.character = e4.position < e4.length ? O3(e4.characters, e4.position++) : 0;
        if (e4.column++, e4.character === 10)
          e4.column = 1, e4.line++;
        return e4.character;
      }
      __name(_5, "_");
      function F3() {
        return O3(e4.characters, e4.position);
      }
      __name(F3, "F");
      function I3() {
        return e4.position;
      }
      __name(I3, "I");
      function L3(r22, a22) {
        return C3(e4.characters, r22, a22);
      }
      __name(L3, "L");
      function D2(e22) {
        switch (e22) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      __name(D2, "D");
      function K2(r22) {
        return e4.line = e4.column = 1, e4.length = M3(e4.characters = r22), e4.position = 0, [];
      }
      __name(K2, "K");
      function V2(r22) {
        return e4.characters = "", r22;
      }
      __name(V2, "V");
      function W2(r22) {
        return E2(L3(e4.position - 1, Z2(r22 === 91 ? r22 + 2 : r22 === 40 ? r22 + 1 : r22)));
      }
      __name(W2, "W");
      function Y2(e22) {
        return V2(G2(K2(e22)));
      }
      __name(Y2, "Y");
      function B3(r22) {
        while (e4.character = F3())
          if (e4.character < 33)
            _5();
          else
            break;
        return D2(r22) > 2 || D2(e4.character) > 3 ? "" : " ";
      }
      __name(B3, "B");
      function G2(r22) {
        while (_5())
          switch (D2(e4.character)) {
            case 0:
              R2(J2(e4.position - 1), r22);
              break;
            case 2:
              R2(W2(e4.character), r22);
              break;
            default:
              R2($3(e4.character), r22);
          }
        return r22;
      }
      __name(G2, "G");
      function H3(r22, a22) {
        while (--a22 && _5())
          if (e4.character < 48 || e4.character > 102 || e4.character > 57 && e4.character < 65 || e4.character > 70 && e4.character < 97)
            break;
        return L3(r22, I3() + (a22 < 6 && F3() == 32 && _5() == 32));
      }
      __name(H3, "H");
      function Z2(r22) {
        while (_5())
          switch (e4.character) {
            case r22:
              return e4.position;
            case 34:
            case 39:
              if (r22 !== 34 && r22 !== 39)
                Z2(e4.character);
              break;
            case 40:
              if (r22 === 41)
                Z2(r22);
              break;
            case 92:
              _5();
              break;
          }
        return e4.position;
      }
      __name(Z2, "Z");
      function q4(r22, a22) {
        while (_5())
          if (r22 + e4.character === 47 + 10)
            break;
          else if (r22 + e4.character === 42 + 42 && F3() === 47)
            break;
        return "/*" + L3(a22, e4.position - 1) + "*" + $3(r22 === 47 ? r22 : _5());
      }
      __name(q4, "q");
      function J2(r22) {
        while (!D2(F3()))
          _5();
        return L3(r22, e4.position);
      }
      __name(J2, "J");
      function Q2(e22) {
        return V2(X2("", null, null, null, [""], e22 = K2(e22), 0, [0], e22));
      }
      __name(Q2, "Q");
      function X2(e22, r22, a22, c22, t22, n22, s22, i22, u22) {
        var o22 = 0;
        var f22 = 0;
        var l22 = s22;
        var h23 = 0;
        var p22 = 0;
        var v22 = 0;
        var b22 = 1;
        var d22 = 1;
        var m22 = 1;
        var w22 = 0;
        var k22 = "";
        var g22 = t22;
        var x22 = n22;
        var E22 = c22;
        var y22 = k22;
        while (d22)
          switch (v22 = w22, w22 = _5()) {
            case 40:
              if (v22 != 108 && y22.charCodeAt(l22 - 1) == 58) {
                if (A4(y22 += T4(W2(w22), "&", "&\f"), "&\f") != -1)
                  m22 = -1;
                break;
              }
            case 34:
            case 39:
            case 91:
              y22 += W2(w22);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              y22 += B3(v22);
              break;
            case 92:
              y22 += H3(I3() - 1, 7);
              continue;
            case 47:
              switch (F3()) {
                case 42:
                case 47:
                  R2(re(q4(_5(), I3()), r22, a22), u22);
                  break;
                default:
                  y22 += "/";
              }
              break;
            case 123 * b22:
              i22[o22++] = M3(y22) * m22;
            case 125 * b22:
            case 59:
            case 0:
              switch (w22) {
                case 0:
                case 125:
                  d22 = 0;
                case 59 + f22:
                  if (p22 > 0 && M3(y22) - l22)
                    R2(p22 > 32 ? ae(y22 + ";", c22, a22, l22 - 1) : ae(T4(y22, " ", "") + ";", c22, a22, l22 - 2), u22);
                  break;
                case 59:
                  y22 += ";";
                default:
                  R2(E22 = ee(y22, r22, a22, o22, f22, t22, i22, k22, g22 = [], x22 = [], l22), n22);
                  if (w22 === 123)
                    if (f22 === 0)
                      X2(y22, r22, E22, E22, g22, n22, l22, i22, x22);
                    else
                      switch (h23) {
                        case 100:
                        case 109:
                        case 115:
                          X2(e22, E22, E22, c22 && R2(ee(e22, E22, E22, 0, 0, t22, i22, k22, t22, g22 = [], l22), x22), t22, x22, l22, i22, c22 ? g22 : x22);
                          break;
                        default:
                          X2(y22, E22, E22, E22, [""], x22, 0, i22, x22);
                      }
              }
              o22 = f22 = p22 = 0, b22 = m22 = 1, k22 = y22 = "", l22 = s22;
              break;
            case 58:
              l22 = 1 + M3(y22), p22 = v22;
            default:
              if (b22 < 1) {
                if (w22 == 123)
                  --b22;
                else if (w22 == 125 && b22++ == 0 && U2() == 125)
                  continue;
              }
              switch (y22 += $3(w22), w22 * b22) {
                case 38:
                  m22 = f22 > 0 ? 1 : (y22 += "\f", -1);
                  break;
                case 44:
                  i22[o22++] = (M3(y22) - 1) * m22, m22 = 1;
                  break;
                case 64:
                  if (F3() === 45)
                    y22 += W2(_5());
                  h23 = F3(), f22 = l22 = M3(k22 = y22 += J2(I3())), w22++;
                  break;
                case 45:
                  if (v22 === 45 && M3(y22) == 2)
                    b22 = 0;
              }
          }
        return n22;
      }
      __name(X2, "X");
      function ee(e22, r22, a22, c22, t22, s22, i22, u22, o22, f22, l22) {
        var h23 = t22 - 1;
        var p22 = t22 === 0 ? s22 : [""];
        var v22 = S4(p22);
        for (var b22 = 0, d22 = 0, m22 = 0; b22 < c22; ++b22)
          for (var w22 = 0, $22 = C3(e22, h23 + 1, h23 = k5(d22 = i22[b22])), g22 = e22; w22 < v22; ++w22)
            if (g22 = E2(d22 > 0 ? p22[w22] + " " + $22 : T4($22, /&\f/g, p22[w22])))
              o22[m22++] = g22;
        return N3(e22, r22, a22, t22 === 0 ? n3 : u22, o22, f22, l22);
      }
      __name(ee, "ee");
      function re(e22, r22, a22) {
        return N3(e22, r22, a22, t3, $3(j4()), C3(e22, 2, -2), 0);
      }
      __name(re, "re");
      function ae(e22, r22, a22, c22) {
        return N3(e22, r22, a22, s4, C3(e22, 0, c22), C3(e22, c22 + 1, -1), c22);
      }
      __name(ae, "ae");
      function ce(e22, t22) {
        switch (x5(e22, t22)) {
          case 5103:
            return c5 + "print-" + e22 + e22;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return c5 + e22 + e22;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return c5 + e22 + a5 + e22 + r5 + e22 + e22;
          case 6828:
          case 4268:
            return c5 + e22 + r5 + e22 + e22;
          case 6165:
            return c5 + e22 + r5 + "flex-" + e22 + e22;
          case 5187:
            return c5 + e22 + T4(e22, /(\w+).+(:[^]+)/, c5 + "box-$1$2" + r5 + "flex-$1$2") + e22;
          case 5443:
            return c5 + e22 + r5 + "flex-item-" + T4(e22, /flex-|-self/, "") + e22;
          case 4675:
            return c5 + e22 + r5 + "flex-line-pack" + T4(e22, /align-content|flex-|-self/, "") + e22;
          case 5548:
            return c5 + e22 + r5 + T4(e22, "shrink", "negative") + e22;
          case 5292:
            return c5 + e22 + r5 + T4(e22, "basis", "preferred-size") + e22;
          case 6060:
            return c5 + "box-" + T4(e22, "-grow", "") + c5 + e22 + r5 + T4(e22, "grow", "positive") + e22;
          case 4554:
            return c5 + T4(e22, /([^-])(transform)/g, "$1" + c5 + "$2") + e22;
          case 6187:
            return T4(T4(T4(e22, /(zoom-|grab)/, c5 + "$1"), /(image-set)/, c5 + "$1"), e22, "") + e22;
          case 5495:
          case 3959:
            return T4(e22, /(image-set\([^]*)/, c5 + "$1$`$1");
          case 4968:
            return T4(T4(e22, /(.+:)(flex-)?(.*)/, c5 + "box-pack:$3" + r5 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + c5 + e22 + e22;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return T4(e22, /(.+)-inline(.+)/, c5 + "$1$2") + e22;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (M3(e22) - 1 - t22 > 6)
              switch (O3(e22, t22 + 1)) {
                case 109:
                  if (O3(e22, t22 + 4) !== 45)
                    break;
                case 102:
                  return T4(e22, /(.+:)(.+)-([^]+)/, "$1" + c5 + "$2-$3$1" + a5 + (O3(e22, t22 + 3) == 108 ? "$3" : "$2-$3")) + e22;
                case 115:
                  return ~A4(e22, "stretch") ? ce(T4(e22, "stretch", "fill-available"), t22) + e22 : e22;
              }
            break;
          case 4949:
            if (O3(e22, t22 + 1) !== 115)
              break;
          case 6444:
            switch (O3(e22, M3(e22) - 3 - (~A4(e22, "!important") && 10))) {
              case 107:
                return T4(e22, ":", ":" + c5) + e22;
              case 101:
                return T4(e22, /(.+:)([^;!]+)(;|!.+)?/, "$1" + c5 + (O3(e22, 14) === 45 ? "inline-" : "") + "box$3$1" + c5 + "$2$3$1" + r5 + "$2box$3") + e22;
            }
            break;
          case 5936:
            switch (O3(e22, t22 + 11)) {
              case 114:
                return c5 + e22 + r5 + T4(e22, /[svh]\w+-[tblr]{2}/, "tb") + e22;
              case 108:
                return c5 + e22 + r5 + T4(e22, /[svh]\w+-[tblr]{2}/, "tb-rl") + e22;
              case 45:
                return c5 + e22 + r5 + T4(e22, /[svh]\w+-[tblr]{2}/, "lr") + e22;
            }
            return c5 + e22 + r5 + e22 + e22;
        }
        return e22;
      }
      __name(ce, "ce");
      function te(e22, r22) {
        var a22 = "";
        var c22 = S4(e22);
        for (var t22 = 0; t22 < c22; t22++)
          a22 += r22(e22[t22], t22, e22, r22) || "";
        return a22;
      }
      __name(te, "te");
      function ne(e22, r22, a22, c22) {
        switch (e22.type) {
          case o5:
          case s4:
            return e22.return = e22.return || e22.value;
          case t3:
            return "";
          case b5:
            return e22.return = e22.value + "{" + te(e22.children, c22) + "}";
          case n3:
            e22.value = e22.props.join(",");
        }
        return M3(a22 = te(e22.children, c22)) ? e22.return = e22.value + "{" + a22 + "}" : "";
      }
      __name(ne, "ne");
      function se(e22) {
        var r22 = S4(e22);
        return function(a22, c22, t22, n22) {
          var s22 = "";
          for (var i22 = 0; i22 < r22; i22++)
            s22 += e22[i22](a22, c22, t22, n22) || "";
          return s22;
        };
      }
      __name(se, "se");
      function ie(e22) {
        return function(r22) {
          if (!r22.root) {
            if (r22 = r22.return)
              e22(r22);
          }
        };
      }
      __name(ie, "ie");
      function ue(e22, t22, i22, u22) {
        if (e22.length > -1) {
          if (!e22.return)
            switch (e22.type) {
              case s4:
                e22.return = ce(e22.value, e22.length);
                break;
              case b5:
                return te([P3(e22, { value: T4(e22.value, "@", "@" + c5) })], u22);
              case n3:
                if (e22.length)
                  return z4(e22.props, function(t32) {
                    switch (y4(t32, /(::plac\w+|:read-\w+)/)) {
                      case ":read-only":
                      case ":read-write":
                        return te([P3(e22, { props: [T4(t32, /:(read-\w+)/, ":" + a5 + "$1")] })], u22);
                      case "::placeholder":
                        return te([P3(e22, { props: [T4(t32, /:(plac\w+)/, ":" + c5 + "input-$1")] }), P3(e22, { props: [T4(t32, /:(plac\w+)/, ":" + a5 + "$1")] }), P3(e22, { props: [T4(t32, /:(plac\w+)/, r5 + "input-$1")] })], u22);
                    }
                    return "";
                  });
            }
        }
      }
      __name(ue, "ue");
      function oe(e22) {
        switch (e22.type) {
          case n3:
            e22.props = e22.props.map(function(r22) {
              return z4(Y2(r22), function(r32, a22, c22) {
                switch (O3(r32, 0)) {
                  case 12:
                    return C3(r32, 1, M3(r32));
                  case 0:
                  case 40:
                  case 43:
                  case 62:
                  case 126:
                    return r32;
                  case 58:
                    if (c22[++a22] === "global")
                      c22[a22] = "", c22[++a22] = "\f" + C3(c22[a22], a22 = 1, -1);
                  case 32:
                    return a22 === 1 ? "" : r32;
                  default:
                    switch (a22) {
                      case 0:
                        e22 = r32;
                        return S4(c22) > 1 ? "" : r32;
                      case (a22 = S4(c22) - 1):
                      case 2:
                        return a22 === 2 ? r32 + e22 + e22 : r32 + e22;
                      default:
                        return r32;
                    }
                }
              });
            });
        }
      }
      __name(oe, "oe");
      e4.CHARSET = f4;
      e4.COMMENT = t3;
      e4.COUNTER_STYLE = m5;
      e4.DECLARATION = s4;
      e4.DOCUMENT = p4;
      e4.FONT_FACE = d4;
      e4.FONT_FEATURE_VALUES = w4;
      e4.IMPORT = o5;
      e4.KEYFRAMES = b5;
      e4.MEDIA = u4;
      e4.MOZ = a5;
      e4.MS = r5;
      e4.NAMESPACE = v5;
      e4.PAGE = i4;
      e4.RULESET = n3;
      e4.SUPPORTS = h4;
      e4.VIEWPORT = l4;
      e4.WEBKIT = c5;
      e4.abs = k5;
      e4.alloc = K2;
      e4.append = R2;
      e4.assign = g5;
      e4.caret = I3;
      e4.char = j4;
      e4.charat = O3;
      e4.combine = z4;
      e4.comment = re;
      e4.commenter = q4;
      e4.compile = Q2;
      e4.copy = P3;
      e4.dealloc = V2;
      e4.declaration = ae;
      e4.delimit = W2;
      e4.delimiter = Z2;
      e4.escaping = H3;
      e4.from = $3;
      e4.hash = x5;
      e4.identifier = J2;
      e4.indexof = A4;
      e4.match = y4;
      e4.middleware = se;
      e4.namespace = oe;
      e4.next = _5;
      e4.node = N3;
      e4.parse = X2;
      e4.peek = F3;
      e4.prefix = ce;
      e4.prefixer = ue;
      e4.prev = U2;
      e4.replace = T4;
      e4.ruleset = ee;
      e4.rulesheet = ie;
      e4.serialize = te;
      e4.sizeof = S4;
      e4.slice = L3;
      e4.stringify = ne;
      e4.strlen = M3;
      e4.substr = C3;
      e4.token = D2;
      e4.tokenize = Y2;
      e4.tokenizer = G2;
      e4.trim = E2;
      e4.whitespace = B3;
      Object.defineProperty(e4, "__esModule", { value: true });
    });
  }
});
var require_emotion_weak_memoize_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-weak-memoize-npm-0.3.0-705bdd075b-9c9.zip/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var weakMemoize = __name(function weakMemoize2(func) {
      var cache2 = /* @__PURE__ */ new WeakMap();
      return function(arg) {
        if (cache2.has(arg)) {
          return cache2.get(arg);
        }
        var ret = func(arg);
        cache2.set(arg, ret);
        return ret;
      };
    }, "weakMemoize");
    exports.default = weakMemoize;
  }
});
var require_emotion_weak_memoize_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-weak-memoize-npm-0.3.0-705bdd075b-9c9.zip/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_weak_memoize_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_memoize_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-memoize-npm-0.8.0-c5dd451828-9c9.zip/node_modules/@emotion/memoize/dist/emotion-memoize.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoize2(fn2) {
      var cache2 = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache2[arg] === void 0)
          cache2[arg] = fn2(arg);
        return cache2[arg];
      };
    }
    __name(memoize2, "memoize");
    exports.default = memoize2;
  }
});
var require_emotion_memoize_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-memoize-npm-0.8.0-c5dd451828-9c9.zip/node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_memoize_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_cache_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-cache-npm-11.10.3-77f93c9eba-9c9.zip/node_modules/@emotion/cache/dist/emotion-cache.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var sheet = require_emotion_sheet_cjs();
    var stylis = require_stylis();
    var weakMemoize = require_emotion_weak_memoize_cjs();
    var memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e4) {
      return e4 && e4.__esModule ? e4 : { "default": e4 };
    }
    __name(_interopDefault, "_interopDefault");
    var weakMemoize__default = _interopDefault(weakMemoize);
    var memoize__default = _interopDefault(memoize2);
    var identifierWithPointTracking = __name(function identifierWithPointTracking2(begin, points, index) {
      var previous = 0;
      var character = 0;
      while (true) {
        previous = character;
        character = stylis.peek();
        if (previous === 38 && character === 12) {
          points[index] = 1;
        }
        if (stylis.token(character)) {
          break;
        }
        stylis.next();
      }
      return stylis.slice(begin, stylis.position);
    }, "identifierWithPointTracking");
    var toRules = __name(function toRules2(parsed, points) {
      var index = -1;
      var character = 44;
      do {
        switch (stylis.token(character)) {
          case 0:
            if (character === 38 && stylis.peek() === 12) {
              points[index] = 1;
            }
            parsed[index] += identifierWithPointTracking(stylis.position - 1, points, index);
            break;
          case 2:
            parsed[index] += stylis.delimit(character);
            break;
          case 4:
            if (character === 44) {
              parsed[++index] = stylis.peek() === 58 ? "&\f" : "";
              points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += stylis.from(character);
        }
      } while (character = stylis.next());
      return parsed;
    }, "toRules");
    var getRules = __name(function getRules2(value, points) {
      return stylis.dealloc(toRules(stylis.alloc(value), points));
    }, "getRules");
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = __name(function compat2(element) {
      if (element.type !== "rule" || !element.parent || element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i4 = 0, k5 = 0; i4 < rules.length; i4++) {
        for (var j4 = 0; j4 < parentRules.length; j4++, k5++) {
          element.props[k5] = points[i4] ? rules[i4].replace(/&\f/g, parentRules[j4]) : parentRules[j4] + " " + rules[i4];
        }
      }
    }, "compat");
    var removeLabel = __name(function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
          element["return"] = "";
          element.value = "";
        }
      }
    }, "removeLabel");
    var isBrowser2 = typeof document !== "undefined";
    var getServerStylisCache = isBrowser2 ? void 0 : weakMemoize__default["default"](function() {
      return memoize__default["default"](function() {
        var cache2 = {};
        return function(name) {
          return cache2[name];
        };
      });
    });
    var defaultStylisPlugins = [stylis.prefixer];
    var createCache = __name(function createCache2(options) {
      var key = options.key;
      if (isBrowser2 && key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node) {
          var dataEmotionAttribute = node.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node);
          node.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      if (isBrowser2) {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node) {
            var attrib = node.getAttribute("data-emotion").split(" ");
            for (var i4 = 1; i4 < attrib.length; i4++) {
              inserted[attrib[i4]] = true;
            }
            nodesToHydrate.push(node);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      if (isBrowser2) {
        var currentSheet;
        var finalizingPlugins = [stylis.stringify, stylis.rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis$1 = __name(function stylis$12(styles2) {
          return stylis.serialize(stylis.compile(styles2), serializer);
        }, "stylis$1");
        _insert = __name(function insert(selector, serialized, sheet2, shouldCache) {
          currentSheet = sheet2;
          stylis$1(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache2.inserted[serialized.name] = true;
          }
        }, "insert");
      } else {
        var _finalizingPlugins = [stylis.stringify];
        var _serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
        var _stylis = __name(function _stylis2(styles2) {
          return stylis.serialize(stylis.compile(styles2), _serializer);
        }, "_stylis");
        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
        var getRules2 = __name(function getRules3(selector, serialized) {
          var name = serialized.name;
          if (serverStylisCache[name] === void 0) {
            serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          }
          return serverStylisCache[name];
        }, "getRules");
        _insert = __name(function _insert2(selector, serialized, sheet2, shouldCache) {
          var name = serialized.name;
          var rules = getRules2(selector, serialized);
          if (cache2.compat === void 0) {
            if (shouldCache) {
              cache2.inserted[name] = true;
            }
            return rules;
          } else {
            if (shouldCache) {
              cache2.inserted[name] = rules;
            } else {
              return rules;
            }
          }
        }, "_insert");
      }
      var cache2 = {
        key,
        sheet: new sheet.StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache2.sheet.hydrate(nodesToHydrate);
      return cache2;
    }, "createCache");
    exports.default = createCache;
  }
});
var require_emotion_cache_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-cache-npm-11.10.3-77f93c9eba-9c9.zip/node_modules/@emotion/cache/dist/emotion-cache.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_cache_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_extends = __commonJS({
  "../../../../.yarn/global/cache/@babel-runtime-npm-7.19.0-86b37fbb72-9c9.zip/node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    init_define_process();
    function _extends2() {
      module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i4 = 1; i4 < arguments.length; i4++) {
          var source = arguments[i4];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends2.apply(this, arguments);
    }
    __name(_extends2, "_extends");
    module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});
var require_react_is_production_min = __commonJS({
  "../../../../.yarn/global/cache/react-is-npm-16.13.1-a9b9382b4f-9c9.zip/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    "use strict";
    init_define_process();
    var b5 = "function" === typeof Symbol && Symbol.for;
    var c5 = b5 ? Symbol.for("react.element") : 60103;
    var d4 = b5 ? Symbol.for("react.portal") : 60106;
    var e4 = b5 ? Symbol.for("react.fragment") : 60107;
    var f4 = b5 ? Symbol.for("react.strict_mode") : 60108;
    var g5 = b5 ? Symbol.for("react.profiler") : 60114;
    var h4 = b5 ? Symbol.for("react.provider") : 60109;
    var k5 = b5 ? Symbol.for("react.context") : 60110;
    var l4 = b5 ? Symbol.for("react.async_mode") : 60111;
    var m5 = b5 ? Symbol.for("react.concurrent_mode") : 60111;
    var n3 = b5 ? Symbol.for("react.forward_ref") : 60112;
    var p4 = b5 ? Symbol.for("react.suspense") : 60113;
    var q4 = b5 ? Symbol.for("react.suspense_list") : 60120;
    var r5 = b5 ? Symbol.for("react.memo") : 60115;
    var t3 = b5 ? Symbol.for("react.lazy") : 60116;
    var v5 = b5 ? Symbol.for("react.block") : 60121;
    var w4 = b5 ? Symbol.for("react.fundamental") : 60117;
    var x5 = b5 ? Symbol.for("react.responder") : 60118;
    var y4 = b5 ? Symbol.for("react.scope") : 60119;
    function z4(a5) {
      if ("object" === typeof a5 && null !== a5) {
        var u4 = a5.$$typeof;
        switch (u4) {
          case c5:
            switch (a5 = a5.type, a5) {
              case l4:
              case m5:
              case e4:
              case g5:
              case f4:
              case p4:
                return a5;
              default:
                switch (a5 = a5 && a5.$$typeof, a5) {
                  case k5:
                  case n3:
                  case t3:
                  case r5:
                  case h4:
                    return a5;
                  default:
                    return u4;
                }
            }
          case d4:
            return u4;
        }
      }
    }
    __name(z4, "z");
    function A4(a5) {
      return z4(a5) === m5;
    }
    __name(A4, "A");
    exports.AsyncMode = l4;
    exports.ConcurrentMode = m5;
    exports.ContextConsumer = k5;
    exports.ContextProvider = h4;
    exports.Element = c5;
    exports.ForwardRef = n3;
    exports.Fragment = e4;
    exports.Lazy = t3;
    exports.Memo = r5;
    exports.Portal = d4;
    exports.Profiler = g5;
    exports.StrictMode = f4;
    exports.Suspense = p4;
    exports.isAsyncMode = function(a5) {
      return A4(a5) || z4(a5) === l4;
    };
    exports.isConcurrentMode = A4;
    exports.isContextConsumer = function(a5) {
      return z4(a5) === k5;
    };
    exports.isContextProvider = function(a5) {
      return z4(a5) === h4;
    };
    exports.isElement = function(a5) {
      return "object" === typeof a5 && null !== a5 && a5.$$typeof === c5;
    };
    exports.isForwardRef = function(a5) {
      return z4(a5) === n3;
    };
    exports.isFragment = function(a5) {
      return z4(a5) === e4;
    };
    exports.isLazy = function(a5) {
      return z4(a5) === t3;
    };
    exports.isMemo = function(a5) {
      return z4(a5) === r5;
    };
    exports.isPortal = function(a5) {
      return z4(a5) === d4;
    };
    exports.isProfiler = function(a5) {
      return z4(a5) === g5;
    };
    exports.isStrictMode = function(a5) {
      return z4(a5) === f4;
    };
    exports.isSuspense = function(a5) {
      return z4(a5) === p4;
    };
    exports.isValidElementType = function(a5) {
      return "string" === typeof a5 || "function" === typeof a5 || a5 === e4 || a5 === m5 || a5 === g5 || a5 === f4 || a5 === p4 || a5 === q4 || "object" === typeof a5 && null !== a5 && (a5.$$typeof === t3 || a5.$$typeof === r5 || a5.$$typeof === h4 || a5.$$typeof === k5 || a5.$$typeof === n3 || a5.$$typeof === w4 || a5.$$typeof === x5 || a5.$$typeof === y4 || a5.$$typeof === v5);
    };
    exports.typeOf = z4;
  }
});
var require_react_is = __commonJS({
  "../../../../.yarn/global/cache/react-is-npm-16.13.1-a9b9382b4f-9c9.zip/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_react_is_production_min();
    } else {
      module.exports = null;
    }
  }
});
var require_hoist_non_react_statics_cjs = __commonJS({
  "../../../../.yarn/global/cache/hoist-non-react-statics-npm-3.3.2-e7b709e6c1-9c9.zip/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    __name(getStatics, "getStatics");
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys3 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i4 = 0; i4 < keys3.length; ++i4) {
          var key = keys3[i4];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e4) {
            }
          }
        }
      }
      return targetComponent;
    }
    __name(hoistNonReactStatics, "hoistNonReactStatics");
    module.exports = hoistNonReactStatics;
  }
});
var require_emotion_react_isolated_hnrs_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hoistNonReactStatics$1 = require_hoist_non_react_statics_cjs();
    function _interopDefault(e4) {
      return e4 && e4.__esModule ? e4 : { "default": e4 };
    }
    __name(_interopDefault, "_interopDefault");
    var hoistNonReactStatics__default = _interopDefault(hoistNonReactStatics$1);
    var hoistNonReactStatics = __name(function(targetComponent, sourceComponent) {
      return hoistNonReactStatics__default["default"](targetComponent, sourceComponent);
    }, "hoistNonReactStatics");
    exports.default = hoistNonReactStatics;
  }
});
var require_emotion_utils_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-utils-npm-1.2.0-337992f692-9c9.zip/node_modules/@emotion/utils/dist/emotion-utils.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var isBrowser2 = typeof document !== "undefined";
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    __name(getRegisteredStyles, "getRegisteredStyles");
    var registerStyles = __name(function registerStyles2(cache2, serialized, isStringTag2) {
      var className = cache2.key + "-" + serialized.name;
      if ((isStringTag2 === false || isBrowser2 === false && cache2.compat !== void 0) && cache2.registered[className] === void 0) {
        cache2.registered[className] = serialized.styles;
      }
    }, "registerStyles");
    var insertStyles = __name(function insertStyles2(cache2, serialized, isStringTag2) {
      registerStyles(cache2, serialized, isStringTag2);
      var className = cache2.key + "-" + serialized.name;
      if (cache2.inserted[serialized.name] === void 0) {
        var stylesForSSR = "";
        var current = serialized;
        do {
          var maybeStyles = cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
          if (!isBrowser2 && maybeStyles !== void 0) {
            stylesForSSR += maybeStyles;
          }
          current = current.next;
        } while (current !== void 0);
        if (!isBrowser2 && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    }, "insertStyles");
    exports.getRegisteredStyles = getRegisteredStyles;
    exports.insertStyles = insertStyles;
    exports.registerStyles = registerStyles;
  }
});
var require_emotion_utils_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-utils-npm-1.2.0-337992f692-9c9.zip/node_modules/@emotion/utils/dist/emotion-utils.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_utils_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_hash_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-hash-npm-0.9.0-efbc0b3f3f-9c9.zip/node_modules/@emotion/hash/dist/emotion-hash.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    function murmur2(str2) {
      var h4 = 0;
      var k5, i4 = 0, len = str2.length;
      for (; len >= 4; ++i4, len -= 4) {
        k5 = str2.charCodeAt(i4) & 255 | (str2.charCodeAt(++i4) & 255) << 8 | (str2.charCodeAt(++i4) & 255) << 16 | (str2.charCodeAt(++i4) & 255) << 24;
        k5 = (k5 & 65535) * 1540483477 + ((k5 >>> 16) * 59797 << 16);
        k5 ^= k5 >>> 24;
        h4 = (k5 & 65535) * 1540483477 + ((k5 >>> 16) * 59797 << 16) ^ (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h4 ^= (str2.charCodeAt(i4 + 2) & 255) << 16;
        case 2:
          h4 ^= (str2.charCodeAt(i4 + 1) & 255) << 8;
        case 1:
          h4 ^= str2.charCodeAt(i4) & 255;
          h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
      }
      h4 ^= h4 >>> 13;
      h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
      return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
    }
    __name(murmur2, "murmur2");
    exports.default = murmur2;
  }
});
var require_emotion_hash_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-hash-npm-0.9.0-efbc0b3f3f-9c9.zip/node_modules/@emotion/hash/dist/emotion-hash.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_hash_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_unitless_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-unitless-npm-0.8.0-aa125284fa-9c9.zip/node_modules/@emotion/unitless/dist/emotion-unitless.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    exports.default = unitlessKeys;
  }
});
var require_emotion_unitless_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-unitless-npm-0.8.0-aa125284fa-9c9.zip/node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_unitless_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_serialize_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-serialize-npm-1.1.0-492b26b387-9c9.zip/node_modules/@emotion/serialize/dist/emotion-serialize.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hashString2 = require_emotion_hash_cjs();
    var unitless = require_emotion_unitless_cjs();
    var memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e4) {
      return e4 && e4.__esModule ? e4 : { "default": e4 };
    }
    __name(_interopDefault, "_interopDefault");
    var hashString__default = _interopDefault(hashString2);
    var unitless__default = _interopDefault(unitless);
    var memoize__default = _interopDefault(memoize2);
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = __name(function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    }, "isCustomProperty");
    var isProcessableValue = __name(function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    }, "isProcessableValue");
    var processStyleName = memoize__default["default"](function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = __name(function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match, p1, p22) {
              cursor = {
                name: p1,
                styles: p22,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitless__default["default"][key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    }, "processStyleValue");
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next = interpolation.next;
            if (next !== void 0) {
              while (next !== void 0) {
                cursor = {
                  name: next.name,
                  styles: next.styles,
                  next: cursor
                };
                next = next.next;
              }
            }
            var styles2 = interpolation.styles + ";";
            return styles2;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }
          break;
        }
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    __name(handleInterpolation, "handleInterpolation");
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj)) {
        for (var i4 = 0; i4 < obj.length; i4++) {
          string += handleInterpolation(mergedProps, registered, obj[i4]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && false) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  string += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string;
    }
    __name(createStringFromObject, "createStringFromObject");
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var cursor;
    var serializeStyles = __name(function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        styles2 += strings[0];
      }
      for (var i4 = 1; i4 < args.length; i4++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i4]);
        if (stringMode) {
          styles2 += strings[i4];
        }
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match;
      while ((match = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + match[1];
      }
      var name = hashString__default["default"](styles2) + identifierName;
      return {
        name,
        styles: styles2,
        next: cursor
      };
    }, "serializeStyles");
    exports.serializeStyles = serializeStyles;
  }
});
var require_emotion_serialize_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-serialize-npm-1.1.0-492b26b387-9c9.zip/node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_serialize_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_use_insertion_effect_with_fallbacks_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-use-insertion-effect-with-fallbacks-virtual-abb7ecf88d/5/.yarn/global/cache/@emotion-use-insertion-effect-with-fallbacks-npm-1.0.0-d02a7659c4-9c9.zip/node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var React2 = (init_react_preact(), __toCommonJS(react_preact_exports));
    function _interopNamespace(e4) {
      if (e4 && e4.__esModule)
        return e4;
      var n3 = /* @__PURE__ */ Object.create(null);
      if (e4) {
        Object.keys(e4).forEach(function(k5) {
          if (k5 !== "default") {
            var d4 = Object.getOwnPropertyDescriptor(e4, k5);
            Object.defineProperty(n3, k5, d4.get ? d4 : {
              enumerable: true,
              get: function() {
                return e4[k5];
              }
            });
          }
        });
      }
      n3["default"] = e4;
      return Object.freeze(n3);
    }
    __name(_interopNamespace, "_interopNamespace");
    var React__namespace = _interopNamespace(React2);
    var isBrowser2 = typeof document !== "undefined";
    var syncFallback = __name(function syncFallback2(create) {
      return create();
    }, "syncFallback");
    var useInsertionEffect2 = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = !isBrowser2 ? syncFallback : useInsertionEffect2 || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React2.useLayoutEffect;
    exports.useInsertionEffectAlwaysWithSyncFallback = useInsertionEffectAlwaysWithSyncFallback;
    exports.useInsertionEffectWithLayoutFallback = useInsertionEffectWithLayoutFallback;
  }
});
var require_emotion_use_insertion_effect_with_fallbacks_cjs = __commonJS({
  ".yarn/__virtual__/@emotion-use-insertion-effect-with-fallbacks-virtual-abb7ecf88d/5/.yarn/global/cache/@emotion-use-insertion-effect-with-fallbacks-npm-1.0.0-d02a7659c4-9c9.zip/node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_use_insertion_effect_with_fallbacks_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_element_20108edd_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/dist/emotion-element-20108edd.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    var React2 = (init_react_preact(), __toCommonJS(react_preact_exports));
    var createCache = require_emotion_cache_cjs();
    var _extends2 = require_extends();
    var weakMemoize = require_emotion_weak_memoize_cjs();
    var _isolatedHnrs_dist_emotionReact_isolatedHnrs = require_emotion_react_isolated_hnrs_cjs_prod();
    var utils = require_emotion_utils_cjs();
    var serialize = require_emotion_serialize_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e4) {
      return e4 && e4.__esModule ? e4 : { "default": e4 };
    }
    __name(_interopDefault, "_interopDefault");
    var createCache__default = _interopDefault(createCache);
    var weakMemoize__default = _interopDefault(weakMemoize);
    var isBrowser2 = typeof document !== "undefined";
    var hasOwnProperty2 = {}.hasOwnProperty;
    var EmotionCacheContext = React2.createContext(
      typeof HTMLElement !== "undefined" ? createCache__default["default"]({
        key: "css"
      }) : null
    );
    var CacheProvider = EmotionCacheContext.Provider;
    var __unsafe_useEmotionCache = __name(function useEmotionCache() {
      return React2.useContext(EmotionCacheContext);
    }, "useEmotionCache");
    exports.withEmotionCache = __name(function withEmotionCache(func) {
      return React2.forwardRef(function(props, ref) {
        var cache2 = React2.useContext(EmotionCacheContext);
        return func(props, cache2, ref);
      });
    }, "withEmotionCache");
    if (!isBrowser2) {
      exports.withEmotionCache = __name(function withEmotionCache(func) {
        return function(props) {
          var cache2 = React2.useContext(EmotionCacheContext);
          if (cache2 === null) {
            cache2 = createCache__default["default"]({
              key: "css"
            });
            return React2.createElement(EmotionCacheContext.Provider, {
              value: cache2
            }, func(props, cache2));
          } else {
            return func(props, cache2);
          }
        };
      }, "withEmotionCache");
    }
    var ThemeContext = React2.createContext({});
    var useTheme5 = __name(function useTheme22() {
      return React2.useContext(ThemeContext);
    }, "useTheme");
    var getTheme = __name(function getTheme2(outerTheme, theme) {
      if (typeof theme === "function") {
        var mergedTheme = theme(outerTheme);
        return mergedTheme;
      }
      return _extends2({}, outerTheme, theme);
    }, "getTheme");
    var createCacheWithTheme = weakMemoize__default["default"](function(outerTheme) {
      return weakMemoize__default["default"](function(theme) {
        return getTheme(outerTheme, theme);
      });
    });
    var ThemeProvider3 = __name(function ThemeProvider22(props) {
      var theme = React2.useContext(ThemeContext);
      if (props.theme !== theme) {
        theme = createCacheWithTheme(theme)(props.theme);
      }
      return React2.createElement(ThemeContext.Provider, {
        value: theme
      }, props.children);
    }, "ThemeProvider");
    function withTheme(Component2) {
      var componentName = Component2.displayName || Component2.name || "Component";
      var render2 = __name(function render22(props, ref) {
        var theme = React2.useContext(ThemeContext);
        return React2.createElement(Component2, _extends2({
          theme,
          ref
        }, props));
      }, "render");
      var WithTheme = React2.forwardRef(render2);
      WithTheme.displayName = "WithTheme(" + componentName + ")";
      return _isolatedHnrs_dist_emotionReact_isolatedHnrs["default"](WithTheme, Component2);
    }
    __name(withTheme, "withTheme");
    var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
    var createEmotionProps = __name(function createEmotionProps2(type, props) {
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty2.call(props, key)) {
          newProps[key] = props[key];
        }
      }
      newProps[typePropName] = type;
      return newProps;
    }, "createEmotionProps");
    var Insertion = __name(function Insertion2(_ref) {
      var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      utils.registerStyles(cache2, serialized, isStringTag2);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache2, serialized, isStringTag2);
      });
      if (!isBrowser2 && rules !== void 0) {
        var _ref2;
        var serializedNames = serialized.name;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          next = next.next;
        }
        return React2.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache2.sheet.nonce, _ref2));
      }
      return null;
    }, "Insertion");
    var Emotion = exports.withEmotionCache(function(props, cache2, ref) {
      var cssProp = props.css;
      if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
        cssProp = cache2.registered[cssProp];
      }
      var WrappedComponent = props[typePropName];
      var registeredStyles = [cssProp];
      var className = "";
      if (typeof props.className === "string") {
        className = utils.getRegisteredStyles(cache2.registered, registeredStyles, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serialize.serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
      className += cache2.key + "-" + serialized.name;
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty2.call(props, key) && key !== "css" && key !== typePropName && true) {
          newProps[key] = props[key];
        }
      }
      newProps.ref = ref;
      newProps.className = className;
      return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof WrappedComponent === "string"
      }), React2.createElement(WrappedComponent, newProps));
    });
    exports.CacheProvider = CacheProvider;
    exports.Emotion = Emotion;
    exports.ThemeContext = ThemeContext;
    exports.ThemeProvider = ThemeProvider3;
    exports.__unsafe_useEmotionCache = __unsafe_useEmotionCache;
    exports.createEmotionProps = createEmotionProps;
    exports.hasOwnProperty = hasOwnProperty2;
    exports.isBrowser = isBrowser2;
    exports.useTheme = useTheme5;
    exports.withTheme = withTheme;
  }
});
var require_emotion_react_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/dist/emotion-react.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var React2 = (init_react_preact(), __toCommonJS(react_preact_exports));
    require_emotion_cache_cjs();
    var emotionElement = require_emotion_element_20108edd_cjs_prod();
    require_extends();
    require_emotion_weak_memoize_cjs();
    require_hoist_non_react_statics_cjs();
    require_emotion_react_isolated_hnrs_cjs_prod();
    var utils = require_emotion_utils_cjs();
    var serialize = require_emotion_serialize_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var jsx = __name(function jsx2(type, props) {
      var args = arguments;
      if (props == null || !emotionElement.hasOwnProperty.call(props, "css")) {
        return React2.createElement.apply(void 0, args);
      }
      var argsLength = args.length;
      var createElementArgArray = new Array(argsLength);
      createElementArgArray[0] = emotionElement.Emotion;
      createElementArgArray[1] = emotionElement.createEmotionProps(type, props);
      for (var i4 = 2; i4 < argsLength; i4++) {
        createElementArgArray[i4] = args[i4];
      }
      return React2.createElement.apply(null, createElementArgArray);
    }, "jsx");
    var Global = emotionElement.withEmotionCache(function(props, cache2) {
      var styles2 = props.styles;
      var serialized = serialize.serializeStyles([styles2], void 0, React2.useContext(emotionElement.ThemeContext));
      if (!emotionElement.isBrowser) {
        var _ref;
        var serializedNames = serialized.name;
        var serializedStyles = serialized.styles;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          serializedStyles += next.styles;
          next = next.next;
        }
        var shouldCache = cache2.compat === true;
        var rules = cache2.insert("", {
          name: serializedNames,
          styles: serializedStyles
        }, cache2.sheet, shouldCache);
        if (shouldCache) {
          return null;
        }
        return React2.createElement("style", (_ref = {}, _ref["data-emotion"] = cache2.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref.nonce = cache2.sheet.nonce, _ref));
      }
      var sheetRef = React2.useRef();
      useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var key = cache2.key + "-global";
        var sheet = new cache2.sheet.constructor({
          key,
          nonce: cache2.sheet.nonce,
          container: cache2.sheet.container,
          speedy: cache2.sheet.isSpeedy
        });
        var rehydrating = false;
        var node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache2.sheet.tags.length) {
          sheet.before = cache2.sheet.tags[0];
        }
        if (node !== null) {
          rehydrating = true;
          node.setAttribute("data-emotion", key);
          sheet.hydrate([node]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache2]);
      useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          utils.insertStyles(cache2, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache2.insert("", serialized, sheet, false);
      }, [cache2, serialized.name]);
      return null;
    });
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serialize.serializeStyles(args);
    }
    __name(css, "css");
    var keyframes3 = __name(function keyframes22() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: __name(function toString5() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }, "toString")
      };
    }, "keyframes");
    var classnames = __name(function classnames2(args) {
      var len = args.length;
      var i4 = 0;
      var cls = "";
      for (; i4 < len; i4++) {
        var arg = args[i4];
        if (arg == null)
          continue;
        var toAdd = void 0;
        switch (typeof arg) {
          case "boolean":
            break;
          case "object": {
            if (Array.isArray(arg)) {
              toAdd = classnames2(arg);
            } else {
              toAdd = "";
              for (var k5 in arg) {
                if (arg[k5] && k5) {
                  toAdd && (toAdd += " ");
                  toAdd += k5;
                }
              }
            }
            break;
          }
          default: {
            toAdd = arg;
          }
        }
        if (toAdd) {
          cls && (cls += " ");
          cls += toAdd;
        }
      }
      return cls;
    }, "classnames");
    function merge2(registered, css2, className) {
      var registeredStyles = [];
      var rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
      if (registeredStyles.length < 2) {
        return className;
      }
      return rawClassName + css2(registeredStyles);
    }
    __name(merge2, "merge");
    var Insertion = __name(function Insertion2(_ref) {
      var cache2 = _ref.cache, serializedArr = _ref.serializedArr;
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        var rules2 = "";
        for (var i4 = 0; i4 < serializedArr.length; i4++) {
          var res = utils.insertStyles(cache2, serializedArr[i4], false);
          if (!emotionElement.isBrowser && res !== void 0) {
            rules2 += res;
          }
        }
        if (!emotionElement.isBrowser) {
          return rules2;
        }
      });
      if (!emotionElement.isBrowser && rules.length !== 0) {
        var _ref2;
        return React2.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + " " + serializedArr.map(function(serialized) {
          return serialized.name;
        }).join(" "), _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache2.sheet.nonce, _ref2));
      }
      return null;
    }, "Insertion");
    var ClassNames = emotionElement.withEmotionCache(function(props, cache2) {
      var hasRendered = false;
      var serializedArr = [];
      var css2 = __name(function css3() {
        if (hasRendered && false) {
          throw new Error("css can only be used during render");
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var serialized = serialize.serializeStyles(args, cache2.registered);
        serializedArr.push(serialized);
        utils.registerStyles(cache2, serialized, false);
        return cache2.key + "-" + serialized.name;
      }, "css");
      var cx = __name(function cx2() {
        if (hasRendered && false) {
          throw new Error("cx can only be used during render");
        }
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return merge2(cache2.registered, css2, classnames(args));
      }, "cx");
      var content = {
        css: css2,
        cx,
        theme: React2.useContext(emotionElement.ThemeContext)
      };
      var ele = props.children(content);
      hasRendered = true;
      return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
        cache: cache2,
        serializedArr
      }), ele);
    });
    exports.CacheProvider = emotionElement.CacheProvider;
    exports.ThemeContext = emotionElement.ThemeContext;
    exports.ThemeProvider = emotionElement.ThemeProvider;
    exports.__unsafe_useEmotionCache = emotionElement.__unsafe_useEmotionCache;
    exports.useTheme = emotionElement.useTheme;
    Object.defineProperty(exports, "withEmotionCache", {
      enumerable: true,
      get: function() {
        return emotionElement.withEmotionCache;
      }
    });
    exports.withTheme = emotionElement.withTheme;
    exports.ClassNames = ClassNames;
    exports.Global = Global;
    exports.createElement = jsx;
    exports.css = css;
    exports.jsx = jsx;
    exports.keyframes = keyframes3;
  }
});
var require_emotion_react_cjs = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/dist/emotion-react.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_react_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});

// dist/chunk-chunk-AUCLOHU2.mjs
var require_emotion_react_jsx_runtime_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/jsx-runtime/dist/emotion-react-jsx-runtime.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    init_react_preact();
    require_emotion_cache_cjs();
    var emotionElement = require_emotion_element_20108edd_cjs_prod();
    require_extends();
    require_emotion_weak_memoize_cjs();
    require_hoist_non_react_statics_cjs();
    require_emotion_react_isolated_hnrs_cjs_prod();
    require_emotion_utils_cjs();
    require_emotion_serialize_cjs();
    require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var ReactJSXRuntime = (init_react_preact(), __toCommonJS(react_preact_exports));
    var Fragment = ReactJSXRuntime.Fragment;
    function jsx8(type, props, key) {
      if (!emotionElement.hasOwnProperty.call(props, "css")) {
        return ReactJSXRuntime.jsx(type, props, key);
      }
      return ReactJSXRuntime.jsx(emotionElement.Emotion, emotionElement.createEmotionProps(type, props), key);
    }
    __name(jsx8, "jsx");
    function jsxs5(type, props, key) {
      if (!emotionElement.hasOwnProperty.call(props, "css")) {
        return ReactJSXRuntime.jsxs(type, props, key);
      }
      return ReactJSXRuntime.jsxs(emotionElement.Emotion, emotionElement.createEmotionProps(type, props), key);
    }
    __name(jsxs5, "jsxs");
    exports.Fragment = Fragment;
    exports.jsx = jsx8;
    exports.jsxs = jsxs5;
  }
});
var require_emotion_react_jsx_runtime_cjs = __commonJS({
  ".yarn/__virtual__/@emotion-react-virtual-022c3d1bd6/5/.yarn/global/cache/@emotion-react-npm-11.10.4-00a955a9fe-9c9.zip/node_modules/@emotion/react/jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_react_jsx_runtime_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_qrious = __commonJS({
  "../../../../.yarn/global/cache/qrious-npm-4.0.2-9d7db0e444-9c9.zip/node_modules/qrious/dist/qrious.js"(exports, module) {
    init_define_process();
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.QRious = factory();
    })(exports, function() {
      "use strict";
      var Constructor = __name(function() {
      }, "Constructor");
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var slice3 = Array.prototype.slice;
      function createObject2(prototype, properties2) {
        var result;
        if (typeof Object.create === "function") {
          result = Object.create(prototype);
        } else {
          Constructor.prototype = prototype;
          result = new Constructor();
          Constructor.prototype = null;
        }
        if (properties2) {
          extendObject(true, result, properties2);
        }
        return result;
      }
      __name(createObject2, "createObject");
      function extend(name, constructor, prototype, statics) {
        var superConstructor = this;
        if (typeof name !== "string") {
          statics = prototype;
          prototype = constructor;
          constructor = name;
          name = null;
        }
        if (typeof constructor !== "function") {
          statics = prototype;
          prototype = constructor;
          constructor = __name(function() {
            return superConstructor.apply(this, arguments);
          }, "constructor");
        }
        extendObject(false, constructor, superConstructor, statics);
        constructor.prototype = createObject2(superConstructor.prototype, prototype);
        constructor.prototype.constructor = constructor;
        constructor.class_ = name || superConstructor.class_;
        constructor.super_ = superConstructor;
        return constructor;
      }
      __name(extend, "extend");
      function extendObject(own, target, sources) {
        sources = slice3.call(arguments, 2);
        var property;
        var source;
        for (var i4 = 0, length = sources.length; i4 < length; i4++) {
          source = sources[i4];
          for (property in source) {
            if (!own || hasOwnProperty2.call(source, property)) {
              target[property] = source[property];
            }
          }
        }
      }
      __name(extendObject, "extendObject");
      var extend_1 = extend;
      function Nevis() {
      }
      __name(Nevis, "Nevis");
      Nevis.class_ = "Nevis";
      Nevis.super_ = Object;
      Nevis.extend = extend_1;
      var nevis = Nevis;
      var lite = nevis;
      var Renderer = lite.extend(function(qrious, element, enabled) {
        this.qrious = qrious;
        this.element = element;
        this.element.qrious = qrious;
        this.enabled = Boolean(enabled);
      }, {
        draw: function(frame2) {
        },
        getElement: function() {
          if (!this.enabled) {
            this.enabled = true;
            this.render();
          }
          return this.element;
        },
        getModuleSize: function(frame2) {
          var qrious = this.qrious;
          var padding2 = qrious.padding || 0;
          var pixels = Math.floor((qrious.size - padding2 * 2) / frame2.width);
          return Math.max(1, pixels);
        },
        getOffset: function(frame2) {
          var qrious = this.qrious;
          var padding2 = qrious.padding;
          if (padding2 != null) {
            return padding2;
          }
          var moduleSize = this.getModuleSize(frame2);
          var offset2 = Math.floor((qrious.size - moduleSize * frame2.width) / 2);
          return Math.max(0, offset2);
        },
        render: function(frame2) {
          if (this.enabled) {
            this.resize();
            this.reset();
            this.draw(frame2);
          }
        },
        reset: function() {
        },
        resize: function() {
        }
      });
      var Renderer_1 = Renderer;
      var CanvasRenderer = Renderer_1.extend({
        draw: function(frame2) {
          var i4, j4;
          var qrious = this.qrious;
          var moduleSize = this.getModuleSize(frame2);
          var offset2 = this.getOffset(frame2);
          var context = this.element.getContext("2d");
          context.fillStyle = qrious.foreground;
          context.globalAlpha = qrious.foregroundAlpha;
          for (i4 = 0; i4 < frame2.width; i4++) {
            for (j4 = 0; j4 < frame2.width; j4++) {
              if (frame2.buffer[j4 * frame2.width + i4]) {
                context.fillRect(moduleSize * i4 + offset2, moduleSize * j4 + offset2, moduleSize, moduleSize);
              }
            }
          }
        },
        reset: function() {
          var qrious = this.qrious;
          var context = this.element.getContext("2d");
          var size = qrious.size;
          context.lineWidth = 1;
          context.clearRect(0, 0, size, size);
          context.fillStyle = qrious.background;
          context.globalAlpha = qrious.backgroundAlpha;
          context.fillRect(0, 0, size, size);
        },
        resize: function() {
          var element = this.element;
          element.width = element.height = this.qrious.size;
        }
      });
      var CanvasRenderer_1 = CanvasRenderer;
      var Alignment = lite.extend(null, {
        BLOCK: [
          0,
          11,
          15,
          19,
          23,
          27,
          31,
          16,
          18,
          20,
          22,
          24,
          26,
          28,
          20,
          22,
          24,
          24,
          26,
          28,
          28,
          22,
          24,
          24,
          26,
          26,
          28,
          28,
          24,
          24,
          26,
          26,
          26,
          28,
          28,
          24,
          26,
          26,
          26,
          28,
          28
        ]
      });
      var Alignment_1 = Alignment;
      var ErrorCorrection = lite.extend(null, {
        BLOCKS: [
          1,
          0,
          19,
          7,
          1,
          0,
          16,
          10,
          1,
          0,
          13,
          13,
          1,
          0,
          9,
          17,
          1,
          0,
          34,
          10,
          1,
          0,
          28,
          16,
          1,
          0,
          22,
          22,
          1,
          0,
          16,
          28,
          1,
          0,
          55,
          15,
          1,
          0,
          44,
          26,
          2,
          0,
          17,
          18,
          2,
          0,
          13,
          22,
          1,
          0,
          80,
          20,
          2,
          0,
          32,
          18,
          2,
          0,
          24,
          26,
          4,
          0,
          9,
          16,
          1,
          0,
          108,
          26,
          2,
          0,
          43,
          24,
          2,
          2,
          15,
          18,
          2,
          2,
          11,
          22,
          2,
          0,
          68,
          18,
          4,
          0,
          27,
          16,
          4,
          0,
          19,
          24,
          4,
          0,
          15,
          28,
          2,
          0,
          78,
          20,
          4,
          0,
          31,
          18,
          2,
          4,
          14,
          18,
          4,
          1,
          13,
          26,
          2,
          0,
          97,
          24,
          2,
          2,
          38,
          22,
          4,
          2,
          18,
          22,
          4,
          2,
          14,
          26,
          2,
          0,
          116,
          30,
          3,
          2,
          36,
          22,
          4,
          4,
          16,
          20,
          4,
          4,
          12,
          24,
          2,
          2,
          68,
          18,
          4,
          1,
          43,
          26,
          6,
          2,
          19,
          24,
          6,
          2,
          15,
          28,
          4,
          0,
          81,
          20,
          1,
          4,
          50,
          30,
          4,
          4,
          22,
          28,
          3,
          8,
          12,
          24,
          2,
          2,
          92,
          24,
          6,
          2,
          36,
          22,
          4,
          6,
          20,
          26,
          7,
          4,
          14,
          28,
          4,
          0,
          107,
          26,
          8,
          1,
          37,
          22,
          8,
          4,
          20,
          24,
          12,
          4,
          11,
          22,
          3,
          1,
          115,
          30,
          4,
          5,
          40,
          24,
          11,
          5,
          16,
          20,
          11,
          5,
          12,
          24,
          5,
          1,
          87,
          22,
          5,
          5,
          41,
          24,
          5,
          7,
          24,
          30,
          11,
          7,
          12,
          24,
          5,
          1,
          98,
          24,
          7,
          3,
          45,
          28,
          15,
          2,
          19,
          24,
          3,
          13,
          15,
          30,
          1,
          5,
          107,
          28,
          10,
          1,
          46,
          28,
          1,
          15,
          22,
          28,
          2,
          17,
          14,
          28,
          5,
          1,
          120,
          30,
          9,
          4,
          43,
          26,
          17,
          1,
          22,
          28,
          2,
          19,
          14,
          28,
          3,
          4,
          113,
          28,
          3,
          11,
          44,
          26,
          17,
          4,
          21,
          26,
          9,
          16,
          13,
          26,
          3,
          5,
          107,
          28,
          3,
          13,
          41,
          26,
          15,
          5,
          24,
          30,
          15,
          10,
          15,
          28,
          4,
          4,
          116,
          28,
          17,
          0,
          42,
          26,
          17,
          6,
          22,
          28,
          19,
          6,
          16,
          30,
          2,
          7,
          111,
          28,
          17,
          0,
          46,
          28,
          7,
          16,
          24,
          30,
          34,
          0,
          13,
          24,
          4,
          5,
          121,
          30,
          4,
          14,
          47,
          28,
          11,
          14,
          24,
          30,
          16,
          14,
          15,
          30,
          6,
          4,
          117,
          30,
          6,
          14,
          45,
          28,
          11,
          16,
          24,
          30,
          30,
          2,
          16,
          30,
          8,
          4,
          106,
          26,
          8,
          13,
          47,
          28,
          7,
          22,
          24,
          30,
          22,
          13,
          15,
          30,
          10,
          2,
          114,
          28,
          19,
          4,
          46,
          28,
          28,
          6,
          22,
          28,
          33,
          4,
          16,
          30,
          8,
          4,
          122,
          30,
          22,
          3,
          45,
          28,
          8,
          26,
          23,
          30,
          12,
          28,
          15,
          30,
          3,
          10,
          117,
          30,
          3,
          23,
          45,
          28,
          4,
          31,
          24,
          30,
          11,
          31,
          15,
          30,
          7,
          7,
          116,
          30,
          21,
          7,
          45,
          28,
          1,
          37,
          23,
          30,
          19,
          26,
          15,
          30,
          5,
          10,
          115,
          30,
          19,
          10,
          47,
          28,
          15,
          25,
          24,
          30,
          23,
          25,
          15,
          30,
          13,
          3,
          115,
          30,
          2,
          29,
          46,
          28,
          42,
          1,
          24,
          30,
          23,
          28,
          15,
          30,
          17,
          0,
          115,
          30,
          10,
          23,
          46,
          28,
          10,
          35,
          24,
          30,
          19,
          35,
          15,
          30,
          17,
          1,
          115,
          30,
          14,
          21,
          46,
          28,
          29,
          19,
          24,
          30,
          11,
          46,
          15,
          30,
          13,
          6,
          115,
          30,
          14,
          23,
          46,
          28,
          44,
          7,
          24,
          30,
          59,
          1,
          16,
          30,
          12,
          7,
          121,
          30,
          12,
          26,
          47,
          28,
          39,
          14,
          24,
          30,
          22,
          41,
          15,
          30,
          6,
          14,
          121,
          30,
          6,
          34,
          47,
          28,
          46,
          10,
          24,
          30,
          2,
          64,
          15,
          30,
          17,
          4,
          122,
          30,
          29,
          14,
          46,
          28,
          49,
          10,
          24,
          30,
          24,
          46,
          15,
          30,
          4,
          18,
          122,
          30,
          13,
          32,
          46,
          28,
          48,
          14,
          24,
          30,
          42,
          32,
          15,
          30,
          20,
          4,
          117,
          30,
          40,
          7,
          47,
          28,
          43,
          22,
          24,
          30,
          10,
          67,
          15,
          30,
          19,
          6,
          118,
          30,
          18,
          31,
          47,
          28,
          34,
          34,
          24,
          30,
          20,
          61,
          15,
          30
        ],
        FINAL_FORMAT: [
          30660,
          29427,
          32170,
          30877,
          26159,
          25368,
          27713,
          26998,
          21522,
          20773,
          24188,
          23371,
          17913,
          16590,
          20375,
          19104,
          13663,
          12392,
          16177,
          14854,
          9396,
          8579,
          11994,
          11245,
          5769,
          5054,
          7399,
          6608,
          1890,
          597,
          3340,
          2107
        ],
        LEVELS: {
          L: 1,
          M: 2,
          Q: 3,
          H: 4
        }
      });
      var ErrorCorrection_1 = ErrorCorrection;
      var Galois = lite.extend(null, {
        EXPONENT: [
          1,
          2,
          4,
          8,
          16,
          32,
          64,
          128,
          29,
          58,
          116,
          232,
          205,
          135,
          19,
          38,
          76,
          152,
          45,
          90,
          180,
          117,
          234,
          201,
          143,
          3,
          6,
          12,
          24,
          48,
          96,
          192,
          157,
          39,
          78,
          156,
          37,
          74,
          148,
          53,
          106,
          212,
          181,
          119,
          238,
          193,
          159,
          35,
          70,
          140,
          5,
          10,
          20,
          40,
          80,
          160,
          93,
          186,
          105,
          210,
          185,
          111,
          222,
          161,
          95,
          190,
          97,
          194,
          153,
          47,
          94,
          188,
          101,
          202,
          137,
          15,
          30,
          60,
          120,
          240,
          253,
          231,
          211,
          187,
          107,
          214,
          177,
          127,
          254,
          225,
          223,
          163,
          91,
          182,
          113,
          226,
          217,
          175,
          67,
          134,
          17,
          34,
          68,
          136,
          13,
          26,
          52,
          104,
          208,
          189,
          103,
          206,
          129,
          31,
          62,
          124,
          248,
          237,
          199,
          147,
          59,
          118,
          236,
          197,
          151,
          51,
          102,
          204,
          133,
          23,
          46,
          92,
          184,
          109,
          218,
          169,
          79,
          158,
          33,
          66,
          132,
          21,
          42,
          84,
          168,
          77,
          154,
          41,
          82,
          164,
          85,
          170,
          73,
          146,
          57,
          114,
          228,
          213,
          183,
          115,
          230,
          209,
          191,
          99,
          198,
          145,
          63,
          126,
          252,
          229,
          215,
          179,
          123,
          246,
          241,
          255,
          227,
          219,
          171,
          75,
          150,
          49,
          98,
          196,
          149,
          55,
          110,
          220,
          165,
          87,
          174,
          65,
          130,
          25,
          50,
          100,
          200,
          141,
          7,
          14,
          28,
          56,
          112,
          224,
          221,
          167,
          83,
          166,
          81,
          162,
          89,
          178,
          121,
          242,
          249,
          239,
          195,
          155,
          43,
          86,
          172,
          69,
          138,
          9,
          18,
          36,
          72,
          144,
          61,
          122,
          244,
          245,
          247,
          243,
          251,
          235,
          203,
          139,
          11,
          22,
          44,
          88,
          176,
          125,
          250,
          233,
          207,
          131,
          27,
          54,
          108,
          216,
          173,
          71,
          142,
          0
        ],
        LOG: [
          255,
          0,
          1,
          25,
          2,
          50,
          26,
          198,
          3,
          223,
          51,
          238,
          27,
          104,
          199,
          75,
          4,
          100,
          224,
          14,
          52,
          141,
          239,
          129,
          28,
          193,
          105,
          248,
          200,
          8,
          76,
          113,
          5,
          138,
          101,
          47,
          225,
          36,
          15,
          33,
          53,
          147,
          142,
          218,
          240,
          18,
          130,
          69,
          29,
          181,
          194,
          125,
          106,
          39,
          249,
          185,
          201,
          154,
          9,
          120,
          77,
          228,
          114,
          166,
          6,
          191,
          139,
          98,
          102,
          221,
          48,
          253,
          226,
          152,
          37,
          179,
          16,
          145,
          34,
          136,
          54,
          208,
          148,
          206,
          143,
          150,
          219,
          189,
          241,
          210,
          19,
          92,
          131,
          56,
          70,
          64,
          30,
          66,
          182,
          163,
          195,
          72,
          126,
          110,
          107,
          58,
          40,
          84,
          250,
          133,
          186,
          61,
          202,
          94,
          155,
          159,
          10,
          21,
          121,
          43,
          78,
          212,
          229,
          172,
          115,
          243,
          167,
          87,
          7,
          112,
          192,
          247,
          140,
          128,
          99,
          13,
          103,
          74,
          222,
          237,
          49,
          197,
          254,
          24,
          227,
          165,
          153,
          119,
          38,
          184,
          180,
          124,
          17,
          68,
          146,
          217,
          35,
          32,
          137,
          46,
          55,
          63,
          209,
          91,
          149,
          188,
          207,
          205,
          144,
          135,
          151,
          178,
          220,
          252,
          190,
          97,
          242,
          86,
          211,
          171,
          20,
          42,
          93,
          158,
          132,
          60,
          57,
          83,
          71,
          109,
          65,
          162,
          31,
          45,
          67,
          216,
          183,
          123,
          164,
          118,
          196,
          23,
          73,
          236,
          127,
          12,
          111,
          246,
          108,
          161,
          59,
          82,
          41,
          157,
          85,
          170,
          251,
          96,
          134,
          177,
          187,
          204,
          62,
          90,
          203,
          89,
          95,
          176,
          156,
          169,
          160,
          81,
          11,
          245,
          22,
          235,
          122,
          117,
          44,
          215,
          79,
          174,
          213,
          233,
          230,
          231,
          173,
          232,
          116,
          214,
          244,
          234,
          168,
          80,
          88,
          175
        ]
      });
      var Galois_1 = Galois;
      var Version = lite.extend(null, {
        BLOCK: [
          3220,
          1468,
          2713,
          1235,
          3062,
          1890,
          2119,
          1549,
          2344,
          2936,
          1117,
          2583,
          1330,
          2470,
          1667,
          2249,
          2028,
          3780,
          481,
          4011,
          142,
          3098,
          831,
          3445,
          592,
          2517,
          1776,
          2234,
          1951,
          2827,
          1070,
          2660,
          1345,
          3177
        ]
      });
      var Version_1 = Version;
      var Frame = lite.extend(function(options) {
        var dataBlock, eccBlock, index2, neccBlock1, neccBlock2;
        var valueLength = options.value.length;
        this._badness = [];
        this._level = ErrorCorrection_1.LEVELS[options.level];
        this._polynomial = [];
        this._value = options.value;
        this._version = 0;
        this._stringBuffer = [];
        while (this._version < 40) {
          this._version++;
          index2 = (this._level - 1) * 4 + (this._version - 1) * 16;
          neccBlock1 = ErrorCorrection_1.BLOCKS[index2++];
          neccBlock2 = ErrorCorrection_1.BLOCKS[index2++];
          dataBlock = ErrorCorrection_1.BLOCKS[index2++];
          eccBlock = ErrorCorrection_1.BLOCKS[index2];
          index2 = dataBlock * (neccBlock1 + neccBlock2) + neccBlock2 - 3 + (this._version <= 9);
          if (valueLength <= index2) {
            break;
          }
        }
        this._dataBlock = dataBlock;
        this._eccBlock = eccBlock;
        this._neccBlock1 = neccBlock1;
        this._neccBlock2 = neccBlock2;
        var width2 = this.width = 17 + 4 * this._version;
        this.buffer = Frame._createArray(width2 * width2);
        this._ecc = Frame._createArray(dataBlock + (dataBlock + eccBlock) * (neccBlock1 + neccBlock2) + neccBlock2);
        this._mask = Frame._createArray((width2 * (width2 + 1) + 1) / 2);
        this._insertFinders();
        this._insertAlignments();
        this.buffer[8 + width2 * (width2 - 8)] = 1;
        this._insertTimingGap();
        this._reverseMask();
        this._insertTimingRowAndColumn();
        this._insertVersion();
        this._syncMask();
        this._convertBitStream(valueLength);
        this._calculatePolynomial();
        this._appendEccToData();
        this._interleaveBlocks();
        this._pack();
        this._finish();
      }, {
        _addAlignment: function(x5, y4) {
          var i4;
          var buffer = this.buffer;
          var width2 = this.width;
          buffer[x5 + width2 * y4] = 1;
          for (i4 = -2; i4 < 2; i4++) {
            buffer[x5 + i4 + width2 * (y4 - 2)] = 1;
            buffer[x5 - 2 + width2 * (y4 + i4 + 1)] = 1;
            buffer[x5 + 2 + width2 * (y4 + i4)] = 1;
            buffer[x5 + i4 + 1 + width2 * (y4 + 2)] = 1;
          }
          for (i4 = 0; i4 < 2; i4++) {
            this._setMask(x5 - 1, y4 + i4);
            this._setMask(x5 + 1, y4 - i4);
            this._setMask(x5 - i4, y4 - 1);
            this._setMask(x5 + i4, y4 + 1);
          }
        },
        _appendData: function(data, dataLength, ecc, eccLength) {
          var bit, i4, j4;
          var polynomial = this._polynomial;
          var stringBuffer = this._stringBuffer;
          for (i4 = 0; i4 < eccLength; i4++) {
            stringBuffer[ecc + i4] = 0;
          }
          for (i4 = 0; i4 < dataLength; i4++) {
            bit = Galois_1.LOG[stringBuffer[data + i4] ^ stringBuffer[ecc]];
            if (bit !== 255) {
              for (j4 = 1; j4 < eccLength; j4++) {
                stringBuffer[ecc + j4 - 1] = stringBuffer[ecc + j4] ^ Galois_1.EXPONENT[Frame._modN(bit + polynomial[eccLength - j4])];
              }
            } else {
              for (j4 = ecc; j4 < ecc + eccLength; j4++) {
                stringBuffer[j4] = stringBuffer[j4 + 1];
              }
            }
            stringBuffer[ecc + eccLength - 1] = bit === 255 ? 0 : Galois_1.EXPONENT[Frame._modN(bit + polynomial[0])];
          }
        },
        _appendEccToData: function() {
          var i4;
          var data = 0;
          var dataBlock = this._dataBlock;
          var ecc = this._calculateMaxLength();
          var eccBlock = this._eccBlock;
          for (i4 = 0; i4 < this._neccBlock1; i4++) {
            this._appendData(data, dataBlock, ecc, eccBlock);
            data += dataBlock;
            ecc += eccBlock;
          }
          for (i4 = 0; i4 < this._neccBlock2; i4++) {
            this._appendData(data, dataBlock + 1, ecc, eccBlock);
            data += dataBlock + 1;
            ecc += eccBlock;
          }
        },
        _applyMask: function(mask) {
          var r3x, r3y, x5, y4;
          var buffer = this.buffer;
          var width2 = this.width;
          switch (mask) {
            case 0:
              for (y4 = 0; y4 < width2; y4++) {
                for (x5 = 0; x5 < width2; x5++) {
                  if (!(x5 + y4 & 1) && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 1:
              for (y4 = 0; y4 < width2; y4++) {
                for (x5 = 0; x5 < width2; x5++) {
                  if (!(y4 & 1) && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 2:
              for (y4 = 0; y4 < width2; y4++) {
                for (r3x = 0, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
                  if (!r3x && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 3:
              for (r3y = 0, y4 = 0; y4 < width2; y4++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
                for (r3x = r3y, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
                  if (!r3x && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 4:
              for (y4 = 0; y4 < width2; y4++) {
                for (r3x = 0, r3y = y4 >> 1 & 1, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                    r3y = !r3y;
                  }
                  if (!r3y && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 5:
              for (r3y = 0, y4 = 0; y4 < width2; y4++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
                for (r3x = 0, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
                  if (!((x5 & y4 & 1) + !(!r3x | !r3y)) && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 6:
              for (r3y = 0, y4 = 0; y4 < width2; y4++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
                for (r3x = 0, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
                  if (!((x5 & y4 & 1) + (r3x && r3x === r3y) & 1) && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
            case 7:
              for (r3y = 0, y4 = 0; y4 < width2; y4++, r3y++) {
                if (r3y === 3) {
                  r3y = 0;
                }
                for (r3x = 0, x5 = 0; x5 < width2; x5++, r3x++) {
                  if (r3x === 3) {
                    r3x = 0;
                  }
                  if (!((r3x && r3x === r3y) + (x5 + y4 & 1) & 1) && !this._isMasked(x5, y4)) {
                    buffer[x5 + y4 * width2] ^= 1;
                  }
                }
              }
              break;
          }
        },
        _calculateMaxLength: function() {
          return this._dataBlock * (this._neccBlock1 + this._neccBlock2) + this._neccBlock2;
        },
        _calculatePolynomial: function() {
          var i4, j4;
          var eccBlock = this._eccBlock;
          var polynomial = this._polynomial;
          polynomial[0] = 1;
          for (i4 = 0; i4 < eccBlock; i4++) {
            polynomial[i4 + 1] = 1;
            for (j4 = i4; j4 > 0; j4--) {
              polynomial[j4] = polynomial[j4] ? polynomial[j4 - 1] ^ Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[j4]] + i4)] : polynomial[j4 - 1];
            }
            polynomial[0] = Galois_1.EXPONENT[Frame._modN(Galois_1.LOG[polynomial[0]] + i4)];
          }
          for (i4 = 0; i4 <= eccBlock; i4++) {
            polynomial[i4] = Galois_1.LOG[polynomial[i4]];
          }
        },
        _checkBadness: function() {
          var b5, b1, h32, x5, y4;
          var bad = 0;
          var badness = this._badness;
          var buffer = this.buffer;
          var width2 = this.width;
          for (y4 = 0; y4 < width2 - 1; y4++) {
            for (x5 = 0; x5 < width2 - 1; x5++) {
              if (buffer[x5 + width2 * y4] && buffer[x5 + 1 + width2 * y4] && buffer[x5 + width2 * (y4 + 1)] && buffer[x5 + 1 + width2 * (y4 + 1)] || !(buffer[x5 + width2 * y4] || buffer[x5 + 1 + width2 * y4] || buffer[x5 + width2 * (y4 + 1)] || buffer[x5 + 1 + width2 * (y4 + 1)])) {
                bad += Frame.N2;
              }
            }
          }
          var bw = 0;
          for (y4 = 0; y4 < width2; y4++) {
            h32 = 0;
            badness[0] = 0;
            for (b5 = 0, x5 = 0; x5 < width2; x5++) {
              b1 = buffer[x5 + width2 * y4];
              if (b5 === b1) {
                badness[h32]++;
              } else {
                badness[++h32] = 1;
              }
              b5 = b1;
              bw += b5 ? 1 : -1;
            }
            bad += this._getBadness(h32);
          }
          if (bw < 0) {
            bw = -bw;
          }
          var count2 = 0;
          var big = bw;
          big += big << 2;
          big <<= 1;
          while (big > width2 * width2) {
            big -= width2 * width2;
            count2++;
          }
          bad += count2 * Frame.N4;
          for (x5 = 0; x5 < width2; x5++) {
            h32 = 0;
            badness[0] = 0;
            for (b5 = 0, y4 = 0; y4 < width2; y4++) {
              b1 = buffer[x5 + width2 * y4];
              if (b5 === b1) {
                badness[h32]++;
              } else {
                badness[++h32] = 1;
              }
              b5 = b1;
            }
            bad += this._getBadness(h32);
          }
          return bad;
        },
        _convertBitStream: function(length) {
          var bit, i4;
          var ecc = this._ecc;
          var version2 = this._version;
          for (i4 = 0; i4 < length; i4++) {
            ecc[i4] = this._value.charCodeAt(i4);
          }
          var stringBuffer = this._stringBuffer = ecc.slice();
          var maxLength = this._calculateMaxLength();
          if (length >= maxLength - 2) {
            length = maxLength - 2;
            if (version2 > 9) {
              length--;
            }
          }
          var index2 = length;
          if (version2 > 9) {
            stringBuffer[index2 + 2] = 0;
            stringBuffer[index2 + 3] = 0;
            while (index2--) {
              bit = stringBuffer[index2];
              stringBuffer[index2 + 3] |= 255 & bit << 4;
              stringBuffer[index2 + 2] = bit >> 4;
            }
            stringBuffer[2] |= 255 & length << 4;
            stringBuffer[1] = length >> 4;
            stringBuffer[0] = 64 | length >> 12;
          } else {
            stringBuffer[index2 + 1] = 0;
            stringBuffer[index2 + 2] = 0;
            while (index2--) {
              bit = stringBuffer[index2];
              stringBuffer[index2 + 2] |= 255 & bit << 4;
              stringBuffer[index2 + 1] = bit >> 4;
            }
            stringBuffer[1] |= 255 & length << 4;
            stringBuffer[0] = 64 | length >> 4;
          }
          index2 = length + 3 - (version2 < 10);
          while (index2 < maxLength) {
            stringBuffer[index2++] = 236;
            stringBuffer[index2++] = 17;
          }
        },
        _getBadness: function(length) {
          var i4;
          var badRuns = 0;
          var badness = this._badness;
          for (i4 = 0; i4 <= length; i4++) {
            if (badness[i4] >= 5) {
              badRuns += Frame.N1 + badness[i4] - 5;
            }
          }
          for (i4 = 3; i4 < length - 1; i4 += 2) {
            if (badness[i4 - 2] === badness[i4 + 2] && badness[i4 + 2] === badness[i4 - 1] && badness[i4 - 1] === badness[i4 + 1] && badness[i4 - 1] * 3 === badness[i4] && (badness[i4 - 3] === 0 || i4 + 3 > length || badness[i4 - 3] * 3 >= badness[i4] * 4 || badness[i4 + 3] * 3 >= badness[i4] * 4)) {
              badRuns += Frame.N3;
            }
          }
          return badRuns;
        },
        _finish: function() {
          this._stringBuffer = this.buffer.slice();
          var currentMask, i4;
          var bit = 0;
          var mask = 3e4;
          for (i4 = 0; i4 < 8; i4++) {
            this._applyMask(i4);
            currentMask = this._checkBadness();
            if (currentMask < mask) {
              mask = currentMask;
              bit = i4;
            }
            if (bit === 7) {
              break;
            }
            this.buffer = this._stringBuffer.slice();
          }
          if (bit !== i4) {
            this._applyMask(bit);
          }
          mask = ErrorCorrection_1.FINAL_FORMAT[bit + (this._level - 1 << 3)];
          var buffer = this.buffer;
          var width2 = this.width;
          for (i4 = 0; i4 < 8; i4++, mask >>= 1) {
            if (mask & 1) {
              buffer[width2 - 1 - i4 + width2 * 8] = 1;
              if (i4 < 6) {
                buffer[8 + width2 * i4] = 1;
              } else {
                buffer[8 + width2 * (i4 + 1)] = 1;
              }
            }
          }
          for (i4 = 0; i4 < 7; i4++, mask >>= 1) {
            if (mask & 1) {
              buffer[8 + width2 * (width2 - 7 + i4)] = 1;
              if (i4) {
                buffer[6 - i4 + width2 * 8] = 1;
              } else {
                buffer[7 + width2 * 8] = 1;
              }
            }
          }
        },
        _interleaveBlocks: function() {
          var i4, j4;
          var dataBlock = this._dataBlock;
          var ecc = this._ecc;
          var eccBlock = this._eccBlock;
          var k5 = 0;
          var maxLength = this._calculateMaxLength();
          var neccBlock1 = this._neccBlock1;
          var neccBlock2 = this._neccBlock2;
          var stringBuffer = this._stringBuffer;
          for (i4 = 0; i4 < dataBlock; i4++) {
            for (j4 = 0; j4 < neccBlock1; j4++) {
              ecc[k5++] = stringBuffer[i4 + j4 * dataBlock];
            }
            for (j4 = 0; j4 < neccBlock2; j4++) {
              ecc[k5++] = stringBuffer[neccBlock1 * dataBlock + i4 + j4 * (dataBlock + 1)];
            }
          }
          for (j4 = 0; j4 < neccBlock2; j4++) {
            ecc[k5++] = stringBuffer[neccBlock1 * dataBlock + i4 + j4 * (dataBlock + 1)];
          }
          for (i4 = 0; i4 < eccBlock; i4++) {
            for (j4 = 0; j4 < neccBlock1 + neccBlock2; j4++) {
              ecc[k5++] = stringBuffer[maxLength + i4 + j4 * eccBlock];
            }
          }
          this._stringBuffer = ecc;
        },
        _insertAlignments: function() {
          var i4, x5, y4;
          var version2 = this._version;
          var width2 = this.width;
          if (version2 > 1) {
            i4 = Alignment_1.BLOCK[version2];
            y4 = width2 - 7;
            for (; ; ) {
              x5 = width2 - 7;
              while (x5 > i4 - 3) {
                this._addAlignment(x5, y4);
                if (x5 < i4) {
                  break;
                }
                x5 -= i4;
              }
              if (y4 <= i4 + 9) {
                break;
              }
              y4 -= i4;
              this._addAlignment(6, y4);
              this._addAlignment(y4, 6);
            }
          }
        },
        _insertFinders: function() {
          var i4, j4, x5, y4;
          var buffer = this.buffer;
          var width2 = this.width;
          for (i4 = 0; i4 < 3; i4++) {
            j4 = 0;
            y4 = 0;
            if (i4 === 1) {
              j4 = width2 - 7;
            }
            if (i4 === 2) {
              y4 = width2 - 7;
            }
            buffer[y4 + 3 + width2 * (j4 + 3)] = 1;
            for (x5 = 0; x5 < 6; x5++) {
              buffer[y4 + x5 + width2 * j4] = 1;
              buffer[y4 + width2 * (j4 + x5 + 1)] = 1;
              buffer[y4 + 6 + width2 * (j4 + x5)] = 1;
              buffer[y4 + x5 + 1 + width2 * (j4 + 6)] = 1;
            }
            for (x5 = 1; x5 < 5; x5++) {
              this._setMask(y4 + x5, j4 + 1);
              this._setMask(y4 + 1, j4 + x5 + 1);
              this._setMask(y4 + 5, j4 + x5);
              this._setMask(y4 + x5 + 1, j4 + 5);
            }
            for (x5 = 2; x5 < 4; x5++) {
              buffer[y4 + x5 + width2 * (j4 + 2)] = 1;
              buffer[y4 + 2 + width2 * (j4 + x5 + 1)] = 1;
              buffer[y4 + 4 + width2 * (j4 + x5)] = 1;
              buffer[y4 + x5 + 1 + width2 * (j4 + 4)] = 1;
            }
          }
        },
        _insertTimingGap: function() {
          var x5, y4;
          var width2 = this.width;
          for (y4 = 0; y4 < 7; y4++) {
            this._setMask(7, y4);
            this._setMask(width2 - 8, y4);
            this._setMask(7, y4 + width2 - 7);
          }
          for (x5 = 0; x5 < 8; x5++) {
            this._setMask(x5, 7);
            this._setMask(x5 + width2 - 8, 7);
            this._setMask(x5, width2 - 8);
          }
        },
        _insertTimingRowAndColumn: function() {
          var x5;
          var buffer = this.buffer;
          var width2 = this.width;
          for (x5 = 0; x5 < width2 - 14; x5++) {
            if (x5 & 1) {
              this._setMask(8 + x5, 6);
              this._setMask(6, 8 + x5);
            } else {
              buffer[8 + x5 + width2 * 6] = 1;
              buffer[6 + width2 * (8 + x5)] = 1;
            }
          }
        },
        _insertVersion: function() {
          var i4, j4, x5, y4;
          var buffer = this.buffer;
          var version2 = this._version;
          var width2 = this.width;
          if (version2 > 6) {
            i4 = Version_1.BLOCK[version2 - 7];
            j4 = 17;
            for (x5 = 0; x5 < 6; x5++) {
              for (y4 = 0; y4 < 3; y4++, j4--) {
                if (1 & (j4 > 11 ? version2 >> j4 - 12 : i4 >> j4)) {
                  buffer[5 - x5 + width2 * (2 - y4 + width2 - 11)] = 1;
                  buffer[2 - y4 + width2 - 11 + width2 * (5 - x5)] = 1;
                } else {
                  this._setMask(5 - x5, 2 - y4 + width2 - 11);
                  this._setMask(2 - y4 + width2 - 11, 5 - x5);
                }
              }
            }
          }
        },
        _isMasked: function(x5, y4) {
          var bit = Frame._getMaskBit(x5, y4);
          return this._mask[bit] === 1;
        },
        _pack: function() {
          var bit, i4, j4;
          var k5 = 1;
          var v5 = 1;
          var width2 = this.width;
          var x5 = width2 - 1;
          var y4 = width2 - 1;
          var length = (this._dataBlock + this._eccBlock) * (this._neccBlock1 + this._neccBlock2) + this._neccBlock2;
          for (i4 = 0; i4 < length; i4++) {
            bit = this._stringBuffer[i4];
            for (j4 = 0; j4 < 8; j4++, bit <<= 1) {
              if (128 & bit) {
                this.buffer[x5 + width2 * y4] = 1;
              }
              do {
                if (v5) {
                  x5--;
                } else {
                  x5++;
                  if (k5) {
                    if (y4 !== 0) {
                      y4--;
                    } else {
                      x5 -= 2;
                      k5 = !k5;
                      if (x5 === 6) {
                        x5--;
                        y4 = 9;
                      }
                    }
                  } else if (y4 !== width2 - 1) {
                    y4++;
                  } else {
                    x5 -= 2;
                    k5 = !k5;
                    if (x5 === 6) {
                      x5--;
                      y4 -= 8;
                    }
                  }
                }
                v5 = !v5;
              } while (this._isMasked(x5, y4));
            }
          }
        },
        _reverseMask: function() {
          var x5, y4;
          var width2 = this.width;
          for (x5 = 0; x5 < 9; x5++) {
            this._setMask(x5, 8);
          }
          for (x5 = 0; x5 < 8; x5++) {
            this._setMask(x5 + width2 - 8, 8);
            this._setMask(8, x5);
          }
          for (y4 = 0; y4 < 7; y4++) {
            this._setMask(8, y4 + width2 - 7);
          }
        },
        _setMask: function(x5, y4) {
          var bit = Frame._getMaskBit(x5, y4);
          this._mask[bit] = 1;
        },
        _syncMask: function() {
          var x5, y4;
          var width2 = this.width;
          for (y4 = 0; y4 < width2; y4++) {
            for (x5 = 0; x5 <= y4; x5++) {
              if (this.buffer[x5 + width2 * y4]) {
                this._setMask(x5, y4);
              }
            }
          }
        }
      }, {
        _createArray: function(length) {
          var i4;
          var array = [];
          for (i4 = 0; i4 < length; i4++) {
            array[i4] = 0;
          }
          return array;
        },
        _getMaskBit: function(x5, y4) {
          var bit;
          if (x5 > y4) {
            bit = x5;
            x5 = y4;
            y4 = bit;
          }
          bit = y4;
          bit += y4 * y4;
          bit >>= 1;
          bit += x5;
          return bit;
        },
        _modN: function(x5) {
          while (x5 >= 255) {
            x5 -= 255;
            x5 = (x5 >> 8) + (x5 & 255);
          }
          return x5;
        },
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
      });
      var Frame_1 = Frame;
      var ImageRenderer = Renderer_1.extend({
        draw: function() {
          this.element.src = this.qrious.toDataURL();
        },
        reset: function() {
          this.element.src = "";
        },
        resize: function() {
          var element = this.element;
          element.width = element.height = this.qrious.size;
        }
      });
      var ImageRenderer_1 = ImageRenderer;
      var Option = lite.extend(function(name, modifiable, defaultValue, valueTransformer) {
        this.name = name;
        this.modifiable = Boolean(modifiable);
        this.defaultValue = defaultValue;
        this._valueTransformer = valueTransformer;
      }, {
        transform: function(value) {
          var transformer = this._valueTransformer;
          if (typeof transformer === "function") {
            return transformer(value, this);
          }
          return value;
        }
      });
      var Option_1 = Option;
      var Utilities = lite.extend(null, {
        abs: function(value) {
          return value != null ? Math.abs(value) : null;
        },
        hasOwn: function(object, name) {
          return Object.prototype.hasOwnProperty.call(object, name);
        },
        noop: function() {
        },
        toUpperCase: function(string) {
          return string != null ? string.toUpperCase() : null;
        }
      });
      var Utilities_1 = Utilities;
      var OptionManager = lite.extend(function(options) {
        this.options = {};
        options.forEach(function(option) {
          this.options[option.name] = option;
        }, this);
      }, {
        exists: function(name) {
          return this.options[name] != null;
        },
        get: function(name, target) {
          return OptionManager._get(this.options[name], target);
        },
        getAll: function(target) {
          var name;
          var options = this.options;
          var result = {};
          for (name in options) {
            if (Utilities_1.hasOwn(options, name)) {
              result[name] = OptionManager._get(options[name], target);
            }
          }
          return result;
        },
        init: function(options, target, changeHandler) {
          if (typeof changeHandler !== "function") {
            changeHandler = Utilities_1.noop;
          }
          var name, option;
          for (name in this.options) {
            if (Utilities_1.hasOwn(this.options, name)) {
              option = this.options[name];
              OptionManager._set(option, option.defaultValue, target);
              OptionManager._createAccessor(option, target, changeHandler);
            }
          }
          this._setAll(options, target, true);
        },
        set: function(name, value, target) {
          return this._set(name, value, target);
        },
        setAll: function(options, target) {
          return this._setAll(options, target);
        },
        _set: function(name, value, target, allowUnmodifiable) {
          var option = this.options[name];
          if (!option) {
            throw new Error("Invalid option: " + name);
          }
          if (!option.modifiable && !allowUnmodifiable) {
            throw new Error("Option cannot be modified: " + name);
          }
          return OptionManager._set(option, value, target);
        },
        _setAll: function(options, target, allowUnmodifiable) {
          if (!options) {
            return false;
          }
          var name;
          var changed = false;
          for (name in options) {
            if (Utilities_1.hasOwn(options, name) && this._set(name, options[name], target, allowUnmodifiable)) {
              changed = true;
            }
          }
          return changed;
        }
      }, {
        _createAccessor: function(option, target, changeHandler) {
          var descriptor = {
            get: function() {
              return OptionManager._get(option, target);
            }
          };
          if (option.modifiable) {
            descriptor.set = function(value) {
              if (OptionManager._set(option, value, target)) {
                changeHandler(value, option);
              }
            };
          }
          Object.defineProperty(target, option.name, descriptor);
        },
        _get: function(option, target) {
          return target["_" + option.name];
        },
        _set: function(option, value, target) {
          var fieldName = "_" + option.name;
          var oldValue = target[fieldName];
          var newValue = option.transform(value != null ? value : option.defaultValue);
          target[fieldName] = newValue;
          return newValue !== oldValue;
        }
      });
      var OptionManager_1 = OptionManager;
      var ServiceManager = lite.extend(function() {
        this._services = {};
      }, {
        getService: function(name) {
          var service = this._services[name];
          if (!service) {
            throw new Error("Service is not being managed with name: " + name);
          }
          return service;
        },
        setService: function(name, service) {
          if (this._services[name]) {
            throw new Error("Service is already managed with name: " + name);
          }
          if (service) {
            this._services[name] = service;
          }
        }
      });
      var ServiceManager_1 = ServiceManager;
      var optionManager = new OptionManager_1([
        new Option_1("background", true, "white"),
        new Option_1("backgroundAlpha", true, 1, Utilities_1.abs),
        new Option_1("element"),
        new Option_1("foreground", true, "black"),
        new Option_1("foregroundAlpha", true, 1, Utilities_1.abs),
        new Option_1("level", true, "L", Utilities_1.toUpperCase),
        new Option_1("mime", true, "image/png"),
        new Option_1("padding", true, null, Utilities_1.abs),
        new Option_1("size", true, 100, Utilities_1.abs),
        new Option_1("value", true, "")
      ]);
      var serviceManager = new ServiceManager_1();
      var QRious3 = lite.extend(function(options) {
        optionManager.init(options, this, this.update.bind(this));
        var element = optionManager.get("element", this);
        var elementService = serviceManager.getService("element");
        var canvas = element && elementService.isCanvas(element) ? element : elementService.createCanvas();
        var image = element && elementService.isImage(element) ? element : elementService.createImage();
        this._canvasRenderer = new CanvasRenderer_1(this, canvas, true);
        this._imageRenderer = new ImageRenderer_1(this, image, image === element);
        this.update();
      }, {
        get: function() {
          return optionManager.getAll(this);
        },
        set: function(options) {
          if (optionManager.setAll(options, this)) {
            this.update();
          }
        },
        toDataURL: function(mime) {
          return this.canvas.toDataURL(mime || this.mime);
        },
        update: function() {
          var frame2 = new Frame_1({
            level: this.level,
            value: this.value
          });
          this._canvasRenderer.render(frame2);
          this._imageRenderer.render(frame2);
        }
      }, {
        use: function(service) {
          serviceManager.setService(service.getName(), service);
        }
      });
      Object.defineProperties(QRious3.prototype, {
        canvas: {
          get: function() {
            return this._canvasRenderer.getElement();
          }
        },
        image: {
          get: function() {
            return this._imageRenderer.getElement();
          }
        }
      });
      var QRious_1$2 = QRious3;
      var index = QRious_1$2;
      var Service = lite.extend({
        getName: function() {
        }
      });
      var Service_1 = Service;
      var ElementService = Service_1.extend({
        createCanvas: function() {
        },
        createImage: function() {
        },
        getName: function() {
          return "element";
        },
        isCanvas: function(element) {
        },
        isImage: function(element) {
        }
      });
      var ElementService_1 = ElementService;
      var BrowserElementService = ElementService_1.extend({
        createCanvas: function() {
          return document.createElement("canvas");
        },
        createImage: function() {
          return document.createElement("img");
        },
        isCanvas: function(element) {
          return element instanceof HTMLCanvasElement;
        },
        isImage: function(element) {
          return element instanceof HTMLImageElement;
        }
      });
      var BrowserElementService_1 = BrowserElementService;
      index.use(new BrowserElementService_1());
      var QRious_1 = index;
      return QRious_1;
    });
  }
});
var require_ReactPropTypesSecret = __commonJS({
  "../../../../.yarn/global/cache/prop-types-npm-15.8.1-17c71ee7ee-9c9.zip/node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    init_define_process();
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});
var require_factoryWithThrowingShims = __commonJS({
  "../../../../.yarn/global/cache/prop-types-npm-15.8.1-17c71ee7ee-9c9.zip/node_modules/prop-types/factoryWithThrowingShims.js"(exports, module) {
    "use strict";
    init_define_process();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    function emptyFunction() {
    }
    __name(emptyFunction, "emptyFunction");
    function emptyFunctionWithReset() {
    }
    __name(emptyFunctionWithReset, "emptyFunctionWithReset");
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    module.exports = function() {
      function shim(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      __name(shim, "shim");
      ;
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      __name(getShim, "getShim");
      ;
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});
var require_prop_types = __commonJS({
  "../../../../.yarn/global/cache/prop-types-npm-15.8.1-17c71ee7ee-9c9.zip/node_modules/prop-types/index.js"(exports, module) {
    init_define_process();
    if (false) {
      ReactIs = null;
      throwOnDirectAccess = true;
      module.exports = null(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = require_factoryWithThrowingShims()();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});
var require_react_is_production_min2 = __commonJS({
  "../../../../.yarn/global/cache/react-is-npm-18.2.0-0cc5edb910-9c9.zip/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
    "use strict";
    init_define_process();
    var b5 = Symbol.for("react.element");
    var c5 = Symbol.for("react.portal");
    var d4 = Symbol.for("react.fragment");
    var e22 = Symbol.for("react.strict_mode");
    var f4 = Symbol.for("react.profiler");
    var g5 = Symbol.for("react.provider");
    var h32 = Symbol.for("react.context");
    var k5 = Symbol.for("react.server_context");
    var l4 = Symbol.for("react.forward_ref");
    var m22 = Symbol.for("react.suspense");
    var n3 = Symbol.for("react.suspense_list");
    var p22 = Symbol.for("react.memo");
    var q4 = Symbol.for("react.lazy");
    var t3 = Symbol.for("react.offscreen");
    var u4;
    u4 = Symbol.for("react.module.reference");
    function v5(a5) {
      if ("object" === typeof a5 && null !== a5) {
        var r22 = a5.$$typeof;
        switch (r22) {
          case b5:
            switch (a5 = a5.type, a5) {
              case d4:
              case f4:
              case e22:
              case m22:
              case n3:
                return a5;
              default:
                switch (a5 = a5 && a5.$$typeof, a5) {
                  case k5:
                  case h32:
                  case l4:
                  case q4:
                  case p22:
                  case g5:
                    return a5;
                  default:
                    return r22;
                }
            }
          case c5:
            return r22;
        }
      }
    }
    __name(v5, "v");
    exports.ContextConsumer = h32;
    exports.ContextProvider = g5;
    exports.Element = b5;
    exports.ForwardRef = l4;
    exports.Fragment = d4;
    exports.Lazy = q4;
    exports.Memo = p22;
    exports.Portal = c5;
    exports.Profiler = f4;
    exports.StrictMode = e22;
    exports.Suspense = m22;
    exports.SuspenseList = n3;
    exports.isAsyncMode = function() {
      return false;
    };
    exports.isConcurrentMode = function() {
      return false;
    };
    exports.isContextConsumer = function(a5) {
      return v5(a5) === h32;
    };
    exports.isContextProvider = function(a5) {
      return v5(a5) === g5;
    };
    exports.isElement = function(a5) {
      return "object" === typeof a5 && null !== a5 && a5.$$typeof === b5;
    };
    exports.isForwardRef = function(a5) {
      return v5(a5) === l4;
    };
    exports.isFragment = function(a5) {
      return v5(a5) === d4;
    };
    exports.isLazy = function(a5) {
      return v5(a5) === q4;
    };
    exports.isMemo = function(a5) {
      return v5(a5) === p22;
    };
    exports.isPortal = function(a5) {
      return v5(a5) === c5;
    };
    exports.isProfiler = function(a5) {
      return v5(a5) === f4;
    };
    exports.isStrictMode = function(a5) {
      return v5(a5) === e22;
    };
    exports.isSuspense = function(a5) {
      return v5(a5) === m22;
    };
    exports.isSuspenseList = function(a5) {
      return v5(a5) === n3;
    };
    exports.isValidElementType = function(a5) {
      return "string" === typeof a5 || "function" === typeof a5 || a5 === d4 || a5 === f4 || a5 === e22 || a5 === m22 || a5 === n3 || a5 === t3 || "object" === typeof a5 && null !== a5 && (a5.$$typeof === q4 || a5.$$typeof === p22 || a5.$$typeof === g5 || a5.$$typeof === h32 || a5.$$typeof === l4 || a5.$$typeof === u4 || void 0 !== a5.getModuleId) ? true : false;
    };
    exports.typeOf = v5;
  }
});
var require_react_is2 = __commonJS({
  "../../../../.yarn/global/cache/react-is-npm-18.2.0-0cc5edb910-9c9.zip/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_react_is_production_min2();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_is_prop_valid_cjs_prod = __commonJS({
  "../../../../.yarn/global/cache/@emotion-is-prop-valid-npm-1.2.0-332d343e3d-9c9.zip/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e22) {
      return e22 && e22.__esModule ? e22 : { "default": e22 };
    }
    __name(_interopDefault, "_interopDefault");
    var memoize__default = _interopDefault(memoize2);
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = memoize__default["default"](
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    exports.default = isPropValid;
  }
});
var require_emotion_is_prop_valid_cjs = __commonJS({
  "../../../../.yarn/global/cache/@emotion-is-prop-valid-npm-1.2.0-332d343e3d-9c9.zip/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_is_prop_valid_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_emotion_styled_base_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-styled-virtual-a383d0174f/5/.yarn/global/cache/@emotion-styled-npm-11.10.4-aa26bdcb16-9c9.zip/node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends2 = require_extends();
    var React2 = (init_react_preact(), __toCommonJS(react_preact_exports));
    var isPropValid = require_emotion_is_prop_valid_cjs();
    var react = require_emotion_react_cjs();
    var utils = require_emotion_utils_cjs();
    var serialize = require_emotion_serialize_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e22) {
      return e22 && e22.__esModule ? e22 : { "default": e22 };
    }
    __name(_interopDefault, "_interopDefault");
    var isPropValid__default = _interopDefault(isPropValid);
    var testOmitPropsOnStringTag = isPropValid__default["default"];
    var testOmitPropsOnComponent = __name(function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    }, "testOmitPropsOnComponent");
    var getDefaultShouldForwardProp = __name(function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    }, "getDefaultShouldForwardProp");
    var composeShouldForwardProps = __name(function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
      }
      return shouldForwardProp2;
    }, "composeShouldForwardProps");
    var isBrowser2 = typeof document !== "undefined";
    var Insertion = __name(function Insertion2(_ref) {
      var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      utils.registerStyles(cache2, serialized, isStringTag2);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache2, serialized, isStringTag2);
      });
      if (!isBrowser2 && rules !== void 0) {
        var _ref2;
        var serializedNames = serialized.name;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          next = next.next;
        }
        return React2.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache2.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache2.sheet.nonce, _ref2));
      }
      return null;
    }, "Insertion");
    var createStyled2 = __name(function createStyled3(tag, options) {
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles2.push.apply(styles2, args);
        } else {
          styles2.push(args[0][0]);
          var len = args.length;
          var i4 = 1;
          for (; i4 < len; i4++) {
            styles2.push(args[i4], args[0][i4]);
          }
        }
        var Styled = react.withEmotionCache(function(props, cache2, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props) {
              mergedProps[key] = props[key];
            }
            mergedProps.theme = React2.useContext(react.ThemeContext);
          }
          if (typeof props.className === "string") {
            className = utils.getRegisteredStyles(cache2.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serialize.serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
          className += cache2.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props) {
            if (shouldUseAs && _key === "as")
              continue;
            if (finalShouldForwardProp(_key)) {
              newProps[_key] = props[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), React2.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
          value: __name(function value() {
            if (targetClassName === void 0 && false) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }, "value")
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled3(nextTag, _extends2({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles2);
        };
        return Styled;
      };
    }, "createStyled");
    exports.default = createStyled2;
  }
});
var require_emotion_styled_cjs_prod = __commonJS({
  ".yarn/__virtual__/@emotion-styled-virtual-a383d0174f/5/.yarn/global/cache/@emotion-styled-npm-11.10.4-aa26bdcb16-9c9.zip/node_modules/@emotion/styled/dist/emotion-styled.cjs.prod.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", { value: true });
    require_extends();
    init_react_preact();
    require_emotion_is_prop_valid_cjs();
    var base_dist_emotionStyledBase = require_emotion_styled_base_cjs_prod();
    require_emotion_react_cjs();
    require_emotion_utils_cjs();
    require_emotion_serialize_cjs();
    require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = base_dist_emotionStyledBase["default"].bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    exports.default = newStyled;
  }
});
var require_emotion_styled_cjs = __commonJS({
  ".yarn/__virtual__/@emotion-styled-virtual-a383d0174f/5/.yarn/global/cache/@emotion-styled-npm-11.10.4-aa26bdcb16-9c9.zip/node_modules/@emotion/styled/dist/emotion-styled.cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    if (true) {
      module.exports = require_emotion_styled_cjs_prod();
    } else {
      module.exports = null;
    }
  }
});
var require_lodash = __commonJS({
  "../../../../.yarn/global/cache/lodash.debounce-npm-4.0.8-f1d6e09799-9c9.zip/node_modules/lodash.debounce/index.js"(exports, module) {
    init_define_process();
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = __name(function() {
      return root.Date.now();
    }, "now");
    function debounce4(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      __name(invokeFunc, "invokeFunc");
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      __name(leadingEdge, "leadingEdge");
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      __name(remainingWait, "remainingWait");
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      __name(shouldInvoke, "shouldInvoke");
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      __name(timerExpired, "timerExpired");
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      __name(trailingEdge, "trailingEdge");
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      __name(cancel, "cancel");
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      __name(flush, "flush");
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      __name(debounced, "debounced");
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    __name(debounce4, "debounce");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = debounce4;
  }
});
init_define_process();
init_define_process();
init_react_preact();
init_react_preact();
init_define_process();
init_react_preact();
init_react_preact();
var __extends2 = function() {
  var extendStatics = __name(function(d4, b5) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
      d22.__proto__ = b22;
    } || function(d22, b22) {
      for (var p22 in b22)
        if (b22.hasOwnProperty(p22))
          d22[p22] = b22[p22];
    };
    return extendStatics(d4, b5);
  }, "extendStatics");
  return function(d4, b5) {
    extendStatics(d4, b5);
    function __() {
      this.constructor = d4;
    }
    __name(__, "__");
    d4.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
  };
}();
var ELEMENT_TYPE_HTML = "html";
var ELEMENT_TYPE_SVG = "svg";
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
var validateElementType = __name(function(domElement, elementType) {
  if (elementType === ELEMENT_TYPE_HTML) {
    return domElement instanceof HTMLElement;
  }
  if (elementType === ELEMENT_TYPE_SVG) {
    return domElement instanceof SVGElement;
  }
  throw new Error('Unrecognized element type "' + elementType + '" for validateElementType.');
}, "validateElementType");
var createPortalNode = __name(function(elementType, options) {
  var initialProps = {};
  var parent;
  var lastPlaceholder;
  var element;
  if (elementType === ELEMENT_TYPE_HTML) {
    element = document.createElement("div");
  } else if (elementType === ELEMENT_TYPE_SVG) {
    element = document.createElementNS(SVG_NAMESPACE, "g");
  } else {
    throw new Error('Invalid element type "' + elementType + '" for createPortalNode: must be "html" or "svg".');
  }
  if (options && typeof options === "object") {
    for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      element.setAttribute(key, value);
    }
  }
  var portalNode = {
    element,
    elementType,
    setPortalProps: function(props) {
      initialProps = props;
    },
    getInitialPortalProps: function() {
      return initialProps;
    },
    mount: function(newParent, newPlaceholder) {
      if (newPlaceholder === lastPlaceholder) {
        return;
      }
      portalNode.unmount();
      if (newParent !== parent) {
        if (!validateElementType(newParent, elementType)) {
          throw new Error('Invalid element type for portal: "' + elementType + '" portalNodes must be used with ' + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");
        }
      }
      newParent.replaceChild(portalNode.element, newPlaceholder);
      parent = newParent;
      lastPlaceholder = newPlaceholder;
    },
    unmount: function(expectedPlaceholder) {
      if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {
        return;
      }
      if (parent && lastPlaceholder) {
        parent.replaceChild(lastPlaceholder, portalNode.element);
        parent = void 0;
        lastPlaceholder = void 0;
      }
    }
  };
  return portalNode;
}, "createPortalNode");
var InPortal = function(_super) {
  __extends2(InPortal2, _super);
  function InPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.addPropsChannel = function() {
      Object.assign(_this.props.node, {
        setPortalProps: function(props2) {
          _this.setState({ nodeProps: props2 });
        }
      });
    };
    _this.state = {
      nodeProps: _this.props.node.getInitialPortalProps()
    };
    return _this;
  }
  __name(InPortal2, "InPortal");
  InPortal2.prototype.componentDidMount = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.componentDidUpdate = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.render = function() {
    var _this = this;
    var _a = this.props, children2 = _a.children, node = _a.node;
    return V(Children.map(children2, function(child) {
      if (!isValidElement(child))
        return child;
      return cloneElement(child, _this.state.nodeProps);
    }), node.element);
  };
  return InPortal2;
}(PureComponent);
var OutPortal = function(_super) {
  __extends2(OutPortal2, _super);
  function OutPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.placeholderNode = createRef();
    _this.passPropsThroughPortal();
    return _this;
  }
  __name(OutPortal2, "OutPortal");
  OutPortal2.prototype.passPropsThroughPortal = function() {
    var propsForTarget = Object.assign({}, this.props, { node: void 0 });
    this.props.node.setPortalProps(propsForTarget);
  };
  OutPortal2.prototype.componentDidMount = function() {
    var node = this.props.node;
    this.currentPortalNode = node;
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentDidUpdate = function() {
    var node = this.props.node;
    if (this.currentPortalNode && node !== this.currentPortalNode) {
      this.currentPortalNode.unmount(this.placeholderNode.current);
      this.currentPortalNode.setPortalProps({});
      this.currentPortalNode = node;
    }
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentWillUnmount = function() {
    var node = this.props.node;
    node.unmount(this.placeholderNode.current);
    node.setPortalProps({});
  };
  OutPortal2.prototype.render = function() {
    return h("div", { ref: this.placeholderNode });
  };
  return OutPortal2;
}(PureComponent);
var createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);
var createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);
init_react_preact();
init_define_process();
var import_react2 = __toESM(require_emotion_react_cjs(), 1);
init_define_process();
init_react_preact();
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var ErrorBoundary = class extends react_preact_default.Component {
  constructor(props) {
    super(props);
    this.state = { error: null, errorInfo: null };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
  }
  render() {
    if (this.state.errorInfo) {
      return (0, import_jsx_runtime.jsxs)("div", {
        children: [
          (0, import_jsx_runtime.jsx)("h2", {
            children: "Something went wrong."
          }),
          (0, import_jsx_runtime.jsxs)("details", {
            style: { whiteSpace: "pre-wrap" },
            children: [
              this.state.error && this.state.error.toString(),
              (0, import_jsx_runtime.jsx)("br", {}),
              this.state.errorInfo.componentStack
            ]
          })
        ]
      });
    }
    return this.props.children;
  }
};
__name(ErrorBoundary, "ErrorBoundary");
var ErrorBoundary_default = ErrorBoundary;
init_define_process();
function md5(inputString) {
  var hc = "0123456789abcdef";
  function rh(n3) {
    var j4, s4 = "";
    for (j4 = 0; j4 <= 3; j4++) {
      s4 += hc.charAt(n3 >> j4 * 8 + 4 & 15) + hc.charAt(n3 >> j4 * 8 & 15);
    }
    return s4;
  }
  __name(rh, "rh");
  function ad(x22, y4) {
    var l4 = (x22 & 65535) + (y4 & 65535);
    var m22 = (x22 >> 16) + (y4 >> 16) + (l4 >> 16);
    return m22 << 16 | l4 & 65535;
  }
  __name(ad, "ad");
  function rl(n3, c22) {
    return n3 << c22 | n3 >>> 32 - c22;
  }
  __name(rl, "rl");
  function cm(q4, a22, b22, x22, s4, t3) {
    return ad(rl(ad(ad(a22, q4), ad(x22, t3)), s4), b22);
  }
  __name(cm, "cm");
  function ff(a22, b22, c22, d22, x22, s4, t3) {
    return cm(b22 & c22 | ~b22 & d22, a22, b22, x22, s4, t3);
  }
  __name(ff, "ff");
  function gg(a22, b22, c22, d22, x22, s4, t3) {
    return cm(b22 & d22 | c22 & ~d22, a22, b22, x22, s4, t3);
  }
  __name(gg, "gg");
  function hh(a22, b22, c22, d22, x22, s4, t3) {
    return cm(b22 ^ c22 ^ d22, a22, b22, x22, s4, t3);
  }
  __name(hh, "hh");
  function ii(a22, b22, c22, d22, x22, s4, t3) {
    return cm(c22 ^ (b22 | ~d22), a22, b22, x22, s4, t3);
  }
  __name(ii, "ii");
  function sb(x22) {
    var i22;
    var nblk = (x22.length + 8 >> 6) + 1;
    var blks = new Array(nblk * 16);
    for (i22 = 0; i22 < nblk * 16; i22++)
      blks[i22] = 0;
    for (i22 = 0; i22 < x22.length; i22++) {
      blks[i22 >> 2] |= x22.charCodeAt(i22) << i22 % 4 * 8;
    }
    blks[i22 >> 2] |= 128 << i22 % 4 * 8;
    blks[nblk * 16 - 2] = x22.length * 8;
    return blks;
  }
  __name(sb, "sb");
  var i4, x5 = sb(inputString), a5 = 1732584193, b5 = -271733879, c5 = -1732584194, d4 = 271733878, olda, oldb, oldc, oldd;
  for (i4 = 0; i4 < x5.length; i4 += 16) {
    olda = a5;
    oldb = b5;
    oldc = c5;
    oldd = d4;
    a5 = ff(a5, b5, c5, d4, x5[i4 + 0], 7, -680876936);
    d4 = ff(d4, a5, b5, c5, x5[i4 + 1], 12, -389564586);
    c5 = ff(c5, d4, a5, b5, x5[i4 + 2], 17, 606105819);
    b5 = ff(b5, c5, d4, a5, x5[i4 + 3], 22, -1044525330);
    a5 = ff(a5, b5, c5, d4, x5[i4 + 4], 7, -176418897);
    d4 = ff(d4, a5, b5, c5, x5[i4 + 5], 12, 1200080426);
    c5 = ff(c5, d4, a5, b5, x5[i4 + 6], 17, -1473231341);
    b5 = ff(b5, c5, d4, a5, x5[i4 + 7], 22, -45705983);
    a5 = ff(a5, b5, c5, d4, x5[i4 + 8], 7, 1770035416);
    d4 = ff(d4, a5, b5, c5, x5[i4 + 9], 12, -1958414417);
    c5 = ff(c5, d4, a5, b5, x5[i4 + 10], 17, -42063);
    b5 = ff(b5, c5, d4, a5, x5[i4 + 11], 22, -1990404162);
    a5 = ff(a5, b5, c5, d4, x5[i4 + 12], 7, 1804603682);
    d4 = ff(d4, a5, b5, c5, x5[i4 + 13], 12, -40341101);
    c5 = ff(c5, d4, a5, b5, x5[i4 + 14], 17, -1502002290);
    b5 = ff(b5, c5, d4, a5, x5[i4 + 15], 22, 1236535329);
    a5 = gg(a5, b5, c5, d4, x5[i4 + 1], 5, -165796510);
    d4 = gg(d4, a5, b5, c5, x5[i4 + 6], 9, -1069501632);
    c5 = gg(c5, d4, a5, b5, x5[i4 + 11], 14, 643717713);
    b5 = gg(b5, c5, d4, a5, x5[i4 + 0], 20, -373897302);
    a5 = gg(a5, b5, c5, d4, x5[i4 + 5], 5, -701558691);
    d4 = gg(d4, a5, b5, c5, x5[i4 + 10], 9, 38016083);
    c5 = gg(c5, d4, a5, b5, x5[i4 + 15], 14, -660478335);
    b5 = gg(b5, c5, d4, a5, x5[i4 + 4], 20, -405537848);
    a5 = gg(a5, b5, c5, d4, x5[i4 + 9], 5, 568446438);
    d4 = gg(d4, a5, b5, c5, x5[i4 + 14], 9, -1019803690);
    c5 = gg(c5, d4, a5, b5, x5[i4 + 3], 14, -187363961);
    b5 = gg(b5, c5, d4, a5, x5[i4 + 8], 20, 1163531501);
    a5 = gg(a5, b5, c5, d4, x5[i4 + 13], 5, -1444681467);
    d4 = gg(d4, a5, b5, c5, x5[i4 + 2], 9, -51403784);
    c5 = gg(c5, d4, a5, b5, x5[i4 + 7], 14, 1735328473);
    b5 = gg(b5, c5, d4, a5, x5[i4 + 12], 20, -1926607734);
    a5 = hh(a5, b5, c5, d4, x5[i4 + 5], 4, -378558);
    d4 = hh(d4, a5, b5, c5, x5[i4 + 8], 11, -2022574463);
    c5 = hh(c5, d4, a5, b5, x5[i4 + 11], 16, 1839030562);
    b5 = hh(b5, c5, d4, a5, x5[i4 + 14], 23, -35309556);
    a5 = hh(a5, b5, c5, d4, x5[i4 + 1], 4, -1530992060);
    d4 = hh(d4, a5, b5, c5, x5[i4 + 4], 11, 1272893353);
    c5 = hh(c5, d4, a5, b5, x5[i4 + 7], 16, -155497632);
    b5 = hh(b5, c5, d4, a5, x5[i4 + 10], 23, -1094730640);
    a5 = hh(a5, b5, c5, d4, x5[i4 + 13], 4, 681279174);
    d4 = hh(d4, a5, b5, c5, x5[i4 + 0], 11, -358537222);
    c5 = hh(c5, d4, a5, b5, x5[i4 + 3], 16, -722521979);
    b5 = hh(b5, c5, d4, a5, x5[i4 + 6], 23, 76029189);
    a5 = hh(a5, b5, c5, d4, x5[i4 + 9], 4, -640364487);
    d4 = hh(d4, a5, b5, c5, x5[i4 + 12], 11, -421815835);
    c5 = hh(c5, d4, a5, b5, x5[i4 + 15], 16, 530742520);
    b5 = hh(b5, c5, d4, a5, x5[i4 + 2], 23, -995338651);
    a5 = ii(a5, b5, c5, d4, x5[i4 + 0], 6, -198630844);
    d4 = ii(d4, a5, b5, c5, x5[i4 + 7], 10, 1126891415);
    c5 = ii(c5, d4, a5, b5, x5[i4 + 14], 15, -1416354905);
    b5 = ii(b5, c5, d4, a5, x5[i4 + 5], 21, -57434055);
    a5 = ii(a5, b5, c5, d4, x5[i4 + 12], 6, 1700485571);
    d4 = ii(d4, a5, b5, c5, x5[i4 + 3], 10, -1894986606);
    c5 = ii(c5, d4, a5, b5, x5[i4 + 10], 15, -1051523);
    b5 = ii(b5, c5, d4, a5, x5[i4 + 1], 21, -2054922799);
    a5 = ii(a5, b5, c5, d4, x5[i4 + 8], 6, 1873313359);
    d4 = ii(d4, a5, b5, c5, x5[i4 + 15], 10, -30611744);
    c5 = ii(c5, d4, a5, b5, x5[i4 + 6], 15, -1560198380);
    b5 = ii(b5, c5, d4, a5, x5[i4 + 13], 21, 1309151649);
    a5 = ii(a5, b5, c5, d4, x5[i4 + 4], 6, -145523070);
    d4 = ii(d4, a5, b5, c5, x5[i4 + 11], 10, -1120210379);
    c5 = ii(c5, d4, a5, b5, x5[i4 + 2], 15, 718787259);
    b5 = ii(b5, c5, d4, a5, x5[i4 + 9], 21, -343485551);
    a5 = ad(a5, olda);
    b5 = ad(b5, oldb);
    c5 = ad(c5, oldc);
    d4 = ad(d4, oldd);
  }
  return rh(a5) + rh(b5) + rh(c5) + rh(d4);
}
__name(md5, "md5");
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var apps = {};
var AutoUpdateApp = __name(({ hash: hash32 }) => {
  const transpiled = mST().transpiled;
  const App = apps[md5(transpiled)];
  return (0, import_jsx_runtime.jsx)(ErrorBoundary_default, {
    children: (0, import_jsx_runtime.jsx)(App, {})
  }, hash32);
}, "AutoUpdateApp");
async function appFactory(transpiled = "") {
  const trp = transpiled.length ? transpiled : mST().transpiled;
  const hash32 = md5(trp);
  if (!apps[hash32]) {
    try {
      apps[hash32] = (await import(createJsBlob(trp))).default;
    } catch (err) {
      if (err instanceof SyntaxError) {
        const name = err.name;
        const message = err.message;
        const cause = err.cause;
        const stack = err.stack;
        apps[hash32] = () => (0, import_jsx_runtime.jsxs)("div", {
          css: import_react2.css`
        background-color: orange;
        `,
          children: [
            (0, import_jsx_runtime.jsx)("h1", {
              children: "Syntax Error"
            }),
            (0, import_jsx_runtime.jsxs)("h2", {
              children: [
                name,
                ": ",
                message
              ]
            }),
            (0, import_jsx_runtime.jsx)("p", {
              children: JSON.stringify({ err })
            })
          ]
        });
      } else if (err instanceof Error) {
        const name = err.name;
        const message = err.message;
        apps[hash32] = () => (0, import_jsx_runtime.jsxs)("div", {
          css: import_react2.css`
        background-color: orange;
        `,
          children: [
            (0, import_jsx_runtime.jsx)("h1", {
              children: "Syntax Error"
            }),
            (0, import_jsx_runtime.jsxs)("h2", {
              children: [
                name,
                ": ",
                message
              ]
            }),
            (0, import_jsx_runtime.jsx)("p", {
              children: JSON.stringify({ err })
            })
          ]
        });
      } else {
        apps[hash32] = () => (0, import_jsx_runtime.jsx)("div", {
          css: import_react2.css`
        background-color: orange;
      `,
          children: (0, import_jsx_runtime.jsxs)("h1", {
            children: [
              "Unknown Error: $",
              hash32
            ]
          })
        });
      }
    }
  }
  return apps[hash32];
}
__name(appFactory, "appFactory");
function createJsBlob(code) {
  const file = new File([code], "index.mjs", {
    type: "application/javascript"
  });
  const blobUrl = URL.createObjectURL(file);
  return blobUrl;
}
__name(createJsBlob, "createJsBlob");
var import_react26 = __toESM(require_emotion_react_cjs(), 1);
init_define_process();
var import_react20 = __toESM(require_emotion_react_cjs(), 1);
init_react_preact();
init_define_process();
var import_react18 = __toESM(require_emotion_react_cjs(), 1);
init_react_preact();
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
var import_qrious = __toESM(require_qrious(), 1);
init_react_preact();
var useQrious = __name((options) => {
  const [qrious] = useState(() => new import_qrious.default(options));
  const [dataUrl, setDataUrl] = useState(() => qrious.toDataURL(options.mime));
  useEffect(() => {
    qrious.set(options);
    setDataUrl(qrious.toDataURL(options.mime));
  }, [options, qrious]);
  return [dataUrl, qrious];
}, "useQrious");
var QRious2 = __name((_a) => {
  var { background, backgroundAlpha, foreground, foregroundAlpha, level, mime, padding: padding2, value, size } = _a, props = __rest(_a, ["background", "backgroundAlpha", "foreground", "foregroundAlpha", "level", "mime", "padding", "value", "size"]);
  const [dataUrl] = useQrious({
    background,
    backgroundAlpha,
    foreground,
    foregroundAlpha,
    level,
    mime,
    padding: padding2,
    size,
    value
  });
  return h("img", Object.assign(Object.assign({}, props), { src: dataUrl }));
}, "QRious");
init_define_process();
init_define_process();
init_define_process();
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
init_define_process();
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
init_react_preact();
var import_prop_types51 = __toESM(require_prop_types());
init_define_process();
function r4(e22) {
  var t3, f4, n3 = "";
  if ("string" == typeof e22 || "number" == typeof e22)
    n3 += e22;
  else if ("object" == typeof e22)
    if (Array.isArray(e22))
      for (t3 = 0; t3 < e22.length; t3++)
        e22[t3] && (f4 = r4(e22[t3])) && (n3 && (n3 += " "), n3 += f4);
    else
      for (t3 in e22)
        e22[t3] && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
__name(r4, "r");
function clsx() {
  for (var e22, t3, f4 = 0, n3 = ""; f4 < arguments.length; )
    (e22 = arguments[f4++]) && (t3 = r4(e22)) && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
__name(clsx, "clsx");
var clsx_m_default = clsx;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function isHostComponent(element) {
  return typeof element === "string";
}
__name(isHostComponent, "isHostComponent");
var isHostComponent_default = isHostComponent;
function appendOwnerState(elementType, otherProps = {}, ownerState) {
  if (isHostComponent_default(elementType)) {
    return otherProps;
  }
  return _extends({}, otherProps, {
    ownerState: _extends({}, otherProps.ownerState, ownerState)
  });
}
__name(appendOwnerState, "appendOwnerState");
init_define_process();
function areArraysEqual(array1, array2, itemComparer = (a5, b5) => a5 === b5) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}
__name(areArraysEqual, "areArraysEqual");
init_define_process();
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(extractEventHandlers, "extractEventHandlers");
init_define_process();
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState);
  }
  return componentProps;
}
__name(resolveComponentProps, "resolveComponentProps");
init_define_process();
init_define_process();
init_define_process();
function chainPropTypes(propType1, propType2) {
  if (true) {
    return () => null;
  }
  return __name(function validate2(...args) {
    return propType1(...args) || propType2(...args);
  }, "validate");
}
__name(chainPropTypes, "chainPropTypes");
init_define_process();
function isPlainObject2(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
__name(isPlainObject2, "isPlainObject");
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends({}, target) : target;
  if (isPlainObject2(target) && isPlainObject2(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isPlainObject2(source[key]) && key in target && isPlainObject2(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
__name(deepmerge, "deepmerge");
init_define_process();
var import_prop_types = __toESM(require_prop_types());
function isClassComponent(elementType) {
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
__name(isClassComponent, "isClassComponent");
function acceptingRef(props, propName, componentName, location2, propFullName) {
  const element = props[propName];
  const safePropName = propFullName || propName;
  if (element == null || typeof window === "undefined") {
    return null;
  }
  let warningHint;
  const elementType = element.type;
  if (typeof elementType === "function" && !isClassComponent(elementType)) {
    warningHint = "Did you accidentally use a plain function component for an element instead?";
  }
  if (warningHint !== void 0) {
    return new Error(`Invalid ${location2} \`${safePropName}\` supplied to \`${componentName}\`. Expected an element that can hold a ref. ${warningHint} For more information see https://mui.com/r/caveat-with-refs-guide`);
  }
  return null;
}
__name(acceptingRef, "acceptingRef");
var elementAcceptingRef = chainPropTypes(import_prop_types.default.element, acceptingRef);
elementAcceptingRef.isRequired = chainPropTypes(import_prop_types.default.element.isRequired, acceptingRef);
init_define_process();
var import_prop_types2 = __toESM(require_prop_types());
function isClassComponent2(elementType) {
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
__name(isClassComponent2, "isClassComponent");
function elementTypeAcceptingRef(props, propName, componentName, location2, propFullName) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null || typeof window === "undefined") {
    return null;
  }
  let warningHint;
  if (typeof propValue === "function" && !isClassComponent2(propValue)) {
    warningHint = "Did you accidentally provide a plain function component instead?";
  }
  if (warningHint !== void 0) {
    return new Error(`Invalid ${location2} \`${safePropName}\` supplied to \`${componentName}\`. Expected an element type that can hold a ref. ${warningHint} For more information see https://mui.com/r/caveat-with-refs-guide`);
  }
  return null;
}
__name(elementTypeAcceptingRef, "elementTypeAcceptingRef");
var elementTypeAcceptingRef_default = chainPropTypes(import_prop_types2.default.elementType, elementTypeAcceptingRef);
init_define_process();
init_define_process();
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i4 = 1; i4 < arguments.length; i4 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i4]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
__name(formatMuiErrorMessage, "formatMuiErrorMessage");
init_define_process();
var import_react_is = __toESM(require_react_is2());
init_define_process();
init_define_process();
var ponyfillGlobal_default = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
init_define_process();
var import_prop_types3 = __toESM(require_prop_types());
var refType = import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object]);
init_define_process();
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(false ? `MUI: \`capitalize(string)\` expects a string argument.` : formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
__name(capitalize, "capitalize");
init_define_process();
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return __name(function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    }, "chainedFunction");
  }, () => {
  });
}
__name(createChainedFunction, "createChainedFunction");
init_define_process();
function debounce(func, wait = 166) {
  let timeout2;
  function debounced(...args) {
    const later = __name(() => {
      func.apply(this, args);
    }, "later");
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  }
  __name(debounced, "debounced");
  debounced.clear = () => {
    clearTimeout(timeout2);
  };
  return debounced;
}
__name(debounce, "debounce");
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
__name(ownerDocument, "ownerDocument");
init_define_process();
function ownerWindow(node) {
  const doc = ownerDocument(node);
  return doc.defaultView || window;
}
__name(ownerWindow, "ownerWindow");
init_define_process();
init_define_process();
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
__name(setRef, "setRef");
init_define_process();
init_react_preact();
var useEnhancedEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
var useEnhancedEffect_default = useEnhancedEffect;
init_define_process();
init_react_preact();
var globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = useState(idOverride);
  const id3 = idOverride || defaultId;
  useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id3;
}
__name(useGlobalId, "useGlobalId");
var maybeReactUseId = useId;
function useId2(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
__name(useId2, "useId");
init_define_process();
init_define_process();
init_react_preact();
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = useRef(controlled !== void 0);
  const [valueState, setValue] = useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  if (false) {
    useEffect(() => {
      if (isControlled !== (controlled !== void 0)) {
        console.error([`MUI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join("\n"));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = useRef(defaultProp);
    useEffect(() => {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. To suppress this warning opt to use a controlled ${name}.`].join("\n"));
      }
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
__name(useControlled, "useControlled");
init_define_process();
init_react_preact();
function useEventCallback(fn2) {
  const ref = useRef(fn2);
  useEnhancedEffect_default(() => {
    ref.current = fn2;
  });
  return useCallback((...args) => (0, ref.current)(...args), []);
}
__name(useEventCallback, "useEventCallback");
init_define_process();
init_react_preact();
function useForkRef(refA, refB) {
  return useMemo(() => {
    if (refA == null && refB == null) {
      return null;
    }
    return (refValue) => {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
__name(useForkRef, "useForkRef");
init_define_process();
init_react_preact();
var hadKeyboardEvent = true;
var hadFocusVisibleRecently = false;
var hadFocusVisibleRecentlyTimeout;
var inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node) {
  const {
    type,
    tagName
  } = node;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node.readOnly) {
    return true;
  }
  if (node.isContentEditable) {
    return true;
  }
  return false;
}
__name(focusTriggersKeyboardModality, "focusTriggersKeyboardModality");
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
__name(handleKeyDown, "handleKeyDown");
function handlePointerDown() {
  hadKeyboardEvent = false;
}
__name(handlePointerDown, "handlePointerDown");
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
__name(handleVisibilityChange, "handleVisibilityChange");
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
__name(prepare, "prepare");
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
__name(isFocusVisible, "isFocusVisible");
function useIsFocusVisible() {
  const ref = useCallback((node) => {
    if (node != null) {
      prepare(node.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  __name(handleBlurVisible, "handleBlurVisible");
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  __name(handleFocusVisible, "handleFocusVisible");
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
__name(useIsFocusVisible, "useIsFocusVisible");
init_define_process();
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
__name(getScrollbarSize, "getScrollbarSize");
init_define_process();
init_define_process();
init_react_preact();
var usePreviousProps = __name((value) => {
  const ref = useRef({});
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}, "usePreviousProps");
var usePreviousProps_default = usePreviousProps;
init_define_process();
var visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: -1,
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
var visuallyHidden_default = visuallyHidden;
init_define_process();
function getTypeByValue(value) {
  const valueType = typeof value;
  switch (valueType) {
    case "number":
      if (Number.isNaN(value)) {
        return "NaN";
      }
      if (!Number.isFinite(value)) {
        return "Infinity";
      }
      if (value !== Math.floor(value)) {
        return "float";
      }
      return "number";
    case "object":
      if (value === null) {
        return "null";
      }
      return value.constructor.name;
    default:
      return valueType;
  }
}
__name(getTypeByValue, "getTypeByValue");
function ponyfillIsInteger(x5) {
  return typeof x5 === "number" && isFinite(x5) && Math.floor(x5) === x5;
}
__name(ponyfillIsInteger, "ponyfillIsInteger");
var isInteger = Number.isInteger || ponyfillIsInteger;
function requiredInteger(props, propName, componentName, location2) {
  const propValue = props[propName];
  if (propValue == null || !isInteger(propValue)) {
    const propType = getTypeByValue(propValue);
    return new RangeError(`Invalid ${location2} \`${propName}\` of type \`${propType}\` supplied to \`${componentName}\`, expected \`integer\`.`);
  }
  return null;
}
__name(requiredInteger, "requiredInteger");
function validator(props, propName, ...other) {
  const propValue = props[propName];
  if (propValue === void 0) {
    return null;
  }
  return requiredInteger(props, propName, ...other);
}
__name(validator, "validator");
function validatorNoop() {
  return null;
}
__name(validatorNoop, "validatorNoop");
validator.isRequired = requiredInteger;
validatorNoop.isRequired = validatorNoop;
init_define_process();
function resolveProps(defaultProps2, props) {
  const output = _extends({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
__name(resolveProps, "resolveProps");
init_define_process();
init_define_process();
function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach(
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          acc.push(getUtilityClass(key));
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
__name(composeClasses, "composeClasses");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var defaultGenerator = __name((componentName) => componentName, "defaultGenerator");
var createClassNameGenerator = __name(() => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
}, "createClassNameGenerator");
var ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator_default = ClassNameGenerator;
var globalStateClassesMapping = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}
__name(generateUtilityClass, "generateUtilityClass");
init_define_process();
init_define_process();
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
__name(generateUtilityClasses, "generateUtilityClasses");
init_define_process();
init_define_process();
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
__name(omitEventHandlers, "omitEventHandlers");
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx_m_default(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx_m_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
__name(mergeSlotProps, "mergeSlotProps");
var _excluded = ["elementType", "externalSlotProps", "ownerState"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState
  } = parameters, rest2 = _objectWithoutPropertiesLoose(parameters, _excluded);
  const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends({}, rest2, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, useForkRef(resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref));
  const props = appendOwnerState(elementType, _extends({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
__name(useSlotProps, "useSlotProps");
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
__name(stripDiacritics, "stripDiacritics");
function createFilterOptions(config = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim = false
  } = config;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
__name(createFilterOptions, "createFilterOptions");
var defaultFilterOptions = createFilterOptions();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types4 = __toESM(require_prop_types());
init_define_process();
init_define_process();
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps_default({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max: max22 = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max22 ? `${max22}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max: max22,
    displayValue
  };
}
__name(useBadge, "useBadge");
init_define_process();
init_define_process();
init_define_process();
function getBadgeUnstyledUtilityClass(slot) {
  return generateUtilityClass("BaseBadge", slot);
}
__name(getBadgeUnstyledUtilityClass, "getBadgeUnstyledUtilityClass");
var badgeUnstyledClasses = generateUtilityClasses("BaseBadge", ["root", "badge", "invisible"]);
init_react_preact();
init_react_preact();
var _excluded2 = ["badgeContent", "component", "children", "components", "componentsProps", "invisible", "max", "showZero"];
var useUtilityClasses = __name((ownerState) => {
  const {
    invisible
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", invisible && "invisible"]
  };
  return composeClasses(slots, getBadgeUnstyledUtilityClass, void 0);
}, "useUtilityClasses");
var BadgeUnstyled = forwardRef(__name(function BadgeUnstyled2(props, ref) {
  const {
    component,
    children: children2,
    components = {},
    componentsProps = {},
    max: maxProp = 99,
    showZero = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const {
    badgeContent,
    max: max22,
    displayValue,
    invisible
  } = useBadge(_extends({}, props, {
    max: maxProp
  }));
  const ownerState = _extends({}, props, {
    badgeContent,
    invisible,
    max: max22,
    showZero
  });
  const classes = useUtilityClasses(ownerState);
  const Root = component || components.Root || "span";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref
    },
    ownerState,
    className: classes.root
  });
  const Badge = components.Badge || "span";
  const badgeProps = useSlotProps({
    elementType: Badge,
    externalSlotProps: componentsProps.badge,
    ownerState,
    className: classes.badge
  });
  return e3(Root, _extends({}, rootProps, {
    children: [children2, e3(Badge, _extends({}, badgeProps, {
      children: displayValue
    }))]
  }));
}, "BadgeUnstyled"));
false ? BadgeUnstyled.propTypes = {
  badgeContent: import_prop_types4.default.node,
  children: import_prop_types4.default.node,
  component: import_prop_types4.default.elementType,
  components: import_prop_types4.default.shape({
    Badge: import_prop_types4.default.elementType,
    Root: import_prop_types4.default.elementType
  }),
  componentsProps: import_prop_types4.default.shape({
    badge: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
    root: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object])
  }),
  invisible: import_prop_types4.default.bool,
  max: import_prop_types4.default.number,
  showZero: import_prop_types4.default.bool
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types5 = __toESM(require_prop_types());
init_define_process();
function getButtonUnstyledUtilityClass(slot) {
  return generateUtilityClass("ButtonUnstyled", slot);
}
__name(getButtonUnstyledUtilityClass, "getButtonUnstyledUtilityClass");
var buttonUnstyledClasses = generateUtilityClasses("ButtonUnstyled", ["root", "active", "disabled", "focusVisible"]);
init_define_process();
init_react_preact();
function useButton(parameters) {
  const {
    disabled = false,
    focusableWhenDisabled,
    href,
    ref,
    tabIndex,
    to,
    type
  } = parameters;
  const buttonRef = useRef();
  const [active, setActive] = useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = useState(false);
  if (disabled && !focusableWhenDisabled && focusVisible) {
    setFocusVisible(false);
  }
  useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const [hostElementName, setHostElementName] = useState("");
  const createHandleMouseLeave = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    if (focusVisible) {
      event.preventDefault();
    }
    (_otherHandlers$onMous = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
  }, "createHandleMouseLeave");
  const createHandleBlur = __name((otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  }, "createHandleBlur");
  const createHandleFocus = __name((otherHandlers) => (event) => {
    var _otherHandlers$onFocu2;
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      var _otherHandlers$onFocu;
      setFocusVisible(true);
      (_otherHandlers$onFocu = otherHandlers.onFocusVisible) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    }
    (_otherHandlers$onFocu2 = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu2.call(otherHandlers, event);
  }, "createHandleFocus");
  const isNativeButton = __name(() => {
    const button = buttonRef.current;
    return hostElementName === "BUTTON" || hostElementName === "INPUT" && ["button", "submit", "reset"].includes(button == null ? void 0 : button.type) || hostElementName === "A" && (button == null ? void 0 : button.href);
  }, "isNativeButton");
  const createHandleClick = __name((otherHandlers) => (event) => {
    if (!disabled) {
      var _otherHandlers$onClic;
      (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    }
  }, "createHandleClick");
  const createHandleMouseDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    if (event.target === event.currentTarget && !disabled) {
      setActive(true);
    }
    (_otherHandlers$onMous2 = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
  }, "createHandleMouseDown");
  const createHandleMouseUp = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onMous3 = otherHandlers.onMouseUp) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
  }, "createHandleMouseUp");
  const createHandleKeyDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (event.target === event.currentTarget && event.key === " " && !disabled) {
      setActive(true);
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === "Enter" && !disabled) {
      var _otherHandlers$onClic2;
      (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
      event.preventDefault();
    }
  }, "createHandleKeyDown");
  const createHandleKeyUp = __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.target === event.currentTarget && !isNativeButton() && !disabled && event.key === " " && !event.defaultPrevented) {
      var _otherHandlers$onClic3;
      (_otherHandlers$onClic3 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic3.call(otherHandlers, event);
    }
  }, "createHandleKeyUp");
  const handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
  const handleRef = useForkRef(ref, handleOwnRef);
  const updateRef = __name((instance) => {
    var _instance$tagName;
    setHostElementName((_instance$tagName = instance == null ? void 0 : instance.tagName) != null ? _instance$tagName : "");
    setRef(handleRef, instance);
  }, "updateRef");
  const buttonProps = {};
  if (hostElementName === "BUTTON") {
    buttonProps.type = type != null ? type : "button";
    if (focusableWhenDisabled) {
      buttonProps["aria-disabled"] = disabled;
    } else {
      buttonProps.disabled = disabled;
    }
  } else if (hostElementName !== "") {
    if (!href && !to) {
      buttonProps.role = "button";
      buttonProps.tabIndex = tabIndex != null ? tabIndex : 0;
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
      buttonProps.tabIndex = focusableWhenDisabled ? tabIndex != null ? tabIndex : 0 : -1;
    }
  }
  const getRootProps = __name((otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
    delete externalEventHandlers.onFocusVisible;
    return _extends({
      type
    }, externalEventHandlers, buttonProps, {
      onBlur: createHandleBlur(externalEventHandlers),
      onClick: createHandleClick(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      onKeyUp: createHandleKeyUp(externalEventHandlers),
      onMouseDown: createHandleMouseDown(externalEventHandlers),
      onMouseLeave: createHandleMouseLeave(externalEventHandlers),
      onMouseUp: createHandleMouseUp(externalEventHandlers),
      ref: updateRef
    });
  }, "getRootProps");
  return {
    getRootProps,
    focusVisible,
    setFocusVisible,
    disabled,
    active
  };
}
__name(useButton, "useButton");
init_react_preact();
var _excluded3 = ["action", "children", "component", "components", "componentsProps", "disabled", "focusableWhenDisabled", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseLeave"];
var useUtilityClasses2 = __name((ownerState) => {
  const {
    active,
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active"]
  };
  return composeClasses(slots, getButtonUnstyledUtilityClass, {});
}, "useUtilityClasses");
var ButtonUnstyled = forwardRef(__name(function ButtonUnstyled2(props, forwardedRef) {
  var _ref;
  const {
    action,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    focusableWhenDisabled = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  const buttonRef = useRef();
  const {
    active,
    focusVisible,
    setFocusVisible,
    getRootProps
  } = useButton(_extends({}, props, {
    focusableWhenDisabled
  }));
  useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), [setFocusVisible]);
  const ownerState = _extends({}, props, {
    active,
    focusableWhenDisabled,
    focusVisible
  });
  const classes = useUtilityClasses2(ownerState);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    externalSlotProps: componentsProps.root,
    additionalProps: {
      ref: forwardedRef
    },
    ownerState,
    className: classes.root
  });
  return e3(Root, _extends({}, rootProps, {
    children: children2
  }));
}, "ButtonUnstyled"));
false ? ButtonUnstyled.propTypes = {
  action: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.shape({
    current: import_prop_types5.default.shape({
      focusVisible: import_prop_types5.default.func.isRequired
    })
  })]),
  children: import_prop_types5.default.node,
  component: import_prop_types5.default.elementType,
  components: import_prop_types5.default.shape({
    Root: import_prop_types5.default.elementType
  }),
  componentsProps: import_prop_types5.default.shape({
    root: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object])
  }),
  disabled: import_prop_types5.default.bool,
  focusableWhenDisabled: import_prop_types5.default.bool,
  onBlur: import_prop_types5.default.func,
  onClick: import_prop_types5.default.func,
  onFocus: import_prop_types5.default.func,
  onFocusVisible: import_prop_types5.default.func,
  onKeyDown: import_prop_types5.default.func,
  onKeyUp: import_prop_types5.default.func,
  onMouseLeave: import_prop_types5.default.func
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types6 = __toESM(require_prop_types());
init_react_preact();
false ? ClickAwayListener.propTypes = {
  children: elementAcceptingRef_default.isRequired,
  disableReactTree: import_prop_types6.default.bool,
  mouseEvent: import_prop_types6.default.oneOf(["onClick", "onMouseDown", "onMouseUp", "onPointerDown", "onPointerUp", false]),
  onClickAway: import_prop_types6.default.func.isRequired,
  touchEvent: import_prop_types6.default.oneOf(["onTouchEnd", "onTouchStart", false])
} : void 0;
if (false) {
  ClickAwayListener["propTypes"] = exactProp(ClickAwayListener.propTypes);
}
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types7 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
var FormControlUnstyledContext = createContext(void 0);
if (false) {
  FormControlUnstyledContext.displayName = "FormControlUnstyledContext";
}
var FormControlUnstyledContext_default = FormControlUnstyledContext;
init_define_process();
function getFormControlUnstyledUtilityClass(slot) {
  return generateUtilityClass("BaseFormControl", slot);
}
__name(getFormControlUnstyledUtilityClass, "getFormControlUnstyledUtilityClass");
var formControlUnstyledClasses = generateUtilityClasses("BaseFormControl", ["root", "disabled", "error", "filled", "focused", "required"]);
init_react_preact();
var _excluded4 = ["defaultValue", "children", "component", "components", "componentsProps", "disabled", "error", "onChange", "required", "value"];
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0) && value !== "";
}
__name(hasValue, "hasValue");
function useUtilityClasses3(ownerState) {
  const {
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focused && "focused", error && "error", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormControlUnstyledUtilityClass, {});
}
__name(useUtilityClasses3, "useUtilityClasses");
var FormControlUnstyled = forwardRef(__name(function FormControlUnstyled2(props, ref) {
  var _ref;
  const {
    defaultValue,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    disabled = false,
    error = false,
    onChange,
    required = false,
    value: incomingValue
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const [value, setValue] = useControlled({
    controlled: incomingValue,
    default: defaultValue,
    name: "FormControl",
    state: "value"
  });
  const filled = hasValue(value);
  const [focused, setFocused] = useState(false);
  if (disabled && focused) {
    setFocused(false);
  }
  const ownerState = _extends({}, props, {
    disabled,
    error,
    filled,
    focused,
    required
  });
  const handleChange = __name((event) => {
    setValue(event.target.value);
    onChange == null ? void 0 : onChange(event);
  }, "handleChange");
  const childContext = {
    disabled,
    error,
    filled,
    focused,
    onBlur: () => {
      setFocused(false);
    },
    onChange: handleChange,
    onFocus: () => {
      setFocused(true);
    },
    required,
    value: value != null ? value : ""
  };
  const classes = useUtilityClasses3(ownerState);
  const renderChildren = __name(() => {
    if (typeof children2 === "function") {
      return children2(childContext);
    }
    return children2;
  }, "renderChildren");
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      children: renderChildren()
    },
    ownerState,
    className: classes.root
  });
  return e3(FormControlUnstyledContext_default.Provider, {
    value: childContext,
    children: e3(Root, _extends({}, rootProps))
  });
}, "FormControlUnstyled"));
false ? FormControlUnstyled.propTypes = {
  children: import_prop_types7.default.oneOfType([import_prop_types7.default.node, import_prop_types7.default.func]),
  component: import_prop_types7.default.elementType,
  components: import_prop_types7.default.shape({
    Root: import_prop_types7.default.elementType
  }),
  componentsProps: import_prop_types7.default.shape({
    root: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object])
  }),
  defaultValue: import_prop_types7.default.any,
  disabled: import_prop_types7.default.bool,
  error: import_prop_types7.default.bool,
  onChange: import_prop_types7.default.func,
  required: import_prop_types7.default.bool,
  value: import_prop_types7.default.any
} : void 0;
init_define_process();
init_react_preact();
function useFormControlUnstyledContext() {
  return useContext(FormControlUnstyledContext_default);
}
__name(useFormControlUnstyledContext, "useFormControlUnstyledContext");
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types8 = __toESM(require_prop_types());
init_define_process();
var inputBaseClasses = generateUtilityClasses("MuiInput", ["root", "formControl", "focused", "disabled", "error", "multiline", "input", "inputMultiline", "inputTypeSearch", "adornedStart", "adornedEnd"]);
var inputUnstyledClasses_default = inputBaseClasses;
init_define_process();
init_react_preact();
function useInput(parameters) {
  const {
    defaultValue: defaultValueProp,
    disabled: disabledProp = false,
    error: errorProp = false,
    onBlur,
    onChange,
    onFocus,
    required: requiredProp = false,
    value: valueProp
  } = parameters;
  const formControlContext = useFormControlUnstyledContext();
  let defaultValue;
  let disabled;
  let error;
  let required;
  let value;
  if (formControlContext) {
    var _formControlContext$d, _formControlContext$e, _formControlContext$r;
    defaultValue = void 0;
    disabled = (_formControlContext$d = formControlContext.disabled) != null ? _formControlContext$d : false;
    error = (_formControlContext$e = formControlContext.error) != null ? _formControlContext$e : false;
    required = (_formControlContext$r = formControlContext.required) != null ? _formControlContext$r : false;
    value = formControlContext.value;
    if (false) {
      const definedLocalProps = ["defaultValue", "disabled", "error", "required", "value"].filter((prop) => parameters[prop] !== void 0);
      if (definedLocalProps.length > 0) {
        console.warn(["MUI: You have set props on an input that is inside a FormControlUnstyled.", "Set these props on a FormControlUnstyled instead. Otherwise they will be ignored.", `Ignored props: ${definedLocalProps.join(", ")}`].join("\n"));
      }
    }
  } else {
    defaultValue = defaultValueProp;
    disabled = disabledProp;
    error = errorProp;
    required = requiredProp;
    value = valueProp;
  }
  const {
    current: isControlled
  } = useRef(value != null);
  const handleInputRefWarning = useCallback((instance) => {
    if (false) {
      if (instance && instance.nodeName !== "INPUT" && !instance.focus) {
        console.error(["MUI: You have provided a `components.Input` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join("\n"));
      }
    }
  }, []);
  const inputRef = useRef(null);
  const handleInputRef = useForkRef(inputRef, handleInputRefWarning);
  const [focused, setFocused] = useState(false);
  useEffect(() => {
    if (!formControlContext && disabled && focused) {
      setFocused(false);
      onBlur == null ? void 0 : onBlur();
    }
  }, [formControlContext, disabled, focused, onBlur]);
  const handleFocus = __name((otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    if (formControlContext != null && formControlContext.disabled) {
      event.stopPropagation();
      return;
    }
    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    if (formControlContext && formControlContext.onFocus) {
      var _formControlContext$o;
      formControlContext == null ? void 0 : (_formControlContext$o = formControlContext.onFocus) == null ? void 0 : _formControlContext$o.call(formControlContext);
    } else {
      setFocused(true);
    }
  }, "handleFocus");
  const handleBlur2 = __name((otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
    if (formControlContext && formControlContext.onBlur) {
      formControlContext.onBlur();
    } else {
      setFocused(false);
    }
  }, "handleBlur");
  const handleChange = __name((otherHandlers) => (event, ...args) => {
    var _formControlContext$o2, _otherHandlers$onChan;
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(false ? `MUI: Expected valid input target. Did you use a custom \`components.Input\` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.` : formatMuiErrorMessage(17));
      }
    }
    formControlContext == null ? void 0 : (_formControlContext$o2 = formControlContext.onChange) == null ? void 0 : _formControlContext$o2.call(formControlContext, event);
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event, ...args);
  }, "handleChange");
  const handleClick = __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
  }, "handleClick");
  const getRootProps = __name((externalProps = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters, ["onBlur", "onChange", "onFocus"]);
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    return _extends({}, externalProps, externalEventHandlers, {
      onClick: handleClick(externalEventHandlers)
    });
  }, "getRootProps");
  const getInputProps = __name((externalProps = {}) => {
    const propsEventHandlers = {
      onBlur,
      onChange,
      onFocus
    };
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    const mergedEventHandlers = _extends({}, externalProps, externalEventHandlers, {
      onBlur: handleBlur2(externalEventHandlers),
      onChange: handleChange(externalEventHandlers),
      onFocus: handleFocus(externalEventHandlers)
    });
    return _extends({}, mergedEventHandlers, {
      "aria-invalid": error || void 0,
      defaultValue,
      ref: handleInputRef,
      value,
      required,
      disabled
    });
  }, "getInputProps");
  return {
    disabled,
    error,
    focused,
    formControlContext,
    getInputProps,
    getRootProps,
    required,
    value
  };
}
__name(useInput, "useInput");
init_react_preact();
init_react_preact();
var _excluded5 = ["aria-describedby", "aria-label", "aria-labelledby", "autoComplete", "autoFocus", "className", "component", "components", "componentsProps", "defaultValue", "disabled", "endAdornment", "error", "id", "maxRows", "minRows", "multiline", "name", "onClick", "onChange", "onKeyDown", "onKeyUp", "onFocus", "onBlur", "placeholder", "readOnly", "required", "rows", "type", "startAdornment", "value"];
var _excluded22 = ["ownerState"];
var InputUnstyled = forwardRef(__name(function InputUnstyled2(props, forwardedRef) {
  var _ref, _components$Input;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    autoComplete,
    autoFocus,
    className,
    component,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    endAdornment,
    error,
    id: id3,
    maxRows,
    minRows,
    multiline = false,
    name,
    onClick,
    onChange,
    onKeyDown,
    onKeyUp,
    onFocus,
    onBlur,
    placeholder,
    readOnly,
    required,
    rows,
    type = "text",
    startAdornment,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    getRootProps,
    getInputProps,
    focused,
    formControlContext,
    error: errorState,
    disabled: disabledState
  } = useInput({
    disabled,
    defaultValue,
    error,
    onBlur,
    onClick,
    onChange,
    onFocus,
    required,
    value
  });
  const ownerState = _extends({}, props, {
    disabled: disabledState,
    error: errorState,
    focused,
    formControlContext,
    multiline,
    type
  });
  const rootStateClasses = {
    [inputUnstyledClasses_default.disabled]: disabledState,
    [inputUnstyledClasses_default.error]: errorState,
    [inputUnstyledClasses_default.focused]: focused,
    [inputUnstyledClasses_default.formControl]: Boolean(formControlContext),
    [inputUnstyledClasses_default.multiline]: multiline,
    [inputUnstyledClasses_default.adornedStart]: Boolean(startAdornment),
    [inputUnstyledClasses_default.adornedEnd]: Boolean(endAdornment)
  };
  const inputStateClasses = {
    [inputUnstyledClasses_default.disabled]: disabledState,
    [inputUnstyledClasses_default.multiline]: multiline
  };
  const propsToForward = {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    autoComplete,
    autoFocus,
    id: id3,
    onKeyDown,
    onKeyUp,
    name,
    placeholder,
    readOnly,
    type
  };
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: forwardedRef
    },
    ownerState,
    className: [inputUnstyledClasses_default.root, rootStateClasses, className]
  });
  let Input = (_components$Input = components.Input) != null ? _components$Input : "input";
  let inputProps = useSlotProps({
    elementType: Input,
    getSlotProps: (otherHandlers) => getInputProps(_extends({}, otherHandlers, propsToForward)),
    externalSlotProps: componentsProps.input,
    ownerState,
    className: [inputUnstyledClasses_default.input, inputStateClasses]
  });
  if (multiline) {
    var _components$Textarea, _components$Textarea2;
    const hasHostTextarea = isHostComponent_default((_components$Textarea = components.Textarea) != null ? _components$Textarea : "textarea");
    const inputPropsWithoutOwnerState = _objectWithoutPropertiesLoose(inputProps, _excluded22);
    if (rows) {
      if (false) {
        if (minRows || maxRows) {
          console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set.");
        }
      }
    }
    inputProps = _extends({}, !hasHostTextarea && {
      minRows: rows || minRows,
      maxRows: rows || maxRows
    }, hasHostTextarea ? inputPropsWithoutOwnerState : inputProps, {
      type: void 0
    });
    Input = (_components$Textarea2 = components.Textarea) != null ? _components$Textarea2 : "textarea";
  }
  return e3(Root, _extends({}, rootProps, {
    children: [startAdornment, e3(Input, _extends({}, inputProps)), endAdornment]
  }));
}, "InputUnstyled"));
false ? InputUnstyled.propTypes = {
  "aria-describedby": import_prop_types8.default.string,
  "aria-label": import_prop_types8.default.string,
  "aria-labelledby": import_prop_types8.default.string,
  autoComplete: import_prop_types8.default.string,
  autoFocus: import_prop_types8.default.bool,
  children: import_prop_types8.default.node,
  className: import_prop_types8.default.string,
  component: import_prop_types8.default.elementType,
  components: import_prop_types8.default.shape({
    Input: import_prop_types8.default.elementType,
    Root: import_prop_types8.default.elementType,
    Textarea: import_prop_types8.default.elementType
  }),
  componentsProps: import_prop_types8.default.shape({
    input: import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object]),
    root: import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object])
  }),
  defaultValue: import_prop_types8.default.any,
  disabled: import_prop_types8.default.bool,
  endAdornment: import_prop_types8.default.node,
  error: import_prop_types8.default.bool,
  id: import_prop_types8.default.string,
  maxRows: import_prop_types8.default.number,
  minRows: import_prop_types8.default.number,
  multiline: import_prop_types8.default.bool,
  name: import_prop_types8.default.string,
  onBlur: import_prop_types8.default.func,
  onChange: import_prop_types8.default.func,
  onClick: import_prop_types8.default.func,
  onFocus: import_prop_types8.default.func,
  onKeyDown: import_prop_types8.default.func,
  onKeyUp: import_prop_types8.default.func,
  placeholder: import_prop_types8.default.string,
  readOnly: import_prop_types8.default.bool,
  required: import_prop_types8.default.bool,
  rows: import_prop_types8.default.number,
  startAdornment: import_prop_types8.default.node,
  type: import_prop_types8.default.oneOf(["button", "checkbox", "color", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]),
  value: import_prop_types8.default.any
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
var ActionTypes;
(function(ActionTypes2) {
  ActionTypes2["blur"] = "blur";
  ActionTypes2["focus"] = "focus";
  ActionTypes2["keyDown"] = "keyDown";
  ActionTypes2["optionClick"] = "optionClick";
  ActionTypes2["optionHover"] = "optionHover";
  ActionTypes2["optionsChange"] = "optionsChange";
  ActionTypes2["setValue"] = "setValue";
  ActionTypes2["setHighlight"] = "setHighlight";
  ActionTypes2["textNavigation"] = "textNagivation";
})(ActionTypes || (ActionTypes = {}));
init_define_process();
var pageSize = 5;
function findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {
  if (options.length === 0 || options.every((o5, i4) => isOptionDisabled(o5, i4))) {
    return -1;
  }
  let nextFocus = index;
  for (; ; ) {
    if (!wrapAround && lookupDirection === "next" && nextFocus === options.length || !wrapAround && lookupDirection === "previous" && nextFocus === -1) {
      return -1;
    }
    const nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);
    if (nextFocusDisabled) {
      nextFocus += lookupDirection === "next" ? 1 : -1;
      if (wrapAround) {
        nextFocus = (nextFocus + options.length) % options.length;
      }
    } else {
      return nextFocus;
    }
  }
}
__name(findValidOptionToHighlight, "findValidOptionToHighlight");
function getNewHighlightedOption(options, previouslyHighlightedOption, diff, lookupDirection, highlightDisabled, isOptionDisabled, wrapAround, optionComparer) {
  var _options$nextIndex;
  const maxIndex = options.length - 1;
  const defaultHighlightedIndex = -1;
  let nextIndexCandidate;
  const previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex((option) => optionComparer(option, previouslyHighlightedOption));
  if (diff === "reset") {
    var _options$defaultHighl;
    return defaultHighlightedIndex === -1 ? null : (_options$defaultHighl = options[defaultHighlightedIndex]) != null ? _options$defaultHighl : null;
  }
  if (diff === "start") {
    nextIndexCandidate = 0;
  } else if (diff === "end") {
    nextIndexCandidate = maxIndex;
  } else {
    const newIndex = previouslyHighlightedIndex + diff;
    if (newIndex < 0) {
      if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {
        nextIndexCandidate = 0;
      } else {
        nextIndexCandidate = maxIndex;
      }
    } else if (newIndex > maxIndex) {
      if (!wrapAround || Math.abs(diff) > 1) {
        nextIndexCandidate = maxIndex;
      } else {
        nextIndexCandidate = 0;
      }
    } else {
      nextIndexCandidate = newIndex;
    }
  }
  const nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabled, isOptionDisabled, wrapAround);
  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;
}
__name(getNewHighlightedOption, "getNewHighlightedOption");
function handleOptionSelection(option, state, props) {
  const {
    multiple,
    optionComparer = __name((o5, v5) => o5 === v5, "optionComparer"),
    isOptionDisabled = __name(() => false, "isOptionDisabled")
  } = props;
  const {
    selectedValue
  } = state;
  const optionIndex = props.options.findIndex((o5) => props.optionComparer(option, o5));
  if (isOptionDisabled(option, optionIndex)) {
    return state;
  }
  if (multiple) {
    var _ref, _ref2;
    const selectedValues = (_ref = selectedValue) != null ? _ref : [];
    const newSelectedValues = selectedValues.some((sv) => optionComparer(sv, option)) ? selectedValue.filter((v5) => !optionComparer(v5, option)) : [...(_ref2 = selectedValue) != null ? _ref2 : [], option];
    return {
      selectedValue: newSelectedValues,
      highlightedValue: option
    };
  }
  if (selectedValue != null && optionComparer(option, selectedValue)) {
    return state;
  }
  return {
    selectedValue: option,
    highlightedValue: option
  };
}
__name(handleOptionSelection, "handleOptionSelection");
function handleKeyDown2(event, state, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer
  } = props;
  const moveHighlight = __name((diff, direction, wrapAround) => {
    return getNewHighlightedOption(options, state.highlightedValue, diff, direction, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, wrapAround, optionComparer);
  }, "moveHighlight");
  switch (event.key) {
    case "Home":
      return _extends({}, state, {
        highlightedValue: moveHighlight("start", "next", false)
      });
    case "End":
      return _extends({}, state, {
        highlightedValue: moveHighlight("end", "previous", false)
      });
    case "PageUp":
      return _extends({}, state, {
        highlightedValue: moveHighlight(-pageSize, "previous", false)
      });
    case "PageDown":
      return _extends({}, state, {
        highlightedValue: moveHighlight(pageSize, "next", false)
      });
    case "ArrowUp":
      return _extends({}, state, {
        highlightedValue: moveHighlight(-1, "previous", !(disableListWrap != null ? disableListWrap : false))
      });
    case "ArrowDown":
      return _extends({}, state, {
        highlightedValue: moveHighlight(1, "next", !(disableListWrap != null ? disableListWrap : false))
      });
    case "Enter":
    case " ":
      if (state.highlightedValue === null) {
        return state;
      }
      return handleOptionSelection(state.highlightedValue, state, props);
    default:
      break;
  }
  return state;
}
__name(handleKeyDown2, "handleKeyDown");
function handleBlur(state) {
  return _extends({}, state, {
    highlightedValue: null
  });
}
__name(handleBlur, "handleBlur");
var textCriteriaMatches = __name((nextFocus, searchString, stringifyOption) => {
  var _stringifyOption;
  const text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();
  if (!text || text.length === 0) {
    return false;
  }
  return text.indexOf(searchString) === 0;
}, "textCriteriaMatches");
function handleTextNavigation(state, searchString, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer,
    optionStringifier
  } = props;
  const moveHighlight = __name((previouslyHighlightedOption) => {
    return getNewHighlightedOption(options, previouslyHighlightedOption, 1, "next", disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, !(disableListWrap != null ? disableListWrap : false), optionComparer);
  }, "moveHighlight");
  const startWithCurrentOption = searchString.length > 1;
  let nextOption = startWithCurrentOption ? state.highlightedValue : moveHighlight(state.highlightedValue);
  for (let index = 0; index < options.length; index += 1) {
    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {
      return state;
    }
    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {
      return _extends({}, state, {
        highlightedValue: nextOption
      });
    }
    nextOption = moveHighlight(nextOption);
  }
  return state;
}
__name(handleTextNavigation, "handleTextNavigation");
function handleOptionsChange(options, previousOptions, state, props) {
  var _options$find, _options$find2;
  const {
    multiple,
    optionComparer
  } = props;
  const newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find((option) => optionComparer(option, state.highlightedValue))) != null ? _options$find : null;
  if (multiple) {
    var _ref3;
    const selectedValues = (_ref3 = state.selectedValue) != null ? _ref3 : [];
    const newSelectedValues = selectedValues.filter((selectedValue) => options.some((option) => optionComparer(option, selectedValue)));
    return {
      highlightedValue: newHighlightedOption,
      selectedValue: newSelectedValues
    };
  }
  const newSelectedValue = (_options$find2 = options.find((option) => optionComparer(option, state.selectedValue))) != null ? _options$find2 : null;
  return {
    highlightedValue: newHighlightedOption,
    selectedValue: newSelectedValue
  };
}
__name(handleOptionsChange, "handleOptionsChange");
function defaultListboxReducer(state, action) {
  const {
    type
  } = action;
  switch (type) {
    case ActionTypes.keyDown:
      return handleKeyDown2(action.event, state, action.props);
    case ActionTypes.optionClick:
      return handleOptionSelection(action.option, state, action.props);
    case ActionTypes.blur:
      return handleBlur(state);
    case ActionTypes.setValue:
      return _extends({}, state, {
        selectedValue: action.value
      });
    case ActionTypes.setHighlight:
      return _extends({}, state, {
        highlightedValue: action.highlight
      });
    case ActionTypes.textNavigation:
      return handleTextNavigation(state, action.searchString, action.props);
    case ActionTypes.optionsChange:
      return handleOptionsChange(action.options, action.previousOptions, state, action.props);
    default:
      return state;
  }
}
__name(defaultListboxReducer, "defaultListboxReducer");
init_define_process();
init_react_preact();
function getControlledState(internalState, props) {
  if (props.value !== void 0) {
    return _extends({}, internalState, {
      selectedValue: props.value
    });
  }
  return internalState;
}
__name(getControlledState, "getControlledState");
function areOptionsEqual(option1, option2, optionComparer) {
  if (option1 === option2) {
    return true;
  }
  if (option1 === null || option2 === null) {
    return false;
  }
  return optionComparer(option1, option2);
}
__name(areOptionsEqual, "areOptionsEqual");
function useStateChangeDetection(nextState, internalPreviousState, propsRef) {
  useEffect(() => {
    if (!propsRef.current) {
      return;
    }
    const previousState = getControlledState(internalPreviousState, propsRef.current);
    const {
      multiple,
      optionComparer
    } = propsRef.current;
    if (multiple) {
      var _previousState$select;
      const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValue) != null ? _previousState$select : [];
      const nextSelectedValues = nextState.selectedValue;
      const onChange = propsRef.current.onChange;
      if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {
        onChange == null ? void 0 : onChange(nextSelectedValues);
      }
    } else {
      const previousSelectedValue = previousState == null ? void 0 : previousState.selectedValue;
      const nextSelectedValue = nextState.selectedValue;
      const onChange = propsRef.current.onChange;
      if (!areOptionsEqual(nextSelectedValue, previousSelectedValue, optionComparer)) {
        onChange == null ? void 0 : onChange(nextSelectedValue);
      }
    }
  }, [nextState.selectedValue, internalPreviousState, propsRef]);
  useEffect(() => {
    if (!propsRef.current) {
      return;
    }
    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {
      var _propsRef$current, _propsRef$current$onH;
      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, nextState.highlightedValue);
    }
  }, [nextState.highlightedValue, internalPreviousState.highlightedValue, propsRef]);
}
__name(useStateChangeDetection, "useStateChangeDetection");
function useControllableReducer(internalReducer, externalReducer, props) {
  var _ref;
  const {
    value,
    defaultValue
  } = props;
  const propsRef = useRef(props);
  propsRef.current = props;
  const initialSelectedValue = (_ref = value === void 0 ? defaultValue : value) != null ? _ref : props.multiple ? [] : null;
  const initalState = {
    highlightedValue: null,
    selectedValue: initialSelectedValue
  };
  const combinedReducer = useCallback((state, action) => {
    if (externalReducer) {
      return externalReducer(getControlledState(state, propsRef.current), action);
    }
    return internalReducer(getControlledState(state, propsRef.current), action);
  }, [externalReducer, internalReducer, propsRef]);
  const [nextState, dispatch] = useReducer(combinedReducer, initalState);
  const previousState = useRef(initalState);
  useEffect(() => {
    previousState.current = nextState;
  }, [previousState, nextState]);
  useStateChangeDetection(nextState, previousState.current, propsRef);
  return [getControlledState(nextState, propsRef.current), dispatch];
}
__name(useControllableReducer, "useControllableReducer");
var TEXT_NAVIGATION_RESET_TIMEOUT = 500;
var defaultOptionComparer = __name((optionA, optionB) => optionA === optionB, "defaultOptionComparer");
var defaultIsOptionDisabled = __name(() => false, "defaultIsOptionDisabled");
var defaultOptionStringifier = __name((option) => typeof option === "string" ? option : String(option), "defaultOptionStringifier");
function useListbox(props) {
  var _props$optionIdGenera, _options$highlightedI;
  const {
    disabledItemsFocusable = false,
    disableListWrap = false,
    focusManagement = "activeDescendant",
    id: idProp,
    isOptionDisabled = defaultIsOptionDisabled,
    listboxRef: externalListboxRef,
    multiple = false,
    optionComparer = defaultOptionComparer,
    optionStringifier = defaultOptionStringifier,
    options,
    stateReducer: externalReducer
  } = props;
  const id3 = useId2(idProp);
  function defaultIdGenerator(_22, index) {
    return `${id3}-option-${index}`;
  }
  __name(defaultIdGenerator, "defaultIdGenerator");
  const optionIdGenerator = (_props$optionIdGenera = props.optionIdGenerator) != null ? _props$optionIdGenera : defaultIdGenerator;
  const propsWithDefaults = _extends({}, props, {
    disabledItemsFocusable,
    disableListWrap,
    focusManagement,
    isOptionDisabled,
    multiple,
    optionComparer,
    optionStringifier
  });
  const listboxRef = useRef(null);
  const handleRef = useForkRef(externalListboxRef, listboxRef);
  const textCriteriaRef = useRef({
    searchString: "",
    lastTime: null
  });
  const [{
    highlightedValue,
    selectedValue
  }, dispatch] = useControllableReducer(defaultListboxReducer, externalReducer, propsWithDefaults);
  const highlightedIndex = useMemo(() => {
    return highlightedValue == null ? -1 : options.findIndex((option) => optionComparer(option, highlightedValue));
  }, [highlightedValue, options, optionComparer]);
  const previousOptions = useRef([]);
  useEffect(() => {
    if (areArraysEqual(previousOptions.current, options, optionComparer)) {
      return;
    }
    dispatch({
      type: ActionTypes.optionsChange,
      options,
      previousOptions: previousOptions.current,
      props: propsWithDefaults
    });
    previousOptions.current = options;
  }, [options, optionComparer, dispatch]);
  const setSelectedValue = useCallback((option) => {
    dispatch({
      type: ActionTypes.setValue,
      value: option
    });
  }, [dispatch]);
  const setHighlightedValue = useCallback((option) => {
    dispatch({
      type: ActionTypes.setHighlight,
      highlight: option
    });
  }, [dispatch]);
  const createHandleOptionClick = __name((option, other) => (event) => {
    var _other$onClick;
    (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    dispatch({
      type: ActionTypes.optionClick,
      option,
      event,
      props: propsWithDefaults
    });
  }, "createHandleOptionClick");
  const createHandleOptionMouseOver = __name((option, other) => (event) => {
    var _other$onMouseOver;
    (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    dispatch({
      type: ActionTypes.optionHover,
      option,
      event,
      props: propsWithDefaults
    });
  }, "createHandleOptionMouseOver");
  const createHandleKeyDown = __name((other) => (event) => {
    var _other$onKeyDown;
    (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    const keysToPreventDefault = ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"];
    if (focusManagement === "activeDescendant") {
      keysToPreventDefault.push(" ", "Enter");
    }
    if (keysToPreventDefault.includes(event.key)) {
      event.preventDefault();
    }
    dispatch({
      type: ActionTypes.keyDown,
      event,
      props: propsWithDefaults
    });
    if (event.key.length === 1 && event.key !== " ") {
      const textCriteria = textCriteriaRef.current;
      const lowerKey = event.key.toLowerCase();
      const currentTime = performance.now();
      if (textCriteria.searchString.length > 0 && textCriteria.lastTime && currentTime - textCriteria.lastTime > TEXT_NAVIGATION_RESET_TIMEOUT) {
        textCriteria.searchString = lowerKey;
      } else if (textCriteria.searchString.length !== 1 || lowerKey !== textCriteria.searchString) {
        textCriteria.searchString += lowerKey;
      }
      textCriteria.lastTime = currentTime;
      dispatch({
        type: ActionTypes.textNavigation,
        searchString: textCriteria.searchString,
        props: propsWithDefaults
      });
    }
  }, "createHandleKeyDown");
  const createHandleBlur = __name((other) => (event) => {
    var _other$onBlur, _listboxRef$current;
    (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    if ((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(document.activeElement)) {
      return;
    }
    dispatch({
      type: ActionTypes.blur,
      event,
      props: propsWithDefaults
    });
  }, "createHandleBlur");
  const getRootProps = __name((otherHandlers = {}) => {
    return _extends({}, otherHandlers, {
      "aria-activedescendant": focusManagement === "activeDescendant" && highlightedValue != null ? optionIdGenerator(highlightedValue, highlightedIndex) : void 0,
      id: id3,
      onBlur: createHandleBlur(otherHandlers),
      onKeyDown: createHandleKeyDown(otherHandlers),
      role: "listbox",
      tabIndex: focusManagement === "DOM" ? -1 : 0,
      ref: handleRef
    });
  }, "getRootProps");
  const getOptionState = __name((option) => {
    let selected;
    const index = options.findIndex((opt) => optionComparer(opt, option));
    if (multiple) {
      var _ref;
      selected = ((_ref = selectedValue) != null ? _ref : []).some((value) => value != null && optionComparer(option, value));
    } else {
      selected = optionComparer(option, selectedValue);
    }
    const disabled = isOptionDisabled(option, index);
    return {
      selected,
      disabled,
      highlighted: highlightedIndex === index
    };
  }, "getOptionState");
  const getOptionTabIndex = __name((optionState) => {
    if (focusManagement === "activeDescendant") {
      return void 0;
    }
    if (!optionState.highlighted) {
      return -1;
    }
    if (optionState.disabled && !disabledItemsFocusable) {
      return -1;
    }
    return 0;
  }, "getOptionTabIndex");
  const getOptionProps = __name((option, otherHandlers = {}) => {
    const optionState = getOptionState(option);
    const index = options.findIndex((opt) => optionComparer(opt, option));
    return _extends({}, otherHandlers, {
      "aria-disabled": optionState.disabled || void 0,
      "aria-selected": optionState.selected,
      tabIndex: getOptionTabIndex(optionState),
      id: optionIdGenerator(option, index),
      onClick: createHandleOptionClick(option, otherHandlers),
      onMouseOver: createHandleOptionMouseOver(option, otherHandlers),
      role: "option"
    });
  }, "getOptionProps");
  useDebugValue({
    highlightedOption: options[highlightedIndex],
    selectedOption: selectedValue
  });
  return {
    getRootProps,
    getOptionProps,
    getOptionState,
    highlightedOption: (_options$highlightedI = options[highlightedIndex]) != null ? _options$highlightedI : null,
    selectedOption: selectedValue,
    setSelectedValue,
    setHighlightedValue
  };
}
__name(useListbox, "useListbox");
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types11 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
var MenuUnstyledContext = createContext(null);
MenuUnstyledContext.displayName = "MenuUnstyledContext";
var MenuUnstyledContext_default = MenuUnstyledContext;
init_define_process();
function getMenuUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiMenuUnstyled", slot);
}
__name(getMenuUnstyledUtilityClass, "getMenuUnstyledUtilityClass");
var menuUnstyledClasses = generateUtilityClasses("MuiMenuUnstyled", ["root", "listbox", "expanded"]);
init_define_process();
init_react_preact();
function stateReducer(state, action) {
  if (action.type === ActionTypes.blur || action.type === ActionTypes.optionHover || action.type === ActionTypes.setValue) {
    return state;
  }
  const newState = defaultListboxReducer(state, action);
  if (action.type !== ActionTypes.setHighlight && newState.highlightedValue === null && action.props.options.length > 0) {
    return _extends({}, newState, {
      highlightedValue: action.props.options[0]
    });
  }
  return newState;
}
__name(stateReducer, "stateReducer");
function useMenu(parameters = {}) {
  const {
    listboxRef: listboxRefProp,
    open: open2 = false,
    onClose,
    listboxId
  } = parameters;
  const [menuItems, setMenuItems] = useState({});
  const listboxRef = useRef(null);
  const handleRef = useForkRef(listboxRef, listboxRefProp);
  const registerItem = useCallback((id3, metadata) => {
    setMenuItems((previousState) => {
      const newState = _extends({}, previousState);
      newState[id3] = metadata;
      return newState;
    });
  }, []);
  const unregisterItem = useCallback((id3) => {
    setMenuItems((previousState) => {
      const newState = _extends({}, previousState);
      delete newState[id3];
      return newState;
    });
  }, []);
  const {
    getOptionState,
    getOptionProps,
    getRootProps,
    highlightedOption,
    setHighlightedValue: setListboxHighlight
  } = useListbox({
    options: Object.keys(menuItems),
    optionStringifier: (id3) => {
      var _menuItems$id$ref$cur;
      return menuItems[id3].label || ((_menuItems$id$ref$cur = menuItems[id3].ref.current) == null ? void 0 : _menuItems$id$ref$cur.innerText);
    },
    isOptionDisabled: (id3) => {
      var _menuItems$id;
      return (menuItems == null ? void 0 : (_menuItems$id = menuItems[id3]) == null ? void 0 : _menuItems$id.disabled) || false;
    },
    listboxRef: handleRef,
    focusManagement: "DOM",
    id: listboxId,
    stateReducer,
    disabledItemsFocusable: true
  });
  const highlightFirstItem = useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[0]].id);
    }
  }, [menuItems, setListboxHighlight]);
  const highlightLastItem = useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[Object.keys(menuItems).length - 1]].id);
    }
  }, [menuItems, setListboxHighlight]);
  useEffect(() => {
    if (!open2) {
      highlightFirstItem();
    }
  }, [open2, highlightFirstItem]);
  const createHandleKeyDown = __name((otherHandlers) => (e22) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, e22);
    if (e22.defaultPrevented) {
      return;
    }
    if (e22.key === "Escape" && open2) {
      onClose == null ? void 0 : onClose();
    }
  }, "createHandleKeyDown");
  const createHandleBlur = __name((otherHandlers) => (e22) => {
    var _otherHandlers$onBlur, _listboxRef$current;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, e22);
    if (!((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(e22.relatedTarget))) {
      onClose == null ? void 0 : onClose();
    }
  }, "createHandleBlur");
  useEffect(() => {
    var _listboxRef$current2;
    if ((_listboxRef$current2 = listboxRef.current) != null && _listboxRef$current2.contains(document.activeElement) && highlightedOption !== null) {
      var _menuItems$highlighte, _menuItems$highlighte2;
      menuItems == null ? void 0 : (_menuItems$highlighte = menuItems[highlightedOption]) == null ? void 0 : (_menuItems$highlighte2 = _menuItems$highlighte.ref.current) == null ? void 0 : _menuItems$highlighte2.focus();
    }
  }, [highlightedOption, menuItems]);
  const getListboxProps = __name((otherHandlers = {}) => {
    const rootProps = getRootProps(_extends({}, otherHandlers, {
      onBlur: createHandleBlur(otherHandlers),
      onKeyDown: createHandleKeyDown(otherHandlers)
    }));
    return _extends({}, otherHandlers, rootProps, {
      role: "menu"
    });
  }, "getListboxProps");
  const getItemState = __name((id3) => {
    const {
      disabled,
      highlighted
    } = getOptionState(id3);
    return {
      disabled,
      highlighted
    };
  }, "getItemState");
  useDebugValue({
    menuItems,
    highlightedOption
  });
  return {
    registerItem,
    unregisterItem,
    menuItems,
    getListboxProps,
    getItemState,
    getItemProps: getOptionProps,
    highlightedOption,
    highlightFirstItem,
    highlightLastItem
  };
}
__name(useMenu, "useMenu");
init_define_process();
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto2 = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto2]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
init_define_process();
init_define_process();
init_define_process();
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
__name(getNodeName, "getNodeName");
init_define_process();
init_define_process();
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument2 = node.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node;
}
__name(getWindow, "getWindow");
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
__name(isElement, "isElement");
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
__name(isHTMLElement, "isHTMLElement");
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
__name(isShadowRoot, "isShadowRoot");
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style4 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style4);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
__name(applyStyles, "applyStyles");
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style4 = styleProperties.reduce(function(style5, property) {
        style5[property] = "";
        return style5;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style4);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
__name(effect, "effect");
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};
init_define_process();
init_define_process();
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
__name(getBasePlacement, "getBasePlacement");
init_define_process();
init_define_process();
init_define_process();
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;
init_define_process();
init_define_process();
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
__name(getUAString, "getUAString");
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
__name(isLayoutViewport, "isLayoutViewport");
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x5 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y4,
    right: x5 + width2,
    bottom: y4 + height2,
    left: x5,
    x: x5,
    y: y4
  };
}
__name(getBoundingClientRect, "getBoundingClientRect");
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
__name(getLayoutRect, "getLayoutRect");
init_define_process();
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
__name(contains, "contains");
init_define_process();
init_define_process();
function getComputedStyle3(element) {
  return getWindow(element).getComputedStyle(element);
}
__name(getComputedStyle3, "getComputedStyle");
init_define_process();
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
__name(isTableElement, "isTableElement");
init_define_process();
init_define_process();
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
__name(getDocumentElement, "getDocumentElement");
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
__name(getParentNode, "getParentNode");
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
__name(getTrueOffsetParent, "getTrueOffsetParent");
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle3(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css7 = getComputedStyle3(currentNode);
    if (css7.transform !== "none" || css7.perspective !== "none" || css7.contain === "paint" || ["transform", "perspective"].indexOf(css7.willChange) !== -1 || isFirefox && css7.willChange === "filter" || isFirefox && css7.filter && css7.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
__name(getContainingBlock, "getContainingBlock");
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle3(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle3(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
__name(getOffsetParent, "getOffsetParent");
init_define_process();
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
__name(getMainAxisFromPlacement, "getMainAxisFromPlacement");
init_define_process();
function within(min22, value, max22) {
  return max2(min22, min2(value, max22));
}
__name(within, "within");
function withinMaxClamp(min22, value, max22) {
  var v5 = within(min22, value, max22);
  return v5 > max22 ? max22 : v5;
}
__name(withinMaxClamp, "withinMaxClamp");
init_define_process();
init_define_process();
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
__name(getFreshSideObject, "getFreshSideObject");
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
__name(mergePaddingObject, "mergePaddingObject");
init_define_process();
function expandToHashMap(value, keys3) {
  return keys3.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
__name(expandToHashMap, "expandToHashMap");
var toPaddingObject = __name(function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
}, "toPaddingObject");
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min22 = paddingObject[minProp];
  var max22 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min22, center, max22);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
__name(arrow, "arrow");
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (false) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
__name(effect2, "effect");
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
init_define_process();
init_define_process();
function getVariation(placement) {
  return placement.split("-")[1];
}
__name(getVariation, "getVariation");
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x5 = _ref.x, y4 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x5 * dpr) / dpr || 0,
    y: round(y4 * dpr) / dpr || 0
  };
}
__name(roundOffsetsByDPR, "roundOffsetsByDPR");
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x5 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x5,
    y: y4
  }) : {
    x: x5,
    y: y4
  };
  x5 = _ref3.x;
  y4 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle3(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y4 -= offsetY - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x5 -= offsetX - popperRect.width;
      x5 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x5,
    y: y4
  }) : {
    x: x5,
    y: y4
  };
  x5 = _ref4.x;
  y4 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x5 + "px, " + y4 + "px)" : "translate3d(" + x5 + "px, " + y4 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x5 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
__name(mapToStyles, "mapToStyles");
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (false) {
    var transitionProperty = getComputedStyle3(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
__name(computeStyles, "computeStyles");
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
init_define_process();
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize2 = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize2) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize2) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
__name(effect3, "effect");
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: __name(function fn() {
  }, "fn"),
  effect: effect3,
  data: {}
};
init_define_process();
init_define_process();
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash3[matched];
  });
}
__name(getOppositePlacement, "getOppositePlacement");
init_define_process();
var hash22 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash22[matched];
  });
}
__name(getOppositeVariationPlacement, "getOppositeVariationPlacement");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
__name(getWindowScroll, "getWindowScroll");
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
__name(getWindowScrollBarX, "getWindowScrollBarX");
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x5 = 0;
  var y4 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x5 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x5 + getWindowScrollBarX(element),
    y: y4
  };
}
__name(getViewportRect, "getViewportRect");
init_define_process();
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x5 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y4 = -winScroll.scrollTop;
  if (getComputedStyle3(body || html).direction === "rtl") {
    x5 += max2(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x5,
    y: y4
  };
}
__name(getDocumentRect, "getDocumentRect");
init_define_process();
init_define_process();
init_define_process();
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle3(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}
__name(isScrollParent, "isScrollParent");
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
__name(getScrollParent, "getScrollParent");
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
__name(listScrollParents, "listScrollParents");
init_define_process();
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
__name(rectToClientRect, "rectToClientRect");
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
__name(getInnerBoundingClientRect, "getInnerBoundingClientRect");
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
__name(getClientRectFromMixedType, "getClientRectFromMixedType");
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle3(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
__name(getClippingParents, "getClippingParents");
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
__name(getClippingRect, "getClippingRect");
init_define_process();
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
__name(computeOffsets, "computeOffsets");
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
__name(detectOverflow, "detectOverflow");
init_define_process();
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (false) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a5, b5) {
    return overflows[a5] - overflows[b5];
  });
}
__name(computeAutoPlacement, "computeAutoPlacement");
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto2) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
__name(getExpandedFallbackPlacements, "getExpandedFallbackPlacements");
function flip2(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto2 ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i4 = 0; i4 < placements2.length; i4++) {
    var placement = placements2[i4];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow2 = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow2[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = __name(function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    }, "_loop");
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
__name(flip2, "flip");
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip2,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
init_define_process();
function getSideOffsets(overflow2, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow2.top - rect.height - preventedOffsets.y,
    right: overflow2.right - rect.width + preventedOffsets.x,
    bottom: overflow2.bottom - rect.height + preventedOffsets.y,
    left: overflow2.left - rect.width - preventedOffsets.x
  };
}
__name(getSideOffsets, "getSideOffsets");
function isAnySideFullyClipped(overflow2) {
  return [top, right, bottom, left].some(function(side) {
    return overflow2[side] >= 0;
  });
}
__name(isAnySideFullyClipped, "isAnySideFullyClipped");
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
__name(hide, "hide");
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
init_define_process();
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
__name(distanceAndSkiddingToXY, "distanceAndSkiddingToXY");
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x5 = _data$state$placement.x, y4 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x5;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data;
}
__name(offset, "offset");
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
init_define_process();
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
__name(popperOffsets, "popperOffsets");
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
init_define_process();
init_define_process();
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
__name(getAltAxis, "getAltAxis");
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow2 = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min22 = offset2 + overflow2[mainSide];
    var max22 = offset2 - overflow2[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min22, tetherMin) : min22, offset2, tether ? max2(max22, tetherMax) : max22);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow2[_mainSide];
    var _max = _offset - overflow2[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
__name(preventOverflow, "preventOverflow");
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
__name(getHTMLElementScroll, "getHTMLElementScroll");
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
__name(getNodeScroll, "getNodeScroll");
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
__name(isElementScaled, "isElementScaled");
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
__name(getCompositeRect, "getCompositeRect");
init_define_process();
function order2(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  __name(sort2, "sort");
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
__name(order2, "order");
function orderModifiers(modifiers) {
  var orderedModifiers = order2(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
__name(orderModifiers, "orderModifiers");
init_define_process();
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
__name(debounce2, "debounce");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
__name(mergeByName, "mergeByName");
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
__name(areValidElements, "areValidElements");
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return __name(function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: __name(function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m22) {
          return m22.enabled;
        });
        if (false) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto2) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle3(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin2) {
            return parseFloat(margin2);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      }, "setOptions"),
      forceUpdate: __name(function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (false) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      }, "forceUpdate"),
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: __name(function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }, "destroy")
    };
    if (!areValidElements(reference2, popper2)) {
      if (false) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = __name(function noopFn2() {
          }, "noopFn");
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    __name(runModifierEffects, "runModifierEffects");
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    __name(cleanupModifierEffects, "cleanupModifierEffects");
    return instance;
  }, "createPopper");
}
__name(popperGenerator, "popperGenerator");
var createPopper = popperGenerator();
init_define_process();
init_define_process();
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});
var import_prop_types10 = __toESM(require_prop_types());
init_define_process();
init_define_process();
init_react_preact();
init_react_preact();
var import_prop_types9 = __toESM(require_prop_types());
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer, "getContainer");
var Portal = forwardRef(__name(function Portal2(props, ref) {
  const {
    children: children2,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = useState(null);
  const handleRef = useForkRef(isValidElement(children2) ? children2.ref : null, ref);
  useEnhancedEffect_default(() => {
    if (!disablePortal) {
      setMountNode(getContainer(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect_default(() => {
    if (mountNode && !disablePortal) {
      setRef(ref, mountNode);
      return () => {
        setRef(ref, null);
      };
    }
    return void 0;
  }, [ref, mountNode, disablePortal]);
  if (disablePortal) {
    if (isValidElement(children2)) {
      return cloneElement(children2, {
        ref: handleRef
      });
    }
    return children2;
  }
  return mountNode ? V(children2, mountNode) : mountNode;
}, "Portal"));
false ? Portal.propTypes = {
  children: import_prop_types9.default.node,
  container: import_prop_types9.default.oneOfType([HTMLElementType, import_prop_types9.default.func]),
  disablePortal: import_prop_types9.default.bool
} : void 0;
if (false) {
  Portal["propTypes"] = exactProp(Portal.propTypes);
}
var Portal_default = Portal;
init_define_process();
function getPopperUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiPopperUnstyled", slot);
}
__name(getPopperUnstyledUtilityClass, "getPopperUnstyledUtilityClass");
var popperUnstyledClasses = generateUtilityClasses("MuiPopperUnstyled", ["root"]);
init_react_preact();
var _excluded6 = ["anchorEl", "children", "component", "components", "componentsProps", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "TransitionProps"];
var _excluded23 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
__name(flipPlacement, "flipPlacement");
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
__name(resolveAnchorEl, "resolveAnchorEl");
var useUtilityClasses4 = __name(() => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUnstyledUtilityClass, {});
}, "useUtilityClasses");
var defaultPopperOptions = {};
var PopperTooltip = forwardRef(__name(function PopperTooltip2(props, ref) {
  var _ref;
  const {
    anchorEl,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    direction,
    disablePortal,
    modifiers,
    open: open2,
    ownerState,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const tooltipRef = useRef(null);
  const ownRef = useForkRef(tooltipRef, ref);
  const popperRef = useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = useRef(handlePopperRef);
  useEnhancedEffect_default(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = useState(rtlPlacement);
  useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  useEnhancedEffect_default(() => {
    if (!anchorEl || !open2) {
      return void 0;
    }
    const handlePopperUpdate = __name((data) => {
      setPlacement(data.placement);
    }, "handlePopperUpdate");
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    if (false) {
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      }
    }
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper3(resolveAnchorEl(anchorEl), tooltipRef.current, _extends({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [anchorEl, disablePortal, modifiers, open2, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses4();
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: _extends({}, props, ownerState),
    className: classes.root
  });
  return e3(Root, _extends({}, rootProps, {
    children: typeof children2 === "function" ? children2(childProps) : children2
  }));
}, "PopperTooltip"));
var PopperUnstyled = forwardRef(__name(function PopperUnstyled2(props, ref) {
  const {
    anchorEl,
    children: children2,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open: open2,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style4,
    transition = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded23);
  const [exited, setExited] = useState(true);
  const handleEnter = __name(() => {
    setExited(false);
  }, "handleEnter");
  const handleExited = __name(() => {
    setExited(true);
  }, "handleExited");
  if (!keepMounted && !open2 && (!transition || exited)) {
    return null;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  return e3(Portal_default, {
    disablePortal,
    container,
    children: e3(PopperTooltip, _extends({
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref,
      open: transition ? !exited : open2,
      placement,
      popperOptions,
      popperRef
    }, other, {
      style: _extends({
        position: "fixed",
        top: 0,
        left: 0,
        display: !open2 && keepMounted && (!transition || exited) ? "none" : null
      }, style4),
      TransitionProps: transition ? {
        in: open2,
        onEnter: handleEnter,
        onExited: handleExited
      } : null,
      children: children2
    }))
  });
}, "PopperUnstyled"));
false ? PopperUnstyled.propTypes = {
  anchorEl: chainPropTypes(import_prop_types10.default.oneOfType([HTMLElementType, import_prop_types10.default.object, import_prop_types10.default.func]), (props) => {
    if (props.open) {
      const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== "function" || resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join("\n"));
      }
    }
    return null;
  }),
  children: import_prop_types10.default.oneOfType([import_prop_types10.default.node, import_prop_types10.default.func]),
  components: import_prop_types10.default.shape({
    Root: import_prop_types10.default.elementType
  }),
  componentsProps: import_prop_types10.default.shape({
    root: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object])
  }),
  container: import_prop_types10.default.oneOfType([HTMLElementType, import_prop_types10.default.func]),
  direction: import_prop_types10.default.oneOf(["ltr", "rtl"]),
  disablePortal: import_prop_types10.default.bool,
  keepMounted: import_prop_types10.default.bool,
  modifiers: import_prop_types10.default.arrayOf(import_prop_types10.default.shape({
    data: import_prop_types10.default.object,
    effect: import_prop_types10.default.func,
    enabled: import_prop_types10.default.bool,
    fn: import_prop_types10.default.func,
    name: import_prop_types10.default.any,
    options: import_prop_types10.default.object,
    phase: import_prop_types10.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types10.default.arrayOf(import_prop_types10.default.string),
    requiresIfExists: import_prop_types10.default.arrayOf(import_prop_types10.default.string)
  })),
  open: import_prop_types10.default.bool.isRequired,
  placement: import_prop_types10.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  popperOptions: import_prop_types10.default.shape({
    modifiers: import_prop_types10.default.array,
    onFirstUpdate: import_prop_types10.default.func,
    placement: import_prop_types10.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types10.default.oneOf(["absolute", "fixed"])
  }),
  popperRef: refType_default,
  style: import_prop_types10.default.object,
  transition: import_prop_types10.default.bool
} : void 0;
var PopperUnstyled_default = PopperUnstyled;
init_react_preact();
var _excluded7 = ["actions", "anchorEl", "children", "component", "components", "componentsProps", "keepMounted", "listboxId", "onClose", "open"];
function getUtilityClasses(ownerState) {
  const {
    open: open2
  } = ownerState;
  const slots = {
    root: ["root", open2 && "expanded"],
    listbox: ["listbox", open2 && "expanded"]
  };
  return composeClasses(slots, getMenuUnstyledUtilityClass, {});
}
__name(getUtilityClasses, "getUtilityClasses");
var MenuUnstyled = forwardRef(__name(function MenuUnstyled2(props, forwardedRef) {
  var _ref, _components$Listbox;
  const {
    actions,
    anchorEl,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    keepMounted = false,
    listboxId,
    onClose,
    open: open2 = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const {
    registerItem,
    unregisterItem,
    getListboxProps,
    getItemProps,
    getItemState,
    highlightFirstItem,
    highlightLastItem
  } = useMenu({
    open: open2,
    onClose,
    listboxId
  });
  useImperativeHandle(actions, () => ({
    highlightFirstItem,
    highlightLastItem
  }), [highlightFirstItem, highlightLastItem]);
  const ownerState = _extends({}, props, {
    open: open2
  });
  const classes = getUtilityClasses(ownerState);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : PopperUnstyled_default;
  const rootProps = useSlotProps({
    elementType: Root,
    externalForwardedProps: other,
    externalSlotProps: componentsProps.root,
    additionalProps: {
      anchorEl,
      open: open2,
      keepMounted,
      role: void 0,
      ref: forwardedRef
    },
    className: classes.root,
    ownerState
  });
  const Listbox = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
  const listboxProps = useSlotProps({
    elementType: Listbox,
    getSlotProps: getListboxProps,
    externalSlotProps: componentsProps.listbox,
    ownerState,
    className: classes.listbox
  });
  const contextValue = {
    registerItem,
    unregisterItem,
    getItemState,
    getItemProps,
    open: open2
  };
  return e3(Root, _extends({}, rootProps, {
    children: e3(Listbox, _extends({}, listboxProps, {
      children: e3(MenuUnstyledContext_default.Provider, {
        value: contextValue,
        children: children2
      })
    }))
  }));
}, "MenuUnstyled"));
false ? MenuUnstyled.propTypes = {
  actions: refType_default,
  anchorEl: import_prop_types11.default.oneOfType([HTMLElementType, import_prop_types11.default.object, import_prop_types11.default.func]),
  children: import_prop_types11.default.node,
  component: import_prop_types11.default.elementType,
  components: import_prop_types11.default.shape({
    Listbox: import_prop_types11.default.elementType,
    Root: import_prop_types11.default.elementType
  }),
  componentsProps: import_prop_types11.default.shape({
    listbox: import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object]),
    root: import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object])
  }),
  keepMounted: import_prop_types11.default.bool,
  listboxId: import_prop_types11.default.string,
  onClose: import_prop_types11.default.func,
  open: import_prop_types11.default.bool
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types12 = __toESM(require_prop_types());
init_define_process();
function getMenuItemUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItemUnstyled", slot);
}
__name(getMenuItemUnstyledUtilityClass, "getMenuItemUnstyledUtilityClass");
var menuItemUnstyledClasses = generateUtilityClasses("MuiMenuItemUnstyled", ["root", "disabled", "focusVisible"]);
init_define_process();
init_react_preact();
function useMenuItem(props) {
  var _itemState$disabled;
  const {
    disabled = false,
    ref,
    label
  } = props;
  const id3 = useId2();
  const menuContext = useContext(MenuUnstyledContext_default);
  const itemRef = useRef(null);
  const handleRef = useForkRef(itemRef, ref);
  if (menuContext === null) {
    throw new Error("MenuItemUnstyled must be used within a MenuUnstyled");
  }
  const {
    registerItem,
    unregisterItem,
    open: open2
  } = menuContext;
  useEffect(() => {
    if (id3 === void 0) {
      return void 0;
    }
    registerItem(id3, {
      disabled,
      id: id3,
      ref: itemRef,
      label
    });
    return () => unregisterItem(id3);
  }, [id3, registerItem, unregisterItem, disabled, ref, label]);
  const {
    getRootProps: getButtonProps,
    focusVisible
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    ref: handleRef
  });
  const [focusRequested, requestFocus] = useState(false);
  const focusIfRequested = useCallback(() => {
    if (focusRequested && itemRef.current != null) {
      itemRef.current.focus();
      requestFocus(false);
    }
  }, [focusRequested]);
  useEffect(() => {
    focusIfRequested();
  });
  useDebugValue({
    id: id3,
    disabled,
    label
  });
  const itemState = menuContext.getItemState(id3 != null ? id3 : "");
  const {
    highlighted
  } = itemState != null ? itemState : {
    highlighted: false
  };
  useEffect(() => {
    requestFocus(highlighted && open2);
  }, [highlighted, open2]);
  if (id3 === void 0) {
    return {
      getRootProps: (other) => _extends({}, other, getButtonProps(other), {
        role: "menuitem"
      }),
      disabled: false,
      focusVisible
    };
  }
  return {
    getRootProps: (other) => {
      const optionProps = menuContext.getItemProps(id3, other);
      return _extends({}, other, getButtonProps(other), {
        tabIndex: optionProps.tabIndex,
        id: optionProps.id,
        role: "menuitem"
      });
    },
    disabled: (_itemState$disabled = itemState == null ? void 0 : itemState.disabled) != null ? _itemState$disabled : false,
    focusVisible
  };
}
__name(useMenuItem, "useMenuItem");
init_react_preact();
var _excluded8 = ["children", "disabled", "component", "components", "componentsProps", "label"];
function getUtilityClasses2(ownerState) {
  const {
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getMenuItemUnstyledUtilityClass, {});
}
__name(getUtilityClasses2, "getUtilityClasses");
var MenuItemUnstyled = forwardRef(__name(function MenuItemUnstyled2(props, ref) {
  var _ref;
  const {
    children: children2,
    disabled: disabledProp = false,
    component,
    components = {},
    componentsProps = {},
    label
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const {
    getRootProps,
    disabled,
    focusVisible
  } = useMenuItem({
    disabled: disabledProp,
    ref,
    label
  });
  const ownerState = _extends({}, props, {
    disabled,
    focusVisible
  });
  const classes = getUtilityClasses2(ownerState);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "li";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    className: classes.root,
    ownerState
  });
  return e3(Root, _extends({}, rootProps, {
    children: children2
  }));
}, "MenuItemUnstyled"));
false ? MenuItemUnstyled.propTypes = {
  children: import_prop_types12.default.node,
  component: import_prop_types12.default.elementType,
  components: import_prop_types12.default.shape({
    Root: import_prop_types12.default.elementType
  }),
  componentsProps: import_prop_types12.default.shape({
    root: import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object])
  }),
  disabled: import_prop_types12.default.bool,
  label: import_prop_types12.default.string
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types14 = __toESM(require_prop_types());
init_define_process();
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
__name(isOverflowing, "isOverflowing");
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
__name(ariaHidden, "ariaHidden");
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
__name(getPaddingRight, "getPaddingRight");
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
__name(isAriaHiddenForbiddenOnElement, "isAriaHiddenForbiddenOnElement");
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
__name(ariaHiddenSiblings, "ariaHiddenSiblings");
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
__name(findIndexOf, "findIndexOf");
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = __name(() => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  }, "restore");
  return restore;
}
__name(handleContainer, "handleContainer");
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
__name(getHiddenSiblings, "getHiddenSiblings");
var ModalManager = class {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
};
__name(ModalManager, "ModalManager");
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types13 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
var candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node) {
  const tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node.contentEditable === "true" || (node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
    return 0;
  }
  return node.tabIndex;
}
__name(getTabIndex, "getTabIndex");
function isNonTabbableRadio(node) {
  if (node.tagName !== "INPUT" || node.type !== "radio") {
    return false;
  }
  if (!node.name) {
    return false;
  }
  const getRadio = __name((selector) => node.ownerDocument.querySelector(`input[type="radio"]${selector}`), "getRadio");
  let roving = getRadio(`[name="${node.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node.name}"]`);
  }
  return roving !== node;
}
__name(isNonTabbableRadio, "isNonTabbableRadio");
function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || node.tagName === "INPUT" && node.type === "hidden" || isNonTabbableRadio(node)) {
    return false;
  }
  return true;
}
__name(isNodeMatchingSelectorFocusable, "isNodeMatchingSelectorFocusable");
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i4) => {
    const nodeTabIndex = getTabIndex(node);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node);
    } else {
      orderedTabNodes.push({
        documentOrder: i4,
        tabIndex: nodeTabIndex,
        node
      });
    }
  });
  return orderedTabNodes.sort((a5, b5) => a5.tabIndex === b5.tabIndex ? a5.documentOrder - b5.documentOrder : a5.tabIndex - b5.tabIndex).map((a5) => a5.node).concat(regularTabNodes);
}
__name(defaultGetTabbable, "defaultGetTabbable");
function defaultIsEnabled() {
  return true;
}
__name(defaultIsEnabled, "defaultIsEnabled");
function TrapFocus(props) {
  const {
    children: children2,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open: open2
  } = props;
  const ignoreNextEnforceFocus = useRef();
  const sentinelStart = useRef(null);
  const sentinelEnd = useRef(null);
  const nodeToRestore = useRef(null);
  const reactFocusEventTarget = useRef(null);
  const activated = useRef(false);
  const rootRef = useRef(null);
  const handleRef = useForkRef(children2.ref, rootRef);
  const lastKeydown = useRef(null);
  useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open2]);
  useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        if (false) {
          console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));
        }
        rootRef.current.setAttribute("tabIndex", -1);
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open2]);
  useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const contain = __name((nativeEvent) => {
      const {
        current: rootElement
      } = rootRef;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (!rootElement.contains(doc.activeElement)) {
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        } else {
          rootElement.focus();
        }
      }
    }, "contain");
    const loopFocus = __name((nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        sentinelEnd.current.focus();
      }
    }, "loopFocus");
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open2, getTabbable]);
  const onFocus = __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children2.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  }, "onFocus");
  const handleFocusSentinel = __name((event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  }, "handleFocusSentinel");
  return e3(p, {
    children: [e3("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-test": "sentinelStart"
    }), cloneElement(children2, {
      ref: handleRef,
      onFocus
    }), e3("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-test": "sentinelEnd"
    })]
  });
}
__name(TrapFocus, "TrapFocus");
false ? TrapFocus.propTypes = {
  children: elementAcceptingRef_default,
  disableAutoFocus: import_prop_types13.default.bool,
  disableEnforceFocus: import_prop_types13.default.bool,
  disableRestoreFocus: import_prop_types13.default.bool,
  getTabbable: import_prop_types13.default.func,
  isEnabled: import_prop_types13.default.func,
  open: import_prop_types13.default.bool.isRequired
} : void 0;
if (false) {
  TrapFocus["propTypes"] = exactProp(TrapFocus.propTypes);
}
var TrapFocus_default = TrapFocus;
init_define_process();
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
__name(getModalUtilityClass, "getModalUtilityClass");
var modalUnstyledClasses = generateUtilityClasses("MuiModal", ["root", "hidden"]);
init_react_preact();
init_react_preact();
var _excluded9 = ["children", "classes", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited"];
var useUtilityClasses5 = __name((ownerState) => {
  const {
    open: open2,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open2 && exited && "hidden"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
}, "useUtilityClasses");
function getContainer2(container) {
  return typeof container === "function" ? container() : container;
}
__name(getContainer2, "getContainer");
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
__name(getHasTransition, "getHasTransition");
var defaultManager = new ModalManager();
var ModalUnstyled = forwardRef(__name(function ModalUnstyled2(props, ref) {
  var _props$ariaHidden;
  const {
    children: children2,
    classes: classesProp,
    closeAfterTransition = false,
    component = "div",
    components = {},
    componentsProps = {},
    container,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    manager = defaultManager,
    onBackdropClick,
    onClose,
    onKeyDown,
    open: open2,
    onTransitionEnter,
    onTransitionExited
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const [exited, setExited] = useState(true);
  const modal = useRef({});
  const mountNodeRef = useRef(null);
  const modalRef = useRef(null);
  const handleRef = useForkRef(modalRef, ref);
  const hasTransition = getHasTransition(props);
  const ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : true;
  const getDoc = __name(() => ownerDocument(mountNodeRef.current), "getDoc");
  const getModal = __name(() => {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  }, "getModal");
  const handleMounted = __name(() => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    modalRef.current.scrollTop = 0;
  }, "handleMounted");
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer2(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node) => {
    mountNodeRef.current = node;
    if (!node) {
      return;
    }
    if (open2 && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [manager, ariaHiddenProp]);
  useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  useEffect(() => {
    if (open2) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const ownerState = _extends({}, props, {
    classes: classesProp,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    exited,
    hideBackdrop,
    keepMounted
  });
  const classes = useUtilityClasses5(ownerState);
  const handleEnter = __name(() => {
    setExited(false);
    if (onTransitionEnter) {
      onTransitionEnter();
    }
  }, "handleEnter");
  const handleExited = __name(() => {
    setExited(true);
    if (onTransitionExited) {
      onTransitionExited();
    }
    if (closeAfterTransition) {
      handleClose();
    }
  }, "handleExited");
  const handleBackdropClick = __name((event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  }, "handleBackdropClick");
  const handleKeyDown3 = __name((event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  }, "handleKeyDown");
  const childProps = {};
  if (children2.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children2.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children2.props.onExited);
  }
  const Root = components.Root || component;
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRef,
      role: "presentation",
      onKeyDown: handleKeyDown3
    },
    className: classes.root,
    ownerState
  });
  const BackdropComponent = components.Backdrop;
  const backdropProps = useSlotProps({
    elementType: BackdropComponent,
    externalSlotProps: componentsProps.backdrop,
    additionalProps: {
      "aria-hidden": true,
      onClick: handleBackdropClick,
      open: open2
    },
    ownerState
  });
  if (!keepMounted && !open2 && (!hasTransition || exited)) {
    return null;
  }
  return e3(Portal_default, {
    ref: handlePortalRef,
    container,
    disablePortal,
    children: e3(Root, _extends({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? e3(BackdropComponent, _extends({}, backdropProps)) : null, e3(TrapFocus_default, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open: open2,
        children: cloneElement(children2, childProps)
      })]
    }))
  });
}, "ModalUnstyled"));
false ? ModalUnstyled.propTypes = {
  children: elementAcceptingRef_default.isRequired,
  classes: import_prop_types14.default.object,
  closeAfterTransition: import_prop_types14.default.bool,
  component: import_prop_types14.default.elementType,
  components: import_prop_types14.default.shape({
    Backdrop: import_prop_types14.default.elementType,
    Root: import_prop_types14.default.elementType
  }),
  componentsProps: import_prop_types14.default.shape({
    backdrop: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object]),
    root: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object])
  }),
  container: import_prop_types14.default.oneOfType([HTMLElementType, import_prop_types14.default.func]),
  disableAutoFocus: import_prop_types14.default.bool,
  disableEnforceFocus: import_prop_types14.default.bool,
  disableEscapeKeyDown: import_prop_types14.default.bool,
  disablePortal: import_prop_types14.default.bool,
  disableRestoreFocus: import_prop_types14.default.bool,
  disableScrollLock: import_prop_types14.default.bool,
  hideBackdrop: import_prop_types14.default.bool,
  keepMounted: import_prop_types14.default.bool,
  onBackdropClick: import_prop_types14.default.func,
  onClose: import_prop_types14.default.func,
  onKeyDown: import_prop_types14.default.func,
  open: import_prop_types14.default.bool.isRequired
} : void 0;
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types15 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
init_define_process();
function isOptionGroup(child) {
  return !!child.options;
}
__name(isOptionGroup, "isOptionGroup");
function getOptionsFromChildren(children2) {
  if (children2 == null) {
    return [];
  }
  const selectChildren = [];
  react_preact_default.Children.forEach(children2, (node) => {
    var _props, _props2, _element$props$disabl2;
    const nodeChildren = node == null ? void 0 : (_props = node.props) == null ? void 0 : _props.children;
    if ((node == null ? void 0 : (_props2 = node.props) == null ? void 0 : _props2.value) === void 0) {
      if (nodeChildren != null) {
        var _element$props$disabl;
        const element2 = node;
        const group = {
          options: getOptionsFromChildren(nodeChildren),
          label: element2.props.label,
          disabled: (_element$props$disabl = element2.props.disabled) != null ? _element$props$disabl : false
        };
        selectChildren.push(group);
      }
      return;
    }
    const element = node;
    const option = {
      value: element.props.value,
      label: element.props.label || element.props.children,
      disabled: (_element$props$disabl2 = element.props.disabled) != null ? _element$props$disabl2 : false
    };
    selectChildren.push(option);
  });
  return selectChildren != null ? selectChildren : [];
}
__name(getOptionsFromChildren, "getOptionsFromChildren");
function flattenOptionGroups(groupedOptions, isGroupDisabled = false) {
  let flatOptions = [];
  groupedOptions.forEach((optionOrGroup) => {
    if (isOptionGroup(optionOrGroup)) {
      flatOptions = flatOptions.concat(flattenOptionGroups(optionOrGroup.options, optionOrGroup.disabled));
    } else {
      flatOptions.push(_extends({}, optionOrGroup, {
        disabled: isGroupDisabled || optionOrGroup.disabled
      }));
    }
  });
  return flatOptions;
}
__name(flattenOptionGroups, "flattenOptionGroups");
init_define_process();
init_react_preact();
var defaultOptionStringifier2 = __name((option) => {
  const {
    label,
    value
  } = option;
  if (typeof label === "string") {
    return label;
  }
  if (typeof value === "string") {
    return value;
  }
  return String(option);
}, "defaultOptionStringifier");
function useSelect(props) {
  const {
    buttonRef: buttonRefProp,
    defaultValue,
    disabled = false,
    listboxId,
    listboxRef: listboxRefProp,
    multiple = false,
    onChange,
    onOpenChange,
    open: open2 = false,
    options,
    optionStringifier = defaultOptionStringifier2,
    value: valueProp
  } = props;
  const buttonRef = useRef(null);
  const handleButtonRef = useForkRef(buttonRefProp, buttonRef);
  const listboxRef = useRef(null);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "SelectUnstyled",
    state: "value"
  });
  const ignoreEnterKeyUp = useRef(false);
  const ignoreClick = useRef(false);
  const [listboxFocusRequested, requestListboxFocus] = useState(false);
  const focusListboxIfRequested = useCallback(() => {
    if (listboxFocusRequested && listboxRef.current != null) {
      listboxRef.current.focus();
      requestListboxFocus(false);
    }
  }, [listboxFocusRequested]);
  const updateListboxRef = __name((listboxElement) => {
    listboxRef.current = listboxElement;
    focusListboxIfRequested();
  }, "updateListboxRef");
  const handleListboxRef = useForkRef(useForkRef(listboxRefProp, listboxRef), updateListboxRef);
  useEffect(() => {
    focusListboxIfRequested();
  }, [focusListboxIfRequested]);
  useEffect(() => {
    requestListboxFocus(open2);
  }, [open2]);
  const createHandleMouseDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    otherHandlers == null ? void 0 : (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (!event.defaultPrevented && open2) {
      ignoreClick.current = true;
    }
  }, "createHandleMouseDown");
  const createHandleButtonClick = __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    otherHandlers == null ? void 0 : (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    if (!event.defaultPrevented && !ignoreClick.current) {
      onOpenChange == null ? void 0 : onOpenChange(!open2);
    }
    ignoreClick.current = false;
  }, "createHandleButtonClick");
  const createHandleButtonKeyDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    otherHandlers == null ? void 0 : (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (event.key === "Enter") {
      ignoreEnterKeyUp.current = true;
    }
    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      event.preventDefault();
      onOpenChange == null ? void 0 : onOpenChange(true);
    }
  }, "createHandleButtonKeyDown");
  const createHandleListboxKeyUp = __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    otherHandlers == null ? void 0 : (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    const closingKeys = multiple ? ["Escape"] : ["Escape", "Enter", " "];
    if (open2 && !ignoreEnterKeyUp.current && closingKeys.includes(event.key)) {
      var _buttonRef$current;
      buttonRef == null ? void 0 : (_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.focus();
    }
    ignoreEnterKeyUp.current = false;
  }, "createHandleListboxKeyUp");
  const createHandleListboxItemClick = __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic2;
    otherHandlers == null ? void 0 : (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (!multiple) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  }, "createHandleListboxItemClick");
  const createHandleListboxBlur = __name((otherHandlers) => (event) => {
    var _otherHandlers$blur;
    otherHandlers == null ? void 0 : (_otherHandlers$blur = otherHandlers.blur) == null ? void 0 : _otherHandlers$blur.call(otherHandlers, event);
    if (!event.defaultPrevented) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  }, "createHandleListboxBlur");
  const listboxReducer = __name((state, action) => {
    const newState = defaultListboxReducer(state, action);
    if (action.type === ActionTypes.keyDown && !open2 && (action.event.key === "ArrowUp" || action.event.key === "ArrowDown")) {
      return _extends({}, newState, {
        selectedValue: newState.highlightedValue
      });
    }
    if (action.type === ActionTypes.blur || action.type === ActionTypes.setValue || action.type === ActionTypes.optionsChange) {
      return _extends({}, newState, {
        highlightedValue: newState.selectedValue
      });
    }
    return newState;
  }, "listboxReducer");
  const {
    getRootProps: getButtonRootProps,
    active: buttonActive,
    focusVisible: buttonFocusVisible
  } = useButton({
    disabled,
    ref: handleButtonRef
  });
  const selectedOption = useMemo(() => {
    var _props$options$find;
    return props.multiple ? props.options.filter((o5) => value.includes(o5.value)) : (_props$options$find = props.options.find((o5) => o5.value === value)) != null ? _props$options$find : null;
  }, [props.multiple, props.options, value]);
  let useListboxParameters;
  if (props.multiple) {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: (o5) => {
        var _o$disabled;
        return (_o$disabled = o5 == null ? void 0 : o5.disabled) != null ? _o$disabled : false;
      },
      optionComparer: (o5, v5) => (o5 == null ? void 0 : o5.value) === (v5 == null ? void 0 : v5.value),
      listboxRef: handleListboxRef,
      multiple: true,
      onChange: (newOptions) => {
        const newValues = newOptions.map((o5) => o5.value);
        setValue(newValues);
        onChange == null ? void 0 : onChange(newValues);
      },
      options,
      optionStringifier,
      value: selectedOption
    };
  } else {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: (o5) => {
        var _o$disabled2;
        return (_o$disabled2 = o5 == null ? void 0 : o5.disabled) != null ? _o$disabled2 : false;
      },
      optionComparer: (o5, v5) => (o5 == null ? void 0 : o5.value) === (v5 == null ? void 0 : v5.value),
      listboxRef: handleListboxRef,
      multiple: false,
      onChange: (option) => {
        var _option$value, _option$value2;
        setValue((_option$value = option == null ? void 0 : option.value) != null ? _option$value : null);
        onChange == null ? void 0 : onChange((_option$value2 = option == null ? void 0 : option.value) != null ? _option$value2 : null);
      },
      options,
      optionStringifier,
      stateReducer: listboxReducer,
      value: selectedOption
    };
  }
  const {
    getRootProps: getListboxRootProps,
    getOptionProps: getListboxOptionProps,
    getOptionState,
    highlightedOption,
    selectedOption: listboxSelectedOption
  } = useListbox(useListboxParameters);
  const getButtonProps = __name((otherHandlers = {}) => {
    return _extends({}, getButtonRootProps(_extends({}, otherHandlers, {
      onClick: createHandleButtonClick(otherHandlers),
      onMouseDown: createHandleMouseDown(otherHandlers),
      onKeyDown: createHandleButtonKeyDown(otherHandlers)
    })), {
      "aria-expanded": open2,
      "aria-haspopup": "listbox"
    });
  }, "getButtonProps");
  const getListboxProps = __name((otherHandlers = {}) => getListboxRootProps(_extends({}, otherHandlers, {
    onBlur: createHandleListboxBlur(otherHandlers),
    onKeyUp: createHandleListboxKeyUp(otherHandlers)
  })), "getListboxProps");
  const getOptionProps = __name((option, otherHandlers = {}) => {
    return getListboxOptionProps(option, _extends({}, otherHandlers, {
      onClick: createHandleListboxItemClick(otherHandlers)
    }));
  }, "getOptionProps");
  useDebugValue({
    selectedOption: listboxSelectedOption,
    highlightedOption,
    open: open2
  });
  return {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    open: open2,
    value
  };
}
__name(useSelect, "useSelect");
var useSelect_default = useSelect;
init_define_process();
init_react_preact();
var SelectUnstyledContext = createContext(void 0);
init_define_process();
function getSelectUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiSelectUnstyled", slot);
}
__name(getSelectUnstyledUtilityClass, "getSelectUnstyledUtilityClass");
var selectUnstyledClasses = generateUtilityClasses("MuiSelectUnstyled", ["root", "button", "listbox", "popper", "active", "expanded", "disabled", "focusVisible"]);
init_react_preact();
init_react_preact();
var _excluded10 = ["autoFocus", "children", "component", "components", "componentsProps", "defaultListboxOpen", "defaultValue", "disabled", "listboxId", "listboxOpen", "onChange", "onListboxOpenChange", "value"];
function defaultRenderMultipleValues(selectedOptions) {
  return e3(p, {
    children: selectedOptions.map((o5) => o5.label).join(", ")
  });
}
__name(defaultRenderMultipleValues, "defaultRenderMultipleValues");
function useUtilityClasses6(ownerState) {
  const {
    active,
    disabled,
    open: open2,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active", open2 && "expanded"],
    listbox: ["listbox", disabled && "disabled"],
    popper: ["popper"]
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
__name(useUtilityClasses6, "useUtilityClasses");
var MultiSelectUnstyled = forwardRef(__name(function MultiSelectUnstyled2(props, ref) {
  var _props$renderValue, _ref, _components$Listbox, _components$Popper;
  const {
    autoFocus,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    defaultListboxOpen = false,
    defaultValue = [],
    disabled: disabledProp,
    listboxId,
    listboxOpen: listboxOpenProp,
    onChange,
    onListboxOpenChange,
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const renderValue = (_props$renderValue = props.renderValue) != null ? _props$renderValue : defaultRenderMultipleValues;
  const [groupedOptions, setGroupedOptions] = useState([]);
  const options = useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
  const [listboxOpen, setListboxOpen] = useControlled({
    controlled: listboxOpenProp,
    default: defaultListboxOpen,
    name: "MultiSelectUnstyled",
    state: "listboxOpen"
  });
  useEffect(() => {
    setGroupedOptions(getOptionsFromChildren(children2));
  }, [children2]);
  const [buttonDefined, setButtonDefined] = useState(false);
  const buttonRef = useRef(null);
  const listboxRef = useRef(null);
  const Button3 = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
  const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
  const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled_default;
  const handleButtonRefChange = __name((element) => {
    buttonRef.current = element;
    if (element != null) {
      setButtonDefined(true);
    }
  }, "handleButtonRefChange");
  const handleButtonRef = useForkRef(ref, handleButtonRefChange);
  useEffect(() => {
    if (autoFocus) {
      buttonRef.current.focus();
    }
  }, [autoFocus]);
  const handleOpenChange = __name((isOpen) => {
    setListboxOpen(isOpen);
    onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
  }, "handleOpenChange");
  const {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    value
  } = useSelect_default({
    buttonRef: handleButtonRef,
    defaultValue,
    disabled: disabledProp,
    listboxId,
    multiple: true,
    onChange,
    onOpenChange: handleOpenChange,
    open: listboxOpen,
    options,
    value: valueProp
  });
  const ownerState = _extends({}, props, {
    active: buttonActive,
    defaultListboxOpen,
    disabled,
    focusVisible: buttonFocusVisible,
    open: listboxOpen,
    renderValue,
    value
  });
  const classes = useUtilityClasses6(ownerState);
  const selectedOptions = useMemo(() => {
    if (value == null) {
      return [];
    }
    return options.filter((o5) => value.includes(o5.value));
  }, [options, value]);
  const buttonProps = useSlotProps({
    elementType: Button3,
    getSlotProps: getButtonProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    ownerState,
    className: classes.root
  });
  const listboxProps = useSlotProps({
    elementType: ListboxRoot,
    getSlotProps: getListboxProps,
    externalSlotProps: componentsProps.listbox,
    additionalProps: {
      ref: listboxRef
    },
    ownerState,
    className: classes.listbox
  });
  const popperProps = useSlotProps({
    elementType: Popper,
    externalSlotProps: componentsProps.popper,
    additionalProps: {
      anchorEl: buttonRef.current,
      disablePortal: true,
      open: listboxOpen,
      placement: "bottom-start",
      role: void 0
    },
    ownerState,
    className: classes.popper
  });
  const context = {
    getOptionProps,
    getOptionState,
    listboxRef
  };
  return e3(p, {
    children: [e3(Button3, _extends({}, buttonProps, {
      children: renderValue(selectedOptions)
    })), buttonDefined && e3(Popper, _extends({}, popperProps, {
      children: e3(ListboxRoot, _extends({}, listboxProps, {
        children: e3(SelectUnstyledContext.Provider, {
          value: context,
          children: children2
        })
      }))
    }))]
  });
}, "MultiSelectUnstyled"));
false ? MultiSelectUnstyled.propTypes = {
  autoFocus: import_prop_types15.default.bool,
  children: import_prop_types15.default.node,
  component: import_prop_types15.default.elementType,
  components: import_prop_types15.default.shape({
    Listbox: import_prop_types15.default.elementType,
    Popper: import_prop_types15.default.elementType,
    Root: import_prop_types15.default.elementType
  }),
  componentsProps: import_prop_types15.default.shape({
    listbox: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object]),
    popper: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object]),
    root: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object])
  }),
  defaultListboxOpen: import_prop_types15.default.bool,
  defaultValue: import_prop_types15.default.array,
  disabled: import_prop_types15.default.bool,
  listboxId: import_prop_types15.default.string,
  listboxOpen: import_prop_types15.default.bool,
  onChange: import_prop_types15.default.func,
  onListboxOpenChange: import_prop_types15.default.func,
  renderValue: import_prop_types15.default.func,
  value: import_prop_types15.default.array
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types16 = __toESM(require_prop_types());
init_react_preact();
false ? NoSsr.propTypes = {
  children: import_prop_types16.default.node,
  defer: import_prop_types16.default.bool,
  fallback: import_prop_types16.default.node
} : void 0;
if (false) {
  NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
}
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types17 = __toESM(require_prop_types());
init_define_process();
function getOptionGroupUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiOptionGroupUnstyled", slot);
}
__name(getOptionGroupUnstyledUtilityClass, "getOptionGroupUnstyledUtilityClass");
var optionGroupUnstyledClasses = generateUtilityClasses("MuiOptionGroupUnstyled", ["root", "label", "list"]);
init_react_preact();
init_react_preact();
var _excluded11 = ["component", "components", "disabled", "componentsProps"];
function useUtilityClasses7(disabled) {
  const slots = {
    root: ["root", disabled && "disabled"],
    label: ["label"],
    list: ["list"]
  };
  return composeClasses(slots, getOptionGroupUnstyledUtilityClass, {});
}
__name(useUtilityClasses7, "useUtilityClasses");
var OptionGroupUnstyled = react_preact_default.forwardRef(__name(function OptionGroupUnstyled2(props, ref) {
  const {
    component,
    components = {},
    disabled = false,
    componentsProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const Root = component || (components == null ? void 0 : components.Root) || "li";
  const Label = (components == null ? void 0 : components.Label) || "span";
  const List2 = (components == null ? void 0 : components.List) || "ul";
  const classes = useUtilityClasses7(disabled);
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref
    },
    ownerState: props,
    className: classes.root
  });
  const labelProps = useSlotProps({
    elementType: Label,
    externalSlotProps: componentsProps.label,
    ownerState: props,
    className: classes.label
  });
  const listProps = useSlotProps({
    elementType: List2,
    externalSlotProps: componentsProps.list,
    ownerState: props,
    className: classes.list
  });
  return e3(Root, _extends({}, rootProps, {
    children: [e3(Label, _extends({}, labelProps, {
      children: props.label
    })), e3(List2, _extends({}, listProps, {
      children: props.children
    }))]
  }));
}, "OptionGroupUnstyled"));
false ? OptionGroupUnstyled.propTypes = {
  children: import_prop_types17.default.node,
  component: import_prop_types17.default.elementType,
  components: import_prop_types17.default.shape({
    Label: import_prop_types17.default.elementType,
    List: import_prop_types17.default.elementType,
    Root: import_prop_types17.default.elementType
  }),
  componentsProps: import_prop_types17.default.shape({
    label: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object]),
    list: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object]),
    root: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object])
  }),
  disabled: import_prop_types17.default.bool,
  label: import_prop_types17.default.node
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types18 = __toESM(require_prop_types());
init_define_process();
function getOptionUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiOptionUnstyled", slot);
}
__name(getOptionUnstyledUtilityClass, "getOptionUnstyledUtilityClass");
var optionUnstyledClasses = generateUtilityClasses("MuiOptionUnstyled", ["root", "disabled", "selected", "highlighted"]);
init_react_preact();
var _excluded12 = ["children", "component", "components", "componentsProps", "disabled", "value", "label"];
function useUtilityClasses8(ownerState) {
  const {
    disabled,
    highlighted,
    selected
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", highlighted && "highlighted", selected && "selected"]
  };
  return composeClasses(slots, getOptionUnstyledUtilityClass, {});
}
__name(useUtilityClasses8, "useUtilityClasses");
var OptionUnstyled = react_preact_default.forwardRef(__name(function OptionUnstyled2(props, ref) {
  const {
    children: children2,
    component,
    components = {},
    componentsProps = {},
    disabled,
    value,
    label
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const selectContext = react_preact_default.useContext(SelectUnstyledContext);
  if (!selectContext) {
    throw new Error("OptionUnstyled must be used within a SelectUnstyled");
  }
  const Root = component || components.Root || "li";
  const selectOption = {
    value,
    label: label || children2,
    disabled
  };
  const optionState = selectContext.getOptionState(selectOption);
  const optionProps = selectContext.getOptionProps(selectOption);
  const listboxRef = selectContext.listboxRef;
  const ownerState = _extends({}, props, optionState);
  const optionRef = react_preact_default.useRef(null);
  const handleRef = useForkRef(ref, optionRef);
  react_preact_default.useEffect(() => {
    if (optionState.highlighted) {
      if (!listboxRef.current || !optionRef.current) {
        return;
      }
      const listboxClientRect = listboxRef.current.getBoundingClientRect();
      const optionClientRect = optionRef.current.getBoundingClientRect();
      if (optionClientRect.top < listboxClientRect.top) {
        listboxRef.current.scrollTop -= listboxClientRect.top - optionClientRect.top;
      } else if (optionClientRect.bottom > listboxClientRect.bottom) {
        listboxRef.current.scrollTop += optionClientRect.bottom - listboxClientRect.bottom;
      }
    }
  }, [optionState.highlighted, listboxRef]);
  const classes = useUtilityClasses8(ownerState);
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: _extends({}, optionProps, {
      ref: handleRef
    }),
    className: classes.root,
    ownerState
  });
  return e3(Root, _extends({}, rootProps, {
    children: children2
  }));
}, "OptionUnstyled"));
false ? OptionUnstyled.propTypes = {
  children: import_prop_types18.default.node,
  component: import_prop_types18.default.elementType,
  components: import_prop_types18.default.shape({
    Root: import_prop_types18.default.elementType
  }),
  componentsProps: import_prop_types18.default.shape({
    root: import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object])
  }),
  disabled: import_prop_types18.default.bool,
  label: import_prop_types18.default.string,
  value: import_prop_types18.default.any.isRequired
} : void 0;
var OptionUnstyled_default = react_preact_default.memo(OptionUnstyled);
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types19 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
var _excluded13 = ["autoFocus", "children", "component", "components", "componentsProps", "defaultValue", "defaultListboxOpen", "disabled", "listboxId", "listboxOpen", "onChange", "onListboxOpenChange", "renderValue", "value"];
function defaultRenderSingleValue(selectedOption) {
  var _selectedOption$label;
  return (_selectedOption$label = selectedOption == null ? void 0 : selectedOption.label) != null ? _selectedOption$label : "";
}
__name(defaultRenderSingleValue, "defaultRenderSingleValue");
function useUtilityClasses9(ownerState) {
  const {
    active,
    disabled,
    open: open2,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active", open2 && "expanded"],
    listbox: ["listbox", disabled && "disabled"],
    popper: ["popper"]
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
__name(useUtilityClasses9, "useUtilityClasses");
var SelectUnstyled = forwardRef(__name(function SelectUnstyled2(props, ref) {
  var _ref, _components$Listbox, _components$Popper;
  const {
    autoFocus,
    children: children2,
    component,
    components = {},
    componentsProps = {},
    defaultValue,
    defaultListboxOpen = false,
    disabled: disabledProp,
    listboxId,
    listboxOpen: listboxOpenProp,
    onChange,
    onListboxOpenChange,
    renderValue: renderValueProp,
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const renderValue = renderValueProp != null ? renderValueProp : defaultRenderSingleValue;
  const [groupedOptions, setGroupedOptions] = useState([]);
  const options = useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
  const [listboxOpen, setListboxOpen] = useControlled({
    controlled: listboxOpenProp,
    default: defaultListboxOpen,
    name: "SelectUnstyled",
    state: "listboxOpen"
  });
  useEffect(() => {
    setGroupedOptions(getOptionsFromChildren(children2));
  }, [children2]);
  const [buttonDefined, setButtonDefined] = useState(false);
  const buttonRef = useRef(null);
  const listboxRef = useRef(null);
  const Button3 = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
  const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
  const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled_default;
  const handleButtonRefChange = __name((element) => {
    buttonRef.current = element;
    if (element != null) {
      setButtonDefined(true);
    }
  }, "handleButtonRefChange");
  const handleButtonRef = useForkRef(ref, handleButtonRefChange);
  useEffect(() => {
    if (autoFocus) {
      buttonRef.current.focus();
    }
  }, [autoFocus]);
  const handleOpenChange = __name((isOpen) => {
    setListboxOpen(isOpen);
    onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
  }, "handleOpenChange");
  const {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    value
  } = useSelect_default({
    buttonRef: handleButtonRef,
    defaultValue,
    disabled: disabledProp,
    listboxId,
    multiple: false,
    onChange,
    onOpenChange: handleOpenChange,
    open: listboxOpen,
    options,
    value: valueProp
  });
  const ownerState = _extends({}, props, {
    active: buttonActive,
    defaultListboxOpen,
    disabled,
    focusVisible: buttonFocusVisible,
    open: listboxOpen,
    renderValue,
    value
  });
  const classes = useUtilityClasses9(ownerState);
  const selectedOptions = useMemo(() => {
    return options.find((o5) => value === o5.value);
  }, [options, value]);
  const buttonProps = useSlotProps({
    elementType: Button3,
    getSlotProps: getButtonProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    ownerState,
    className: classes.root
  });
  const listboxProps = useSlotProps({
    elementType: ListboxRoot,
    getSlotProps: getListboxProps,
    externalSlotProps: componentsProps.listbox,
    additionalProps: {
      ref: listboxRef
    },
    ownerState,
    className: classes.listbox
  });
  const popperProps = useSlotProps({
    elementType: Popper,
    externalSlotProps: componentsProps.popper,
    additionalProps: {
      anchorEl: buttonRef.current,
      disablePortal: true,
      open: listboxOpen,
      placement: "bottom-start",
      role: void 0
    },
    ownerState,
    className: classes.popper
  });
  const context = {
    getOptionProps,
    getOptionState,
    listboxRef
  };
  return e3(p, {
    children: [e3(Button3, _extends({}, buttonProps, {
      children: renderValue(selectedOptions)
    })), buttonDefined && e3(Popper, _extends({}, popperProps, {
      children: e3(ListboxRoot, _extends({}, listboxProps, {
        children: e3(SelectUnstyledContext.Provider, {
          value: context,
          children: children2
        })
      }))
    }))]
  });
}, "SelectUnstyled"));
false ? SelectUnstyled.propTypes = {
  autoFocus: import_prop_types19.default.bool,
  children: import_prop_types19.default.node,
  component: import_prop_types19.default.elementType,
  components: import_prop_types19.default.shape({
    Listbox: import_prop_types19.default.elementType,
    Popper: import_prop_types19.default.elementType,
    Root: import_prop_types19.default.elementType
  }),
  componentsProps: import_prop_types19.default.shape({
    listbox: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
    popper: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
    root: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object])
  }),
  defaultListboxOpen: import_prop_types19.default.bool,
  defaultValue: import_prop_types19.default.any,
  disabled: import_prop_types19.default.bool,
  listboxId: import_prop_types19.default.string,
  listboxOpen: import_prop_types19.default.bool,
  onChange: import_prop_types19.default.func,
  onListboxOpenChange: import_prop_types19.default.func,
  renderValue: import_prop_types19.default.func,
  value: import_prop_types19.default.any
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types21 = __toESM(require_prop_types());
init_define_process();
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
__name(getSliderUtilityClass, "getSliderUtilityClass");
var sliderUnstyledClasses = generateUtilityClasses("MuiSlider", ["root", "active", "focusVisible", "disabled", "dragging", "marked", "vertical", "trackInverted", "trackFalse", "rail", "track", "mark", "markActive", "markLabel", "markLabelActive", "thumb", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel"]);
var sliderUnstyledClasses_default = sliderUnstyledClasses;
init_define_process();
init_react_preact();
var import_prop_types20 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
var useValueLabelClasses = __name((props) => {
  const {
    open: open2
  } = props;
  const utilityClasses = {
    offset: clsx_m_default(open2 && sliderUnstyledClasses_default.valueLabelOpen),
    circle: sliderUnstyledClasses_default.valueLabelCircle,
    label: sliderUnstyledClasses_default.valueLabelLabel
  };
  return utilityClasses;
}, "useValueLabelClasses");
function SliderValueLabelUnstyled(props) {
  const {
    children: children2,
    className,
    value,
    theme
  } = props;
  const classes = useValueLabelClasses(props);
  return cloneElement(children2, {
    className: clsx_m_default(children2.props.className)
  }, e3(p, {
    children: [children2.props.children, e3("span", {
      className: clsx_m_default(classes.offset, className),
      theme,
      "aria-hidden": true,
      children: e3("span", {
        className: classes.circle,
        children: e3("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
__name(SliderValueLabelUnstyled, "SliderValueLabelUnstyled");
false ? SliderValueLabelUnstyled.propTypes = {
  children: import_prop_types20.default.element.isRequired,
  className: import_prop_types20.default.string,
  theme: import_prop_types20.default.any,
  value: import_prop_types20.default.node
} : void 0;
init_define_process();
init_react_preact();
var INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a5, b5) {
  return a5 - b5;
}
__name(asc, "asc");
function clamp4(value, min22, max22) {
  if (value == null) {
    return min22;
  }
  return Math.min(Math.max(min22, value), max22);
}
__name(clamp4, "clamp");
function findClosest(values3, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values3.reduce((acc, value, index) => {
    const distance2 = Math.abs(currentValue - value);
    if (acc === null || distance2 < acc.distance || distance2 === acc.distance) {
      return {
        distance: distance2,
        index
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
__name(findClosest, "findClosest");
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i4 = 0; i4 < touchEvent.changedTouches.length; i4 += 1) {
      const touch = touchEvent.changedTouches[i4];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
__name(trackFinger, "trackFinger");
function valueToPercent(value, min22, max22) {
  return (value - min22) * 100 / (max22 - min22);
}
__name(valueToPercent, "valueToPercent");
function percentToValue(percent2, min22, max22) {
  return (max22 - min22) * percent2 + min22;
}
__name(percentToValue, "percentToValue");
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
__name(getDecimalPrecision, "getDecimalPrecision");
function roundValueToStep(value, step, min22) {
  const nearest = Math.round((value - min22) / step) * step + min22;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
__name(roundValueToStep, "roundValueToStep");
function setValueIndex({
  values: values3,
  newValue,
  index
}) {
  const output = values3.slice();
  output[index] = newValue;
  return output.sort(asc);
}
__name(setValueIndex, "setValueIndex");
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = ownerDocument(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
__name(focusThumb, "focusThumb");
var axisProps = {
  horizontal: {
    offset: (percent2) => ({
      left: `${percent2}%`
    }),
    leap: (percent2) => ({
      width: `${percent2}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent2) => ({
      right: `${percent2}%`
    }),
    leap: (percent2) => ({
      width: `${percent2}%`
    })
  },
  vertical: {
    offset: (percent2) => ({
      bottom: `${percent2}%`
    }),
    leap: (percent2) => ({
      height: `${percent2}%`
    })
  }
};
var Identity = __name((x5) => x5, "Identity");
var cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
__name(doesSupportTouchActionNone, "doesSupportTouchActionNone");
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max22 = 100,
    min: min22 = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    ref,
    scale: scale2 = Identity,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = useRef();
  const [active, setActive] = useState(-1);
  const [open2, setOpen] = useState(-1);
  const [dragging, setDragging] = useState(false);
  const moveCount = useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min22,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values3 = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values3 = values3.map((value) => clamp4(value, min22, max22));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max22 - min22) / step) + 1)].map((_22, index) => ({
    value: min22 + step * index
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusedThumbIndex, setFocusedThumbIndex] = useState(-1);
  const sliderRef = useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef = useForkRef(ref, handleFocusRef);
  const createHandleHiddenInputFocus = __name((otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    const index = Number(event.currentTarget.getAttribute("data-index"));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index);
    }
    setOpen(index);
    otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
  }, "createHandleHiddenInputFocus");
  const createHandleHiddenInputBlur = __name((otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  }, "createHandleHiddenInputBlur");
  useEnhancedEffect_default(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = __name((otherHandlers) => (event) => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    const value = values3[index];
    const marksIndex = marksValues.indexOf(value);
    let newValue = event.target.valueAsNumber;
    if (marks && step == null) {
      newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
    }
    newValue = clamp4(newValue, min22, max22);
    if (marks && step == null) {
      const currentMarkIndex = marksValues.indexOf(values3[index]);
      newValue = newValue < values3[index] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
    }
    if (range) {
      if (disableSwap) {
        newValue = clamp4(newValue, values3[index - 1] || -Infinity, values3[index + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values3,
        newValue,
        index
      });
      let activeIndex = index;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index);
    if (handleChange) {
      handleChange(event, newValue, index);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  }, "createHandleHiddenInputChange");
  const previousIndex = useRef();
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = __name(({
    finger,
    move = false,
    values: values222
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width: width2,
      height: height2,
      bottom: bottom3,
      left: left3
    } = slider.getBoundingClientRect();
    let percent2;
    if (axis.indexOf("vertical") === 0) {
      percent2 = (bottom3 - finger.y) / height2;
    } else {
      percent2 = (finger.x - left3) / width2;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent2 = 1 - percent2;
    }
    let newValue;
    newValue = percentToValue(percent2, min22, max22);
    if (step) {
      newValue = roundValueToStep(newValue, step, min22);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp4(newValue, min22, max22);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values222, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp4(newValue, values222[activeIndex - 1] || -Infinity, values222[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values222,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  }, "getFingerNewValue");
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true,
      values: values3
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true,
      values: values3
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values: values3
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove);
    doc.addEventListener("touchend", handleTouchEnd);
  });
  const stopListening = useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values: values3
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove);
    doc.addEventListener("mouseup", handleTouchEnd);
  }, "createHandleMouseDown");
  const trackOffset = valueToPercent(range ? values3[0] : min22, min22, max22);
  const trackLeap = valueToPercent(values3[values3.length - 1], min22, max22) - trackOffset;
  const getRootProps = __name((otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };
    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);
    return _extends({
      ref: handleRef
    }, mergedEventHandlers);
  }, "getRootProps");
  const createHandleMouseOver = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index);
  }, "createHandleMouseOver");
  const createHandleMouseLeave = __name((otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  }, "createHandleMouseLeave");
  const getThumbProps = __name((otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };
    return _extends({}, otherHandlers, ownEventHandlers);
  }, "getThumbProps");
  const getHiddenInputProps = __name((otherHandlers = {}) => {
    var _parameters$step;
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };
    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);
    return _extends({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale2(max22),
      "aria-valuemin": scale2(min22),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: (_parameters$step = parameters.step) != null ? _parameters$step : void 0,
      disabled
    }, mergedEventHandlers, {
      style: _extends({}, visuallyHidden_default, {
        direction: isRtl ? "rtl" : "ltr",
        width: "100%",
        height: "100%"
      })
    });
  }, "getHiddenInputProps");
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open: open2,
    range,
    trackLeap,
    trackOffset,
    values: values3
  };
}
__name(useSlider, "useSlider");
init_react_preact();
init_react_preact();
var _excluded14 = ["aria-label", "aria-valuetext", "className", "component", "classes", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "scale", "step", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat", "isRtl", "components", "componentsProps"];
var Identity2 = __name((x5) => x5, "Identity");
var useUtilityClasses10 = __name((ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse"],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled"],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
}, "useUtilityClasses");
var Forward = __name(({
  children: children2
}) => children2, "Forward");
var SliderUnstyled = forwardRef(__name(function SliderUnstyled2(props, ref) {
  var _ref, _components$Rail, _components$Track, _components$Thumb, _components$ValueLabe, _components$Mark, _components$MarkLabel;
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    className,
    component,
    classes: classesProp,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max22 = 100,
    min: min22 = 0,
    orientation = "horizontal",
    scale: scale2 = Identity2,
    step = 1,
    track = "normal",
    valueLabelDisplay = "off",
    valueLabelFormat = Identity2,
    isRtl = false,
    components = {},
    componentsProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const ownerState = _extends({}, props, {
    marks: marksProp,
    classes: classesProp,
    disabled,
    isRtl,
    max: max22,
    min: min22,
    orientation,
    scale: scale2,
    step,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open: open2,
    active,
    axis,
    range,
    focusedThumbIndex,
    dragging,
    marks,
    values: values3,
    trackOffset,
    trackLeap
  } = useSlider(_extends({}, ownerState, {
    ref
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses10(ownerState);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "span";
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    ownerState,
    className: [classes.root, className]
  });
  const Rail = (_components$Rail = components.Rail) != null ? _components$Rail : "span";
  const railProps = useSlotProps({
    elementType: Rail,
    externalSlotProps: componentsProps.rail,
    ownerState,
    className: classes.rail
  });
  const Track = (_components$Track = components.Track) != null ? _components$Track : "span";
  const trackProps = useSlotProps({
    elementType: Track,
    externalSlotProps: componentsProps.track,
    additionalProps: {
      style: _extends({}, axisProps2[axis].offset(trackOffset), axisProps2[axis].leap(trackLeap))
    },
    ownerState,
    className: classes.track
  });
  const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : "span";
  const thumbProps = useSlotProps({
    elementType: Thumb,
    getSlotProps: getThumbProps,
    externalSlotProps: componentsProps.thumb,
    ownerState
  });
  const ValueLabel = (_components$ValueLabe = components.ValueLabel) != null ? _components$ValueLabe : SliderValueLabelUnstyled;
  const valueLabelProps = useSlotProps({
    elementType: ValueLabel,
    externalSlotProps: componentsProps.valueLabel,
    ownerState
  });
  const Mark = (_components$Mark = components.Mark) != null ? _components$Mark : "span";
  const markProps = useSlotProps({
    elementType: Mark,
    externalSlotProps: componentsProps.mark,
    ownerState,
    className: classes.mark
  });
  const MarkLabel = (_components$MarkLabel = components.MarkLabel) != null ? _components$MarkLabel : "span";
  const markLabelProps = useSlotProps({
    elementType: MarkLabel,
    externalSlotProps: componentsProps.markLabel,
    ownerState
  });
  const Input = components.Input || "input";
  const inputProps = useSlotProps({
    elementType: Input,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: componentsProps.input,
    ownerState
  });
  return e3(Root, _extends({}, rootProps, {
    children: [e3(Rail, _extends({}, railProps)), e3(Track, _extends({}, trackProps)), marks.filter((mark) => mark.value >= min22 && mark.value <= max22).map((mark, index) => {
      const percent2 = valueToPercent(mark.value, min22, max22);
      const style4 = axisProps2[axis].offset(percent2);
      let markActive;
      if (track === false) {
        markActive = values3.indexOf(mark.value) !== -1;
      } else {
        markActive = track === "normal" && (range ? mark.value >= values3[0] && mark.value <= values3[values3.length - 1] : mark.value <= values3[0]) || track === "inverted" && (range ? mark.value <= values3[0] || mark.value >= values3[values3.length - 1] : mark.value >= values3[0]);
      }
      return e3(p, {
        children: [e3(Mark, _extends({
          "data-index": index
        }, markProps, !isHostComponent_default(Mark) && {
          markActive
        }, {
          style: _extends({}, style4, markProps.style),
          className: clsx_m_default(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? e3(MarkLabel, _extends({
          "aria-hidden": true,
          "data-index": index
        }, markLabelProps, !isHostComponent_default(MarkLabel) && {
          markLabelActive: markActive
        }, {
          style: _extends({}, style4, markLabelProps.style),
          className: clsx_m_default(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, mark.value);
    }), values3.map((value, index) => {
      const percent2 = valueToPercent(value, min22, max22);
      const style4 = axisProps2[axis].offset(percent2);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabel;
      return e3(p, {
        children: e3(ValueLabelComponent, _extends({}, !isHostComponent_default(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale2(value), index) : valueLabelFormat,
          index,
          open: open2 === index || active === index || valueLabelDisplay === "on",
          disabled
        }, valueLabelProps, {
          className: clsx_m_default(classes.valueLabel, valueLabelProps.className),
          children: e3(Thumb, _extends({
            "data-index": index,
            "data-focusvisible": focusedThumbIndex === index
          }, thumbProps, {
            className: clsx_m_default(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
            style: _extends({}, style4, {
              pointerEvents: disableSwap && active !== index ? "none" : void 0
            }, thumbProps.style),
            children: e3(Input, _extends({
              "data-index": index,
              "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
              "aria-valuenow": scale2(value),
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale2(value), index) : ariaValuetext,
              value: values3[index]
            }, inputProps))
          }))
        }))
      }, index);
    })]
  }));
}, "SliderUnstyled"));
false ? SliderUnstyled.propTypes = {
  "aria-label": chainPropTypes(import_prop_types21.default.string, (props) => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props["aria-label"] != null) {
      return new Error("MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.");
    }
    return null;
  }),
  "aria-labelledby": import_prop_types21.default.string,
  "aria-valuetext": chainPropTypes(import_prop_types21.default.string, (props) => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props["aria-valuetext"] != null) {
      return new Error("MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.");
    }
    return null;
  }),
  children: import_prop_types21.default.node,
  classes: import_prop_types21.default.object,
  className: import_prop_types21.default.string,
  component: import_prop_types21.default.elementType,
  components: import_prop_types21.default.shape({
    Input: import_prop_types21.default.elementType,
    Mark: import_prop_types21.default.elementType,
    MarkLabel: import_prop_types21.default.elementType,
    Rail: import_prop_types21.default.elementType,
    Root: import_prop_types21.default.elementType,
    Thumb: import_prop_types21.default.elementType,
    Track: import_prop_types21.default.elementType,
    ValueLabel: import_prop_types21.default.elementType
  }),
  componentsProps: import_prop_types21.default.shape({
    input: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    mark: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    markLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    rail: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    root: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    thumb: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    track: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
    valueLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.shape({
      children: import_prop_types21.default.element,
      className: import_prop_types21.default.string,
      components: import_prop_types21.default.shape({
        Root: import_prop_types21.default.elementType
      }),
      open: import_prop_types21.default.bool,
      style: import_prop_types21.default.object,
      value: import_prop_types21.default.number,
      valueLabelDisplay: import_prop_types21.default.oneOf(["auto", "off", "on"])
    })])
  }),
  defaultValue: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.number), import_prop_types21.default.number]),
  disabled: import_prop_types21.default.bool,
  disableSwap: import_prop_types21.default.bool,
  getAriaLabel: import_prop_types21.default.func,
  getAriaValueText: import_prop_types21.default.func,
  isRtl: import_prop_types21.default.bool,
  marks: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.shape({
    label: import_prop_types21.default.node,
    value: import_prop_types21.default.number.isRequired
  })), import_prop_types21.default.bool]),
  max: import_prop_types21.default.number,
  min: import_prop_types21.default.number,
  name: import_prop_types21.default.string,
  onChange: import_prop_types21.default.func,
  onChangeCommitted: import_prop_types21.default.func,
  orientation: import_prop_types21.default.oneOf(["horizontal", "vertical"]),
  scale: import_prop_types21.default.func,
  step: import_prop_types21.default.number,
  tabIndex: import_prop_types21.default.number,
  track: import_prop_types21.default.oneOf(["inverted", "normal", false]),
  value: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.number), import_prop_types21.default.number]),
  valueLabelDisplay: import_prop_types21.default.oneOf(["auto", "off", "on"]),
  valueLabelFormat: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.string])
} : void 0;
var SliderUnstyled_default = SliderUnstyled;
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types22 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
function useSwitch(props) {
  const {
    checked: checkedProp,
    defaultChecked,
    disabled,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly,
    required
  } = props;
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "Switch",
    state: "checked"
  });
  const createHandleInputChange = __name((otherProps) => (event) => {
    var _otherProps$onChange;
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    setCheckedState(event.target.checked);
    onChange == null ? void 0 : onChange(event);
    (_otherProps$onChange = otherProps.onChange) == null ? void 0 : _otherProps$onChange.call(otherProps, event);
  }, "createHandleInputChange");
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const inputRef = useRef(null);
  const createHandleFocus = __name((otherProps) => (event) => {
    var _otherProps$onFocus;
    if (!inputRef.current) {
      inputRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      onFocusVisible == null ? void 0 : onFocusVisible(event);
    }
    onFocus == null ? void 0 : onFocus(event);
    (_otherProps$onFocus = otherProps.onFocus) == null ? void 0 : _otherProps$onFocus.call(otherProps, event);
  }, "createHandleFocus");
  const createHandleBlur = __name((otherProps) => (event) => {
    var _otherProps$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    onBlur == null ? void 0 : onBlur(event);
    (_otherProps$onBlur = otherProps.onBlur) == null ? void 0 : _otherProps$onBlur.call(otherProps, event);
  }, "createHandleBlur");
  const handleRefChange = useForkRef(focusVisibleRef, inputRef);
  const getInputProps = __name((otherProps = {}) => _extends({
    checked: checkedProp,
    defaultChecked,
    disabled,
    readOnly,
    ref: handleRefChange,
    required,
    type: "checkbox"
  }, otherProps, {
    onChange: createHandleInputChange(otherProps),
    onFocus: createHandleFocus(otherProps),
    onBlur: createHandleBlur(otherProps)
  }), "getInputProps");
  return {
    checked,
    disabled: Boolean(disabled),
    focusVisible,
    getInputProps,
    readOnly: Boolean(readOnly)
  };
}
__name(useSwitch, "useSwitch");
init_define_process();
function getSwitchUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
__name(getSwitchUnstyledUtilityClass, "getSwitchUnstyledUtilityClass");
var switchUnstyledClasses = generateUtilityClasses("MuiSwitch", ["root", "input", "track", "thumb", "checked", "disabled", "focusVisible", "readOnly"]);
init_react_preact();
init_react_preact();
var _excluded15 = ["checked", "component", "components", "componentsProps", "defaultChecked", "disabled", "onBlur", "onChange", "onFocus", "onFocusVisible", "readOnly", "required"];
var useUtilityClasses11 = __name((ownerState) => {
  const {
    checked,
    disabled,
    focusVisible,
    readOnly
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", focusVisible && "focusVisible", readOnly && "readOnly"],
    thumb: ["thumb"],
    input: ["input"],
    track: ["track"]
  };
  return composeClasses(slots, getSwitchUnstyledUtilityClass, {});
}, "useUtilityClasses");
var SwitchUnstyled = forwardRef(__name(function SwitchUnstyled2(props, ref) {
  var _ref, _components$Thumb, _components$Input, _components$Track;
  const {
    checked: checkedProp,
    component,
    components = {},
    componentsProps = {},
    defaultChecked,
    disabled: disabledProp,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly: readOnlyProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const useSwitchProps = {
    checked: checkedProp,
    defaultChecked,
    disabled: disabledProp,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly: readOnlyProp
  };
  const {
    getInputProps,
    checked,
    disabled,
    focusVisible,
    readOnly
  } = useSwitch(useSwitchProps);
  const ownerState = _extends({}, props, {
    checked,
    disabled,
    focusVisible,
    readOnly
  });
  const classes = useUtilityClasses11(ownerState);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "span";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref
    },
    ownerState,
    className: classes.root
  });
  const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : "span";
  const thumbProps = useSlotProps({
    elementType: Thumb,
    externalSlotProps: componentsProps.thumb,
    ownerState,
    className: classes.thumb
  });
  const Input = (_components$Input = components.Input) != null ? _components$Input : "input";
  const inputProps = useSlotProps({
    elementType: Input,
    getSlotProps: getInputProps,
    externalSlotProps: componentsProps.input,
    ownerState,
    className: classes.input
  });
  const Track = components.Track === null ? () => null : (_components$Track = components.Track) != null ? _components$Track : "span";
  const trackProps = useSlotProps({
    elementType: Track,
    externalSlotProps: componentsProps.track,
    ownerState,
    className: classes.track
  });
  return e3(Root, _extends({}, rootProps, {
    children: [e3(Track, _extends({}, trackProps)), e3(Thumb, _extends({}, thumbProps)), e3(Input, _extends({}, inputProps))]
  }));
}, "SwitchUnstyled"));
false ? SwitchUnstyled.propTypes = {
  checked: import_prop_types22.default.bool,
  children: import_prop_types22.default.node,
  component: import_prop_types22.default.elementType,
  components: import_prop_types22.default.shape({
    Input: import_prop_types22.default.elementType,
    Root: import_prop_types22.default.elementType,
    Thumb: import_prop_types22.default.elementType,
    Track: import_prop_types22.default.oneOfType([import_prop_types22.default.elementType, import_prop_types22.default.oneOf([null])])
  }),
  componentsProps: import_prop_types22.default.shape({
    input: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object]),
    root: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object]),
    thumb: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object]),
    track: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object])
  }),
  defaultChecked: import_prop_types22.default.bool,
  disabled: import_prop_types22.default.bool,
  onBlur: import_prop_types22.default.func,
  onChange: import_prop_types22.default.func,
  onFocus: import_prop_types22.default.func,
  onFocusVisible: import_prop_types22.default.func,
  readOnly: import_prop_types22.default.bool,
  required: import_prop_types22.default.bool
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types24 = __toESM(require_prop_types());
init_define_process();
function getTabPanelUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabPanelUnstyled", slot);
}
__name(getTabPanelUnstyledUtilityClass, "getTabPanelUnstyledUtilityClass");
var tabPanelUnstyledClasses = generateUtilityClasses("TabPanelUnstyled", ["root", "hidden"]);
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types23 = __toESM(require_prop_types());
init_define_process();
function getTabsUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsUnstyled", slot);
}
__name(getTabsUnstyledUtilityClass, "getTabsUnstyledUtilityClass");
var tabsUnstyledClasses = generateUtilityClasses("TabsUnstyled", ["root", "horizontal", "vertical"]);
init_define_process();
init_react_preact();
var useTabs = __name((parameters) => {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    orientation,
    direction,
    selectionFollowsFocus
  } = parameters;
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Tabs",
    state: "value"
  });
  const idPrefix = useId2();
  const onSelected = useCallback((e22, newValue) => {
    setValue(newValue);
    if (onChange) {
      onChange(e22, newValue);
    }
  }, [onChange, setValue]);
  const tabsContextValue = useMemo(() => {
    return {
      idPrefix,
      value,
      onSelected,
      orientation,
      direction,
      selectionFollowsFocus
    };
  }, [idPrefix, value, onSelected, orientation, direction, selectionFollowsFocus]);
  return {
    tabsContextValue
  };
}, "useTabs");
var useTabs_default = useTabs;
init_define_process();
init_react_preact();
var Context = createContext(null);
if (false) {
  Context.displayName = "TabsContext";
}
function useTabContext() {
  return useContext(Context);
}
__name(useTabContext, "useTabContext");
function getPanelId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-P-${value}`;
}
__name(getPanelId, "getPanelId");
function getTabId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-T-${value}`;
}
__name(getTabId, "getTabId");
var TabsContext_default = Context;
init_react_preact();
var _excluded16 = ["children", "value", "defaultValue", "orientation", "direction", "component", "components", "componentsProps", "onChange", "selectionFollowsFocus"];
var useUtilityClasses12 = __name((ownerState) => {
  const {
    orientation
  } = ownerState;
  const slots = {
    root: ["root", orientation]
  };
  return composeClasses(slots, getTabsUnstyledUtilityClass, {});
}, "useUtilityClasses");
var TabsUnstyled = forwardRef((props, ref) => {
  var _ref;
  const {
    children: children2,
    orientation = "horizontal",
    direction = "ltr",
    component,
    components = {},
    componentsProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const {
    tabsContextValue
  } = useTabs_default(props);
  const ownerState = _extends({}, props, {
    orientation,
    direction
  });
  const classes = useUtilityClasses12(ownerState);
  const TabsRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const tabsRootProps = useSlotProps({
    elementType: TabsRoot,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref
    },
    ownerState,
    className: classes.root
  });
  return e3(TabsRoot, _extends({}, tabsRootProps, {
    children: e3(TabsContext_default.Provider, {
      value: tabsContextValue,
      children: children2
    })
  }));
});
false ? TabsUnstyled.propTypes = {
  children: import_prop_types23.default.node,
  component: import_prop_types23.default.elementType,
  components: import_prop_types23.default.shape({
    Root: import_prop_types23.default.elementType
  }),
  componentsProps: import_prop_types23.default.shape({
    root: import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object])
  }),
  defaultValue: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf([false]), import_prop_types23.default.number, import_prop_types23.default.string]),
  direction: import_prop_types23.default.oneOf(["ltr", "rtl"]),
  onChange: import_prop_types23.default.func,
  orientation: import_prop_types23.default.oneOf(["horizontal", "vertical"]),
  selectionFollowsFocus: import_prop_types23.default.bool,
  value: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf([false]), import_prop_types23.default.number, import_prop_types23.default.string])
} : void 0;
init_define_process();
var useTabPanel = __name((parameters) => {
  const {
    value
  } = parameters;
  const context = useTabContext();
  if (context === null) {
    throw new Error("No TabContext provided");
  }
  const hidden = value !== context.value;
  const id3 = getPanelId(context, value);
  const tabId = getTabId(context, value);
  const getRootProps = __name(() => {
    return {
      "aria-labelledby": tabId != null ? tabId : void 0,
      hidden,
      id: id3 != null ? id3 : void 0
    };
  }, "getRootProps");
  return {
    hidden,
    getRootProps
  };
}, "useTabPanel");
var useTabPanel_default = useTabPanel;
init_react_preact();
var _excluded17 = ["children", "value", "components", "componentsProps", "component"];
var useUtilityClasses13 = __name((ownerState) => {
  const {
    hidden
  } = ownerState;
  const slots = {
    root: ["root", hidden && "hidden"]
  };
  return composeClasses(slots, getTabPanelUnstyledUtilityClass, {});
}, "useUtilityClasses");
var TabPanelUnstyled = forwardRef(__name(function TabPanelUnstyled2(props, ref) {
  var _ref;
  const {
    children: children2,
    components = {},
    componentsProps = {},
    component
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
  const {
    hidden,
    getRootProps
  } = useTabPanel_default(props);
  const ownerState = _extends({}, props, {
    hidden
  });
  const classes = useUtilityClasses13(ownerState);
  const TabPanelRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const tabPanelRootProps = useSlotProps({
    elementType: TabPanelRoot,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tabpanel",
      ref
    },
    ownerState,
    className: classes.root
  });
  return e3(TabPanelRoot, _extends({}, tabPanelRootProps, {
    children: !hidden && children2
  }));
}, "TabPanelUnstyled"));
false ? TabPanelUnstyled.propTypes = {
  children: import_prop_types24.default.node,
  component: import_prop_types24.default.elementType,
  components: import_prop_types24.default.shape({
    Root: import_prop_types24.default.elementType
  }),
  componentsProps: import_prop_types24.default.shape({
    root: import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object])
  }),
  value: import_prop_types24.default.oneOfType([import_prop_types24.default.number, import_prop_types24.default.string]).isRequired
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types25 = __toESM(require_prop_types());
init_define_process();
function getTabsListUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsListUnstyled", slot);
}
__name(getTabsListUnstyledUtilityClass, "getTabsListUnstyledUtilityClass");
var tabsListUnstyledClasses = generateUtilityClasses("TabsListUnstyled", ["root", "horizontal", "vertical"]);
init_define_process();
init_react_preact();
var import_react_is2 = __toESM(require_react_is2());
var nextItem = __name((list, item) => {
  if (!list) {
    return null;
  }
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
}, "nextItem");
var previousItem = __name((list, item) => {
  if (!list) {
    return null;
  }
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
}, "previousItem");
var moveFocus = __name((list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (list && nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
}, "moveFocus");
var useTabsList = __name((parameters) => {
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    children: children2,
    ref
  } = parameters;
  const tabsListRef = createRef();
  const handleRef = useForkRef(tabsListRef, ref);
  const context = useTabContext();
  if (context === null) {
    throw new Error("No TabContext provided");
  }
  const {
    value,
    orientation = "horizontal",
    direction = "ltr"
  } = context;
  const isRtl = direction === "rtl";
  const handleKeyDown3 = __name((event) => {
    const list = tabsListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus == null ? void 0 : currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
      default:
        break;
    }
  }, "handleKeyDown");
  const createHandleKeyDown = __name((otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    handleKeyDown3(event);
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
  }, "createHandleKeyDown");
  const getRootProps = __name((otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
    const ownEventHandlers = {
      onKeyDown: createHandleKeyDown(externalEventHandlers)
    };
    const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);
    return _extends({
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-orientation": orientation === "vertical" ? "vertical" : void 0,
      role: "tablist",
      ref: handleRef
    }, mergedEventHandlers);
  }, "getRootProps");
  const processChildren = useCallback(() => {
    const valueToIndex = /* @__PURE__ */ new Map();
    let childIndex = 0;
    const processedChildren = Children.map(children2, (child) => {
      if (!isValidElement(child)) {
        return null;
      }
      if (false) {
        if ((0, import_react_is2.isFragment)(child)) {
          console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
        }
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      valueToIndex.set(childValue, childIndex);
      childIndex += 1;
      return cloneElement(child, _extends({
        value: childValue
      }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {
        tabIndex: 0
      } : {
        tabIndex: -1
      }));
    });
    return processedChildren;
  }, [children2, value]);
  return {
    isRtl,
    orientation,
    value,
    processChildren,
    getRootProps
  };
}, "useTabsList");
var useTabsList_default = useTabsList;
init_react_preact();
var _excluded18 = ["children", "component", "components", "componentsProps"];
var useUtilityClasses14 = __name((ownerState) => {
  const {
    orientation
  } = ownerState;
  const slots = {
    root: ["root", orientation]
  };
  return composeClasses(slots, getTabsListUnstyledUtilityClass, {});
}, "useUtilityClasses");
var TabsListUnstyled = forwardRef((props, ref) => {
  var _ref;
  const {
    component,
    components = {},
    componentsProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
  const {
    isRtl,
    orientation,
    getRootProps,
    processChildren
  } = useTabsList_default(_extends({}, props, {
    ref
  }));
  const ownerState = _extends({}, props, {
    isRtl,
    orientation
  });
  const classes = useUtilityClasses14(ownerState);
  const TabsListRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
  const tabsListRootProps = useSlotProps({
    elementType: TabsListRoot,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    ownerState,
    className: classes.root
  });
  const processedChildren = processChildren();
  return e3(TabsListRoot, _extends({}, tabsListRootProps, {
    children: processedChildren
  }));
});
false ? TabsListUnstyled.propTypes = {
  children: import_prop_types25.default.node,
  component: import_prop_types25.default.elementType,
  components: import_prop_types25.default.shape({
    Root: import_prop_types25.default.elementType
  }),
  componentsProps: import_prop_types25.default.shape({
    root: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object])
  })
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types26 = __toESM(require_prop_types());
init_define_process();
function getTabUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabUnstyled", slot);
}
__name(getTabUnstyledUtilityClass, "getTabUnstyledUtilityClass");
var tabUnstyledClasses = generateUtilityClasses("TabUnstyled", ["root", "selected", "disabled"]);
init_define_process();
var _excluded19 = ["getRootProps"];
var useTab = __name((parameters) => {
  var _getPanelId, _getTabId;
  const {
    value: valueProp,
    onChange,
    onClick,
    onFocus
  } = parameters;
  const _useButton = useButton(parameters), {
    getRootProps: getRootPropsButton
  } = _useButton, otherButtonProps = _objectWithoutPropertiesLoose(_useButton, _excluded19);
  const context = useTabContext();
  if (context === null) {
    throw new Error("No TabContext provided");
  }
  const value = valueProp != null ? valueProp : 0;
  const selected = context.value === value;
  const selectionFollowsFocus = context.selectionFollowsFocus;
  const a11yAttributes = {
    role: "tab",
    "aria-controls": (_getPanelId = getPanelId(context, value)) != null ? _getPanelId : void 0,
    id: (_getTabId = getTabId(context, value)) != null ? _getTabId : void 0,
    "aria-selected": selected,
    disabled: otherButtonProps.disabled
  };
  const createHandleFocus = __name((otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (selectionFollowsFocus && !selected) {
      if (onChange) {
        onChange(event, value);
      }
      context.onSelected(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  }, "createHandleFocus");
  const createHandleClick = __name((otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (!selected) {
      if (onChange) {
        onChange(event, value);
      }
      context.onSelected(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  }, "createHandleClick");
  const getRootProps = __name((otherHandlers = {}) => {
    const buttonResolvedProps = getRootPropsButton(_extends({}, otherHandlers, {
      onClick: createHandleClick(otherHandlers),
      onFocus: createHandleFocus(otherHandlers)
    }));
    return _extends({}, buttonResolvedProps, a11yAttributes);
  }, "getRootProps");
  return _extends({
    getRootProps
  }, otherButtonProps, {
    selected
  });
}, "useTab");
var useTab_default = useTab;
init_react_preact();
var _excluded20 = ["action", "children", "value", "disabled", "onChange", "onClick", "onFocus", "component", "components", "componentsProps"];
var useUtilityClasses15 = __name((ownerState) => {
  const {
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", disabled && "disabled"]
  };
  return composeClasses(slots, getTabUnstyledUtilityClass, {});
}, "useUtilityClasses");
var TabUnstyled = forwardRef(__name(function TabUnstyled2(props, ref) {
  var _ref;
  const {
    action,
    children: children2,
    disabled = false,
    component,
    components = {},
    componentsProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  const tabRef = useRef();
  const handleRef = useForkRef(tabRef, ref);
  const {
    active,
    focusVisible,
    setFocusVisible,
    selected,
    getRootProps
  } = useTab_default(_extends({}, props, {
    ref: handleRef
  }));
  useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      tabRef.current.focus();
    }
  }), [setFocusVisible]);
  const ownerState = _extends({}, props, {
    active,
    focusVisible,
    disabled,
    selected
  });
  const classes = useUtilityClasses15(ownerState);
  const TabRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
  const tabRootProps = useSlotProps({
    elementType: TabRoot,
    getSlotProps: getRootProps,
    externalSlotProps: componentsProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref
    },
    ownerState,
    className: classes.root
  });
  return e3(TabRoot, _extends({}, tabRootProps, {
    children: children2
  }));
}, "TabUnstyled"));
false ? TabUnstyled.propTypes = {
  action: import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.shape({
    current: import_prop_types26.default.shape({
      focusVisible: import_prop_types26.default.func.isRequired
    })
  })]),
  children: import_prop_types26.default.node,
  component: import_prop_types26.default.elementType,
  components: import_prop_types26.default.shape({
    Root: import_prop_types26.default.elementType
  }),
  componentsProps: import_prop_types26.default.shape({
    root: import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.object])
  }),
  disabled: import_prop_types26.default.bool,
  onChange: import_prop_types26.default.func,
  onClick: import_prop_types26.default.func,
  onFocus: import_prop_types26.default.func,
  value: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string])
} : void 0;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types27 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
init_react_preact();
var _excluded21 = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
__name(getStyleValue, "getStyleValue");
var styles = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)"
  }
};
function isEmpty2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
__name(isEmpty2, "isEmpty");
var TextareaAutosize = forwardRef(__name(function TextareaAutosize2(props, ref) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style4,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
  const {
    current: isControlled
  } = useRef(value != null);
  const inputRef = useRef(null);
  const handleRef = useForkRef(ref, inputRef);
  const shadowRef = useRef(null);
  const renders = useRef(0);
  const [state, setState] = useState({});
  const getUpdatedState = useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {};
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle["box-sizing"];
    const padding2 = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
    const border2 = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
    const innerHeight2 = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight2;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflow2 = Math.abs(outerHeight - innerHeight2) <= 1;
    return {
      outerHeightStyle,
      overflow: overflow2
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = __name((prevState, newState) => {
    const {
      outerHeightStyle,
      overflow: overflow2
    } = newState;
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow2)) {
      renders.current += 1;
      return {
        overflow: overflow2,
        outerHeightStyle
      };
    }
    if (false) {
      if (renders.current === 20) {
        console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join("\n"));
      }
    }
    return prevState;
  }, "updateState");
  const syncHeight = useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty2(newState)) {
      return;
    }
    setState((prevState) => {
      return updateState(prevState, newState);
    });
  }, [getUpdatedState]);
  const syncHeightWithFlushSycn = __name(() => {
    const newState = getUpdatedState();
    if (isEmpty2(newState)) {
      return;
    }
    flushSync(() => {
      setState((prevState) => {
        return updateState(prevState, newState);
      });
    });
  }, "syncHeightWithFlushSycn");
  useEffect(() => {
    const handleResize = debounce(() => {
      renders.current = 0;
      if (inputRef.current) {
        syncHeightWithFlushSycn();
      }
    });
    const containerWindow = ownerWindow(inputRef.current);
    containerWindow.addEventListener("resize", handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(inputRef.current);
    }
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  });
  useEnhancedEffect_default(() => {
    syncHeight();
  });
  useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = __name((event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  }, "handleChange");
  return e3(p, {
    children: [e3("textarea", _extends({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: _extends({
        height: state.outerHeightStyle,
        overflow: state.overflow ? "hidden" : null
      }, style4)
    }, other)), e3("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends({}, styles.shadow, style4, {
        padding: 0
      })
    })]
  });
}, "TextareaAutosize"));
false ? TextareaAutosize.propTypes = {
  className: import_prop_types27.default.string,
  maxRows: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  minRows: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  onChange: import_prop_types27.default.func,
  placeholder: import_prop_types27.default.string,
  style: import_prop_types27.default.object,
  value: import_prop_types27.default.oneOfType([import_prop_types27.default.arrayOf(import_prop_types27.default.string), import_prop_types27.default.number, import_prop_types27.default.string])
} : void 0;
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types50 = __toESM(require_prop_types());
init_define_process();
init_define_process();
init_define_process();
var import_styled = __toESM(require_emotion_styled_cjs());
var import_react10 = __toESM(require_emotion_react_cjs());
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types28 = __toESM(require_prop_types());
var import_react8 = __toESM(require_emotion_react_cjs());
var import_cache = __toESM(require_emotion_cache_cjs());
init_react_preact();
var cache = (0, import_cache.default)({
  key: "css",
  prepend: true
});
false ? StyledEngineProvider.propTypes = {
  children: import_prop_types28.default.node,
  injectFirst: import_prop_types28.default.bool
} : void 0;
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types29 = __toESM(require_prop_types());
var import_react9 = __toESM(require_emotion_react_cjs());
init_react_preact();
function isEmpty22(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
__name(isEmpty22, "isEmpty");
function GlobalStyles(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme7 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty22(themeInput) ? defaultTheme7 : themeInput) : styles2;
  return e3(import_react9.Global, {
    styles: globalStyles
  });
}
__name(GlobalStyles, "GlobalStyles");
false ? GlobalStyles.propTypes = {
  defaultTheme: import_prop_types29.default.object,
  styles: import_prop_types29.default.oneOfType([import_prop_types29.default.string, import_prop_types29.default.object, import_prop_types29.default.func])
} : void 0;
function styled(tag, options) {
  const stylesFactory = (0, import_styled.default)(tag, options);
  if (false) {
    return (...styles2) => {
      const component = typeof tag === "string" ? `"${tag}"` : "component";
      if (styles2.length === 0) {
        console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join("\n"));
      } else if (styles2.some((style4) => style4 === void 0)) {
        console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
      }
      return stylesFactory(...styles2);
    };
  }
  return stylesFactory;
}
__name(styled, "styled");
var internal_processStyles = __name((tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}, "internal_processStyles");
init_define_process();
init_define_process();
var import_prop_types30 = __toESM(require_prop_types());
var responsivePropType = false ? import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string, import_prop_types30.default.object, import_prop_types30.default.array]) : {};
init_define_process();
init_define_process();
var import_prop_types31 = __toESM(require_prop_types());
init_define_process();
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
  });
}
__name(merge, "merge");
var merge_default = merge;
var values2 = {
  xs: 0,
  sm: 600,
  md: 900,
  lg: 1200,
  xl: 1536
};
var defaultBreakpoints = {
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values2[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values2).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
__name(handleBreakpoints, "handleBreakpoints");
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
__name(createEmptyBreakpointObject, "createEmptyBreakpointObject");
function removeUnusedBreakpoints(breakpointKeys, style4) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style4);
}
__name(removeUnusedBreakpoints, "removeUnusedBreakpoints");
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev, next) => deepmerge(prev, next), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
__name(mergeBreakpointsInOrder, "mergeBreakpointsInOrder");
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i4) => {
      if (i4 < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
__name(computeBreakpointsBase, "computeBreakpointsBase");
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys3 = Object.keys(base);
  if (keys3.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys3.reduce((acc, breakpoint, i4) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i4] != null ? breakpointValues[i4] : breakpointValues[previous];
      previous = i4;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
__name(resolveBreakpointValues, "resolveBreakpointValues");
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
__name(getPath, "getPath");
function getValue2(themeMapping, transform22, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform22) {
    value = transform22(value);
  }
  return value;
}
__name(getValue2, "getValue");
function style(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform22
  } = options;
  const fn2 = __name((props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = __name((propValueFinal) => {
      let value = getValue2(themeMapping, transform22, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getValue2(themeMapping, transform22, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    }, "styleFromPropValue");
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }, "fn");
  fn2.propTypes = false ? {
    [prop]: responsivePropType_default
  } : {};
  fn2.filterProps = [prop];
  return fn2;
}
__name(style, "style");
var style_default = style;
init_define_process();
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style4) => {
    style4.filterProps.forEach((prop) => {
      acc[prop] = style4;
    });
    return acc;
  }, {});
  const fn2 = __name((props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge_default(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  }, "fn");
  fn2.propTypes = false ? styles2.reduce((acc, style4) => Object.assign(acc, style4.propTypes), {}) : {};
  fn2.filterProps = styles2.reduce((acc, style4) => acc.concat(style4.filterProps), []);
  return fn2;
}
__name(compose, "compose");
var compose_default = compose;
init_define_process();
init_define_process();
function memoize(fn2) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn2(arg);
    }
    return cache2[arg];
  };
}
__name(memoize, "memoize");
var properties = {
  m: "margin",
  p: "padding"
};
var directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
var aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
var getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a5, b5] = prop.split("");
  const property = properties[a5];
  const direction = directions[b5] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
var marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
var paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
var spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs) => {
      if (typeof abs === "string") {
        return abs;
      }
      if (false) {
        if (typeof abs !== "number") {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`);
        }
      }
      return themeSpacing * abs;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs) => {
      if (typeof abs === "string") {
        return abs;
      }
      if (false) {
        if (!Number.isInteger(abs)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
        } else if (abs > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join("\n"));
        }
      }
      return themeSpacing[abs];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  if (false) {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
  }
  return () => void 0;
}
__name(createUnaryUnit, "createUnaryUnit");
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8, "spacing");
}
__name(createUnarySpacing, "createUnarySpacing");
function getValue22(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs = Math.abs(propValue);
  const transformed = transformer(abs);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
__name(getValue22, "getValue");
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue22(transformer, propValue);
    return acc;
  }, {});
}
__name(getStyleFromPropValue, "getStyleFromPropValue");
function resolveCssProperty(props, keys3, prop, transformer) {
  if (keys3.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
__name(resolveCssProperty, "resolveCssProperty");
function style2(props, keys3) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys3, prop, transformer)).reduce(merge_default, {});
}
__name(style2, "style");
function margin(props) {
  return style2(props, marginKeys);
}
__name(margin, "margin");
margin.propTypes = false ? marginKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
margin.filterProps = marginKeys;
function padding(props) {
  return style2(props, paddingKeys);
}
__name(padding, "padding");
padding.propTypes = false ? paddingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
padding.filterProps = paddingKeys;
function spacing(props) {
  return style2(props, spacingKeys);
}
__name(spacing, "spacing");
spacing.propTypes = false ? spacingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
spacing.filterProps = spacingKeys;
var spacing_default = spacing;
function getBorder(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
__name(getBorder, "getBorder");
var border = style_default({
  prop: "border",
  themeKey: "borders",
  transform: getBorder
});
var borderTop = style_default({
  prop: "borderTop",
  themeKey: "borders",
  transform: getBorder
});
var borderRight = style_default({
  prop: "borderRight",
  themeKey: "borders",
  transform: getBorder
});
var borderBottom = style_default({
  prop: "borderBottom",
  themeKey: "borders",
  transform: getBorder
});
var borderLeft = style_default({
  prop: "borderLeft",
  themeKey: "borders",
  transform: getBorder
});
var borderColor = style_default({
  prop: "borderColor",
  themeKey: "palette"
});
var borderTopColor = style_default({
  prop: "borderTopColor",
  themeKey: "palette"
});
var borderRightColor = style_default({
  prop: "borderRightColor",
  themeKey: "palette"
});
var borderBottomColor = style_default({
  prop: "borderBottomColor",
  themeKey: "palette"
});
var borderLeftColor = style_default({
  prop: "borderLeftColor",
  themeKey: "palette"
});
var borderRadius = __name((props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
    const styleFromPropValue = __name((propValue) => ({
      borderRadius: getValue22(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
}, "borderRadius");
borderRadius.propTypes = false ? {
  borderRadius: responsivePropType_default
} : {};
borderRadius.filterProps = ["borderRadius"];
var borders2 = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
var borders_default = borders2;
init_define_process();
var displayPrint = style_default({
  prop: "displayPrint",
  cssProperty: false,
  transform: (value) => ({
    "@media print": {
      display: value
    }
  })
});
var displayRaw = style_default({
  prop: "display"
});
var overflow = style_default({
  prop: "overflow"
});
var textOverflow = style_default({
  prop: "textOverflow"
});
var visibility = style_default({
  prop: "visibility"
});
var whiteSpace = style_default({
  prop: "whiteSpace"
});
var display_default = compose_default(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);
init_define_process();
var flexBasis = style_default({
  prop: "flexBasis"
});
var flexDirection = style_default({
  prop: "flexDirection"
});
var flexWrap = style_default({
  prop: "flexWrap"
});
var justifyContent = style_default({
  prop: "justifyContent"
});
var alignItems = style_default({
  prop: "alignItems"
});
var alignContent = style_default({
  prop: "alignContent"
});
var order22 = style_default({
  prop: "order"
});
var flex = style_default({
  prop: "flex"
});
var flexGrow = style_default({
  prop: "flexGrow"
});
var flexShrink = style_default({
  prop: "flexShrink"
});
var alignSelf = style_default({
  prop: "alignSelf"
});
var justifyItems = style_default({
  prop: "justifyItems"
});
var justifySelf = style_default({
  prop: "justifySelf"
});
var flexbox = compose_default(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order22, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
var flexbox_default = flexbox;
init_define_process();
var gap = __name((props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "gap");
    const styleFromPropValue = __name((propValue) => ({
      gap: getValue22(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
}, "gap");
gap.propTypes = false ? {
  gap: responsivePropType_default
} : {};
gap.filterProps = ["gap"];
var columnGap = __name((props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
    const styleFromPropValue = __name((propValue) => ({
      columnGap: getValue22(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
}, "columnGap");
columnGap.propTypes = false ? {
  columnGap: responsivePropType_default
} : {};
columnGap.filterProps = ["columnGap"];
var rowGap = __name((props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
    const styleFromPropValue = __name((propValue) => ({
      rowGap: getValue22(transformer, propValue)
    }), "styleFromPropValue");
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
}, "rowGap");
rowGap.propTypes = false ? {
  rowGap: responsivePropType_default
} : {};
rowGap.filterProps = ["rowGap"];
var gridColumn = style_default({
  prop: "gridColumn"
});
var gridRow = style_default({
  prop: "gridRow"
});
var gridAutoFlow = style_default({
  prop: "gridAutoFlow"
});
var gridAutoColumns = style_default({
  prop: "gridAutoColumns"
});
var gridAutoRows = style_default({
  prop: "gridAutoRows"
});
var gridTemplateColumns = style_default({
  prop: "gridTemplateColumns"
});
var gridTemplateRows = style_default({
  prop: "gridTemplateRows"
});
var gridTemplateAreas = style_default({
  prop: "gridTemplateAreas"
});
var gridArea = style_default({
  prop: "gridArea"
});
var grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
var cssGrid_default = grid;
init_define_process();
var color2 = style_default({
  prop: "color",
  themeKey: "palette"
});
var bgcolor = style_default({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette"
});
var backgroundColor = style_default({
  prop: "backgroundColor",
  themeKey: "palette"
});
var palette = compose_default(color2, bgcolor, backgroundColor);
var palette_default = palette;
init_define_process();
var position = style_default({
  prop: "position"
});
var zIndex = style_default({
  prop: "zIndex",
  themeKey: "zIndex"
});
var top2 = style_default({
  prop: "top"
});
var right2 = style_default({
  prop: "right"
});
var bottom2 = style_default({
  prop: "bottom"
});
var left2 = style_default({
  prop: "left"
});
var positions_default = compose_default(position, zIndex, top2, right2, bottom2, left2);
init_define_process();
var boxShadow = style_default({
  prop: "boxShadow",
  themeKey: "shadows"
});
var shadows_default = boxShadow;
init_define_process();
function transform2(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
__name(transform2, "transform");
var width = style_default({
  prop: "width",
  transform: transform2
});
var maxWidth = __name((props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = __name((propValue) => {
      var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
      const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values2[propValue];
      return {
        maxWidth: breakpoint || transform2(propValue)
      };
    }, "styleFromPropValue");
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
}, "maxWidth");
maxWidth.filterProps = ["maxWidth"];
var minWidth = style_default({
  prop: "minWidth",
  transform: transform2
});
var height = style_default({
  prop: "height",
  transform: transform2
});
var maxHeight = style_default({
  prop: "maxHeight",
  transform: transform2
});
var minHeight = style_default({
  prop: "minHeight",
  transform: transform2
});
var sizeWidth = style_default({
  prop: "size",
  cssProperty: "width",
  transform: transform2
});
var sizeHeight = style_default({
  prop: "size",
  cssProperty: "height",
  transform: transform2
});
var boxSizing = style_default({
  prop: "boxSizing"
});
var sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
var sizing_default = sizing;
init_define_process();
var fontFamily = style_default({
  prop: "fontFamily",
  themeKey: "typography"
});
var fontSize = style_default({
  prop: "fontSize",
  themeKey: "typography"
});
var fontStyle = style_default({
  prop: "fontStyle",
  themeKey: "typography"
});
var fontWeight = style_default({
  prop: "fontWeight",
  themeKey: "typography"
});
var letterSpacing = style_default({
  prop: "letterSpacing"
});
var textTransform = style_default({
  prop: "textTransform"
});
var lineHeight = style_default({
  prop: "lineHeight"
});
var textAlign = style_default({
  prop: "textAlign"
});
var typographyVariant = style_default({
  prop: "typography",
  cssProperty: false,
  themeKey: "typography"
});
var typography = compose_default(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
var typography_default = typography;
init_define_process();
init_define_process();
init_define_process();
var filterPropsMapping = {
  borders: borders_default.filterProps,
  display: display_default.filterProps,
  flexbox: flexbox_default.filterProps,
  grid: cssGrid_default.filterProps,
  positions: positions_default.filterProps,
  palette: palette_default.filterProps,
  shadows: shadows_default.filterProps,
  sizing: sizing_default.filterProps,
  spacing: spacing_default.filterProps,
  typography: typography_default.filterProps
};
var styleFunctionMapping = {
  borders: borders_default,
  display: display_default,
  flexbox: flexbox_default,
  grid: cssGrid_default,
  positions: positions_default,
  palette: palette_default,
  shadows: shadows_default,
  sizing: sizing_default,
  spacing: spacing_default,
  typography: typography_default
};
var propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
  filterPropsMapping[styleFnName].forEach((propName) => {
    acc[propName] = styleFunctionMapping[styleFnName];
  });
  return acc;
}, {});
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys3, object) => keys3.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
__name(objectsHaveSameKeys, "objectsHaveSameKeys");
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
__name(callIfFn, "callIfFn");
function unstable_createStyleFunctionSx(styleFunctionMapping2 = styleFunctionMapping) {
  const propToStyleFunction2 = Object.keys(styleFunctionMapping2).reduce((acc, styleFnName) => {
    styleFunctionMapping2[styleFnName].filterProps.forEach((propName) => {
      acc[propName] = styleFunctionMapping2[styleFnName];
    });
    return acc;
  }, {});
  function getThemeValue(prop, value, theme) {
    const inputProps = {
      [prop]: value,
      theme
    };
    const styleFunction = propToStyleFunction2[prop];
    return styleFunction ? styleFunction(inputProps) : {
      [prop]: value
    };
  }
  __name(getThemeValue, "getThemeValue");
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css7 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (propToStyleFunction2[styleKey]) {
              css7 = merge_default(css7, getThemeValue(styleKey, value, theme));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x5) => ({
                [styleKey]: x5
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css7[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css7 = merge_default(css7, breakpointsValues);
              }
            }
          } else {
            css7 = merge_default(css7, getThemeValue(styleKey, value, theme));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css7);
    }
    __name(traverse, "traverse");
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  __name(styleFunctionSx2, "styleFunctionSx");
  return styleFunctionSx2;
}
__name(unstable_createStyleFunctionSx, "unstable_createStyleFunctionSx");
var styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
var styleFunctionSx_default = styleFunctionSx;
init_define_process();
var _excluded24 = ["sx"];
var splitProps = __name((props) => {
  const result = {
    systemProps: {},
    otherProps: {}
  };
  Object.keys(props).forEach((prop) => {
    if (propToStyleFunction[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
}, "splitProps");
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded24);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = __name((...args) => {
      const result = inSx(...args);
      if (!isPlainObject2(result)) {
        return systemProps;
      }
      return _extends({}, systemProps, result);
    }, "finalSx");
  } else {
    finalSx = _extends({}, systemProps, inSx);
  }
  return _extends({}, otherProps, {
    sx: finalSx
  });
}
__name(extendSxProp, "extendSxProp");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var import_prop_types33 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
var _excluded25 = ["values", "unit", "step"];
var sortBreakpointsValues = __name((values3) => {
  const breakpointsAsArray = Object.keys(values3).map((key) => ({
    key,
    val: values3[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
}, "sortBreakpointsValues");
function createBreakpoints(breakpoints) {
  const {
    values: values3 = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded25);
  const sortedValues = sortBreakpointsValues(values3);
  const keys3 = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  __name(up, "up");
  function down(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  __name(down, "down");
  function between(start2, end2) {
    const endIndex = keys3.indexOf(end2);
    return `@media (min-width:${typeof values3[start2] === "number" ? values3[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values3[keys3[endIndex]] === "number" ? values3[keys3[endIndex]] : end2) - step / 100}${unit})`;
  }
  __name(between, "between");
  function only(key) {
    if (keys3.indexOf(key) + 1 < keys3.length) {
      return between(key, keys3[keys3.indexOf(key) + 1]);
    }
    return up(key);
  }
  __name(only, "only");
  function not2(key) {
    const keyIndex = keys3.indexOf(key);
    if (keyIndex === 0) {
      return up(keys3[1]);
    }
    if (keyIndex === keys3.length - 1) {
      return down(keys3[keyIndex]);
    }
    return between(key, keys3[keys3.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  __name(not2, "not");
  return _extends({
    keys: keys3,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not: not2,
    unit
  }, other);
}
__name(createBreakpoints, "createBreakpoints");
init_define_process();
var shape = {
  borderRadius: 4
};
var shape_default = shape;
init_define_process();
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform22 = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing2 = __name((...argsInput) => {
    if (false) {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform22(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  }, "spacing");
  spacing2.mui = true;
  return spacing2;
}
__name(createSpacing, "createSpacing");
var _excluded26 = ["breakpoints", "palette", "spacing", "shape"];
function createTheme(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded26);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing2 = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    palette: _extends({
      mode: "light"
    }, paletteInput),
    spacing: spacing2,
    shape: _extends({}, shape_default, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}
__name(createTheme, "createTheme");
var createTheme_default = createTheme;
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types32 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
var ThemeContext2 = createContext(null);
if (false) {
  ThemeContext2.displayName = "ThemeContext";
}
var ThemeContext_default = ThemeContext2;
init_define_process();
init_define_process();
init_react_preact();
function useTheme() {
  const theme = useContext(ThemeContext_default);
  if (false) {
    useDebugValue(theme);
  }
  return theme;
}
__name(useTheme, "useTheme");
init_define_process();
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var nested_default = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
init_react_preact();
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    if (false) {
      if (!mergedTheme) {
        console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join("\n"));
      }
    }
    return mergedTheme;
  }
  return _extends({}, outerTheme, localTheme);
}
__name(mergeOuterLocalTheme, "mergeOuterLocalTheme");
function ThemeProvider(props) {
  const {
    children: children2,
    theme: localTheme
  } = props;
  const outerTheme = useTheme();
  if (false) {
    if (outerTheme === null && typeof localTheme === "function") {
      console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
    }
  }
  const theme = useMemo(() => {
    const output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested_default] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return e3(ThemeContext_default.Provider, {
    value: theme,
    children: children2
  });
}
__name(ThemeProvider, "ThemeProvider");
false ? ThemeProvider.propTypes = {
  children: import_prop_types32.default.node,
  theme: import_prop_types32.default.oneOfType([import_prop_types32.default.object, import_prop_types32.default.func]).isRequired
} : void 0;
if (false) {
  false ? ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes) : void 0;
}
var ThemeProvider_default = ThemeProvider;
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
__name(isObjectEmpty, "isObjectEmpty");
function useTheme2(defaultTheme7 = null) {
  const contextTheme = useTheme();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme7 : contextTheme;
}
__name(useTheme2, "useTheme");
var useThemeWithoutDefault_default = useTheme2;
var systemDefaultTheme = createTheme_default();
function useTheme3(defaultTheme7 = systemDefaultTheme) {
  return useThemeWithoutDefault_default(defaultTheme7);
}
__name(useTheme3, "useTheme");
var useTheme_default = useTheme3;
init_react_preact();
var _excluded27 = ["className", "component"];
function createBox2(options = {}) {
  const {
    defaultTheme: defaultTheme7,
    defaultClassName = "MuiBox-root",
    generateClassName,
    styleFunctionSx: styleFunctionSx2 = styleFunctionSx_default
  } = options;
  const BoxRoot = styled("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx2);
  const Box3 = forwardRef(__name(function Box4(inProps, ref) {
    const theme = useTheme_default(defaultTheme7);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded27);
    return e3(BoxRoot, _extends({
      as: component,
      ref,
      className: clsx_m_default(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme
    }, other));
  }, "Box"));
  return Box3;
}
__name(createBox2, "createBox");
var Box = createBox2();
false ? Box.propTypes = {
  children: import_prop_types33.default.node,
  component: import_prop_types33.default.elementType,
  sx: import_prop_types33.default.oneOfType([import_prop_types33.default.arrayOf(import_prop_types33.default.oneOfType([import_prop_types33.default.func, import_prop_types33.default.object, import_prop_types33.default.bool])), import_prop_types33.default.func, import_prop_types33.default.object])
} : void 0;
init_define_process();
init_define_process();
var _excluded28 = ["variant"];
function isEmpty3(string) {
  return string.length === 0;
}
__name(isEmpty3, "isEmpty");
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded28);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty3(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}
__name(propsToClassKey, "propsToClassKey");
var _excluded29 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
var _excluded210 = ["theme"];
var _excluded32 = ["theme"];
function isEmpty4(obj) {
  return Object.keys(obj).length === 0;
}
__name(isEmpty4, "isEmpty");
function isStringTag(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96;
}
__name(isStringTag, "isStringTag");
var getStyleOverrides = __name((name, theme) => {
  if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
    return theme.components[name].styleOverrides;
  }
  return null;
}, "getStyleOverrides");
var getVariantStyles = __name((name, theme) => {
  let variants = [];
  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    variants = theme.components[name].variants;
  }
  const variantsStyles = {};
  variants.forEach((definition) => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
}, "getVariantStyles");
var variantsResolver = __name((props, styles2, theme, name) => {
  var _theme$components, _theme$components$nam;
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
  if (themeVariants) {
    themeVariants.forEach((themeVariant) => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach((key) => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
      }
    });
  }
  return variantsStyles;
}, "variantsResolver");
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
__name(shouldForwardProp, "shouldForwardProp");
var systemDefaultTheme2 = createTheme_default();
function createStyled(input = {}) {
  const {
    defaultTheme: defaultTheme7 = systemDefaultTheme2,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp,
    styleFunctionSx: styleFunctionSx2 = styleFunctionSx_default
  } = input;
  const systemSx = __name((props) => {
    const theme = isEmpty4(props.theme) ? defaultTheme7 : props.theme;
    return styleFunctionSx2(_extends({}, props, {
      theme
    }));
  }, "systemSx");
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style4) => !(style4 != null && style4.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver
    } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded29);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" || false;
    const skipSx = inputSkipSx || false;
    let label;
    if (false) {
      if (componentName) {
        label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
      }
    }
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled(tag, _extends({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = __name((styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (_ref) => {
          let {
            theme: themeInput
          } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded210);
          return stylesArg(_extends({
            theme: isEmpty4(themeInput) ? defaultTheme7 : themeInput
          }, other));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = isEmpty4(props.theme) ? defaultTheme7 : props.theme;
          const styleOverrides = getStyleOverrides(componentName, theme);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = isEmpty4(props.theme) ? defaultTheme7 : props.theme;
          return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else if (typeof styleArg === "function" && styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = __name((_ref2) => {
          let {
            theme: themeInput
          } = _ref2, other = _objectWithoutPropertiesLoose(_ref2, _excluded32);
          return styleArg(_extends({
            theme: isEmpty4(themeInput) ? defaultTheme7 : themeInput
          }, other));
        }, "transformedStyleArg");
      }
      const Component2 = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (false) {
        let displayName;
        if (componentName) {
          displayName = `${componentName}${componentSlot || ""}`;
        }
        if (displayName === void 0) {
          displayName = `Styled(${getDisplayName(tag)})`;
        }
        Component2.displayName = displayName;
      }
      return Component2;
    }, "muiStyledResolver");
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
__name(createStyled, "createStyled");
init_define_process();
var styled2 = createStyled();
var styled_default = styled2;
init_define_process();
init_define_process();
init_define_process();
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
__name(getThemeProps, "getThemeProps");
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme7
}) {
  const theme = useTheme_default(defaultTheme7);
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}
__name(useThemeProps, "useThemeProps");
init_define_process();
function clamp22(value, min22 = 0, max22 = 1) {
  if (false) {
    if (value < min22 || value > max22) {
      console.error(`MUI: The value provided ${value} is out of range [${min22}, ${max22}].`);
    }
  }
  return Math.min(Math.max(min22, value), max22);
}
__name(clamp22, "clamp");
function hexToRgb(color22) {
  color22 = color22.slice(1);
  const re = new RegExp(`.{1,${color22.length >= 6 ? 2 : 1}}`, "g");
  let colors = color22.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n3) => n3 + n3);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n3, index) => {
    return index < 3 ? parseInt(n3, 16) : Math.round(parseInt(n3, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
__name(hexToRgb, "hexToRgb");
function decomposeColor(color22) {
  if (color22.type) {
    return color22;
  }
  if (color22.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color22));
  }
  const marker = color22.indexOf("(");
  const type = color22.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(false ? `MUI: Unsupported \`${color22}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color22));
  }
  let values3 = color22.substring(marker + 1, color22.length - 1);
  let colorSpace;
  if (type === "color") {
    values3 = values3.split(" ");
    colorSpace = values3.shift();
    if (values3.length === 4 && values3[3].charAt(0) === "/") {
      values3[3] = values3[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(false ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values3 = values3.split(",");
  }
  values3 = values3.map((value) => parseFloat(value));
  return {
    type,
    values: values3,
    colorSpace
  };
}
__name(decomposeColor, "decomposeColor");
var colorChannel = __name((color22) => {
  const decomposedColor = decomposeColor(color22);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf("hsl") !== -1 && idx !== 0 ? `${val}%` : val).join(" ");
}, "colorChannel");
function recomposeColor(color22) {
  const {
    type,
    colorSpace
  } = color22;
  let {
    values: values3
  } = color22;
  if (type.indexOf("rgb") !== -1) {
    values3 = values3.map((n3, i4) => i4 < 3 ? parseInt(n3, 10) : n3);
  } else if (type.indexOf("hsl") !== -1) {
    values3[1] = `${values3[1]}%`;
    values3[2] = `${values3[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values3 = `${colorSpace} ${values3.join(" ")}`;
  } else {
    values3 = `${values3.join(", ")}`;
  }
  return `${type}(${values3})`;
}
__name(recomposeColor, "recomposeColor");
function hslToRgb(color22) {
  color22 = decomposeColor(color22);
  const {
    values: values3
  } = color22;
  const h32 = values3[0];
  const s4 = values3[1] / 100;
  const l4 = values3[2] / 100;
  const a5 = s4 * Math.min(l4, 1 - l4);
  const f4 = __name((n3, k5 = (n3 + h32 / 30) % 12) => l4 - a5 * Math.max(Math.min(k5 - 3, 9 - k5, 1), -1), "f");
  let type = "rgb";
  const rgb = [Math.round(f4(0) * 255), Math.round(f4(8) * 255), Math.round(f4(4) * 255)];
  if (color22.type === "hsla") {
    type += "a";
    rgb.push(values3[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
__name(hslToRgb, "hslToRgb");
function getLuminance(color22) {
  color22 = decomposeColor(color22);
  let rgb = color22.type === "hsl" ? decomposeColor(hslToRgb(color22)).values : color22.values;
  rgb = rgb.map((val) => {
    if (color22.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
__name(getLuminance, "getLuminance");
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
__name(getContrastRatio, "getContrastRatio");
function alpha2(color22, value) {
  color22 = decomposeColor(color22);
  value = clamp22(value);
  if (color22.type === "rgb" || color22.type === "hsl") {
    color22.type += "a";
  }
  if (color22.type === "color") {
    color22.values[3] = `/${value}`;
  } else {
    color22.values[3] = value;
  }
  return recomposeColor(color22);
}
__name(alpha2, "alpha");
function darken(color22, coefficient) {
  color22 = decomposeColor(color22);
  coefficient = clamp22(coefficient);
  if (color22.type.indexOf("hsl") !== -1) {
    color22.values[2] *= 1 - coefficient;
  } else if (color22.type.indexOf("rgb") !== -1 || color22.type.indexOf("color") !== -1) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color22.values[i4] *= 1 - coefficient;
    }
  }
  return recomposeColor(color22);
}
__name(darken, "darken");
function lighten(color22, coefficient) {
  color22 = decomposeColor(color22);
  coefficient = clamp22(coefficient);
  if (color22.type.indexOf("hsl") !== -1) {
    color22.values[2] += (100 - color22.values[2]) * coefficient;
  } else if (color22.type.indexOf("rgb") !== -1) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color22.values[i4] += (255 - color22.values[i4]) * coefficient;
    }
  } else if (color22.type.indexOf("color") !== -1) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color22.values[i4] += (1 - color22.values[i4]) * coefficient;
    }
  }
  return recomposeColor(color22);
}
__name(lighten, "lighten");
function emphasize(color22, coefficient = 0.15) {
  return getLuminance(color22) > 0.5 ? darken(color22, coefficient) : lighten(color22, coefficient);
}
__name(emphasize, "emphasize");
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types34 = __toESM(require_prop_types());
init_react_preact();
function InnerThemeProvider(props) {
  const theme = useTheme_default();
  return e3(import_react10.ThemeContext.Provider, {
    value: typeof theme === "object" ? theme : {},
    children: props.children
  });
}
__name(InnerThemeProvider, "InnerThemeProvider");
false ? InnerThemeProvider.propTypes = {
  children: import_prop_types34.default.node
} : void 0;
function ThemeProvider2(props) {
  const {
    children: children2,
    theme: localTheme
  } = props;
  return e3(ThemeProvider_default, {
    theme: localTheme,
    children: e3(InnerThemeProvider, {
      children: children2
    })
  });
}
__name(ThemeProvider2, "ThemeProvider");
false ? ThemeProvider2.propTypes = {
  children: import_prop_types34.default.node,
  theme: import_prop_types34.default.oneOfType([import_prop_types34.default.func, import_prop_types34.default.object]).isRequired
} : void 0;
if (false) {
  false ? ThemeProvider2.propTypes = exactProp(ThemeProvider2.propTypes) : void 0;
}
var ThemeProvider_default2 = ThemeProvider2;
init_define_process();
init_react_preact();
var import_prop_types35 = __toESM(require_prop_types());
init_define_process();
var assignNestedKeys = __name((obj, keys3, value, arrayKeys = []) => {
  let temp = obj;
  keys3.forEach((k5, index) => {
    if (index === keys3.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k5)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k5] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k5]) {
        temp[k5] = arrayKeys.includes(k5) ? [] : {};
      }
      temp = temp[k5];
    }
  });
}, "assignNestedKeys");
var walkObjectDeep = __name((obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  __name(recurse, "recurse");
  recurse(obj);
}, "walkObjectDeep");
var getCssValue = __name((keys3, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys3.includes(prop))) {
      return value;
    }
    const lastKey = keys3[keys3.length - 1];
    if (lastKey.toLowerCase().indexOf("opacity") >= 0) {
      return value;
    }
    return `${value}px`;
  }
  return value;
}, "getCssValue");
function cssVarsParser(theme, options) {
  const {
    prefix,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css7 = {};
  const vars = {};
  const parsedTheme = {};
  walkObjectDeep(
    theme,
    (keys3, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || shouldSkipGeneratingVar2 && !shouldSkipGeneratingVar2(keys3, value)) {
          const cssVar = `--${prefix ? `${prefix}-` : ""}${keys3.join("-")}`;
          Object.assign(css7, {
            [cssVar]: getCssValue(keys3, value)
          });
          assignNestedKeys(vars, keys3, `var(${cssVar})`, arrayKeys);
        }
      }
      assignNestedKeys(parsedTheme, keys3, value, arrayKeys);
    },
    (keys3) => keys3[0] === "vars"
  );
  return {
    css: css7,
    vars,
    parsedTheme
  };
}
__name(cssVarsParser, "cssVarsParser");
init_define_process();
init_react_preact();
init_react_preact();
var DEFAULT_MODE_STORAGE_KEY = "mode";
var DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
var DEFAULT_ATTRIBUTE = "data-color-scheme";
function getInitColorSchemeScript(options) {
  const {
    enableColorScheme = true,
    enableSystem = false,
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement"
  } = options || {};
  return e3("script", {
    dangerouslySetInnerHTML: {
      __html: `(function() { try {
        var mode = localStorage.getItem('${modeStorageKey}');
        var cssColorScheme = mode;
        var colorScheme = '';
        if (mode === 'system' || (!mode && !!${enableSystem})) {
          // handle system mode
          var mql = window.matchMedia('(prefers-color-scheme: dark)');
          if (mql.matches) {
            cssColorScheme = 'dark';
            colorScheme = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
          } else {
            cssColorScheme = 'light';
            colorScheme = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
          }
        }
        if (mode === 'light') {
          colorScheme = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
        }
        if (mode === 'dark') {
          colorScheme = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
        }
        if (colorScheme) {
          ${colorSchemeNode}.setAttribute('${attribute}', colorScheme);
        }
        if (${enableColorScheme} && !!cssColorScheme) {
          ${colorSchemeNode}.style.setProperty('color-scheme', cssColorScheme);
        }
      } catch (e) {} })();`
    }
  });
}
__name(getInitColorSchemeScript, "getInitColorSchemeScript");
init_define_process();
init_react_preact();
function getSystemMode(mode) {
  if (typeof window !== "undefined" && mode === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
__name(getSystemMode, "getSystemMode");
function processState(state, callback) {
  if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
    return callback("light");
  }
  if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
__name(processState, "processState");
function getColorScheme(state) {
  return processState(state, (mode) => {
    if (mode === "light") {
      return state.lightColorScheme;
    }
    if (mode === "dark") {
      return state.darkColorScheme;
    }
    return void 0;
  });
}
__name(getColorScheme, "getColorScheme");
function initializeValue(key, defaultValue) {
  if (typeof window === "undefined") {
    return void 0;
  }
  let value;
  try {
    value = localStorage.getItem(key) || void 0;
    if (!value) {
      localStorage.setItem(key, defaultValue);
    }
  } catch (e22) {
  }
  return value || defaultValue;
}
__name(initializeValue, "initializeValue");
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const [state, setState] = useState(() => {
    const initialMode = initializeValue(modeStorageKey, defaultMode);
    const lightColorScheme = initializeValue(`${colorSchemeStorageKey}-light`, defaultLightColorScheme);
    const darkColorScheme = initializeValue(`${colorSchemeStorageKey}-dark`, defaultDarkColorScheme);
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const colorScheme = getColorScheme(state);
  const setMode = useCallback((mode) => {
    setState((currentState) => {
      if (mode === currentState.mode) {
        return currentState;
      }
      const newMode = !mode ? defaultMode : mode;
      try {
        localStorage.setItem(modeStorageKey, newMode);
      } catch (e22) {
      }
      return _extends({}, currentState, {
        mode: newMode,
        systemMode: getSystemMode(newMode)
      });
    });
  }, [modeStorageKey, defaultMode]);
  const setColorScheme = useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        try {
          localStorage.setItem(`${colorSchemeStorageKey}-light`, defaultLightColorScheme);
          localStorage.setItem(`${colorSchemeStorageKey}-dark`, defaultDarkColorScheme);
        } catch (e22) {
        }
        return _extends({}, currentState, {
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        });
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = _extends({}, currentState);
          processState(currentState, (mode) => {
            try {
              localStorage.setItem(`${colorSchemeStorageKey}-${mode}`, value);
            } catch (e22) {
            }
            if (mode === "light") {
              newState.lightColorScheme = value;
            }
            if (mode === "dark") {
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = _extends({}, currentState);
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            try {
              localStorage.setItem(`${colorSchemeStorageKey}-light`, newLightColorScheme);
            } catch (error) {
            }
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            try {
              localStorage.setItem(`${colorSchemeStorageKey}-dark`, newDarkColorScheme);
            } catch (error) {
            }
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, colorSchemeStorageKey, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = useCallback((e22) => {
    if (state.mode === "system") {
      setState((currentState) => _extends({}, currentState, {
        systemMode: e22 != null && e22.matches ? "dark" : "light"
      }));
    }
  }, [state.mode]);
  const mediaListener = useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  useEffect(() => {
    const handler = __name((...args) => mediaListener.current(...args), "handler");
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => media.removeListener(handler);
  }, []);
  useEffect(() => {
    const handleStorage = __name((event) => {
      const value = event.newValue;
      if (typeof event.key === "string" && event.key.startsWith(colorSchemeStorageKey) && (!value || joinedColorSchemes.match(value))) {
        if (event.key.endsWith("light")) {
          setColorScheme({
            light: value
          });
        }
        if (event.key.endsWith("dark")) {
          setColorScheme({
            dark: value
          });
        }
      }
      if (event.key === modeStorageKey && (!value || ["light", "dark", "system"].includes(value))) {
        setMode(value || defaultMode);
      }
    }, "handleStorage");
    if (storageWindow) {
      storageWindow.addEventListener("storage", handleStorage);
      return () => storageWindow.removeEventListener("storage", handleStorage);
    }
    return void 0;
  }, [setColorScheme, setMode, modeStorageKey, colorSchemeStorageKey, joinedColorSchemes, defaultMode, storageWindow]);
  return _extends({}, state, {
    colorScheme,
    setMode,
    setColorScheme
  });
}
__name(useCurrentColorScheme, "useCurrentColorScheme");
init_react_preact();
init_react_preact();
var _excluded30 = ["colorSchemes", "components", "cssVarPrefix"];
var DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    theme: defaultTheme7 = {},
    attribute: defaultAttribute = DEFAULT_ATTRIBUTE,
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    defaultMode: desisgnSystemMode = "light",
    defaultColorScheme: designSystemColorScheme,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    enableColorScheme: designSystemEnableColorScheme = true,
    shouldSkipGeneratingVar: designSystemShouldSkipGeneratingVar,
    resolveTheme
  } = options;
  if (!defaultTheme7.colorSchemes || typeof designSystemColorScheme === "string" && !defaultTheme7.colorSchemes[designSystemColorScheme] || typeof designSystemColorScheme === "object" && !defaultTheme7.colorSchemes[designSystemColorScheme == null ? void 0 : designSystemColorScheme.light] || typeof designSystemColorScheme === "object" && !defaultTheme7.colorSchemes[designSystemColorScheme == null ? void 0 : designSystemColorScheme.dark]) {
    console.error(`MUI: \`${designSystemColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
  }
  const ColorSchemeContext = createContext(void 0);
  const useColorScheme2 = __name(() => {
    const value = useContext(ColorSchemeContext);
    if (!value) {
      throw new Error(false ? `MUI: \`useColorScheme\` must be called under <CssVarsProvider />` : formatMuiErrorMessage(19));
    }
    return value;
  }, "useColorScheme");
  function CssVarsProvider2({
    children: children2,
    theme: themeProp = defaultTheme7,
    modeStorageKey = defaultModeStorageKey,
    colorSchemeStorageKey = defaultColorSchemeStorageKey,
    attribute = defaultAttribute,
    defaultMode = desisgnSystemMode,
    defaultColorScheme = designSystemColorScheme,
    disableTransitionOnChange = designSystemTransitionOnChange,
    enableColorScheme = designSystemEnableColorScheme,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    documentNode = typeof document === "undefined" ? void 0 : document,
    colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
    colorSchemeSelector = ":root",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2 = designSystemShouldSkipGeneratingVar
  }) {
    const hasMounted = useRef(false);
    const {
      colorSchemes = {},
      components = {},
      cssVarPrefix
    } = themeProp, restThemeProp = _objectWithoutPropertiesLoose(themeProp, _excluded30);
    const allColorSchemes = Object.keys(colorSchemes);
    const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const {
      mode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme,
      defaultDarkColorScheme,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageWindow
    });
    const resolvedColorScheme = (() => {
      if (!colorScheme) {
        if (defaultMode === "dark") {
          return defaultDarkColorScheme;
        }
        return defaultLightColorScheme;
      }
      return colorScheme;
    })();
    let theme = restThemeProp;
    const {
      css: rootCss,
      vars: rootVars,
      parsedTheme
    } = cssVarsParser(theme, {
      prefix: cssVarPrefix,
      shouldSkipGeneratingVar: shouldSkipGeneratingVar2
    });
    theme = _extends({}, parsedTheme, {
      components,
      colorSchemes,
      cssVarPrefix,
      vars: rootVars,
      getColorSchemeSelector: (targetColorScheme) => `[${attribute}="${targetColorScheme}"] &`
    });
    const defaultColorSchemeStyleSheet = {};
    const otherColorSchemesStyleSheet = {};
    Object.entries(colorSchemes).forEach(([key, scheme]) => {
      const {
        css: css7,
        vars,
        parsedTheme: parsedScheme
      } = cssVarsParser(scheme, {
        prefix: cssVarPrefix,
        shouldSkipGeneratingVar: shouldSkipGeneratingVar2
      });
      theme.vars = deepmerge(theme.vars, vars);
      if (key === resolvedColorScheme) {
        theme = _extends({}, theme, parsedScheme);
        if (theme.palette) {
          theme.palette.mode = mode;
          theme.palette.colorScheme = resolvedColorScheme;
        }
      }
      const resolvedDefaultColorScheme = (() => {
        if (typeof defaultColorScheme === "string") {
          return defaultColorScheme;
        }
        if (defaultMode === "dark") {
          return defaultColorScheme.dark;
        }
        return defaultColorScheme.light;
      })();
      if (key === resolvedDefaultColorScheme) {
        defaultColorSchemeStyleSheet[`${colorSchemeSelector}, [${attribute}="${key}"]`] = css7;
      } else {
        otherColorSchemesStyleSheet[`${colorSchemeSelector === ":root" ? "" : colorSchemeSelector}[${attribute}="${key}"]`] = css7;
      }
    });
    useEffect(() => {
      if (colorScheme && colorSchemeNode) {
        colorSchemeNode.setAttribute(attribute, colorScheme);
      }
    }, [colorScheme, attribute, colorSchemeNode]);
    useEnhancedEffect_default(() => {
      if (!mode || !enableColorScheme || !colorSchemeNode) {
        return void 0;
      }
      const priorColorScheme = colorSchemeNode.style.getPropertyValue("color-scheme");
      if (mode === "system") {
        colorSchemeNode.style.setProperty("color-scheme", systemMode);
      } else {
        colorSchemeNode.style.setProperty("color-scheme", mode);
      }
      return () => {
        colorSchemeNode.style.setProperty("color-scheme", priorColorScheme);
      };
    }, [mode, systemMode, enableColorScheme, colorSchemeNode]);
    useEffect(() => {
      let timer;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css7 = documentNode.createElement("style");
        css7.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css7);
        (() => window.getComputedStyle(documentNode.body))();
        timer = setTimeout(() => {
          documentNode.head.removeChild(css7);
        }, 1);
      }
      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    return e3(ColorSchemeContext.Provider, {
      value: {
        mode,
        setMode,
        lightColorScheme,
        darkColorScheme,
        colorScheme,
        setColorScheme,
        allColorSchemes
      },
      children: [e3(GlobalStyles, {
        styles: {
          [colorSchemeSelector]: rootCss
        }
      }), e3(GlobalStyles, {
        styles: defaultColorSchemeStyleSheet
      }), e3(GlobalStyles, {
        styles: otherColorSchemesStyleSheet
      }), e3(ThemeProvider_default2, {
        theme: resolveTheme ? resolveTheme(theme) : theme,
        children: children2
      })]
    });
  }
  __name(CssVarsProvider2, "CssVarsProvider");
  false ? CssVarsProvider2.propTypes = {
    attribute: import_prop_types35.default.string,
    children: import_prop_types35.default.node,
    colorSchemeNode: import_prop_types35.default.any,
    colorSchemeSelector: import_prop_types35.default.string,
    colorSchemeStorageKey: import_prop_types35.default.string,
    defaultColorScheme: import_prop_types35.default.oneOfType([import_prop_types35.default.string, import_prop_types35.default.object]),
    defaultMode: import_prop_types35.default.string,
    disableTransitionOnChange: import_prop_types35.default.bool,
    documentNode: import_prop_types35.default.any,
    enableColorScheme: import_prop_types35.default.bool,
    modeStorageKey: import_prop_types35.default.string,
    shouldSkipGeneratingVar: import_prop_types35.default.func,
    storageWindow: import_prop_types35.default.any,
    theme: import_prop_types35.default.object
  } : void 0;
  const getInitColorSchemeScript3 = __name((params) => getInitColorSchemeScript(_extends({
    attribute: defaultAttribute,
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    modeStorageKey: defaultModeStorageKey,
    enableColorScheme: designSystemEnableColorScheme
  }, params)), "getInitColorSchemeScript");
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme: useColorScheme2,
    getInitColorSchemeScript: getInitColorSchemeScript3
  };
}
__name(createCssVarsProvider, "createCssVarsProvider");
init_define_process();
function createGetCssVar(prefix = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))/)) {
      return `, var(--${prefix ? `${prefix}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  __name(appendVar, "appendVar");
  const getCssVar = __name((field, ...fallbacks) => {
    return `var(--${prefix ? `${prefix}-` : ""}${field}${appendVar(...fallbacks)})`;
  }, "getCssVar");
  return getCssVar;
}
__name(createGetCssVar, "createGetCssVar");
init_define_process();
init_react_preact();
var import_prop_types36 = __toESM(require_prop_types());
init_react_preact();
var _excluded31 = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"];
var defaultTheme = createTheme_default();
var defaultCreateStyledComponent = styled_default("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
var useThemePropsDefault = __name((inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme
}), "useThemePropsDefault");
var useUtilityClasses16 = __name((ownerState, componentName) => {
  const getContainerUtilityClass = __name((slot) => {
    return generateUtilityClass(componentName, slot);
  }, "getContainerUtilityClass");
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
}, "useUtilityClasses");
function createContainer(options = {}) {
  const {
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps3 = useThemePropsDefault,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme,
    ownerState
  }) => _extends({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    display: "block"
  }, !ownerState.disableGutters && {
    paddingLeft: theme.spacing(2),
    paddingRight: theme.spacing(2),
    [theme.breakpoints.up("sm")]: {
      paddingLeft: theme.spacing(3),
      paddingRight: theme.spacing(3)
    }
  }), ({
    theme,
    ownerState
  }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme,
    ownerState
  }) => _extends({}, ownerState.maxWidth === "xs" && {
    [theme.breakpoints.up("xs")]: {
      maxWidth: Math.max(theme.breakpoints.values.xs, 444)
    }
  }, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
    [theme.breakpoints.up(ownerState.maxWidth)]: {
      maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
    }
  }));
  const Container2 = forwardRef(__name(function Container3(inProps, ref) {
    const props = useThemeProps3(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded31);
    const ownerState = _extends({}, props, {
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    });
    const classes = useUtilityClasses16(ownerState, componentName);
    return e3(ContainerRoot, _extends({
      as: component,
      ownerState,
      className: clsx_m_default(classes.root, className),
      ref
    }, other));
  }, "Container"));
  false ? Container2.propTypes = {
    children: import_prop_types36.default.node,
    classes: import_prop_types36.default.object,
    className: import_prop_types36.default.string,
    component: import_prop_types36.default.elementType,
    disableGutters: import_prop_types36.default.bool,
    fixed: import_prop_types36.default.bool,
    maxWidth: import_prop_types36.default.oneOfType([import_prop_types36.default.oneOf(["xs", "sm", "md", "lg", "xl", false]), import_prop_types36.default.string]),
    sx: import_prop_types36.default.oneOfType([import_prop_types36.default.arrayOf(import_prop_types36.default.oneOfType([import_prop_types36.default.func, import_prop_types36.default.object, import_prop_types36.default.bool])), import_prop_types36.default.func, import_prop_types36.default.object])
  } : void 0;
  return Container2;
}
__name(createContainer, "createContainer");
init_define_process();
init_define_process();
var import_prop_types37 = __toESM(require_prop_types());
var Container = createContainer();
false ? Container.propTypes = {
  children: import_prop_types37.default.node,
  classes: import_prop_types37.default.object,
  component: import_prop_types37.default.elementType,
  disableGutters: import_prop_types37.default.bool,
  fixed: import_prop_types37.default.bool,
  maxWidth: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["xs", "sm", "md", "lg", "xl", false]), import_prop_types37.default.string]),
  sx: import_prop_types37.default.oneOfType([import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.func, import_prop_types37.default.object, import_prop_types37.default.bool])), import_prop_types37.default.func, import_prop_types37.default.object])
} : void 0;
init_define_process();
var containerClasses = generateUtilityClasses("MuiContainer", ["root", "disableGutters", "fixed", "maxWidthXs", "maxWidthSm", "maxWidthMd", "maxWidthLg", "maxWidthXl"]);
init_define_process();
var import_prop_types39 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
var import_prop_types38 = __toESM(require_prop_types());
init_define_process();
var traverseBreakpoints = __name((breakpoints, responsize, iterator) => {
  const smallestBreakpoint = breakpoints.keys[0];
  if (Array.isArray(responsize)) {
    responsize.forEach((breakpointValue, index) => {
      iterator((responsizeStyles, style4) => {
        if (index <= breakpoints.keys.length - 1) {
          if (index === 0) {
            Object.assign(responsizeStyles, style4);
          } else {
            responsizeStyles[breakpoints.up(breakpoints.keys[index])] = style4;
          }
        }
      }, breakpointValue);
    });
  } else if (responsize && typeof responsize === "object") {
    const keys3 = Object.keys(responsize).length > breakpoints.keys.length ? breakpoints.keys : Object.keys(responsize);
    keys3.forEach((key) => {
      if (breakpoints.keys.indexOf(key) !== -1) {
        const breakpointValue = responsize[key];
        if (breakpointValue !== void 0) {
          iterator((responsizeStyles, style4) => {
            if (smallestBreakpoint === key) {
              Object.assign(responsizeStyles, style4);
            } else {
              responsizeStyles[breakpoints.up(key)] = style4;
            }
          }, breakpointValue);
        }
      }
    });
  } else if (typeof responsize === "number" || typeof responsize === "string") {
    iterator((responsizeStyles, style4) => {
      Object.assign(responsizeStyles, style4);
    }, responsize);
  }
}, "traverseBreakpoints");
var generateGridSizeStyles = __name(({
  theme,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme.breakpoints, ownerState.gridSize, (appendStyle, value) => {
    let style4 = {};
    if (value === true) {
      style4 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    }
    if (value === "auto") {
      style4 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    }
    if (typeof value === "number") {
      style4 = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${value} / var(--Grid-columns)${ownerState.nested && ownerState.container ? ` + var(--Grid-columnSpacing)` : ""})`
      };
    }
    appendStyle(styles2, style4);
  });
  return styles2;
}, "generateGridSizeStyles");
var generateGridOffsetStyles = __name(({
  theme,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme.breakpoints, ownerState.gridOffset, (appendStyle, value) => {
    let style4 = {};
    if (value === "auto") {
      style4 = {
        marginLeft: "auto"
      };
    }
    if (typeof value === "number") {
      style4 = {
        marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(--Grid-columns))`
      };
    }
    appendStyle(styles2, style4);
  });
  return styles2;
}, "generateGridOffsetStyles");
var generateGridColumnsStyles = __name(({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {
    "--Grid-columns": 12
  };
  traverseBreakpoints(theme.breakpoints, ownerState.columns, (appendStyle, value) => {
    appendStyle(styles2, {
      "--Grid-columns": value
    });
  });
  return styles2;
}, "generateGridColumnsStyles");
var generateGridRowSpacingStyles = __name(({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
    var _theme$spacing;
    appendStyle(styles2, {
      "--Grid-rowSpacing": typeof value === "string" ? value : (_theme$spacing = theme.spacing) == null ? void 0 : _theme$spacing.call(theme, value)
    });
  });
  return styles2;
}, "generateGridRowSpacingStyles");
var generateGridColumnSpacingStyles = __name(({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
    var _theme$spacing2;
    appendStyle(styles2, {
      "--Grid-columnSpacing": typeof value === "string" ? value : (_theme$spacing2 = theme.spacing) == null ? void 0 : _theme$spacing2.call(theme, value)
    });
  });
  return styles2;
}, "generateGridColumnSpacingStyles");
var generateGridDirectionStyles = __name(({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme.breakpoints, ownerState.direction, (appendStyle, value) => {
    appendStyle(styles2, {
      flexDirection: value
    });
  });
  return styles2;
}, "generateGridDirectionStyles");
var generateGridStyles = __name(({
  ownerState
}) => {
  return _extends({
    minWidth: 0,
    boxSizing: "border-box"
  }, ownerState.container ? _extends({
    display: "flex",
    flexWrap: "wrap"
  }, ownerState.wrap && ownerState.wrap !== "wrap" && {
    flexWrap: ownerState.wrap
  }, {
    margin: `calc(var(--Grid-rowSpacing) / -2) calc(var(--Grid-columnSpacing) / -2)`
  }, ownerState.disableEqualOverflow && {
    margin: `calc(var(--Grid-rowSpacing) * -1) 0px 0px calc(var(--Grid-columnSpacing) * -1)`
  }, ownerState.nested ? _extends({
    padding: `calc(var(--Grid-nested-rowSpacing) / 2) calc(var(--Grid-nested-columnSpacing) / 2)`
  }, (ownerState.disableEqualOverflow || ownerState.parentDisableEqualOverflow) && {
    padding: `calc(var(--Grid-nested-rowSpacing)) 0px 0px calc(var(--Grid-nested-columnSpacing))`
  }) : {
    "--Grid-nested-rowSpacing": "var(--Grid-rowSpacing)",
    "--Grid-nested-columnSpacing": "var(--Grid-columnSpacing)"
  }) : _extends({
    padding: `calc(var(--Grid-rowSpacing) / 2) calc(var(--Grid-columnSpacing) / 2)`
  }, ownerState.disableEqualOverflow && {
    padding: `calc(var(--Grid-rowSpacing)) 0px 0px calc(var(--Grid-columnSpacing))`
  }));
}, "generateGridStyles");
var generateSizeClassNames = __name((gridSize) => {
  const classNames = [];
  Object.entries(gridSize).forEach(([key, value]) => {
    if (value !== false && value !== void 0) {
      classNames.push(`grid-${key}-${String(value)}`);
    }
  });
  return classNames;
}, "generateSizeClassNames");
var generateSpacingClassNames = __name((spacing2, smallestBreakpoint = "xs") => {
  function isValidSpacing(val) {
    if (val === void 0) {
      return false;
    }
    return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
  }
  __name(isValidSpacing, "isValidSpacing");
  if (isValidSpacing(spacing2)) {
    return [`spacing-${smallestBreakpoint}-${String(spacing2)}`];
  }
  if (typeof spacing2 === "object" && !Array.isArray(spacing2)) {
    const classNames = [];
    Object.entries(spacing2).forEach(([key, value]) => {
      if (isValidSpacing(value)) {
        classNames.push(`spacing-${key}-${String(value)}`);
      }
    });
    return classNames;
  }
  return [];
}, "generateSpacingClassNames");
init_react_preact();
var _excluded33 = ["className", "columns", "container", "component", "direction", "wrap", "spacing", "rowSpacing", "columnSpacing", "disableEqualOverflow"];
var defaultTheme2 = createTheme_default();
var defaultCreateStyledComponent2 = styled_default("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault2(props) {
  return useThemeProps({
    props,
    name: "MuiGrid",
    defaultTheme: defaultTheme2
  });
}
__name(useThemePropsDefault2, "useThemePropsDefault");
function createGrid(options = {}) {
  const {
    createStyledComponent = defaultCreateStyledComponent2,
    useThemeProps: useThemeProps3 = useThemePropsDefault2,
    componentName = "MuiGrid"
  } = options;
  const NestedContext = createContext(false);
  const OverflowContext = createContext(void 0);
  const useUtilityClasses24 = __name((ownerState, theme) => {
    const {
      container,
      direction,
      spacing: spacing2,
      wrap: wrap3,
      gridSize
    } = ownerState;
    const slots = {
      root: ["root", container && "container", direction !== "row" && `direction-xs-${String(direction)}`, wrap3 !== "wrap" && `wrap-xs-${String(wrap3)}`, ...generateSizeClassNames(gridSize), ...container ? generateSpacingClassNames(spacing2, theme.breakpoints.keys[0]) : []]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  }, "useUtilityClasses");
  const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
  const Grid2 = forwardRef(__name(function Grid3(inProps, ref) {
    var _inProps$columns, _inProps$spacing, _ref, _inProps$rowSpacing, _ref2, _inProps$columnSpacin, _ref3, _disableEqualOverflow;
    const theme = useTheme_default();
    const themeProps = useThemeProps3(inProps);
    const props = extendSxProp(themeProps);
    const nested = useContext(NestedContext);
    const overflow2 = useContext(OverflowContext);
    const {
      className,
      columns: columnsProp = 12,
      container = false,
      component = "div",
      direction = "row",
      wrap: wrap3 = "wrap",
      spacing: spacingProp = 0,
      rowSpacing: rowSpacingProp = spacingProp,
      columnSpacing: columnSpacingProp = spacingProp,
      disableEqualOverflow: themeDisableEqualOverflow
    } = props, rest2 = _objectWithoutPropertiesLoose(props, _excluded33);
    let disableEqualOverflow = themeDisableEqualOverflow;
    if (nested && themeDisableEqualOverflow !== void 0) {
      disableEqualOverflow = inProps.disableEqualOverflow;
    }
    const gridSize = {};
    const gridOffset = {};
    const other = {};
    Object.entries(rest2).forEach(([key, val]) => {
      if (theme.breakpoints.values[key] !== void 0) {
        gridSize[key] = val;
      } else if (theme.breakpoints.values[key.replace("Offset", "")] !== void 0) {
        gridOffset[key.replace("Offset", "")] = val;
      } else {
        other[key] = val;
      }
    });
    const columns = (_inProps$columns = inProps.columns) != null ? _inProps$columns : nested ? void 0 : columnsProp;
    const spacing2 = (_inProps$spacing = inProps.spacing) != null ? _inProps$spacing : nested ? void 0 : spacingProp;
    const rowSpacing = (_ref = (_inProps$rowSpacing = inProps.rowSpacing) != null ? _inProps$rowSpacing : inProps.spacing) != null ? _ref : nested ? void 0 : rowSpacingProp;
    const columnSpacing = (_ref2 = (_inProps$columnSpacin = inProps.columnSpacing) != null ? _inProps$columnSpacin : inProps.spacing) != null ? _ref2 : nested ? void 0 : columnSpacingProp;
    const ownerState = _extends({}, props, {
      nested,
      columns,
      container,
      direction,
      wrap: wrap3,
      spacing: spacing2,
      rowSpacing,
      columnSpacing,
      gridSize,
      gridOffset,
      disableEqualOverflow: (_ref3 = (_disableEqualOverflow = disableEqualOverflow) != null ? _disableEqualOverflow : overflow2) != null ? _ref3 : false,
      parentDisableEqualOverflow: overflow2
    });
    const classes = useUtilityClasses24(ownerState, theme);
    let result = e3(GridRoot, _extends({
      ref,
      as: component,
      ownerState,
      className: clsx_m_default(classes.root, className)
    }, other));
    if (!nested) {
      result = e3(NestedContext.Provider, {
        value: true,
        children: result
      });
    }
    if (disableEqualOverflow !== void 0 && disableEqualOverflow !== (overflow2 != null ? overflow2 : false)) {
      result = e3(OverflowContext.Provider, {
        value: disableEqualOverflow,
        children: result
      });
    }
    return result;
  }, "Grid"));
  false ? Grid2.propTypes = {
    children: import_prop_types38.default.node,
    className: import_prop_types38.default.string,
    columns: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.number), import_prop_types38.default.number, import_prop_types38.default.object]),
    columnSpacing: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.number, import_prop_types38.default.string])), import_prop_types38.default.number, import_prop_types38.default.object, import_prop_types38.default.string]),
    component: import_prop_types38.default.elementType,
    container: import_prop_types38.default.bool,
    direction: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types38.default.arrayOf(import_prop_types38.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types38.default.object]),
    disableEqualOverflow: import_prop_types38.default.bool,
    lg: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number, import_prop_types38.default.bool]),
    lgOffset: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number]),
    md: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number, import_prop_types38.default.bool]),
    mdOffset: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number]),
    rowSpacing: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.number, import_prop_types38.default.string])), import_prop_types38.default.number, import_prop_types38.default.object, import_prop_types38.default.string]),
    sm: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number, import_prop_types38.default.bool]),
    smOffset: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number]),
    spacing: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.number, import_prop_types38.default.string])), import_prop_types38.default.number, import_prop_types38.default.object, import_prop_types38.default.string]),
    sx: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.func, import_prop_types38.default.object, import_prop_types38.default.bool])), import_prop_types38.default.func, import_prop_types38.default.object]),
    wrap: import_prop_types38.default.oneOf(["nowrap", "wrap-reverse", "wrap"]),
    xl: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number, import_prop_types38.default.bool]),
    xlOffset: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number]),
    xs: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number, import_prop_types38.default.bool]),
    xsOffset: import_prop_types38.default.oneOfType([import_prop_types38.default.oneOf(["auto"]), import_prop_types38.default.number])
  } : void 0;
  return Grid2;
}
__name(createGrid, "createGrid");
var Grid = createGrid();
false ? Grid.propTypes = {
  children: import_prop_types39.default.node,
  columns: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.number), import_prop_types39.default.number, import_prop_types39.default.object]),
  columnSpacing: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.number, import_prop_types39.default.string])), import_prop_types39.default.number, import_prop_types39.default.object, import_prop_types39.default.string]),
  container: import_prop_types39.default.bool,
  direction: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types39.default.arrayOf(import_prop_types39.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types39.default.object]),
  disableEqualOverflow: import_prop_types39.default.bool,
  lg: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number, import_prop_types39.default.bool]),
  lgOffset: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number]),
  md: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number, import_prop_types39.default.bool]),
  mdOffset: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number]),
  rowSpacing: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.number, import_prop_types39.default.string])), import_prop_types39.default.number, import_prop_types39.default.object, import_prop_types39.default.string]),
  sm: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number, import_prop_types39.default.bool]),
  smOffset: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number]),
  spacing: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.number, import_prop_types39.default.string])), import_prop_types39.default.number, import_prop_types39.default.object, import_prop_types39.default.string]),
  sx: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object, import_prop_types39.default.bool])), import_prop_types39.default.func, import_prop_types39.default.object]),
  wrap: import_prop_types39.default.oneOf(["nowrap", "wrap-reverse", "wrap"]),
  xl: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number, import_prop_types39.default.bool]),
  xlOffset: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number]),
  xs: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number, import_prop_types39.default.bool]),
  xsOffset: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["auto"]), import_prop_types39.default.number])
} : void 0;
init_define_process();
init_define_process();
init_define_process();
var SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
var WRAPS = ["nowrap", "wrap-reverse", "wrap"];
var GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
var gridClasses = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  ...SPACINGS.map((spacing2) => `spacing-xs-${spacing2}`),
  ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
  ...WRAPS.map((wrap3) => `wrap-xs-${wrap3}`),
  ...GRID_SIZES.map((size) => `grid-xs-${size}`),
  ...GRID_SIZES.map((size) => `grid-sm-${size}`),
  ...GRID_SIZES.map((size) => `grid-md-${size}`),
  ...GRID_SIZES.map((size) => `grid-lg-${size}`),
  ...GRID_SIZES.map((size) => `grid-xl-${size}`)
]);
init_define_process();
var import_prop_types41 = __toESM(require_prop_types());
init_define_process();
init_react_preact();
var import_prop_types40 = __toESM(require_prop_types());
init_react_preact();
var _excluded34 = ["component", "direction", "spacing", "divider", "children", "className"];
var defaultTheme3 = createTheme_default();
var defaultCreateStyledComponent3 = styled_default("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault3(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme3
  });
}
__name(useThemePropsDefault3, "useThemePropsDefault");
function joinChildren(children2, separator) {
  const childrenArray = Children.toArray(children2).filter(Boolean);
  return childrenArray.reduce((output, child, index) => {
    output.push(child);
    if (index < childrenArray.length - 1) {
      output.push(cloneElement(separator, {
        key: `separator-${index}`
      }));
    }
    return output;
  }, []);
}
__name(joinChildren, "joinChildren");
var getSideFromDirection = __name((direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
}, "getSideFromDirection");
var style3 = __name(({
  ownerState,
  theme
}) => {
  let styles2 = _extends({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme);
    const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = __name((propValue, breakpoint) => {
      return {
        "& > :not(style) + :not(style)": {
          margin: 0,
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue22(transformer, propValue)
        }
      };
    }, "styleFromPropValue");
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
  return styles2;
}, "style");
function createStack(options = {}) {
  const {
    createStyledComponent = defaultCreateStyledComponent3,
    useThemeProps: useThemeProps3 = useThemePropsDefault3,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses24 = __name(() => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  }, "useUtilityClasses");
  const StackRoot = createStyledComponent(style3);
  const Stack22 = forwardRef(__name(function Grid2(inProps, ref) {
    const themeProps = useThemeProps3(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing: spacing2 = 0,
      divider,
      children: children2,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded34);
    const ownerState = {
      direction,
      spacing: spacing2
    };
    const classes = useUtilityClasses24();
    return e3(StackRoot, _extends({
      as: component,
      ownerState,
      ref,
      className: clsx_m_default(classes.root, className)
    }, other, {
      children: divider ? joinChildren(children2, divider) : children2
    }));
  }, "Grid"));
  false ? Stack22.propTypes = {
    children: import_prop_types40.default.node,
    direction: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types40.default.arrayOf(import_prop_types40.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types40.default.object]),
    divider: import_prop_types40.default.node,
    spacing: import_prop_types40.default.oneOfType([import_prop_types40.default.arrayOf(import_prop_types40.default.oneOfType([import_prop_types40.default.number, import_prop_types40.default.string])), import_prop_types40.default.number, import_prop_types40.default.object, import_prop_types40.default.string]),
    sx: import_prop_types40.default.oneOfType([import_prop_types40.default.arrayOf(import_prop_types40.default.oneOfType([import_prop_types40.default.func, import_prop_types40.default.object, import_prop_types40.default.bool])), import_prop_types40.default.func, import_prop_types40.default.object])
  } : void 0;
  return Stack22;
}
__name(createStack, "createStack");
var Stack2 = createStack();
false ? Stack2.propTypes = {
  children: import_prop_types41.default.node,
  direction: import_prop_types41.default.oneOfType([import_prop_types41.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types41.default.arrayOf(import_prop_types41.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types41.default.object]),
  divider: import_prop_types41.default.node,
  spacing: import_prop_types41.default.oneOfType([import_prop_types41.default.arrayOf(import_prop_types41.default.oneOfType([import_prop_types41.default.number, import_prop_types41.default.string])), import_prop_types41.default.number, import_prop_types41.default.object, import_prop_types41.default.string]),
  sx: import_prop_types41.default.oneOfType([import_prop_types41.default.arrayOf(import_prop_types41.default.oneOfType([import_prop_types41.default.func, import_prop_types41.default.object, import_prop_types41.default.bool])), import_prop_types41.default.func, import_prop_types41.default.object])
} : void 0;
init_define_process();
init_define_process();
init_define_process();
var stackClasses = generateUtilityClasses("MuiStack", ["root"]);
init_define_process();
init_define_process();
init_define_process();
function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
__name(createMixins, "createMixins");
init_define_process();
init_define_process();
var common = {
  black: "#000",
  white: "#fff"
};
var common_default = common;
init_define_process();
var grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
var grey_default = grey;
init_define_process();
var purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
var purple_default = purple;
init_define_process();
var red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
var red_default = red;
init_define_process();
var orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
var orange_default = orange;
init_define_process();
var blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
var blue_default = blue;
init_define_process();
var lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
var lightBlue_default = lightBlue;
init_define_process();
var green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
var green_default = green;
var _excluded35 = ["mode", "contrastThreshold", "tonalOffset"];
var light = {
  text: {
    primary: "rgba(0, 0, 0, 0.87)",
    secondary: "rgba(0, 0, 0, 0.6)",
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  divider: "rgba(0, 0, 0, 0.12)",
  background: {
    paper: common_default.white,
    default: common_default.white
  },
  action: {
    active: "rgba(0, 0, 0, 0.54)",
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    disabled: "rgba(0, 0, 0, 0.26)",
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
var dark = {
  text: {
    primary: common_default.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common_default.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
__name(addLightOrDark, "addLightOrDark");
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue_default[200],
      light: blue_default[50],
      dark: blue_default[400]
    };
  }
  return {
    main: blue_default[700],
    light: blue_default[400],
    dark: blue_default[800]
  };
}
__name(getDefaultPrimary, "getDefaultPrimary");
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple_default[200],
      light: purple_default[50],
      dark: purple_default[400]
    };
  }
  return {
    main: purple_default[500],
    light: purple_default[300],
    dark: purple_default[700]
  };
}
__name(getDefaultSecondary, "getDefaultSecondary");
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red_default[500],
      light: red_default[300],
      dark: red_default[700]
    };
  }
  return {
    main: red_default[700],
    light: red_default[400],
    dark: red_default[800]
  };
}
__name(getDefaultError, "getDefaultError");
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue_default[400],
      light: lightBlue_default[300],
      dark: lightBlue_default[700]
    };
  }
  return {
    main: lightBlue_default[700],
    light: lightBlue_default[500],
    dark: lightBlue_default[900]
  };
}
__name(getDefaultInfo, "getDefaultInfo");
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green_default[400],
      light: green_default[300],
      dark: green_default[700]
    };
  }
  return {
    main: green_default[800],
    light: green_default[500],
    dark: green_default[900]
  };
}
__name(getDefaultSuccess, "getDefaultSuccess");
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange_default[400],
      light: orange_default[300],
      dark: orange_default[700]
    };
  }
  return {
    main: "#ed6c02",
    light: orange_default[500],
    dark: orange_default[900]
  };
}
__name(getDefaultWarning, "getDefaultWarning");
function createPalette(palette2) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette2, other = _objectWithoutPropertiesLoose(palette2, _excluded35);
  const primary = palette2.primary || getDefaultPrimary(mode);
  const secondary = palette2.secondary || getDefaultSecondary(mode);
  const error = palette2.error || getDefaultError(mode);
  const info = palette2.info || getDefaultInfo(mode);
  const success = palette2.success || getDefaultSuccess(mode);
  const warning2 = palette2.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (false) {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  __name(getContrastText, "getContrastText");
  const augmentColor = __name(({
    color: color22,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color22 = _extends({}, color22);
    if (!color22.main && color22[mainShade]) {
      color22.main = color22[mainShade];
    }
    if (!color22.hasOwnProperty("main")) {
      throw new Error(false ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color22.main !== "string") {
      throw new Error(false ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color22.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color22.main)));
    }
    addLightOrDark(color22, "light", lightShade, tonalOffset);
    addLightOrDark(color22, "dark", darkShade, tonalOffset);
    if (!color22.contrastText) {
      color22.contrastText = getContrastText(color22.main);
    }
    return color22;
  }, "augmentColor");
  const modes2 = {
    dark,
    light
  };
  if (false) {
    if (!modes2[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge(_extends({
    common: _extends({}, common_default),
    mode,
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    error: augmentColor({
      color: error,
      name: "error"
    }),
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    info: augmentColor({
      color: info,
      name: "info"
    }),
    success: augmentColor({
      color: success,
      name: "success"
    }),
    grey: grey_default,
    contrastThreshold,
    getContrastText,
    augmentColor,
    tonalOffset
  }, modes2[mode]), other);
  return paletteOutput;
}
__name(createPalette, "createPalette");
init_define_process();
var _excluded36 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round2(value) {
  return Math.round(value * 1e5) / 1e5;
}
__name(round2, "round");
var caseAllCaps = {
  textTransform: "uppercase"
};
var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette2, typography2) {
  const _ref = typeof typography2 === "function" ? typography2(palette2) : typography2, {
    fontFamily: fontFamily2 = defaultFontFamily,
    fontSize: fontSize2 = 14,
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize = 16,
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded36);
  if (false) {
    if (typeof fontSize2 !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = __name((fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    lineHeight: lineHeight2
  }, fontFamily2 === defaultFontFamily ? {
    letterSpacing: `${round2(letterSpacing2 / size)}em`
  } : {}, casing, allVariants), "buildVariant");
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
  });
}
__name(createTypography, "createTypography");
init_define_process();
var shadowKeyUmbraOpacity = 0.2;
var shadowKeyPenumbraOpacity = 0.14;
var shadowAmbientShadowOpacity = 0.12;
function createShadow(...px2) {
  return [`${px2[0]}px ${px2[1]}px ${px2[2]}px ${px2[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px2[4]}px ${px2[5]}px ${px2[6]}px ${px2[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px2[8]}px ${px2[9]}px ${px2[10]}px ${px2[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
__name(createShadow, "createShadow");
var shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
var shadows_default2 = shadows;
init_define_process();
var _excluded37 = ["duration", "easing", "delay"];
var easing = {
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  standard: 300,
  complex: 375,
  enteringScreen: 225,
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
__name(formatMs, "formatMs");
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
__name(getAutoHeightDuration, "getAutoHeightDuration");
function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);
  const mergedDuration = _extends({}, duration, inputTransitions.duration);
  const create = __name((props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options, other = _objectWithoutPropertiesLoose(options, _excluded37);
    if (false) {
      const isString3 = __name((value) => typeof value === "string", "isString");
      const isNumber2 = __name((value) => !isNaN(parseFloat(value)), "isNumber");
      if (!isString3(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber2(durationOption) && !isString3(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString3(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber2(delay) && !isString3(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  }, "create");
  return _extends({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
__name(createTransitions, "createTransitions");
init_define_process();
var zIndex2 = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
var zIndex_default = zIndex2;
var _excluded38 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme2(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded38);
  if (options.vars) {
    throw new Error(false ? `MUI: \`vars\` is a private field used for CSS variables support.
Please use another name.` : formatMuiErrorMessage(18));
  }
  const palette2 = createPalette(paletteInput);
  const systemTheme = createTheme_default(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette: palette2,
    shadows: shadows_default2.slice(),
    typography: createTypography(palette2, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex_default)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (false) {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = __name((node, component) => {
      let key;
      for (key in node) {
        const child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (false) {
            const stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node[key] = {};
        }
      }
    }, "traverse");
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.indexOf("Mui") === 0) {
        traverse(styleOverrides, component);
      }
    });
  }
  return muiTheme;
}
__name(createTheme2, "createTheme");
var createTheme_default2 = createTheme2;
var defaultTheme4 = createTheme_default2();
var defaultTheme_default = defaultTheme4;
var rootShouldForwardProp = __name((prop) => shouldForwardProp(prop) && prop !== "classes", "rootShouldForwardProp");
var slotShouldForwardProp = shouldForwardProp;
var styled3 = createStyled({
  defaultTheme: defaultTheme_default,
  rootShouldForwardProp
});
var styled_default2 = styled3;
init_define_process();
function useThemeProps2({
  props,
  name
}) {
  return useThemeProps({
    props,
    name,
    defaultTheme: defaultTheme_default
  });
}
__name(useThemeProps2, "useThemeProps");
init_define_process();
var useForkRef_default = useForkRef;
init_define_process();
var useEventCallback_default = useEventCallback;
init_define_process();
var useIsFocusVisible_default = useIsFocusVisible;
init_define_process();
init_react_preact();
var import_prop_types49 = __toESM(require_prop_types());
init_define_process();
init_define_process();
init_define_process();
init_define_process();
function _setPrototypeOf(o5, p22) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : __name(function _setPrototypeOf2(o22, p32) {
    o22.__proto__ = p32;
    return o22;
  }, "_setPrototypeOf");
  return _setPrototypeOf(o5, p22);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
__name(_inheritsLoose, "_inheritsLoose");
var import_prop_types44 = __toESM(require_prop_types());
init_define_process();
init_define_process();
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
__name(hasClass, "hasClass");
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
__name(addClass, "addClass");
init_define_process();
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
__name(replaceClassName, "replaceClassName");
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
__name(removeClass, "removeClass");
init_react_preact();
init_define_process();
var import_prop_types43 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
init_define_process();
var config_default = {
  disabled: false
};
init_define_process();
var import_prop_types42 = __toESM(require_prop_types());
var timeoutsShape = false ? import_prop_types42.default.oneOfType([import_prop_types42.default.number, import_prop_types42.default.shape({
  enter: import_prop_types42.default.number,
  exit: import_prop_types42.default.number,
  appear: import_prop_types42.default.number
}).isRequired]) : null;
var classNamesShape = false ? import_prop_types42.default.oneOfType([import_prop_types42.default.string, import_prop_types42.default.shape({
  enter: import_prop_types42.default.string,
  exit: import_prop_types42.default.string,
  active: import_prop_types42.default.string
}), import_prop_types42.default.shape({
  enter: import_prop_types42.default.string,
  enterDone: import_prop_types42.default.string,
  enterActive: import_prop_types42.default.string,
  exit: import_prop_types42.default.string,
  exitDone: import_prop_types42.default.string,
  exitActive: import_prop_types42.default.string
})]) : null;
init_define_process();
init_react_preact();
var TransitionGroupContext_default = react_preact_default.createContext(null);
init_define_process();
var forceReflow = __name(function forceReflow2(node) {
  return node.scrollTop;
}, "forceReflow");
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  __name(Transition2, "Transition");
  Transition2.getDerivedStateFromProps = __name(function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  }, "getDerivedStateFromProps");
  var _proto = Transition2.prototype;
  _proto.componentDidMount = __name(function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  }, "componentDidMount");
  _proto.componentDidUpdate = __name(function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  }, "componentDidUpdate");
  _proto.componentWillUnmount = __name(function componentWillUnmount() {
    this.cancelNextCallback();
  }, "componentWillUnmount");
  _proto.getTimeouts = __name(function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  }, "getTimeouts");
  _proto.updateStatus = __name(function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : react_preact_default.findDOMNode(this);
          if (node)
            forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  }, "updateStatus");
  _proto.performEnter = __name(function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [react_preact_default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  }, "performEnter");
  _proto.performExit = __name(function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : react_preact_default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  }, "performExit");
  _proto.cancelNextCallback = __name(function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  }, "cancelNextCallback");
  _proto.safeSetState = __name(function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  }, "safeSetState");
  _proto.setNextCallback = __name(function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  }, "setNextCallback");
  _proto.onTransitionEnd = __name(function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : react_preact_default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  }, "onTransitionEnd");
  _proto.render = __name(function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return react_preact_default.createElement(TransitionGroupContext_default.Provider, {
      value: null
    }, typeof children2 === "function" ? children2(status, childProps) : react_preact_default.cloneElement(react_preact_default.Children.only(children2), childProps));
  }, "render");
  return Transition2;
}(react_preact_default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = false ? {
  nodeRef: import_prop_types43.default.shape({
    current: typeof Element === "undefined" ? import_prop_types43.default.any : function(propValue, key, componentName, location2, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types43.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location2, propFullName, secret);
    }
  }),
  children: import_prop_types43.default.oneOfType([import_prop_types43.default.func.isRequired, import_prop_types43.default.element.isRequired]).isRequired,
  in: import_prop_types43.default.bool,
  mountOnEnter: import_prop_types43.default.bool,
  unmountOnExit: import_prop_types43.default.bool,
  appear: import_prop_types43.default.bool,
  enter: import_prop_types43.default.bool,
  exit: import_prop_types43.default.bool,
  timeout: __name(function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  }, "timeout"),
  addEndListener: import_prop_types43.default.func,
  onEnter: import_prop_types43.default.func,
  onEntering: import_prop_types43.default.func,
  onEntered: import_prop_types43.default.func,
  onExit: import_prop_types43.default.func,
  onExiting: import_prop_types43.default.func,
  onExited: import_prop_types43.default.func
} : {};
function noop() {
}
__name(noop, "noop");
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;
var _addClass = __name(function addClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c5) {
    return addClass(node, c5);
  });
}, "addClass");
var removeClass2 = __name(function removeClass3(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c5) {
    return removeClass(node, c5);
  });
}, "removeClass");
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  __name(CSSTransition2, "CSSTransition");
  var _proto = CSSTransition2.prototype;
  _proto.addClass = __name(function addClass3(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node)
        forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  }, "addClass");
  _proto.removeClasses = __name(function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass2(node, baseClassName);
    }
    if (activeClassName) {
      removeClass2(node, activeClassName);
    }
    if (doneClassName) {
      removeClass2(node, doneClassName);
    }
  }, "removeClasses");
  _proto.render = __name(function render2() {
    var _this$props = this.props, _22 = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return react_preact_default.createElement(Transition_default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, "render");
  return CSSTransition2;
}(react_preact_default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = false ? _extends({}, Transition_default.propTypes, {
  classNames: classNamesShape,
  onEnter: import_prop_types44.default.func,
  onEntering: import_prop_types44.default.func,
  onEntered: import_prop_types44.default.func,
  onExit: import_prop_types44.default.func,
  onExiting: import_prop_types44.default.func,
  onExited: import_prop_types44.default.func
}) : {};
init_define_process();
var import_prop_types46 = __toESM(require_prop_types());
init_react_preact();
init_react_preact();
init_define_process();
init_define_process();
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
__name(_assertThisInitialized, "_assertThisInitialized");
var import_prop_types45 = __toESM(require_prop_types());
init_react_preact();
init_define_process();
init_react_preact();
function getChildMapping(children2, mapFn) {
  var mapper = __name(function mapper2(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  }, "mapper");
  var result = /* @__PURE__ */ Object.create(null);
  if (children2)
    Children.map(children2, function(c5) {
      return c5;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
__name(getChildMapping, "getChildMapping");
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  __name(getValueForKey, "getValueForKey");
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i4;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i4 = 0; i4 < nextKeysPending[nextKey].length; i4++) {
        var pendingNextKey = nextKeysPending[nextKey][i4];
        childMapping[nextKeysPending[nextKey][i4]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i4 = 0; i4 < pendingKeys.length; i4++) {
    childMapping[pendingKeys[i4]] = getValueForKey(pendingKeys[i4]);
  }
  return childMapping;
}
__name(mergeChildMappings, "mergeChildMappings");
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
__name(getProp, "getProp");
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
__name(getInitialChildMapping, "getInitialChildMapping");
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      children2[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}
__name(getNextChildMapping, "getNextChildMapping");
var values22 = Object.values || function(obj) {
  return Object.keys(obj).map(function(k5) {
    return obj[k5];
  });
};
var defaultProps = {
  component: "div",
  childFactory: __name(function childFactory(child) {
    return child;
  }, "childFactory")
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  __name(TransitionGroup2, "TransitionGroup");
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = __name(function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  }, "componentDidMount");
  _proto.componentWillUnmount = __name(function componentWillUnmount() {
    this.mounted = false;
  }, "componentWillUnmount");
  TransitionGroup2.getDerivedStateFromProps = __name(function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  }, "getDerivedStateFromProps");
  _proto.handleExited = __name(function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  }, "handleExited");
  _proto.render = __name(function render2() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values22(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return react_preact_default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, children2);
    }
    return react_preact_default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, react_preact_default.createElement(Component2, props, children2));
  }, "render");
  return TransitionGroup2;
}(react_preact_default.Component);
TransitionGroup.propTypes = false ? {
  component: import_prop_types45.default.any,
  children: import_prop_types45.default.node,
  appear: import_prop_types45.default.bool,
  enter: import_prop_types45.default.bool,
  exit: import_prop_types45.default.bool,
  childFactory: import_prop_types45.default.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  __name(ReplaceTransition2, "ReplaceTransition");
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = __name(function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = react_preact_default.Children.toArray(children2)[idx];
    if (child.props[handler])
      (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : react_preact_default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  }, "handleLifecycle");
  _proto.render = __name(function render2() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = react_preact_default.Children.toArray(children2), first3 = _React$Children$toArr[0], second = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return react_preact_default.createElement(TransitionGroup_default, props, inProp ? react_preact_default.cloneElement(first3, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : react_preact_default.cloneElement(second, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  }, "render");
  return ReplaceTransition2;
}(react_preact_default.Component);
ReplaceTransition.propTypes = false ? {
  in: import_prop_types46.default.bool.isRequired,
  children: __name(function children(props, propName) {
    if (react_preact_default.Children.count(props[propName]) !== 2)
      return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }, "children")
} : {};
init_define_process();
init_react_preact();
var import_prop_types47 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (react_preact_default.isValidElement(oldChildren) && react_preact_default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
__name(areChildrenDifferent, "areChildrenDifferent");
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = __name(function callHook2(element, name, cb2) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb2();
  };
}, "callHook");
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return react_preact_default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, react_preact_default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return react_preact_default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, react_preact_default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [react_preact_default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, react_preact_default.cloneElement(children2, {
        in: true
      }));
    })
  }), react_preact_default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  __name(SwitchTransition2, "SwitchTransition");
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = __name(function componentDidMount() {
    this.appeared = true;
  }, "componentDidMount");
  SwitchTransition2.getDerivedStateFromProps = __name(function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: react_preact_default.cloneElement(props.children, {
        in: true
      })
    };
  }, "getDerivedStateFromProps");
  _proto.render = __name(function render2() {
    var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return react_preact_default.createElement(TransitionGroupContext_default.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  }, "render");
  return SwitchTransition2;
}(react_preact_default.Component);
SwitchTransition.propTypes = false ? {
  mode: import_prop_types47.default.oneOf([modes.in, modes.out]),
  children: import_prop_types47.default.oneOfType([import_prop_types47.default.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
init_define_process();
init_react_preact();
var import_prop_types48 = __toESM(require_prop_types());
init_react_preact();
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout: timeout2
  } = props;
  const [leaving, setLeaving] = useState(false);
  const rippleClassName = clsx_m_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx_m_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout2);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout2]);
  return e3("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: e3("span", {
      className: childClassName
    })
  });
}
__name(Ripple, "Ripple");
false ? Ripple.propTypes = {
  classes: import_prop_types48.default.object.isRequired,
  className: import_prop_types48.default.string,
  in: import_prop_types48.default.bool,
  onExited: import_prop_types48.default.func,
  pulsate: import_prop_types48.default.bool,
  rippleSize: import_prop_types48.default.number,
  rippleX: import_prop_types48.default.number,
  rippleY: import_prop_types48.default.number,
  timeout: import_prop_types48.default.number.isRequired
} : void 0;
var Ripple_default = Ripple;
init_define_process();
var touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
var touchRippleClasses_default = touchRippleClasses;
init_react_preact();
var _excluded39 = ["center", "classes", "className"];
var _4 = __name((t3) => t3, "_");
var _t;
var _t2;
var _t3;
var _t4;
var DURATION = 550;
var DELAY_RIPPLE = 80;
var enterKeyframe = (0, import_react10.keyframes)(_t || (_t = _4`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
var exitKeyframe = (0, import_react10.keyframes)(_t2 || (_t2 = _4`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
var pulsateKeyframe = (0, import_react10.keyframes)(_t3 || (_t3 = _4`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
var TouchRippleRoot = styled_default2("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
var TouchRippleRipple = styled_default2(Ripple_default, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _4`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses_default.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses_default.child, touchRippleClasses_default.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);
var TouchRipple = forwardRef(__name(function TouchRipple2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded39);
  const [ripples, setRipples] = useState([]);
  const nextKey = useRef(0);
  const rippleCallback = useRef(null);
  useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = useRef(false);
  const startTimer = useRef(null);
  const startTimerCommit = useRef(null);
  const container = useRef(null);
  useEffect(() => {
    return () => {
      clearTimeout(startTimer.current);
    };
  }, []);
  const startCommit = useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, e3(TouchRippleRipple, {
      classes: {
        ripple: clsx_m_default(classes.ripple, touchRippleClasses_default.ripple),
        rippleVisible: clsx_m_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),
        ripplePulsate: clsx_m_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),
        child: clsx_m_default(classes.child, touchRippleClasses_default.child),
        childLeaving: clsx_m_default(classes.childLeaving, touchRippleClasses_default.childLeaving),
        childPulsate: clsx_m_default(classes.childPulsate, touchRippleClasses_default.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start2 = useCallback((event = {}, options = {}, cb2) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return e3(TouchRippleRoot, _extends({
    className: clsx_m_default(touchRippleClasses_default.root, classes.root, className),
    ref: container
  }, other, {
    children: e3(TransitionGroup_default, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
}, "TouchRipple"));
false ? TouchRipple.propTypes = {
  center: import_prop_types49.default.bool,
  classes: import_prop_types49.default.object,
  className: import_prop_types49.default.string
} : void 0;
var TouchRipple_default = TouchRipple;
init_define_process();
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
__name(getButtonBaseUtilityClass, "getButtonBaseUtilityClass");
var buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
var buttonBaseClasses_default = buttonBaseClasses;
init_react_preact();
init_react_preact();
var _excluded40 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
var useUtilityClasses17 = __name((ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
}, "useUtilityClasses");
var ButtonBaseRoot = styled_default2("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  outline: 0,
  border: 0,
  margin: 0,
  borderRadius: 0,
  padding: 0,
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  WebkitAppearance: "none",
  textDecoration: "none",
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
  },
  [`&.${buttonBaseClasses_default.disabled}`]: {
    pointerEvents: "none",
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
var ButtonBase = forwardRef(__name(function ButtonBase2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children: children2,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded40);
  const buttonRef = useRef(null);
  const rippleRef = useRef(null);
  const handleRippleRef = useForkRef_default(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible_default();
  const [focusVisible, setFocusVisible] = useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = useState(false);
  useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback_default((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  __name(useRippleHandler, "useRippleHandler");
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur2 = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback_default((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = __name(() => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  }, "isNonNativeButton");
  const keydownRef = useRef(false);
  const handleKeyDown3 = useEventCallback_default((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback_default((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleOwnRef = useForkRef_default(focusVisibleRef, buttonRef);
  const handleRef = useForkRef_default(ref, handleOwnRef);
  if (false) {
    useEffect(() => {
      if (enableTouchRipple && !rippleRef.current) {
        console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join("\n"));
      }
    }, [enableTouchRipple]);
  }
  const ownerState = _extends({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses17(ownerState);
  return e3(ButtonBaseRoot, _extends({
    as: ComponentProp,
    className: clsx_m_default(classes.root, className),
    ownerState,
    onBlur: handleBlur2,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown3,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children2, enableTouchRipple ? e3(TouchRipple_default, _extends({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
}, "ButtonBase"));
false ? ButtonBase.propTypes = {
  action: refType_default,
  centerRipple: import_prop_types50.default.bool,
  children: import_prop_types50.default.node,
  classes: import_prop_types50.default.object,
  className: import_prop_types50.default.string,
  component: elementTypeAcceptingRef_default,
  disabled: import_prop_types50.default.bool,
  disableRipple: import_prop_types50.default.bool,
  disableTouchRipple: import_prop_types50.default.bool,
  focusRipple: import_prop_types50.default.bool,
  focusVisibleClassName: import_prop_types50.default.string,
  href: import_prop_types50.default.any,
  LinkComponent: import_prop_types50.default.elementType,
  onBlur: import_prop_types50.default.func,
  onClick: import_prop_types50.default.func,
  onContextMenu: import_prop_types50.default.func,
  onDragLeave: import_prop_types50.default.func,
  onFocus: import_prop_types50.default.func,
  onFocusVisible: import_prop_types50.default.func,
  onKeyDown: import_prop_types50.default.func,
  onKeyUp: import_prop_types50.default.func,
  onMouseDown: import_prop_types50.default.func,
  onMouseLeave: import_prop_types50.default.func,
  onMouseUp: import_prop_types50.default.func,
  onTouchEnd: import_prop_types50.default.func,
  onTouchMove: import_prop_types50.default.func,
  onTouchStart: import_prop_types50.default.func,
  sx: import_prop_types50.default.oneOfType([import_prop_types50.default.arrayOf(import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.object, import_prop_types50.default.bool])), import_prop_types50.default.func, import_prop_types50.default.object]),
  tabIndex: import_prop_types50.default.number,
  TouchRippleProps: import_prop_types50.default.object,
  touchRippleRef: import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.shape({
    current: import_prop_types50.default.shape({
      pulsate: import_prop_types50.default.func.isRequired,
      start: import_prop_types50.default.func.isRequired,
      stop: import_prop_types50.default.func.isRequired
    })
  })]),
  type: import_prop_types50.default.oneOfType([import_prop_types50.default.oneOf(["button", "reset", "submit"]), import_prop_types50.default.string])
} : void 0;
var ButtonBase_default = ButtonBase;
init_define_process();
var capitalize_default = capitalize;
init_define_process();
function getFabUtilityClass(slot) {
  return generateUtilityClass("MuiFab", slot);
}
__name(getFabUtilityClass, "getFabUtilityClass");
var fabClasses = generateUtilityClasses("MuiFab", ["root", "primary", "secondary", "extended", "circular", "focusVisible", "disabled", "colorInherit", "sizeSmall", "sizeMedium", "sizeLarge", "info", "error", "warning", "success"]);
var fabClasses_default = fabClasses;
init_react_preact();
var _excluded41 = ["children", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"];
var useUtilityClasses18 = __name((ownerState) => {
  const {
    color: color22,
    variant,
    classes,
    size
  } = ownerState;
  const slots = {
    root: ["root", variant, `size${capitalize_default(size)}`, color22 === "inherit" ? "colorInherit" : color22]
  };
  return composeClasses(slots, getFabUtilityClass, classes);
}, "useUtilityClasses");
var FabRoot = styled_default2(ButtonBase_default, {
  name: "MuiFab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize_default(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize_default(ownerState.size)], styles2[ownerState.color]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends({}, theme.typography.button, {
    minHeight: 36,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
      duration: theme.transitions.duration.short
    }),
    borderRadius: "50%",
    padding: 0,
    minWidth: 0,
    width: 56,
    height: 56,
    zIndex: (theme.vars || theme).zIndex.fab,
    boxShadow: (theme.vars || theme).shadows[6],
    "&:active": {
      boxShadow: (theme.vars || theme).shadows[12]
    },
    color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    "&:hover": {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette.grey[300]
      },
      textDecoration: "none"
    },
    [`&.${fabClasses_default.focusVisible}`]: {
      boxShadow: (theme.vars || theme).shadows[6]
    },
    [`&.${fabClasses_default.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    }
  }, ownerState.size === "small" && {
    width: 40,
    height: 40
  }, ownerState.size === "medium" && {
    width: 48,
    height: 48
  }, ownerState.variant === "extended" && {
    borderRadius: 48 / 2,
    padding: "0 16px",
    width: "auto",
    minHeight: "auto",
    minWidth: 48,
    height: 48
  }, ownerState.variant === "extended" && ownerState.size === "small" && {
    width: "auto",
    padding: "0 8px",
    borderRadius: 34 / 2,
    minWidth: 34,
    height: 34
  }, ownerState.variant === "extended" && ownerState.size === "medium" && {
    width: "auto",
    padding: "0 16px",
    borderRadius: 40 / 2,
    minWidth: 40,
    height: 40
  }, ownerState.color === "inherit" && {
    color: "inherit"
  });
}, ({
  theme,
  ownerState
}) => _extends({}, ownerState.color !== "inherit" && ownerState.color !== "default" && (theme.vars || theme).palette[ownerState.color] != null && {
  color: (theme.vars || theme).palette[ownerState.color].contrastText,
  backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
    "@media (hover: none)": {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main
    }
  }
}));
var Fab = forwardRef(__name(function Fab2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiFab"
  });
  const {
    children: children2,
    className,
    color: color22 = "default",
    component = "button",
    disabled = false,
    disableFocusRipple = false,
    focusVisibleClassName,
    size = "large",
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded41);
  const ownerState = _extends({}, props, {
    color: color22,
    component,
    disabled,
    disableFocusRipple,
    size,
    variant
  });
  const classes = useUtilityClasses18(ownerState);
  return e3(FabRoot, _extends({
    className: clsx_m_default(classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx_m_default(classes.focusVisible, focusVisibleClassName),
    ownerState,
    ref
  }, other, {
    children: children2
  }));
}, "Fab"));
false ? Fab.propTypes = {
  children: import_prop_types51.default.node,
  classes: import_prop_types51.default.object,
  className: import_prop_types51.default.string,
  color: import_prop_types51.default.oneOfType([import_prop_types51.default.oneOf(["default", "error", "info", "inherit", "primary", "secondary", "success", "warning"]), import_prop_types51.default.string]),
  component: import_prop_types51.default.elementType,
  disabled: import_prop_types51.default.bool,
  disableFocusRipple: import_prop_types51.default.bool,
  disableRipple: import_prop_types51.default.bool,
  focusVisibleClassName: import_prop_types51.default.string,
  href: import_prop_types51.default.string,
  size: import_prop_types51.default.oneOfType([import_prop_types51.default.oneOf(["small", "medium", "large"]), import_prop_types51.default.string]),
  sx: import_prop_types51.default.oneOfType([import_prop_types51.default.arrayOf(import_prop_types51.default.oneOfType([import_prop_types51.default.func, import_prop_types51.default.object, import_prop_types51.default.bool])), import_prop_types51.default.func, import_prop_types51.default.object]),
  variant: import_prop_types51.default.oneOfType([import_prop_types51.default.oneOf(["circular", "extended"]), import_prop_types51.default.string])
} : void 0;
var Fab_default = Fab;
init_define_process();
init_react_preact();
var import_prop_types52 = __toESM(require_prop_types());
init_define_process();
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
__name(getButtonUtilityClass, "getButtonUtilityClass");
var buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
var buttonClasses_default = buttonClasses;
init_define_process();
init_react_preact();
var ButtonGroupContext = createContext({});
if (false) {
  ButtonGroupContext.displayName = "ButtonGroupContext";
}
var ButtonGroupContext_default = ButtonGroupContext;
init_react_preact();
init_react_preact();
var _excluded42 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
var _excluded211 = ["root"];
var useUtilityClasses19 = __name((ownerState) => {
  const {
    color: color22,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize_default(color22)}`, `size${capitalize_default(size)}`, `${variant}Size${capitalize_default(size)}`, color22 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize_default(size)}`],
    endIcon: ["endIcon", `iconSize${capitalize_default(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, "useUtilityClasses");
var commonIconStyles = __name((ownerState) => _extends({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), "commonIconStyles");
var ButtonRoot = styled_default2(ButtonBase_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize_default(ownerState.color)}`], styles2[`size${capitalize_default(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize_default(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends({}, theme.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": _extends({
      textDecoration: "none",
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha2(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha2(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha2(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      boxShadow: (theme.vars || theme).shadows[4],
      "@media (hover: none)": {
        boxShadow: (theme.vars || theme).shadows[2],
        backgroundColor: (theme.vars || theme).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }),
    "&:active": _extends({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[8]
    }),
    [`&.${buttonClasses_default.focusVisible}`]: _extends({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[6]
    }),
    [`&.${buttonClasses_default.disabled}`]: _extends({
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    }, ownerState.variant === "outlined" && ownerState.color === "secondary" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabled}`
    }, ownerState.variant === "contained" && {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha2(theme.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses_default.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses_default.disabled}`]: {
    boxShadow: "none"
  }
});
var ButtonStartIcon = styled_default2("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
var ButtonEndIcon = styled_default2("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
var Button = forwardRef(__name(function Button2(inProps, ref) {
  const contextProps = useContext(ButtonGroupContext_default);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps2({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children: children2,
    color: color22 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded42);
  const ownerState = _extends({}, props, {
    color: color22,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type,
    variant
  });
  const _useUtilityClasses = useUtilityClasses19(ownerState), {
    root: classesRoot
  } = _useUtilityClasses, classes = _objectWithoutPropertiesLoose(_useUtilityClasses, _excluded211);
  const startIcon = startIconProp && e3(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && e3(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  return e3(ButtonRoot, _extends({
    ownerState,
    className: clsx_m_default(contextProps.className, classesRoot, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx_m_default(classes.focusVisible, focusVisibleClassName),
    ref,
    type
  }, other, {
    classes,
    children: [startIcon, children2, endIcon]
  }));
}, "Button"));
false ? Button.propTypes = {
  children: import_prop_types52.default.node,
  classes: import_prop_types52.default.object,
  className: import_prop_types52.default.string,
  color: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), import_prop_types52.default.string]),
  component: import_prop_types52.default.elementType,
  disabled: import_prop_types52.default.bool,
  disableElevation: import_prop_types52.default.bool,
  disableFocusRipple: import_prop_types52.default.bool,
  disableRipple: import_prop_types52.default.bool,
  endIcon: import_prop_types52.default.node,
  focusVisibleClassName: import_prop_types52.default.string,
  fullWidth: import_prop_types52.default.bool,
  href: import_prop_types52.default.string,
  size: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["small", "medium", "large"]), import_prop_types52.default.string]),
  startIcon: import_prop_types52.default.node,
  sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
  type: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["button", "reset", "submit"]), import_prop_types52.default.string]),
  variant: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["contained", "outlined", "text"]), import_prop_types52.default.string])
} : void 0;
init_define_process();
var import_prop_types54 = __toESM(require_prop_types());
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
function useTheme4() {
  const theme = useTheme_default(defaultTheme_default);
  if (false) {
    useDebugValue(theme);
  }
  return theme;
}
__name(useTheme4, "useTheme");
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types53 = __toESM(require_prop_types());
init_define_process();
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
__name(getPaperUtilityClass, "getPaperUtilityClass");
var paperClasses = generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
init_react_preact();
var _excluded43 = ["className", "component", "elevation", "square", "variant"];
var getOverlayAlpha = __name((elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
}, "getOverlayAlpha");
var useUtilityClasses20 = __name((ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
}, "useUtilityClasses");
var PaperRoot = styled_default2("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === "elevation" && _extends({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha2("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha2("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
var Paper = forwardRef(__name(function Paper2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded43);
  const ownerState = _extends({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses20(ownerState);
  if (false) {
    const theme = useTheme4();
    if (theme.shadows[elevation] === void 0) {
      console.error([`MUI: The elevation provided <Paper elevation={${elevation}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${elevation}]\` is defined.`].join("\n"));
    }
  }
  return e3(PaperRoot, _extends({
    as: component,
    ownerState,
    className: clsx_m_default(classes.root, className),
    ref
  }, other));
}, "Paper"));
false ? Paper.propTypes = {
  children: import_prop_types53.default.node,
  classes: import_prop_types53.default.object,
  className: import_prop_types53.default.string,
  component: import_prop_types53.default.elementType,
  elevation: chainPropTypes(integerPropType_default, (props) => {
    const {
      elevation,
      variant
    } = props;
    if (elevation > 0 && variant === "outlined") {
      return new Error(`MUI: Combining \`elevation={${elevation}}\` with \`variant="${variant}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`);
    }
    return null;
  }),
  square: import_prop_types53.default.bool,
  sx: import_prop_types53.default.oneOfType([import_prop_types53.default.arrayOf(import_prop_types53.default.oneOfType([import_prop_types53.default.func, import_prop_types53.default.object, import_prop_types53.default.bool])), import_prop_types53.default.func, import_prop_types53.default.object]),
  variant: import_prop_types53.default.oneOfType([import_prop_types53.default.oneOf(["elevation", "outlined"]), import_prop_types53.default.string])
} : void 0;
var _excluded44 = ["colorSchemes", "cssVarPrefix"];
var _excluded212 = ["palette"];
var defaultDarkOverlays = [...Array(25)].map((_22, index) => {
  if (index === 0) {
    return void 0;
  }
  const overlay = getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function assignNode(obj, keys3) {
  keys3.forEach((k5) => {
    if (!obj[k5]) {
      obj[k5] = {};
    }
  });
}
__name(assignNode, "assignNode");
function setColor(obj, key, defaultValue) {
  obj[key] = obj[key] || defaultValue;
}
__name(setColor, "setColor");
var createGetCssVar2 = __name((cssVarPrefix = "mui") => createGetCssVar(cssVarPrefix), "createGetCssVar");
function extendTheme(options = {}, ...args) {
  var _colorSchemesInput$li, _colorSchemesInput$da, _colorSchemesInput$li2, _colorSchemesInput$li3, _colorSchemesInput$da2, _colorSchemesInput$da3;
  const {
    colorSchemes: colorSchemesInput = {},
    cssVarPrefix = "mui"
  } = options, input = _objectWithoutPropertiesLoose(options, _excluded44);
  const getCssVar = createGetCssVar2(cssVarPrefix);
  const _createThemeWithoutVa = createTheme_default2(_extends({}, input, colorSchemesInput.light && {
    palette: (_colorSchemesInput$li = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li.palette
  })), {
    palette: lightPalette
  } = _createThemeWithoutVa, muiTheme = _objectWithoutPropertiesLoose(_createThemeWithoutVa, _excluded212);
  const {
    palette: darkPalette
  } = createTheme_default2({
    palette: _extends({
      mode: "dark"
    }, (_colorSchemesInput$da = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da.palette)
  });
  let theme = _extends({}, muiTheme, {
    cssVarPrefix,
    getCssVar,
    colorSchemes: _extends({}, colorSchemesInput, {
      light: _extends({}, colorSchemesInput.light, {
        palette: lightPalette,
        opacity: _extends({
          inputPlaceholder: 0.42,
          inputUnderline: 0.42,
          switchTrackDisabled: 0.12,
          switchTrack: 0.38
        }, (_colorSchemesInput$li2 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li2.opacity),
        overlays: ((_colorSchemesInput$li3 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li3.overlays) || []
      }),
      dark: _extends({}, colorSchemesInput.dark, {
        palette: darkPalette,
        opacity: _extends({
          inputPlaceholder: 0.5,
          inputUnderline: 0.7,
          switchTrackDisabled: 0.2,
          switchTrack: 0.3
        }, (_colorSchemesInput$da2 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da2.opacity),
        overlays: ((_colorSchemesInput$da3 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da3.overlays) || defaultDarkOverlays
      })
    })
  });
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette2 = theme.colorSchemes[key].palette;
    if (key === "light") {
      setColor(palette2.common, "background", "#fff");
      setColor(palette2.common, "onBackground", "#000");
    } else {
      setColor(palette2.common, "background", "#000");
      setColor(palette2.common, "onBackground", "#fff");
    }
    assignNode(palette2, ["Alert", "AppBar", "Avatar", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (key === "light") {
      setColor(palette2.Alert, "errorColor", darken(palette2.error.light, 0.6));
      setColor(palette2.Alert, "infoColor", darken(palette2.info.light, 0.6));
      setColor(palette2.Alert, "successColor", darken(palette2.success.light, 0.6));
      setColor(palette2.Alert, "warningColor", darken(palette2.warning.light, 0.6));
      setColor(palette2.Alert, "errorFilledBg", getCssVar("palette-error-main"));
      setColor(palette2.Alert, "infoFilledBg", getCssVar("palette-info-main"));
      setColor(palette2.Alert, "successFilledBg", getCssVar("palette-success-main"));
      setColor(palette2.Alert, "warningFilledBg", getCssVar("palette-warning-main"));
      setColor(palette2.Alert, "errorFilledColor", lightPalette.getContrastText(palette2.error.main));
      setColor(palette2.Alert, "infoFilledColor", lightPalette.getContrastText(palette2.info.main));
      setColor(palette2.Alert, "successFilledColor", lightPalette.getContrastText(palette2.success.main));
      setColor(palette2.Alert, "warningFilledColor", lightPalette.getContrastText(palette2.warning.main));
      setColor(palette2.Alert, "errorStandardBg", lighten(palette2.error.light, 0.9));
      setColor(palette2.Alert, "infoStandardBg", lighten(palette2.info.light, 0.9));
      setColor(palette2.Alert, "successStandardBg", lighten(palette2.success.light, 0.9));
      setColor(palette2.Alert, "warningStandardBg", lighten(palette2.warning.light, 0.9));
      setColor(palette2.Alert, "errorIconColor", getCssVar("palette-error-light"));
      setColor(palette2.Alert, "infoIconColor", getCssVar("palette-info-light"));
      setColor(palette2.Alert, "successIconColor", getCssVar("palette-success-light"));
      setColor(palette2.Alert, "warningIconColor", getCssVar("palette-warning-light"));
      setColor(palette2.AppBar, "defaultBg", getCssVar("palette-grey-100"));
      setColor(palette2.Avatar, "defaultBg", getCssVar("palette-grey-400"));
      setColor(palette2.Chip, "defaultBorder", getCssVar("palette-grey-400"));
      setColor(palette2.Chip, "defaultAvatarColor", getCssVar("palette-grey-700"));
      setColor(palette2.Chip, "defaultIconColor", getCssVar("palette-grey-700"));
      setColor(palette2.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette2.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette2.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette2.LinearProgress, "primaryBg", lighten(palette2.primary.main, 0.62));
      setColor(palette2.LinearProgress, "secondaryBg", lighten(palette2.secondary.main, 0.62));
      setColor(palette2.LinearProgress, "errorBg", lighten(palette2.error.main, 0.62));
      setColor(palette2.LinearProgress, "infoBg", lighten(palette2.info.main, 0.62));
      setColor(palette2.LinearProgress, "successBg", lighten(palette2.success.main, 0.62));
      setColor(palette2.LinearProgress, "warningBg", lighten(palette2.warning.main, 0.62));
      setColor(palette2.Skeleton, "bg", `rgba(${getCssVar("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette2.Slider, "primaryTrack", lighten(palette2.primary.main, 0.62));
      setColor(palette2.Slider, "secondaryTrack", lighten(palette2.secondary.main, 0.62));
      setColor(palette2.Slider, "errorTrack", lighten(palette2.error.main, 0.62));
      setColor(palette2.Slider, "infoTrack", lighten(palette2.info.main, 0.62));
      setColor(palette2.Slider, "successTrack", lighten(palette2.success.main, 0.62));
      setColor(palette2.Slider, "warningTrack", lighten(palette2.warning.main, 0.62));
      const snackbarContentBackground = emphasize(palette2.background.default, 0.8);
      setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette2.SnackbarContent, "color", lightPalette.getContrastText(snackbarContentBackground));
      setColor(palette2.SpeedDialAction, "fabHoverBg", emphasize(palette2.background.paper, 0.15));
      setColor(palette2.StepConnector, "border", getCssVar("palette-grey-400"));
      setColor(palette2.StepContent, "border", getCssVar("palette-grey-400"));
      setColor(palette2.Switch, "defaultColor", getCssVar("palette-common-white"));
      setColor(palette2.Switch, "defaultDisabledColor", getCssVar("palette-grey-100"));
      setColor(palette2.Switch, "primaryDisabledColor", lighten(palette2.primary.main, 0.62));
      setColor(palette2.Switch, "secondaryDisabledColor", lighten(palette2.secondary.main, 0.62));
      setColor(palette2.Switch, "errorDisabledColor", lighten(palette2.error.main, 0.62));
      setColor(palette2.Switch, "infoDisabledColor", lighten(palette2.info.main, 0.62));
      setColor(palette2.Switch, "successDisabledColor", lighten(palette2.success.main, 0.62));
      setColor(palette2.Switch, "warningDisabledColor", lighten(palette2.warning.main, 0.62));
      setColor(palette2.TableCell, "border", lighten(alpha2(palette2.divider, 1), 0.88));
      setColor(palette2.Tooltip, "bg", alpha2(palette2.grey[700], 0.92));
    } else {
      setColor(palette2.Alert, "errorColor", lighten(palette2.error.light, 0.6));
      setColor(palette2.Alert, "infoColor", lighten(palette2.info.light, 0.6));
      setColor(palette2.Alert, "successColor", lighten(palette2.success.light, 0.6));
      setColor(palette2.Alert, "warningColor", lighten(palette2.warning.light, 0.6));
      setColor(palette2.Alert, "errorFilledBg", getCssVar("palette-error-dark"));
      setColor(palette2.Alert, "infoFilledBg", getCssVar("palette-info-dark"));
      setColor(palette2.Alert, "successFilledBg", getCssVar("palette-success-dark"));
      setColor(palette2.Alert, "warningFilledBg", getCssVar("palette-warning-dark"));
      setColor(palette2.Alert, "errorFilledColor", darkPalette.getContrastText(palette2.error.dark));
      setColor(palette2.Alert, "infoFilledColor", darkPalette.getContrastText(palette2.info.dark));
      setColor(palette2.Alert, "successFilledColor", darkPalette.getContrastText(palette2.success.dark));
      setColor(palette2.Alert, "warningFilledColor", darkPalette.getContrastText(palette2.warning.dark));
      setColor(palette2.Alert, "errorStandardBg", darken(palette2.error.light, 0.9));
      setColor(palette2.Alert, "infoStandardBg", darken(palette2.info.light, 0.9));
      setColor(palette2.Alert, "successStandardBg", darken(palette2.success.light, 0.9));
      setColor(palette2.Alert, "warningStandardBg", darken(palette2.warning.light, 0.9));
      setColor(palette2.Alert, "errorIconColor", getCssVar("palette-error-main"));
      setColor(palette2.Alert, "infoIconColor", getCssVar("palette-info-main"));
      setColor(palette2.Alert, "successIconColor", getCssVar("palette-success-main"));
      setColor(palette2.Alert, "warningIconColor", getCssVar("palette-warning-main"));
      setColor(palette2.AppBar, "defaultBg", getCssVar("palette-grey-900"));
      setColor(palette2.AppBar, "darkBg", getCssVar("palette-background-paper"));
      setColor(palette2.AppBar, "darkColor", getCssVar("palette-text-primary"));
      setColor(palette2.Avatar, "defaultBg", getCssVar("palette-grey-600"));
      setColor(palette2.Chip, "defaultBorder", getCssVar("palette-grey-700"));
      setColor(palette2.Chip, "defaultAvatarColor", getCssVar("palette-grey-300"));
      setColor(palette2.Chip, "defaultIconColor", getCssVar("palette-grey-300"));
      setColor(palette2.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette2.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette2.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette2.LinearProgress, "primaryBg", darken(palette2.primary.main, 0.5));
      setColor(palette2.LinearProgress, "secondaryBg", darken(palette2.secondary.main, 0.5));
      setColor(palette2.LinearProgress, "errorBg", darken(palette2.error.main, 0.5));
      setColor(palette2.LinearProgress, "infoBg", darken(palette2.info.main, 0.5));
      setColor(palette2.LinearProgress, "successBg", darken(palette2.success.main, 0.5));
      setColor(palette2.LinearProgress, "warningBg", darken(palette2.warning.main, 0.5));
      setColor(palette2.Skeleton, "bg", `rgba(${getCssVar("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette2.Slider, "primaryTrack", darken(palette2.primary.main, 0.5));
      setColor(palette2.Slider, "secondaryTrack", darken(palette2.secondary.main, 0.5));
      setColor(palette2.Slider, "errorTrack", darken(palette2.error.main, 0.5));
      setColor(palette2.Slider, "infoTrack", darken(palette2.info.main, 0.5));
      setColor(palette2.Slider, "successTrack", darken(palette2.success.main, 0.5));
      setColor(palette2.Slider, "warningTrack", darken(palette2.warning.main, 0.5));
      const snackbarContentBackground = emphasize(palette2.background.default, 0.98);
      setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette2.SnackbarContent, "color", darkPalette.getContrastText(snackbarContentBackground));
      setColor(palette2.SpeedDialAction, "fabHoverBg", emphasize(palette2.background.paper, 0.15));
      setColor(palette2.StepConnector, "border", getCssVar("palette-grey-600"));
      setColor(palette2.StepContent, "border", getCssVar("palette-grey-600"));
      setColor(palette2.Switch, "defaultColor", getCssVar("palette-grey-300"));
      setColor(palette2.Switch, "defaultDisabledColor", getCssVar("palette-grey-600"));
      setColor(palette2.Switch, "primaryDisabledColor", darken(palette2.primary.main, 0.55));
      setColor(palette2.Switch, "secondaryDisabledColor", darken(palette2.secondary.main, 0.55));
      setColor(palette2.Switch, "errorDisabledColor", darken(palette2.error.main, 0.55));
      setColor(palette2.Switch, "infoDisabledColor", darken(palette2.info.main, 0.55));
      setColor(palette2.Switch, "successDisabledColor", darken(palette2.success.main, 0.55));
      setColor(palette2.Switch, "warningDisabledColor", darken(palette2.warning.main, 0.55));
      setColor(palette2.TableCell, "border", darken(alpha2(palette2.divider, 1), 0.68));
      setColor(palette2.Tooltip, "bg", alpha2(palette2.grey[700], 0.92));
    }
    palette2.common.backgroundChannel = colorChannel(palette2.common.background);
    palette2.common.onBackgroundChannel = colorChannel(palette2.common.onBackground);
    palette2.dividerChannel = colorChannel(palette2.divider);
    Object.keys(palette2).forEach((color22) => {
      const colors = palette2[color22];
      if (colors.main) {
        palette2[color22].mainChannel = colorChannel(colors.main);
      }
      if (colors.light) {
        palette2[color22].lightChannel = colorChannel(colors.light);
      }
      if (colors.dark) {
        palette2[color22].darkChannel = colorChannel(colors.dark);
      }
      if (colors.contrastText) {
        palette2[color22].contrastTextChannel = colorChannel(colors.contrastText);
      }
      if (colors.primary) {
        palette2[color22].primaryChannel = colorChannel(colors.primary);
      }
      if (colors.secondary) {
        palette2[color22].secondaryChannel = colorChannel(colors.secondary);
      }
      if (colors.active) {
        palette2[color22].activeChannel = colorChannel(colors.active);
      }
      if (colors.selected) {
        palette2[color22].selectedChannel = colorChannel(colors.selected);
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  return theme;
}
__name(extendTheme, "extendTheme");
var shouldSkipGeneratingVar = __name((keys3) => {
  var _keys$;
  return !!keys3[0].match(/(typography|mixins|breakpoints|direction|transitions)/) || keys3[0] === "palette" && !!((_keys$ = keys3[1]) != null && _keys$.match(/(mode|contrastThreshold|tonalOffset)/));
}, "shouldSkipGeneratingVar");
var defaultTheme5 = extendTheme();
var {
  CssVarsProvider,
  useColorScheme,
  getInitColorSchemeScript: getInitColorSchemeScript2
} = createCssVarsProvider({
  theme: defaultTheme5,
  attribute: "data-mui-color-scheme",
  modeStorageKey: "mui-mode",
  colorSchemeStorageKey: "mui-color-scheme",
  defaultColorScheme: {
    light: "light",
    dark: "dark"
  },
  resolveTheme: (theme) => {
    const newTheme = _extends({}, theme, {
      typography: createTypography(theme.palette, theme.typography)
    });
    return newTheme;
  },
  shouldSkipGeneratingVar
});
var defaultTheme6 = createTheme_default2();
var Box2 = createBox2({
  defaultTheme: defaultTheme6,
  defaultClassName: "MuiBox-root",
  generateClassName: ClassNameGenerator_default.generate
});
false ? Box2.propTypes = {
  children: import_prop_types54.default.node,
  component: import_prop_types54.default.elementType,
  sx: import_prop_types54.default.oneOfType([import_prop_types54.default.arrayOf(import_prop_types54.default.oneOfType([import_prop_types54.default.func, import_prop_types54.default.object, import_prop_types54.default.bool])), import_prop_types54.default.func, import_prop_types54.default.object])
} : void 0;
init_define_process();
init_react_preact();
var import_prop_types55 = __toESM(require_prop_types());
init_define_process();
var shouldSpreadAdditionalProps = __name((Slot) => {
  return !Slot || !isHostComponent_default(Slot);
}, "shouldSpreadAdditionalProps");
var shouldSpreadAdditionalProps_default = shouldSpreadAdditionalProps;
init_react_preact();
var _excluded45 = ["component", "components", "componentsProps", "color", "size"];
var sliderClasses = _extends({}, sliderUnstyledClasses_default, generateUtilityClasses("MuiSlider", ["colorPrimary", "colorSecondary", "thumbColorPrimary", "thumbColorSecondary", "sizeSmall", "thumbSizeSmall"]));
var SliderRoot = styled_default2("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize_default(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize_default(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(({
  theme,
  ownerState
}) => _extends({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  color: (theme.vars || theme).palette[ownerState.color].main,
  WebkitTapHighlightColor: "transparent"
}, ownerState.orientation === "horizontal" && _extends({
  height: 4,
  width: "100%",
  padding: "13px 0",
  "@media (pointer: coarse)": {
    padding: "20px 0"
  }
}, ownerState.size === "small" && {
  height: 2
}, ownerState.marked && {
  marginBottom: 20
}), ownerState.orientation === "vertical" && _extends({
  height: "100%",
  width: 4,
  padding: "0 13px",
  "@media (pointer: coarse)": {
    padding: "0 20px"
  }
}, ownerState.size === "small" && {
  width: 2
}, ownerState.marked && {
  marginRight: 44
}), {
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme.vars || theme).palette.grey[400]
  },
  [`&.${sliderClasses.dragging}`]: {
    [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
      transition: "none"
    }
  }
}));
false ? SliderRoot.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderRail = styled_default2("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (props, styles2) => styles2.rail
})(({
  ownerState
}) => _extends({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38
}, ownerState.orientation === "horizontal" && {
  width: "100%",
  height: "inherit",
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.orientation === "vertical" && {
  height: "100%",
  width: "inherit",
  left: "50%",
  transform: "translateX(-50%)"
}, ownerState.track === "inverted" && {
  opacity: 1
}));
false ? SliderRail.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderTrack = styled_default2("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme,
  ownerState
}) => {
  const color22 = theme.palette.mode === "light" ? lighten(theme.palette[ownerState.color].main, 0.62) : darken(theme.palette[ownerState.color].main, 0.5);
  return _extends({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme.transitions.duration.shortest
    })
  }, ownerState.size === "small" && {
    border: "none"
  }, ownerState.orientation === "horizontal" && {
    height: "inherit",
    top: "50%",
    transform: "translateY(-50%)"
  }, ownerState.orientation === "vertical" && {
    width: "inherit",
    left: "50%",
    transform: "translateX(-50%)"
  }, ownerState.track === false && {
    display: "none"
  }, ownerState.track === "inverted" && {
    backgroundColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color22,
    borderColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color22
  });
});
false ? SliderTrack.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderThumb = styled_default2("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize_default(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize_default(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme.transitions.duration.shortest
  })
}, ownerState.size === "small" && {
  width: 12,
  height: 12
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-50%, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 50%)"
}, {
  "&:before": _extends({
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.size === "small" && {
    boxShadow: "none"
  }),
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&:hover, &.${sliderClasses.focusVisible}`]: {
    boxShadow: `0px 0px 0px 8px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha2(theme.palette[ownerState.color].main, 0.16)}`,
    "@media (hover: none)": {
      boxShadow: "none"
    }
  },
  [`&.${sliderClasses.active}`]: {
    boxShadow: `0px 0px 0px 14px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha2(theme.palette[ownerState.color].main, 0.16)}`
  },
  [`&.${sliderClasses.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  }
}));
false ? SliderThumb.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderValueLabel = styled_default2(SliderValueLabelUnstyled, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (props, styles2) => styles2.valueLabel
})(({
  theme,
  ownerState
}) => _extends({
  [`&.${sliderClasses.valueLabelOpen}`]: {
    transform: "translateY(-100%) scale(1)"
  },
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme.typography.body2, {
  fontWeight: 500,
  transition: theme.transitions.create(["transform"], {
    duration: theme.transitions.duration.shortest
  }),
  transform: "translateY(-100%) scale(0)",
  position: "absolute",
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem"
}, ownerState.orientation === "horizontal" && {
  top: "-10px",
  transformOrigin: "bottom center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, 50%) rotate(45deg)",
    backgroundColor: "inherit",
    bottom: 0,
    left: "50%"
  }
}, ownerState.orientation === "vertical" && {
  right: "30px",
  top: "24px",
  transformOrigin: "right center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, 50%) rotate(45deg)",
    backgroundColor: "inherit",
    right: "-20%",
    top: "25%"
  }
}, ownerState.size === "small" && {
  fontSize: theme.typography.pxToRem(12),
  padding: "0.25rem 0.5rem"
}));
false ? SliderValueLabel.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderMark = styled_default2("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => styles2.mark
})(({
  theme,
  ownerState,
  markActive
}) => _extends({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor"
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-1px, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 1px)"
}, markActive && {
  backgroundColor: (theme.vars || theme).palette.background.paper,
  opacity: 0.8
}));
false ? SliderMark.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var SliderMarkLabel = styled_default2("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive",
  overridesResolver: (props, styles2) => styles2.markLabel
})(({
  theme,
  ownerState,
  markLabelActive
}) => _extends({}, theme.typography.body2, {
  color: (theme.vars || theme).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap"
}, ownerState.orientation === "horizontal" && {
  top: 30,
  transform: "translateX(-50%)",
  "@media (pointer: coarse)": {
    top: 40
  }
}, ownerState.orientation === "vertical" && {
  left: 36,
  transform: "translateY(50%)",
  "@media (pointer: coarse)": {
    left: 44
  }
}, markLabelActive && {
  color: (theme.vars || theme).palette.text.primary
}));
false ? SliderMarkLabel.propTypes = {
  children: import_prop_types55.default.node
} : void 0;
var extendUtilityClasses = __name((ownerState) => {
  const {
    color: color22,
    size,
    classes = {}
  } = ownerState;
  return _extends({}, classes, {
    root: clsx_m_default(classes.root, getSliderUtilityClass(`color${capitalize_default(color22)}`), classes[`color${capitalize_default(color22)}`], size && [getSliderUtilityClass(`size${capitalize_default(size)}`), classes[`size${capitalize_default(size)}`]]),
    thumb: clsx_m_default(classes.thumb, getSliderUtilityClass(`thumbColor${capitalize_default(color22)}`), classes[`thumbColor${capitalize_default(color22)}`], size && [getSliderUtilityClass(`thumbSize${capitalize_default(size)}`), classes[`thumbSize${capitalize_default(size)}`]])
  });
}, "extendUtilityClasses");
var Slider = forwardRef(__name(function Slider2(inputProps, ref) {
  var _componentsProps$root, _componentsProps$thum, _componentsProps$trac, _componentsProps$valu;
  const props = useThemeProps2({
    props: inputProps,
    name: "MuiSlider"
  });
  const theme = useTheme4();
  const isRtl = theme.direction === "rtl";
  const {
    component = "span",
    components = {},
    componentsProps = {},
    color: color22 = "primary",
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded45);
  const ownerState = _extends({}, props, {
    color: color22,
    size
  });
  const classes = extendUtilityClasses(ownerState);
  return e3(SliderUnstyled_default, _extends({}, other, {
    isRtl,
    components: _extends({
      Root: SliderRoot,
      Rail: SliderRail,
      Track: SliderTrack,
      Thumb: SliderThumb,
      ValueLabel: SliderValueLabel,
      Mark: SliderMark,
      MarkLabel: SliderMarkLabel
    }, components),
    componentsProps: _extends({}, componentsProps, {
      root: _extends({}, componentsProps.root, shouldSpreadAdditionalProps_default(components.Root) && {
        as: component,
        ownerState: _extends({}, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.ownerState, {
          color: color22,
          size
        })
      }),
      thumb: _extends({}, componentsProps.thumb, shouldSpreadAdditionalProps_default(components.Thumb) && {
        ownerState: _extends({}, (_componentsProps$thum = componentsProps.thumb) == null ? void 0 : _componentsProps$thum.ownerState, {
          color: color22,
          size
        })
      }),
      track: _extends({}, componentsProps.track, shouldSpreadAdditionalProps_default(components.Track) && {
        ownerState: _extends({}, (_componentsProps$trac = componentsProps.track) == null ? void 0 : _componentsProps$trac.ownerState, {
          color: color22,
          size
        })
      }),
      valueLabel: _extends({}, componentsProps.valueLabel, shouldSpreadAdditionalProps_default(components.ValueLabel) && {
        ownerState: _extends({}, (_componentsProps$valu = componentsProps.valueLabel) == null ? void 0 : _componentsProps$valu.ownerState, {
          color: color22,
          size
        })
      })
    }),
    classes,
    ref
  }));
}, "Slider"));
false ? Slider.propTypes = {
  "aria-label": chainPropTypes(import_prop_types55.default.string, (props) => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props["aria-label"] != null) {
      return new Error("MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.");
    }
    return null;
  }),
  "aria-labelledby": import_prop_types55.default.string,
  "aria-valuetext": chainPropTypes(import_prop_types55.default.string, (props) => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props["aria-valuetext"] != null) {
      return new Error("MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.");
    }
    return null;
  }),
  children: import_prop_types55.default.node,
  classes: import_prop_types55.default.object,
  color: import_prop_types55.default.oneOfType([import_prop_types55.default.oneOf(["primary", "secondary"]), import_prop_types55.default.string]),
  components: import_prop_types55.default.shape({
    Input: import_prop_types55.default.elementType,
    Mark: import_prop_types55.default.elementType,
    MarkLabel: import_prop_types55.default.elementType,
    Rail: import_prop_types55.default.elementType,
    Root: import_prop_types55.default.elementType,
    Thumb: import_prop_types55.default.elementType,
    Track: import_prop_types55.default.elementType,
    ValueLabel: import_prop_types55.default.elementType
  }),
  componentsProps: import_prop_types55.default.shape({
    input: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    mark: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    markLabel: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    rail: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    root: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    thumb: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    track: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object]),
    valueLabel: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.shape({
      children: import_prop_types55.default.element,
      className: import_prop_types55.default.string,
      components: import_prop_types55.default.shape({
        Root: import_prop_types55.default.elementType
      }),
      open: import_prop_types55.default.bool,
      style: import_prop_types55.default.object,
      value: import_prop_types55.default.number,
      valueLabelDisplay: import_prop_types55.default.oneOf(["auto", "off", "on"])
    })])
  }),
  defaultValue: import_prop_types55.default.oneOfType([import_prop_types55.default.arrayOf(import_prop_types55.default.number), import_prop_types55.default.number]),
  disabled: import_prop_types55.default.bool,
  disableSwap: import_prop_types55.default.bool,
  getAriaLabel: import_prop_types55.default.func,
  getAriaValueText: import_prop_types55.default.func,
  isRtl: import_prop_types55.default.bool,
  marks: import_prop_types55.default.oneOfType([import_prop_types55.default.arrayOf(import_prop_types55.default.shape({
    label: import_prop_types55.default.node,
    value: import_prop_types55.default.number.isRequired
  })), import_prop_types55.default.bool]),
  max: import_prop_types55.default.number,
  min: import_prop_types55.default.number,
  name: import_prop_types55.default.string,
  onChange: import_prop_types55.default.func,
  onChangeCommitted: import_prop_types55.default.func,
  orientation: import_prop_types55.default.oneOf(["horizontal", "vertical"]),
  scale: import_prop_types55.default.func,
  size: import_prop_types55.default.oneOfType([import_prop_types55.default.oneOf(["small", "medium"]), import_prop_types55.default.string]),
  step: import_prop_types55.default.number,
  sx: import_prop_types55.default.oneOfType([import_prop_types55.default.arrayOf(import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.object, import_prop_types55.default.bool])), import_prop_types55.default.func, import_prop_types55.default.object]),
  tabIndex: import_prop_types55.default.number,
  track: import_prop_types55.default.oneOf(["inverted", "normal", false]),
  value: import_prop_types55.default.oneOfType([import_prop_types55.default.arrayOf(import_prop_types55.default.number), import_prop_types55.default.number]),
  valueLabelDisplay: import_prop_types55.default.oneOf(["auto", "off", "on"]),
  valueLabelFormat: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.string])
} : void 0;
init_define_process();
init_react_preact();
init_define_process();
init_define_process();
init_react_preact();
var import_prop_types56 = __toESM(require_prop_types());
init_define_process();
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
__name(getSvgIconUtilityClass, "getSvgIconUtilityClass");
var svgIconClasses = generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
init_react_preact();
init_react_preact();
var _excluded46 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
var useUtilityClasses21 = __name((ownerState) => {
  const {
    color: color22,
    fontSize: fontSize2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color22 !== "inherit" && `color${capitalize_default(color22)}`, `fontSize${capitalize_default(fontSize2)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
}, "useUtilityClasses");
var SvgIconRoot = styled_default2("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize_default(ownerState.color)}`], styles2[`fontSize${capitalize_default(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    fill: "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null ? void 0 : (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme.typography) == null ? void 0 : (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme.typography) == null ? void 0 : (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875"
    }[ownerState.fontSize],
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
var SvgIcon = forwardRef(__name(function SvgIcon2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children: children2,
    className,
    color: color22 = "inherit",
    component = "svg",
    fontSize: fontSize2 = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded46);
  const ownerState = _extends({}, props, {
    color: color22,
    component,
    fontSize: fontSize2,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses21(ownerState);
  return e3(SvgIconRoot, _extends({
    as: component,
    className: clsx_m_default(classes.root, className),
    ownerState,
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, {
    children: [children2, titleAccess ? e3("title", {
      children: titleAccess
    }) : null]
  }));
}, "SvgIcon"));
false ? SvgIcon.propTypes = {
  children: import_prop_types56.default.node,
  classes: import_prop_types56.default.object,
  className: import_prop_types56.default.string,
  color: import_prop_types56.default.oneOfType([import_prop_types56.default.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types56.default.string]),
  component: import_prop_types56.default.elementType,
  fontSize: import_prop_types56.default.oneOfType([import_prop_types56.default.oneOf(["inherit", "large", "medium", "small"]), import_prop_types56.default.string]),
  htmlColor: import_prop_types56.default.string,
  inheritViewBox: import_prop_types56.default.bool,
  shapeRendering: import_prop_types56.default.string,
  sx: import_prop_types56.default.oneOfType([import_prop_types56.default.arrayOf(import_prop_types56.default.oneOfType([import_prop_types56.default.func, import_prop_types56.default.object, import_prop_types56.default.bool])), import_prop_types56.default.func, import_prop_types56.default.object]),
  titleAccess: import_prop_types56.default.string,
  viewBox: import_prop_types56.default.string
} : void 0;
SvgIcon.muiName = "SvgIcon";
var SvgIcon_default = SvgIcon;
init_react_preact();
function createSvgIcon(path, displayName) {
  const Component2 = __name((props, ref) => e3(SvgIcon_default, _extends({
    "data-testid": `${displayName}Icon`,
    ref
  }, props, {
    children: path
  })), "Component");
  if (false) {
    Component2.displayName = `${displayName}Icon`;
  }
  Component2.muiName = SvgIcon_default.muiName;
  return memo(forwardRef(Component2));
}
__name(createSvgIcon, "createSvgIcon");
init_define_process();
init_react_preact();
var import_prop_types57 = __toESM(require_prop_types());
init_define_process();
function getToggleButtonUtilityClass(slot) {
  return generateUtilityClass("MuiToggleButton", slot);
}
__name(getToggleButtonUtilityClass, "getToggleButtonUtilityClass");
var toggleButtonClasses = generateUtilityClasses("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge"]);
var toggleButtonClasses_default = toggleButtonClasses;
init_react_preact();
var _excluded47 = ["children", "className", "color", "disabled", "disableFocusRipple", "fullWidth", "onChange", "onClick", "selected", "size", "value"];
var useUtilityClasses22 = __name((ownerState) => {
  const {
    classes,
    fullWidth,
    selected,
    disabled,
    size,
    color: color22
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", disabled && "disabled", fullWidth && "fullWidth", `size${capitalize_default(size)}`, color22]
  };
  return composeClasses(slots, getToggleButtonUtilityClass, classes);
}, "useUtilityClasses");
var ToggleButtonRoot = styled_default2(ButtonBase_default, {
  name: "MuiToggleButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`size${capitalize_default(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  let selectedColor = ownerState.color === "standard" ? theme.palette.text.primary : theme.palette[ownerState.color].main;
  let selectedColorChannel;
  if (theme.vars) {
    selectedColor = ownerState.color === "standard" ? theme.vars.palette.text.primary : theme.vars.palette[ownerState.color].main;
    selectedColorChannel = ownerState.color === "standard" ? theme.vars.palette.text.primaryChannel : theme.vars.palette[ownerState.color].mainChannel;
  }
  return _extends({}, theme.typography.button, {
    borderRadius: (theme.vars || theme).shape.borderRadius,
    padding: 11,
    border: `1px solid ${(theme.vars || theme).palette.divider}`,
    color: (theme.vars || theme).palette.action.active
  }, ownerState.fullWidth && {
    width: "100%"
  }, {
    [`&.${toggleButtonClasses_default.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled,
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    },
    "&:hover": {
      textDecoration: "none",
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha2(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${toggleButtonClasses_default.selected}`]: {
      color: selectedColor,
      backgroundColor: theme.vars ? `rgba(${selectedColorChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha2(selectedColor, theme.palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${selectedColorChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha2(selectedColor, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${selectedColorChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha2(selectedColor, theme.palette.action.selectedOpacity)
        }
      }
    }
  }, ownerState.size === "small" && {
    padding: 7,
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && {
    padding: 15,
    fontSize: theme.typography.pxToRem(15)
  });
});
var ToggleButton = forwardRef(__name(function ToggleButton2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiToggleButton"
  });
  const {
    children: children2,
    className,
    color: color22 = "standard",
    disabled = false,
    disableFocusRipple = false,
    fullWidth = false,
    onChange,
    onClick,
    selected,
    size = "medium",
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded47);
  const ownerState = _extends({}, props, {
    color: color22,
    disabled,
    disableFocusRipple,
    fullWidth,
    size
  });
  const classes = useUtilityClasses22(ownerState);
  const handleChange = __name((event) => {
    if (onClick) {
      onClick(event, value);
      if (event.defaultPrevented) {
        return;
      }
    }
    if (onChange) {
      onChange(event, value);
    }
  }, "handleChange");
  return e3(ToggleButtonRoot, _extends({
    className: clsx_m_default(classes.root, className),
    disabled,
    focusRipple: !disableFocusRipple,
    ref,
    onClick: handleChange,
    onChange,
    value,
    ownerState,
    "aria-pressed": selected
  }, other, {
    children: children2
  }));
}, "ToggleButton"));
false ? ToggleButton.propTypes = {
  children: import_prop_types57.default.node,
  classes: import_prop_types57.default.object,
  className: import_prop_types57.default.string,
  color: import_prop_types57.default.oneOfType([import_prop_types57.default.oneOf(["standard", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types57.default.string]),
  disabled: import_prop_types57.default.bool,
  disableFocusRipple: import_prop_types57.default.bool,
  disableRipple: import_prop_types57.default.bool,
  fullWidth: import_prop_types57.default.bool,
  onChange: import_prop_types57.default.func,
  onClick: import_prop_types57.default.func,
  selected: import_prop_types57.default.bool,
  size: import_prop_types57.default.oneOfType([import_prop_types57.default.oneOf(["small", "medium", "large"]), import_prop_types57.default.string]),
  sx: import_prop_types57.default.oneOfType([import_prop_types57.default.arrayOf(import_prop_types57.default.oneOfType([import_prop_types57.default.func, import_prop_types57.default.object, import_prop_types57.default.bool])), import_prop_types57.default.func, import_prop_types57.default.object]),
  value: import_prop_types57.default.any.isRequired
} : void 0;
var ToggleButton_default = ToggleButton;
init_define_process();
init_react_preact();
var import_react_is3 = __toESM(require_react_is2());
var import_prop_types58 = __toESM(require_prop_types());
init_define_process();
function isValueSelected(value, candidate) {
  if (candidate === void 0 || value === void 0) {
    return false;
  }
  if (Array.isArray(candidate)) {
    return candidate.indexOf(value) >= 0;
  }
  return value === candidate;
}
__name(isValueSelected, "isValueSelected");
init_define_process();
function getToggleButtonGroupUtilityClass(slot) {
  return generateUtilityClass("MuiToggleButtonGroup", slot);
}
__name(getToggleButtonGroupUtilityClass, "getToggleButtonGroupUtilityClass");
var toggleButtonGroupClasses = generateUtilityClasses("MuiToggleButtonGroup", ["root", "selected", "vertical", "disabled", "grouped", "groupedHorizontal", "groupedVertical"]);
var toggleButtonGroupClasses_default = toggleButtonGroupClasses;
init_react_preact();
var _excluded48 = ["children", "className", "color", "disabled", "exclusive", "fullWidth", "onChange", "orientation", "size", "value"];
var useUtilityClasses23 = __name((ownerState) => {
  const {
    classes,
    orientation,
    fullWidth,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation === "vertical" && "vertical", fullWidth && "fullWidth"],
    grouped: ["grouped", `grouped${capitalize_default(orientation)}`, disabled && "disabled"]
  };
  return composeClasses(slots, getToggleButtonGroupUtilityClass, classes);
}, "useUtilityClasses");
var ToggleButtonGroupRoot = styled_default2("div", {
  name: "MuiToggleButtonGroup",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${toggleButtonGroupClasses_default.grouped}`]: styles2.grouped
    }, {
      [`& .${toggleButtonGroupClasses_default.grouped}`]: styles2[`grouped${capitalize_default(ownerState.orientation)}`]
    }, styles2.root, ownerState.orientation === "vertical" && styles2.vertical, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  ownerState,
  theme
}) => _extends({
  display: "inline-flex",
  borderRadius: (theme.vars || theme).shape.borderRadius
}, ownerState.orientation === "vertical" && {
  flexDirection: "column"
}, ownerState.fullWidth && {
  width: "100%"
}, {
  [`& .${toggleButtonGroupClasses_default.grouped}`]: _extends({}, ownerState.orientation === "horizontal" ? {
    "&:not(:first-of-type)": {
      marginLeft: -1,
      borderLeft: "1px solid transparent",
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    },
    "&:not(:last-of-type)": {
      borderTopRightRadius: 0,
      borderBottomRightRadius: 0
    },
    [`&.${toggleButtonGroupClasses_default.selected} + .${toggleButtonGroupClasses_default.grouped}.${toggleButtonGroupClasses_default.selected}`]: {
      borderLeft: 0,
      marginLeft: 0
    }
  } : {
    "&:not(:first-of-type)": {
      marginTop: -1,
      borderTop: "1px solid transparent",
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    "&:not(:last-of-type)": {
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    [`&.${toggleButtonGroupClasses_default.selected} + .${toggleButtonGroupClasses_default.grouped}.${toggleButtonGroupClasses_default.selected}`]: {
      borderTop: 0,
      marginTop: 0
    }
  })
}));
var ToggleButtonGroup = forwardRef(__name(function ToggleButtonGroup2(inProps, ref) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiToggleButtonGroup"
  });
  const {
    children: children2,
    className,
    color: color22 = "standard",
    disabled = false,
    exclusive = false,
    fullWidth = false,
    onChange,
    orientation = "horizontal",
    size = "medium",
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded48);
  const ownerState = _extends({}, props, {
    disabled,
    fullWidth,
    orientation,
    size
  });
  const classes = useUtilityClasses23(ownerState);
  const handleChange = __name((event, buttonValue) => {
    if (!onChange) {
      return;
    }
    const index = value && value.indexOf(buttonValue);
    let newValue;
    if (value && index >= 0) {
      newValue = value.slice();
      newValue.splice(index, 1);
    } else {
      newValue = value ? value.concat(buttonValue) : [buttonValue];
    }
    onChange(event, newValue);
  }, "handleChange");
  const handleExclusiveChange = __name((event, buttonValue) => {
    if (!onChange) {
      return;
    }
    onChange(event, value === buttonValue ? null : buttonValue);
  }, "handleExclusiveChange");
  return e3(ToggleButtonGroupRoot, _extends({
    role: "group",
    className: clsx_m_default(classes.root, className),
    ref,
    ownerState
  }, other, {
    children: Children.map(children2, (child) => {
      if (!isValidElement(child)) {
        return null;
      }
      if (false) {
        if ((0, import_react_is3.isFragment)(child)) {
          console.error(["MUI: The ToggleButtonGroup component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
        }
      }
      return cloneElement(child, {
        className: clsx_m_default(classes.grouped, child.props.className),
        onChange: exclusive ? handleExclusiveChange : handleChange,
        selected: child.props.selected === void 0 ? isValueSelected(child.props.value, value) : child.props.selected,
        size: child.props.size || size,
        fullWidth,
        color: child.props.color || color22,
        disabled: child.props.disabled || disabled
      });
    })
  }));
}, "ToggleButtonGroup"));
false ? ToggleButtonGroup.propTypes = {
  children: import_prop_types58.default.node,
  classes: import_prop_types58.default.object,
  className: import_prop_types58.default.string,
  color: import_prop_types58.default.oneOfType([import_prop_types58.default.oneOf(["standard", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types58.default.string]),
  disabled: import_prop_types58.default.bool,
  exclusive: import_prop_types58.default.bool,
  fullWidth: import_prop_types58.default.bool,
  onChange: import_prop_types58.default.func,
  orientation: import_prop_types58.default.oneOf(["horizontal", "vertical"]),
  size: import_prop_types58.default.oneOfType([import_prop_types58.default.oneOf(["small", "medium", "large"]), import_prop_types58.default.string]),
  sx: import_prop_types58.default.oneOfType([import_prop_types58.default.arrayOf(import_prop_types58.default.oneOfType([import_prop_types58.default.func, import_prop_types58.default.object, import_prop_types58.default.bool])), import_prop_types58.default.func, import_prop_types58.default.object]),
  value: import_prop_types58.default.any
} : void 0;
var ToggleButtonGroup_default = ToggleButtonGroup;
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var FullscreenIcon = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M17 4h5v5h-2V6h-3V4zM4 9V6h3V4H2v5h2zm16 6v3h-3v2h5v-5h-2zM7 18H4v-3H2v5h5v-2zM18 8H6v8h12V8z"
  }),
  "Fullscreen"
);
var Phone = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M16 1H8C6.34 1 5 2.34 5 4v16c0 1.66 1.34 3 3 3h8c1.66 0 3-1.34 3-3V4c0-1.66-1.34-3-3-3zm-2 20h-4v-1h4v1zm3.25-3H6.75V4h10.5v14z"
  }, "12"),
  "PhoneAndroid"
);
var Share = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"
  }, "12"),
  "Share"
);
var Tablet = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M18 0H6C4.34 0 3 1.34 3 3v18c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V3c0-1.66-1.34-3-3-3zm-4 22h-4v-1h4v1zm5.25-3H4.75V3h14.5v16z"
  }, "12"),
  "TabletAndroid"
);
var Tv = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"
  }, "12"),
  "Tv"
);
var QrCode = createSvgIcon(
  (0, import_jsx_runtime.jsx)("path", {
    d: "M3 11h8V3H3v8zm2-6h4v4H5V5zM3 21h8v-8H3v8zm2-6h4v4H5v-4zm8-12v8h8V3h-8zm6 6h-4V5h4v4zm0 10h2v2h-2zm-6-6h2v2h-2zm2 2h2v2h-2zm-2 2h2v2h-2zm2 2h2v2h-2zm2-2h2v2h-2zm0-4h2v2h-2zm2 2h2v2h-2z"
  }, "12"),
  "QrCode"
);
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var QR = __name(({ url }) => (0, import_jsx_runtime.jsx)(QRious2, {
  value: url
}), "QR");
var QRButton = __name(({ url }) => {
  const [showQR, setQR] = useState(false);
  return (0, import_jsx_runtime.jsx)(LazyMotion, {
    features: domAnimation,
    children: (0, import_jsx_runtime.jsx)(m4.div, {
      animate: {
        width: showQR ? 200 : 56,
        height: showQR ? 220 : 48
      },
      onClick: () => {
        setQR(!showQR);
      },
      css: import_react18.css`
          margin-top: 12px;
          margin-bottom: 12px;
              `,
      children: showQR ? (0, import_jsx_runtime.jsx)(QR, {
        url: url || "/live/coder/public"
      }, url || "http://spike.land") : (0, import_jsx_runtime.jsx)(Fab_default, {
        children: (0, import_jsx_runtime.jsx)(QrCode, {})
      })
    })
  });
}, "QRButton");
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var ToggleButtonGroup3 = ToggleButtonGroup_default;
var ToggleButton3 = ToggleButton_default;
var breakPoints = [680, 768, 1920];
var breakPointHeights = [1137, 1024, 1080];
var sizes = [10, 25, 50, 75, 100, 150];
var bg = `rgba(${Math.random() * 128 + 64}, ${Math.random() * 128 + 64}, ${Math.random() * 128 + 64}, ${!navigator.userAgent.includes("Firefox") ? 0.3 : 0.7})`;
var DraggableWindow = __name(({
  children: children2,
  room,
  hashCode: hashCode32
}) => {
  const [scaleRange, changeScaleRange] = useState(100);
  const startPositions = { bottom: 0, right: 0 };
  const [{ bottom: bottom3, right: right3 }, setPositions] = useState(startPositions);
  const [width2, setWidth] = useState(window.innerWidth * devicePixelRatio);
  const [height2, setHeight] = useState(window.innerHeight * devicePixelRatio);
  const scale2 = scaleRange / 100;
  useEffect(() => {
    const reveal = __name(async () => {
      setPositions({
        bottom: window.innerHeight * 0.2,
        right: window.innerWidth * 0.2
      });
      if (window.innerWidth / devicePixelRatio < 600) {
        changeScaleRange(50);
        setWidth(breakPoints[0]);
        setHeight(breakPointHeights[0]);
      }
      if (window.innerWidth / devicePixelRatio < 1200) {
        changeScaleRange(75);
        setWidth(breakPoints[0]);
        setHeight(breakPointHeights[0]);
      } else if (window.innerWidth / devicePixelRatio < 1800) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(50);
      } else if (window.innerWidth / devicePixelRatio < 2500) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(75);
      } else if (window.innerWidth / devicePixelRatio > 2500) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(100);
      }
      setPositions({
        bottom: 20,
        right: 20
      });
    }, "reveal");
    reveal();
  }, []);
  return (0, import_jsx_runtime.jsx)(LazyMotion, {
    features: domMax,
    children: (0, import_jsx_runtime.jsx)(m4.div, {
      transition: { delay: 0, duration: 0.4 },
      initial: {
        top: 0,
        padding: 0,
        right: 0,
        borderRadius: 0
      },
      animate: {
        top: bottom3,
        padding: 8,
        right: right3,
        borderRadius: 16
      },
      css: import_react20.css`
            background-color:${bg};
            backdrop-filter: blur(15px);
            z-index: 10;

            white-space: normal;
            position: fixed;
          `,
      drag: true,
      dragMomentum: false,
      dragConstraints: {
        left: 0,
        right: width2 - 20 - width2 / 6,
        bottom: innerHeight
      },
      dragElastic: 0.5,
      children: (0, import_jsx_runtime.jsxs)("div", {
        css: import_react20.css` 
              display: flex;
              
                `,
        children: [
          (0, import_jsx_runtime.jsxs)("div", {
            css: import_react20.css`
            display: flex;
            flex-direction: column;
            align-items: center;
          `,
            children: [
              (0, import_jsx_runtime.jsx)(m4.div, {
                transition: { delay: 0, duration: 0.4 },
                initial: { height: 0, width: 0 },
                animate: { height: "auto", width: "auto" },
                children: (0, import_jsx_runtime.jsx)(ToggleButtonGroup3, {
                  value: scaleRange,
                  size: "small",
                  exclusive: true,
                  onChange: (_e, newScale) => {
                    newScale && changeScaleRange(newScale);
                  },
                  children: sizes.map((size) => (0, import_jsx_runtime.jsx)(ToggleButton3, {
                    value: size,
                    children: (0, import_jsx_runtime.jsxs)("span", {
                      css: import_react20.css`
                       color: ${size === scaleRange ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                       `,
                      children: [
                        size,
                        "%"
                      ]
                    })
                  }, size))
                })
              }),
              (0, import_jsx_runtime.jsx)(m4.div, {
                transition: { delay: 0, duration: 0.4 },
                initial: {
                  width: window.innerWidth,
                  height: window.innerHeight,
                  borderRadius: 0
                },
                animate: {
                  width: width2 * scale2 / devicePixelRatio,
                  height: height2 * scale2 / devicePixelRatio,
                  borderRadius: 8
                },
                css: import_react20.css`

                display: block;
                overflow: hidden;
                overflow-y: hidden;
            `,
                children: (0, import_jsx_runtime.jsx)(m4.div, {
                  transition: { delay: 0, duration: 0.4 },
                  initial: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    background: "rgba(0,0,0, 1)",
                    scale: 1
                  },
                  animate: {
                    background: "rgba(92,92,92, 0.5)",
                    transformOrigin: "0px 0px",
                    width: width2 / devicePixelRatio,
                    height: height2 / devicePixelRatio,
                    scale: scaleRange / 100
                  },
                  "data-test-id": "z-body",
                  css: import_react20.css`
                  overflow:overlay;
                  overflow-y: hidden;
              `,
                  children: children2
                })
              }),
              (0, import_jsx_runtime.jsx)(m4.div, {
                transition: { delay: 0, duration: 0.4 },
                children: (0, import_jsx_runtime.jsx)(ToggleButtonGroup3, {
                  value: width2,
                  size: "small",
                  exclusive: true,
                  onChange: (_e, newSize) => {
                    if (newSize) {
                      setHeight(breakPointHeights[breakPoints.indexOf(newSize)]);
                      setWidth(newSize);
                    }
                  },
                  children: breakPoints.map((size) => (0, import_jsx_runtime.jsx)(ToggleButton3, {
                    value: size,
                    children: size === 680 ? (0, import_jsx_runtime.jsx)(Phone, {
                      css: import_react20.css`
                        color: ${width2 === 680 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                        `
                    }) : size === 768 ? (0, import_jsx_runtime.jsx)(Tablet, {
                      css: import_react20.css`
                        color: ${width2 === 768 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                        `
                    }) : (0, import_jsx_runtime.jsx)(Tv, {
                      css: import_react20.css`
                        color: ${width2 === 1920 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                      `
                    })
                  }, `size-${size}`))
                })
              })
            ]
          }),
          (0, import_jsx_runtime.jsx)(m4.div, {
            transition: { delay: 0, duration: 0.4 },
            initial: { height: 0, width: 0 },
            animate: { height: "100%", width: "auto" },
            children: (0, import_jsx_runtime.jsxs)("div", {
              css: import_react20.css`
              padding: 16px;
              display: flex;
              overflow: "hidden";
              align-items: center;          
              flex-direction: column;
              `,
              children: [
                (0, import_jsx_runtime.jsx)(Fab_default, {
                  onClick: () => {
                    document.getElementById("root")?.requestFullscreen();
                  },
                  children: (0, import_jsx_runtime.jsx)(FullscreenIcon, {}, "fs")
                }, "fullscreen"),
                (0, import_jsx_runtime.jsx)(QRButton, {
                  url: location.origin + `/live/${room}/public`
                }, `qr-${hashCode32}`),
                (0, import_jsx_runtime.jsx)(Fab_default, {
                  onClick: () => open(`/live/${room}/public`),
                  children: (0, import_jsx_runtime.jsx)(Share, {})
                }, "Share")
              ]
            })
          })
        ]
      })
    })
  });
}, "DraggableWindow");
init_define_process();
init_react_preact();
init_define_process();
function isMobile() {
  let check = false;
  (function(a5) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a5) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a5.substr(0, 4))) {
      check = true;
    }
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
}
__name(isMobile, "isMobile");
var import_react23 = __toESM(require_emotion_react_cjs(), 1);
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var mod = {
  CH: () => {
  },
  code: ""
};
var Editor = __name(({ code, i: i4, codeSpace: codeSpace2, assets }) => {
  const ref = useRef(null);
  const [
    mySession,
    changeContent
  ] = useState({
    myCode: code,
    counter: i4,
    started: false,
    prettierJs: (code2) => code2 + "// " + Math.random(),
    runner: async ({ code: code2, counter: counter2, codeSpace: codeSpace3 }) => {
      const { runner: runner2 } = await import("./chunk-runner-6CJTC3M5-UP5R5JJY.mjs");
      const { prettierJs: prettierJs2 } = await import("./chunk-prettierEsm-JALIKOB4-CNG7B2FS.mjs");
      runner2({ code: prettierJs2(code2), counter: counter2, codeSpace: codeSpace3 });
      changeContent((x5) => ({
        ...x5,
        runner: runner2,
        code: code2,
        counter: counter2,
        prettierJs: prettierJs2
      }));
    },
    myId: "loading",
    getValue: () => "",
    setValue: (_code) => {
    },
    onChange: (_cb) => {
    },
    engine: isMobile() ? "ace" : "monaco"
  });
  mod.CH = () => changeContent;
  const {
    counter,
    myCode,
    started,
    myId,
    runner,
    engine,
    prettierJs,
    getValue: getValue3,
    setValue,
    onChange
  } = mySession;
  mod.code = myCode;
  const lines = code?.split("\n").length || 0;
  useEffect(() => {
    if (!ref?.current)
      return;
    const setMonaco = __name(async () => {
      const link = document.createElement("link");
      link.setAttribute("rel", "stylesheet");
      link.href = location.origin + "/" + assets["startMonaco.css"];
      document.head.appendChild(link);
      const { startMonaco } = await import(new URL(assets["startMonaco.mjs"], location.origin).toString());
      const { editor, monaco, model } = await startMonaco(
        {
          container: ref.current,
          name: codeSpace2,
          code: mST().code
        }
      );
      changeContent((x5) => ({
        ...x5,
        started: true,
        setValue: (code2) => {
          if (code2 == mST().code || code2 == mod.code)
            return;
          let state = null;
          try {
            state = editor.saveViewState();
          } catch (e22) {
            console.error("error while saving the state");
          }
          model.setValue(code2);
          if (state)
            editor.restoreViewState(state);
        },
        getValue: () => {
          try {
            (async () => {
              const tsWorker = await (await monaco.languages.typescript.getTypeScriptWorker())(
                monaco.Uri.parse(
                  location.origin + "/live/" + codeSpace2 + ".tsx"
                )
              );
              const diag = await tsWorker.getSemanticDiagnostics(
                location.origin + "/live/" + codeSpace2 + ".tsx"
              );
              console.log({ diag });
            })();
          } catch {
            console.error("ts diag error");
          }
          return model.getValue();
        },
        onChange: (cb2) => model.onDidChangeContent(cb2).dispose,
        myId: "editor"
      }));
    }, "setMonaco");
    const setAce = __name(async () => {
      const { startAce } = await import("./chunk-startAce-OPPUYB43-J4UQDLVA.mjs");
      const editor = await startAce(mST().code);
      changeContent((x5) => ({
        ...x5,
        onChange: (cb2) => {
          editor.session.on("change", cb2);
          return () => editor.session.off("change", cb2);
        },
        started: true,
        getValue: () => editor.session.getValue(),
        setValue: (code2) => editor.session.setValue(code2),
        myId: "editor"
      }));
    }, "setAce");
    const loadEditors = __name(async () => {
      if (engine === "monaco") {
        await setMonaco();
      } else {
        await setAce();
      }
      runner({ code: code + " ", counter, codeSpace: codeSpace2 });
    }, "loadEditors");
    loadEditors();
  }, [started, ref]);
  useEffect(() => {
    if (!started)
      return;
    const lastCode = mod.code;
    let last3 = 0;
    const handler = setInterval(() => {
      const now = Date.now();
      if (now - last3 < 5e3)
        return;
      last3 = now;
      if (getValue3() !== lastCode) {
        const code2 = getValue3();
        if (code2 === mST().code || code2 === mod.code)
          return;
        changeContent((x5) => ({ ...x5, myCode: code2, i: i4 + 1 }));
        runner({ code: code2, counter, codeSpace: codeSpace2 });
      }
    }, 5e3);
    return () => clearInterval(handler);
  }, [changeContent, i4, runner, prettierJs]);
  useEffect(() => {
    if (!started)
      return;
    if (i4 > counter) {
      changeContent((x5) => ({ ...x5, myCode: code, counter: i4 }));
      return;
    }
    const cb2 = __name(async () => {
      const code2 = getValue3();
      const newCode = prettierJs(code2);
      if (newCode === mod.code)
        return;
      if (newCode === mST().code)
        return;
      try {
        changeContent((x5) => ({
          ...x5,
          counter: counter + 1,
          myCode: newCode
        }));
        await runner({ code: newCode, counter: counter + 1, codeSpace: codeSpace2 });
      } catch (err) {
        console.error({ err });
        console.error("restore editor");
      }
    }, "cb");
    return onChange(() => cb2());
  }, [setValue, getValue3, onChange, counter, prettierJs, runner]);
  onSessionUpdate(() => {
    console.log("sessUP");
    const sess = mST();
    setTimeout(() => {
      if (sess.i <= counter) {
        return;
      }
      if (mST().i > sess.i)
        return;
      setValue(sess.code);
      if (mod.CH() !== changeContent) {
        const ch = mod.CH();
        ch((x5) => ({
          ...x5,
          myCode: sess.code,
          counter: sess.i
        }));
      }
      changeContent((x5) => ({
        ...x5,
        myCode: sess.code,
        counter: sess.i
      }));
    }, 300);
  }, "editor");
  return engine === "monaco" ? (0, import_jsx_runtime.jsx)("div", {
    "data-test-id": myId,
    css: import_react23.css`
        
            max-width: 640px;
              height: ${60 + lines / 40 * 100}%;
            
        `,
    ref
  }) : (0, import_jsx_runtime.jsx)("div", {
    "data-test-id": myId,
    css: import_react23.css`
                margin: 0;
                position: absolute;
                bottom: 0;
                top: 0;
                left: 0;
                right: 0;
              `,
    id: "editor",
    ref
  });
}, "Editor");
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var RainbowContainer = __name(({ children: children2 }) => (0, import_jsx_runtime.jsx)("div", {
  css: import_react26.css`
height: 100%;
width: 100%;
background-blend-mode: overlay;
background:  repeating-radial-gradient(circle at bottom left, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
            #e87f24 0, #e87f24 22.2222222222%, 
            #dd6227 0, #dd6227 27.7777777778%,
             #dc4c27 0, #dc4c27 33.3333333333%, 
            #ca3435 0, #ca3435 38.8888888889%, 
            #b82841 0, #b82841 44.4444444444%, 
            #953751 0, #953751 50%, #364c88 0, 
            #364c88 55.5555555556%, #16599d 0, 
            #16599d 61.1111111111%, #02609e 0, 
            #02609e 66.6666666667%, #0073a9 0, 
            #0073a9 72.2222222222%, #008aa4 0, 
            #008aa4 77.7777777778%, #239a87 0, 
            #239a87 83.3333333333%, #7cba6d 0, 
            #7cba6d 88.8888888889%, #becc2f 0, 
            #becc2f 94.4444444444%, #e0d81d 0, 
            #e0d81d 100%), 
            repeating-radial-gradient(circle at bottom right, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
              #e87f24 0, #e87f24 22.2222222222%, 
              #dd6227 0, #dd6227 27.7777777778%, 
              #dc4c27 0, #dc4c27 33.3333333333%, 
              #ca3435 0, #ca3435 38.8888888889%, 
              #b82841 0, #b82841 44.4444444444%, 
              #953751 0, #953751 50%,
               #364c88 0, #364c88 55.5555555556%, 
               #16599d 0, #16599d 61.1111111111%, 
               #02609e 0, #02609e 66.6666666667%, 
               #0073a9 0, #0073a9 72.2222222222%, 
               #008aa4 0, #008aa4 77.7777777778%,
                #239a87 0, #239a87 83.3333333333%, 
                #7cba6d 0, #7cba6d 88.8888888889%, 
                #becc2f 0, #becc2f 94.4444444444%, 
                #e0d81d 0, #e0d81d 100%);
`,
  children: children2
}), "RainbowContainer");
var AppToRender = __name(({ codeSpace: codeSpace2, assets }) => {
  const [hash32, setHash] = useState(() => hashCode3());
  const [isStandalone, setIsStandalone] = useState(true);
  useEffect(() => {
    onSessionUpdate(async () => {
      const newHash = hashCode3();
      if (hash32 !== newHash) {
        try {
          await appFactory();
          setHash(newHash);
        } catch (e22) {
          console.error({ e: e22 });
        }
      }
    }, "myApp");
  }, [hash32, setHash]);
  useEffect(() => {
    setTimeout(() => {
      const isStandalone2 = location.pathname.endsWith("public") || location.pathname.endsWith("hydrated");
      setIsStandalone(isStandalone2);
    }, 800);
  }, []);
  const portalNode = useMemo(() => createHtmlPortalNode({
    attributes: { id: `root-${codeSpace2}`, style: "height: 100%" }
  }), []);
  return (0, import_jsx_runtime.jsxs)(p, {
    children: [
      (0, import_jsx_runtime.jsx)(InPortal, {
        node: portalNode,
        children: (0, import_jsx_runtime.jsx)(AutoUpdateApp, {
          hash: hash32
        })
      }),
      isStandalone ? (0, import_jsx_runtime.jsx)(OutPortal, {
        node: portalNode
      }) : (0, import_jsx_runtime.jsxs)(RainbowContainer, {
        children: [
          (0, import_jsx_runtime.jsx)(OutPortal, {
            node: portalNode
          }),
          (0, import_jsx_runtime.jsx)(Editor, {
            code: mST().code,
            i: mST().i,
            codeSpace: codeSpace2,
            assets
          }),
          (0, import_jsx_runtime.jsx)(DraggableWindow, {
            hashCode: 0,
            room: codeSpace2,
            children: (0, import_jsx_runtime.jsx)(OutPortal, {
              node: portalNode
            })
          })
        ]
      })
    ]
  });
}, "AppToRender");
var renderPreviewWindow = __name(({ codeSpace: codeSpace2, assets }) => {
  const div = document.getElementById("root");
  const root = createRoot(div);
  root.render(
    (0, import_jsx_runtime.jsx)(p, {
      children: (0, import_jsx_runtime.jsx)(AppToRender, {
        codeSpace: codeSpace2,
        assets
      })
    })
  );
}, "renderPreviewWindow");
var import_lodash = __toESM(require_lodash(), 1);
init_define_process();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    }
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");
var __default = /^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;
function validate(uuid) {
  return typeof uuid === "string" && __default.test(uuid);
}
__name(validate, "validate");
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function stringify(array) {
  const offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const uuid = (byteToHex[array[offset2 + 0]] + byteToHex[array[offset2 + 1]] + byteToHex[array[offset2 + 2]] + byteToHex[array[offset2 + 3]] + "-" + byteToHex[array[offset2 + 4]] + byteToHex[array[offset2 + 5]] + "-" + byteToHex[array[offset2 + 6]] + byteToHex[array[offset2 + 7]] + "-" + byteToHex[array[offset2 + 8]] + byteToHex[array[offset2 + 9]] + "-" + byteToHex[array[offset2 + 10]] + byteToHex[array[offset2 + 11]] + byteToHex[array[offset2 + 12]] + byteToHex[array[offset2 + 13]] + byteToHex[array[offset2 + 14]] + byteToHex[array[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw new TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
__name(stringify, "stringify");
function v4(options, buf, offset2) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i1 = 0; i1 < 16; ++i1) {
      buf[offset2 + i1] = rnds[i1];
    }
    return buf;
  }
  return stringify(rnds);
}
__name(v4, "v4");
var webRtcArray = [];
var user = (self && self.crypto && self.crypto.randomUUID && self.crypto.randomUUID() || v4()).slice(
  0,
  8
);
var rtcConns = {};
var bc;
var codeSpace;
var address;
var wsLastHashCode = 0;
var webRTCLastSeenHashCode = 0;
var lastSeenTimestamp = 0;
var lastSeenNow = 0;
var ws = null;
var sendWS;
var rejoined = false;
var sendChannel = {
  webRtcArray,
  rtcConns,
  send: (data) => {
    const target = data.target;
    const messageString = JSON.stringify({
      ...data,
      name: data.name || user
    });
    webRtcArray.map((ch) => {
      try {
        console.log("WebRtc send", data, ch);
        if (ch.readyState !== "open")
          return;
        if (!target || ch.target === target && !ignoreUsers.includes(ch.target)) {
          ch.send(messageString);
        }
      } catch (e22) {
        console.error("Error in broadcasting event", { e: e22 });
      }
    });
  }
};
var run = __name(async (startState) => {
  codeSpace = startState.codeSpace;
  address = startState.address;
  startSession(codeSpace, {
    name: user,
    state: startState.mST
  }, location.origin);
  await appFactory(startState.mST.transpiled);
  renderPreviewWindow(startState);
  join2();
  bc = new BroadcastChannel("spike.land");
  bc.onmessage = async (event) => {
    if (event.data.ignoreUser && event.data.ignoreUser === user)
      return;
    console.log({ event });
    if (event.data.codeSpace === codeSpace && event.data.address && !address) {
      ws?.send(JSON.stringify({ codeSpace, address: event.data.address }));
    }
    if (event.data.ignoreUser) {
      !ignoreUsers.includes(event.data.ignoreUser) && ignoreUsers.push(event.data.ignoreUser);
    }
    if (event.data.codeSpace === codeSpace && event.data.sess.code !== mST().code) {
      const messageData = await makePatch(event.data.sess);
      await applyPatch2(messageData);
    }
  };
}, "run");
var intervalHandler = null;
async function rejoin() {
  if (!rejoined || ws === null) {
    ws = null;
    const newWs = await join2();
    return newWs;
  }
  return ws;
}
__name(rejoin, "rejoin");
var ignoreUsers = [];
async function saveCode(sess) {
  if (sess.i <= mST().i)
    return;
  console.log("creating a patch");
  const messageData = await makePatch(sess);
  console.log("applying the patch");
  await applyPatch2(messageData);
  console.log("done");
  if (sess.i !== mST().i)
    return;
  bc.postMessage({ ignoreUser: user, sess, codeSpace, address, messageData });
  debouncedSyncWs();
  debouncedSyncRTC();
}
__name(saveCode, "saveCode");
var debouncedSyncRTC = (0, import_lodash.default)(syncRTC, 100, {
  trailing: true,
  leading: true,
  maxWait: 500
});
var debouncedSyncWs = (0, import_lodash.default)(syncWS, 1200, {
  trailing: true,
  leading: true,
  maxWait: 2500
});
async function syncWS() {
  try {
    if (ws) {
      if (wsLastHashCode === hashCode3())
        return;
      const sess = mST();
      console.log({ wsLastHashCode });
      const message = await makePatchFrom(
        wsLastHashCode,
        sess
      );
      if (!message)
        return;
      if (message.newHash !== hashCode3()) {
        console.error("NEW hash is not even hashCode", hashCode3());
        return;
      }
      const messageString = JSON.stringify({ ...message, name: user });
      sendWS(messageString);
    } else {
      rejoined = false;
      await rejoin();
    }
  } catch (e22) {
    console.error("error 2", { e: e22 });
  }
}
__name(syncWS, "syncWS");
async function syncRTC() {
  try {
    if (Object.keys(rtcConns).length > 0) {
      if (webRTCLastSeenHashCode === hashCode3())
        return;
      const sess = mST();
      console.log({ wsLastHashCode });
      const message = webRTCLastSeenHashCode ? await makePatchFrom(
        webRTCLastSeenHashCode,
        sess
      ) : await makePatch(sess);
      if (message && message.patch) {
        console.log("sendRTC");
        sendChannel.send(message);
      }
    }
  } catch (e22) {
    console.error("Error sending RTC...", { e: e22 });
  }
}
__name(syncRTC, "syncRTC");
async function join2() {
  if (ws !== null)
    return ws;
  rejoined = true;
  console.log("WS connect!");
  if (location.host.includes("localhost"))
    return;
  const wsConnection = new WebSocket(
    `wss://${location.host}/live/` + codeSpace + "/websocket"
  );
  rejoined = false;
  wsConnection.addEventListener("open", () => {
    console.log("NEW WS CONNECTION");
    ws = wsConnection;
    const mess = __name((data) => {
      try {
        ws && ws?.send && ws?.send(data);
      } catch (e22) {
        ws = null;
        rejoined = false;
        rejoin();
      }
    }, "mess");
    sendWS = mess;
    ws.addEventListener(
      "message",
      (message) => processWsMessage(message, "ws")
    );
    if (intervalHandler) {
      clearInterval(intervalHandler);
    }
    intervalHandler = setInterval(() => {
      const now = Date.now();
      const diff = now - lastSeenNow;
      if (diff > 4e4) {
        try {
          if (wsConnection.readyState === wsConnection.OPEN) {
            return wsConnection?.send(
              JSON.stringify({
                name: user,
                timestamp: lastSeenTimestamp + diff
              })
            );
          }
          rejoined = false;
          rejoin();
        } catch {
          rejoined = false;
          rejoin();
        }
      }
    }, 3e4);
    wsConnection.send(JSON.stringify({ name: user }));
    return wsConnection;
  });
  return wsConnection;
}
__name(join2, "join");
var h22 = {};
async function processWsMessage(event, source) {
  if (ws == null)
    return;
  lastSeenNow = Date.now();
  const data = JSON.parse(event.data);
  processData(data, source);
}
__name(processWsMessage, "processWsMessage");
async function processData(data, source) {
  console.log("ws", data.name, data.oldHash, data.newHash);
  if (source === "ws" && data.timestamp) {
    lastSeenNow = Date.now();
    lastSeenTimestamp = data.timestamp;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "rtc" && data.hashCode || data.newHash) {
    webRTCLastSeenHashCode = data.hashCode || data.newHash;
  }
  if (ignoreUsers.includes(data.name))
    return;
  if (data.newHash === hashCode3())
    return;
  if (data.oldHash && data.newHash) {
    if (h22[data.oldHash] && h22[data.oldHash] === data.newHash)
      return;
    h22[data.oldHash] = data.newHash;
  }
  if (data.newHash === hashCode3())
    return;
  (async () => {
    try {
      if (data.type === "new-ice-candidate") {
        await handleNewICECandidateMessage(data.candidate, data.name);
        return;
      }
      if (data.type === "offer") {
        await handleChatOffer(data.offer, data.name);
        return;
      }
      if (data.type === "answer") {
        await handleChatAnswerMessage(data.answer, data.name);
        return;
      }
      if (data.name && data.name !== user && !rtcConns[data.name]) {
        await createPeerConnection(data.name);
        return;
      }
    } catch (error) {
      console.log({ e: error });
      log_error("Error with p2p");
    }
  })();
  if (data.patch && data.name !== user) {
    if (data.newHash === hashCode3()) {
      return;
    }
    await applyPatch2(data);
    if (data.newHash === hashCode3()) {
      if (sendChannel) {
        sendChannel.send({ hashCode: data.newHash });
      }
      return;
    } else {
      console.log("error -sending on sendChannel");
    }
    return;
  }
  if (data.patch && data.name === user) {
    wsLastHashCode = data.newHash;
    return;
  }
  if (data.name === user) {
    return;
  }
  if (wsLastHashCode !== hashCode3()) {
    const resp = await fetch(`https://spike.land/live/${codeSpace}/mST`);
    const state = await resp.json();
    const codePatch = await makePatch(state.mST);
    if (codePatch.newHash === wsLastHashCode)
      await applyPatch2(codePatch);
  }
  function createPeerConnection(target) {
    log(`Setting up a connection with ${target}`);
    if (rtcConns[target]) {
      log(`Aborting, since we have connection with this ${target}`);
      return;
    }
    rtcConns[target] = new RTCPeerConnection(
      rcpOptions
    );
    rtcConns[target].onicecandidate = (event) => {
      if (event.candidate) {
        log("*** Outgoing ICE candidate: " + event.candidate);
        ws?.send(JSON.stringify({
          type: "new-ice-candidate",
          target,
          name: user,
          candidate: event.candidate.toJSON()
        }));
      }
    };
    rtcConns[target].oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
    rtcConns[target].onicegatheringstatechange = handleICEGatheringStateChangeEvent;
    rtcConns[target].onsignalingstatechange = () => {
      log(
        "*** rtcConns[target].signalingState  changed to: " + rtcConns[target].signalingState
      );
      switch (rtcConns[target].signalingState) {
        case "closed":
          break;
      }
    };
    rtcConns[target].onnegotiationneeded = handleNegotiationNeededEvent;
    rtcConns[target].ontrack = (ev) => console.log(ev);
    rtcConns[target].ondatachannel = (event) => {
      console.log("Receive Channel Callback");
      const rtc2 = event.channel;
      rtc2.binaryType = "arraybuffer";
      rtc2.addEventListener("close", onReceiveChannelClosed);
      rtc2.addEventListener(
        "message",
        (message) => processWsMessage(message, "rtc")
      );
      const rtcWithTarget = Object.assign(rtc2, { target });
      webRtcArray.push(rtcWithTarget);
    };
    const dataChannelOptions = {
      ordered: true,
      reliable: true,
      maxPacketLifeTime: 3e3
    };
    const rtc = Object.assign(
      rtcConns[target].createDataChannel(
        target,
        dataChannelOptions
      ),
      { target }
    );
    rtc.binaryType = "arraybuffer";
    rtc.addEventListener("message", (message) => {
      console.log("***********RTC***", { msg: message });
      const data2 = JSON.parse(message.data);
      if (data2 && data2.hashCode) {
        webRTCLastSeenHashCode = data2.hashCode;
      }
      if (data2 && data2.newHash) {
        webRTCLastSeenHashCode = data2.newHash;
      }
      return processWsMessage(message, "rtc");
    });
    rtc.addEventListener("error", (error) => {
      console.log("xxxxxx-  Data Channel Error:", error);
    });
    rtc.addEventListener("open", () => {
      console.log("@@@@@@@@RTC IS OPEN&&&&&&&&");
      webRtcArray.push(rtc);
    });
    rtc.addEventListener("close", () => {
      console.log("xxxxxxxx- The Data Channel is Closed");
    });
    return rtcConns[target];
    function onReceiveChannelClosed() {
      console.log("Receive channel is closed");
      rtcConns[target].close();
      delete rtcConns[target];
      console.log("Closed remote peer connection");
    }
    __name(onReceiveChannelClosed, "onReceiveChannelClosed");
    async function handleNegotiationNeededEvent() {
      log("*** Negotiation needed");
      try {
        log("---> Creating offer");
        const offer = await rtcConns[target].createOffer();
        if (rtcConns[target].signalingState != "stable") {
          log("The connection isn't stable yet; postponing...");
          return;
        }
        log("---> Setting local description to the offer");
        await rtcConns[target].setLocalDescription(offer);
        log("---> Sending the offer to the remote peer");
        ws?.send(JSON.stringify({
          target,
          name: user,
          type: "offer",
          offer: rtcConns[target].localDescription
        }));
      } catch {
        log(
          "*** The following error occurred while handling the negotiationneeded event:"
        );
      }
    }
    __name(handleNegotiationNeededEvent, "handleNegotiationNeededEvent");
    function handleICEConnectionStateChangeEvent() {
      log(
        "*** ICE connection state changed to " + rtcConns[target].iceConnectionState
      );
      switch (rtcConns[target].iceConnectionState) {
        case "closed":
        case "failed":
        case "disconnected":
          break;
      }
    }
    __name(handleICEConnectionStateChangeEvent, "handleICEConnectionStateChangeEvent");
    function handleICEGatheringStateChangeEvent() {
      log(
        "*** rtcConns[target].iceGatheringState changed to: " + rtcConns[target].iceGatheringState
      );
    }
    __name(handleICEGatheringStateChangeEvent, "handleICEGatheringStateChangeEvent");
  }
  __name(createPeerConnection, "createPeerConnection");
  async function handleChatAnswerMessage(answer, target) {
    log("*** Call recipient has accepted our call");
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(
        answer
      )
    ).catch(console.error);
  }
  __name(handleChatAnswerMessage, "handleChatAnswerMessage");
  async function handleChatOffer(offer, target) {
    if (!rtcConns[target])
      createPeerConnection(target);
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(offer)
    );
    log("---> Creating and sending answer to caller");
    const answer = await rtcConns[target].createAnswer();
    await rtcConns[target].setLocalDescription(
      answer
    );
    ws?.send(JSON.stringify({
      target,
      name: user,
      type: "answer",
      answer
    }));
  }
  __name(handleChatOffer, "handleChatOffer");
}
__name(processData, "processData");
function log(text) {
  const time2 = new Date();
  console.log("[" + time2.toLocaleTimeString() + "] " + text);
}
__name(log, "log");
function log_error(text) {
  const time2 = new Date();
  console.trace("[" + time2.toLocaleTimeString() + "] " + text);
}
__name(log_error, "log_error");
var rcpOptions = {
  iceServers: ["stun3.l.google.com:19302"].map((url) => ({
    urls: `stun:${url}`
  }))
};
rcpOptions.iceServers = [{ urls: "stun:stun.stunprotocol.org:3478" }, {
  urls: "stun:stun.l.google.com:19302"
}];
async function handleNewICECandidateMessage(init, target) {
  log(
    "*** Adding received ICE candidate: " + JSON.stringify(init)
  );
  const candidate = new RTCIceCandidate(init);
  console.log(rtcConns[target]);
  await rtcConns[target].addIceCandidate(candidate);
}
__name(handleNewICECandidateMessage, "handleNewICECandidateMessage");
async function sw() {
  try {
    navigator.serviceWorker.onmessage = async (event) => {
      const serviceWorker = event.source;
      if (serviceWorker == null)
        return;
      switch (event.data.method) {
        case "ipfs-message-port":
          console.log("Message port request");
          const channel = new MessageChannel();
          return serviceWorker.postMessage({
            method: "ipfs-message-port",
            id: event.data.id,
            port: channel.port2
          }, { transfer: [channel.port2] });
      }
    };
    if (document.documentElement.dataset.viewer) {
      const load = __name(async (path) => {
        const paths = path && path.split("/") || [];
        const protocol = paths[0] || "";
        switch (protocol) {
          case "ipfs":
          case "ipns": {
            document.body.innerHTML = `<iframe id="viewer" style="width:100%;height:100%;position:fixed;top:0;left:0;border:none;" src="/view${path}"></iframe>`;
          }
        }
      }, "load");
      return load(location.pathname);
    }
  } catch {
    console.log("ipfs load error");
  }
}
__name(sw, "sw");

export {
  mST,
  createRoot,
  useEffect,
  flushSync,
  init_react_preact,
  require_emotion_react_jsx_runtime_cjs,
  md5,
  appFactory,
  run,
  saveCode,
  join2 as join,
  sw
};

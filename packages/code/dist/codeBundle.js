async function transpile(code) {
    const { transpileCode  } = await import("./transpile.js");
    return transpileCode(code);
}
const src = "https://unpkg.com/@zedvision/emotion-react-renderer@10.13.3/dist/bundle.js";
let renderEmotion = null;
function getSession() {
    const session = {
        unmount: ()=>{
        },
        hydrated: false,
        preRendered: false,
        lastErrors: 0,
        HTML: "",
        ipfs: 0,
        transpiled: "",
        code: ""
    };
    return session;
}
let prettier;
let parserBabel;
let parserHtml;
async function formatter(code) {
    prettier = prettier || (await import("https://unpkg.com/prettier@2.2.1/esm/standalone.mjs")).default;
    parserBabel = parserBabel || (await import("https://unpkg.com/prettier@2.2.1/esm/parser-babel.mjs")).default;
    parserHtml = parserHtml || (await import("https://unpkg.com/prettier@2.2.1/esm/parser-html.mjs")).default;
    try {
        return prettier.format(code, {
            "arrowParens": "always",
            "bracketSpacing": true,
            "embeddedLanguageFormatting": "auto",
            "htmlWhitespaceSensitivity": "css",
            "insertPragma": false,
            "jsxBracketSameLine": true,
            "jsxSingleQuote": false,
            "printWidth": 80,
            "proseWrap": "preserve",
            "quoteProps": "as-needed",
            "requirePragma": false,
            "semi": true,
            "singleQuote": true,
            "tabWidth": 2,
            "trailingComma": "all",
            "useTabs": false,
            parser: "babel-ts",
            plugins: [
                parserBabel,
                parserHtml
            ]
        });
    } catch  {
        return code;
    }
}
function createJsBlob(code) {
    const blob = new Blob([
        code
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
let transform;
let node = null;
let ipfsNode;
function e2(e1, t) {
    if (null == e1) return {
    };
    var n, r, o = {
    }, u = Object.keys(e1);
    for(r = 0; r < u.length; r++)n = u[r], t.indexOf(n) >= 0 || (o[n] = e1[n]);
    return o;
}
function t5(e1, t1) {
    return t1 || (t1 = e1.slice(0)), Object.freeze(Object.defineProperties(e1, {
        raw: {
            value: Object.freeze(t1)
        }
    }));
}
var n2 = {
    name: "prettier",
    version: "2.2.1",
    description: "Prettier is an opinionated code formatter",
    bin: "./bin/prettier.js",
    repository: "prettier/prettier",
    homepage: "https://prettier.io",
    author: "James Long",
    license: "MIT",
    main: "./index.js",
    browser: "./standalone.js",
    unpkg: "./standalone.js",
    engines: {
        node: ">=10.13.0"
    },
    files: [
        "index.js",
        "standalone.js",
        "src",
        "bin"
    ],
    dependencies: {
        "@angular/compiler": "10.2.3",
        "@babel/code-frame": "7.10.4",
        "@babel/parser": "7.12.5",
        "@glimmer/syntax": "0.66.0",
        "@iarna/toml": "2.2.5",
        "@typescript-eslint/typescript-estree": "4.8.1",
        "angular-estree-parser": "2.2.1",
        "angular-html-parser": "1.7.1",
        camelcase: "6.2.0",
        chalk: "4.1.0",
        "ci-info": "watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540",
        "cjk-regex": "2.0.0",
        cosmiconfig: "7.0.0",
        dashify: "2.0.0",
        diff: "5.0.0",
        editorconfig: "0.15.3",
        "editorconfig-to-prettier": "0.2.0",
        "escape-string-regexp": "4.0.0",
        espree: "7.3.0",
        esutils: "2.0.3",
        "fast-glob": "3.2.4",
        "fast-json-stable-stringify": "2.1.0",
        "find-parent-dir": "0.3.0",
        "flow-parser": "0.138.0",
        "get-stdin": "8.0.0",
        globby: "11.0.1",
        graphql: "15.4.0",
        "html-element-attributes": "2.3.0",
        "html-styles": "1.0.0",
        "html-tag-names": "1.1.5",
        "html-void-elements": "1.0.5",
        ignore: "4.0.6",
        "jest-docblock": "26.0.0",
        json5: "2.1.3",
        leven: "3.1.0",
        "lines-and-columns": "1.1.6",
        "linguist-languages": "7.12.1",
        lodash: "4.17.20",
        mem: "8.0.0",
        meriyah: "3.1.6",
        minimatch: "3.0.4",
        minimist: "1.2.5",
        "n-readlines": "1.0.1",
        outdent: "0.7.1",
        "parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee",
        "please-upgrade-node": "3.2.0",
        "postcss-less": "3.1.4",
        "postcss-media-query-parser": "0.2.3",
        "postcss-scss": "2.1.1",
        "postcss-selector-parser": "2.2.3",
        "postcss-values-parser": "2.0.1",
        "regexp-util": "1.2.2",
        "remark-footnotes": "2.0.0",
        "remark-math": "3.0.1",
        "remark-parse": "8.0.3",
        resolve: "1.19.0",
        semver: "7.3.2",
        "string-width": "4.2.0",
        typescript: "4.1.2",
        "unicode-regex": "3.0.0",
        unified: "9.2.0",
        vnopts: "1.0.2",
        "yaml-unist-parser": "1.3.1"
    },
    devDependencies: {
        "@babel/core": "7.12.3",
        "@babel/preset-env": "7.12.1",
        "@babel/types": "7.12.6",
        "@glimmer/reference": "0.66.0",
        "@rollup/plugin-alias": "3.1.1",
        "@rollup/plugin-babel": "5.2.1",
        "@rollup/plugin-commonjs": "16.0.0",
        "@rollup/plugin-json": "4.1.0",
        "@rollup/plugin-node-resolve": "10.0.0",
        "@rollup/plugin-replace": "2.3.4",
        "@types/estree": "0.0.45",
        "@types/node": "14.14.0",
        "@typescript-eslint/types": "4.8.1",
        "babel-jest": "26.6.3",
        "babel-loader": "8.2.1",
        benchmark: "2.1.4",
        "builtin-modules": "3.1.0",
        "cross-env": "7.0.2",
        cspell: "4.2.2",
        eslint: "7.13.0",
        "eslint-config-prettier": "6.15.0",
        "eslint-formatter-friendly": "7.0.0",
        "eslint-plugin-import": "2.22.1",
        "eslint-plugin-jest": "24.1.3",
        "eslint-plugin-prettier-internal-rules": "file:scripts/tools/eslint-plugin-prettier-internal-rules",
        "eslint-plugin-react": "7.21.5",
        "eslint-plugin-unicorn": "23.0.0",
        execa: "4.1.0",
        jest: "26.6.3",
        "jest-snapshot-serializer-ansi": "1.0.0",
        "jest-snapshot-serializer-raw": "1.1.0",
        "jest-watch-typeahead": "0.6.1",
        "npm-run-all": "4.1.5",
        "path-browserify": "1.0.1",
        prettier: "2.2.0",
        rimraf: "3.0.2",
        rollup: "2.33.3",
        "rollup-plugin-node-globals": "1.4.0",
        "rollup-plugin-terser": "7.0.2",
        shelljs: "0.8.4",
        "snapshot-diff": "0.8.1",
        "strip-ansi": "6.0.0",
        "synchronous-promise": "2.0.15",
        tempy: "1.0.0",
        "terser-webpack-plugin": "5.0.3",
        webpack: "5.5.1"
    },
    scripts: {
        prepublishOnly: 'echo "Error: must publish from dist/" && exit 1',
        "prepare-release": "yarn && yarn build && yarn test:dist",
        test: "jest",
        "test:dev-package": "cross-env INSTALL_PACKAGE=1 jest",
        "test:dist": "cross-env NODE_ENV=production jest",
        "test:dist-standalone": "cross-env NODE_ENV=production TEST_STANDALONE=1 jest",
        "test:integration": "jest tests_integration",
        "perf:repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        "perf:repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        "perf:benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
        lint: "run-p lint:*",
        "lint:typecheck": "tsc",
        "lint:eslint": "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly",
        "lint:changelog": "node ./scripts/lint-changelog.js",
        "lint:prettier": 'prettier . "!test*" --check',
        "lint:dist": 'eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2018 "dist/!(bin-prettier|index|third-party).js"',
        "lint:spellcheck": 'cspell "**/*" ".github/**/*"',
        "lint:deps": "node ./scripts/check-deps.js",
        fix: "run-s fix:eslint fix:prettier",
        "fix:eslint": "yarn lint:eslint --fix",
        "fix:prettier": "yarn lint:prettier --write",
        build: "node --max-old-space-size=3072 ./scripts/build/build.js",
        "build-docs": "node ./scripts/build-docs.js"
    }
};
function r1() {
}
function o1(e1, t1, n1, r1, o1) {
    for(var u = 0, i = t1.length, a = 0, s = 0; u < i; u++){
        var l = t1[u];
        if (l.removed) {
            if (l.value = e1.join(r1.slice(s, s + l.count)), s += l.count, u && t1[u - 1].added) {
                var c = t1[u - 1];
                t1[u - 1] = t1[u], t1[u] = c;
            }
        } else {
            if (!l.added && o1) {
                var p = n1.slice(a, a + l.count);
                p = p.map(function(e2, t2) {
                    var n2 = r1[s + t2];
                    return n2.length > e2.length ? n2 : e2;
                }), l.value = e1.join(p);
            } else l.value = e1.join(n1.slice(a, a + l.count));
            a += l.count, l.added || (s += l.count);
        }
    }
    var d = t1[i - 1];
    return i > 1 && "string" == typeof d.value && (d.added || d.removed) && e1.equals("", d.value) && (t1[i - 2].value += d.value, t1.pop()), t1;
}
function u1(e1) {
    return {
        newPos: e1.newPos,
        components: e1.components.slice(0)
    };
}
r1.prototype = {
    diff: function(e1, t1) {
        var n1 = arguments.length > 2 && (void 0) !== arguments[2] ? arguments[2] : {
        }, r1 = n1.callback;
        "function" == typeof n1 && (r1 = n1, n1 = {
        }), this.options = n1;
        var i = this;
        function a(e2) {
            return r1 ? (setTimeout(function() {
                r1(void 0, e2);
            }, 0), !0) : e2;
        }
        e1 = this.castInput(e1), t1 = this.castInput(t1), e1 = this.removeEmpty(this.tokenize(e1));
        var s = (t1 = this.removeEmpty(this.tokenize(t1))).length, l = e1.length, c = 1, p = s + l, d = [
            {
                newPos: -1,
                components: []
            }
        ], f = this.extractCommon(d[0], t1, e1, 0);
        if (d[0].newPos + 1 >= s && f + 1 >= l) return a([
            {
                value: this.join(t1),
                count: t1.length
            }
        ]);
        function h() {
            for(var n2 = -1 * c; n2 <= c; n2 += 2){
                var r2 = void 0, p1 = d[n2 - 1], f1 = d[n2 + 1], h = (f1 ? f1.newPos : 0) - n2;
                p1 && (d[n2 - 1] = void 0);
                var m = p1 && p1.newPos + 1 < s, g = f1 && 0 <= h && h < l;
                if (m || g) {
                    if (!m || g && p1.newPos < f1.newPos ? (r2 = u1(f1), i.pushComponent(r2.components, void 0, !0)) : ((r2 = p1).newPos++, i.pushComponent(r2.components, !0, void 0)), h = i.extractCommon(r2, t1, e1, n2), r2.newPos + 1 >= s && h + 1 >= l) return a(o1(i, r2.components, t1, e1, i.useLongestToken));
                    d[n2] = r2;
                } else d[n2] = void 0;
            }
            c++;
        }
        if (r1) !(function e1() {
            setTimeout(function() {
                if (c > p) return r1();
                h() || e1();
            }, 0);
        })();
        else for(; c <= p;){
            var m = h();
            if (m) return m;
        }
    },
    pushComponent: function(e1, t1, n1) {
        var r1 = e1[e1.length - 1];
        r1 && r1.added === t1 && r1.removed === n1 ? e1[e1.length - 1] = {
            count: r1.count + 1,
            added: t1,
            removed: n1
        } : e1.push({
            count: 1,
            added: t1,
            removed: n1
        });
    },
    extractCommon: function(e1, t1, n1, r1) {
        for(var o1 = t1.length, u1 = n1.length, i = e1.newPos, a = i - r1, s = 0; i + 1 < o1 && a + 1 < u1 && this.equals(t1[i + 1], n1[a + 1]);)i++, a++, s++;
        return s && e1.components.push({
            count: s
        }), e1.newPos = i, a;
    },
    equals: function(e1, t1) {
        return this.options.comparator ? this.options.comparator(e1, t1) : e1 === t1 || this.options.ignoreCase && e1.toLowerCase() === t1.toLowerCase();
    },
    removeEmpty: function(e1) {
        for(var t1 = [], n1 = 0; n1 < e1.length; n1++)e1[n1] && t1.push(e1[n1]);
        return t1;
    },
    castInput: function(e1) {
        return e1;
    },
    tokenize: function(e1) {
        return e1.split("");
    },
    join: function(e1) {
        return e1.join("");
    }
};
var i1 = new r1;
function a1(e1, t1) {
    if ("function" == typeof e1) t1.callback = e1;
    else if (e1) for(var n1 in e1)e1.hasOwnProperty(n1) && (t1[n1] = e1[n1]);
    return t1;
}
var s1 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, l1 = /\S/, c1 = new r1;
c1.equals = function(e1, t1) {
    return this.options.ignoreCase && (e1 = e1.toLowerCase(), t1 = t1.toLowerCase()), e1 === t1 || this.options.ignoreWhitespace && !l1.test(e1) && !l1.test(t1);
}, c1.tokenize = function(e1) {
    for(var t1 = e1.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n1 = 0; n1 < t1.length - 1; n1++)!t1[n1 + 1] && t1[n1 + 2] && s1.test(t1[n1]) && s1.test(t1[n1 + 2]) && (t1[n1] += t1[n1 + 2], t1.splice(n1 + 1, 2), n1--);
    return t1;
};
var p1 = new r1;
function d1(e1, t1, n1) {
    return p1.diff(e1, t1, n1);
}
p1.tokenize = function(e1) {
    var t1 = [], n1 = e1.split(/(\n|\r\n)/);
    n1[n1.length - 1] || n1.pop();
    for(var r1 = 0; r1 < n1.length; r1++){
        var o1 = n1[r1];
        r1 % 2 && !this.options.newlineIsToken ? t1[t1.length - 1] += o1 : (this.options.ignoreWhitespace && (o1 = o1.trim()), t1.push(o1));
    }
    return t1;
};
var f2 = new r1;
f2.tokenize = function(e1) {
    return e1.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var h3 = new r1;
function m2(e1) {
    return (m2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
        return typeof e2;
    } : function(e2) {
        return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
    })(e1);
}
function D3(e1, t1) {
    (null == t1 || t1 > e1.length) && (t1 = e1.length);
    for(var n1 = 0, r1 = new Array(t1); n1 < t1; n1++)r1[n1] = e1[n1];
    return r1;
}
h3.tokenize = function(e1) {
    return e1.split(/([{}:;,]|\s+)/);
};
var y2 = Object.prototype.toString, E2 = new r1;
function C1(e1, t1, n1, r1, o1) {
    var u1, i1;
    for(t1 = t1 || [], n1 = n1 || [], r1 && (e1 = r1(o1, e1)), u1 = 0; u1 < t1.length; u1 += 1)if (t1[u1] === e1) return n1[u1];
    if ("[object Array]" === y2.call(e1)) {
        for(t1.push(e1), i1 = new Array(e1.length), n1.push(i1), u1 = 0; u1 < e1.length; u1 += 1)i1[u1] = C1(e1[u1], t1, n1, r1, o1);
        return t1.pop(), n1.pop(), i1;
    }
    if (e1 && e1.toJSON && (e1 = e1.toJSON()), "object" === m2(e1) && null !== e1) {
        t1.push(e1), i1 = {
        }, n1.push(i1);
        var a1, s1 = [];
        for(a1 in e1)e1.hasOwnProperty(a1) && s1.push(a1);
        for(s1.sort(), u1 = 0; u1 < s1.length; u1 += 1)i1[a1 = s1[u1]] = C1(e1[a1], t1, n1, r1, a1);
        t1.pop(), n1.pop();
    } else i1 = e1;
    return i1;
}
E2.useLongestToken = !0, E2.tokenize = p1.tokenize, E2.castInput = function(e1) {
    var t1 = this.options, n1 = t1.undefinedReplacement, r1 = t1.stringifyReplacer, o1 = (void 0) === r1 ? function(e2, t2) {
        return (void 0) === t2 ? n1 : t2;
    } : r1;
    return "string" == typeof e1 ? e1 : JSON.stringify(C1(e1, null, null, o1), o1, "  ");
}, E2.equals = function(e1, t1) {
    return r1.prototype.equals.call(E2, e1.replace(/,([\r\n])/g, "$1"), t1.replace(/,([\r\n])/g, "$1"));
};
var b = new r1;
function v(e1) {
    var t1 = arguments.length > 1 && (void 0) !== arguments[1] ? arguments[1] : {
    }, n1 = e1.split(/\r\n|[\n\v\f\r\x85]/), r1 = e1.match(/\r\n|[\n\v\f\r\x85]/g) || [], o1 = [], u1 = 0;
    function i1() {
        var e2 = {
        };
        for(o1.push(e2); u1 < n1.length;){
            var r2 = n1[u1];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(r2)) break;
            var i1 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r2);
            i1 && (e2.index = i1[1]), u1++;
        }
        for(a2(e2), a2(e2), e2.hunks = []; u1 < n1.length;){
            var l1 = n1[u1];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(l1)) break;
            if (/^@@/.test(l1)) e2.hunks.push(s2());
            else {
                if (l1 && t1.strict) throw new Error("Unknown line " + (u1 + 1) + " " + JSON.stringify(l1));
                u1++;
            }
        }
    }
    function a2(e2) {
        var t2 = /^(---|\+\+\+)\s+(.*)$/.exec(n1[u1]);
        if (t2) {
            var r2 = "---" === t2[1] ? "old" : "new", o2 = t2[2].split("\t", 2), i2 = o2[0].replace(/\\\\/g, "\\");
            /^".*"$/.test(i2) && (i2 = i2.substr(1, i2.length - 2)), e2[r2 + "FileName"] = i2, e2[r2 + "Header"] = (o2[1] || "").trim(), u1++;
        }
    }
    function s2() {
        var e2 = u1, o2 = n1[u1++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), i2 = {
            oldStart: +o2[1],
            oldLines: (void 0) === o2[2] ? 1 : +o2[2],
            newStart: +o2[3],
            newLines: (void 0) === o2[4] ? 1 : +o2[4],
            lines: [],
            linedelimiters: []
        };
        0 === i2.oldLines && (i2.oldStart += 1), 0 === i2.newLines && (i2.newStart += 1);
        for(var a3 = 0, s2 = 0; u1 < n1.length && !(0 === n1[u1].indexOf("--- ") && u1 + 2 < n1.length && 0 === n1[u1 + 1].indexOf("+++ ") && 0 === n1[u1 + 2].indexOf("@@")); u1++){
            var l1 = 0 == n1[u1].length && u1 != n1.length - 1 ? " " : n1[u1][0];
            if ("+" !== l1 && "-" !== l1 && " " !== l1 && "\\" !== l1) break;
            i2.lines.push(n1[u1]), i2.linedelimiters.push(r1[u1] || "\n"), "+" === l1 ? a3++ : "-" === l1 ? s2++ : " " === l1 && (a3++, s2++);
        }
        if (a3 || 1 !== i2.newLines || (i2.newLines = 0), s2 || 1 !== i2.oldLines || (i2.oldLines = 0), t1.strict) {
            if (a3 !== i2.newLines) throw new Error("Added line count did not match for hunk at line " + (e2 + 1));
            if (s2 !== i2.oldLines) throw new Error("Removed line count did not match for hunk at line " + (e2 + 1));
        }
        return i2;
    }
    for(; u1 < n1.length;)i1();
    return o1;
}
function A(e1, t1, n1) {
    var r1 = !0, o1 = !1, u1 = !1, i1 = 1;
    return function a2() {
        if (r1 && !u1) {
            if (o1 ? i1++ : r1 = !1, e1 + i1 <= n1) return i1;
            u1 = !0;
        }
        if (!o1) return u1 || (r1 = !0), t1 <= e1 - i1 ? -i1++ : (o1 = !0, a2());
    };
}
function F(e1, t1) {
    var n1 = arguments.length > 2 && (void 0) !== arguments[2] ? arguments[2] : {
    };
    if ("string" == typeof t1 && (t1 = v(t1)), Array.isArray(t1)) {
        if (t1.length > 1) throw new Error("applyPatch only works with a single input.");
        t1 = t1[0];
    }
    var r1, o1, u1 = e1.split(/\r\n|[\n\v\f\r\x85]/), i1 = e1.match(/\r\n|[\n\v\f\r\x85]/g) || [], a2 = t1.hunks, s2 = n1.compareLine || function(e2, t2, n2, r2) {
        return t2 === r2;
    }, l1 = 0, c1 = n1.fuzzFactor || 0, p1 = 0, d1 = 0;
    function f1(e2, t2) {
        for(var n2 = 0; n2 < e2.lines.length; n2++){
            var r2 = e2.lines[n2], o2 = r2.length > 0 ? r2[0] : " ", i2 = r2.length > 0 ? r2.substr(1) : r2;
            if (" " === o2 || "-" === o2) {
                if (!s2(t2 + 1, u1[t2], o2, i2) && (++l1) > c1) return !1;
                t2++;
            }
        }
        return !0;
    }
    for(var h1 = 0; h1 < a2.length; h1++){
        for(var m1 = a2[h1], g = u1.length - m1.oldLines, D1 = 0, y1 = d1 + m1.oldStart - 1, E1 = A(y1, p1, g); (void 0) !== D1; D1 = E1())if (f1(m1, y1 + D1)) {
            m1.offset = d1 += D1;
            break;
        }
        if ((void 0) === D1) return !1;
        p1 = m1.offset + m1.oldStart + m1.oldLines;
    }
    for(var C1 = 0, b1 = 0; b1 < a2.length; b1++){
        var F = a2[b1], x = F.oldStart + F.offset + C1 - 1;
        C1 += F.newLines - F.oldLines;
        for(var S = 0; S < F.lines.length; S++){
            var w = F.lines[S], T = w.length > 0 ? w[0] : " ", B = w.length > 0 ? w.substr(1) : w, N = F.linedelimiters[S];
            if (" " === T) x++;
            else if ("-" === T) u1.splice(x, 1), i1.splice(x, 1);
            else if ("+" === T) u1.splice(x, 0, B), i1.splice(x, 0, N), x++;
            else if ("\\" === T) {
                var k = F.lines[S - 1] ? F.lines[S - 1][0] : null;
                "+" === k ? r1 = !0 : "-" === k && (o1 = !0);
            }
        }
    }
    if (r1) for(; !u1[u1.length - 1];)u1.pop(), i1.pop();
    else o1 && (u1.push(""), i1.push("\n"));
    for(var P = 0; P < u1.length - 1; P++)u1[P] = u1[P] + i1[P];
    return u1.join("");
}
function w(e1, t1) {
    if (t1.length > e1.length) return !1;
    for(var n1 = 0; n1 < t1.length; n1++)if (t1[n1] !== e1[n1]) return !1;
    return !0;
}
function N(e1) {
    return e1.newFileName && e1.newFileName !== e1.oldFileName;
}
function k3(e1, t1, n1) {
    return t1 === n1 ? t1 : (e1.conflict = !0, {
        mine: t1,
        theirs: n1
    });
}
function P2(e1, t1) {
    return e1.oldStart < t1.oldStart && e1.oldStart + e1.oldLines < t1.oldStart;
}
function O(e1, t1) {
    return {
        oldStart: e1.oldStart,
        oldLines: e1.oldLines,
        newStart: e1.newStart + t1,
        newLines: e1.newLines,
        lines: e1.lines
    };
}
function j2(e1, t1, n1) {
    e1.conflict = !0, e1.lines.push({
        conflict: !0,
        mine: t1,
        theirs: n1
    });
}
function _(e1, t1, n1) {
    for(; t1.offset < n1.offset && t1.index < t1.lines.length;){
        var r1 = t1.lines[t1.index++];
        e1.lines.push(r1), t1.offset++;
    }
}
function R(e1, t1) {
    for(; t1.index < t1.lines.length;){
        var n1 = t1.lines[t1.index++];
        e1.lines.push(n1);
    }
}
function V(e1) {
    for(var t1 = [], n1 = e1.lines[e1.index][0]; e1.index < e1.lines.length;){
        var r1 = e1.lines[e1.index];
        if ("-" === n1 && "+" === r1[0] && (n1 = "+"), n1 !== r1[0]) break;
        t1.push(r1), e1.index++;
    }
    return t1;
}
function $(e1) {
    return e1.reduce(function(e2, t1) {
        return e2 && "-" === t1[0];
    }, !0);
}
function q(e1, t1, n1) {
    for(var r1 = 0; r1 < n1; r1++){
        var o1 = t1[t1.length - n1 + r1].substr(1);
        if (e1.lines[e1.index + r1] !== " " + o1) return !1;
    }
    return e1.index += n1, !0;
}
function W(e1) {
    var t1 = 0, n1 = 0;
    return e1.forEach(function(e2) {
        if ("string" != typeof e2) {
            var r1 = W(e2.mine), o1 = W(e2.theirs);
            (void 0) !== t1 && (r1.oldLines === o1.oldLines ? t1 += r1.oldLines : t1 = void 0), (void 0) !== n1 && (r1.newLines === o1.newLines ? n1 += r1.newLines : n1 = void 0);
        } else (void 0) === n1 || "+" !== e2[0] && " " !== e2[0] || n1++, (void 0) === t1 || "-" !== e2[0] && " " !== e2[0] || t1++;
    }), {
        oldLines: t1,
        newLines: n1
    };
}
function U(e1) {
    var t1 = e1;
    return t1 = (t1 = (t1 = (t1 = t1.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
}
b.tokenize = function(e1) {
    return e1.slice();
}, b.join = b.removeEmpty = function(e1) {
    return e1;
};
function z(e1) {
    return {
        type: "concat",
        parts: e1
    };
}
function G(e1) {
    return {
        type: "indent",
        contents: e1
    };
}
function H2(e1, t1) {
    return {
        type: "align",
        contents: t1,
        n: e1
    };
}
function X(e1, t1) {
    return {
        type: "group",
        id: (t1 = t1 || {
        }).id,
        contents: e1,
        break: !!t1.shouldBreak,
        expandedStates: t1.expandedStates
    };
}
const Y = {
    type: "break-parent"
}, K = z([
    {
        type: "line",
        hard: !0
    },
    Y
]), Q1 = z([
    {
        type: "line",
        hard: !0,
        literal: !0
    },
    Y
]);
var Z2 = {
    concat: z,
    join: function(e1, t1) {
        const n1 = [];
        for(let r1 = 0; r1 < t1.length; r1++)0 !== r1 && n1.push(e1), n1.push(t1[r1]);
        return z(n1);
    },
    line: {
        type: "line"
    },
    softline: {
        type: "line",
        soft: !0
    },
    hardline: K,
    literalline: Q1,
    group: X,
    conditionalGroup: function(e1, t1) {
        return X(e1[0], Object.assign({
        }, t1, {
            expandedStates: e1
        }));
    },
    fill: function(e1) {
        return {
            type: "fill",
            parts: e1
        };
    },
    lineSuffix: function(e1) {
        return {
            type: "line-suffix",
            contents: e1
        };
    },
    lineSuffixBoundary: {
        type: "line-suffix-boundary"
    },
    cursor: {
        type: "cursor",
        placeholder: Symbol("cursor")
    },
    breakParent: Y,
    ifBreak: function(e1, t1, n1) {
        return {
            type: "if-break",
            breakContents: e1,
            flatContents: t1,
            groupId: (n1 = n1 || {
            }).groupId
        };
    },
    trim: {
        type: "trim"
    },
    indent: G,
    align: H2,
    addAlignmentToDoc: function(e1, t1, n1) {
        let r1 = e1;
        if (t1 > 0) {
            for(let e2 = 0; e2 < Math.floor(t1 / n1); ++e2)r1 = G(r1);
            r1 = H2(t1 % n1, r1), r1 = H2(-1 / 0, r1);
        }
        return r1;
    },
    markAsRoot: function(e1) {
        return H2({
            type: "root"
        }, e1);
    },
    dedentToRoot: function(e1) {
        return H2(-1 / 0, e1);
    },
    dedent: function(e1) {
        return H2(-1, e1);
    }
}, ee2 = (e1)=>"string" == typeof e1 ? e1.replace((({ onlyFirst: e2 = !1  } = {
    })=>{
        const t1 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(t1, e2 ? void 0 : "g");
    })(), "") : e1
;
const te = (e1)=>!Number.isNaN(e1) && (e1 >= 4352 && (e1 <= 4447 || 9001 === e1 || 9002 === e1 || 11904 <= e1 && e1 <= 12871 && 12351 !== e1 || 12880 <= e1 && e1 <= 19903 || 19968 <= e1 && e1 <= 42182 || 43360 <= e1 && e1 <= 43388 || 44032 <= e1 && e1 <= 55203 || 63744 <= e1 && e1 <= 64255 || 65040 <= e1 && e1 <= 65049 || 65072 <= e1 && e1 <= 65131 || 65281 <= e1 && e1 <= 65376 || 65504 <= e1 && e1 <= 65510 || 110592 <= e1 && e1 <= 110593 || 127488 <= e1 && e1 <= 127569 || 131072 <= e1 && e1 <= 262141))
;
var ne1 = te, re = te;
ne1.default = re;
const oe = (e1)=>{
    if ("string" != typeof (e1 = e1.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === e1.length) return 0;
    e1 = ee2(e1);
    let t1 = 0;
    for(let n1 = 0; n1 < e1.length; n1++){
        const r1 = e1.codePointAt(n1);
        r1 <= 31 || r1 >= 127 && r1 <= 159 || (r1 >= 768 && r1 <= 879 || (r1 > 65535 && n1++, t1 += ne1(r1) ? 2 : 1));
    }
    return t1;
};
var ue = oe, ie = oe;
ue.default = ie;
var ae = (e1)=>{
    if ("string" != typeof e1) throw new TypeError("Expected a string");
    return e1.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, se = (e1)=>e1[e1.length - 1]
, le = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function ce2() {
    throw new Error("setTimeout has not been defined");
}
function pe2() {
    throw new Error("clearTimeout has not been defined");
}
var de3 = ce2, fe = pe2;
function he3(e1) {
    if (de3 === setTimeout) return setTimeout(e1, 0);
    if ((de3 === ce2 || !de3) && setTimeout) return de3 = setTimeout, setTimeout(e1, 0);
    try {
        return de3(e1, 0);
    } catch (t) {
        try {
            return de3.call(null, e1, 0);
        } catch (t) {
            return de3.call(this, e1, 0);
        }
    }
}
"function" == typeof le.setTimeout && (de3 = setTimeout), "function" == typeof le.clearTimeout && (fe = clearTimeout);
var me, ge3 = [], De2 = !1, ye2 = -1;
function be2(e1, t1) {
    this.fun = e1, this.array = t1;
}
be2.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function ve3() {
}
var Ae = ve3, Fe = ve3, xe = ve3, Se = ve3, we3 = ve3, Te = ve3, Be = ve3;
var Ne = le.performance || {
}, ke = Ne.now || Ne.mozNow || Ne.msNow || Ne.oNow || Ne.webkitNow || function() {
    return (new Date).getTime();
};
var Pe3 = new Date;
var Le3 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
}, Me = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {
};
function je(e1, t1, n1) {
    return e1(n1 = {
        path: t1,
        exports: {
        },
        require: function(e2, t2) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == t2 && n1.path);
        }
    }, n1.exports), n1.exports;
}
function _e(e1) {
    return e1 && Object.prototype.hasOwnProperty.call(e1, "default") ? e1.default : e1;
}
const Ve = /^[0-9]+$/, $e = (e1, t1)=>{
    const n1 = Ve.test(e1), r1 = Ve.test(t1);
    return n1 && r1 && (e1 = +e1, t1 = +t1), e1 === t1 ? 0 : n1 && !r1 ? -1 : r1 && !n1 ? 1 : e1 < t1 ? -1 : 1;
};
var qe = {
    compareIdentifiers: $e,
    rcompareIdentifiers: (e1, t1)=>$e(t1, e1)
};
function et() {
    const e1 = t5([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return et = function() {
        return e1;
    }, e1;
}
function tt() {
    const e1 = t5([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return tt = function() {
        return e1;
    }, e1;
}
function nt() {
    const e1 = t5([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return nt = function() {
        return e1;
    }, e1;
}
function rt() {
    const e1 = t5([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return rt = function() {
        return e1;
    }, e1;
}
function ot() {
    const e1 = t5([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return ot = function() {
        return e1;
    }, e1;
}
function ut() {
    const e1 = t5([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return ut = function() {
        return e1;
    }, e1;
}
function ht(e1) {
    return (t1, n1, r1)=>{
        const o1 = r1 && r1.backwards;
        if (!1 === n1) return !1;
        const { length: u1  } = t1;
        let i1 = n1;
        for(; i1 >= 0 && i1 < u1;){
            const n2 = t1.charAt(i1);
            if (e1 instanceof RegExp) {
                if (!e1.test(n2)) return i1;
            } else if (!e1.includes(n2)) return i1;
            o1 ? i1-- : i1++;
        }
        return (-1 === i1 || i1 === u1) && i1;
    };
}
const mt = ht(/\s/), gt = ht(" \t"), Dt = ht(",; \t"), yt = ht(/[^\n\r]/);
function Et(e1, t1) {
    if (!1 === t1) return !1;
    if ("/" === e1.charAt(t1) && "*" === e1.charAt(t1 + 1)) for(let n1 = t1 + 2; n1 < e1.length; ++n1)if ("*" === e1.charAt(n1) && "/" === e1.charAt(n1 + 1)) return n1 + 2;
    return t1;
}
function Ct(e1, t1) {
    return !1 !== t1 && ("/" === e1.charAt(t1) && "/" === e1.charAt(t1 + 1) ? yt(e1, t1) : t1);
}
function bt(e1, t1, n1) {
    const r1 = n1 && n1.backwards;
    if (!1 === t1) return !1;
    const o1 = e1.charAt(t1);
    if (r1) {
        if ("\r" === e1.charAt(t1 - 1) && "\n" === o1) return t1 - 2;
        if ("\n" === o1 || "\r" === o1 || "\u2028" === o1 || "\u2029" === o1) return t1 - 1;
    } else {
        if ("\r" === o1 && "\n" === e1.charAt(t1 + 1)) return t1 + 2;
        if ("\n" === o1 || "\r" === o1 || "\u2028" === o1 || "\u2029" === o1) return t1 + 1;
    }
    return t1;
}
function vt(e1, t1, n1) {
    const r1 = gt(e1, (n1 = n1 || {
    }).backwards ? t1 - 1 : t1, n1);
    return r1 !== bt(e1, r1, n1);
}
function At(e1, t1) {
    let n1 = null, r1 = t1;
    for(; r1 !== n1;)n1 = r1, r1 = Dt(e1, r1), r1 = Et(e1, r1), r1 = gt(e1, r1);
    return r1 = Ct(e1, r1), r1 = bt(e1, r1), !1 !== r1 && vt(e1, r1);
}
function Ft(e1, t1) {
    let n1 = null, r1 = t1;
    for(; r1 !== n1;)n1 = r1, r1 = gt(e1, r1), r1 = Et(e1, r1), r1 = Ct(e1, r1), r1 = bt(e1, r1);
    return r1;
}
function xt(e1, t1, n1) {
    return Ft(e1, n1(t1));
}
function St2(e1, t1, n1) {
    let r1 = 0;
    for(let o1 = n1 = n1 || 0; o1 < e1.length; ++o1)"\t" === e1[o1] ? r1 = r1 + t1 - r1 % t1 : r1++;
    return r1;
}
function wt(e1, t1) {
    const n1 = e1.slice(1, -1), r1 = {
        quote: '"',
        regex: /"/g
    }, o1 = {
        quote: "'",
        regex: /'/g
    }, u1 = "'" === t1 ? o1 : r1, i1 = u1 === o1 ? r1 : o1;
    let a2 = u1.quote;
    if (n1.includes(u1.quote) || n1.includes(i1.quote)) {
        a2 = (n1.match(u1.regex) || []).length > (n1.match(i1.regex) || []).length ? i1.quote : u1.quote;
    }
    return a2;
}
function Tt(e1, t1, n1) {
    const r1 = '"' === t1 ? "'" : '"', o1 = e1.replace(/\\([\S\s])|(["'])/g, (e2, o2, u1)=>o2 === r1 ? o2 : u1 === t1 ? "\\" + u1 : u1 || (n1 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o2) ? o2 : "\\" + o2)
    );
    return t1 + o1 + t1;
}
function Bt(e1, t1) {
    (e1.comments || (e1.comments = [])).push(t1), t1.printed = !1, "JSXText" === e1.type && (t1.printed = !0);
}
var kt = {
    guessEndOfLine: function(e1) {
        const t1 = e1.indexOf("\r");
        return t1 >= 0 ? "\n" === e1.charAt(t1 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(e1) {
        switch(e1){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(e1, t1) {
        let n1;
        if ("\n" === t1) n1 = /\n/g;
        else if ("\r" === t1) n1 = /\r/g;
        else {
            if ("\r\n" !== t1) throw new Error('Unexpected "eol" '.concat(JSON.stringify(t1), "."));
            n1 = /\r\n/g;
        }
        const r1 = e1.match(n1);
        return r1 ? r1.length : 0;
    },
    normalizeEndOfLine: function(e1) {
        return e1.replace(/\r\n?/g, "\n");
    }
};
let jt;
function Vt(e1, t1, n1) {
    const r1 = "dedent" === t1.type ? e1.queue.slice(0, -1) : e1.queue.concat(t1);
    let o1 = "", u1 = 0, i1 = 0, a2 = 0;
    for (const e2 of r1)switch(e2.type){
        case "indent":
            c2(), n1.useTabs ? s2(1) : l2(n1.tabWidth);
            break;
        case "stringAlign":
            c2(), o1 += e2.n, u1 += e2.n.length;
            break;
        case "numberAlign":
            i1 += 1, a2 += e2.n;
            break;
        default:
            throw new Error("Unexpected type '".concat(e2.type, "'"));
    }
    return p2(), Object.assign({
    }, e1, {
        value: o1,
        length: u1,
        queue: r1
    });
    function s2(e3) {
        o1 += "\t".repeat(e3), u1 += n1.tabWidth * e3;
    }
    function l2(e3) {
        o1 += " ".repeat(e3), u1 += e3;
    }
    function c2() {
        n1.useTabs ? (function() {
            i1 > 0 && s2(i1);
            d2();
        })() : p2();
    }
    function p2() {
        a2 > 0 && l2(a2), d2();
    }
    function d2() {
        i1 = 0, a2 = 0;
    }
}
function $t(e1) {
    if (0 === e1.length) return 0;
    let t1 = 0;
    for(; e1.length > 0 && "string" == typeof e1[e1.length - 1] && e1[e1.length - 1].match(/^[\t ]*$/);)t1 += e1.pop().length;
    if (e1.length && "string" == typeof e1[e1.length - 1]) {
        const n1 = e1[e1.length - 1].replace(/[\t ]*$/, "");
        t1 += e1[e1.length - 1].length - n1.length, e1[e1.length - 1] = n1;
    }
    return t1;
}
const { literalline: Ut , concat: Jt  } = Z2, zt2 = {
};
function Gt(e1, t1, n1, r1) {
    const o1 = [
        e1
    ];
    for(; 0 !== o1.length;){
        const e2 = o1.pop();
        if (e2 !== zt2) {
            if (n1 && o1.push(e2, zt2), !t1 || !1 !== t1(e2)) {
                if ("concat" === e2.type || "fill" === e2.type) for(let t2 = e2.parts.length - 1; t2 >= 0; --t2)o1.push(e2.parts[t2]);
                else if ("if-break" === e2.type) e2.flatContents && o1.push(e2.flatContents), e2.breakContents && o1.push(e2.breakContents);
                else if ("group" === e2.type && e2.expandedStates) {
                    if (r1) for(let t3 = e2.expandedStates.length - 1; t3 >= 0; --t3)o1.push(e2.expandedStates[t3]);
                    else o1.push(e2.contents);
                } else e2.contents && o1.push(e2.contents);
            }
        } else n1(o1.pop());
    }
}
function Ht(e1, t1) {
    if ("concat" === e1.type || "fill" === e1.type) {
        const n1 = e1.parts.map((e2)=>Ht(e2, t1)
        );
        return t1(Object.assign({
        }, e1, {
            parts: n1
        }));
    }
    if ("if-break" === e1.type) {
        const n1 = e1.breakContents && Ht(e1.breakContents, t1), r1 = e1.flatContents && Ht(e1.flatContents, t1);
        return t1(Object.assign({
        }, e1, {
            breakContents: n1,
            flatContents: r1
        }));
    }
    if (e1.contents) {
        const n1 = Ht(e1.contents, t1);
        return t1(Object.assign({
        }, e1, {
            contents: n1
        }));
    }
    return t1(e1);
}
function Xt(e1, t1, n1) {
    let r1 = n1, o1 = !1;
    return Gt(e1, function(e2) {
        const n2 = t1(e2);
        if (((void 0) !== n2 && (o1 = !0, r1 = n2), o1)) return !1;
    }), r1;
}
function Yt(e1) {
    return "string" != typeof e1 && ("line" === e1.type || void 0);
}
function Kt(e1) {
    return !("group" !== e1.type || !e1.break) || (!("line" !== e1.type || !e1.hard) || ("break-parent" === e1.type || void 0));
}
function Qt2(e1) {
    if (e1.length > 0) {
        const t1 = e1[e1.length - 1];
        t1.expandedStates || (t1.break = !0);
    }
    return null;
}
function Zt(e1) {
    return "line" !== e1.type || e1.hard ? "if-break" === e1.type ? e1.flatContents || "" : e1 : e1.soft ? "" : " ";
}
function en(e1) {
    const t1 = [], n1 = e1.filter(Boolean);
    for(; 0 !== n1.length;){
        const e2 = n1.shift();
        e2 && ("concat" !== e2.type ? 0 === t1.length || "string" != typeof t1[t1.length - 1] || "string" != typeof e2 ? t1.push(e2) : t1[t1.length - 1] += e2 : n1.unshift(...e2.parts));
    }
    return t1;
}
function tn(e1) {
    if ("concat" === e1.type) {
        const t1 = [];
        for(let n1 = 0; n1 < e1.parts.length; ++n1){
            const r1 = e1.parts[n1];
            if ("string" != typeof r1 && "concat" === r1.type) t1.push(...tn(r1).parts);
            else {
                const e2 = tn(r1);
                "" !== e2 && t1.push(e2);
            }
        }
        return Object.assign({
        }, e1, {
            parts: t1
        });
    }
    return "if-break" === e1.type ? Object.assign({
    }, e1, {
        breakContents: null != e1.breakContents ? tn(e1.breakContents) : null,
        flatContents: null != e1.flatContents ? tn(e1.flatContents) : null
    }) : "group" === e1.type ? Object.assign({
    }, e1, {
        contents: tn(e1.contents),
        expandedStates: e1.expandedStates ? e1.expandedStates.map(tn) : e1.expandedStates
    }) : e1.contents ? Object.assign({
    }, e1, {
        contents: tn(e1.contents)
    }) : e1;
}
function nn(e1) {
    if ("string" == typeof e1) return JSON.stringify(e1);
    if ("line" === e1.type) return e1.literal ? "literalline" : e1.hard ? "hardline" : e1.soft ? "softline" : "line";
    if ("break-parent" === e1.type) return "breakParent";
    if ("trim" === e1.type) return "trim";
    if ("concat" === e1.type) return "[" + e1.parts.map(nn).join(", ") + "]";
    if ("indent" === e1.type) return "indent(" + nn(e1.contents) + ")";
    if ("align" === e1.type) return e1.n === -1 / 0 ? "dedentToRoot(" + nn(e1.contents) + ")" : e1.n < 0 ? "dedent(" + nn(e1.contents) + ")" : "root" === e1.n.type ? "markAsRoot(" + nn(e1.contents) + ")" : "align(" + JSON.stringify(e1.n) + ", " + nn(e1.contents) + ")";
    if ("if-break" === e1.type) return "ifBreak(" + nn(e1.breakContents) + (e1.flatContents ? ", " + nn(e1.flatContents) : "") + ")";
    if ("group" === e1.type) return e1.expandedStates ? "conditionalGroup([" + e1.expandedStates.map(nn).join(",") + "])" : (e1.break ? "wrappedGroup" : "group") + "(" + nn(e1.contents) + ")";
    if ("fill" === e1.type) return "fill(" + e1.parts.map(nn).join(", ") + ")";
    if ("line-suffix" === e1.type) return "lineSuffix(" + nn(e1.contents) + ")";
    if ("line-suffix-boundary" === e1.type) return "lineSuffixBoundary";
    throw new Error("Unknown doc type " + e1.type);
}
const on = ()=>!1
, un = ()=>""
;
var an = {
    existsSync: on,
    readFileSync: un
}, sn = Object.freeze({
    __proto__: null,
    existsSync: on,
    readFileSync: un,
    default: an
});
function ln(e1) {
    if ("string" != typeof e1) throw new TypeError("Path must be a string. Received " + JSON.stringify(e1));
}
function cn(e1, t1) {
    for(var n1, r1 = "", o1 = 0, u1 = -1, i1 = 0, a2 = 0; a2 <= e1.length; ++a2){
        if (a2 < e1.length) n1 = e1.charCodeAt(a2);
        else {
            if (47 === n1) break;
            n1 = 47;
        }
        if (47 === n1) {
            if (u1 === a2 - 1 || 1 === i1) ;
            else if (u1 !== a2 - 1 && 2 === i1) {
                if (r1.length < 2 || 2 !== o1 || 46 !== r1.charCodeAt(r1.length - 1) || 46 !== r1.charCodeAt(r1.length - 2)) {
                    if (r1.length > 2) {
                        var s2 = r1.lastIndexOf("/");
                        if (s2 !== r1.length - 1) {
                            -1 === s2 ? (r1 = "", o1 = 0) : o1 = (r1 = r1.slice(0, s2)).length - 1 - r1.lastIndexOf("/"), u1 = a2, i1 = 0;
                            continue;
                        }
                    } else if (2 === r1.length || 1 === r1.length) {
                        r1 = "", o1 = 0, u1 = a2, i1 = 0;
                        continue;
                    }
                }
                t1 && (r1.length > 0 ? r1 += "/.." : r1 = "..", o1 = 2);
            } else r1.length > 0 ? r1 += "/" + e1.slice(u1 + 1, a2) : r1 = e1.slice(u1 + 1, a2), o1 = a2 - u1 - 1;
            u1 = a2, i1 = 0;
        } else 46 === n1 && -1 !== i1 ? ++i1 : i1 = -1;
    }
    return r1;
}
function bn(e1, t1, n1, r1, o1) {
    var u1, i1, a2 = 8 * o1 - r1 - 1, s2 = (1 << a2) - 1, l2 = s2 >> 1, c2 = -7, p2 = n1 ? o1 - 1 : 0, d2 = n1 ? -1 : 1, f1 = e1[t1 + p2];
    for(p2 += d2, u1 = f1 & (1 << -c2) - 1, f1 >>= -c2, c2 += a2; c2 > 0; u1 = 256 * u1 + e1[t1 + p2], p2 += d2, c2 -= 8);
    for(i1 = u1 & (1 << -c2) - 1, u1 >>= -c2, c2 += r1; c2 > 0; i1 = 256 * i1 + e1[t1 + p2], p2 += d2, c2 -= 8);
    if (0 === u1) u1 = 1 - l2;
    else {
        if (u1 === s2) return i1 ? NaN : 1 / 0 * (f1 ? -1 : 1);
        i1 += Math.pow(2, r1), u1 -= l2;
    }
    return (f1 ? -1 : 1) * i1 * Math.pow(2, u1 - r1);
}
function vn(e1, t1, n1, r1, o1, u1) {
    var i1, a2, s2, l2 = 8 * u1 - o1 - 1, c2 = (1 << l2) - 1, p2 = c2 >> 1, d2 = 23 === o1 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f1 = r1 ? 0 : u1 - 1, h1 = r1 ? 1 : -1, m1 = t1 < 0 || 0 === t1 && 1 / t1 < 0 ? 1 : 0;
    for(t1 = Math.abs(t1), isNaN(t1) || t1 === 1 / 0 ? (a2 = isNaN(t1) ? 1 : 0, i1 = c2) : (i1 = Math.floor(Math.log(t1) / Math.LN2), t1 * (s2 = Math.pow(2, -i1)) < 1 && (i1--, s2 *= 2), (t1 += i1 + p2 >= 1 ? d2 / s2 : d2 * Math.pow(2, 1 - p2)) * s2 >= 2 && (i1++, s2 /= 2), i1 + p2 >= c2 ? (a2 = 0, i1 = c2) : i1 + p2 >= 1 ? (a2 = (t1 * s2 - 1) * Math.pow(2, o1), i1 += p2) : (a2 = t1 * Math.pow(2, p2 - 1) * Math.pow(2, o1), i1 = 0)); o1 >= 8; e1[n1 + f1] = 255 & a2, f1 += h1, a2 /= 256, o1 -= 8);
    for(i1 = i1 << o1 | a2, l2 += o1; l2 > 0; e1[n1 + f1] = 255 & i1, f1 += h1, i1 /= 256, l2 -= 8);
    e1[n1 + f1 - h1] |= 128 * m1;
}
var An = {
}.toString, Fn = Array.isArray || function(e1) {
    return "[object Array]" == An.call(e1);
};
function Bn(e1) {
    if ("number" != typeof e1) throw new TypeError('"size" argument must be a number');
    if (e1 < 0) throw new RangeError('"size" argument must not be negative');
}
function On(e1) {
    return !(null == e1 || !e1._isBuffer);
}
function Mn(e1, t1, n1) {
    var r1 = e1[t1];
    e1[t1] = e1[n1], e1[n1] = r1;
}
function _n(e1, t1, n1, r1, o1) {
    var u1, i1 = 1, a2 = e1.length, s2 = t1.length;
    if ((void 0) !== r1 && ("ucs2" === (r1 = String(r1).toLowerCase()) || "ucs-2" === r1 || "utf16le" === r1 || "utf-16le" === r1)) {
        if (e1.length < 2 || t1.length < 2) return -1;
        i1 = 2, a2 /= 2, s2 /= 2, n1 /= 2;
    }
    function l2(e2, t2) {
        return 1 === i1 ? e2[t2] : e2.readUInt16BE(t2 * i1);
    }
    if (o1) {
        var c2 = -1;
        for(u1 = n1; u1 < a2; u1++)if (l2(e1, u1) === l2(t1, -1 === c2 ? 0 : u1 - c2)) {
            if (-1 === c2 && (c2 = u1), u1 - c2 + 1 === s2) return c2 * i1;
        } else -1 !== c2 && (u1 -= u1 - c2), c2 = -1;
    } else for(n1 + s2 > a2 && (n1 = a2 - s2), u1 = n1; u1 >= 0; u1--){
        for(var p2 = !0, d2 = 0; d2 < s2; d2++)if (l2(e1, u1 + d2) !== l2(t1, d2)) {
            p2 = !1;
            break;
        }
        if (p2) return u1;
    }
    return -1;
}
function Rn(e1, t1, n1, r1) {
    n1 = Number(n1) || 0;
    var o1 = e1.length - n1;
    r1 ? (r1 = Number(r1)) > o1 && (r1 = o1) : r1 = o1;
    var u1 = t1.length;
    if (u1 % 2 != 0) throw new TypeError("Invalid hex string");
    r1 > u1 / 2 && (r1 = u1 / 2);
    for(var i1 = 0; i1 < r1; ++i1){
        var a2 = parseInt(t1.substr(2 * i1, 2), 16);
        if (isNaN(a2)) return i1;
        e1[n1 + i1] = a2;
    }
    return i1;
}
function zn(e1, t1, n1) {
    n1 = Math.min(e1.length, n1);
    for(var r1 = [], o1 = t1; o1 < n1;){
        var u1, i1, a2, s2, l2 = e1[o1], c2 = null, p2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
        if (o1 + p2 <= n1) switch(p2){
            case 1:
                l2 < 128 && (c2 = l2);
                break;
            case 2:
                128 == (192 & (u1 = e1[o1 + 1])) && (s2 = (31 & l2) << 6 | 63 & u1) > 127 && (c2 = s2);
                break;
            case 3:
                u1 = e1[o1 + 1], i1 = e1[o1 + 2], 128 == (192 & u1) && 128 == (192 & i1) && (s2 = (15 & l2) << 12 | (63 & u1) << 6 | 63 & i1) > 2047 && (s2 < 55296 || s2 > 57343) && (c2 = s2);
                break;
            case 4:
                u1 = e1[o1 + 1], i1 = e1[o1 + 2], a2 = e1[o1 + 3], 128 == (192 & u1) && 128 == (192 & i1) && 128 == (192 & a2) && (s2 = (15 & l2) << 18 | (63 & u1) << 12 | (63 & i1) << 6 | 63 & a2) > 65535 && s2 < 1114112 && (c2 = s2);
        }
        null === c2 ? (c2 = 65533, p2 = 1) : c2 > 65535 && (c2 -= 65536, r1.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r1.push(c2), o1 += p2;
    }
    return (function(e2) {
        var t2 = e2.length;
        if (t2 <= 4096) return String.fromCharCode.apply(String, e2);
        var n2 = "", r2 = 0;
        for(; r2 < t2;)n2 += String.fromCharCode.apply(String, e2.slice(r2, r2 += 4096));
        return n2;
    })(r1);
}
function Gn(e1, t1, n1) {
    var r1 = "";
    n1 = Math.min(e1.length, n1);
    for(var o1 = t1; o1 < n1; ++o1)r1 += String.fromCharCode(127 & e1[o1]);
    return r1;
}
function Hn(e1, t1, n1) {
    var r1 = "";
    n1 = Math.min(e1.length, n1);
    for(var o1 = t1; o1 < n1; ++o1)r1 += String.fromCharCode(e1[o1]);
    return r1;
}
function Yn(e1, t1, n1) {
    for(var r1 = e1.slice(t1, n1), o1 = "", u1 = 0; u1 < r1.length; u1 += 2)o1 += String.fromCharCode(r1[u1] + 256 * r1[u1 + 1]);
    return o1;
}
function Kn(e1, t1, n1) {
    if (e1 % 1 != 0 || e1 < 0) throw new RangeError("offset is not uint");
    if (e1 + t1 > n1) throw new RangeError("Trying to access beyond buffer length");
}
function Qn(e1, t1, n1, r1, o1, u1) {
    if (!On(e1)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t1 > o1 || t1 < u1) throw new RangeError('"value" argument is out of bounds');
    if (n1 + r1 > e1.length) throw new RangeError("Index out of range");
}
function Zn(e1, t1, n1, r1) {
    t1 < 0 && (t1 = 65535 + t1 + 1);
    for(var o1 = 0, u1 = Math.min(e1.length - n1, 2); o1 < u1; ++o1)e1[n1 + o1] = (t1 & 255 << 8 * (r1 ? o1 : 1 - o1)) >>> 8 * (r1 ? o1 : 1 - o1);
}
function er(e1, t1, n1, r1) {
    t1 < 0 && (t1 = 4294967295 + t1 + 1);
    for(var o1 = 0, u1 = Math.min(e1.length - n1, 4); o1 < u1; ++o1)e1[n1 + o1] = t1 >>> 8 * (r1 ? o1 : 3 - o1) & 255;
}
function tr(e1, t1, n1, r1, o1, u1) {
    if (n1 + r1 > e1.length) throw new RangeError("Index out of range");
    if (n1 < 0) throw new RangeError("Index out of range");
}
function nr(e1, t1, n1, r1, o1) {
    return o1 || tr(e1, 0, n1, 4), vn(e1, t1, n1, r1, 23, 4), n1 + 4;
}
function rr(e1, t1, n1, r1, o1) {
    return o1 || tr(e1, 0, n1, 8), vn(e1, t1, n1, r1, 52, 8), n1 + 8;
}
var or = /[^+\/0-9A-Za-z-_]/g;
function ur(e1) {
    return e1 < 16 ? "0" + e1.toString(16) : e1.toString(16);
}
function ir(e1, t1) {
    var n1;
    t1 = t1 || 1 / 0;
    for(var r1 = e1.length, o1 = null, u1 = [], i1 = 0; i1 < r1; ++i1){
        if ((n1 = e1.charCodeAt(i1)) > 55295 && n1 < 57344) {
            if (!o1) {
                if (n1 > 56319) {
                    (t1 -= 3) > -1 && u1.push(239, 191, 189);
                    continue;
                }
                if (i1 + 1 === r1) {
                    (t1 -= 3) > -1 && u1.push(239, 191, 189);
                    continue;
                }
                o1 = n1;
                continue;
            }
            if (n1 < 56320) {
                (t1 -= 3) > -1 && u1.push(239, 191, 189), o1 = n1;
                continue;
            }
            n1 = 65536 + (o1 - 55296 << 10 | n1 - 56320);
        } else o1 && (t1 -= 3) > -1 && u1.push(239, 191, 189);
        if (o1 = null, n1 < 128) {
            if ((t1 -= 1) < 0) break;
            u1.push(n1);
        } else if (n1 < 2048) {
            if ((t1 -= 2) < 0) break;
            u1.push(n1 >> 6 | 192, 63 & n1 | 128);
        } else if (n1 < 65536) {
            if ((t1 -= 3) < 0) break;
            u1.push(n1 >> 12 | 224, n1 >> 6 & 63 | 128, 63 & n1 | 128);
        } else {
            if (!(n1 < 1114112)) throw new Error("Invalid code point");
            if ((t1 -= 4) < 0) break;
            u1.push(n1 >> 18 | 240, n1 >> 12 & 63 | 128, n1 >> 6 & 63 | 128, 63 & n1 | 128);
        }
    }
    return u1;
}
function sr(e1, t1, n1, r1) {
    for(var o1 = 0; o1 < r1 && !(o1 + n1 >= t1.length || o1 >= e1.length); ++o1)t1[o1 + n1] = e1[o1];
    return o1;
}
function lr(e1) {
    return !!e1.constructor && "function" == typeof e1.constructor.isBuffer && e1.constructor.isBuffer(e1);
}
var cr = _e(sn);
var dr = function(e1) {
    for(var t1 = -1, n1 = null == e1 ? 0 : e1.length, r1 = {
    }; (++t1) < n1;){
        var o1 = e1[t1];
        r1[o1[0]] = o1[1];
    }
    return r1;
};
var Dr = function(e1, t1) {
    return (Dr = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(e2, t2) {
        e2.__proto__ = t2;
    } || function(e2, t2) {
        for(var n1 in t2)t2.hasOwnProperty(n1) && (e2[n1] = t2[n1]);
    })(e1, t1);
};
var yr = function() {
    return (yr = Object.assign || function(e1) {
        for(var t1, n1 = 1, r1 = arguments.length; n1 < r1; n1++)for(var o1 in t1 = arguments[n1])Object.prototype.hasOwnProperty.call(t1, o1) && (e1[o1] = t1[o1]);
        return e1;
    }).apply(this, arguments);
};
function Er(e1) {
    var t1 = "function" == typeof Symbol && Symbol.iterator, n1 = t1 && e1[t1], r1 = 0;
    if (n1) return n1.call(e1);
    if (e1 && "number" == typeof e1.length) return {
        next: function() {
            return e1 && r1 >= e1.length && (e1 = void 0), {
                value: e1 && e1[r1++],
                done: !e1
            };
        }
    };
    throw new TypeError(t1 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Cr(e1, t1) {
    var n1 = "function" == typeof Symbol && e1[Symbol.iterator];
    if (!n1) return e1;
    var r1, o1, u1 = n1.call(e1), i1 = [];
    try {
        for(; ((void 0) === t1 || (t1--) > 0) && !(r1 = u1.next()).done;)i1.push(r1.value);
    } catch (e) {
        o1 = {
            error: e
        };
    } finally{
        try {
            r1 && !r1.done && (n1 = u1.return) && n1.call(u1);
        } finally{
            if (o1) throw o1.error;
        }
    }
    return i1;
}
function br(e1) {
    return this instanceof br ? (this.v = e1, this) : new br(e1);
}
var vr = Object.freeze({
    __proto__: null,
    __extends: function(e1, t1) {
        function n1() {
            this.constructor = e1;
        }
        Dr(e1, t1), e1.prototype = null === t1 ? Object.create(t1) : (n1.prototype = t1.prototype, new n1);
    },
    get __assign () {
        return yr;
    },
    __rest: function(e1, t1) {
        var n1 = {
        };
        for(var r1 in e1)Object.prototype.hasOwnProperty.call(e1, r1) && t1.indexOf(r1) < 0 && (n1[r1] = e1[r1]);
        if (null != e1 && "function" == typeof Object.getOwnPropertySymbols) {
            var o1 = 0;
            for(r1 = Object.getOwnPropertySymbols(e1); o1 < r1.length; o1++)t1.indexOf(r1[o1]) < 0 && Object.prototype.propertyIsEnumerable.call(e1, r1[o1]) && (n1[r1[o1]] = e1[r1[o1]]);
        }
        return n1;
    },
    __decorate: function(e1, t1, n1, r1) {
        var o1, u1 = arguments.length, i1 = u1 < 3 ? t1 : null === r1 ? r1 = Object.getOwnPropertyDescriptor(t1, n1) : r1;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i1 = Reflect.decorate(e1, t1, n1, r1);
        else for(var a2 = e1.length - 1; a2 >= 0; a2--)(o1 = e1[a2]) && (i1 = (u1 < 3 ? o1(i1) : u1 > 3 ? o1(t1, n1, i1) : o1(t1, n1)) || i1);
        return (u1 > 3 && i1 && Object.defineProperty(t1, n1, i1), i1);
    },
    __param: function(e1, t1) {
        return function(n1, r1) {
            t1(n1, r1, e1);
        };
    },
    __metadata: function(e1, t1) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e1, t1);
    },
    __awaiter: function(e1, t1, n1, r1) {
        return new (n1 || (n1 = Promise))(function(o1, u1) {
            function i1(e2) {
                try {
                    s2(r1.next(e2));
                } catch (e) {
                    u1(e);
                }
            }
            function a2(e2) {
                try {
                    s2(r1.throw(e2));
                } catch (e) {
                    u1(e);
                }
            }
            function s2(e2) {
                var t2;
                e2.done ? o1(e2.value) : (t2 = e2.value, t2 instanceof n1 ? t2 : new n1(function(e3) {
                    e3(t2);
                })).then(i1, a2);
            }
            s2((r1 = r1.apply(e1, t1 || [])).next());
        });
    },
    __generator: function(e1, t1) {
        var n1, r1, o1, u1, i1 = {
            label: 0,
            sent: function() {
                if (1 & o1[0]) throw o1[1];
                return o1[1];
            },
            trys: [],
            ops: []
        };
        return (u1 = {
            next: a2(0),
            throw: a2(1),
            return: a2(2)
        }, "function" == typeof Symbol && (u1[Symbol.iterator] = function() {
            return this;
        }), u1);
        function a2(u2) {
            return function(a3) {
                return function(u3) {
                    if (n1) throw new TypeError("Generator is already executing.");
                    for(; i1;)try {
                        if (n1 = 1, r1 && (o1 = 2 & u3[0] ? r1.return : u3[0] ? r1.throw || ((o1 = r1.return) && o1.call(r1), 0) : r1.next) && !(o1 = o1.call(r1, u3[1])).done) return o1;
                        switch(r1 = 0, o1 && (u3 = [
                            2 & u3[0],
                            o1.value
                        ]), u3[0]){
                            case 0:
                            case 1:
                                o1 = u3;
                                break;
                            case 4:
                                return i1.label++, {
                                    value: u3[1],
                                    done: !1
                                };
                            case 5:
                                i1.label++, r1 = u3[1], u3 = [
                                    0
                                ];
                                continue;
                            case 7:
                                u3 = i1.ops.pop(), i1.trys.pop();
                                continue;
                            default:
                                if (!(o1 = i1.trys, (o1 = o1.length > 0 && o1[o1.length - 1]) || 6 !== u3[0] && 2 !== u3[0])) {
                                    i1 = 0;
                                    continue;
                                }
                                if (3 === u3[0] && (!o1 || u3[1] > o1[0] && u3[1] < o1[3])) {
                                    i1.label = u3[1];
                                    break;
                                }
                                if (6 === u3[0] && i1.label < o1[1]) {
                                    i1.label = o1[1], o1 = u3;
                                    break;
                                }
                                if (o1 && i1.label < o1[2]) {
                                    i1.label = o1[2], i1.ops.push(u3);
                                    break;
                                }
                                o1[2] && i1.ops.pop(), i1.trys.pop();
                                continue;
                        }
                        u3 = t1.call(e1, i1);
                    } catch (e) {
                        u3 = [
                            6,
                            e
                        ], r1 = 0;
                    } finally{
                        n1 = o1 = 0;
                    }
                    if (5 & u3[0]) throw u3[1];
                    return {
                        value: u3[0] ? u3[1] : void 0,
                        done: !0
                    };
                }([
                    u2,
                    a3
                ]);
            };
        }
    },
    __createBinding: function(e1, t1, n1, r1) {
        (void 0) === r1 && (r1 = n1), e1[r1] = t1[n1];
    },
    __exportStar: function(e1, t1) {
        for(var n1 in e1)"default" === n1 || t1.hasOwnProperty(n1) || (t1[n1] = e1[n1]);
    },
    __values: Er,
    __read: Cr,
    __spread: function() {
        for(var e1 = [], t1 = 0; t1 < arguments.length; t1++)e1 = e1.concat(Cr(arguments[t1]));
        return e1;
    },
    __spreadArrays: function() {
        for(var e1 = 0, t1 = 0, n1 = arguments.length; t1 < n1; t1++)e1 += arguments[t1].length;
        var r1 = Array(e1), o1 = 0;
        for(t1 = 0; t1 < n1; t1++)for(var u1 = arguments[t1], i1 = 0, a2 = u1.length; i1 < a2; (i1++, o1++))r1[o1] = u1[i1];
        return r1;
    },
    __await: br,
    __asyncGenerator: function(e1, t1, n1) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var r1, o1 = n1.apply(e1, t1 || []), u1 = [];
        return (r1 = {
        }, i2("next"), i2("throw"), i2("return"), r1[Symbol.asyncIterator] = function() {
            return this;
        }, r1);
        function i2(e2) {
            o1[e2] && (r1[e2] = function(t2) {
                return new Promise(function(n2, r2) {
                    u1.push([
                        e2,
                        t2,
                        n2,
                        r2
                    ]) > 1 || a2(e2, t2);
                });
            });
        }
        function a2(e2, t2) {
            try {
                (n3 = o1[e2](t2)).value instanceof br ? Promise.resolve(n3.value.v).then(s2, l2) : c2(u1[0][2], n3);
            } catch (e) {
                c2(u1[0][3], e);
            }
            var n3;
        }
        function s2(e2) {
            a2("next", e2);
        }
        function l2(e2) {
            a2("throw", e2);
        }
        function c2(e2, t2) {
            e2(t2), u1.shift(), u1.length && a2(u1[0][0], u1[0][1]);
        }
    },
    __asyncDelegator: function(e1) {
        var t1, n1;
        return (t1 = {
        }, r2("next"), r2("throw", function(e2) {
            throw e2;
        }), r2("return"), t1[Symbol.iterator] = function() {
            return this;
        }, t1);
        function r2(r3, o1) {
            t1[r3] = e1[r3] ? function(t2) {
                return (n1 = !n1) ? {
                    value: br(e1[r3](t2)),
                    done: "return" === r3
                } : o1 ? o1(t2) : t2;
            } : o1;
        }
    },
    __asyncValues: function(e1) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var t1, n1 = e1[Symbol.asyncIterator];
        return n1 ? n1.call(e1) : (e1 = Er(e1), t1 = {
        }, r2("next"), r2("throw"), r2("return"), t1[Symbol.asyncIterator] = function() {
            return this;
        }, t1);
        function r2(n3) {
            t1[n3] = e1[n3] && function(t2) {
                return new Promise(function(r3, o1) {
                    (function(e2, t3, n4, r4) {
                        Promise.resolve(r4).then(function(t4) {
                            e2({
                                value: t4,
                                done: n4
                            });
                        }, t3);
                    })(r3, o1, (t2 = e1[n3](t2)).done, t2.value);
                });
            };
        }
    },
    __makeTemplateObject: function(e1, t1) {
        return (Object.defineProperty ? Object.defineProperty(e1, "raw", {
            value: t1
        }) : e1.raw = t1, e1);
    },
    __importStar: function(e1) {
        if (e1 && e1.__esModule) return e1;
        var t1 = {
        };
        if (null != e1) for(var n1 in e1)Object.hasOwnProperty.call(e1, n1) && (t1[n1] = e1[n1]);
        return (t1.default = e1, t1);
    },
    __importDefault: function(e1) {
        return e1 && e1.__esModule ? e1 : {
            default: e1
        };
    },
    __classPrivateFieldGet: function(e1, t1) {
        if (!t1.has(e1)) throw new TypeError("attempted to get private field on non-instance");
        return t1.get(e1);
    },
    __classPrivateFieldSet: function(e1, t1, n1) {
        if (!t1.has(e1)) throw new TypeError("attempted to set private field on non-instance");
        return (t1.set(e1, n1), n1);
    }
}), Ar = je(function(e1, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), t1.apiDescriptor = {
        key: (e2)=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2)
        ,
        value (e) {
            if (null === e || "object" != typeof e) return JSON.stringify(e);
            if (Array.isArray(e)) return "[".concat(e.map((e3)=>t1.apiDescriptor.value(e3)
            ).join(", "), "]");
            const n1 = Object.keys(e);
            return 0 === n1.length ? "{}" : "{ ".concat(n1.map((n3)=>"".concat(t1.apiDescriptor.key(n3), ": ").concat(t1.apiDescriptor.value(e[n3]))
            ).join(", "), " }");
        },
        pair: ({ key: e3 , value: n1  })=>t1.apiDescriptor.value({
                [e3]: n1
            })
    };
}), Fr = je(function(e1, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), vr.__exportStar(Ar, t1);
}), xr = /[|\\{}()[\]^$+*?.]/g, Sr = function(e1) {
    if ("string" != typeof e1) throw new TypeError("Expected a string");
    return e1.replace(xr, "\\$&");
}, wr = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, Tr = je(function(e1) {
    var t1 = {
    };
    for(var n1 in wr)wr.hasOwnProperty(n1) && (t1[wr[n1]] = n1);
    var r2 = e1.exports = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    for(var o1 in r2)if (r2.hasOwnProperty(o1)) {
        if (!("channels" in r2[o1])) throw new Error("missing channels property: " + o1);
        if (!("labels" in r2[o1])) throw new Error("missing channel labels property: " + o1);
        if (r2[o1].labels.length !== r2[o1].channels) throw new Error("channel and label counts mismatch: " + o1);
        var u1 = r2[o1].channels, i2 = r2[o1].labels;
        delete r2[o1].channels, delete r2[o1].labels, Object.defineProperty(r2[o1], "channels", {
            value: u1
        }), Object.defineProperty(r2[o1], "labels", {
            value: i2
        });
    }
    r2.rgb.hsl = function(e3) {
        var t2, n3, r3 = e3[0] / 255, o2 = e3[1] / 255, u1 = e3[2] / 255, i2 = Math.min(r3, o2, u1), a2 = Math.max(r3, o2, u1), s2 = a2 - i2;
        return a2 === i2 ? t2 = 0 : r3 === a2 ? t2 = (o2 - u1) / s2 : o2 === a2 ? t2 = 2 + (u1 - r3) / s2 : u1 === a2 && (t2 = 4 + (r3 - o2) / s2), (t2 = Math.min(60 * t2, 360)) < 0 && (t2 += 360), n3 = (i2 + a2) / 2, [
            t2,
            100 * (a2 === i2 ? 0 : n3 <= 0.5 ? s2 / (a2 + i2) : s2 / (2 - a2 - i2)),
            100 * n3
        ];
    }, r2.rgb.hsv = function(e3) {
        var t2, n3, r3, o2, u1, i2 = e3[0] / 255, a2 = e3[1] / 255, s2 = e3[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e4) {
            return (l2 - e4) / 6 / c2 + 0.5;
        };
        return 0 === c2 ? o2 = u1 = 0 : (u1 = c2 / l2, t2 = p2(i2), n3 = p2(a2), r3 = p2(s2), i2 === l2 ? o2 = r3 - n3 : a2 === l2 ? o2 = 1 / 3 + t2 - r3 : s2 === l2 && (o2 = 2 / 3 + n3 - t2), o2 < 0 ? o2 += 1 : o2 > 1 && (o2 -= 1)), [
            360 * o2,
            100 * u1,
            100 * l2
        ];
    }, r2.rgb.hwb = function(e3) {
        var t2 = e3[0], n3 = e3[1], o2 = e3[2];
        return [
            r2.rgb.hsl(e3)[0],
            100 * (1 / 255 * Math.min(t2, Math.min(n3, o2))),
            100 * (o2 = 1 - 1 / 255 * Math.max(t2, Math.max(n3, o2)))
        ];
    }, r2.rgb.cmyk = function(e3) {
        var t2, n3 = e3[0] / 255, r3 = e3[1] / 255, o2 = e3[2] / 255;
        return [
            100 * ((1 - n3 - (t2 = Math.min(1 - n3, 1 - r3, 1 - o2))) / (1 - t2) || 0),
            100 * ((1 - r3 - t2) / (1 - t2) || 0),
            100 * ((1 - o2 - t2) / (1 - t2) || 0),
            100 * t2
        ];
    }, r2.rgb.keyword = function(e3) {
        var n3 = t1[e3];
        if (n3) return n3;
        var r3, o2, u1, i2 = 1 / 0;
        for(var a2 in wr)if (wr.hasOwnProperty(a2)) {
            var s2 = wr[a2], l2 = (o2 = e3, u1 = s2, Math.pow(o2[0] - u1[0], 2) + Math.pow(o2[1] - u1[1], 2) + Math.pow(o2[2] - u1[2], 2));
            l2 < i2 && (i2 = l2, r3 = a2);
        }
        return r3;
    }, r2.keyword.rgb = function(e3) {
        return wr[e3];
    }, r2.rgb.xyz = function(e3) {
        var t2 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
        return [
            100 * (0.4124 * (t2 = t2 > 0.04045 ? Math.pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)),
            100 * (0.2126 * t2 + 0.7152 * n3 + 0.0722 * r3),
            100 * (0.0193 * t2 + 0.1192 * n3 + 0.9505 * r3)
        ];
    }, r2.rgb.lab = function(e3) {
        var t2 = r2.rgb.xyz(e3), n3 = t2[0], o2 = t2[1], u1 = t2[2];
        return o2 /= 100, u1 /= 108.883, n3 = (n3 /= 95.047) > 0.008856 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [
            116 * (o2 = o2 > 0.008856 ? Math.pow(o2, 1 / 3) : 7.787 * o2 + 16 / 116) - 16,
            500 * (n3 - o2),
            200 * (o2 - (u1 = u1 > 0.008856 ? Math.pow(u1, 1 / 3) : 7.787 * u1 + 16 / 116))
        ];
    }, r2.hsl.rgb = function(e3) {
        var t2, n3, r3, o2, u1, i2 = e3[0] / 360, a2 = e3[1] / 100, s2 = e3[2] / 100;
        if (0 === a2) return [
            u1 = 255 * s2,
            u1,
            u1
        ];
        t2 = 2 * s2 - (n3 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2), o2 = [
            0,
            0,
            0
        ];
        for(var l2 = 0; l2 < 3; l2++)(r3 = i2 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, u1 = 6 * r3 < 1 ? t2 + 6 * (n3 - t2) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t2 + (n3 - t2) * (2 / 3 - r3) * 6 : t2, o2[l2] = 255 * u1;
        return o2;
    }, r2.hsl.hsv = function(e3) {
        var t2 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, o2 = n3, u1 = Math.max(r3, 0.01);
        return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, o2 *= u1 <= 1 ? u1 : 2 - u1, [
            t2,
            100 * (0 === r3 ? 2 * o2 / (u1 + o2) : 2 * n3 / (r3 + n3)),
            100 * ((r3 + n3) / 2)
        ];
    }, r2.hsv.rgb = function(e3) {
        var t2 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, o2 = Math.floor(t2) % 6, u1 = t2 - Math.floor(t2), i2 = 255 * r3 * (1 - n3), a2 = 255 * r3 * (1 - n3 * u1), s2 = 255 * r3 * (1 - n3 * (1 - u1));
        switch(r3 *= 255, o2){
            case 0:
                return [
                    r3,
                    s2,
                    i2
                ];
            case 1:
                return [
                    a2,
                    r3,
                    i2
                ];
            case 2:
                return [
                    i2,
                    r3,
                    s2
                ];
            case 3:
                return [
                    i2,
                    a2,
                    r3
                ];
            case 4:
                return [
                    s2,
                    i2,
                    r3
                ];
            case 5:
                return [
                    r3,
                    i2,
                    a2
                ];
        }
    }, r2.hsv.hsl = function(e3) {
        var t2, n3, r3, o2 = e3[0], u1 = e3[1] / 100, i2 = e3[2] / 100, a2 = Math.max(i2, 0.01);
        return r3 = (2 - u1) * i2, n3 = u1 * a2, [
            o2,
            100 * (n3 = (n3 /= (t2 = (2 - u1) * a2) <= 1 ? t2 : 2 - t2) || 0),
            100 * (r3 /= 2)
        ];
    }, r2.hwb.rgb = function(e3) {
        var t2, n3, r3, o2, u1, i2, a2, s2 = e3[0] / 360, l2 = e3[1] / 100, c2 = e3[2] / 100, p2 = l2 + c2;
        switch(p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t2 = Math.floor(6 * s2)), 0 != (1 & t2) && (r3 = 1 - r3), o2 = l2 + r3 * ((n3 = 1 - c2) - l2), t2){
            default:
            case 6:
            case 0:
                u1 = n3, i2 = o2, a2 = l2;
                break;
            case 1:
                u1 = o2, i2 = n3, a2 = l2;
                break;
            case 2:
                u1 = l2, i2 = n3, a2 = o2;
                break;
            case 3:
                u1 = l2, i2 = o2, a2 = n3;
                break;
            case 4:
                u1 = o2, i2 = l2, a2 = n3;
                break;
            case 5:
                u1 = n3, i2 = l2, a2 = o2;
        }
        return [
            255 * u1,
            255 * i2,
            255 * a2
        ];
    }, r2.cmyk.rgb = function(e3) {
        var t2 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, o2 = e3[3] / 100;
        return [
            255 * (1 - Math.min(1, t2 * (1 - o2) + o2)),
            255 * (1 - Math.min(1, n3 * (1 - o2) + o2)),
            255 * (1 - Math.min(1, r3 * (1 - o2) + o2))
        ];
    }, r2.xyz.rgb = function(e3) {
        var t2, n3, r3, o2 = e3[0] / 100, u1 = e3[1] / 100, i2 = e3[2] / 100;
        return n3 = -0.9689 * o2 + 1.8758 * u1 + 0.0415 * i2, r3 = 0.0557 * o2 + -0.204 * u1 + 1.057 * i2, t2 = (t2 = 3.2406 * o2 + -1.5372 * u1 + -0.4986 * i2) > 0.0031308 ? 1.055 * Math.pow(t2, 1 / 2.4) - 0.055 : 12.92 * t2, n3 = n3 > 0.0031308 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 0.0031308 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [
            255 * (t2 = Math.min(Math.max(0, t2), 1)),
            255 * (n3 = Math.min(Math.max(0, n3), 1)),
            255 * (r3 = Math.min(Math.max(0, r3), 1))
        ];
    }, r2.xyz.lab = function(e3) {
        var t2 = e3[0], n3 = e3[1], r3 = e3[2];
        return n3 /= 100, r3 /= 108.883, t2 = (t2 /= 95.047) > 0.008856 ? Math.pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, [
            116 * (n3 = n3 > 0.008856 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16,
            500 * (t2 - n3),
            200 * (n3 - (r3 = r3 > 0.008856 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))
        ];
    }, r2.lab.xyz = function(e3) {
        var t2, n3, r3, o2 = e3[0];
        t2 = e3[1] / 500 + (n3 = (o2 + 16) / 116), r3 = n3 - e3[2] / 200;
        var u1 = Math.pow(n3, 3), i2 = Math.pow(t2, 3), a2 = Math.pow(r3, 3);
        return n3 = u1 > 0.008856 ? u1 : (n3 - 16 / 116) / 7.787, t2 = i2 > 0.008856 ? i2 : (t2 - 16 / 116) / 7.787, r3 = a2 > 0.008856 ? a2 : (r3 - 16 / 116) / 7.787, [
            t2 *= 95.047,
            n3 *= 100,
            r3 *= 108.883
        ];
    }, r2.lab.lch = function(e3) {
        var t2, n3 = e3[0], r3 = e3[1], o2 = e3[2];
        return (t2 = 360 * Math.atan2(o2, r3) / 2 / Math.PI) < 0 && (t2 += 360), [
            n3,
            Math.sqrt(r3 * r3 + o2 * o2),
            t2
        ];
    }, r2.lch.lab = function(e3) {
        var t2, n3 = e3[0], r3 = e3[1];
        return t2 = e3[2] / 360 * 2 * Math.PI, [
            n3,
            r3 * Math.cos(t2),
            r3 * Math.sin(t2)
        ];
    }, r2.rgb.ansi16 = function(e3) {
        var t2 = e3[0], n3 = e3[1], o2 = e3[2], u1 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e3)[2];
        if (0 === (u1 = Math.round(u1 / 50))) return 30;
        var i2 = 30 + (Math.round(o2 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t2 / 255));
        return 2 === u1 && (i2 += 60), i2;
    }, r2.hsv.ansi16 = function(e3) {
        return r2.rgb.ansi16(r2.hsv.rgb(e3), e3[2]);
    }, r2.rgb.ansi256 = function(e3) {
        var t2 = e3[0], n3 = e3[1], r3 = e3[2];
        return t2 === n3 && n3 === r3 ? t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e3) {
        var t2 = e3 % 10;
        if (0 === t2 || 7 === t2) return e3 > 50 && (t2 += 3.5), [
            t2 = t2 / 10.5 * 255,
            t2,
            t2
        ];
        var n3 = 0.5 * (1 + ~~(e3 > 50));
        return [
            (1 & t2) * n3 * 255,
            (t2 >> 1 & 1) * n3 * 255,
            (t2 >> 2 & 1) * n3 * 255
        ];
    }, r2.ansi256.rgb = function(e3) {
        if (e3 >= 232) {
            var t2 = 10 * (e3 - 232) + 8;
            return [
                t2,
                t2,
                t2
            ];
        }
        var n3;
        return e3 -= 16, [
            Math.floor(e3 / 36) / 5 * 255,
            Math.floor((n3 = e3 % 36) / 6) / 5 * 255,
            n3 % 6 / 5 * 255
        ];
    }, r2.rgb.hex = function(e3) {
        var t2 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
        return "000000".substring(t2.length) + t2;
    }, r2.hex.rgb = function(e3) {
        var t2 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t2) return [
            0,
            0,
            0
        ];
        var n3 = t2[0];
        3 === t2[0].length && (n3 = n3.split("").map(function(e4) {
            return e4 + e4;
        }).join(""));
        var r3 = parseInt(n3, 16);
        return [
            r3 >> 16 & 255,
            r3 >> 8 & 255,
            255 & r3
        ];
    }, r2.rgb.hcg = function(e3) {
        var t2, n3 = e3[0] / 255, r3 = e3[1] / 255, o2 = e3[2] / 255, u1 = Math.max(Math.max(n3, r3), o2), i2 = Math.min(Math.min(n3, r3), o2), a2 = u1 - i2;
        return t2 = a2 <= 0 ? 0 : u1 === n3 ? (r3 - o2) / a2 % 6 : u1 === r3 ? 2 + (o2 - n3) / a2 : 4 + (n3 - r3) / a2 + 4, t2 /= 6, [
            360 * (t2 %= 1),
            100 * a2,
            100 * (a2 < 1 ? i2 / (1 - a2) : 0)
        ];
    }, r2.hsl.hcg = function(e3) {
        var t2 = e3[1] / 100, n3 = e3[2] / 100, r3 = 1, o2 = 0;
        return (r3 = n3 < 0.5 ? 2 * t2 * n3 : 2 * t2 * (1 - n3)) < 1 && (o2 = (n3 - 0.5 * r3) / (1 - r3)), [
            e3[0],
            100 * r3,
            100 * o2
        ];
    }, r2.hsv.hcg = function(e3) {
        var t2 = e3[1] / 100, n3 = e3[2] / 100, r3 = t2 * n3, o2 = 0;
        return r3 < 1 && (o2 = (n3 - r3) / (1 - r3)), [
            e3[0],
            100 * r3,
            100 * o2
        ];
    }, r2.hcg.rgb = function(e3) {
        var t2 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
        if (0 === n3) return [
            255 * r3,
            255 * r3,
            255 * r3
        ];
        var o2, u1 = [
            0,
            0,
            0
        ], i2 = t2 % 1 * 6, a2 = i2 % 1, s2 = 1 - a2;
        switch(Math.floor(i2)){
            case 0:
                u1[0] = 1, u1[1] = a2, u1[2] = 0;
                break;
            case 1:
                u1[0] = s2, u1[1] = 1, u1[2] = 0;
                break;
            case 2:
                u1[0] = 0, u1[1] = 1, u1[2] = a2;
                break;
            case 3:
                u1[0] = 0, u1[1] = s2, u1[2] = 1;
                break;
            case 4:
                u1[0] = a2, u1[1] = 0, u1[2] = 1;
                break;
            default:
                u1[0] = 1, u1[1] = 0, u1[2] = s2;
        }
        return o2 = (1 - n3) * r3, [
            255 * (n3 * u1[0] + o2),
            255 * (n3 * u1[1] + o2),
            255 * (n3 * u1[2] + o2)
        ];
    }, r2.hcg.hsv = function(e3) {
        var t2 = e3[1] / 100, n3 = t2 + e3[2] / 100 * (1 - t2), r3 = 0;
        return n3 > 0 && (r3 = t2 / n3), [
            e3[0],
            100 * r3,
            100 * n3
        ];
    }, r2.hcg.hsl = function(e3) {
        var t2 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t2) + 0.5 * t2, r3 = 0;
        return n3 > 0 && n3 < 0.5 ? r3 = t2 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t2 / (2 * (1 - n3))), [
            e3[0],
            100 * r3,
            100 * n3
        ];
    }, r2.hcg.hwb = function(e3) {
        var t2 = e3[1] / 100, n3 = t2 + e3[2] / 100 * (1 - t2);
        return [
            e3[0],
            100 * (n3 - t2),
            100 * (1 - n3)
        ];
    }, r2.hwb.hcg = function(e3) {
        var t2 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t2, o2 = 0;
        return r3 < 1 && (o2 = (n3 - r3) / (1 - r3)), [
            e3[0],
            100 * r3,
            100 * o2
        ];
    }, r2.apple.rgb = function(e3) {
        return [
            e3[0] / 65535 * 255,
            e3[1] / 65535 * 255,
            e3[2] / 65535 * 255
        ];
    }, r2.rgb.apple = function(e3) {
        return [
            e3[0] / 255 * 65535,
            e3[1] / 255 * 65535,
            e3[2] / 255 * 65535
        ];
    }, r2.gray.rgb = function(e3) {
        return [
            e3[0] / 100 * 255,
            e3[0] / 100 * 255,
            e3[0] / 100 * 255
        ];
    }, r2.gray.hsl = r2.gray.hsv = function(e3) {
        return [
            0,
            0,
            e3[0]
        ];
    }, r2.gray.hwb = function(e3) {
        return [
            0,
            100,
            e3[0]
        ];
    }, r2.gray.cmyk = function(e3) {
        return [
            0,
            0,
            0,
            e3[0]
        ];
    }, r2.gray.lab = function(e3) {
        return [
            e3[0],
            0,
            0
        ];
    }, r2.gray.hex = function(e3) {
        var t2 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
        return "000000".substring(n3.length) + n3;
    }, r2.rgb.gray = function(e3) {
        return [
            (e3[0] + e3[1] + e3[2]) / 3 / 255 * 100
        ];
    };
});
function Br(e1) {
    var t1 = function() {
        for(var e3 = {
        }, t1 = Object.keys(Tr), n1 = t1.length, r2 = 0; r2 < n1; r2++)e3[t1[r2]] = {
            distance: -1,
            parent: null
        };
        return e3;
    }(), n1 = [
        e1
    ];
    for(t1[e1].distance = 0; n1.length;)for(var r2 = n1.pop(), o1 = Object.keys(Tr[r2]), u1 = o1.length, i2 = 0; i2 < u1; i2++){
        var a2 = o1[i2], s2 = t1[a2];
        -1 === s2.distance && (s2.distance = t1[r2].distance + 1, s2.parent = r2, n1.unshift(a2));
    }
    return t1;
}
function Nr(e1, t1) {
    return function(n1) {
        return t1(e1(n1));
    };
}
function kr(e1, t1) {
    for(var n1 = [
        t1[e1].parent,
        e1
    ], r2 = Tr[t1[e1].parent][e1], o1 = t1[e1].parent; t1[o1].parent;)n1.unshift(t1[o1].parent), r2 = Nr(Tr[t1[o1].parent][o1], r2), o1 = t1[o1].parent;
    return r2.conversion = n1, r2;
}
var Pr = {
};
Object.keys(Tr).forEach(function(e1) {
    Pr[e1] = {
    }, Object.defineProperty(Pr[e1], "channels", {
        value: Tr[e1].channels
    }), Object.defineProperty(Pr[e1], "labels", {
        value: Tr[e1].labels
    });
    var t1 = function(e3) {
        for(var t1 = Br(e3), n1 = {
        }, r2 = Object.keys(t1), o1 = r2.length, u1 = 0; u1 < o1; u1++){
            var i2 = r2[u1];
            null !== t1[i2].parent && (n1[i2] = kr(i2, t1));
        }
        return n1;
    }(e1);
    Object.keys(t1).forEach(function(n1) {
        var r2 = t1[n1];
        Pr[e1][n1] = (function(e3) {
            var t2 = function(t3) {
                if (null == t3) return t3;
                arguments.length > 1 && (t3 = Array.prototype.slice.call(arguments));
                var n3 = e3(t3);
                if ("object" == typeof n3) for(var r3 = n3.length, o1 = 0; o1 < r3; o1++)n3[o1] = Math.round(n3[o1]);
                return n3;
            };
            return "conversion" in e3 && (t2.conversion = e3.conversion), t2;
        })(r2), Pr[e1][n1].raw = (function(e3) {
            var t2 = function(t3) {
                return null == t3 ? t3 : (arguments.length > 1 && (t3 = Array.prototype.slice.call(arguments)), e3(t3));
            };
            return "conversion" in e3 && (t2.conversion = e3.conversion), t2;
        })(r2);
    });
});
let _r;
const $r = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, qr = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Wr = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Ur = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Jr = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function zr(e1) {
    return "u" === e1[0] && 5 === e1.length || "x" === e1[0] && 3 === e1.length ? String.fromCharCode(parseInt(e1.slice(1), 16)) : Jr.get(e1) || e1;
}
function Gr(e1, t1) {
    const n1 = [], r2 = t1.trim().split(/\s*,\s*/g);
    let o1;
    for (const t2 of r2)if (isNaN(t2)) {
        if (!(o1 = t2.match(Wr))) throw new Error("Invalid Chalk template style argument: ".concat(t2, " (in style '").concat(e1, "')"));
        n1.push(o1[2].replace(Ur, (e3, t3, n3)=>t3 ? zr(t3) : n3
        ));
    } else n1.push(Number(t2));
    return n1;
}
function Hr(e1) {
    qr.lastIndex = 0;
    const t1 = [];
    let n1;
    for(; null !== (n1 = qr.exec(e1));){
        const e3 = n1[1];
        if (n1[2]) {
            const r2 = Gr(e3, n1[2]);
            t1.push([
                e3
            ].concat(r2));
        } else t1.push([
            e3
        ]);
    }
    return t1;
}
function Xr(e1, t1) {
    const n1 = {
    };
    for (const e3 of t1)for (const t2 of e3.styles)n1[t2[0]] = e3.inverse ? null : t2.slice(1);
    let r2 = e1;
    for (const e4 of Object.keys(n1))if (Array.isArray(n1[e4])) {
        if (!(e4 in r2)) throw new Error("Unknown Chalk style: ".concat(e4));
        r2 = n1[e4].length > 0 ? r2[e4].apply(r2, n1[e4]) : r2[e4];
    }
    return r2;
}
const vo = [], Ao = [], Fo = (e1, t1)=>{
    if (e1 === t1) return 0;
    const n1 = e1;
    e1.length > t1.length && (e1 = t1, t1 = e1);
    let r2 = e1.length, o1 = t1.length;
    for(; r2 > 0 && e1.charCodeAt(~-r2) === t1.charCodeAt(~-o1);)r2--, o1--;
    let u1, i2, a2, s2, l2 = 0;
    for(; l2 < r2 && e1.charCodeAt(l2) === t1.charCodeAt(l2);)l2++;
    if (r2 -= l2, o1 -= l2, 0 === r2) return o1;
    let c2 = 0, p2 = 0;
    for(; c2 < r2;)Ao[c2] = e1.charCodeAt(l2 + c2), vo[c2] = ++c2;
    for(; p2 < o1;)for(u1 = t1.charCodeAt(l2 + p2), a2 = p2++, i2 = p2, c2 = 0; c2 < r2; c2++)s2 = u1 === Ao[c2] ? a2 : a2 + 1, a2 = vo[c2], i2 = vo[c2] = a2 > i2 ? s2 > i2 ? i2 + 1 : s2 : s2 > a2 ? a2 + 1 : s2;
    return i2;
};
var xo = Fo, So = Fo;
xo.default = So;
var wo = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};
const To = {
};
for (const e1 of Object.keys(wo))To[wo[e1]] = e1;
const Bo = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    hex: {
        channels: 1,
        labels: [
            "hex"
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            "keyword"
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            "ansi16"
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            "ansi256"
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            "h",
            "c",
            "g"
        ]
    },
    apple: {
        channels: 3,
        labels: [
            "r16",
            "g16",
            "b16"
        ]
    },
    gray: {
        channels: 1,
        labels: [
            "gray"
        ]
    }
};
var No = Bo;
for (const e3 of Object.keys(Bo)){
    if (!("channels" in Bo[e3])) throw new Error("missing channels property: " + e3);
    if (!("labels" in Bo[e3])) throw new Error("missing channel labels property: " + e3);
    if (Bo[e3].labels.length !== Bo[e3].channels) throw new Error("channel and label counts mismatch: " + e3);
    const { channels: t1 , labels: n1  } = Bo[e3];
    delete Bo[e3].channels, delete Bo[e3].labels, Object.defineProperty(Bo[e3], "channels", {
        value: t1
    }), Object.defineProperty(Bo[e3], "labels", {
        value: n1
    });
}
function ko(e4) {
    const t1 = function() {
        const e5 = {
        }, t2 = Object.keys(No);
        for(let n1 = t2.length, r2 = 0; r2 < n1; r2++)e5[t2[r2]] = {
            distance: -1,
            parent: null
        };
        return e5;
    }(), n1 = [
        e4
    ];
    for(t1[e4].distance = 0; n1.length;){
        const e5 = n1.pop(), r2 = Object.keys(No[e5]);
        for(let o1 = r2.length, u1 = 0; u1 < o1; u1++){
            const o1 = r2[u1], i2 = t1[o1];
            -1 === i2.distance && (i2.distance = t1[e5].distance + 1, i2.parent = e5, n1.unshift(o1));
        }
    }
    return t1;
}
function Po(e4, t1) {
    return function(n1) {
        return t1(e4(n1));
    };
}
function Oo(e4, t1) {
    const n1 = [
        t1[e4].parent,
        e4
    ];
    let r2 = No[t1[e4].parent][e4], o1 = t1[e4].parent;
    for(; t1[o1].parent;)n1.unshift(t1[o1].parent), r2 = Po(No[t1[o1].parent][o1], r2), o1 = t1[o1].parent;
    return r2.conversion = n1, r2;
}
Bo.rgb.hsl = function(e4) {
    const t1 = e4[0] / 255, n1 = e4[1] / 255, r2 = e4[2] / 255, o1 = Math.min(t1, n1, r2), u1 = Math.max(t1, n1, r2), i2 = u1 - o1;
    let a2, s2;
    u1 === o1 ? a2 = 0 : t1 === u1 ? a2 = (n1 - r2) / i2 : n1 === u1 ? a2 = 2 + (r2 - t1) / i2 : r2 === u1 && (a2 = 4 + (t1 - n1) / i2), a2 = Math.min(60 * a2, 360), a2 < 0 && (a2 += 360);
    const l2 = (o1 + u1) / 2;
    return s2 = u1 === o1 ? 0 : l2 <= 0.5 ? i2 / (u1 + o1) : i2 / (2 - u1 - o1), [
        a2,
        100 * s2,
        100 * l2
    ];
}, Bo.rgb.hsv = function(e4) {
    let t1, n1, r2, o1, u1;
    const i2 = e4[0] / 255, a2 = e4[1] / 255, s2 = e4[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e5) {
        return (l2 - e5) / 6 / c2 + 0.5;
    };
    return 0 === c2 ? (o1 = 0, u1 = 0) : (u1 = c2 / l2, t1 = p2(i2), n1 = p2(a2), r2 = p2(s2), i2 === l2 ? o1 = r2 - n1 : a2 === l2 ? o1 = 1 / 3 + t1 - r2 : s2 === l2 && (o1 = 2 / 3 + n1 - t1), o1 < 0 ? o1 += 1 : o1 > 1 && (o1 -= 1)), [
        360 * o1,
        100 * u1,
        100 * l2
    ];
}, Bo.rgb.hwb = function(e4) {
    const t1 = e4[0], n1 = e4[1];
    let r2 = e4[2];
    const o1 = Bo.rgb.hsl(e4)[0], u1 = 1 / 255 * Math.min(t1, Math.min(n1, r2));
    return r2 = 1 - 1 / 255 * Math.max(t1, Math.max(n1, r2)), [
        o1,
        100 * u1,
        100 * r2
    ];
}, Bo.rgb.cmyk = function(e4) {
    const t1 = e4[0] / 255, n1 = e4[1] / 255, r2 = e4[2] / 255, o1 = Math.min(1 - t1, 1 - n1, 1 - r2);
    return [
        100 * ((1 - t1 - o1) / (1 - o1) || 0),
        100 * ((1 - n1 - o1) / (1 - o1) || 0),
        100 * ((1 - r2 - o1) / (1 - o1) || 0),
        100 * o1
    ];
}, Bo.rgb.keyword = function(e4) {
    const t1 = To[e4];
    if (t1) return t1;
    let n1, r2 = 1 / 0;
    for (const t2 of Object.keys(wo)){
        const i2 = (u2 = wo[t2], ((o2 = e4)[0] - u2[0]) ** 2 + (o2[1] - u2[1]) ** 2 + (o2[2] - u2[2]) ** 2);
        i2 < r2 && (r2 = i2, n1 = t2);
    }
    var o2, u2;
    return n1;
}, Bo.keyword.rgb = function(e4) {
    return wo[e4];
}, Bo.rgb.xyz = function(e4) {
    let t1 = e4[0] / 255, n1 = e4[1] / 255, r2 = e4[2] / 255;
    t1 = t1 > 0.04045 ? ((t1 + 0.055) / 1.055) ** 2.4 : t1 / 12.92, n1 = n1 > 0.04045 ? ((n1 + 0.055) / 1.055) ** 2.4 : n1 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
    return [
        100 * (0.4124 * t1 + 0.3576 * n1 + 0.1805 * r2),
        100 * (0.2126 * t1 + 0.7152 * n1 + 0.0722 * r2),
        100 * (0.0193 * t1 + 0.1192 * n1 + 0.9505 * r2)
    ];
}, Bo.rgb.lab = function(e4) {
    const t1 = Bo.rgb.xyz(e4);
    let n1 = t1[0], r2 = t1[1], o2 = t1[2];
    n1 /= 95.047, r2 /= 100, o2 /= 108.883, n1 = n1 > 0.008856 ? n1 ** (1 / 3) : 7.787 * n1 + 16 / 116, r2 = r2 > 0.008856 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, o2 = o2 > 0.008856 ? o2 ** (1 / 3) : 7.787 * o2 + 16 / 116;
    return [
        116 * r2 - 16,
        500 * (n1 - r2),
        200 * (r2 - o2)
    ];
}, Bo.hsl.rgb = function(e4) {
    const t1 = e4[0] / 360, n1 = e4[1] / 100, r2 = e4[2] / 100;
    let o2, u2, i2;
    if (0 === n1) return i2 = 255 * r2, [
        i2,
        i2,
        i2
    ];
    o2 = r2 < 0.5 ? r2 * (1 + n1) : r2 + n1 - r2 * n1;
    const a2 = 2 * r2 - o2, s2 = [
        0,
        0,
        0
    ];
    for(let e5 = 0; e5 < 3; e5++)u2 = t1 + 1 / 3 * -(e5 - 1), u2 < 0 && u2++, u2 > 1 && u2--, i2 = 6 * u2 < 1 ? a2 + 6 * (o2 - a2) * u2 : 2 * u2 < 1 ? o2 : 3 * u2 < 2 ? a2 + (o2 - a2) * (2 / 3 - u2) * 6 : a2, s2[e5] = 255 * i2;
    return s2;
}, Bo.hsl.hsv = function(e4) {
    const t1 = e4[0];
    let n1 = e4[1] / 100, r2 = e4[2] / 100, o2 = n1;
    const u2 = Math.max(r2, 0.01);
    r2 *= 2, n1 *= r2 <= 1 ? r2 : 2 - r2, o2 *= u2 <= 1 ? u2 : 2 - u2;
    return [
        t1,
        100 * (0 === r2 ? 2 * o2 / (u2 + o2) : 2 * n1 / (r2 + n1)),
        100 * ((r2 + n1) / 2)
    ];
}, Bo.hsv.rgb = function(e4) {
    const t1 = e4[0] / 60, n1 = e4[1] / 100;
    let r2 = e4[2] / 100;
    const o2 = Math.floor(t1) % 6, u2 = t1 - Math.floor(t1), i2 = 255 * r2 * (1 - n1), a2 = 255 * r2 * (1 - n1 * u2), s2 = 255 * r2 * (1 - n1 * (1 - u2));
    switch(r2 *= 255, o2){
        case 0:
            return [
                r2,
                s2,
                i2
            ];
        case 1:
            return [
                a2,
                r2,
                i2
            ];
        case 2:
            return [
                i2,
                r2,
                s2
            ];
        case 3:
            return [
                i2,
                a2,
                r2
            ];
        case 4:
            return [
                s2,
                i2,
                r2
            ];
        case 5:
            return [
                r2,
                i2,
                a2
            ];
    }
}, Bo.hsv.hsl = function(e4) {
    const t1 = e4[0], n1 = e4[1] / 100, r2 = e4[2] / 100, o2 = Math.max(r2, 0.01);
    let u2, i2;
    i2 = (2 - n1) * r2;
    const a2 = (2 - n1) * o2;
    return u2 = n1 * o2, u2 /= a2 <= 1 ? a2 : 2 - a2, u2 = u2 || 0, i2 /= 2, [
        t1,
        100 * u2,
        100 * i2
    ];
}, Bo.hwb.rgb = function(e4) {
    const t1 = e4[0] / 360;
    let n1 = e4[1] / 100, r2 = e4[2] / 100;
    const o2 = n1 + r2;
    let u2;
    o2 > 1 && (n1 /= o2, r2 /= o2);
    const i2 = Math.floor(6 * t1), a2 = 1 - r2;
    u2 = 6 * t1 - i2, 0 != (1 & i2) && (u2 = 1 - u2);
    const s2 = n1 + u2 * (a2 - n1);
    let l2, c2, p2;
    switch(i2){
        default:
        case 6:
        case 0:
            l2 = a2, c2 = s2, p2 = n1;
            break;
        case 1:
            l2 = s2, c2 = a2, p2 = n1;
            break;
        case 2:
            l2 = n1, c2 = a2, p2 = s2;
            break;
        case 3:
            l2 = n1, c2 = s2, p2 = a2;
            break;
        case 4:
            l2 = s2, c2 = n1, p2 = a2;
            break;
        case 5:
            l2 = a2, c2 = n1, p2 = s2;
    }
    return [
        255 * l2,
        255 * c2,
        255 * p2
    ];
}, Bo.cmyk.rgb = function(e4) {
    const t1 = e4[0] / 100, n1 = e4[1] / 100, r2 = e4[2] / 100, o2 = e4[3] / 100;
    return [
        255 * (1 - Math.min(1, t1 * (1 - o2) + o2)),
        255 * (1 - Math.min(1, n1 * (1 - o2) + o2)),
        255 * (1 - Math.min(1, r2 * (1 - o2) + o2))
    ];
}, Bo.xyz.rgb = function(e4) {
    const t1 = e4[0] / 100, n1 = e4[1] / 100, r2 = e4[2] / 100;
    let o2, u2, i2;
    return o2 = 3.2406 * t1 + -1.5372 * n1 + -0.4986 * r2, u2 = -0.9689 * t1 + 1.8758 * n1 + 0.0415 * r2, i2 = 0.0557 * t1 + -0.204 * n1 + 1.057 * r2, o2 = o2 > 0.0031308 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, u2 = u2 > 0.0031308 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, i2 = i2 > 0.0031308 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, o2 = Math.min(Math.max(0, o2), 1), u2 = Math.min(Math.max(0, u2), 1), i2 = Math.min(Math.max(0, i2), 1), [
        255 * o2,
        255 * u2,
        255 * i2
    ];
}, Bo.xyz.lab = function(e4) {
    let t1 = e4[0], n1 = e4[1], r2 = e4[2];
    t1 /= 95.047, n1 /= 100, r2 /= 108.883, t1 = t1 > 0.008856 ? t1 ** (1 / 3) : 7.787 * t1 + 16 / 116, n1 = n1 > 0.008856 ? n1 ** (1 / 3) : 7.787 * n1 + 16 / 116, r2 = r2 > 0.008856 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
    return [
        116 * n1 - 16,
        500 * (t1 - n1),
        200 * (n1 - r2)
    ];
}, Bo.lab.xyz = function(e4) {
    let t1, n1, r2;
    n1 = (e4[0] + 16) / 116, t1 = e4[1] / 500 + n1, r2 = n1 - e4[2] / 200;
    const o2 = n1 ** 3, u2 = t1 ** 3, i2 = r2 ** 3;
    return n1 = o2 > 0.008856 ? o2 : (n1 - 16 / 116) / 7.787, t1 = u2 > 0.008856 ? u2 : (t1 - 16 / 116) / 7.787, r2 = i2 > 0.008856 ? i2 : (r2 - 16 / 116) / 7.787, t1 *= 95.047, n1 *= 100, r2 *= 108.883, [
        t1,
        n1,
        r2
    ];
}, Bo.lab.lch = function(e4) {
    const t1 = e4[0], n1 = e4[1], r2 = e4[2];
    let o2;
    o2 = 360 * Math.atan2(r2, n1) / 2 / Math.PI, o2 < 0 && (o2 += 360);
    return [
        t1,
        Math.sqrt(n1 * n1 + r2 * r2),
        o2
    ];
}, Bo.lch.lab = function(e4) {
    const t1 = e4[0], n1 = e4[1], r2 = e4[2] / 360 * 2 * Math.PI;
    return [
        t1,
        n1 * Math.cos(r2),
        n1 * Math.sin(r2)
    ];
}, Bo.rgb.ansi16 = function(e4, t1 = null) {
    const [n1, r2, o2] = e4;
    let u2 = null === t1 ? Bo.rgb.hsv(e4)[2] : t1;
    if (u2 = Math.round(u2 / 50), 0 === u2) return 30;
    let i2 = 30 + (Math.round(o2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n1 / 255));
    return 2 === u2 && (i2 += 60), i2;
}, Bo.hsv.ansi16 = function(e4) {
    return Bo.rgb.ansi16(Bo.hsv.rgb(e4), e4[2]);
}, Bo.rgb.ansi256 = function(e4) {
    const t1 = e4[0], n1 = e4[1], r2 = e4[2];
    if (t1 === n1 && n1 === r2) return t1 < 8 ? 16 : t1 > 248 ? 231 : Math.round((t1 - 8) / 247 * 24) + 232;
    return 16 + 36 * Math.round(t1 / 255 * 5) + 6 * Math.round(n1 / 255 * 5) + Math.round(r2 / 255 * 5);
}, Bo.ansi16.rgb = function(e4) {
    let t1 = e4 % 10;
    if (0 === t1 || 7 === t1) return e4 > 50 && (t1 += 3.5), t1 = t1 / 10.5 * 255, [
        t1,
        t1,
        t1
    ];
    const n1 = 0.5 * (1 + ~~(e4 > 50));
    return [
        (1 & t1) * n1 * 255,
        (t1 >> 1 & 1) * n1 * 255,
        (t1 >> 2 & 1) * n1 * 255
    ];
}, Bo.ansi256.rgb = function(e4) {
    if (e4 >= 232) {
        const t1 = 10 * (e4 - 232) + 8;
        return [
            t1,
            t1,
            t1
        ];
    }
    let t1;
    e4 -= 16;
    return [
        Math.floor(e4 / 36) / 5 * 255,
        Math.floor((t1 = e4 % 36) / 6) / 5 * 255,
        t1 % 6 / 5 * 255
    ];
}, Bo.rgb.hex = function(e4) {
    const t1 = (((255 & Math.round(e4[0])) << 16) + ((255 & Math.round(e4[1])) << 8) + (255 & Math.round(e4[2]))).toString(16).toUpperCase();
    return "000000".substring(t1.length) + t1;
}, Bo.hex.rgb = function(e4) {
    const t1 = e4.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t1) return [
        0,
        0,
        0
    ];
    let n1 = t1[0];
    3 === t1[0].length && (n1 = n1.split("").map((e5)=>e5 + e5
    ).join(""));
    const r2 = parseInt(n1, 16);
    return [
        r2 >> 16 & 255,
        r2 >> 8 & 255,
        255 & r2
    ];
}, Bo.rgb.hcg = function(e4) {
    const t1 = e4[0] / 255, n1 = e4[1] / 255, r2 = e4[2] / 255, o2 = Math.max(Math.max(t1, n1), r2), u2 = Math.min(Math.min(t1, n1), r2), i2 = o2 - u2;
    let a2, s2;
    return a2 = i2 < 1 ? u2 / (1 - i2) : 0, s2 = i2 <= 0 ? 0 : o2 === t1 ? (n1 - r2) / i2 % 6 : o2 === n1 ? 2 + (r2 - t1) / i2 : 4 + (t1 - n1) / i2, s2 /= 6, s2 %= 1, [
        360 * s2,
        100 * i2,
        100 * a2
    ];
}, Bo.hsl.hcg = function(e4) {
    const t1 = e4[1] / 100, n1 = e4[2] / 100, r2 = n1 < 0.5 ? 2 * t1 * n1 : 2 * t1 * (1 - n1);
    let o2 = 0;
    return r2 < 1 && (o2 = (n1 - 0.5 * r2) / (1 - r2)), [
        e4[0],
        100 * r2,
        100 * o2
    ];
}, Bo.hsv.hcg = function(e4) {
    const t1 = e4[1] / 100, n1 = e4[2] / 100, r2 = t1 * n1;
    let o2 = 0;
    return r2 < 1 && (o2 = (n1 - r2) / (1 - r2)), [
        e4[0],
        100 * r2,
        100 * o2
    ];
}, Bo.hcg.rgb = function(e4) {
    const t1 = e4[0] / 360, n1 = e4[1] / 100, r2 = e4[2] / 100;
    if (0 === n1) return [
        255 * r2,
        255 * r2,
        255 * r2
    ];
    const o2 = [
        0,
        0,
        0
    ], u2 = t1 % 1 * 6, i2 = u2 % 1, a2 = 1 - i2;
    let s2 = 0;
    switch(Math.floor(u2)){
        case 0:
            o2[0] = 1, o2[1] = i2, o2[2] = 0;
            break;
        case 1:
            o2[0] = a2, o2[1] = 1, o2[2] = 0;
            break;
        case 2:
            o2[0] = 0, o2[1] = 1, o2[2] = i2;
            break;
        case 3:
            o2[0] = 0, o2[1] = a2, o2[2] = 1;
            break;
        case 4:
            o2[0] = i2, o2[1] = 0, o2[2] = 1;
            break;
        default:
            o2[0] = 1, o2[1] = 0, o2[2] = a2;
    }
    return s2 = (1 - n1) * r2, [
        255 * (n1 * o2[0] + s2),
        255 * (n1 * o2[1] + s2),
        255 * (n1 * o2[2] + s2)
    ];
}, Bo.hcg.hsv = function(e4) {
    const t1 = e4[1] / 100, n1 = t1 + e4[2] / 100 * (1 - t1);
    let r2 = 0;
    return n1 > 0 && (r2 = t1 / n1), [
        e4[0],
        100 * r2,
        100 * n1
    ];
}, Bo.hcg.hsl = function(e4) {
    const t1 = e4[1] / 100, n1 = e4[2] / 100 * (1 - t1) + 0.5 * t1;
    let r2 = 0;
    return n1 > 0 && n1 < 0.5 ? r2 = t1 / (2 * n1) : n1 >= 0.5 && n1 < 1 && (r2 = t1 / (2 * (1 - n1))), [
        e4[0],
        100 * r2,
        100 * n1
    ];
}, Bo.hcg.hwb = function(e4) {
    const t1 = e4[1] / 100, n1 = t1 + e4[2] / 100 * (1 - t1);
    return [
        e4[0],
        100 * (n1 - t1),
        100 * (1 - n1)
    ];
}, Bo.hwb.hcg = function(e4) {
    const t1 = e4[1] / 100, n1 = 1 - e4[2] / 100, r2 = n1 - t1;
    let o2 = 0;
    return r2 < 1 && (o2 = (n1 - r2) / (1 - r2)), [
        e4[0],
        100 * r2,
        100 * o2
    ];
}, Bo.apple.rgb = function(e4) {
    return [
        e4[0] / 65535 * 255,
        e4[1] / 65535 * 255,
        e4[2] / 65535 * 255
    ];
}, Bo.rgb.apple = function(e4) {
    return [
        e4[0] / 255 * 65535,
        e4[1] / 255 * 65535,
        e4[2] / 255 * 65535
    ];
}, Bo.gray.rgb = function(e4) {
    return [
        e4[0] / 100 * 255,
        e4[0] / 100 * 255,
        e4[0] / 100 * 255
    ];
}, Bo.gray.hsl = function(e4) {
    return [
        0,
        0,
        e4[0]
    ];
}, Bo.gray.hsv = Bo.gray.hsl, Bo.gray.hwb = function(e4) {
    return [
        0,
        100,
        e4[0]
    ];
}, Bo.gray.cmyk = function(e4) {
    return [
        0,
        0,
        0,
        e4[0]
    ];
}, Bo.gray.lab = function(e4) {
    return [
        e4[0],
        0,
        0
    ];
}, Bo.gray.hex = function(e4) {
    const t1 = 255 & Math.round(e4[0] / 100 * 255), n1 = ((t1 << 16) + (t1 << 8) + t1).toString(16).toUpperCase();
    return "000000".substring(n1.length) + n1;
}, Bo.rgb.gray = function(e4) {
    return [
        (e4[0] + e4[1] + e4[2]) / 3 / 255 * 100
    ];
};
const Io = {
};
Object.keys(No).forEach((e4)=>{
    Io[e4] = {
    }, Object.defineProperty(Io[e4], "channels", {
        value: No[e4].channels
    }), Object.defineProperty(Io[e4], "labels", {
        value: No[e4].labels
    });
    const t1 = function(e5) {
        const t2 = ko(e5), n1 = {
        }, r2 = Object.keys(t2);
        for(let e6 = r2.length, o2 = 0; o2 < e6; o2++){
            const e6 = r2[o2];
            null !== t2[e6].parent && (n1[e6] = Oo(e6, t2));
        }
        return n1;
    }(e4);
    Object.keys(t1).forEach((n1)=>{
        const r2 = t1[n1];
        Io[e4][n1] = (function(e5) {
            const t2 = function(...t3) {
                const n3 = t3[0];
                if (null == n3) return n3;
                n3.length > 1 && (t3 = n3);
                const r3 = e5(t3);
                if ("object" == typeof r3) for(let e6 = r3.length, t4 = 0; t4 < e6; t4++)r3[t4] = Math.round(r3[t4]);
                return r3;
            };
            return "conversion" in e5 && (t2.conversion = e5.conversion), t2;
        })(r2), Io[e4][n1].raw = (function(e5) {
            const t2 = function(...t3) {
                const n3 = t3[0];
                return null == n3 ? n3 : (n3.length > 1 && (t3 = n3), e5(t3));
            };
            return "conversion" in e5 && (t2.conversion = e5.conversion), t2;
        })(r2);
    });
});
var Lo = Io, Mo = je(function(e4) {
    const t1 = (e5, t2)=>(...n1)=>{
            const r2 = e5(...n1);
            return "\x1b[".concat(r2 + t2, "m");
        }
    , n1 = (e5, t2)=>(...n3)=>{
            const r2 = e5(...n3);
            return "\x1b[".concat(38 + t2, ";5;").concat(r2, "m");
        }
    , r2 = (e5, t2)=>(...n3)=>{
            const r3 = e5(...n3);
            return "\x1b[".concat(38 + t2, ";2;").concat(r3[0], ";").concat(r3[1], ";").concat(r3[2], "m");
        }
    , o2 = (e5)=>e5
    , u2 = (e5, t2, n3)=>[
            e5,
            t2,
            n3
        ]
    , i2 = (e5, t2, n3)=>{
        Object.defineProperty(e5, t2, {
            get: ()=>{
                const r3 = n3();
                return Object.defineProperty(e5, t2, {
                    value: r3,
                    enumerable: !0,
                    configurable: !0
                }), r3;
            },
            enumerable: !0,
            configurable: !0
        });
    };
    let a2;
    const s2 = (e5, t2, n3, r3)=>{
        (void 0) === a2 && (a2 = Lo);
        const o3 = r3 ? 10 : 0, u3 = {
        };
        for (const [r4, i3] of Object.entries(a2)){
            const a3 = "ansi16" === r4 ? "ansi" : r4;
            r4 === t2 ? u3[a3] = e5(n3, o3) : "object" == typeof i3 && (u3[a3] = e5(i3[t2], o3));
        }
        return u3;
    };
    Object.defineProperty(e4, "exports", {
        enumerable: !0,
        get: function() {
            const e5 = new Map, a3 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            a3.color.gray = a3.color.blackBright, a3.bgColor.bgGray = a3.bgColor.bgBlackBright, a3.color.grey = a3.color.blackBright, a3.bgColor.bgGrey = a3.bgColor.bgBlackBright;
            for (const [t2, n3] of Object.entries(a3)){
                for (const [t3, r3] of Object.entries(n3))a3[t3] = {
                    open: "\x1b[".concat(r3[0], "m"),
                    close: "\x1b[".concat(r3[1], "m")
                }, n3[t3] = a3[t3], e5.set(r3[0], r3[1]);
                Object.defineProperty(a3, t2, {
                    value: n3,
                    enumerable: !1
                });
            }
            return (Object.defineProperty(a3, "codes", {
                value: e5,
                enumerable: !1
            }), a3.color.close = "\x1b[39m", a3.bgColor.close = "\x1b[49m", i2(a3.color, "ansi", ()=>s2(t1, "ansi16", o2, !1)
            ), i2(a3.color, "ansi256", ()=>s2(n1, "ansi256", o2, !1)
            ), i2(a3.color, "ansi16m", ()=>s2(r2, "rgb", u2, !1)
            ), i2(a3.bgColor, "ansi", ()=>s2(t1, "ansi16", o2, !0)
            ), i2(a3.bgColor, "ansi256", ()=>s2(n1, "ansi256", o2, !0)
            ), i2(a3.bgColor, "ansi16m", ()=>s2(r2, "rgb", u2, !0)
            ), a3);
        }
    });
}), jo = {
    isatty: ()=>!1
}, _o = (e4, t1 = Oe2.argv)=>{
    const n1 = e4.startsWith("-") ? "" : 1 === e4.length ? "-" : "--", r2 = t1.indexOf(n1 + e4), o2 = t1.indexOf("--");
    return -1 !== r2 && (-1 === o2 || r2 < o2);
}, Ro = _e(Object.freeze({
    __proto__: null,
    default: jo
}));
let $o;
function qo(e4) {
    return 0 !== e4 && {
        level: e4,
        hasBasic: !0,
        has256: e4 >= 2,
        has16m: e4 >= 3
    };
}
var Jo = {
    stringReplaceAll: (e4, t1, n1)=>{
        let r2 = e4.indexOf(t1);
        if (-1 === r2) return e4;
        const o2 = t1.length;
        let u2 = 0, i2 = "";
        do {
            i2 += e4.substr(u2, r2 - u2) + t1 + n1, u2 = r2 + o2, r2 = e4.indexOf(t1, u2);
        }while (-1 !== r2)
        return i2 += e4.substr(u2), i2;
    },
    stringEncaseCRLFWithFirstIndex: (e4, t1, n1, r2)=>{
        let o2 = 0, u2 = "";
        do {
            const i2 = "\r" === e4[r2 - 1];
            u2 += e4.substr(o2, (i2 ? r2 - 1 : r2) - o2) + t1 + (i2 ? "\r\n" : "\n") + n1, o2 = r2 + 1, r2 = e4.indexOf("\n", o2);
        }while (-1 !== r2)
        return u2 += e4.substr(o2), u2;
    }
};
const zo = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Go = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Ho = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Xo = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, Yo = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function Ko(e4) {
    const t1 = "u" === e4[0], n1 = "{" === e4[1];
    return t1 && !n1 && 5 === e4.length || "x" === e4[0] && 3 === e4.length ? String.fromCharCode(parseInt(e4.slice(1), 16)) : t1 && n1 ? String.fromCodePoint(parseInt(e4.slice(2, -1), 16)) : Yo.get(e4) || e4;
}
function Qo(e4, t1) {
    const n1 = [], r2 = t1.trim().split(/\s*,\s*/g);
    let o2;
    for (const t2 of r2){
        const r3 = Number(t2);
        if (Number.isNaN(r3)) {
            if (!(o2 = t2.match(Ho))) throw new Error("Invalid Chalk template style argument: ".concat(t2, " (in style '").concat(e4, "')"));
            n1.push(o2[2].replace(Xo, (e5, t3, n3)=>t3 ? Ko(t3) : n3
            ));
        } else n1.push(r3);
    }
    return n1;
}
function Zo(e4) {
    Go.lastIndex = 0;
    const t1 = [];
    let n1;
    for(; null !== (n1 = Go.exec(e4));){
        const e5 = n1[1];
        if (n1[2]) {
            const r2 = Qo(e5, n1[2]);
            t1.push([
                e5
            ].concat(r2));
        } else t1.push([
            e5
        ]);
    }
    return t1;
}
function eu(e4, t1) {
    const n1 = {
    };
    for (const e5 of t1)for (const t2 of e5.styles)n1[t2[0]] = e5.inverse ? null : t2.slice(1);
    let r2 = e4;
    for (const [e6, t3] of Object.entries(n1))if (Array.isArray(t3)) {
        if (!(e6 in r2)) throw new Error("Unknown Chalk style: ".concat(e6));
        r2 = t3.length > 0 ? r2[e6](...t3) : r2[e6];
    }
    return r2;
}
var tu = (e4, t1)=>{
    const n1 = [], r2 = [];
    let o2 = [];
    if (t1.replace(zo, (t2, u2, i2, a2, s2, l2)=>{
        if (u2) o2.push(Ko(u2));
        else if (a2) {
            const t3 = o2.join("");
            o2 = [], r2.push(0 === n1.length ? t3 : eu(e4, n1)(t3)), n1.push({
                inverse: i2,
                styles: Zo(a2)
            });
        } else if (s2) {
            if (0 === n1.length) throw new Error("Found extraneous } in Chalk template literal");
            r2.push(eu(e4, n1)(o2.join(""))), o2 = [], n1.pop();
        } else o2.push(l2);
    }), r2.push(o2.join("")), n1.length > 0) {
        const e5 = "Chalk template literal is missing ".concat(n1.length, " closing bracket").concat(1 === n1.length ? "" : "s", " (`}`)");
        throw new Error(e5);
    }
    return r2.join("");
};
const du = [
    "rgb",
    "hex",
    "keyword",
    "hsl",
    "hsv",
    "hwb",
    "ansi",
    "ansi256"
];
let Du;
var bu = function(e4, t1) {
    for(var n1 = -1, r2 = t1.length, o2 = e4.length; (++n1) < r2;)e4[o2 + n1] = t1[n1];
    return e4;
}, vu = "object" == typeof Me && Me && Me.Object === Object && Me, Au = "object" == typeof self && self && self.Object === Object && self, Fu = (vu || Au || Function("return this")()).Symbol, xu = Object.prototype, Su = xu.hasOwnProperty, wu = xu.toString, Tu = Fu ? Fu.toStringTag : void 0;
var Bu = function(e4) {
    var t1 = Su.call(e4, Tu), n1 = e4[Tu];
    try {
        e4[Tu] = void 0;
        var r2 = !0;
    } catch (e) {
    }
    var o2 = wu.call(e4);
    return (r2 && (t1 ? e4[Tu] = n1 : delete e4[Tu]), o2);
}, Nu = Object.prototype.toString;
var ku = function(e4) {
    return Nu.call(e4);
}, Pu = Fu ? Fu.toStringTag : void 0;
var Ou = function(e4) {
    return null == e4 ? (void 0) === e4 ? "[object Undefined]" : "[object Null]" : Pu && Pu in Object(e4) ? Bu(e4) : ku(e4);
};
var Iu = function(e4) {
    return null != e4 && "object" == typeof e4;
};
var Lu = function(e4) {
    return Iu(e4) && "[object Arguments]" == Ou(e4);
}, Mu = Object.prototype, ju = Mu.hasOwnProperty, _u = Mu.propertyIsEnumerable, Ru = Lu(function() {
    return arguments;
}()) ? Lu : function(e4) {
    return Iu(e4) && ju.call(e4, "callee") && !_u.call(e4, "callee");
}, Vu = Array.isArray, $u = Fu ? Fu.isConcatSpreadable : void 0;
var qu = function(e4) {
    return Vu(e4) || Ru(e4) || !!($u && e4 && e4[$u]);
};
var Wu = function e2(t1, n1, r2, o2, u2) {
    var i2 = -1, a2 = t1.length;
    for((r2 || (r2 = qu), u2 || (u2 = [])); (++i2) < a2;){
        var s2 = t1[i2];
        n1 > 0 && r2(s2) ? n1 > 1 ? e2(s2, n1 - 1, r2, o2, u2) : bu(u2, s2) : o2 || (u2[u2.length] = s2);
    }
    return u2;
};
var Uu = function(e4) {
    return (null == e4 ? 0 : e4.length) ? Wu(e4, 1) : [];
};
let Gu;
function Ku(e4, t1) {
    const { ignoreDecorators: n1  } = t1 || {
    };
    if (!n1) {
        const t2 = e4.declaration && e4.declaration.decorators || e4.decorators;
        if (t2 && t2.length > 0) return Ku(t2[0]);
    }
    return e4.range ? e4.range[0] : e4.start;
}
function Qu(e4) {
    const t1 = e4.range ? e4.range[1] : e4.end;
    return e4.typeAnnotation ? Math.max(t1, Qu(e4.typeAnnotation)) : t1;
}
function Zu(e4, t1) {
    return Ku(e4) === Ku(t1);
}
var ei = {
    locStart: Ku,
    locEnd: Qu,
    composeLoc: function(e4, t1 = e4) {
        const n1 = Ku(e4);
        return [
            n1,
            "number" == typeof t1 ? n1 + t1 : Qu(t1)
        ];
    },
    hasSameLocStart: Zu,
    hasSameLoc: function(e4, t1) {
        return Zu(e4, t1) && function(e5, t2) {
            return Qu(e5) === Qu(t2);
        }(e4, t1);
    }
}, ti = je(function(e4, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), t1.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t1.matchToToken = function(e5) {
        var t2 = {
            type: "invalid",
            value: e5[0],
            closed: void 0
        };
        return e5[1] ? (t2.type = "string", t2.closed = !(!e5[3] && !e5[4])) : e5[5] ? t2.type = "comment" : e5[6] ? (t2.type = "comment", t2.closed = !!e5[7]) : e5[8] ? t2.type = "regex" : e5[9] ? t2.type = "number" : e5[10] ? t2.type = "name" : e5[11] ? t2.type = "punctuator" : e5[12] && (t2.type = "whitespace"), t2;
    };
}), ni = je(function(e4, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), t1.isIdentifierStart = l2, t1.isIdentifierChar = c2, t1.isIdentifierName = function(e5) {
        let t2 = !0;
        for(let n1 = 0, r2 = Array.from(e5); n1 < r2.length; n1++){
            const e6 = r2[n1].codePointAt(0);
            if (t2) {
                if (!l2(e6)) return !1;
                t2 = !1;
            } else if (!c2(e6)) return !1;
        }
        return !t2;
    };
    let n1 = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc", r2 = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    const o2 = new RegExp("[" + n1 + "]"), u2 = new RegExp("[" + n1 + r2 + "]");
    n1 = r2 = null;
    const i2 = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ], a2 = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    function s2(e5, t2) {
        let n3 = 65536;
        for(let r3 = 0, o3 = t2.length; r3 < o3; r3 += 2){
            if ((n3 += t2[r3], n3 > e5)) return !1;
            if ((n3 += t2[r3 + 1], n3 >= e5)) return !0;
        }
        return !1;
    }
    function l2(e5) {
        return e5 < 65 ? 36 === e5 : e5 <= 90 || (e5 < 97 ? 95 === e5 : e5 <= 122 || (e5 <= 65535 ? e5 >= 170 && o2.test(String.fromCharCode(e5)) : s2(e5, i2)));
    }
    function c2(e5) {
        return e5 < 48 ? 36 === e5 : e5 < 58 || !(e5 < 65) && (e5 <= 90 || (e5 < 97 ? 95 === e5 : e5 <= 122 || (e5 <= 65535 ? e5 >= 170 && u2.test(String.fromCharCode(e5)) : s2(e5, i2) || s2(e5, a2))));
    }
}), ri = je(function(e4, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), t1.isReservedWord = a2, t1.isStrictReservedWord = s2, t1.isStrictBindOnlyReservedWord = l2, t1.isStrictBindReservedWord = function(e5, t2) {
        return s2(e5, t2) || l2(e5);
    }, t1.isKeyword = function(e5) {
        return o2.has(e5);
    };
    const n1 = [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ], r2 = [
        "eval",
        "arguments"
    ], o2 = new Set([
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ]), u2 = new Set(n1), i2 = new Set(r2);
    function a2(e5, t2) {
        return t2 && "await" === e5 || "enum" === e5;
    }
    function s2(e5, t2) {
        return a2(e5, t2) || u2.has(e5);
    }
    function l2(e5) {
        return i2.has(e5);
    }
}), oi = je(function(e4, t1) {
    Object.defineProperty(t1, "__esModule", {
        value: !0
    }), Object.defineProperty(t1, "isIdentifierName", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierName;
        }
    }), Object.defineProperty(t1, "isIdentifierChar", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierChar;
        }
    }), Object.defineProperty(t1, "isIdentifierStart", {
        enumerable: !0,
        get: function() {
            return ni.isIdentifierStart;
        }
    }), Object.defineProperty(t1, "isReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isReservedWord;
        }
    }), Object.defineProperty(t1, "isStrictBindOnlyReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictBindOnlyReservedWord;
        }
    }), Object.defineProperty(t1, "isStrictBindReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictBindReservedWord;
        }
    }), Object.defineProperty(t1, "isStrictReservedWord", {
        enumerable: !0,
        get: function() {
            return ri.isStrictReservedWord;
        }
    }), Object.defineProperty(t1, "isKeyword", {
        enumerable: !0,
        get: function() {
            return ri.isKeyword;
        }
    });
}), ui = /[|\\{}()[\]^$+*?.]/g, ii = function(e4) {
    if ("string" != typeof e4) throw new TypeError("Expected a string");
    return e4.replace(ui, "\\$&");
}, ai = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
}, si = je(function(e4) {
    var t1 = {
    };
    for(var n1 in ai)ai.hasOwnProperty(n1) && (t1[ai[n1]] = n1);
    var r2 = e4.exports = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [
                "hex"
            ]
        },
        keyword: {
            channels: 1,
            labels: [
                "keyword"
            ]
        },
        ansi16: {
            channels: 1,
            labels: [
                "ansi16"
            ]
        },
        ansi256: {
            channels: 1,
            labels: [
                "ansi256"
            ]
        },
        hcg: {
            channels: 3,
            labels: [
                "h",
                "c",
                "g"
            ]
        },
        apple: {
            channels: 3,
            labels: [
                "r16",
                "g16",
                "b16"
            ]
        },
        gray: {
            channels: 1,
            labels: [
                "gray"
            ]
        }
    };
    for(var o2 in r2)if (r2.hasOwnProperty(o2)) {
        if (!("channels" in r2[o2])) throw new Error("missing channels property: " + o2);
        if (!("labels" in r2[o2])) throw new Error("missing channel labels property: " + o2);
        if (r2[o2].labels.length !== r2[o2].channels) throw new Error("channel and label counts mismatch: " + o2);
        var u2 = r2[o2].channels, i2 = r2[o2].labels;
        delete r2[o2].channels, delete r2[o2].labels, Object.defineProperty(r2[o2], "channels", {
            value: u2
        }), Object.defineProperty(r2[o2], "labels", {
            value: i2
        });
    }
    r2.rgb.hsl = function(e5) {
        var t2, n3, r3 = e5[0] / 255, o3 = e5[1] / 255, u2 = e5[2] / 255, i2 = Math.min(r3, o3, u2), a2 = Math.max(r3, o3, u2), s2 = a2 - i2;
        return a2 === i2 ? t2 = 0 : r3 === a2 ? t2 = (o3 - u2) / s2 : o3 === a2 ? t2 = 2 + (u2 - r3) / s2 : u2 === a2 && (t2 = 4 + (r3 - o3) / s2), (t2 = Math.min(60 * t2, 360)) < 0 && (t2 += 360), n3 = (i2 + a2) / 2, [
            t2,
            100 * (a2 === i2 ? 0 : n3 <= 0.5 ? s2 / (a2 + i2) : s2 / (2 - a2 - i2)),
            100 * n3
        ];
    }, r2.rgb.hsv = function(e5) {
        var t2, n3, r3, o3, u2, i2 = e5[0] / 255, a2 = e5[1] / 255, s2 = e5[2] / 255, l2 = Math.max(i2, a2, s2), c2 = l2 - Math.min(i2, a2, s2), p2 = function(e6) {
            return (l2 - e6) / 6 / c2 + 0.5;
        };
        return 0 === c2 ? o3 = u2 = 0 : (u2 = c2 / l2, t2 = p2(i2), n3 = p2(a2), r3 = p2(s2), i2 === l2 ? o3 = r3 - n3 : a2 === l2 ? o3 = 1 / 3 + t2 - r3 : s2 === l2 && (o3 = 2 / 3 + n3 - t2), o3 < 0 ? o3 += 1 : o3 > 1 && (o3 -= 1)), [
            360 * o3,
            100 * u2,
            100 * l2
        ];
    }, r2.rgb.hwb = function(e5) {
        var t2 = e5[0], n3 = e5[1], o3 = e5[2];
        return [
            r2.rgb.hsl(e5)[0],
            100 * (1 / 255 * Math.min(t2, Math.min(n3, o3))),
            100 * (o3 = 1 - 1 / 255 * Math.max(t2, Math.max(n3, o3)))
        ];
    }, r2.rgb.cmyk = function(e5) {
        var t2, n3 = e5[0] / 255, r3 = e5[1] / 255, o3 = e5[2] / 255;
        return [
            100 * ((1 - n3 - (t2 = Math.min(1 - n3, 1 - r3, 1 - o3))) / (1 - t2) || 0),
            100 * ((1 - r3 - t2) / (1 - t2) || 0),
            100 * ((1 - o3 - t2) / (1 - t2) || 0),
            100 * t2
        ];
    }, r2.rgb.keyword = function(e5) {
        var n3 = t1[e5];
        if (n3) return n3;
        var r3, o3, u2, i2 = 1 / 0;
        for(var a2 in ai)if (ai.hasOwnProperty(a2)) {
            var s2 = ai[a2], l2 = (o3 = e5, u2 = s2, Math.pow(o3[0] - u2[0], 2) + Math.pow(o3[1] - u2[1], 2) + Math.pow(o3[2] - u2[2], 2));
            l2 < i2 && (i2 = l2, r3 = a2);
        }
        return r3;
    }, r2.keyword.rgb = function(e5) {
        return ai[e5];
    }, r2.rgb.xyz = function(e5) {
        var t2 = e5[0] / 255, n3 = e5[1] / 255, r3 = e5[2] / 255;
        return [
            100 * (0.4124 * (t2 = t2 > 0.04045 ? Math.pow((t2 + 0.055) / 1.055, 2.4) : t2 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)),
            100 * (0.2126 * t2 + 0.7152 * n3 + 0.0722 * r3),
            100 * (0.0193 * t2 + 0.1192 * n3 + 0.9505 * r3)
        ];
    }, r2.rgb.lab = function(e5) {
        var t2 = r2.rgb.xyz(e5), n3 = t2[0], o3 = t2[1], u2 = t2[2];
        return o3 /= 100, u2 /= 108.883, n3 = (n3 /= 95.047) > 0.008856 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [
            116 * (o3 = o3 > 0.008856 ? Math.pow(o3, 1 / 3) : 7.787 * o3 + 16 / 116) - 16,
            500 * (n3 - o3),
            200 * (o3 - (u2 = u2 > 0.008856 ? Math.pow(u2, 1 / 3) : 7.787 * u2 + 16 / 116))
        ];
    }, r2.hsl.rgb = function(e5) {
        var t2, n3, r3, o3, u2, i2 = e5[0] / 360, a2 = e5[1] / 100, s2 = e5[2] / 100;
        if (0 === a2) return [
            u2 = 255 * s2,
            u2,
            u2
        ];
        t2 = 2 * s2 - (n3 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2), o3 = [
            0,
            0,
            0
        ];
        for(var l2 = 0; l2 < 3; l2++)(r3 = i2 + 1 / 3 * -(l2 - 1)) < 0 && r3++, r3 > 1 && r3--, u2 = 6 * r3 < 1 ? t2 + 6 * (n3 - t2) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t2 + (n3 - t2) * (2 / 3 - r3) * 6 : t2, o3[l2] = 255 * u2;
        return o3;
    }, r2.hsl.hsv = function(e5) {
        var t2 = e5[0], n3 = e5[1] / 100, r3 = e5[2] / 100, o3 = n3, u2 = Math.max(r3, 0.01);
        return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, o3 *= u2 <= 1 ? u2 : 2 - u2, [
            t2,
            100 * (0 === r3 ? 2 * o3 / (u2 + o3) : 2 * n3 / (r3 + n3)),
            100 * ((r3 + n3) / 2)
        ];
    }, r2.hsv.rgb = function(e5) {
        var t2 = e5[0] / 60, n3 = e5[1] / 100, r3 = e5[2] / 100, o3 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), i2 = 255 * r3 * (1 - n3), a2 = 255 * r3 * (1 - n3 * u2), s2 = 255 * r3 * (1 - n3 * (1 - u2));
        switch(r3 *= 255, o3){
            case 0:
                return [
                    r3,
                    s2,
                    i2
                ];
            case 1:
                return [
                    a2,
                    r3,
                    i2
                ];
            case 2:
                return [
                    i2,
                    r3,
                    s2
                ];
            case 3:
                return [
                    i2,
                    a2,
                    r3
                ];
            case 4:
                return [
                    s2,
                    i2,
                    r3
                ];
            case 5:
                return [
                    r3,
                    i2,
                    a2
                ];
        }
    }, r2.hsv.hsl = function(e5) {
        var t2, n3, r3, o3 = e5[0], u2 = e5[1] / 100, i2 = e5[2] / 100, a2 = Math.max(i2, 0.01);
        return r3 = (2 - u2) * i2, n3 = u2 * a2, [
            o3,
            100 * (n3 = (n3 /= (t2 = (2 - u2) * a2) <= 1 ? t2 : 2 - t2) || 0),
            100 * (r3 /= 2)
        ];
    }, r2.hwb.rgb = function(e5) {
        var t2, n3, r3, o3, u2, i2, a2, s2 = e5[0] / 360, l2 = e5[1] / 100, c2 = e5[2] / 100, p2 = l2 + c2;
        switch(p2 > 1 && (l2 /= p2, c2 /= p2), r3 = 6 * s2 - (t2 = Math.floor(6 * s2)), 0 != (1 & t2) && (r3 = 1 - r3), o3 = l2 + r3 * ((n3 = 1 - c2) - l2), t2){
            default:
            case 6:
            case 0:
                u2 = n3, i2 = o3, a2 = l2;
                break;
            case 1:
                u2 = o3, i2 = n3, a2 = l2;
                break;
            case 2:
                u2 = l2, i2 = n3, a2 = o3;
                break;
            case 3:
                u2 = l2, i2 = o3, a2 = n3;
                break;
            case 4:
                u2 = o3, i2 = l2, a2 = n3;
                break;
            case 5:
                u2 = n3, i2 = l2, a2 = o3;
        }
        return [
            255 * u2,
            255 * i2,
            255 * a2
        ];
    }, r2.cmyk.rgb = function(e5) {
        var t2 = e5[0] / 100, n3 = e5[1] / 100, r3 = e5[2] / 100, o3 = e5[3] / 100;
        return [
            255 * (1 - Math.min(1, t2 * (1 - o3) + o3)),
            255 * (1 - Math.min(1, n3 * (1 - o3) + o3)),
            255 * (1 - Math.min(1, r3 * (1 - o3) + o3))
        ];
    }, r2.xyz.rgb = function(e5) {
        var t2, n3, r3, o3 = e5[0] / 100, u2 = e5[1] / 100, i2 = e5[2] / 100;
        return n3 = -0.9689 * o3 + 1.8758 * u2 + 0.0415 * i2, r3 = 0.0557 * o3 + -0.204 * u2 + 1.057 * i2, t2 = (t2 = 3.2406 * o3 + -1.5372 * u2 + -0.4986 * i2) > 0.0031308 ? 1.055 * Math.pow(t2, 1 / 2.4) - 0.055 : 12.92 * t2, n3 = n3 > 0.0031308 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 0.0031308 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [
            255 * (t2 = Math.min(Math.max(0, t2), 1)),
            255 * (n3 = Math.min(Math.max(0, n3), 1)),
            255 * (r3 = Math.min(Math.max(0, r3), 1))
        ];
    }, r2.xyz.lab = function(e5) {
        var t2 = e5[0], n3 = e5[1], r3 = e5[2];
        return n3 /= 100, r3 /= 108.883, t2 = (t2 /= 95.047) > 0.008856 ? Math.pow(t2, 1 / 3) : 7.787 * t2 + 16 / 116, [
            116 * (n3 = n3 > 0.008856 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16,
            500 * (t2 - n3),
            200 * (n3 - (r3 = r3 > 0.008856 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))
        ];
    }, r2.lab.xyz = function(e5) {
        var t2, n3, r3, o3 = e5[0];
        t2 = e5[1] / 500 + (n3 = (o3 + 16) / 116), r3 = n3 - e5[2] / 200;
        var u2 = Math.pow(n3, 3), i2 = Math.pow(t2, 3), a2 = Math.pow(r3, 3);
        return n3 = u2 > 0.008856 ? u2 : (n3 - 16 / 116) / 7.787, t2 = i2 > 0.008856 ? i2 : (t2 - 16 / 116) / 7.787, r3 = a2 > 0.008856 ? a2 : (r3 - 16 / 116) / 7.787, [
            t2 *= 95.047,
            n3 *= 100,
            r3 *= 108.883
        ];
    }, r2.lab.lch = function(e5) {
        var t2, n3 = e5[0], r3 = e5[1], o3 = e5[2];
        return (t2 = 360 * Math.atan2(o3, r3) / 2 / Math.PI) < 0 && (t2 += 360), [
            n3,
            Math.sqrt(r3 * r3 + o3 * o3),
            t2
        ];
    }, r2.lch.lab = function(e5) {
        var t2, n3 = e5[0], r3 = e5[1];
        return t2 = e5[2] / 360 * 2 * Math.PI, [
            n3,
            r3 * Math.cos(t2),
            r3 * Math.sin(t2)
        ];
    }, r2.rgb.ansi16 = function(e5) {
        var t2 = e5[0], n3 = e5[1], o3 = e5[2], u2 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e5)[2];
        if (0 === (u2 = Math.round(u2 / 50))) return 30;
        var i2 = 30 + (Math.round(o3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t2 / 255));
        return 2 === u2 && (i2 += 60), i2;
    }, r2.hsv.ansi16 = function(e5) {
        return r2.rgb.ansi16(r2.hsv.rgb(e5), e5[2]);
    }, r2.rgb.ansi256 = function(e5) {
        var t2 = e5[0], n3 = e5[1], r3 = e5[2];
        return t2 === n3 && n3 === r3 ? t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
    }, r2.ansi16.rgb = function(e5) {
        var t2 = e5 % 10;
        if (0 === t2 || 7 === t2) return e5 > 50 && (t2 += 3.5), [
            t2 = t2 / 10.5 * 255,
            t2,
            t2
        ];
        var n3 = 0.5 * (1 + ~~(e5 > 50));
        return [
            (1 & t2) * n3 * 255,
            (t2 >> 1 & 1) * n3 * 255,
            (t2 >> 2 & 1) * n3 * 255
        ];
    }, r2.ansi256.rgb = function(e5) {
        if (e5 >= 232) {
            var t2 = 10 * (e5 - 232) + 8;
            return [
                t2,
                t2,
                t2
            ];
        }
        var n3;
        return e5 -= 16, [
            Math.floor(e5 / 36) / 5 * 255,
            Math.floor((n3 = e5 % 36) / 6) / 5 * 255,
            n3 % 6 / 5 * 255
        ];
    }, r2.rgb.hex = function(e5) {
        var t2 = (((255 & Math.round(e5[0])) << 16) + ((255 & Math.round(e5[1])) << 8) + (255 & Math.round(e5[2]))).toString(16).toUpperCase();
        return "000000".substring(t2.length) + t2;
    }, r2.hex.rgb = function(e5) {
        var t2 = e5.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t2) return [
            0,
            0,
            0
        ];
        var n3 = t2[0];
        3 === t2[0].length && (n3 = n3.split("").map(function(e6) {
            return e6 + e6;
        }).join(""));
        var r3 = parseInt(n3, 16);
        return [
            r3 >> 16 & 255,
            r3 >> 8 & 255,
            255 & r3
        ];
    }, r2.rgb.hcg = function(e5) {
        var t2, n3 = e5[0] / 255, r3 = e5[1] / 255, o3 = e5[2] / 255, u2 = Math.max(Math.max(n3, r3), o3), i2 = Math.min(Math.min(n3, r3), o3), a2 = u2 - i2;
        return t2 = a2 <= 0 ? 0 : u2 === n3 ? (r3 - o3) / a2 % 6 : u2 === r3 ? 2 + (o3 - n3) / a2 : 4 + (n3 - r3) / a2 + 4, t2 /= 6, [
            360 * (t2 %= 1),
            100 * a2,
            100 * (a2 < 1 ? i2 / (1 - a2) : 0)
        ];
    }, r2.hsl.hcg = function(e5) {
        var t2 = e5[1] / 100, n3 = e5[2] / 100, r3 = 1, o3 = 0;
        return (r3 = n3 < 0.5 ? 2 * t2 * n3 : 2 * t2 * (1 - n3)) < 1 && (o3 = (n3 - 0.5 * r3) / (1 - r3)), [
            e5[0],
            100 * r3,
            100 * o3
        ];
    }, r2.hsv.hcg = function(e5) {
        var t2 = e5[1] / 100, n3 = e5[2] / 100, r3 = t2 * n3, o3 = 0;
        return r3 < 1 && (o3 = (n3 - r3) / (1 - r3)), [
            e5[0],
            100 * r3,
            100 * o3
        ];
    }, r2.hcg.rgb = function(e5) {
        var t2 = e5[0] / 360, n3 = e5[1] / 100, r3 = e5[2] / 100;
        if (0 === n3) return [
            255 * r3,
            255 * r3,
            255 * r3
        ];
        var o3, u2 = [
            0,
            0,
            0
        ], i2 = t2 % 1 * 6, a2 = i2 % 1, s2 = 1 - a2;
        switch(Math.floor(i2)){
            case 0:
                u2[0] = 1, u2[1] = a2, u2[2] = 0;
                break;
            case 1:
                u2[0] = s2, u2[1] = 1, u2[2] = 0;
                break;
            case 2:
                u2[0] = 0, u2[1] = 1, u2[2] = a2;
                break;
            case 3:
                u2[0] = 0, u2[1] = s2, u2[2] = 1;
                break;
            case 4:
                u2[0] = a2, u2[1] = 0, u2[2] = 1;
                break;
            default:
                u2[0] = 1, u2[1] = 0, u2[2] = s2;
        }
        return o3 = (1 - n3) * r3, [
            255 * (n3 * u2[0] + o3),
            255 * (n3 * u2[1] + o3),
            255 * (n3 * u2[2] + o3)
        ];
    }, r2.hcg.hsv = function(e5) {
        var t2 = e5[1] / 100, n3 = t2 + e5[2] / 100 * (1 - t2), r3 = 0;
        return n3 > 0 && (r3 = t2 / n3), [
            e5[0],
            100 * r3,
            100 * n3
        ];
    }, r2.hcg.hsl = function(e5) {
        var t2 = e5[1] / 100, n3 = e5[2] / 100 * (1 - t2) + 0.5 * t2, r3 = 0;
        return n3 > 0 && n3 < 0.5 ? r3 = t2 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t2 / (2 * (1 - n3))), [
            e5[0],
            100 * r3,
            100 * n3
        ];
    }, r2.hcg.hwb = function(e5) {
        var t2 = e5[1] / 100, n3 = t2 + e5[2] / 100 * (1 - t2);
        return [
            e5[0],
            100 * (n3 - t2),
            100 * (1 - n3)
        ];
    }, r2.hwb.hcg = function(e5) {
        var t2 = e5[1] / 100, n3 = 1 - e5[2] / 100, r3 = n3 - t2, o3 = 0;
        return r3 < 1 && (o3 = (n3 - r3) / (1 - r3)), [
            e5[0],
            100 * r3,
            100 * o3
        ];
    }, r2.apple.rgb = function(e5) {
        return [
            e5[0] / 65535 * 255,
            e5[1] / 65535 * 255,
            e5[2] / 65535 * 255
        ];
    }, r2.rgb.apple = function(e5) {
        return [
            e5[0] / 255 * 65535,
            e5[1] / 255 * 65535,
            e5[2] / 255 * 65535
        ];
    }, r2.gray.rgb = function(e5) {
        return [
            e5[0] / 100 * 255,
            e5[0] / 100 * 255,
            e5[0] / 100 * 255
        ];
    }, r2.gray.hsl = r2.gray.hsv = function(e5) {
        return [
            0,
            0,
            e5[0]
        ];
    }, r2.gray.hwb = function(e5) {
        return [
            0,
            100,
            e5[0]
        ];
    }, r2.gray.cmyk = function(e5) {
        return [
            0,
            0,
            0,
            e5[0]
        ];
    }, r2.gray.lab = function(e5) {
        return [
            e5[0],
            0,
            0
        ];
    }, r2.gray.hex = function(e5) {
        var t2 = 255 & Math.round(e5[0] / 100 * 255), n3 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
        return "000000".substring(n3.length) + n3;
    }, r2.rgb.gray = function(e5) {
        return [
            (e5[0] + e5[1] + e5[2]) / 3 / 255 * 100
        ];
    };
});
function li(e4) {
    var t1 = function() {
        for(var e5 = {
        }, t1 = Object.keys(si), n1 = t1.length, r2 = 0; r2 < n1; r2++)e5[t1[r2]] = {
            distance: -1,
            parent: null
        };
        return e5;
    }(), n1 = [
        e4
    ];
    for(t1[e4].distance = 0; n1.length;)for(var r2 = n1.pop(), o2 = Object.keys(si[r2]), u2 = o2.length, i2 = 0; i2 < u2; i2++){
        var a2 = o2[i2], s2 = t1[a2];
        -1 === s2.distance && (s2.distance = t1[r2].distance + 1, s2.parent = r2, n1.unshift(a2));
    }
    return t1;
}
function ci(e4, t1) {
    return function(n1) {
        return t1(e4(n1));
    };
}
function pi(e4, t1) {
    for(var n1 = [
        t1[e4].parent,
        e4
    ], r2 = si[t1[e4].parent][e4], o2 = t1[e4].parent; t1[o2].parent;)n1.unshift(t1[o2].parent), r2 = ci(si[t1[o2].parent][o2], r2), o2 = t1[o2].parent;
    return r2.conversion = n1, r2;
}
var di = {
};
Object.keys(si).forEach(function(e4) {
    di[e4] = {
    }, Object.defineProperty(di[e4], "channels", {
        value: si[e4].channels
    }), Object.defineProperty(di[e4], "labels", {
        value: si[e4].labels
    });
    var t1 = function(e5) {
        for(var t1 = li(e5), n1 = {
        }, r2 = Object.keys(t1), o2 = r2.length, u2 = 0; u2 < o2; u2++){
            var i2 = r2[u2];
            null !== t1[i2].parent && (n1[i2] = pi(i2, t1));
        }
        return n1;
    }(e4);
    Object.keys(t1).forEach(function(n1) {
        var r2 = t1[n1];
        di[e4][n1] = (function(e5) {
            var t2 = function(t3) {
                if (null == t3) return t3;
                arguments.length > 1 && (t3 = Array.prototype.slice.call(arguments));
                var n3 = e5(t3);
                if ("object" == typeof n3) for(var r3 = n3.length, o2 = 0; o2 < r3; o2++)n3[o2] = Math.round(n3[o2]);
                return n3;
            };
            return "conversion" in e5 && (t2.conversion = e5.conversion), t2;
        })(r2), di[e4][n1].raw = (function(e5) {
            var t2 = function(t3) {
                return null == t3 ? t3 : (arguments.length > 1 && (t3 = Array.prototype.slice.call(arguments)), e5(t3));
            };
            return "conversion" in e5 && (t2.conversion = e5.conversion), t2;
        })(r2);
    });
});
var fi = di, hi = je(function(e4) {
    const t1 = (e5, t2)=>function() {
            const n1 = e5.apply(fi, arguments);
            return "\x1b[".concat(n1 + t2, "m");
        }
    , n1 = (e5, t2)=>function() {
            const n3 = e5.apply(fi, arguments);
            return "\x1b[".concat(38 + t2, ";5;").concat(n3, "m");
        }
    , r2 = (e5, t2)=>function() {
            const n3 = e5.apply(fi, arguments);
            return "\x1b[".concat(38 + t2, ";2;").concat(n3[0], ";").concat(n3[1], ";").concat(n3[2], "m");
        }
    ;
    Object.defineProperty(e4, "exports", {
        enumerable: !0,
        get: function() {
            const e5 = new Map, o2 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    gray: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            o2.color.grey = o2.color.gray;
            for (const t2 of Object.keys(o2)){
                const n3 = o2[t2];
                for (const t3 of Object.keys(n3)){
                    const r3 = n3[t3];
                    o2[t3] = {
                        open: "\x1b[".concat(r3[0], "m"),
                        close: "\x1b[".concat(r3[1], "m")
                    }, n3[t3] = o2[t3], e5.set(r3[0], r3[1]);
                }
                Object.defineProperty(o2, t2, {
                    value: n3,
                    enumerable: !1
                }), Object.defineProperty(o2, "codes", {
                    value: e5,
                    enumerable: !1
                });
            }
            const u2 = (e6)=>e6
            , i2 = (e6, t3, n3)=>[
                    e6,
                    t3,
                    n3
                ]
            ;
            o2.color.close = "\x1b[39m", o2.bgColor.close = "\x1b[49m", o2.color.ansi = {
                ansi: t1(u2, 0)
            }, o2.color.ansi256 = {
                ansi256: n1(u2, 0)
            }, o2.color.ansi16m = {
                rgb: r2(i2, 0)
            }, o2.bgColor.ansi = {
                ansi: t1(u2, 10)
            }, o2.bgColor.ansi256 = {
                ansi256: n1(u2, 10)
            }, o2.bgColor.ansi16m = {
                rgb: r2(i2, 10)
            };
            for (let e6 of Object.keys(fi)){
                if ("object" != typeof fi[e6]) continue;
                const u3 = fi[e6];
                "ansi16" === e6 && (e6 = "ansi"), "ansi16" in u3 && (o2.color.ansi[e6] = t1(u3.ansi16, 0), o2.bgColor.ansi[e6] = t1(u3.ansi16, 10)), "ansi256" in u3 && (o2.color.ansi256[e6] = n1(u3.ansi256, 0), o2.bgColor.ansi256[e6] = n1(u3.ansi256, 10)), "rgb" in u3 && (o2.color.ansi16m[e6] = r2(u3.rgb, 0), o2.bgColor.ansi16m[e6] = r2(u3.rgb, 10));
            }
            return o2;
        }
    });
});
let gi;
const Ei = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ci = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, bi = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, vi = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Ai = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "\t"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function Fi(e4) {
    return "u" === e4[0] && 5 === e4.length || "x" === e4[0] && 3 === e4.length ? String.fromCharCode(parseInt(e4.slice(1), 16)) : Ai.get(e4) || e4;
}
function xi(e4, t1) {
    const n1 = [], r2 = t1.trim().split(/\s*,\s*/g);
    let o2;
    for (const t2 of r2)if (isNaN(t2)) {
        if (!(o2 = t2.match(bi))) throw new Error("Invalid Chalk template style argument: ".concat(t2, " (in style '").concat(e4, "')"));
        n1.push(o2[2].replace(vi, (e5, t3, n3)=>t3 ? Fi(t3) : n3
        ));
    } else n1.push(Number(t2));
    return n1;
}
function Si(e4) {
    Ci.lastIndex = 0;
    const t1 = [];
    let n1;
    for(; null !== (n1 = Ci.exec(e4));){
        const e5 = n1[1];
        if (n1[2]) {
            const r2 = xi(e5, n1[2]);
            t1.push([
                e5
            ].concat(r2));
        } else t1.push([
            e5
        ]);
    }
    return t1;
}
function wi(e4, t1) {
    const n1 = {
    };
    for (const e5 of t1)for (const t2 of e5.styles)n1[t2[0]] = e5.inverse ? null : t2.slice(1);
    let r2 = e4;
    for (const e6 of Object.keys(n1))if (Array.isArray(n1[e6])) {
        if (!(e6 in r2)) throw new Error("Unknown Chalk style: ".concat(e6));
        r2 = n1[e6].length > 0 ? r2[e6].apply(r2, n1[e6]) : r2[e6];
    }
    return r2;
}
const { locStart: Ii , locEnd: Li  } = ei, Mi = Object.getOwnPropertyNames, ji = Object.getOwnPropertyDescriptor;
function _i(e4) {
    const t1 = {
    };
    for (const n1 of e4.plugins)if (n1.parsers) for (const e5 of Mi(n1.parsers))Object.defineProperty(t1, e5, ji(n1.parsers, e5));
    return t1;
}
function Ri(e4, t1) {
    if (t1 = t1 || _i(e4), "function" == typeof e4.parser) return {
        parse: e4.parser,
        astFormat: "estree",
        locStart: Ii,
        locEnd: Li
    };
    if ("string" == typeof e4.parser) {
        if (Object.prototype.hasOwnProperty.call(t1, e4.parser)) return t1[e4.parser];
        throw new Oi("Couldn't resolve parser \"".concat(e4.parser, '". Parsers must be explicitly added to the standalone bundle.'));
    }
}
var Gi = function e2(t1, n1, r2) {
    if (Array.isArray(t1)) return t1.map((t2)=>e2(t2, n1, r2)
    ).filter(Boolean);
    if (!t1 || "object" != typeof t1) return t1;
    const o2 = n1.printer.massageAstNode;
    let u2;
    u2 = o2 && o2.ignoredProperties ? o2.ignoredProperties : new Set;
    const i2 = {
    };
    for (const r3 of Object.keys(t1))u2.has(r3) || "function" == typeof t1[r3] || (i2[r3] = e2(t1[r3], n1, t1));
    if (o2) {
        const e4 = o2(t1, i2, r2);
        if (null === e4) return;
        if (e4) return e4;
    }
    return i2;
};
function Hi() {
}
Hi.ok = function() {
}, Hi.strictEqual = function() {
};
var Xi = _e(Object.freeze({
    __proto__: null,
    default: Hi
}));
function ma(e4, t1) {
    return e4.getValue().printed = !0, t1.printer.printComment(e4, t1);
}
function ga(e4, t1, n1) {
    const r2 = n1.locStart(t1) - 1;
    for(let t2 = 1; t2 < e4.length; ++t2)if (r2 < n1.locStart(e4[t2])) return t2 - 1;
    return 0;
}
function Ca(e4, t1) {
    for(let n1 = e4.length - 1; n1 >= 0; n1 -= 2){
        const r2 = e4[n1];
        if (r2 && !Array.isArray(r2) && (--t1) < 0) return n1;
    }
    return -1;
}
const La = new Set([
    "ObjectExpression",
    "ArrayExpression",
    "StringLiteral",
    "NumericLiteral",
    "BooleanLiteral",
    "NullLiteral"
]), Ma = new Set([
    "OperationDefinition",
    "FragmentDefinition",
    "VariableDefinition",
    "TypeExtensionDefinition",
    "ObjectTypeDefinition",
    "FieldDefinition",
    "DirectiveDefinition",
    "EnumTypeDefinition",
    "EnumValueDefinition",
    "InputValueDefinition",
    "InputObjectTypeDefinition",
    "SchemaDefinition",
    "OperationTypeDefinition",
    "InterfaceTypeDefinition",
    "UnionTypeDefinition",
    "ScalarTypeDefinition"
]);
function ja(e4, t1) {
    if (null == t1) return !1;
    switch(e4.parser){
        case "flow":
        case "babel":
        case "babel-flow":
        case "babel-ts":
        case "typescript":
        case "espree":
        case "meriyah":
            return (function(e5) {
                return "Directive" === e5 || "TypeAlias" === e5 || "TSExportAssignment" === e5 || e5.startsWith("Declare") || e5.startsWith("TSDeclare") || e5.endsWith("Statement") || e5.endsWith("Declaration");
            })(t1.type);
        case "json":
            return La.has(t1.type);
        case "graphql":
            return Ma.has(t1.kind);
        case "vue":
            return "root" !== t1.tag;
    }
    return !1;
}
function Ya(e4, t1, n1) {
    return "number" != typeof t1 || isNaN(t1) || t1 < 0 || t1 > e4.length ? n1 : t1;
}
function Ka(e4, t1) {
    let { cursorOffset: n1 , rangeStart: r2 , rangeEnd: o2  } = t1;
    return n1 = Ya(e4, n1, -1), r2 = Ya(e4, r2, 0), o2 = Ya(e4, o2, e4.length), Object.assign({
    }, t1, {
        cursorOffset: n1,
        rangeStart: r2,
        rangeEnd: o2
    });
}
function Rs(e4, t1) {
    if (!e4 || "object" != typeof e4) return !1;
    if (Array.isArray(e4)) return e4.some((e5)=>Rs(e5, t1)
    );
    const n1 = t1(e4);
    return "boolean" == typeof n1 ? n1 : Object.keys(e4).some((n3)=>Rs(e4[n3], t1)
    );
}
function Vs(e4) {
    return "AssignmentExpression" === e4.type || "BinaryExpression" === e4.type || "LogicalExpression" === e4.type || "NGPipeExpression" === e4.type || "ConditionalExpression" === e4.type || "CallExpression" === e4.type || "OptionalCallExpression" === e4.type || "MemberExpression" === e4.type || "OptionalMemberExpression" === e4.type || "SequenceExpression" === e4.type || "TaggedTemplateExpression" === e4.type || "BindExpression" === e4.type || "UpdateExpression" === e4.type && !e4.prefix || "TSAsExpression" === e4.type || "TSNonNullExpression" === e4.type;
}
function $s(e4) {
    return "Block" === e4.type || "CommentBlock" === e4.type || "MultiLine" === e4.type;
}
const qs = new Set([
    "ExportDefaultDeclaration",
    "ExportDefaultSpecifier",
    "DeclareExportDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration"
]);
function Ws1(e4) {
    return e4 && qs.has(e4.type);
}
function Us(e4) {
    return "BooleanLiteral" === e4.type || "DirectiveLiteral" === e4.type || "Literal" === e4.type || "NullLiteral" === e4.type || "NumericLiteral" === e4.type || "BigIntLiteral" === e4.type || "DecimalLiteral" === e4.type || "RegExpLiteral" === e4.type || "StringLiteral" === e4.type || "TemplateLiteral" === e4.type || "TSTypeLiteral" === e4.type || "JSXText" === e4.type;
}
function Js(e4) {
    return "NumericLiteral" === e4.type || "Literal" === e4.type && "number" == typeof e4.value;
}
function zs(e4) {
    return "StringLiteral" === e4.type || "Literal" === e4.type && "string" == typeof e4.value;
}
function Gs(e4) {
    return "FunctionExpression" === e4.type || "ArrowFunctionExpression" === e4.type;
}
function Hs(e4) {
    return !("CallExpression" !== e4.type && "OptionalCallExpression" !== e4.type || "Identifier" !== e4.callee.type || "async" !== e4.callee.name && "inject" !== e4.callee.name && "fakeAsync" !== e4.callee.name);
}
function Xs(e4) {
    return "JSXElement" === e4.type || "JSXFragment" === e4.type;
}
function Ys(e4) {
    return "get" === e4.kind || "set" === e4.kind;
}
const Qs = new Set([
    "BinaryExpression",
    "LogicalExpression",
    "NGPipeExpression"
]);
const Zs = new Set([
    "AnyTypeAnnotation",
    "TSAnyKeyword",
    "NullLiteralTypeAnnotation",
    "TSNullKeyword",
    "ThisTypeAnnotation",
    "TSThisType",
    "NumberTypeAnnotation",
    "TSNumberKeyword",
    "VoidTypeAnnotation",
    "TSVoidKeyword",
    "BooleanTypeAnnotation",
    "TSBooleanKeyword",
    "BigIntTypeAnnotation",
    "TSBigIntKeyword",
    "SymbolTypeAnnotation",
    "TSSymbolKeyword",
    "StringTypeAnnotation",
    "TSStringKeyword",
    "BooleanLiteralTypeAnnotation",
    "StringLiteralTypeAnnotation",
    "BigIntLiteralTypeAnnotation",
    "NumberLiteralTypeAnnotation",
    "TSLiteralType",
    "TSTemplateLiteralType",
    "EmptyTypeAnnotation",
    "MixedTypeAnnotation",
    "TSNeverKeyword",
    "TSObjectKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword"
]);
const el = /^(skip|[fx]?(it|describe|test))$/;
function tl(e4) {
    return "CallExpression" === e4.type || "OptionalCallExpression" === e4.type;
}
const nl = new RegExp("([ \n\r\t]+)"), rl = new RegExp("[^ \n\r\t]");
function il(e4) {
    return /^(\d+|\d+\.\d+)$/.test(e4);
}
function al(e4) {
    return e4.quasis.some((e5)=>e5.value.raw.includes("\n")
    );
}
function sl(e4) {
    return e4.extra ? e4.extra.raw : e4.raw;
}
const ll = {
    "==": !0,
    "!=": !0,
    "===": !0,
    "!==": !0
}, cl = {
    "*": !0,
    "/": !0,
    "%": !0
}, pl = {
    ">>": !0,
    ">>>": !0,
    "<<": !0
};
const dl = {
};
function fl(e4) {
    return dl[e4];
}
[
    [
        "|>"
    ],
    [
        "??"
    ],
    [
        "||"
    ],
    [
        "&&"
    ],
    [
        "|"
    ],
    [
        "^"
    ],
    [
        "&"
    ],
    [
        "==",
        "===",
        "!=",
        "!=="
    ],
    [
        "<",
        ">",
        "<=",
        ">=",
        "in",
        "instanceof"
    ],
    [
        ">>",
        "<<",
        ">>>"
    ],
    [
        "+",
        "-"
    ],
    [
        "*",
        "/",
        "%"
    ],
    [
        "**"
    ]
].forEach((e4, t1)=>{
    e4.forEach((e5)=>{
        dl[e5] = t1;
    });
});
const hl = new WeakMap;
function ml(e4) {
    if (hl.has(e4)) return hl.get(e4);
    const t1 = [];
    return e4.this && t1.push(e4.this), Array.isArray(e4.parameters) ? t1.push(...e4.parameters) : Array.isArray(e4.params) && t1.push(...e4.params), e4.rest && t1.push(e4.rest), hl.set(e4, t1), t1;
}
const gl = new WeakMap;
function Dl(e4) {
    return "prettier-ignore" === e4.value.trim();
}
function yl(e4) {
    return e4 && (e4.comments && e4.comments.length > 0 && e4.comments.some((e5)=>Dl(e5) && !e5.unignore
    ) || e4.prettierIgnore);
}
function El(e4) {
    return yl(e4.getValue());
}
function Kl(e4) {
    return "ArrowFunctionExpression" === e4.type || "FunctionExpression" === e4.type || "FunctionDeclaration" === e4.type || "ObjectMethod" === e4.type || "ClassMethod" === e4.type || "TSDeclareFunction" === e4.type || "TSCallSignatureDeclaration" === e4.type || "TSConstructSignatureDeclaration" === e4.type || "TSMethodSignature" === e4.type || "TSConstructorType" === e4.type || "TSFunctionType" === e4.type || "TSDeclareMethod" === e4.type;
}
function gc(e4) {
    return e4.replace(/([\\`]|\${)/g, "\\$1");
}
let Xc = 0;
const ep = [
    (e4, t1)=>"ObjectExpression" === e4.type && "properties" === t1
    ,
    (e4, t1)=>"CallExpression" === e4.type && "Identifier" === e4.callee.type && "Component" === e4.callee.name && "arguments" === t1
    ,
    (e4, t1)=>"Decorator" === e4.type && "expression" === t1
];
function tp(e4) {
    return "Identifier" === e4.type && "styled" === e4.name;
}
function np(e4) {
    return /^[A-Z]/.test(e4.object.name) && "extend" === e4.property.name;
}
const lp = (e4)=>{
    if ("string" != typeof e4) throw new TypeError("Expected a string");
    const t1 = e4.match(/(?:\r?\n)/g) || [];
    if (0 === t1.length) return;
    const n1 = t1.filter((e5)=>"\r\n" === e5
    ).length;
    return n1 > t1.length - n1 ? "\r\n" : "\n";
};
var cp = lp;
cp.graceful = (e4)=>"string" == typeof e4 && lp(e4) || "\n"
;
function Np(e4) {
    const t1 = e4.getValue(), n1 = e4.getParentNode(), r2 = e4.getName();
    switch(n1.type){
        case "NGPipeExpression":
            if ("number" == typeof r2 && n1.arguments[r2] === t1 && n1.arguments.length - 1 === r2) return e4.callParent(Np);
            break;
        case "ObjectProperty":
            if ("value" === r2) {
                const t2 = e4.getParentNode(1);
                return t2.properties[t2.properties.length - 1] === n1;
            }
            break;
        case "BinaryExpression":
        case "LogicalExpression":
            if ("right" === r2) return e4.callParent(Np);
            break;
        case "ConditionalExpression":
            if ("alternate" === r2) return e4.callParent(Np);
            break;
        case "UnaryExpression":
            if (n1.prefix) return e4.callParent(Np);
    }
    return !1;
}
var Vp = function(e4, t1) {
    switch(t1.parser){
        case "json":
        case "json5":
        case "json-stringify":
        case "__js_expression":
        case "__vue_expression":
            return Object.assign({
            }, e4, {
                type: t1.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
                node: e4,
                comments: [],
                rootMarker: t1.rootMarker
            });
        default:
            return e4;
    }
};
let $D = 0;
function vC(e4) {
    const t1 = e4.flags.split("").sort().join("");
    return "/".concat(e4.pattern, "/").concat(t1);
}
const TC = new Set([
    "start",
    "end",
    "extra",
    "loc",
    "comments",
    "errors",
    "range"
]);
function BC(e4, t1) {
    const { type: n1  } = e4;
    return "Identifier" === n1 ? {
        type: "StringLiteral",
        value: e4.name
    } : "UnaryExpression" === n1 && "+" === e4.operator ? t1.argument : void 0;
}
BC.ignoredProperties = TC;
var kC = {
    bracketSpacing: {
        since: "0.0.0",
        category: "Common",
        type: "boolean",
        default: !0,
        description: "Print spaces between brackets.",
        oppositeDescription: "Do not print spaces between brackets."
    },
    singleQuote: {
        since: "0.0.0",
        category: "Common",
        type: "boolean",
        default: !1,
        description: "Use single quotes instead of double quotes."
    },
    proseWrap: {
        since: "1.8.2",
        category: "Common",
        type: "choice",
        default: [
            {
                since: "1.8.2",
                value: !0
            },
            {
                since: "1.9.0",
                value: "preserve"
            }
        ],
        description: "How to wrap prose.",
        choices: [
            {
                since: "1.9.0",
                value: "always",
                description: "Wrap prose if it exceeds the print width."
            },
            {
                since: "1.9.0",
                value: "never",
                description: "Do not wrap prose."
            },
            {
                since: "1.9.0",
                value: "preserve",
                description: "Wrap prose as-is."
            }
        ]
    }
};
var PC = {
    arrowParens: {
        since: "1.9.0",
        category: "JavaScript",
        type: "choice",
        default: [
            {
                since: "1.9.0",
                value: "avoid"
            },
            {
                since: "2.0.0",
                value: "always"
            }
        ],
        description: "Include parentheses around a sole arrow function parameter.",
        choices: [
            {
                value: "always",
                description: "Always include parens. Example: `(x) => x`"
            },
            {
                value: "avoid",
                description: "Omit parens when possible. Example: `x => x`"
            }
        ]
    },
    bracketSpacing: kC.bracketSpacing,
    jsxBracketSameLine: {
        since: "0.17.0",
        category: "JavaScript",
        type: "boolean",
        default: !1,
        description: "Put > on the last line instead of at a new line."
    },
    semi: {
        since: "1.0.0",
        category: "JavaScript",
        type: "boolean",
        default: !0,
        description: "Print semicolons.",
        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
    },
    singleQuote: kC.singleQuote,
    jsxSingleQuote: {
        since: "1.15.0",
        category: "JavaScript",
        type: "boolean",
        default: !1,
        description: "Use single quotes in JSX."
    },
    quoteProps: {
        since: "1.17.0",
        category: "JavaScript",
        type: "choice",
        default: "as-needed",
        description: "Change when properties in objects are quoted.",
        choices: [
            {
                value: "as-needed",
                description: "Only add quotes around object properties where required."
            },
            {
                value: "consistent",
                description: "If at least one property in an object requires quotes, quote all properties."
            },
            {
                value: "preserve",
                description: "Respect the input use of quotes in object properties."
            }
        ]
    },
    trailingComma: {
        since: "0.0.0",
        category: "JavaScript",
        type: "choice",
        default: [
            {
                since: "0.0.0",
                value: !1
            },
            {
                since: "0.19.0",
                value: "none"
            },
            {
                since: "2.0.0",
                value: "es5"
            }
        ],
        description: "Print trailing commas wherever possible when multi-line.",
        choices: [
            {
                value: "es5",
                description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
            },
            {
                value: "none",
                description: "No trailing commas."
            },
            {
                value: "all",
                description: "Trailing commas wherever possible (including function arguments)."
            }
        ]
    }
}, OC = {
    name: "JavaScript",
    type: "programming",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    color: "#f1e05a",
    aliases: [
        "js",
        "node"
    ],
    extensions: [
        ".js",
        "._js",
        ".bones",
        ".cjs",
        ".es",
        ".es6",
        ".frag",
        ".gs",
        ".jake",
        ".jsb",
        ".jscad",
        ".jsfl",
        ".jsm",
        ".jss",
        ".mjs",
        ".njs",
        ".pac",
        ".sjs",
        ".ssjs",
        ".xsjs",
        ".xsjslib"
    ],
    filenames: [
        "Jakefile"
    ],
    interpreters: [
        "chakra",
        "d8",
        "gjs",
        "js",
        "node",
        "nodejs",
        "qjs",
        "rhino",
        "v8",
        "v8-shell"
    ],
    languageId: 183
}, IC = {
    name: "JSX",
    type: "programming",
    group: "JavaScript",
    extensions: [
        ".jsx"
    ],
    tmScope: "source.js.jsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    languageId: 178
}, LC = {
    name: "TypeScript",
    type: "programming",
    color: "#2b7489",
    aliases: [
        "ts"
    ],
    interpreters: [
        "deno",
        "ts-node"
    ],
    extensions: [
        ".ts"
    ],
    tmScope: "source.ts",
    aceMode: "typescript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/typescript",
    languageId: 378
}, MC = {
    name: "TSX",
    type: "programming",
    group: "TypeScript",
    extensions: [
        ".tsx"
    ],
    tmScope: "source.tsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    languageId: 94901924
}, jC = {
    name: "JSON",
    type: "data",
    tmScope: "source.json",
    aceMode: "json",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    searchable: !1,
    extensions: [
        ".json",
        ".avsc",
        ".geojson",
        ".gltf",
        ".har",
        ".ice",
        ".JSON-tmLanguage",
        ".jsonl",
        ".mcmeta",
        ".tfstate",
        ".tfstate.backup",
        ".topojson",
        ".webapp",
        ".webmanifest",
        ".yy",
        ".yyp"
    ],
    filenames: [
        ".arcconfig",
        ".htmlhintrc",
        ".tern-config",
        ".tern-project",
        ".watchmanconfig",
        "composer.lock",
        "mcmod.info"
    ],
    languageId: 174
}, _C = {
    name: "JSON with Comments",
    type: "data",
    group: "JSON",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    aliases: [
        "jsonc"
    ],
    extensions: [
        ".jsonc",
        ".sublime-build",
        ".sublime-commands",
        ".sublime-completions",
        ".sublime-keymap",
        ".sublime-macro",
        ".sublime-menu",
        ".sublime-mousemap",
        ".sublime-project",
        ".sublime-settings",
        ".sublime-theme",
        ".sublime-workspace",
        ".sublime_metrics",
        ".sublime_session"
    ],
    filenames: [
        ".babelrc",
        ".eslintrc.json",
        ".jscsrc",
        ".jshintrc",
        ".jslintrc",
        "devcontainer.json",
        "jsconfig.json",
        "language-configuration.json",
        "tsconfig.json",
        "tslint.json"
    ],
    languageId: 423
}, RC = {
    name: "JSON5",
    type: "data",
    extensions: [
        ".json5"
    ],
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    languageId: 175
};
const nb = new Set([
    "red",
    "green",
    "blue",
    "alpha",
    "a",
    "rgb",
    "hue",
    "h",
    "saturation",
    "s",
    "lightness",
    "l",
    "whiteness",
    "w",
    "blackness",
    "b",
    "tint",
    "shade",
    "blend",
    "blenda",
    "contrast",
    "hsl",
    "hsla",
    "hwb",
    "hwba"
]);
function rb(e4, t1) {
    const n1 = [].concat(t1);
    let r2, o2 = -1;
    for(; r2 = e4.getParentNode(++o2);)if (n1.includes(r2.type)) return o2;
    return -1;
}
function ob(e4, t1) {
    const n1 = rb(e4, t1);
    return -1 === n1 ? null : e4.getParentNode(n1);
}
function ub(e4) {
    return "value-operator" === e4.type && "*" === e4.value;
}
function ib(e4) {
    return "value-operator" === e4.type && "/" === e4.value;
}
function ab(e4) {
    return "value-operator" === e4.type && "+" === e4.value;
}
function sb(e4) {
    return "value-operator" === e4.type && "-" === e4.value;
}
function lb(e4) {
    return "value-operator" === e4.type && "%" === e4.value;
}
function cb(e4) {
    return "value-comma_group" === e4.type && e4.groups && e4.groups[1] && "value-colon" === e4.groups[1].type;
}
function pb(e4) {
    return "value-paren_group" === e4.type && e4.groups && e4.groups[0] && cb(e4.groups[0]);
}
var db1 = {
    getAncestorCounter: rb,
    getAncestorNode: ob,
    getPropOfDeclNode: function(e4) {
        const t1 = ob(e4, "css-decl");
        return t1 && t1.prop && t1.prop.toLowerCase();
    },
    hasSCSSInterpolation: function(e4) {
        if (e4 && e4.length) for(let t1 = e4.length - 1; t1 > 0; t1--)if ("word" === e4[t1].type && "{" === e4[t1].value && "word" === e4[t1 - 1].type && e4[t1 - 1].value.endsWith("#")) return !0;
        return !1;
    },
    hasStringOrFunction: function(e4) {
        if (e4 && e4.length) for(let t1 = 0; t1 < e4.length; t1++)if ("string" === e4[t1].type || "func" === e4[t1].type) return !0;
        return !1;
    },
    maybeToLowerCase: function(e4) {
        return e4.includes("$") || e4.includes("@") || e4.includes("#") || e4.startsWith("%") || e4.startsWith("--") || e4.startsWith(":--") || e4.includes("(") && e4.includes(")") ? e4 : e4.toLowerCase();
    },
    insideValueFunctionNode: function(e4, t1) {
        const n1 = ob(e4, "value-func");
        return n1 && n1.value && n1.value.toLowerCase() === t1;
    },
    insideICSSRuleNode: function(e4) {
        const t1 = ob(e4, "css-rule");
        return t1 && t1.raws && t1.raws.selector && (t1.raws.selector.startsWith(":import") || t1.raws.selector.startsWith(":export"));
    },
    insideAtRuleNode: function(e4, t1) {
        const n1 = [].concat(t1), r2 = ob(e4, "css-atrule");
        return r2 && n1.includes(r2.name.toLowerCase());
    },
    insideURLFunctionInImportAtRuleNode: function(e4) {
        const t1 = e4.getValue(), n1 = ob(e4, "css-atrule");
        return n1 && "import" === n1.name && "url" === t1.groups[0].value && 2 === t1.groups.length;
    },
    isKeyframeAtRuleKeywords: function(e4, t1) {
        const n1 = ob(e4, "css-atrule");
        return n1 && n1.name && n1.name.toLowerCase().endsWith("keyframes") && [
            "from",
            "to"
        ].includes(t1.toLowerCase());
    },
    isWideKeywords: function(e4) {
        return [
            "initial",
            "inherit",
            "unset",
            "revert"
        ].includes(e4.toLowerCase());
    },
    isSCSS: function(e4, t1) {
        return "less" === e4 || "scss" === e4 ? "scss" === e4 : /(\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t1);
    },
    isSCSSVariable: function(e4) {
        return !(!e4 || "word" !== e4.type || !e4.value.startsWith("$"));
    },
    isLastNode: function(e4, t1) {
        const n1 = e4.getParentNode();
        if (!n1) return !1;
        const { nodes: r2  } = n1;
        return r2 && r2.indexOf(t1) === r2.length - 1;
    },
    isLessParser: function(e4) {
        return "css" === e4.parser || "less" === e4.parser;
    },
    isSCSSControlDirectiveNode: function(e4) {
        return "css-atrule" === e4.type && [
            "if",
            "else",
            "for",
            "each",
            "while"
        ].includes(e4.name);
    },
    isDetachedRulesetDeclarationNode: function(e4) {
        return !!e4.selector && ("string" == typeof e4.selector && /^@.+:.*$/.test(e4.selector) || e4.selector.value && /^@.+:.*$/.test(e4.selector.value));
    },
    isRelationalOperatorNode: function(e4) {
        return "value-word" === e4.type && [
            "<",
            ">",
            "<=",
            ">="
        ].includes(e4.value);
    },
    isEqualityOperatorNode: function(e4) {
        return "value-word" === e4.type && [
            "==",
            "!="
        ].includes(e4.value);
    },
    isMultiplicationNode: ub,
    isDivisionNode: ib,
    isAdditionNode: ab,
    isSubtractionNode: sb,
    isModuloNode: lb,
    isMathOperatorNode: function(e4) {
        return ub(e4) || ib(e4) || ab(e4) || sb(e4) || lb(e4);
    },
    isEachKeywordNode: function(e4) {
        return "value-word" === e4.type && "in" === e4.value;
    },
    isForKeywordNode: function(e4) {
        return "value-word" === e4.type && [
            "from",
            "through",
            "end"
        ].includes(e4.value);
    },
    isURLFunctionNode: function(e4) {
        return "value-func" === e4.type && "url" === e4.value.toLowerCase();
    },
    isIfElseKeywordNode: function(e4) {
        return "value-word" === e4.type && [
            "and",
            "or",
            "not"
        ].includes(e4.value);
    },
    hasComposesNode: function(e4) {
        return e4.value && "value-root" === e4.value.type && e4.value.group && "value-value" === e4.value.group.type && "composes" === e4.prop.toLowerCase();
    },
    hasParensAroundNode: function(e4) {
        return e4.value && e4.value.group && e4.value.group.group && "value-paren_group" === e4.value.group.group.type && null !== e4.value.group.group.open && null !== e4.value.group.group.close;
    },
    hasEmptyRawBefore: function(e4) {
        return e4.raws && "" === e4.raws.before;
    },
    isSCSSNestedPropertyNode: function(e4) {
        return !!e4.selector && e4.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
    },
    isDetachedRulesetCallNode: function(e4) {
        return e4.raws && e4.raws.params && /^\(\s*\)$/.test(e4.raws.params);
    },
    isTemplatePlaceholderNode: function(e4) {
        return e4.name.startsWith("prettier-placeholder");
    },
    isTemplatePropNode: function(e4) {
        return e4.prop.startsWith("@prettier-placeholder");
    },
    isPostcssSimpleVarNode: function(e4, t1) {
        return "$$" === e4.value && "value-func" === e4.type && t1 && "value-word" === t1.type && !t1.raws.before;
    },
    isKeyValuePairNode: cb,
    isKeyValuePairInParenGroupNode: pb,
    isSCSSMapItemNode: function(e4) {
        const t1 = e4.getValue();
        if (0 === t1.groups.length) return !1;
        const n1 = e4.getParentNode(1);
        if (!(pb(t1) || n1 && pb(n1))) return !1;
        const r2 = ob(e4, "css-decl");
        return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!pb(n1) || "value-func" === n1.type);
    },
    isInlineValueCommentNode: function(e4) {
        return "value-comment" === e4.type && e4.inline;
    },
    isHashNode: function(e4) {
        return "value-word" === e4.type && "#" === e4.value;
    },
    isLeftCurlyBraceNode: function(e4) {
        return "value-word" === e4.type && "{" === e4.value;
    },
    isRightCurlyBraceNode: function(e4) {
        return "value-word" === e4.type && "}" === e4.value;
    },
    isWordNode: function(e4) {
        return [
            "value-word",
            "value-atword"
        ].includes(e4.type);
    },
    isColonNode: function(e4) {
        return "value-colon" === e4.type;
    },
    isMediaAndSupportsKeywords: function(e4) {
        return e4.value && [
            "not",
            "and",
            "or"
        ].includes(e4.value.toLowerCase());
    },
    isColorAdjusterFuncNode: function(e4) {
        return "value-func" === e4.type && nb.has(e4.value.toLowerCase());
    },
    lastLineHasInlineComment: function(e4) {
        return /\/\//.test(e4.split(/[\n\r]/).pop());
    },
    stringifyNode: function e4(t1) {
        if (t1.groups) {
            return (t1.open && t1.open.value ? t1.open.value : "") + t1.groups.reduce((n1, r2, o2)=>n1 + e4(r2) + ("comma_group" === t1.groups[0].type && o2 !== t1.groups.length - 1 ? "," : "")
            , "") + (t1.close && t1.close.value ? t1.close.value : "");
        }
        const n1 = t1.raws && t1.raws.before ? t1.raws.before : "", r2 = t1.raws && t1.raws.quote ? t1.raws.quote : "";
        return n1 + r2 + ("atword" === t1.type ? "@" : "") + (t1.value ? t1.value : "") + r2 + (t1.unit ? t1.unit : "") + (t1.group ? e4(t1.group) : "") + (t1.raws && t1.raws.after ? t1.raws.after : "");
    },
    isAtWordPlaceholderNode: function(e5) {
        return e5 && "value-atword" === e5.type && e5.value.startsWith("prettier-placeholder-");
    }
}, fb = function(e4, t1) {
    let n1 = 0;
    for(let r2 = 0; r2 < e4.line - 1; ++r2)n1 = t1.indexOf("\n", n1) + 1;
    return n1 + e4.column;
};
function gb(e4, t1) {
    return "number" == typeof e4.sourceIndex ? e4.sourceIndex : e4.source ? fb(e4.source.start, t1) - 1 : null;
}
function Eb(e4) {
    let t1 = e4.source.startOffset;
    return "string" == typeof e4.prop && (t1 += e4.prop.length), "css-atrule" === e4.type && "string" == typeof e4.name && (t1 += 1 + e4.name.length + e4.raws.afterName.match(/^\s*:?\s*/)[0].length), "css-atrule" !== e4.type && e4.raws && "string" == typeof e4.raws.between && (t1 += e4.raws.between.length), t1;
}
function kv(e4) {
    return "es5" === e4.trailingComma || "all" === e4.trailingComma;
}
const Ov = /(["'])(?:(?!\1)[^\\]|\\[\S\s])*\1/g, Iv = new RegExp(Ov.source + "|" + "(".concat(/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source, ")") + "(".concat(/[A-Za-z]+/g.source, ")?"), "g");
function Mv(e4, t1) {
    const n1 = t1.singleQuote ? "'" : '"';
    return e4.includes('"') || e4.includes("'") ? e4 : n1 + e4 + n1;
}
var Jv = {
    locStart: function(e4) {
        return e4.loc.start.offset;
    },
    locEnd: function(e4) {
        return e4.loc.end.offset;
    }
};
function zv(e4, t1) {
    if ("TextNode" === e4.type) {
        const n1 = e4.chars.trim();
        if (!n1) return null;
        t1.chars = n1;
    }
}
zv.ignoredProperties = new Set([
    "loc",
    "selfClosing"
]);
var Gv = zv;
const Hv = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
]);
function Yv(e4, t1) {
    return e4 && t1.some((t2)=>e4.type === t2
    );
}
function Kv(e4, t1) {
    const n1 = e4.getValue(), r2 = e4.getParentNode(0) || {
    }, o2 = r2.children || r2.body || r2.parts || [], u2 = o2.indexOf(n1);
    return -1 !== u2 && o2[u2 + t1];
}
function Qv(e4, t1 = 1) {
    return Kv(e4, -t1);
}
function Zv(e4) {
    return Kv(e4, 1);
}
function eA(e4) {
    return Yv(e4, [
        "MustacheCommentStatement"
    ]) && "string" == typeof e4.value && "prettier-ignore" === e4.value.trim();
}
function $A(e4) {
    return (e4 = "string" == typeof e4 ? e4 : "").split("\n").length - 1;
}
function zA(e4, t1) {
    return e4.call(t1, "path");
}
var KA = {
    hasPragma: function(e4) {
        return /^\s*#[^\S\n]*@(format|prettier)\s*(\n|$)/.test(e4);
    },
    insertPragma: function(e4) {
        return "# @format\n\n" + e4;
    }
};
var QA = {
    locStart: function(e4) {
        return "number" == typeof e4.start ? e4.start : e4.loc && e4.loc.start;
    },
    locEnd: function(e4) {
        return "number" == typeof e4.end ? e4.end : e4.loc && e4.loc.end;
    }
};
function hF() {
}
hF.ignoredProperties = new Set([
    "loc",
    "comments"
]);
var yF = {
    locStart: function(e4) {
        return e4.position.start.offset;
    },
    locEnd: function(e4) {
        return e4.position.end.offset;
    }
};
function BF(e4, t1) {
    const [, n1, r2, o2] = t1.slice(e4.position.start.offset, e4.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return {
        numberText: n1,
        marker: r2,
        leadingSpaces: o2
    };
}
function Lx(e4, t1) {
    return (function(e5, t2, n1) {
        n1 = n1 || (()=>!0
        );
        let r2 = -1;
        for (const o2 of t2.children)if (o2.type === e5.type && n1(o2) ? r2++ : r2 = -1, o2 === e5) return r2;
    })(e4, t1, (t2)=>t2.ordered === e4.ordered
    );
}
function Mx(e4, t1) {
    const n1 = [].concat(t1);
    let r2, o2 = -1;
    for(; r2 = e4.getParentNode(++o2);)if (n1.includes(r2.type)) return o2;
    return -1;
}
function jx(e4, t1) {
    const n1 = Mx(e4, t1);
    return -1 === n1 ? null : e4.getParentNode(n1);
}
function $x(e4) {
    let t1 = e4;
    for(; t1.children && 0 !== t1.children.length;)t1 = t1.children[t1.children.length - 1];
    return t1;
}
function qx(e4) {
    if ("html" !== e4.type) return !1;
    const t1 = e4.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return null !== t1 && (t1[1] ? t1[1] : "next");
}
function Wx(e4, t1) {
    const n1 = t1.prevNode && "list" === t1.prevNode.type, r2 = "code" === e4.type && e4.isIndented;
    return n1 && r2;
}
function Ux(e4, t1) {
    const n1 = [
        " "
    ].concat(t1 || []);
    return new RegExp(n1.map((e5)=>"\\".concat(e5)
    ).join("|")).test(e4) ? "<".concat(e4, ">") : e4;
}
function Jx(e4, t1, n1) {
    if (null == n1 && (n1 = !0), !e4) return "";
    if (n1) return " " + Jx(e4, t1, !1);
    if ((e4 = e4.replace(/\\(["')])/g, "$1")).includes('"') && e4.includes("'") && !e4.includes(")")) return "(".concat(e4, ")");
    const r2 = e4.split("'").length - 1, o2 = e4.split('"').length - 1, u2 = r2 > o2 ? '"' : o2 > r2 || t1.singleQuote ? "'" : '"';
    return e4 = (e4 = e4.replace(/\\/, "\\\\")).replace(new RegExp("(".concat(u2, ")"), "g"), "\\$1"), "".concat(u2).concat(e4).concat(u2);
}
function dS(e4) {
    const t1 = Object.create(null);
    for (const n1 of e4)t1[n1] = !0;
    return t1;
}
function hS(e4) {
    if ("attribute" === e4.type) return !1;
    if (!e4.parent) return !1;
    if ("number" != typeof e4.index || 0 === e4.index) return !1;
    return (function(e5) {
        return "comment" === e5.type && "prettier-ignore" === e5.value.trim();
    })(e4.parent.children[e4.index - 1]);
}
function DS(e4) {
    return "element" === e4.type && 0 !== e4.children.length && ([
        "html",
        "head",
        "ul",
        "ol",
        "select"
    ].includes(e4.name) || e4.cssDisplay.startsWith("table") && "table-cell" !== e4.cssDisplay);
}
function CS(e4) {
    return e4.hasLeadingSpaces && (e4.prev ? e4.prev.sourceSpan.end.line < e4.sourceSpan.start.line : "root" === e4.parent.type || e4.parent.startSourceSpan.end.line < e4.sourceSpan.start.line);
}
function bS(e4) {
    return e4.hasTrailingSpaces && (e4.next ? e4.next.sourceSpan.start.line > e4.sourceSpan.end.line : "root" === e4.parent.type || e4.parent.endSourceSpan && e4.parent.endSourceSpan.start.line > e4.sourceSpan.end.line);
}
function vS(e4) {
    switch(e4.type){
        case "ieConditionalComment":
        case "comment":
        case "directive":
            return !0;
        case "element":
            return [
                "script",
                "select"
            ].includes(e4.name);
    }
    return !1;
}
function AS(e4) {
    const { type: t1 , lang: n1  } = e4.attrMap;
    return "module" === t1 || "text/javascript" === t1 || "text/babel" === t1 || "application/javascript" === t1 || "jsx" === n1 ? "babel" : "application/x-typescript" === t1 || "ts" === n1 || "tsx" === n1 ? "typescript" : "text/markdown" === t1 ? "markdown" : "text/html" === t1 ? "html" : t1 && (t1.endsWith("json") || t1.endsWith("importmap")) ? "json" : "text/x-handlebars-template" === t1 ? "glimmer" : void 0;
}
function FS(e4) {
    return "block" === e4 || "list-item" === e4 || e4.startsWith("table");
}
function SS(e4) {
    return "element" === e4.type && !e4.hasExplicitNamespace && ![
        "html",
        "svg"
    ].includes(e4.namespace);
}
const TS = new Set([
    "template",
    "style",
    "script"
]);
function NS(e4, t1) {
    return "vue" === t1.parser && "element" === e4.type && "root" === e4.parent.type && "html" !== e4.fullName.toLowerCase();
}
var KS = {
    hasPragma: function(e4) {
        return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e4);
    },
    insertPragma: function(e4) {
        return "\x3c!-- @format --\x3e\n\n" + e4.replace(/^\s*\n/, "");
    }
};
var QS = {
    locStart: function(e4) {
        return e4.sourceSpan.start.offset;
    },
    locEnd: function(e4) {
        return e4.sourceSpan.end.offset;
    }
};
function dT(e4) {
    return !e4.prev && e4.isLeadingSpaceSensitive && !e4.hasLeadingSpaces;
}
function ET(e4) {
    switch(e4.type){
        case "ieConditionalComment":
        case "ieConditionalStartComment":
            return "\x3c!--[if ".concat(e4.condition);
        case "ieConditionalEndComment":
            return "\x3c!--<!";
        case "interpolation":
            return "{{";
        case "docType":
            return "<!DOCTYPE";
        case "element":
            if (e4.condition) return "\x3c!--[if ".concat(e4.condition, "]>\x3c!--\x3e<").concat(e4.rawName);
        default:
            return "<".concat(e4.rawName);
    }
}
function CT(e4) {
    switch(Xi(!e4.isSelfClosing), e4.type){
        case "ieConditionalComment":
            return "]>";
        case "element":
            if (e4.condition) return ">\x3c!--<![endif]--\x3e";
        default:
            return ">";
    }
}
var xT = {
    htmlWhitespaceSensitivity: {
        since: "1.15.0",
        category: "HTML",
        type: "choice",
        default: "css",
        description: "How to handle whitespaces in HTML.",
        choices: [
            {
                value: "css",
                description: "Respect the default value of CSS display property."
            },
            {
                value: "strict",
                description: "Whitespaces are considered sensitive."
            },
            {
                value: "ignore",
                description: "Whitespaces are considered insensitive."
            }
        ]
    },
    vueIndentScriptAndStyle: {
        since: "1.19.0",
        category: "HTML",
        type: "boolean",
        default: !1,
        description: "Indent script and style tags in Vue files."
    }
}, ST = {
    name: "HTML",
    type: "markup",
    tmScope: "text.html.basic",
    aceMode: "html",
    codemirrorMode: "htmlmixed",
    codemirrorMimeType: "text/html",
    color: "#e34c26",
    aliases: [
        "xhtml"
    ],
    extensions: [
        ".html",
        ".htm",
        ".html.hl",
        ".inc",
        ".st",
        ".xht",
        ".xhtml"
    ],
    languageId: 146
}, wT = {
    name: "Vue",
    type: "markup",
    color: "#2c3e50",
    extensions: [
        ".vue"
    ],
    tmScope: "text.html.vue",
    aceMode: "html",
    languageId: 391
};
var BT = {
    isPragma: function(e4) {
        return /^\s*@(prettier|format)\s*$/.test(e4);
    },
    hasPragma: function(e4) {
        return /^\s*#[^\S\n]*@(prettier|format)\s*?(\n|$)/.test(e4);
    },
    insertPragma: function(e4) {
        return "# @format\n\n".concat(e4);
    }
};
var NT = {
    locStart: function(e4) {
        return e4.position.start.offset;
    },
    locEnd: function(e4) {
        return e4.position.end.offset;
    }
};
function PT(e4, t1) {
    return e4 && "string" == typeof e4.type && (!t1 || t1.includes(e4.type));
}
function OT(e4) {
    return "prettier-ignore" === e4.value.trim();
}
function IT(e4) {
    return e4 && e4.leadingComments && 0 !== e4.leadingComments.length;
}
function LT(e4) {
    return e4 && e4.middleComments && 0 !== e4.middleComments.length;
}
function MT(e4) {
    return e4 && e4.indicatorComment;
}
function jT(e4) {
    return e4 && e4.trailingComment;
}
function _T(e4) {
    return e4 && e4.endComments && 0 !== e4.endComments.length;
}
function RT(e4) {
    const t1 = [];
    let n1;
    for (const r2 of e4.split(/( +)/g))" " !== r2 ? " " === n1 ? t1.push(r2) : t1.push((t1.pop() || "") + r2) : (void 0) === n1 && t1.unshift(""), n1 = r2;
    return " " === n1 && t1.push((t1.pop() || "") + " "), "" === t1[0] && (t1.shift(), t1.unshift(" " + (t1.shift() || ""))), t1;
}
function TB(e4) {
    if (!e4) return !0;
    switch(e4.type){
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
        case "alias":
        case "flowMapping":
        case "flowSequence":
            return !0;
        default:
            return !1;
    }
}
function PB(e4, t1) {
    if (!e4) return !0;
    switch(e4.type){
        case "plain":
        case "quoteSingle":
        case "quoteDouble": break;
        case "alias":
            return !0;
        default:
            return !1;
    }
    if ("preserve" === t1.proseWrap) return e4.position.start.line === e4.position.end.line;
    if (/\\$/m.test(t1.originalText.slice(e4.position.start.offset, e4.position.end.offset))) return !1;
    switch(t1.proseWrap){
        case "never":
            return !e4.value.includes("\n");
        case "always":
            return !/[\n ]/.test(e4.value);
        default:
            return !1;
    }
}
function OB(e4) {
    return e4.key.content && "alias" === e4.key.content.type;
}
const LB = new WeakMap;
var t1 = function(t2, e4) {
    const s2 = new SyntaxError(t2 + " (" + e4.start.line + ":" + e4.start.column + ")");
    return (s2.loc = e4, s2);
}, e4 = (t2)=>"string" == typeof t2 ? t2.replace((({ onlyFirst: t3 = !1  } = {
    })=>{
        const e5 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(e5, t3 ? void 0 : "g");
    })(), "") : t2
;
const s2 = (t2)=>!Number.isNaN(t2) && (t2 >= 4352 && (t2 <= 4447 || 9001 === t2 || 9002 === t2 || 11904 <= t2 && t2 <= 12871 && 12351 !== t2 || 12880 <= t2 && t2 <= 19903 || 19968 <= t2 && t2 <= 42182 || 43360 <= t2 && t2 <= 43388 || 44032 <= t2 && t2 <= 55203 || 63744 <= t2 && t2 <= 64255 || 65040 <= t2 && t2 <= 65049 || 65072 <= t2 && t2 <= 65131 || 65281 <= t2 && t2 <= 65376 || 65504 <= t2 && t2 <= 65510 || 110592 <= t2 && t2 <= 110593 || 127488 <= t2 && t2 <= 127569 || 131072 <= t2 && t2 <= 262141))
;
var r2 = s2, i2 = s2;
r2.default = i2;
const n1 = (t2)=>{
    if ("string" != typeof (t2 = t2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === t2.length) return 0;
    t2 = e4(t2);
    let s3 = 0;
    for(let e5 = 0; e5 < t2.length; e5++){
        const i3 = t2.codePointAt(e5);
        i3 <= 31 || i3 >= 127 && i3 <= 159 || (i3 >= 768 && i3 <= 879 || (i3 > 65535 && e5++, s3 += r2(i3) ? 2 : 1));
    }
    return s3;
};
var a2 = n1, o2 = n1;
a2.default = o2;
var u2 = (t2)=>{
    if ("string" != typeof t2) throw new TypeError("Expected a string");
    return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function h1(t2, e5) {
    return e5 || (e5 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, {
        raw: {
            value: Object.freeze(e5)
        }
    }));
}
var c2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function p2() {
    throw new Error("setTimeout has not been defined");
}
function l2() {
    throw new Error("clearTimeout has not been defined");
}
var d2 = p2, D1 = l2;
function m1(t2) {
    if (d2 === setTimeout) return setTimeout(t2, 0);
    if ((d2 === p2 || !d2) && setTimeout) return d2 = setTimeout, setTimeout(t2, 0);
    try {
        return d2(t2, 0);
    } catch (e) {
        try {
            return d2.call(null, t2, 0);
        } catch (e) {
            return d2.call(this, t2, 0);
        }
    }
}
"function" == typeof c2.setTimeout && (d2 = setTimeout), "function" == typeof c2.clearTimeout && (D1 = clearTimeout);
var f1, y1 = [], E1 = !1, A1 = -1;
function F1(t2, e5) {
    this.fun = t2, this.array = e5;
}
F1.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function g1() {
}
var b1 = g1, P1 = g1, T1 = g1, w1 = g1, B = g1, S = g1, N1 = g1;
var I2 = c2.performance || {
}, v1 = I2.now || I2.mozNow || I2.msNow || I2.oNow || I2.webkitNow || function() {
    return (new Date).getTime();
};
var k1 = new Date;
var M2 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
};
function R1(t2, e5, s3) {
    return t2(s3 = {
        path: e5,
        exports: {
        },
        require: function(t3, e6) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == e6 && s3.path);
        }
    }, s3.exports), s3.exports;
}
function _1(t2) {
    return t2 && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
const U1 = /^[0-9]+$/, q1 = (t2, e5)=>{
    const s3 = U1.test(t2), r3 = U1.test(e5);
    return s3 && r3 && (t2 = +t2, e5 = +e5), t2 === e5 ? 0 : s3 && !r3 ? -1 : r3 && !s3 ? 1 : t2 < e5 ? -1 : 1;
};
var V1 = {
    compareIdentifiers: q1,
    rcompareIdentifiers: (t2, e5)=>q1(e5, t2)
};
function et1() {
    const t2 = h1([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return et1 = function() {
        return t2;
    }, t2;
}
function st() {
    const t2 = h1([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return st = function() {
        return t2;
    }, t2;
}
function rt1() {
    const t2 = h1([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return rt1 = function() {
        return t2;
    }, t2;
}
function it() {
    const t2 = h1([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return it = function() {
        return t2;
    }, t2;
}
function nt1() {
    const t2 = h1([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return nt1 = function() {
        return t2;
    }, t2;
}
function at() {
    const t2 = h1([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return at = function() {
        return t2;
    }, t2;
}
function mt1(t2) {
    return (e5, s3, r3)=>{
        const i3 = r3 && r3.backwards;
        if (!1 === s3) return !1;
        const { length: n3  } = e5;
        let a3 = s3;
        for(; a3 >= 0 && a3 < n3;){
            const s4 = e5.charAt(a3);
            if (t2 instanceof RegExp) {
                if (!t2.test(s4)) return a3;
            } else if (!t2.includes(s4)) return a3;
            i3 ? a3-- : a3++;
        }
        return (-1 === a3 || a3 === n3) && a3;
    };
}
const ft = mt1(/\s/), yt1 = mt1(" \t"), Et1 = mt1(",; \t"), At1 = mt1(/[^\n\r]/);
function Ct1(t2, e5) {
    if (!1 === e5) return !1;
    if ("/" === t2.charAt(e5) && "*" === t2.charAt(e5 + 1)) for(let s3 = e5 + 2; s3 < t2.length; ++s3)if ("*" === t2.charAt(s3) && "/" === t2.charAt(s3 + 1)) return s3 + 2;
    return e5;
}
function xt1(t2, e5) {
    return !1 !== e5 && ("/" === t2.charAt(e5) && "/" === t2.charAt(e5 + 1) ? At1(t2, e5) : e5);
}
function Ft1(t2, e5, s3) {
    const r3 = s3 && s3.backwards;
    if (!1 === e5) return !1;
    const i3 = t2.charAt(e5);
    if (r3) {
        if ("\r" === t2.charAt(e5 - 1) && "\n" === i3) return e5 - 2;
        if ("\n" === i3 || "\r" === i3 || "\u2028" === i3 || "\u2029" === i3) return e5 - 1;
    } else {
        if ("\r" === i3 && "\n" === t2.charAt(e5 + 1)) return e5 + 2;
        if ("\n" === i3 || "\r" === i3 || "\u2028" === i3 || "\u2029" === i3) return e5 + 1;
    }
    return e5;
}
function gt1(t2, e5, s3) {
    const r3 = yt1(t2, (s3 = s3 || {
    }).backwards ? e5 - 1 : e5, s3);
    return r3 !== Ft1(t2, r3, s3);
}
function bt1(t2, e5) {
    let s3 = null, r3 = e5;
    for(; r3 !== s3;)s3 = r3, r3 = Et1(t2, r3), r3 = Ct1(t2, r3), r3 = yt1(t2, r3);
    return r3 = xt1(t2, r3), r3 = Ft1(t2, r3), !1 !== r3 && gt1(t2, r3);
}
function Pt(t2, e5) {
    let s3 = null, r3 = e5;
    for(; r3 !== s3;)s3 = r3, r3 = yt1(t2, r3), r3 = Ct1(t2, r3), r3 = xt1(t2, r3), r3 = Ft1(t2, r3);
    return r3;
}
function Tt1(t2, e5, s3) {
    return Pt(t2, s3(e5));
}
function wt1(t2, e5, s3) {
    let r3 = 0;
    for(let i3 = s3 = s3 || 0; i3 < t2.length; ++i3)"\t" === t2[i3] ? r3 = r3 + e5 - r3 % e5 : r3++;
    return r3;
}
function Bt1(t2, e5) {
    const s3 = t2.slice(1, -1), r3 = {
        quote: '"',
        regex: /"/g
    }, i3 = {
        quote: "'",
        regex: /'/g
    }, n3 = "'" === e5 ? i3 : r3, a3 = n3 === i3 ? r3 : i3;
    let o3 = n3.quote;
    if (s3.includes(n3.quote) || s3.includes(a3.quote)) {
        o3 = (s3.match(n3.regex) || []).length > (s3.match(a3.regex) || []).length ? a3.quote : n3.quote;
    }
    return o3;
}
function St1(t2, e5, s3) {
    const r3 = '"' === e5 ? "'" : '"', i3 = t2.replace(/\\([\S\s])|(["'])/g, (t3, i4, n3)=>i4 === r3 ? i4 : n3 === e5 ? "\\" + n3 : n3 || (s3 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i4) ? i4 : "\\" + i4)
    );
    return e5 + i3 + e5;
}
function Nt(t2, e5) {
    (t2.comments || (t2.comments = [])).push(e5), e5.printed = !1, "JSXText" === t2.type && (e5.printed = !0);
}
const kt1 = (t2)=>{
    if ("string" != typeof t2) throw new TypeError("Expected a string");
    const e5 = t2.match(/(?:\r?\n)/g) || [];
    if (0 === e5.length) return;
    const s3 = e5.filter((t3)=>"\r\n" === t3
    ).length;
    return s3 > e5.length - s3 ? "\r\n" : "\n";
};
var Lt = kt1;
Lt.graceful = (t2)=>"string" == typeof t2 && kt1(t2) || "\n"
;
var Rt = {
    guessEndOfLine: function(t2) {
        const e5 = t2.indexOf("\r");
        return e5 >= 0 ? "\n" === t2.charAt(e5 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(t2) {
        switch(t2){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(t2, e5) {
        let s3;
        if ("\n" === e5) s3 = /\n/g;
        else if ("\r" === e5) s3 = /\r/g;
        else {
            if ("\r\n" !== e5) throw new Error('Unexpected "eol" '.concat(JSON.stringify(e5), "."));
            s3 = /\r\n/g;
        }
        const r3 = t2.match(s3);
        return r3 ? r3.length : 0;
    },
    normalizeEndOfLine: function(t2) {
        return t2.replace(/\r\n?/g, "\n");
    }
};
function Gt1(t2, e5) {
    const { ignoreDecorators: s3  } = e5 || {
    };
    if (!s3) {
        const e6 = t2.declaration && t2.declaration.decorators || t2.decorators;
        if (e6 && e6.length > 0) return Gt1(e6[0]);
    }
    return t2.range ? t2.range[0] : t2.start;
}
function Xt1(t2) {
    const e5 = t2.range ? t2.range[1] : t2.end;
    return t2.typeAnnotation ? Math.max(e5, Xt1(t2.typeAnnotation)) : e5;
}
function Kt1(t2, e5) {
    return Gt1(t2) === Gt1(e5);
}
var Jt1 = {
    locStart: Gt1,
    locEnd: Xt1,
    composeLoc: function(t2, e5 = t2) {
        const s3 = Gt1(t2);
        return [
            s3,
            "number" == typeof e5 ? s3 + e5 : Xt1(e5)
        ];
    },
    hasSameLocStart: Kt1,
    hasSameLoc: function(t2, e5) {
        return Kt1(t2, e5) && function(t3, e6) {
            return Xt1(t3) === Xt1(e6);
        }(t2, e5);
    }
}, $t1 = R1(function(t2) {
    !(function() {
        function e5(t3) {
            if (null == t3) return !1;
            switch(t3.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                    return !0;
            }
            return !1;
        }
        function s3(t3) {
            switch(t3.type){
                case "IfStatement":
                    return null != t3.alternate ? t3.alternate : t3.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                    return t3.body;
            }
            return null;
        }
        t2.exports = {
            isExpression: function(t3) {
                if (null == t3) return !1;
                switch(t3.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                        return !0;
                }
                return !1;
            },
            isStatement: e5,
            isIterationStatement: function(t3) {
                if (null == t3) return !1;
                switch(t3.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                        return !0;
                }
                return !1;
            },
            isSourceElement: function(t3) {
                return e5(t3) || null != t3 && "FunctionDeclaration" === t3.type;
            },
            isProblematicIfStatement: function(t3) {
                var e6;
                if ("IfStatement" !== t3.type) return !1;
                if (null == t3.alternate) return !1;
                e6 = t3.consequent;
                do {
                    if ("IfStatement" === e6.type && null == e6.alternate) return !0;
                    e6 = s3(e6);
                }while (e6)
                return !1;
            },
            trailingStatement: s3
        };
    })();
}), Yt1 = R1(function(t2) {
    !(function() {
        var e5, s3, r3, i3, n3, a3;
        function o3(t3) {
            return t3 <= 65535 ? String.fromCharCode(t3) : String.fromCharCode(Math.floor((t3 - 65536) / 1024) + 55296) + String.fromCharCode((t3 - 65536) % 1024 + 56320);
        }
        for(s3 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        }, e5 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        }, r3 = [
            5760,
            8192,
            8193,
            8194,
            8195,
            8196,
            8197,
            8198,
            8199,
            8200,
            8201,
            8202,
            8239,
            8287,
            12288,
            65279
        ], i3 = new Array(128), a3 = 0; a3 < 128; ++a3)i3[a3] = a3 >= 97 && a3 <= 122 || a3 >= 65 && a3 <= 90 || 36 === a3 || 95 === a3;
        for(n3 = new Array(128), a3 = 0; a3 < 128; ++a3)n3[a3] = a3 >= 97 && a3 <= 122 || a3 >= 65 && a3 <= 90 || a3 >= 48 && a3 <= 57 || 36 === a3 || 95 === a3;
        t2.exports = {
            isDecimalDigit: function(t3) {
                return 48 <= t3 && t3 <= 57;
            },
            isHexDigit: function(t3) {
                return 48 <= t3 && t3 <= 57 || 97 <= t3 && t3 <= 102 || 65 <= t3 && t3 <= 70;
            },
            isOctalDigit: function(t3) {
                return t3 >= 48 && t3 <= 55;
            },
            isWhiteSpace: function(t3) {
                return 32 === t3 || 9 === t3 || 11 === t3 || 12 === t3 || 160 === t3 || t3 >= 5760 && r3.indexOf(t3) >= 0;
            },
            isLineTerminator: function(t3) {
                return 10 === t3 || 13 === t3 || 8232 === t3 || 8233 === t3;
            },
            isIdentifierStartES5: function(t3) {
                return t3 < 128 ? i3[t3] : s3.NonAsciiIdentifierStart.test(o3(t3));
            },
            isIdentifierPartES5: function(t3) {
                return t3 < 128 ? n3[t3] : s3.NonAsciiIdentifierPart.test(o3(t3));
            },
            isIdentifierStartES6: function(t3) {
                return t3 < 128 ? i3[t3] : e5.NonAsciiIdentifierStart.test(o3(t3));
            },
            isIdentifierPartES6: function(t3) {
                return t3 < 128 ? n3[t3] : e5.NonAsciiIdentifierPart.test(o3(t3));
            }
        };
    })();
}), Qt1 = R1(function(t2) {
    !(function() {
        var e5 = Yt1;
        function s3(t3, e6) {
            return !(!e6 && "yield" === t3) && r3(t3, e6);
        }
        function r3(t3, e6) {
            if (e6 && (function(t4) {
                switch(t4){
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                        return !0;
                    default:
                        return !1;
                }
            })(t3)) return !0;
            switch(t3.length){
                case 2:
                    return "if" === t3 || "in" === t3 || "do" === t3;
                case 3:
                    return "var" === t3 || "for" === t3 || "new" === t3 || "try" === t3;
                case 4:
                    return "this" === t3 || "else" === t3 || "case" === t3 || "void" === t3 || "with" === t3 || "enum" === t3;
                case 5:
                    return "while" === t3 || "break" === t3 || "catch" === t3 || "throw" === t3 || "const" === t3 || "yield" === t3 || "class" === t3 || "super" === t3;
                case 6:
                    return "return" === t3 || "typeof" === t3 || "delete" === t3 || "switch" === t3 || "export" === t3 || "import" === t3;
                case 7:
                    return "default" === t3 || "finally" === t3 || "extends" === t3;
                case 8:
                    return "function" === t3 || "continue" === t3 || "debugger" === t3;
                case 10:
                    return "instanceof" === t3;
                default:
                    return !1;
            }
        }
        function i3(t3, e6) {
            return "null" === t3 || "true" === t3 || "false" === t3 || s3(t3, e6);
        }
        function n3(t3, e6) {
            return "null" === t3 || "true" === t3 || "false" === t3 || r3(t3, e6);
        }
        function a3(t3) {
            var s4, r4, i4;
            if (0 === t3.length) return !1;
            if (i4 = t3.charCodeAt(0), !e5.isIdentifierStartES5(i4)) return !1;
            for(s4 = 1, r4 = t3.length; s4 < r4; ++s4)if (i4 = t3.charCodeAt(s4), !e5.isIdentifierPartES5(i4)) return !1;
            return !0;
        }
        function o3(t3) {
            var s4, r4, i4, n4, a4;
            if (0 === t3.length) return !1;
            for(a4 = e5.isIdentifierStartES6, s4 = 0, r4 = t3.length; s4 < r4; ++s4){
                if (55296 <= (i4 = t3.charCodeAt(s4)) && i4 <= 56319) {
                    if ((++s4) >= r4) return !1;
                    if (!(56320 <= (n4 = t3.charCodeAt(s4)) && n4 <= 57343)) return !1;
                    i4 = 1024 * (i4 - 55296) + (n4 - 56320) + 65536;
                }
                if (!a4(i4)) return !1;
                a4 = e5.isIdentifierPartES6;
            }
            return !0;
        }
        t2.exports = {
            isKeywordES5: s3,
            isKeywordES6: r3,
            isReservedWordES5: i3,
            isReservedWordES6: n3,
            isRestrictedWord: function(t3) {
                return "eval" === t3 || "arguments" === t3;
            },
            isIdentifierNameES5: a3,
            isIdentifierNameES6: o3,
            isIdentifierES5: function(t3, e6) {
                return a3(t3) && !i3(t3, e6);
            },
            isIdentifierES6: function(t3, e6) {
                return o3(t3) && !n3(t3, e6);
            }
        };
    })();
});
function he1(t2, e5) {
    if (!t2 || "object" != typeof t2) return !1;
    if (Array.isArray(t2)) return t2.some((t3)=>he1(t3, e5)
    );
    const s3 = e5(t2);
    return "boolean" == typeof s3 ? s3 : Object.keys(t2).some((s4)=>he1(t2[s4], e5)
    );
}
function ce1(t2) {
    return "AssignmentExpression" === t2.type || "BinaryExpression" === t2.type || "LogicalExpression" === t2.type || "NGPipeExpression" === t2.type || "ConditionalExpression" === t2.type || "CallExpression" === t2.type || "OptionalCallExpression" === t2.type || "MemberExpression" === t2.type || "OptionalMemberExpression" === t2.type || "SequenceExpression" === t2.type || "TaggedTemplateExpression" === t2.type || "BindExpression" === t2.type || "UpdateExpression" === t2.type && !t2.prefix || "TSAsExpression" === t2.type || "TSNonNullExpression" === t2.type;
}
function pe1(t2) {
    return "Block" === t2.type || "CommentBlock" === t2.type || "MultiLine" === t2.type;
}
const le1 = new Set([
    "ExportDefaultDeclaration",
    "ExportDefaultSpecifier",
    "DeclareExportDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration"
]);
function de1(t2) {
    return t2 && le1.has(t2.type);
}
function De1(t2) {
    return "BooleanLiteral" === t2.type || "DirectiveLiteral" === t2.type || "Literal" === t2.type || "NullLiteral" === t2.type || "NumericLiteral" === t2.type || "BigIntLiteral" === t2.type || "DecimalLiteral" === t2.type || "RegExpLiteral" === t2.type || "StringLiteral" === t2.type || "TemplateLiteral" === t2.type || "TSTypeLiteral" === t2.type || "JSXText" === t2.type;
}
function me1(t2) {
    return "NumericLiteral" === t2.type || "Literal" === t2.type && "number" == typeof t2.value;
}
function fe1(t2) {
    return "StringLiteral" === t2.type || "Literal" === t2.type && "string" == typeof t2.value;
}
function ye1(t2) {
    return "FunctionExpression" === t2.type || "ArrowFunctionExpression" === t2.type;
}
function Ee2(t2) {
    return !("CallExpression" !== t2.type && "OptionalCallExpression" !== t2.type || "Identifier" !== t2.callee.type || "async" !== t2.callee.name && "inject" !== t2.callee.name && "fakeAsync" !== t2.callee.name);
}
function Ae1(t2) {
    return "JSXElement" === t2.type || "JSXFragment" === t2.type;
}
function Ce1(t2) {
    return "get" === t2.kind || "set" === t2.kind;
}
const Fe1 = new Set([
    "BinaryExpression",
    "LogicalExpression",
    "NGPipeExpression"
]);
const ge1 = new Set([
    "AnyTypeAnnotation",
    "TSAnyKeyword",
    "NullLiteralTypeAnnotation",
    "TSNullKeyword",
    "ThisTypeAnnotation",
    "TSThisType",
    "NumberTypeAnnotation",
    "TSNumberKeyword",
    "VoidTypeAnnotation",
    "TSVoidKeyword",
    "BooleanTypeAnnotation",
    "TSBooleanKeyword",
    "BigIntTypeAnnotation",
    "TSBigIntKeyword",
    "SymbolTypeAnnotation",
    "TSSymbolKeyword",
    "StringTypeAnnotation",
    "TSStringKeyword",
    "BooleanLiteralTypeAnnotation",
    "StringLiteralTypeAnnotation",
    "BigIntLiteralTypeAnnotation",
    "NumberLiteralTypeAnnotation",
    "TSLiteralType",
    "TSTemplateLiteralType",
    "EmptyTypeAnnotation",
    "MixedTypeAnnotation",
    "TSNeverKeyword",
    "TSObjectKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword"
]);
const be1 = /^(skip|[fx]?(it|describe|test))$/;
function Pe1(t2) {
    return "CallExpression" === t2.type || "OptionalCallExpression" === t2.type;
}
const Te1 = new RegExp("([ \n\r\t]+)"), we1 = new RegExp("[^ \n\r\t]");
function Ne1(t2) {
    return /^(\d+|\d+\.\d+)$/.test(t2);
}
function Ie2(t2) {
    return t2.quasis.some((t3)=>t3.value.raw.includes("\n")
    );
}
function ve1(t2) {
    return t2.extra ? t2.extra.raw : t2.raw;
}
const ke1 = {
    "==": !0,
    "!=": !0,
    "===": !0,
    "!==": !0
}, Le1 = {
    "*": !0,
    "/": !0,
    "%": !0
}, Oe = {
    ">>": !0,
    ">>>": !0,
    "<<": !0
};
const Me1 = {
};
function Re2(t2) {
    return Me1[t2];
}
[
    [
        "|>"
    ],
    [
        "??"
    ],
    [
        "||"
    ],
    [
        "&&"
    ],
    [
        "|"
    ],
    [
        "^"
    ],
    [
        "&"
    ],
    [
        "==",
        "===",
        "!=",
        "!=="
    ],
    [
        "<",
        ">",
        "<=",
        ">=",
        "in",
        "instanceof"
    ],
    [
        ">>",
        "<<",
        ">>>"
    ],
    [
        "+",
        "-"
    ],
    [
        "*",
        "/",
        "%"
    ],
    [
        "**"
    ]
].forEach((t2, e5)=>{
    t2.forEach((t3)=>{
        Me1[t3] = e5;
    });
});
const _e1 = new WeakMap;
function je1(t2) {
    if (_e1.has(t2)) return _e1.get(t2);
    const e5 = [];
    return t2.this && e5.push(t2.this), Array.isArray(t2.parameters) ? e5.push(...t2.parameters) : Array.isArray(t2.params) && e5.push(...t2.params), t2.rest && e5.push(t2.rest), _e1.set(t2, e5), e5;
}
const Ue = new WeakMap;
function qe1(t2) {
    return "prettier-ignore" === t2.value.trim();
}
function Ve1(t2) {
    return t2 && (t2.comments && t2.comments.length > 0 && t2.comments.some((t3)=>qe1(t3) && !t3.unignore
    ) || t2.prettierIgnore);
}
function ze(t2) {
    return Ve1(t2.getValue());
}
function xs(t2) {
    return "ArrowFunctionExpression" === t2.type || "FunctionExpression" === t2.type || "FunctionDeclaration" === t2.type || "ObjectMethod" === t2.type || "ClassMethod" === t2.type || "TSDeclareFunction" === t2.type || "TSCallSignatureDeclaration" === t2.type || "TSConstructSignatureDeclaration" === t2.type || "TSMethodSignature" === t2.type || "TSConstructorType" === t2.type || "TSFunctionType" === t2.type || "TSDeclareMethod" === t2.type;
}
function Is(t2) {
    return "CallExpression" === t2.type ? (t2.type = "OptionalCallExpression", t2.callee = Is(t2.callee)) : "MemberExpression" === t2.type ? (t2.type = "OptionalMemberExpression", t2.object = Is(t2.object)) : "TSNonNullExpression" === t2.type && (t2.expression = Is(t2.expression)), t2;
}
function vs(t2, e5) {
    let s3;
    if (Array.isArray(t2)) s3 = t2.entries();
    else {
        if (!t2 || "object" != typeof t2 || "string" != typeof t2.type) return t2;
        s3 = Object.entries(t2);
    }
    for (const [r3, i3] of s3)t2[r3] = vs(i3, e5);
    return Array.isArray(t2) ? t2 : e5(t2) || t2;
}
function ks(t2) {
    return "LogicalExpression" === t2.type && "LogicalExpression" === t2.right.type && t2.operator === t2.right.operator;
}
const Vs1 = /@(?:no)?flow\b/;
const Ks = new Set([
    "Did not expect a type annotation here.",
    "The only accepted module attribute is `type`",
    "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`"
]);
function Js1(t2) {
    const e5 = t2.errors.find((t3)=>(function(t4) {
            const [, e6] = t4.message.match(/(.*?)\s*\(\d+:\d+\)/);
            return Ks.has(e6);
        })(t3)
    );
    if (e5) throw e5;
    return t2;
}
function $s1(e5, s3) {
    switch(e5.type){
        case "ArrayExpression":
            return e5.elements.forEach(r3);
        case "ObjectExpression":
            return e5.properties.forEach(r3);
        case "ObjectProperty":
            if (e5.computed) throw i3("computed");
            if (e5.shorthand) throw i3("shorthand");
            return [
                e5.key,
                e5.value
            ].forEach(r3);
        case "UnaryExpression":
            switch(e5.operator){
                case "+":
                case "-":
                    return r3(e5.argument);
                default:
                    throw i3("operator");
            }
        case "Identifier":
            if (s3 && "ObjectProperty" === s3.type && s3.key === e5) return;
            throw i3();
        case "NullLiteral":
        case "BooleanLiteral":
        case "NumericLiteral":
        case "StringLiteral":
            return;
        default:
            throw i3();
    }
    function r3(t2) {
        return $s1(t2, e5);
    }
    function i3(s4) {
        const r4 = s4 ? "".concat(e5.type, " with ").concat(s4, "=").concat(JSON.stringify(e5[s4])) : e5.type;
        return t1("".concat(r4, " is not allowed in JSON."), {
            start: {
                line: e5.loc.start.line,
                column: e5.loc.start.column + 1
            }
        });
    }
}
function t2(e5, t3, n3) {
    return e5(n3 = {
        path: t3,
        exports: {
        },
        require: function(e6, t4) {
            return function() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == t4 && n3.path);
        }
    }, n3.exports), n3.exports;
}
var n3 = t2(function(e5, t3) {
    function n3(e6) {
        return t3.$0 <= e6 && e6 <= t3.$9;
    }
    Object.defineProperty(t3, "__esModule", {
        value: !0
    }), t3.$EOF = 0, t3.$BSPACE = 8, t3.$TAB = 9, t3.$LF = 10, t3.$VTAB = 11, t3.$FF = 12, t3.$CR = 13, t3.$SPACE = 32, t3.$BANG = 33, t3.$DQ = 34, t3.$HASH = 35, t3.$$ = 36, t3.$PERCENT = 37, t3.$AMPERSAND = 38, t3.$SQ = 39, t3.$LPAREN = 40, t3.$RPAREN = 41, t3.$STAR = 42, t3.$PLUS = 43, t3.$COMMA = 44, t3.$MINUS = 45, t3.$PERIOD = 46, t3.$SLASH = 47, t3.$COLON = 58, t3.$SEMICOLON = 59, t3.$LT = 60, t3.$EQ = 61, t3.$GT = 62, t3.$QUESTION = 63, t3.$0 = 48, t3.$7 = 55, t3.$9 = 57, t3.$A = 65, t3.$E = 69, t3.$F = 70, t3.$X = 88, t3.$Z = 90, t3.$LBRACKET = 91, t3.$BACKSLASH = 92, t3.$RBRACKET = 93, t3.$CARET = 94, t3.$_ = 95, t3.$a = 97, t3.$b = 98, t3.$e = 101, t3.$f = 102, t3.$n = 110, t3.$r = 114, t3.$t = 116, t3.$u = 117, t3.$v = 118, t3.$x = 120, t3.$z = 122, t3.$LBRACE = 123, t3.$BAR = 124, t3.$RBRACE = 125, t3.$NBSP = 160, t3.$PIPE = 124, t3.$TILDA = 126, t3.$AT = 64, t3.$BT = 96, t3.isWhitespace = function(e6) {
        return e6 >= t3.$TAB && e6 <= t3.$SPACE || e6 == t3.$NBSP;
    }, t3.isDigit = n3, t3.isAsciiLetter = function(e6) {
        return e6 >= t3.$a && e6 <= t3.$z || e6 >= t3.$A && e6 <= t3.$Z;
    }, t3.isAsciiHexDigit = function(e6) {
        return e6 >= t3.$a && e6 <= t3.$f || e6 >= t3.$A && e6 <= t3.$F || n3(e6);
    }, t3.isNewLine = function(e6) {
        return e6 === t3.$LF || e6 === t3.$CR;
    }, t3.isOctalDigit = function(e6) {
        return t3.$0 <= e6 && e6 <= t3.$7;
    };
}), r3 = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    class n4 {
        constructor(e6, t4, n5){
            this.filePath = e6, this.name = t4, this.members = n5;
        }
        assertNoMembers() {
            if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
        }
    }
    t3.StaticSymbol = n4;
    t3.StaticSymbolCache = class {
        constructor(){
            this.cache = new Map;
        }
        get(e, t, r) {
            const s3 = (r = r || []).length ? ".".concat(r.join(".")) : "", i3 = '"'.concat(e, '".').concat(t).concat(s3);
            let o3 = this.cache.get(i3);
            return o3 || (o3 = new n4(e, t, r), this.cache.set(i3, o3)), o3;
        }
    };
}), s3 = t2(function(t3, n4) {
    Object.defineProperty(n4, "__esModule", {
        value: !0
    });
    const r4 = /-+([a-z0-9])/g;
    function s3(e5, t4, n5) {
        const r5 = e5.indexOf(t4);
        return -1 == r5 ? n5 : [
            e5.slice(0, r5).trim(),
            e5.slice(r5 + 1).trim()
        ];
    }
    function i3(e5, t4, n5) {
        return Array.isArray(e5) ? t4.visitArray(e5, n5) : "object" == typeof (r5 = e5) && null !== r5 && Object.getPrototypeOf(r5) === u3 ? t4.visitStringMap(e5, n5) : null == e5 || "string" == typeof e5 || "number" == typeof e5 || "boolean" == typeof e5 ? t4.visitPrimitive(e5, n5) : t4.visitOther(e5, n5);
        var r5;
    }
    n4.dashCaseToCamelCase = function(e5) {
        return e5.replace(r4, (...e6)=>e6[1].toUpperCase()
        );
    }, n4.splitAtColon = function(e5, t4) {
        return s3(e5, ":", t4);
    }, n4.splitAtPeriod = function(e5, t4) {
        return s3(e5, ".", t4);
    }, n4.visitValue = i3, n4.isDefined = function(e5) {
        return null != e5;
    }, n4.noUndefined = function(e5) {
        return (void 0) === e5 ? null : e5;
    };
    n4.ValueTransformer = class {
        visitArray(e, t) {
            return e.map((e5)=>i3(e5, this, t)
            );
        }
        visitStringMap(e, t) {
            const n5 = {
            };
            return Object.keys(e).forEach((r5)=>{
                n5[r5] = i3(e[r5], this, t);
            }), n5;
        }
        visitPrimitive(e, t) {
            return e;
        }
        visitOther(e, t) {
            return e;
        }
    }, n4.SyncAsync = {
        assertSync: (e5)=>{
            if (c3(e5)) throw new Error("Illegal state: value cannot be a promise");
            return e5;
        },
        then: (e5, t4)=>c3(e5) ? e5.then(t4) : t4(e5)
        ,
        all: (e5)=>e5.some(c3) ? Promise.all(e5) : e5
    }, n4.error = function(e5) {
        throw new Error("Internal Error: ".concat(e5));
    }, n4.syntaxError = function(e5, t4) {
        const n5 = Error(e5);
        return n5[o3] = !0, t4 && (n5[a3] = t4), n5;
    };
    const o3 = "ngSyntaxError", a3 = "ngParseErrors";
    n4.isSyntaxError = function(e5) {
        return e5[o3];
    }, n4.getParseErrors = function(e5) {
        return e5[a3] || [];
    }, n4.escapeRegExp = function(e5) {
        return e5.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const u3 = Object.getPrototypeOf({
    });
    function c3(e5) {
        return !!e5 && "function" == typeof e5.then;
    }
    n4.utf8Encode = function(e5) {
        let t4 = "";
        for(let n5 = 0; n5 < e5.length; n5++){
            let r5 = e5.charCodeAt(n5);
            if (r5 >= 55296 && r5 <= 56319 && e5.length > n5 + 1) {
                const t6 = e5.charCodeAt(n5 + 1);
                t6 >= 56320 && t6 <= 57343 && (n5++, r5 = (r5 - 55296 << 10) + t6 - 56320 + 65536);
            }
            r5 <= 127 ? t4 += String.fromCharCode(r5) : r5 <= 2047 ? t4 += String.fromCharCode(r5 >> 6 & 31 | 192, 63 & r5 | 128) : r5 <= 65535 ? t4 += String.fromCharCode(r5 >> 12 | 224, r5 >> 6 & 63 | 128, 63 & r5 | 128) : r5 <= 2097151 && (t4 += String.fromCharCode(r5 >> 18 & 7 | 240, r5 >> 12 & 63 | 128, r5 >> 6 & 63 | 128, 63 & r5 | 128));
        }
        return t4;
    }, n4.stringify = function e5(t4) {
        if ("string" == typeof t4) return t4;
        if (t4 instanceof Array) return "[" + t4.map(e5).join(", ") + "]";
        if (null == t4) return "" + t4;
        if (t4.overriddenName) return "".concat(t4.overriddenName);
        if (t4.name) return "".concat(t4.name);
        if (!t4.toString) return "object";
        const n5 = t4.toString();
        if (null == n5) return "" + n5;
        const r5 = n5.indexOf("\n");
        return -1 === r5 ? n5 : n5.substring(0, r5);
    }, n4.resolveForwardRef = function(e6) {
        return "function" == typeof e6 && e6.hasOwnProperty("__forward_ref__") ? e6() : e6;
    }, n4.isPromise = c3;
    n4.Version = class {
        constructor(e6){
            this.full = e6;
            const t4 = e6.split(".");
            this.major = t4[0], this.minor = t4[1], this.patch = t4.slice(2).join(".");
        }
    };
    const l3 = "undefined" != typeof window && window, p3 = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, D2 = (void 0) !== e5 && e5 || l3 || p3;
    n4.global = D2;
}), i3 = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    const n4 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function i3(e6) {
        return e6.replace(/\W/g, "_");
    }
    t3.sanitizeIdentifier = i3;
    let o3 = 0;
    function a3(e6) {
        if (!e6 || !e6.reference) return null;
        const t4 = e6.reference;
        if (t4 instanceof r3.StaticSymbol) return t4.name;
        if (t4.__anonymousType) return t4.__anonymousType;
        let n5 = s3.stringify(t4);
        return (n5.indexOf("(") >= 0 ? (n5 = "anonymous_".concat(o3++), t4.__anonymousType = n5) : n5 = i3(n5), n5);
    }
    var u3;
    t3.identifierName = a3, t3.identifierModuleUrl = function(e6) {
        const t4 = e6.reference;
        return t4 instanceof r3.StaticSymbol ? t4.filePath : "./".concat(s3.stringify(t4));
    }, t3.viewClassName = function(e6, t4) {
        return "View_".concat(a3({
            reference: e6
        }), "_").concat(t4);
    }, t3.rendererTypeName = function(e6) {
        return "RenderType_".concat(a3({
            reference: e6
        }));
    }, t3.hostViewClassName = function(e6) {
        return "HostView_".concat(a3({
            reference: e6
        }));
    }, t3.componentFactoryName = function(e6) {
        return "".concat(a3({
            reference: e6
        }), "NgFactory");
    }, (function(e6) {
        e6[e6.Pipe = 0] = "Pipe", e6[e6.Directive = 1] = "Directive", e6[e6.NgModule = 2] = "NgModule", e6[e6.Injectable = 3] = "Injectable";
    })(u3 = t3.CompileSummaryKind || (t3.CompileSummaryKind = {
    })), t3.tokenName = function(e6) {
        return null != e6.value ? i3(e6.value) : a3(e6.identifier);
    }, t3.tokenReference = function(e6) {
        return null != e6.identifier ? e6.identifier.reference : e6.value;
    };
    t3.CompileStylesheetMetadata = class {
        constructor({ moduleUrl: e6 , styles: t4 , styleUrls: n5  } = {
        }){
            this.moduleUrl = e6 || null, this.styles = l3(t4), this.styleUrls = l3(n5);
        }
    };
    t3.CompileTemplateMetadata = class {
        constructor({ encapsulation: e7 , template: t6 , templateUrl: n6 , htmlAst: r4 , styles: s4 , styleUrls: i4 , externalStylesheets: o4 , animations: a4 , ngContentSelectors: u4 , interpolation: c3 , isInline: D2 , preserveWhitespaces: h2  }){
            if (this.encapsulation = e7, this.template = t6, this.templateUrl = n6, this.htmlAst = r4, this.styles = l3(s4), this.styleUrls = l3(i4), this.externalStylesheets = l3(o4), this.animations = a4 ? p5(a4) : [], this.ngContentSelectors = u4 || [], c3 && 2 != c3.length) throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = c3, this.isInline = D2, this.preserveWhitespaces = h2;
        }
        toSummary() {
            return {
                ngContentSelectors: this.ngContentSelectors,
                encapsulation: this.encapsulation,
                styles: this.styles,
                animations: this.animations
            };
        }
    };
    class c4 {
        static create({ isHost: e , type: t , isComponent: r , selector: i , exportAs: o , changeDetection: a , inputs: u , outputs: l , host: p , providers: D , viewProviders: h , queries: d , guards: f , viewQueries: m , entryComponents: g , template: E , componentViewType: C , rendererType: T , componentFactory: y  }) {
            const S1 = {
            }, _2 = {
            }, b2 = {
            };
            null != p && Object.keys(p).forEach((e8)=>{
                const t7 = p[e8], r5 = e8.match(n4);
                null === r5 ? b2[e8] = t7 : null != r5[1] ? _2[r5[1]] = t7 : null != r5[2] && (S1[r5[2]] = t7);
            });
            const F2 = {
            };
            null != u && u.forEach((e8)=>{
                const t7 = s3.splitAtColon(e8, [
                    e8,
                    e8
                ]);
                F2[t7[0]] = t7[1];
            });
            const A2 = {
            };
            return null != l && l.forEach((e8)=>{
                const t7 = s3.splitAtColon(e8, [
                    e8,
                    e8
                ]);
                A2[t7[0]] = t7[1];
            }), new c4({
                isHost: e,
                type: t,
                isComponent: !!r,
                selector: i,
                exportAs: o,
                changeDetection: a,
                inputs: F2,
                outputs: A2,
                hostListeners: S1,
                hostProperties: _2,
                hostAttributes: b2,
                providers: D,
                viewProviders: h,
                queries: d,
                guards: f,
                viewQueries: m,
                entryComponents: g,
                template: E,
                componentViewType: C,
                rendererType: T,
                componentFactory: y
            });
        }
        constructor({ isHost: e8 , type: t7 , isComponent: n7 , selector: r5 , exportAs: s5 , changeDetection: i5 , inputs: o5 , outputs: a5 , hostListeners: u5 , hostProperties: c5 , hostAttributes: p3 , providers: D4 , viewProviders: h4 , queries: d3 , guards: f3 , viewQueries: m3 , entryComponents: g2 , template: E3 , componentViewType: C2 , rendererType: T2 , componentFactory: y3  }){
            this.isHost = !!e8, this.type = t7, this.isComponent = n7, this.selector = r5, this.exportAs = s5, this.changeDetection = i5, this.inputs = o5, this.outputs = a5, this.hostListeners = u5, this.hostProperties = c5, this.hostAttributes = p3, this.providers = l3(D4), this.viewProviders = l3(h4), this.queries = l3(d3), this.guards = f3, this.viewQueries = l3(m3), this.entryComponents = l3(g2), this.template = E3, this.componentViewType = C2, this.rendererType = T2, this.componentFactory = y3;
        }
        toSummary() {
            return {
                summaryKind: u3.Directive,
                type: this.type,
                isComponent: this.isComponent,
                selector: this.selector,
                exportAs: this.exportAs,
                inputs: this.inputs,
                outputs: this.outputs,
                hostListeners: this.hostListeners,
                hostProperties: this.hostProperties,
                hostAttributes: this.hostAttributes,
                providers: this.providers,
                viewProviders: this.viewProviders,
                queries: this.queries,
                guards: this.guards,
                viewQueries: this.viewQueries,
                entryComponents: this.entryComponents,
                changeDetection: this.changeDetection,
                template: this.template && this.template.toSummary(),
                componentViewType: this.componentViewType,
                rendererType: this.rendererType,
                componentFactory: this.componentFactory
            };
        }
    }
    t3.CompileDirectiveMetadata = c4;
    t3.CompilePipeMetadata = class {
        constructor({ type: e9 , name: t8 , pure: n8  }){
            this.type = e9, this.name = t8, this.pure = !!n8;
        }
        toSummary() {
            return {
                summaryKind: u3.Pipe,
                type: this.type,
                name: this.name,
                pure: this.pure
            };
        }
    };
    t3.CompileShallowModuleMetadata = class {
    };
    t3.CompileNgModuleMetadata = class {
        constructor({ type: e10 , providers: t9 , declaredDirectives: n9 , exportedDirectives: r6 , declaredPipes: s6 , exportedPipes: i6 , entryComponents: o6 , bootstrapComponents: a6 , importedModules: u6 , exportedModules: c6 , schemas: p4 , transitiveModule: D5 , id: h5  }){
            this.type = e10 || null, this.declaredDirectives = l3(n9), this.exportedDirectives = l3(r6), this.declaredPipes = l3(s6), this.exportedPipes = l3(i6), this.providers = l3(t9), this.entryComponents = l3(o6), this.bootstrapComponents = l3(a6), this.importedModules = l3(u6), this.exportedModules = l3(c6), this.schemas = l3(p4), this.id = h5 || null, this.transitiveModule = D5 || null;
        }
        toSummary() {
            const e11 = this.transitiveModule;
            return {
                summaryKind: u3.NgModule,
                type: this.type,
                entryComponents: e11.entryComponents,
                providers: e11.providers,
                modules: e11.modules,
                exportedDirectives: e11.exportedDirectives,
                exportedPipes: e11.exportedPipes
            };
        }
    };
    function l3(e11) {
        return e11 || [];
    }
    t3.TransitiveCompileNgModuleMetadata = class {
        constructor(){
            this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
        }
        addProvider(e, t) {
            this.providers.push({
                provider: e,
                module: t
            });
        }
        addDirective(e) {
            this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e));
        }
        addExportedDirective(e) {
            this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e));
        }
        addPipe(e) {
            this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e));
        }
        addExportedPipe(e) {
            this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e));
        }
        addModule(e) {
            this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e));
        }
        addEntryComponent(e) {
            this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e));
        }
    };
    function p5(e11) {
        return e11.reduce((e12, t10)=>{
            const n10 = Array.isArray(t10) ? p5(t10) : t10;
            return e12.concat(n10);
        }, []);
    }
    function D6(e11) {
        return e11.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t3.ProviderMeta = class {
        constructor(e11, { useClass: t10 , useValue: n10 , useExisting: r7 , useFactory: s7 , deps: i7 , multi: o7  }){
            this.token = e11, this.useClass = t10 || null, this.useValue = n10, this.useExisting = r7, this.useFactory = s7 || null, this.dependencies = i7 || null, this.multi = !!o7;
        }
    }, t3.flatten = p5, t3.templateSourceUrl = function(e12, t11, n11) {
        let s8;
        return s8 = n11.isInline ? t11.type.reference instanceof r3.StaticSymbol ? "".concat(t11.type.reference.filePath, ".").concat(t11.type.reference.name, ".html") : "".concat(a3(e12), "/").concat(a3(t11.type), ".html") : n11.templateUrl, t11.type.reference instanceof r3.StaticSymbol ? s8 : D6(s8);
    }, t3.sharedStylesheetJitUrl = function(e12, t11) {
        const n11 = e12.moduleUrl.split(/\/\\/g), r8 = n11[n11.length - 1];
        return D6("css/".concat(t11).concat(r8, ".ngstyle.js"));
    }, t3.ngModuleJitUrl = function(e12) {
        return D6("".concat(a3(e12.type), "/module.ngfactory.js"));
    }, t3.templateJitUrl = function(e12, t11) {
        return D6("".concat(a3(e12), "/").concat(a3(t11.type), ".ngfactory.js"));
    };
}), o3 = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    class r4 {
        constructor(e6, t4, n4, r5){
            this.file = e6, this.offset = t4, this.line = n4, this.col = r5;
        }
        toString() {
            return null != this.offset ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
        moveBy(e) {
            const t6 = this.file.content, s4 = t6.length;
            let i4 = this.offset, o4 = this.line, a3 = this.col;
            for(; i4 > 0 && e < 0;){
                i4--, e++;
                if (t6.charCodeAt(i4) == n3.$LF) {
                    o4--;
                    const e7 = t6.substr(0, i4 - 1).lastIndexOf(String.fromCharCode(n3.$LF));
                    a3 = e7 > 0 ? i4 - e7 : i4;
                } else a3--;
            }
            for(; i4 < s4 && e > 0;){
                const r6 = t6.charCodeAt(i4);
                i4++, e--, r6 == n3.$LF ? (o4++, a3 = 0) : a3++;
            }
            return new r4(this.file, i4, o4, a3);
        }
        getContext(e, t) {
            const n5 = this.file.content;
            let r6 = this.offset;
            if (null != r6) {
                r6 > n5.length - 1 && (r6 = n5.length - 1);
                let s4 = r6, i4 = 0, o4 = 0;
                for(; i4 < e && r6 > 0 && (r6--, i4++, "\n" != n5[r6] || (++o4) != t););
                for(i4 = 0, o4 = 0; i4 < e && s4 < n5.length - 1 && (s4++, i4++, "\n" != n5[s4] || (++o4) != t););
                return {
                    before: n5.substring(r6, this.offset),
                    after: n5.substring(this.offset, s4 + 1)
                };
            }
            return null;
        }
    }
    t3.ParseLocation = r4;
    class s4 {
        constructor(e7, t6){
            this.content = e7, this.url = t6;
        }
    }
    t3.ParseSourceFile = s4;
    class o4 {
        constructor(e8, t7, n5 = null){
            this.start = e8, this.end = t7, this.details = n5;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var a3;
    t3.ParseSourceSpan = o4, t3.EMPTY_PARSE_LOCATION = new r4(new s4("", ""), 0, 0, 0), t3.EMPTY_SOURCE_SPAN = new o4(t3.EMPTY_PARSE_LOCATION, t3.EMPTY_PARSE_LOCATION), (function(e9) {
        e9[e9.WARNING = 0] = "WARNING", e9[e9.ERROR = 1] = "ERROR";
    })(a3 = t3.ParseErrorLevel || (t3.ParseErrorLevel = {
    }));
    t3.ParseError = class {
        constructor(e9, t8, n6 = a3.ERROR){
            this.span = e9, this.msg = t8, this.level = n6;
        }
        contextualMessage() {
            const e10 = this.span.start.getContext(100, 3);
            return e10 ? "".concat(this.msg, ' ("').concat(e10.before, "[").concat(a3[this.level], " ->]").concat(e10.after, '")') : this.msg;
        }
        toString() {
            const e10 = this.span.details ? ", ".concat(this.span.details) : "";
            return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e10);
        }
    }, t3.typeSourceSpan = function(e10, t9) {
        const n7 = i3.identifierModuleUrl(t9), a4 = null != n7 ? "in ".concat(e10, " ").concat(i3.identifierName(t9), " in ").concat(n7) : "in ".concat(e10, " ").concat(i3.identifierName(t9)), u3 = new s4("", a4);
        return new o4(new r4(u3, -1, -1, -1), new r4(u3, -1, -1, -1));
    }, t3.r3JitTypeSourceSpan = function(e10, t9, n7) {
        const i4 = "in ".concat(e10, " ").concat(t9, " in ").concat(n7), a4 = new s4("", i4);
        return new o4(new r4(a4, -1, -1, -1), new r4(a4, -1, -1, -1));
    };
}), a3 = (e5)=>{
    if ("string" != typeof e5) throw new TypeError("Expected a string");
    return e5.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
function u3(e5) {
    return {
        type: "concat",
        parts: e5
    };
}
function c3(e5) {
    return {
        type: "indent",
        contents: e5
    };
}
function l3(e5, t3) {
    return {
        type: "align",
        contents: t3,
        n: e5
    };
}
function p3(e5, t3) {
    return {
        type: "group",
        id: (t3 = t3 || {
        }).id,
        contents: e5,
        break: !!t3.shouldBreak,
        expandedStates: t3.expandedStates
    };
}
const D2 = {
    type: "break-parent"
}, h2 = u3([
    {
        type: "line",
        hard: !0
    },
    D2
]), d3 = u3([
    {
        type: "line",
        hard: !0,
        literal: !0
    },
    D2
]);
var f3 = {
    concat: u3,
    join: function(e5, t3) {
        const n4 = [];
        for(let r4 = 0; r4 < t3.length; r4++)0 !== r4 && n4.push(e5), n4.push(t3[r4]);
        return u3(n4);
    },
    line: {
        type: "line"
    },
    softline: {
        type: "line",
        soft: !0
    },
    hardline: h2,
    literalline: d3,
    group: p3,
    conditionalGroup: function(e5, t3) {
        return p3(e5[0], Object.assign({
        }, t3, {
            expandedStates: e5
        }));
    },
    fill: function(e5) {
        return {
            type: "fill",
            parts: e5
        };
    },
    lineSuffix: function(e5) {
        return {
            type: "line-suffix",
            contents: e5
        };
    },
    lineSuffixBoundary: {
        type: "line-suffix-boundary"
    },
    cursor: {
        type: "cursor",
        placeholder: Symbol("cursor")
    },
    breakParent: D2,
    ifBreak: function(e5, t3, n4) {
        return {
            type: "if-break",
            breakContents: e5,
            flatContents: t3,
            groupId: (n4 = n4 || {
            }).groupId
        };
    },
    trim: {
        type: "trim"
    },
    indent: c3,
    align: l3,
    addAlignmentToDoc: function(e5, t3, n4) {
        let r4 = e5;
        if (t3 > 0) {
            for(let e6 = 0; e6 < Math.floor(t3 / n4); ++e6)r4 = c3(r4);
            r4 = l3(t3 % n4, r4), r4 = l3(-1 / 0, r4);
        }
        return r4;
    },
    markAsRoot: function(e5) {
        return l3({
            type: "root"
        }, e5);
    },
    dedentToRoot: function(e5) {
        return l3(-1 / 0, e5);
    },
    dedent: function(e5) {
        return l3(-1, e5);
    }
}, m3 = (e5)=>"string" == typeof e5 ? e5.replace((({ onlyFirst: e6 = !1  } = {
    })=>{
        const t3 = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(t3, e6 ? void 0 : "g");
    })(), "") : e5
;
const g2 = (e5)=>!Number.isNaN(e5) && (e5 >= 4352 && (e5 <= 4447 || 9001 === e5 || 9002 === e5 || 11904 <= e5 && e5 <= 12871 && 12351 !== e5 || 12880 <= e5 && e5 <= 19903 || 19968 <= e5 && e5 <= 42182 || 43360 <= e5 && e5 <= 43388 || 44032 <= e5 && e5 <= 55203 || 63744 <= e5 && e5 <= 64255 || 65040 <= e5 && e5 <= 65049 || 65072 <= e5 && e5 <= 65131 || 65281 <= e5 && e5 <= 65376 || 65504 <= e5 && e5 <= 65510 || 110592 <= e5 && e5 <= 110593 || 127488 <= e5 && e5 <= 127569 || 131072 <= e5 && e5 <= 262141))
;
var E3 = g2, C2 = g2;
E3.default = C2;
const T2 = (e5)=>{
    if ("string" != typeof (e5 = e5.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === e5.length) return 0;
    e5 = m3(e5);
    let t3 = 0;
    for(let n4 = 0; n4 < e5.length; n4++){
        const r4 = e5.codePointAt(n4);
        r4 <= 31 || r4 >= 127 && r4 <= 159 || (r4 >= 768 && r4 <= 879 || (r4 > 65535 && n4++, t3 += E3(r4) ? 2 : 1));
    }
    return t3;
};
var y3 = T2, S1 = T2;
y3.default = S1;
function _2(e5, t3) {
    return t3 || (t3 = e5.slice(0)), Object.freeze(Object.defineProperties(e5, {
        raw: {
            value: Object.freeze(t3)
        }
    }));
}
var b2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {
};
function F2() {
    throw new Error("setTimeout has not been defined");
}
function A2() {
    throw new Error("clearTimeout has not been defined");
}
var v2 = F2, w2 = A2;
function k2(e5) {
    if (v2 === setTimeout) return setTimeout(e5, 0);
    if ((v2 === F2 || !v2) && setTimeout) return v2 = setTimeout, setTimeout(e5, 0);
    try {
        return v2(e5, 0);
    } catch (t) {
        try {
            return v2.call(null, e5, 0);
        } catch (t) {
            return v2.call(this, e5, 0);
        }
    }
}
"function" == typeof b2.setTimeout && (v2 = setTimeout), "function" == typeof b2.clearTimeout && (w2 = clearTimeout);
var N2, x2 = [], O1 = !1, R2 = -1;
function B1(e5, t3) {
    this.fun = e5, this.array = t3;
}
B1.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function I1() {
}
var q2 = I1, $1 = I1, M1 = I1, U2 = I1, G1 = I1, V2 = I1, j1 = I1;
var H1 = b2.performance || {
}, X1 = H1.now || H1.mozNow || H1.msNow || H1.oNow || H1.webkitNow || function() {
    return (new Date).getTime();
};
var z1 = new Date;
const Z1 = /^[0-9]+$/, K1 = (e5, t3)=>{
    const n4 = Z1.test(e5), r4 = Z1.test(t3);
    return n4 && r4 && (e5 = +e5, t3 = +t3), e5 === t3 ? 0 : n4 && !r4 ? -1 : r4 && !n4 ? 1 : e5 < t3 ? -1 : 1;
};
var ee1 = {
    compareIdentifiers: K1,
    rcompareIdentifiers: (e5, t3)=>K1(t3, e5)
};
function he2() {
    const e5 = _2([
        "\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "
    ]);
    return he2 = function() {
        return e5;
    }, e5;
}
function de2() {
    const e5 = _2([
        "\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return de2 = function() {
        return e5;
    }, e5;
}
function fe2() {
    const e5 = _2([
        "\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "
    ]);
    return fe2 = function() {
        return e5;
    }, e5;
}
function me2() {
    const e5 = _2([
        "\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "
    ]);
    return me2 = function() {
        return e5;
    }, e5;
}
function ge2() {
    const e5 = _2([
        "\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "
    ]);
    return ge2 = function() {
        return e5;
    }, e5;
}
function Ee1() {
    const e5 = _2([
        "\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "
    ]);
    return Ee1 = function() {
        return e5;
    }, e5;
}
function ve2(e5) {
    return (t3, n4, r4)=>{
        const s4 = r4 && r4.backwards;
        if (!1 === n4) return !1;
        const { length: i4  } = t3;
        let o4 = n4;
        for(; o4 >= 0 && o4 < i4;){
            const n5 = t3.charAt(o4);
            if (e5 instanceof RegExp) {
                if (!e5.test(n5)) return o4;
            } else if (!e5.includes(n5)) return o4;
            s4 ? o4-- : o4++;
        }
        return (-1 === o4 || o4 === i4) && o4;
    };
}
const we2 = ve2(/\s/), ke2 = ve2(" \t"), Ne2 = ve2(",; \t"), xe1 = ve2(/[^\n\r]/);
function Oe1(e5, t3) {
    if (!1 === t3) return !1;
    if ("/" === e5.charAt(t3) && "*" === e5.charAt(t3 + 1)) for(let n4 = t3 + 2; n4 < e5.length; ++n4)if ("*" === e5.charAt(n4) && "/" === e5.charAt(n4 + 1)) return n4 + 2;
    return t3;
}
function Re1(e5, t3) {
    return !1 !== t3 && ("/" === e5.charAt(t3) && "/" === e5.charAt(t3 + 1) ? xe1(e5, t3) : t3);
}
function Le2(e5, t3, n4) {
    const r4 = n4 && n4.backwards;
    if (!1 === t3) return !1;
    const s4 = e5.charAt(t3);
    if (r4) {
        if ("\r" === e5.charAt(t3 - 1) && "\n" === s4) return t3 - 2;
        if ("\n" === s4 || "\r" === s4 || "\u2028" === s4 || "\u2029" === s4) return t3 - 1;
    } else {
        if ("\r" === s4 && "\n" === e5.charAt(t3 + 1)) return t3 + 2;
        if ("\n" === s4 || "\r" === s4 || "\u2028" === s4 || "\u2029" === s4) return t3 + 1;
    }
    return t3;
}
function Pe2(e5, t3, n4) {
    const r4 = ke2(e5, (n4 = n4 || {
    }).backwards ? t3 - 1 : t3, n4);
    return r4 !== Le2(e5, r4, n4);
}
function Be1(e5, t3) {
    let n4 = null, r4 = t3;
    for(; r4 !== n4;)n4 = r4, r4 = Ne2(e5, r4), r4 = Oe1(e5, r4), r4 = ke2(e5, r4);
    return r4 = Re1(e5, r4), r4 = Le2(e5, r4), !1 !== r4 && Pe2(e5, r4);
}
function Ie1(e5, t3) {
    let n4 = null, r4 = t3;
    for(; r4 !== n4;)n4 = r4, r4 = ke2(e5, r4), r4 = Oe1(e5, r4), r4 = Re1(e5, r4), r4 = Le2(e5, r4);
    return r4;
}
function qe2(e5, t3, n4) {
    return Ie1(e5, n4(t3));
}
function $e1(e5, t3, n4) {
    let r4 = 0;
    for(let s4 = n4 = n4 || 0; s4 < e5.length; ++s4)"\t" === e5[s4] ? r4 = r4 + t3 - r4 % t3 : r4++;
    return r4;
}
function Me2(e5, t3) {
    const n4 = e5.slice(1, -1), r4 = {
        quote: '"',
        regex: /"/g
    }, s4 = {
        quote: "'",
        regex: /'/g
    }, i4 = "'" === t3 ? s4 : r4, o4 = i4 === s4 ? r4 : s4;
    let a4 = i4.quote;
    if (n4.includes(i4.quote) || n4.includes(o4.quote)) {
        a4 = (n4.match(i4.regex) || []).length > (n4.match(o4.regex) || []).length ? o4.quote : i4.quote;
    }
    return a4;
}
function Ue1(e5, t3, n4) {
    const r4 = '"' === t3 ? "'" : '"', s4 = e5.replace(/\\([\S\s])|(["'])/g, (e6, s5, i4)=>s5 === r4 ? s5 : i4 === t3 ? "\\" + i4 : i4 || (n4 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(s5) ? s5 : "\\" + s5)
    );
    return t3 + s4 + t3;
}
function Ge(e5, t3) {
    (e5.comments || (e5.comments = [])).push(t3), t3.printed = !1, "JSXText" === e5.type && (t3.printed = !0);
}
var je2 = {
    guessEndOfLine: function(e5) {
        const t3 = e5.indexOf("\r");
        return t3 >= 0 ? "\n" === e5.charAt(t3 + 1) ? "crlf" : "cr" : "lf";
    },
    convertEndOfLineToChars: function(e5) {
        switch(e5){
            case "cr":
                return "\r";
            case "crlf":
                return "\r\n";
            default:
                return "\n";
        }
    },
    countEndOfLineChars: function(e5, t3) {
        let n4;
        if ("\n" === t3) n4 = /\n/g;
        else if ("\r" === t3) n4 = /\r/g;
        else {
            if ("\r\n" !== t3) throw new Error('Unexpected "eol" '.concat(JSON.stringify(t3), "."));
            n4 = /\r\n/g;
        }
        const r4 = e5.match(n4);
        return r4 ? r4.length : 0;
    },
    normalizeEndOfLine: function(e5) {
        return e5.replace(/\r\n?/g, "\n");
    }
};
let Ye;
function Ke(e5, t3, n4) {
    const r4 = "dedent" === t3.type ? e5.queue.slice(0, -1) : e5.queue.concat(t3);
    let s4 = "", i4 = 0, o4 = 0, a4 = 0;
    for (const e6 of r4)switch(e6.type){
        case "indent":
            l4(), n4.useTabs ? u4(1) : c4(n4.tabWidth);
            break;
        case "stringAlign":
            l4(), s4 += e6.n, i4 += e6.n.length;
            break;
        case "numberAlign":
            o4 += 1, a4 += e6.n;
            break;
        default:
            throw new Error("Unexpected type '".concat(e6.type, "'"));
    }
    return p4(), Object.assign({
    }, e5, {
        value: s4,
        length: i4,
        queue: r4
    });
    function u4(e7) {
        s4 += "\t".repeat(e7), i4 += n4.tabWidth * e7;
    }
    function c4(e7) {
        s4 += " ".repeat(e7), i4 += e7;
    }
    function l4() {
        n4.useTabs ? (function() {
            o4 > 0 && u4(o4);
            D4();
        })() : p4();
    }
    function p4() {
        a4 > 0 && c4(a4), D4();
    }
    function D4() {
        o4 = 0, a4 = 0;
    }
}
function et2(e5) {
    if (0 === e5.length) return 0;
    let t3 = 0;
    for(; e5.length > 0 && "string" == typeof e5[e5.length - 1] && e5[e5.length - 1].match(/^[\t ]*$/);)t3 += e5.pop().length;
    if (e5.length && "string" == typeof e5[e5.length - 1]) {
        const n4 = e5[e5.length - 1].replace(/[\t ]*$/, "");
        t3 += e5[e5.length - 1].length - n4.length, e5[e5.length - 1] = n4;
    }
    return t3;
}
const { literalline: rt2 , concat: st1  } = f3, it1 = {
};
function ot1(e5, t3, n4, r4) {
    const s4 = [
        e5
    ];
    for(; 0 !== s4.length;){
        const e6 = s4.pop();
        if (e6 !== it1) {
            if (n4 && s4.push(e6, it1), !t3 || !1 !== t3(e6)) {
                if ("concat" === e6.type || "fill" === e6.type) for(let t4 = e6.parts.length - 1; t4 >= 0; --t4)s4.push(e6.parts[t4]);
                else if ("if-break" === e6.type) e6.flatContents && s4.push(e6.flatContents), e6.breakContents && s4.push(e6.breakContents);
                else if ("group" === e6.type && e6.expandedStates) {
                    if (r4) for(let t6 = e6.expandedStates.length - 1; t6 >= 0; --t6)s4.push(e6.expandedStates[t6]);
                    else s4.push(e6.contents);
                } else e6.contents && s4.push(e6.contents);
            }
        } else n4(s4.pop());
    }
}
function at1(e5, t3) {
    if ("concat" === e5.type || "fill" === e5.type) {
        const n4 = e5.parts.map((e6)=>at1(e6, t3)
        );
        return t3(Object.assign({
        }, e5, {
            parts: n4
        }));
    }
    if ("if-break" === e5.type) {
        const n4 = e5.breakContents && at1(e5.breakContents, t3), r4 = e5.flatContents && at1(e5.flatContents, t3);
        return t3(Object.assign({
        }, e5, {
            breakContents: n4,
            flatContents: r4
        }));
    }
    if (e5.contents) {
        const n4 = at1(e5.contents, t3);
        return t3(Object.assign({
        }, e5, {
            contents: n4
        }));
    }
    return t3(e5);
}
function ut1(e5, t3, n4) {
    let r4 = n4, s4 = !1;
    return ot1(e5, function(e6) {
        const n5 = t3(e6);
        if (((void 0) !== n5 && (s4 = !0, r4 = n5), s4)) return !1;
    }), r4;
}
function ct(e5) {
    return "string" != typeof e5 && ("line" === e5.type || void 0);
}
function lt(e5) {
    return !("group" !== e5.type || !e5.break) || (!("line" !== e5.type || !e5.hard) || ("break-parent" === e5.type || void 0));
}
function pt(e5) {
    if (e5.length > 0) {
        const t3 = e5[e5.length - 1];
        t3.expandedStates || (t3.break = !0);
    }
    return null;
}
function Dt1(e5) {
    return "line" !== e5.type || e5.hard ? "if-break" === e5.type ? e5.flatContents || "" : e5 : e5.soft ? "" : " ";
}
function ht1(e5) {
    const t3 = [], n4 = e5.filter(Boolean);
    for(; 0 !== n4.length;){
        const e6 = n4.shift();
        e6 && ("concat" !== e6.type ? 0 === t3.length || "string" != typeof t3[t3.length - 1] || "string" != typeof e6 ? t3.push(e6) : t3[t3.length - 1] += e6 : n4.unshift(...e6.parts));
    }
    return t3;
}
function dt(e5) {
    if ("concat" === e5.type) {
        const t3 = [];
        for(let n4 = 0; n4 < e5.parts.length; ++n4){
            const r4 = e5.parts[n4];
            if ("string" != typeof r4 && "concat" === r4.type) t3.push(...dt(r4).parts);
            else {
                const e6 = dt(r4);
                "" !== e6 && t3.push(e6);
            }
        }
        return Object.assign({
        }, e5, {
            parts: t3
        });
    }
    return "if-break" === e5.type ? Object.assign({
    }, e5, {
        breakContents: null != e5.breakContents ? dt(e5.breakContents) : null,
        flatContents: null != e5.flatContents ? dt(e5.flatContents) : null
    }) : "group" === e5.type ? Object.assign({
    }, e5, {
        contents: dt(e5.contents),
        expandedStates: e5.expandedStates ? e5.expandedStates.map(dt) : e5.expandedStates
    }) : e5.contents ? Object.assign({
    }, e5, {
        contents: dt(e5.contents)
    }) : e5;
}
function ft1(e5) {
    if ("string" == typeof e5) return JSON.stringify(e5);
    if ("line" === e5.type) return e5.literal ? "literalline" : e5.hard ? "hardline" : e5.soft ? "softline" : "line";
    if ("break-parent" === e5.type) return "breakParent";
    if ("trim" === e5.type) return "trim";
    if ("concat" === e5.type) return "[" + e5.parts.map(ft1).join(", ") + "]";
    if ("indent" === e5.type) return "indent(" + ft1(e5.contents) + ")";
    if ("align" === e5.type) return e5.n === -1 / 0 ? "dedentToRoot(" + ft1(e5.contents) + ")" : e5.n < 0 ? "dedent(" + ft1(e5.contents) + ")" : "root" === e5.n.type ? "markAsRoot(" + ft1(e5.contents) + ")" : "align(" + JSON.stringify(e5.n) + ", " + ft1(e5.contents) + ")";
    if ("if-break" === e5.type) return "ifBreak(" + ft1(e5.breakContents) + (e5.flatContents ? ", " + ft1(e5.flatContents) : "") + ")";
    if ("group" === e5.type) return e5.expandedStates ? "conditionalGroup([" + e5.expandedStates.map(ft1).join(",") + "])" : (e5.break ? "wrappedGroup" : "group") + "(" + ft1(e5.contents) + ")";
    if ("fill" === e5.type) return "fill(" + e5.parts.map(ft1).join(", ") + ")";
    if ("line-suffix" === e5.type) return "lineSuffix(" + ft1(e5.contents) + ")";
    if ("line-suffix-boundary" === e5.type) return "lineSuffixBoundary";
    throw new Error("Unknown doc type " + e5.type);
}
var _t = {
    "*": [
        "accesskey",
        "autocapitalize",
        "autofocus",
        "class",
        "contenteditable",
        "dir",
        "draggable",
        "enterkeyhint",
        "hidden",
        "id",
        "inputmode",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemscope",
        "itemtype",
        "lang",
        "nonce",
        "slot",
        "spellcheck",
        "style",
        "tabindex",
        "title",
        "translate"
    ],
    a: [
        "accesskey",
        "charset",
        "coords",
        "download",
        "href",
        "hreflang",
        "name",
        "ping",
        "referrerpolicy",
        "rel",
        "rev",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    abbr: [
        "title"
    ],
    applet: [
        "align",
        "alt",
        "archive",
        "code",
        "codebase",
        "height",
        "hspace",
        "name",
        "object",
        "vspace",
        "width"
    ],
    area: [
        "accesskey",
        "alt",
        "coords",
        "download",
        "href",
        "hreflang",
        "nohref",
        "ping",
        "referrerpolicy",
        "rel",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
    ],
    base: [
        "href",
        "target"
    ],
    basefont: [
        "color",
        "face",
        "size"
    ],
    bdo: [
        "dir"
    ],
    blockquote: [
        "cite"
    ],
    body: [
        "alink",
        "background",
        "bgcolor",
        "link",
        "text",
        "vlink"
    ],
    br: [
        "clear"
    ],
    button: [
        "accesskey",
        "autofocus",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "name",
        "tabindex",
        "type",
        "value"
    ],
    canvas: [
        "height",
        "width"
    ],
    caption: [
        "align"
    ],
    col: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    colgroup: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    data: [
        "value"
    ],
    del: [
        "cite",
        "datetime"
    ],
    details: [
        "open"
    ],
    dfn: [
        "title"
    ],
    dialog: [
        "open"
    ],
    dir: [
        "compact"
    ],
    div: [
        "align"
    ],
    dl: [
        "compact"
    ],
    embed: [
        "height",
        "src",
        "type",
        "width"
    ],
    fieldset: [
        "disabled",
        "form",
        "name"
    ],
    font: [
        "color",
        "face",
        "size"
    ],
    form: [
        "accept",
        "accept-charset",
        "action",
        "autocomplete",
        "enctype",
        "method",
        "name",
        "novalidate",
        "target"
    ],
    frame: [
        "frameborder",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "noresize",
        "scrolling",
        "src"
    ],
    frameset: [
        "cols",
        "rows"
    ],
    h1: [
        "align"
    ],
    h2: [
        "align"
    ],
    h3: [
        "align"
    ],
    h4: [
        "align"
    ],
    h5: [
        "align"
    ],
    h6: [
        "align"
    ],
    head: [
        "profile"
    ],
    hr: [
        "align",
        "noshade",
        "size",
        "width"
    ],
    html: [
        "manifest",
        "version"
    ],
    iframe: [
        "align",
        "allow",
        "allowfullscreen",
        "allowpaymentrequest",
        "allowusermedia",
        "frameborder",
        "height",
        "loading",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "referrerpolicy",
        "sandbox",
        "scrolling",
        "src",
        "srcdoc",
        "width"
    ],
    img: [
        "align",
        "alt",
        "border",
        "crossorigin",
        "decoding",
        "height",
        "hspace",
        "ismap",
        "loading",
        "longdesc",
        "name",
        "referrerpolicy",
        "sizes",
        "src",
        "srcset",
        "usemap",
        "vspace",
        "width"
    ],
    input: [
        "accept",
        "accesskey",
        "align",
        "alt",
        "autocomplete",
        "autofocus",
        "checked",
        "dirname",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "height",
        "ismap",
        "list",
        "max",
        "maxlength",
        "min",
        "minlength",
        "multiple",
        "name",
        "pattern",
        "placeholder",
        "readonly",
        "required",
        "size",
        "src",
        "step",
        "tabindex",
        "title",
        "type",
        "usemap",
        "value",
        "width"
    ],
    ins: [
        "cite",
        "datetime"
    ],
    isindex: [
        "prompt"
    ],
    label: [
        "accesskey",
        "for",
        "form"
    ],
    legend: [
        "accesskey",
        "align"
    ],
    li: [
        "type",
        "value"
    ],
    link: [
        "as",
        "charset",
        "color",
        "crossorigin",
        "disabled",
        "href",
        "hreflang",
        "imagesizes",
        "imagesrcset",
        "integrity",
        "media",
        "nonce",
        "referrerpolicy",
        "rel",
        "rev",
        "sizes",
        "target",
        "title",
        "type"
    ],
    map: [
        "name"
    ],
    menu: [
        "compact"
    ],
    meta: [
        "charset",
        "content",
        "http-equiv",
        "name",
        "scheme"
    ],
    meter: [
        "high",
        "low",
        "max",
        "min",
        "optimum",
        "value"
    ],
    object: [
        "align",
        "archive",
        "border",
        "classid",
        "codebase",
        "codetype",
        "data",
        "declare",
        "form",
        "height",
        "hspace",
        "name",
        "standby",
        "tabindex",
        "type",
        "typemustmatch",
        "usemap",
        "vspace",
        "width"
    ],
    ol: [
        "compact",
        "reversed",
        "start",
        "type"
    ],
    optgroup: [
        "disabled",
        "label"
    ],
    option: [
        "disabled",
        "label",
        "selected",
        "value"
    ],
    output: [
        "for",
        "form",
        "name"
    ],
    p: [
        "align"
    ],
    param: [
        "name",
        "type",
        "value",
        "valuetype"
    ],
    pre: [
        "width"
    ],
    progress: [
        "max",
        "value"
    ],
    q: [
        "cite"
    ],
    script: [
        "async",
        "charset",
        "crossorigin",
        "defer",
        "integrity",
        "language",
        "nomodule",
        "nonce",
        "referrerpolicy",
        "src",
        "type"
    ],
    select: [
        "autocomplete",
        "autofocus",
        "disabled",
        "form",
        "multiple",
        "name",
        "required",
        "size",
        "tabindex"
    ],
    slot: [
        "name"
    ],
    source: [
        "media",
        "sizes",
        "src",
        "srcset",
        "type"
    ],
    style: [
        "media",
        "nonce",
        "title",
        "type"
    ],
    table: [
        "align",
        "bgcolor",
        "border",
        "cellpadding",
        "cellspacing",
        "frame",
        "rules",
        "summary",
        "width"
    ],
    tbody: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    td: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    textarea: [
        "accesskey",
        "autocomplete",
        "autofocus",
        "cols",
        "dirname",
        "disabled",
        "form",
        "maxlength",
        "minlength",
        "name",
        "placeholder",
        "readonly",
        "required",
        "rows",
        "tabindex",
        "wrap"
    ],
    tfoot: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    th: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    thead: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    time: [
        "datetime"
    ],
    tr: [
        "align",
        "bgcolor",
        "char",
        "charoff",
        "valign"
    ],
    track: [
        "default",
        "kind",
        "label",
        "src",
        "srclang"
    ],
    ul: [
        "compact",
        "type"
    ],
    video: [
        "autoplay",
        "controls",
        "crossorigin",
        "height",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "width"
    ]
};
function Lt1(e5) {
    const t3 = Object.create(null);
    for (const n4 of e5)t3[n4] = !0;
    return t3;
}
function Bt2(e5) {
    if ("attribute" === e5.type) return !1;
    if (!e5.parent) return !1;
    if ("number" != typeof e5.index || 0 === e5.index) return !1;
    return (function(e6) {
        return "comment" === e6.type && "prettier-ignore" === e6.value.trim();
    })(e5.parent.children[e5.index - 1]);
}
function $t2(e5) {
    return "element" === e5.type && 0 !== e5.children.length && ([
        "html",
        "head",
        "ul",
        "ol",
        "select"
    ].includes(e5.name) || e5.cssDisplay.startsWith("table") && "table-cell" !== e5.cssDisplay);
}
function Gt2(e5) {
    return e5.hasLeadingSpaces && (e5.prev ? e5.prev.sourceSpan.end.line < e5.sourceSpan.start.line : "root" === e5.parent.type || e5.parent.startSourceSpan.end.line < e5.sourceSpan.start.line);
}
function Vt1(e5) {
    return e5.hasTrailingSpaces && (e5.next ? e5.next.sourceSpan.start.line > e5.sourceSpan.end.line : "root" === e5.parent.type || e5.parent.endSourceSpan && e5.parent.endSourceSpan.start.line > e5.sourceSpan.end.line);
}
function jt1(e5) {
    switch(e5.type){
        case "ieConditionalComment":
        case "comment":
        case "directive":
            return !0;
        case "element":
            return [
                "script",
                "select"
            ].includes(e5.name);
    }
    return !1;
}
function Ht1(e5) {
    const { type: t3 , lang: n4  } = e5.attrMap;
    return "module" === t3 || "text/javascript" === t3 || "text/babel" === t3 || "application/javascript" === t3 || "jsx" === n4 ? "babel" : "application/x-typescript" === t3 || "ts" === n4 || "tsx" === n4 ? "typescript" : "text/markdown" === t3 ? "markdown" : "text/html" === t3 ? "html" : t3 && (t3.endsWith("json") || t3.endsWith("importmap")) ? "json" : "text/x-handlebars-template" === t3 ? "glimmer" : void 0;
}
function Xt2(e5) {
    return "block" === e5 || "list-item" === e5 || e5.startsWith("table");
}
function Wt(e5) {
    return "element" === e5.type && !e5.hasExplicitNamespace && ![
        "html",
        "svg"
    ].includes(e5.namespace);
}
const Yt2 = new Set([
    "template",
    "style",
    "script"
]);
function Zt1(e5, t3) {
    return "vue" === t3.parser && "element" === e5.type && "root" === e5.parent.type && "html" !== e5.fullName.toLowerCase();
}
var tn1 = {
    hasPragma: function(e5) {
        return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e5);
    },
    insertPragma: function(e5) {
        return "\x3c!-- @format --\x3e\n\n" + e5.replace(/^\s*\n/, "");
    }
};
const nn1 = {
    attrs: !0,
    children: !0
};
function sn1(e5, t3) {
    const n4 = e5.map(t3);
    return n4.some((t4, n5)=>t4 !== e5[n5]
    ) ? n4 : e5;
}
function on1(e5, t3) {
    const n4 = Object.keys(t3).reduce((e6, n5)=>(e6[n5] = {
            value: t3[n5],
            enumerable: !1
        }, e6)
    , {
    });
    Object.defineProperties(e5, n4);
}
const { ParseSourceSpan: un1  } = o3, cn1 = [
    [
        /^(\[if([^\]]*?)]>)([\S\s]*?)<!\s*\[endif]$/,
        function(e5, t3, n4) {
            const [, r4, s4, i4] = n4, o4 = "\x3c!--".length + r4.length, a4 = e5.sourceSpan.start.moveBy(o4), u4 = a4.moveBy(i4.length), [c4, l4] = (()=>{
                try {
                    return [
                        !0,
                        t3(i4, a4).children
                    ];
                } catch (e) {
                    return [
                        !1,
                        [
                            {
                                type: "text",
                                value: i4,
                                sourceSpan: new un1(a4, u4)
                            }
                        ]
                    ];
                }
            })();
            return {
                type: "ieConditionalComment",
                complete: c4,
                children: l4,
                condition: s4.trim().replace(/\s+/g, " "),
                sourceSpan: e5.sourceSpan,
                startSourceSpan: new un1(e5.sourceSpan.start, a4),
                endSourceSpan: new un1(u4, e5.sourceSpan.end)
            };
        }
    ],
    [
        /^\[if([^\]]*?)]><!$/,
        function(e5, t3, n4) {
            const [, r4] = n4;
            return {
                type: "ieConditionalStartComment",
                condition: r4.trim().replace(/\s+/g, " "),
                sourceSpan: e5.sourceSpan
            };
        }
    ],
    [
        /^<!\s*\[endif]$/,
        function(e5) {
            return {
                type: "ieConditionalEndComment",
                sourceSpan: e5.sourceSpan
            };
        }
    ]
];
var ln1 = {
    parseIeConditionalComment: function(e5, t3) {
        if (e5.value) {
            let n4;
            for (const [r4, s4] of cn1)if (n4 = e5.value.match(r4)) return s4(e5, t3, n4);
        }
        return null;
    }
};
var pn = {
    locStart: function(e5) {
        return e5.sourceSpan.start.offset;
    },
    locEnd: function(e5) {
        return e5.sourceSpan.end.offset;
    }
}, Dn = t2(function(e5, t3) {
    function n4(e6) {
        if (":" != e6[0]) return [
            null,
            e6
        ];
        const t4 = e6.indexOf(":", 1);
        if (-1 == t4) throw new Error('Unsupported format "'.concat(e6, '" expecting ":namespace:name"'));
        return [
            e6.slice(1, t4),
            e6.slice(t4 + 1)
        ];
    }
    Object.defineProperty(t3, "__esModule", {
        value: !0
    }), (function(e6) {
        e6[e6.RAW_TEXT = 0] = "RAW_TEXT", e6[e6.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e6[e6.PARSABLE_DATA = 2] = "PARSABLE_DATA";
    })(t3.TagContentType || (t3.TagContentType = {
    })), t3.splitNsName = n4, t3.isNgContainer = function(e6) {
        return "ng-container" === n4(e6)[1];
    }, t3.isNgContent = function(e6) {
        return "ng-content" === n4(e6)[1];
    }, t3.isNgTemplate = function(e6) {
        return "ng-template" === n4(e6)[1];
    }, t3.getNsPrefix = function(e6) {
        return null === e6 ? null : n4(e6)[0];
    }, t3.mergeNsAndName = function(e6, t4) {
        return e6 ? ":".concat(e6, ":").concat(t4) : t4;
    }, t3.NAMED_ENTITIES = {
        Aacute: "\xc1",
        aacute: "\xe1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223e",
        acd: "\u223f",
        acE: "\u223e\u0333",
        Acirc: "\xc2",
        acirc: "\xe2",
        acute: "\xb4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xc6",
        aelig: "\xe6",
        af: "\u2061",
        Afr: "\ud835\udd04",
        afr: "\ud835\udd1e",
        Agrave: "\xc0",
        agrave: "\xe0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03b1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2a3f",
        AMP: "&",
        amp: "&",
        And: "\u2a53",
        and: "\u2227",
        andand: "\u2a55",
        andd: "\u2a5c",
        andslope: "\u2a58",
        andv: "\u2a5a",
        ang: "\u2220",
        ange: "\u29a4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29a8",
        angmsdab: "\u29a9",
        angmsdac: "\u29aa",
        angmsdad: "\u29ab",
        angmsdae: "\u29ac",
        angmsdaf: "\u29ad",
        angmsdag: "\u29ae",
        angmsdah: "\u29af",
        angrt: "\u221f",
        angrtvb: "\u22be",
        angrtvbd: "\u299d",
        angsph: "\u2222",
        angst: "\xc5",
        angzarr: "\u237c",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\ud835\udd38",
        aopf: "\ud835\udd52",
        ap: "\u2248",
        apacir: "\u2a6f",
        apE: "\u2a70",
        ape: "\u224a",
        apid: "\u224b",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224a",
        Aring: "\xc5",
        aring: "\xe5",
        Ascr: "\ud835\udc9c",
        ascr: "\ud835\udcb6",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224d",
        Atilde: "\xc3",
        atilde: "\xe3",
        Auml: "\xc4",
        auml: "\xe4",
        awconint: "\u2233",
        awint: "\u2a11",
        backcong: "\u224c",
        backepsilon: "\u03f6",
        backprime: "\u2035",
        backsim: "\u223d",
        backsimeq: "\u22cd",
        Backslash: "\u2216",
        Barv: "\u2ae7",
        barvee: "\u22bd",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23b5",
        bbrktbrk: "\u23b6",
        bcong: "\u224c",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201e",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29b0",
        bepsi: "\u03f6",
        bernou: "\u212c",
        Bernoullis: "\u212c",
        Beta: "\u0392",
        beta: "\u03b2",
        beth: "\u2136",
        between: "\u226c",
        Bfr: "\ud835\udd05",
        bfr: "\ud835\udd1f",
        bigcap: "\u22c2",
        bigcirc: "\u25ef",
        bigcup: "\u22c3",
        bigodot: "\u2a00",
        bigoplus: "\u2a01",
        bigotimes: "\u2a02",
        bigsqcup: "\u2a06",
        bigstar: "\u2605",
        bigtriangledown: "\u25bd",
        bigtriangleup: "\u25b3",
        biguplus: "\u2a04",
        bigvee: "\u22c1",
        bigwedge: "\u22c0",
        bkarow: "\u290d",
        blacklozenge: "\u29eb",
        blacksquare: "\u25aa",
        blacktriangle: "\u25b4",
        blacktriangledown: "\u25be",
        blacktriangleleft: "\u25c2",
        blacktriangleright: "\u25b8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20e5",
        bnequiv: "\u2261\u20e5",
        bNot: "\u2aed",
        bnot: "\u2310",
        Bopf: "\ud835\udd39",
        bopf: "\ud835\udd53",
        bot: "\u22a5",
        bottom: "\u22a5",
        bowtie: "\u22c8",
        boxbox: "\u29c9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250c",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252c",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229f",
        boxplus: "\u229e",
        boxtimes: "\u22a0",
        boxUL: "\u255d",
        boxUl: "\u255c",
        boxuL: "\u255b",
        boxul: "\u2518",
        boxUR: "\u255a",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256c",
        boxVh: "\u256b",
        boxvH: "\u256a",
        boxvh: "\u253c",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255f",
        boxvR: "\u255e",
        boxvr: "\u251c",
        bprime: "\u2035",
        Breve: "\u02d8",
        breve: "\u02d8",
        brvbar: "\xa6",
        Bscr: "\u212c",
        bscr: "\ud835\udcb7",
        bsemi: "\u204f",
        bsim: "\u223d",
        bsime: "\u22cd",
        bsol: "\\",
        bsolb: "\u29c5",
        bsolhsub: "\u27c8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224e",
        bumpE: "\u2aae",
        bumpe: "\u224f",
        Bumpeq: "\u224e",
        bumpeq: "\u224f",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22d2",
        cap: "\u2229",
        capand: "\u2a44",
        capbrcup: "\u2a49",
        capcap: "\u2a4b",
        capcup: "\u2a47",
        capdot: "\u2a40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\ufe00",
        caret: "\u2041",
        caron: "\u02c7",
        Cayleys: "\u212d",
        ccaps: "\u2a4d",
        Ccaron: "\u010c",
        ccaron: "\u010d",
        Ccedil: "\xc7",
        ccedil: "\xe7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2a4c",
        ccupssm: "\u2a50",
        Cdot: "\u010a",
        cdot: "\u010b",
        cedil: "\xb8",
        Cedilla: "\xb8",
        cemptyv: "\u29b2",
        cent: "\xa2",
        CenterDot: "\xb7",
        centerdot: "\xb7",
        Cfr: "\u212d",
        cfr: "\ud835\udd20",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03a7",
        chi: "\u03c7",
        cir: "\u25cb",
        circ: "\u02c6",
        circeq: "\u2257",
        circlearrowleft: "\u21ba",
        circlearrowright: "\u21bb",
        circledast: "\u229b",
        circledcirc: "\u229a",
        circleddash: "\u229d",
        CircleDot: "\u2299",
        circledR: "\xae",
        circledS: "\u24c8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29c3",
        cire: "\u2257",
        cirfnint: "\u2a10",
        cirmid: "\u2aef",
        cirscir: "\u29c2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201d",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2a74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2a6d",
        Congruent: "\u2261",
        Conint: "\u222f",
        conint: "\u222e",
        ContourIntegral: "\u222e",
        Copf: "\u2102",
        copf: "\ud835\udd54",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xa9",
        copy: "\xa9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21b5",
        Cross: "\u2a2f",
        cross: "\u2717",
        Cscr: "\ud835\udc9e",
        cscr: "\ud835\udcb8",
        csub: "\u2acf",
        csube: "\u2ad1",
        csup: "\u2ad0",
        csupe: "\u2ad2",
        ctdot: "\u22ef",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22de",
        cuesc: "\u22df",
        cularr: "\u21b6",
        cularrp: "\u293d",
        Cup: "\u22d3",
        cup: "\u222a",
        cupbrcap: "\u2a48",
        CupCap: "\u224d",
        cupcap: "\u2a46",
        cupcup: "\u2a4a",
        cupdot: "\u228d",
        cupor: "\u2a45",
        cups: "\u222a\ufe00",
        curarr: "\u21b7",
        curarrm: "\u293c",
        curlyeqprec: "\u22de",
        curlyeqsucc: "\u22df",
        curlyvee: "\u22ce",
        curlywedge: "\u22cf",
        curren: "\xa4",
        curvearrowleft: "\u21b6",
        curvearrowright: "\u21b7",
        cuvee: "\u22ce",
        cuwed: "\u22cf",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232d",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21a1",
        dArr: "\u21d3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2ae4",
        dashv: "\u22a3",
        dbkarow: "\u290f",
        dblac: "\u02dd",
        Dcaron: "\u010e",
        dcaron: "\u010f",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21ca",
        DDotrahd: "\u2911",
        ddotseq: "\u2a77",
        deg: "\xb0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03b4",
        demptyv: "\u29b1",
        dfisht: "\u297f",
        Dfr: "\ud835\udd07",
        dfr: "\ud835\udd21",
        dHar: "\u2965",
        dharl: "\u21c3",
        dharr: "\u21c2",
        DiacriticalAcute: "\xb4",
        DiacriticalDot: "\u02d9",
        DiacriticalDoubleAcute: "\u02dd",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02dc",
        diam: "\u22c4",
        Diamond: "\u22c4",
        diamond: "\u22c4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xa8",
        DifferentialD: "\u2146",
        digamma: "\u03dd",
        disin: "\u22f2",
        div: "\xf7",
        divide: "\xf7",
        divideontimes: "\u22c7",
        divonx: "\u22c7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231e",
        dlcrop: "\u230d",
        dollar: "$",
        Dopf: "\ud835\udd3b",
        dopf: "\ud835\udd55",
        Dot: "\xa8",
        dot: "\u02d9",
        DotDot: "\u20dc",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22a1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222f",
        DoubleDot: "\xa8",
        DoubleDownArrow: "\u21d3",
        DoubleLeftArrow: "\u21d0",
        DoubleLeftRightArrow: "\u21d4",
        DoubleLeftTee: "\u2ae4",
        DoubleLongLeftArrow: "\u27f8",
        DoubleLongLeftRightArrow: "\u27fa",
        DoubleLongRightArrow: "\u27f9",
        DoubleRightArrow: "\u21d2",
        DoubleRightTee: "\u22a8",
        DoubleUpArrow: "\u21d1",
        DoubleUpDownArrow: "\u21d5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21d3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21f5",
        DownBreve: "\u0311",
        downdownarrows: "\u21ca",
        downharpoonleft: "\u21c3",
        downharpoonright: "\u21c2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295e",
        DownLeftVector: "\u21bd",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295f",
        DownRightVector: "\u21c1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22a4",
        DownTeeArrow: "\u21a7",
        drbkarow: "\u2910",
        drcorn: "\u231f",
        drcrop: "\u230c",
        Dscr: "\ud835\udc9f",
        dscr: "\ud835\udcb9",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29f6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22f1",
        dtri: "\u25bf",
        dtrif: "\u25be",
        duarr: "\u21f5",
        duhar: "\u296f",
        dwangle: "\u29a6",
        DZcy: "\u040f",
        dzcy: "\u045f",
        dzigrarr: "\u27ff",
        Eacute: "\xc9",
        eacute: "\xe9",
        easter: "\u2a6e",
        Ecaron: "\u011a",
        ecaron: "\u011b",
        ecir: "\u2256",
        Ecirc: "\xca",
        ecirc: "\xea",
        ecolon: "\u2255",
        Ecy: "\u042d",
        ecy: "\u044d",
        eDDot: "\u2a77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\ud835\udd08",
        efr: "\ud835\udd22",
        eg: "\u2a9a",
        Egrave: "\xc8",
        egrave: "\xe8",
        egs: "\u2a96",
        egsdot: "\u2a98",
        el: "\u2a99",
        Element: "\u2208",
        elinters: "\u23e7",
        ell: "\u2113",
        els: "\u2a95",
        elsdot: "\u2a97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25fb",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25ab",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014a",
        eng: "\u014b",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\ud835\udd3c",
        eopf: "\ud835\udd56",
        epar: "\u22d5",
        eparsl: "\u29e3",
        eplus: "\u2a71",
        epsi: "\u03b5",
        Epsilon: "\u0395",
        epsilon: "\u03b5",
        epsiv: "\u03f5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2a96",
        eqslantless: "\u2a95",
        Equal: "\u2a75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225f",
        Equilibrium: "\u21cc",
        equiv: "\u2261",
        equivDD: "\u2a78",
        eqvparsl: "\u29e5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212f",
        esdot: "\u2250",
        Esim: "\u2a73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03b7",
        ETH: "\xd0",
        eth: "\xf0",
        Euml: "\xcb",
        euml: "\xeb",
        euro: "\u20ac",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\ufb03",
        fflig: "\ufb00",
        ffllig: "\ufb04",
        Ffr: "\ud835\udd09",
        ffr: "\ud835\udd23",
        filig: "\ufb01",
        FilledSmallSquare: "\u25fc",
        FilledVerySmallSquare: "\u25aa",
        fjlig: "fj",
        flat: "\u266d",
        fllig: "\ufb02",
        fltns: "\u25b1",
        fnof: "\u0192",
        Fopf: "\ud835\udd3d",
        fopf: "\ud835\udd57",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22d4",
        forkv: "\u2ad9",
        Fouriertrf: "\u2131",
        fpartint: "\u2a0d",
        frac12: "\xbd",
        frac13: "\u2153",
        frac14: "\xbc",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215b",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xbe",
        frac35: "\u2157",
        frac38: "\u215c",
        frac45: "\u2158",
        frac56: "\u215a",
        frac58: "\u215d",
        frac78: "\u215e",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\ud835\udcbb",
        gacute: "\u01f5",
        Gamma: "\u0393",
        gamma: "\u03b3",
        Gammad: "\u03dc",
        gammad: "\u03dd",
        gap: "\u2a86",
        Gbreve: "\u011e",
        gbreve: "\u011f",
        Gcedil: "\u0122",
        Gcirc: "\u011c",
        gcirc: "\u011d",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2a8c",
        gel: "\u22db",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2a7e",
        ges: "\u2a7e",
        gescc: "\u2aa9",
        gesdot: "\u2a80",
        gesdoto: "\u2a82",
        gesdotol: "\u2a84",
        gesl: "\u22db\ufe00",
        gesles: "\u2a94",
        Gfr: "\ud835\udd0a",
        gfr: "\ud835\udd24",
        Gg: "\u22d9",
        gg: "\u226b",
        ggg: "\u22d9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2aa5",
        glE: "\u2a92",
        glj: "\u2aa4",
        gnap: "\u2a8a",
        gnapprox: "\u2a8a",
        gnE: "\u2269",
        gne: "\u2a88",
        gneq: "\u2a88",
        gneqq: "\u2269",
        gnsim: "\u22e7",
        Gopf: "\ud835\udd3e",
        gopf: "\ud835\udd58",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22db",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2aa2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2a7e",
        GreaterTilde: "\u2273",
        Gscr: "\ud835\udca2",
        gscr: "\u210a",
        gsim: "\u2273",
        gsime: "\u2a8e",
        gsiml: "\u2a90",
        GT: ">",
        Gt: "\u226b",
        gt: ">",
        gtcc: "\u2aa7",
        gtcir: "\u2a7a",
        gtdot: "\u22d7",
        gtlPar: "\u2995",
        gtquest: "\u2a7c",
        gtrapprox: "\u2a86",
        gtrarr: "\u2978",
        gtrdot: "\u22d7",
        gtreqless: "\u22db",
        gtreqqless: "\u2a8c",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\ufe00",
        gvnE: "\u2269\ufe00",
        Hacek: "\u02c7",
        hairsp: "\u200a",
        half: "\xbd",
        hamilt: "\u210b",
        HARDcy: "\u042a",
        hardcy: "\u044a",
        hArr: "\u21d4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21ad",
        Hat: "^",
        hbar: "\u210f",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22b9",
        Hfr: "\u210c",
        hfr: "\ud835\udd25",
        HilbertSpace: "\u210b",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21ff",
        homtht: "\u223b",
        hookleftarrow: "\u21a9",
        hookrightarrow: "\u21aa",
        Hopf: "\u210d",
        hopf: "\ud835\udd59",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210b",
        hscr: "\ud835\udcbd",
        hslash: "\u210f",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224e",
        HumpEqual: "\u224f",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xcd",
        iacute: "\xed",
        ic: "\u2063",
        Icirc: "\xce",
        icirc: "\xee",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xa1",
        iff: "\u21d4",
        Ifr: "\u2111",
        ifr: "\ud835\udd26",
        Igrave: "\xcc",
        igrave: "\xec",
        ii: "\u2148",
        iiiint: "\u2a0c",
        iiint: "\u222d",
        iinfin: "\u29dc",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012a",
        imacr: "\u012b",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22b7",
        imped: "\u01b5",
        Implies: "\u21d2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221e",
        infintie: "\u29dd",
        inodot: "\u0131",
        Int: "\u222c",
        int: "\u222b",
        intcal: "\u22ba",
        integers: "\u2124",
        Integral: "\u222b",
        intercal: "\u22ba",
        Intersection: "\u22c2",
        intlarhk: "\u2a17",
        intprod: "\u2a3c",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012e",
        iogon: "\u012f",
        Iopf: "\ud835\udd40",
        iopf: "\ud835\udd5a",
        Iota: "\u0399",
        iota: "\u03b9",
        iprod: "\u2a3c",
        iquest: "\xbf",
        Iscr: "\u2110",
        iscr: "\ud835\udcbe",
        isin: "\u2208",
        isindot: "\u22f5",
        isinE: "\u22f9",
        isins: "\u22f4",
        isinsv: "\u22f3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xcf",
        iuml: "\xef",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\ud835\udd0d",
        jfr: "\ud835\udd27",
        jmath: "\u0237",
        Jopf: "\ud835\udd41",
        jopf: "\ud835\udd5b",
        Jscr: "\ud835\udca5",
        jscr: "\ud835\udcbf",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039a",
        kappa: "\u03ba",
        kappav: "\u03f0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041a",
        kcy: "\u043a",
        Kfr: "\ud835\udd0e",
        kfr: "\ud835\udd28",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040c",
        kjcy: "\u045c",
        Kopf: "\ud835\udd42",
        kopf: "\ud835\udd5c",
        Kscr: "\ud835\udca6",
        kscr: "\ud835\udcc0",
        lAarr: "\u21da",
        Lacute: "\u0139",
        lacute: "\u013a",
        laemptyv: "\u29b4",
        lagran: "\u2112",
        Lambda: "\u039b",
        lambda: "\u03bb",
        Lang: "\u27ea",
        lang: "\u27e8",
        langd: "\u2991",
        langle: "\u27e8",
        lap: "\u2a85",
        Laplacetrf: "\u2112",
        laquo: "\xab",
        Larr: "\u219e",
        lArr: "\u21d0",
        larr: "\u2190",
        larrb: "\u21e4",
        larrbfs: "\u291f",
        larrfs: "\u291d",
        larrhk: "\u21a9",
        larrlp: "\u21ab",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21a2",
        lat: "\u2aab",
        lAtail: "\u291b",
        latail: "\u2919",
        late: "\u2aad",
        lates: "\u2aad\ufe00",
        lBarr: "\u290e",
        lbarr: "\u290c",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298b",
        lbrksld: "\u298f",
        lbrkslu: "\u298d",
        Lcaron: "\u013d",
        lcaron: "\u013e",
        Lcedil: "\u013b",
        lcedil: "\u013c",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041b",
        lcy: "\u043b",
        ldca: "\u2936",
        ldquo: "\u201c",
        ldquor: "\u201e",
        ldrdhar: "\u2967",
        ldrushar: "\u294b",
        ldsh: "\u21b2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27e8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21d0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21e4",
        LeftArrowRightArrow: "\u21c6",
        leftarrowtail: "\u21a2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27e6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21c3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230a",
        leftharpoondown: "\u21bd",
        leftharpoonup: "\u21bc",
        leftleftarrows: "\u21c7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21d4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21c6",
        leftrightharpoons: "\u21cb",
        leftrightsquigarrow: "\u21ad",
        LeftRightVector: "\u294e",
        LeftTee: "\u22a3",
        LeftTeeArrow: "\u21a4",
        LeftTeeVector: "\u295a",
        leftthreetimes: "\u22cb",
        LeftTriangle: "\u22b2",
        LeftTriangleBar: "\u29cf",
        LeftTriangleEqual: "\u22b4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21bf",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21bc",
        LeftVectorBar: "\u2952",
        lEg: "\u2a8b",
        leg: "\u22da",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2a7d",
        les: "\u2a7d",
        lescc: "\u2aa8",
        lesdot: "\u2a7f",
        lesdoto: "\u2a81",
        lesdotor: "\u2a83",
        lesg: "\u22da\ufe00",
        lesges: "\u2a93",
        lessapprox: "\u2a85",
        lessdot: "\u22d6",
        lesseqgtr: "\u22da",
        lesseqqgtr: "\u2a8b",
        LessEqualGreater: "\u22da",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2aa1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2a7d",
        LessTilde: "\u2272",
        lfisht: "\u297c",
        lfloor: "\u230a",
        Lfr: "\ud835\udd0f",
        lfr: "\ud835\udd29",
        lg: "\u2276",
        lgE: "\u2a91",
        lHar: "\u2962",
        lhard: "\u21bd",
        lharu: "\u21bc",
        lharul: "\u296a",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22d8",
        ll: "\u226a",
        llarr: "\u21c7",
        llcorner: "\u231e",
        Lleftarrow: "\u21da",
        llhard: "\u296b",
        lltri: "\u25fa",
        Lmidot: "\u013f",
        lmidot: "\u0140",
        lmoust: "\u23b0",
        lmoustache: "\u23b0",
        lnap: "\u2a89",
        lnapprox: "\u2a89",
        lnE: "\u2268",
        lne: "\u2a87",
        lneq: "\u2a87",
        lneqq: "\u2268",
        lnsim: "\u22e6",
        loang: "\u27ec",
        loarr: "\u21fd",
        lobrk: "\u27e6",
        LongLeftArrow: "\u27f5",
        Longleftarrow: "\u27f8",
        longleftarrow: "\u27f5",
        LongLeftRightArrow: "\u27f7",
        Longleftrightarrow: "\u27fa",
        longleftrightarrow: "\u27f7",
        longmapsto: "\u27fc",
        LongRightArrow: "\u27f6",
        Longrightarrow: "\u27f9",
        longrightarrow: "\u27f6",
        looparrowleft: "\u21ab",
        looparrowright: "\u21ac",
        lopar: "\u2985",
        Lopf: "\ud835\udd43",
        lopf: "\ud835\udd5d",
        loplus: "\u2a2d",
        lotimes: "\u2a34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25ca",
        lozenge: "\u25ca",
        lozf: "\u29eb",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21c6",
        lrcorner: "\u231f",
        lrhar: "\u21cb",
        lrhard: "\u296d",
        lrm: "\u200e",
        lrtri: "\u22bf",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\ud835\udcc1",
        Lsh: "\u21b0",
        lsh: "\u21b0",
        lsim: "\u2272",
        lsime: "\u2a8d",
        lsimg: "\u2a8f",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201a",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        LT: "<",
        Lt: "\u226a",
        lt: "<",
        ltcc: "\u2aa6",
        ltcir: "\u2a79",
        ltdot: "\u22d6",
        lthree: "\u22cb",
        ltimes: "\u22c9",
        ltlarr: "\u2976",
        ltquest: "\u2a7b",
        ltri: "\u25c3",
        ltrie: "\u22b4",
        ltrif: "\u25c2",
        ltrPar: "\u2996",
        lurdshar: "\u294a",
        luruhar: "\u2966",
        lvertneqq: "\u2268\ufe00",
        lvnE: "\u2268\ufe00",
        macr: "\xaf",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21a6",
        mapsto: "\u21a6",
        mapstodown: "\u21a7",
        mapstoleft: "\u21a4",
        mapstoup: "\u21a5",
        marker: "\u25ae",
        mcomma: "\u2a29",
        Mcy: "\u041c",
        mcy: "\u043c",
        mdash: "\u2014",
        mDDot: "\u223a",
        measuredangle: "\u2221",
        MediumSpace: "\u205f",
        Mellintrf: "\u2133",
        Mfr: "\ud835\udd10",
        mfr: "\ud835\udd2a",
        mho: "\u2127",
        micro: "\xb5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2af0",
        middot: "\xb7",
        minus: "\u2212",
        minusb: "\u229f",
        minusd: "\u2238",
        minusdu: "\u2a2a",
        MinusPlus: "\u2213",
        mlcp: "\u2adb",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22a7",
        Mopf: "\ud835\udd44",
        mopf: "\ud835\udd5e",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\ud835\udcc2",
        mstpos: "\u223e",
        Mu: "\u039c",
        mu: "\u03bc",
        multimap: "\u22b8",
        mumap: "\u22b8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20d2",
        nap: "\u2249",
        napE: "\u2a70\u0338",
        napid: "\u224b\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266e",
        natural: "\u266e",
        naturals: "\u2115",
        nbsp: "\xa0",
        nbump: "\u224e\u0338",
        nbumpe: "\u224f\u0338",
        ncap: "\u2a43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2a6d\u0338",
        ncup: "\u2a42",
        Ncy: "\u041d",
        ncy: "\u043d",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21d7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200b",
        NegativeThickSpace: "\u200b",
        NegativeThinSpace: "\u200b",
        NegativeVeryThinSpace: "\u200b",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226b",
        NestedLessLess: "\u226a",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\ud835\udd11",
        nfr: "\ud835\udd2b",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2a7e\u0338",
        nges: "\u2a7e\u0338",
        nGg: "\u22d9\u0338",
        ngsim: "\u2275",
        nGt: "\u226b\u20d2",
        ngt: "\u226f",
        ngtr: "\u226f",
        nGtv: "\u226b\u0338",
        nhArr: "\u21ce",
        nharr: "\u21ae",
        nhpar: "\u2af2",
        ni: "\u220b",
        nis: "\u22fc",
        nisd: "\u22fa",
        niv: "\u220b",
        NJcy: "\u040a",
        njcy: "\u045a",
        nlArr: "\u21cd",
        nlarr: "\u219a",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21cd",
        nleftarrow: "\u219a",
        nLeftrightarrow: "\u21ce",
        nleftrightarrow: "\u21ae",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2a7d\u0338",
        nles: "\u2a7d\u0338",
        nless: "\u226e",
        nLl: "\u22d8\u0338",
        nlsim: "\u2274",
        nLt: "\u226a\u20d2",
        nlt: "\u226e",
        nltri: "\u22ea",
        nltrie: "\u22ec",
        nLtv: "\u226a\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xa0",
        Nopf: "\u2115",
        nopf: "\ud835\udd5f",
        Not: "\u2aec",
        not: "\xac",
        NotCongruent: "\u2262",
        NotCupCap: "\u226d",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226f",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226b\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2a7e\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224e\u0338",
        NotHumpEqual: "\u224f\u0338",
        notin: "\u2209",
        notindot: "\u22f5\u0338",
        notinE: "\u22f9\u0338",
        notinva: "\u2209",
        notinvb: "\u22f7",
        notinvc: "\u22f6",
        NotLeftTriangle: "\u22ea",
        NotLeftTriangleBar: "\u29cf\u0338",
        NotLeftTriangleEqual: "\u22ec",
        NotLess: "\u226e",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226a\u0338",
        NotLessSlantEqual: "\u2a7d\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2aa2\u0338",
        NotNestedLessLess: "\u2aa1\u0338",
        notni: "\u220c",
        notniva: "\u220c",
        notnivb: "\u22fe",
        notnivc: "\u22fd",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2aaf\u0338",
        NotPrecedesSlantEqual: "\u22e0",
        NotReverseElement: "\u220c",
        NotRightTriangle: "\u22eb",
        NotRightTriangleBar: "\u29d0\u0338",
        NotRightTriangleEqual: "\u22ed",
        NotSquareSubset: "\u228f\u0338",
        NotSquareSubsetEqual: "\u22e2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22e3",
        NotSubset: "\u2282\u20d2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2ab0\u0338",
        NotSucceedsSlantEqual: "\u22e1",
        NotSucceedsTilde: "\u227f\u0338",
        NotSuperset: "\u2283\u20d2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2afd\u20e5",
        npart: "\u2202\u0338",
        npolint: "\u2a14",
        npr: "\u2280",
        nprcue: "\u22e0",
        npre: "\u2aaf\u0338",
        nprec: "\u2280",
        npreceq: "\u2aaf\u0338",
        nrArr: "\u21cf",
        nrarr: "\u219b",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219d\u0338",
        nRightarrow: "\u21cf",
        nrightarrow: "\u219b",
        nrtri: "\u22eb",
        nrtrie: "\u22ed",
        nsc: "\u2281",
        nsccue: "\u22e1",
        nsce: "\u2ab0\u0338",
        Nscr: "\ud835\udca9",
        nscr: "\ud835\udcc3",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22e2",
        nsqsupe: "\u22e3",
        nsub: "\u2284",
        nsubE: "\u2ac5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20d2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2ac5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2ab0\u0338",
        nsup: "\u2285",
        nsupE: "\u2ac6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20d2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2ac6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xd1",
        ntilde: "\xf1",
        ntlg: "\u2278",
        ntriangleleft: "\u22ea",
        ntrianglelefteq: "\u22ec",
        ntriangleright: "\u22eb",
        ntrianglerighteq: "\u22ed",
        Nu: "\u039d",
        nu: "\u03bd",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224d\u20d2",
        nVDash: "\u22af",
        nVdash: "\u22ae",
        nvDash: "\u22ad",
        nvdash: "\u22ac",
        nvge: "\u2265\u20d2",
        nvgt: ">\u20d2",
        nvHarr: "\u2904",
        nvinfin: "\u29de",
        nvlArr: "\u2902",
        nvle: "\u2264\u20d2",
        nvlt: "<\u20d2",
        nvltrie: "\u22b4\u20d2",
        nvrArr: "\u2903",
        nvrtrie: "\u22b5\u20d2",
        nvsim: "\u223c\u20d2",
        nwarhk: "\u2923",
        nwArr: "\u21d6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xd3",
        oacute: "\xf3",
        oast: "\u229b",
        ocir: "\u229a",
        Ocirc: "\xd4",
        ocirc: "\xf4",
        Ocy: "\u041e",
        ocy: "\u043e",
        odash: "\u229d",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2a38",
        odot: "\u2299",
        odsold: "\u29bc",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29bf",
        Ofr: "\ud835\udd12",
        ofr: "\ud835\udd2c",
        ogon: "\u02db",
        Ograve: "\xd2",
        ograve: "\xf2",
        ogt: "\u29c1",
        ohbar: "\u29b5",
        ohm: "\u03a9",
        oint: "\u222e",
        olarr: "\u21ba",
        olcir: "\u29be",
        olcross: "\u29bb",
        oline: "\u203e",
        olt: "\u29c0",
        Omacr: "\u014c",
        omacr: "\u014d",
        Omega: "\u03a9",
        omega: "\u03c9",
        Omicron: "\u039f",
        omicron: "\u03bf",
        omid: "\u29b6",
        ominus: "\u2296",
        Oopf: "\ud835\udd46",
        oopf: "\ud835\udd60",
        opar: "\u29b7",
        OpenCurlyDoubleQuote: "\u201c",
        OpenCurlyQuote: "\u2018",
        operp: "\u29b9",
        oplus: "\u2295",
        Or: "\u2a54",
        or: "\u2228",
        orarr: "\u21bb",
        ord: "\u2a5d",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xaa",
        ordm: "\xba",
        origof: "\u22b6",
        oror: "\u2a56",
        orslope: "\u2a57",
        orv: "\u2a5b",
        oS: "\u24c8",
        Oscr: "\ud835\udcaa",
        oscr: "\u2134",
        Oslash: "\xd8",
        oslash: "\xf8",
        osol: "\u2298",
        Otilde: "\xd5",
        otilde: "\xf5",
        Otimes: "\u2a37",
        otimes: "\u2297",
        otimesas: "\u2a36",
        Ouml: "\xd6",
        ouml: "\xf6",
        ovbar: "\u233d",
        OverBar: "\u203e",
        OverBrace: "\u23de",
        OverBracket: "\u23b4",
        OverParenthesis: "\u23dc",
        par: "\u2225",
        para: "\xb6",
        parallel: "\u2225",
        parsim: "\u2af3",
        parsl: "\u2afd",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041f",
        pcy: "\u043f",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22a5",
        pertenk: "\u2031",
        Pfr: "\ud835\udd13",
        pfr: "\ud835\udd2d",
        Phi: "\u03a6",
        phi: "\u03c6",
        phiv: "\u03d5",
        phmmat: "\u2133",
        phone: "\u260e",
        Pi: "\u03a0",
        pi: "\u03c0",
        pitchfork: "\u22d4",
        piv: "\u03d6",
        planck: "\u210f",
        planckh: "\u210e",
        plankv: "\u210f",
        plus: "+",
        plusacir: "\u2a23",
        plusb: "\u229e",
        pluscir: "\u2a22",
        plusdo: "\u2214",
        plusdu: "\u2a25",
        pluse: "\u2a72",
        PlusMinus: "\xb1",
        plusmn: "\xb1",
        plussim: "\u2a26",
        plustwo: "\u2a27",
        pm: "\xb1",
        Poincareplane: "\u210c",
        pointint: "\u2a15",
        Popf: "\u2119",
        popf: "\ud835\udd61",
        pound: "\xa3",
        Pr: "\u2abb",
        pr: "\u227a",
        prap: "\u2ab7",
        prcue: "\u227c",
        prE: "\u2ab3",
        pre: "\u2aaf",
        prec: "\u227a",
        precapprox: "\u2ab7",
        preccurlyeq: "\u227c",
        Precedes: "\u227a",
        PrecedesEqual: "\u2aaf",
        PrecedesSlantEqual: "\u227c",
        PrecedesTilde: "\u227e",
        preceq: "\u2aaf",
        precnapprox: "\u2ab9",
        precneqq: "\u2ab5",
        precnsim: "\u22e8",
        precsim: "\u227e",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2ab9",
        prnE: "\u2ab5",
        prnsim: "\u22e8",
        prod: "\u220f",
        Product: "\u220f",
        profalar: "\u232e",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221d",
        Proportion: "\u2237",
        Proportional: "\u221d",
        propto: "\u221d",
        prsim: "\u227e",
        prurel: "\u22b0",
        Pscr: "\ud835\udcab",
        pscr: "\ud835\udcc5",
        Psi: "\u03a8",
        psi: "\u03c8",
        puncsp: "\u2008",
        Qfr: "\ud835\udd14",
        qfr: "\ud835\udd2e",
        qint: "\u2a0c",
        Qopf: "\u211a",
        qopf: "\ud835\udd62",
        qprime: "\u2057",
        Qscr: "\ud835\udcac",
        qscr: "\ud835\udcc6",
        quaternions: "\u210d",
        quatint: "\u2a16",
        quest: "?",
        questeq: "\u225f",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21db",
        race: "\u223d\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221a",
        raemptyv: "\u29b3",
        Rang: "\u27eb",
        rang: "\u27e9",
        rangd: "\u2992",
        range: "\u29a5",
        rangle: "\u27e9",
        raquo: "\xbb",
        Rarr: "\u21a0",
        rArr: "\u21d2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21e5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291e",
        rarrhk: "\u21aa",
        rarrlp: "\u21ac",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21a3",
        rarrw: "\u219d",
        rAtail: "\u291c",
        ratail: "\u291a",
        ratio: "\u2236",
        rationals: "\u211a",
        RBarr: "\u2910",
        rBarr: "\u290f",
        rbarr: "\u290d",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298c",
        rbrksld: "\u298e",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201d",
        rdquor: "\u201d",
        rdsh: "\u21b3",
        Re: "\u211c",
        real: "\u211c",
        realine: "\u211b",
        realpart: "\u211c",
        reals: "\u211d",
        rect: "\u25ad",
        REG: "\xae",
        reg: "\xae",
        ReverseElement: "\u220b",
        ReverseEquilibrium: "\u21cb",
        ReverseUpEquilibrium: "\u296f",
        rfisht: "\u297d",
        rfloor: "\u230b",
        Rfr: "\u211c",
        rfr: "\ud835\udd2f",
        rHar: "\u2964",
        rhard: "\u21c1",
        rharu: "\u21c0",
        rharul: "\u296c",
        Rho: "\u03a1",
        rho: "\u03c1",
        rhov: "\u03f1",
        RightAngleBracket: "\u27e9",
        RightArrow: "\u2192",
        Rightarrow: "\u21d2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21e5",
        RightArrowLeftArrow: "\u21c4",
        rightarrowtail: "\u21a3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27e7",
        RightDownTeeVector: "\u295d",
        RightDownVector: "\u21c2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230b",
        rightharpoondown: "\u21c1",
        rightharpoonup: "\u21c0",
        rightleftarrows: "\u21c4",
        rightleftharpoons: "\u21cc",
        rightrightarrows: "\u21c9",
        rightsquigarrow: "\u219d",
        RightTee: "\u22a2",
        RightTeeArrow: "\u21a6",
        RightTeeVector: "\u295b",
        rightthreetimes: "\u22cc",
        RightTriangle: "\u22b3",
        RightTriangleBar: "\u29d0",
        RightTriangleEqual: "\u22b5",
        RightUpDownVector: "\u294f",
        RightUpTeeVector: "\u295c",
        RightUpVector: "\u21be",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21c0",
        RightVectorBar: "\u2953",
        ring: "\u02da",
        risingdotseq: "\u2253",
        rlarr: "\u21c4",
        rlhar: "\u21cc",
        rlm: "\u200f",
        rmoust: "\u23b1",
        rmoustache: "\u23b1",
        rnmid: "\u2aee",
        roang: "\u27ed",
        roarr: "\u21fe",
        robrk: "\u27e7",
        ropar: "\u2986",
        Ropf: "\u211d",
        ropf: "\ud835\udd63",
        roplus: "\u2a2e",
        rotimes: "\u2a35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2a12",
        rrarr: "\u21c9",
        Rrightarrow: "\u21db",
        rsaquo: "\u203a",
        Rscr: "\u211b",
        rscr: "\ud835\udcc7",
        Rsh: "\u21b1",
        rsh: "\u21b1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22cc",
        rtimes: "\u22ca",
        rtri: "\u25b9",
        rtrie: "\u22b5",
        rtrif: "\u25b8",
        rtriltri: "\u29ce",
        RuleDelayed: "\u29f4",
        ruluhar: "\u2968",
        rx: "\u211e",
        Sacute: "\u015a",
        sacute: "\u015b",
        sbquo: "\u201a",
        Sc: "\u2abc",
        sc: "\u227b",
        scap: "\u2ab8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227d",
        scE: "\u2ab4",
        sce: "\u2ab0",
        Scedil: "\u015e",
        scedil: "\u015f",
        Scirc: "\u015c",
        scirc: "\u015d",
        scnap: "\u2aba",
        scnE: "\u2ab6",
        scnsim: "\u22e9",
        scpolint: "\u2a13",
        scsim: "\u227f",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22c5",
        sdotb: "\u22a1",
        sdote: "\u2a66",
        searhk: "\u2925",
        seArr: "\u21d8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xa7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\ud835\udd16",
        sfr: "\ud835\udd30",
        sfrown: "\u2322",
        sharp: "\u266f",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xad",
        Sigma: "\u03a3",
        sigma: "\u03c3",
        sigmaf: "\u03c2",
        sigmav: "\u03c2",
        sim: "\u223c",
        simdot: "\u2a6a",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2a9e",
        simgE: "\u2aa0",
        siml: "\u2a9d",
        simlE: "\u2a9f",
        simne: "\u2246",
        simplus: "\u2a24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2a33",
        smeparsl: "\u29e4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2aaa",
        smte: "\u2aac",
        smtes: "\u2aac\ufe00",
        SOFTcy: "\u042c",
        softcy: "\u044c",
        sol: "/",
        solb: "\u29c4",
        solbar: "\u233f",
        Sopf: "\ud835\udd4a",
        sopf: "\ud835\udd64",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\ufe00",
        sqcup: "\u2294",
        sqcups: "\u2294\ufe00",
        Sqrt: "\u221a",
        sqsub: "\u228f",
        sqsube: "\u2291",
        sqsubset: "\u228f",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25a1",
        Square: "\u25a1",
        square: "\u25a1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228f",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25aa",
        squf: "\u25aa",
        srarr: "\u2192",
        Sscr: "\ud835\udcae",
        sscr: "\ud835\udcc8",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22c6",
        Star: "\u22c6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03f5",
        straightphi: "\u03d5",
        strns: "\xaf",
        Sub: "\u22d0",
        sub: "\u2282",
        subdot: "\u2abd",
        subE: "\u2ac5",
        sube: "\u2286",
        subedot: "\u2ac3",
        submult: "\u2ac1",
        subnE: "\u2acb",
        subne: "\u228a",
        subplus: "\u2abf",
        subrarr: "\u2979",
        Subset: "\u22d0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2ac5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228a",
        subsetneqq: "\u2acb",
        subsim: "\u2ac7",
        subsub: "\u2ad5",
        subsup: "\u2ad3",
        succ: "\u227b",
        succapprox: "\u2ab8",
        succcurlyeq: "\u227d",
        Succeeds: "\u227b",
        SucceedsEqual: "\u2ab0",
        SucceedsSlantEqual: "\u227d",
        SucceedsTilde: "\u227f",
        succeq: "\u2ab0",
        succnapprox: "\u2aba",
        succneqq: "\u2ab6",
        succnsim: "\u22e9",
        succsim: "\u227f",
        SuchThat: "\u220b",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266a",
        Sup: "\u22d1",
        sup: "\u2283",
        sup1: "\xb9",
        sup2: "\xb2",
        sup3: "\xb3",
        supdot: "\u2abe",
        supdsub: "\u2ad8",
        supE: "\u2ac6",
        supe: "\u2287",
        supedot: "\u2ac4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27c9",
        suphsub: "\u2ad7",
        suplarr: "\u297b",
        supmult: "\u2ac2",
        supnE: "\u2acc",
        supne: "\u228b",
        supplus: "\u2ac0",
        Supset: "\u22d1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2ac6",
        supsetneq: "\u228b",
        supsetneqq: "\u2acc",
        supsim: "\u2ac8",
        supsub: "\u2ad4",
        supsup: "\u2ad6",
        swarhk: "\u2926",
        swArr: "\u21d9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292a",
        szlig: "\xdf",
        Tab: "\t",
        target: "\u2316",
        Tau: "\u03a4",
        tau: "\u03c4",
        tbrk: "\u23b4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20db",
        telrec: "\u2315",
        Tfr: "\ud835\udd17",
        tfr: "\ud835\udd31",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03b8",
        thetasym: "\u03d1",
        thetav: "\u03d1",
        thickapprox: "\u2248",
        thicksim: "\u223c",
        ThickSpace: "\u205f\u200a",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223c",
        THORN: "\xde",
        thorn: "\xfe",
        Tilde: "\u223c",
        tilde: "\u02dc",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xd7",
        timesb: "\u22a0",
        timesbar: "\u2a31",
        timesd: "\u2a30",
        tint: "\u222d",
        toea: "\u2928",
        top: "\u22a4",
        topbot: "\u2336",
        topcir: "\u2af1",
        Topf: "\ud835\udd4b",
        topf: "\ud835\udd65",
        topfork: "\u2ada",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25b5",
        triangledown: "\u25bf",
        triangleleft: "\u25c3",
        trianglelefteq: "\u22b4",
        triangleq: "\u225c",
        triangleright: "\u25b9",
        trianglerighteq: "\u22b5",
        tridot: "\u25ec",
        trie: "\u225c",
        triminus: "\u2a3a",
        TripleDot: "\u20db",
        triplus: "\u2a39",
        trisb: "\u29cd",
        tritime: "\u2a3b",
        trpezium: "\u23e2",
        Tscr: "\ud835\udcaf",
        tscr: "\ud835\udcc9",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040b",
        tshcy: "\u045b",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226c",
        twoheadleftarrow: "\u219e",
        twoheadrightarrow: "\u21a0",
        Uacute: "\xda",
        uacute: "\xfa",
        Uarr: "\u219f",
        uArr: "\u21d1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040e",
        ubrcy: "\u045e",
        Ubreve: "\u016c",
        ubreve: "\u016d",
        Ucirc: "\xdb",
        ucirc: "\xfb",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21c5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296e",
        ufisht: "\u297e",
        Ufr: "\ud835\udd18",
        ufr: "\ud835\udd32",
        Ugrave: "\xd9",
        ugrave: "\xf9",
        uHar: "\u2963",
        uharl: "\u21bf",
        uharr: "\u21be",
        uhblk: "\u2580",
        ulcorn: "\u231c",
        ulcorner: "\u231c",
        ulcrop: "\u230f",
        ultri: "\u25f8",
        Umacr: "\u016a",
        umacr: "\u016b",
        uml: "\xa8",
        UnderBar: "_",
        UnderBrace: "\u23df",
        UnderBracket: "\u23b5",
        UnderParenthesis: "\u23dd",
        Union: "\u22c3",
        UnionPlus: "\u228e",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\ud835\udd4c",
        uopf: "\ud835\udd66",
        UpArrow: "\u2191",
        Uparrow: "\u21d1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21c5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21d5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296e",
        upharpoonleft: "\u21bf",
        upharpoonright: "\u21be",
        uplus: "\u228e",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03d2",
        upsi: "\u03c5",
        upsih: "\u03d2",
        Upsilon: "\u03a5",
        upsilon: "\u03c5",
        UpTee: "\u22a5",
        UpTeeArrow: "\u21a5",
        upuparrows: "\u21c8",
        urcorn: "\u231d",
        urcorner: "\u231d",
        urcrop: "\u230e",
        Uring: "\u016e",
        uring: "\u016f",
        urtri: "\u25f9",
        Uscr: "\ud835\udcb0",
        uscr: "\ud835\udcca",
        utdot: "\u22f0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25b5",
        utrif: "\u25b4",
        uuarr: "\u21c8",
        Uuml: "\xdc",
        uuml: "\xfc",
        uwangle: "\u29a7",
        vangrt: "\u299c",
        varepsilon: "\u03f5",
        varkappa: "\u03f0",
        varnothing: "\u2205",
        varphi: "\u03d5",
        varpi: "\u03d6",
        varpropto: "\u221d",
        vArr: "\u21d5",
        varr: "\u2195",
        varrho: "\u03f1",
        varsigma: "\u03c2",
        varsubsetneq: "\u228a\ufe00",
        varsubsetneqq: "\u2acb\ufe00",
        varsupsetneq: "\u228b\ufe00",
        varsupsetneqq: "\u2acc\ufe00",
        vartheta: "\u03d1",
        vartriangleleft: "\u22b2",
        vartriangleright: "\u22b3",
        Vbar: "\u2aeb",
        vBar: "\u2ae8",
        vBarv: "\u2ae9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22ab",
        Vdash: "\u22a9",
        vDash: "\u22a8",
        vdash: "\u22a2",
        Vdashl: "\u2ae6",
        Vee: "\u22c1",
        vee: "\u2228",
        veebar: "\u22bb",
        veeeq: "\u225a",
        vellip: "\u22ee",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200a",
        Vfr: "\ud835\udd19",
        vfr: "\ud835\udd33",
        vltri: "\u22b2",
        vnsub: "\u2282\u20d2",
        vnsup: "\u2283\u20d2",
        Vopf: "\ud835\udd4d",
        vopf: "\ud835\udd67",
        vprop: "\u221d",
        vrtri: "\u22b3",
        Vscr: "\ud835\udcb1",
        vscr: "\ud835\udccb",
        vsubnE: "\u2acb\ufe00",
        vsubne: "\u228a\ufe00",
        vsupnE: "\u2acc\ufe00",
        vsupne: "\u228b\ufe00",
        Vvdash: "\u22aa",
        vzigzag: "\u299a",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2a5f",
        Wedge: "\u22c0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\ud835\udd1a",
        wfr: "\ud835\udd34",
        Wopf: "\ud835\udd4e",
        wopf: "\ud835\udd68",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\ud835\udcb2",
        wscr: "\ud835\udccc",
        xcap: "\u22c2",
        xcirc: "\u25ef",
        xcup: "\u22c3",
        xdtri: "\u25bd",
        Xfr: "\ud835\udd1b",
        xfr: "\ud835\udd35",
        xhArr: "\u27fa",
        xharr: "\u27f7",
        Xi: "\u039e",
        xi: "\u03be",
        xlArr: "\u27f8",
        xlarr: "\u27f5",
        xmap: "\u27fc",
        xnis: "\u22fb",
        xodot: "\u2a00",
        Xopf: "\ud835\udd4f",
        xopf: "\ud835\udd69",
        xoplus: "\u2a01",
        xotime: "\u2a02",
        xrArr: "\u27f9",
        xrarr: "\u27f6",
        Xscr: "\ud835\udcb3",
        xscr: "\ud835\udccd",
        xsqcup: "\u2a06",
        xuplus: "\u2a04",
        xutri: "\u25b3",
        xvee: "\u22c1",
        xwedge: "\u22c0",
        Yacute: "\xdd",
        yacute: "\xfd",
        YAcy: "\u042f",
        yacy: "\u044f",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042b",
        ycy: "\u044b",
        yen: "\xa5",
        Yfr: "\ud835\udd1c",
        yfr: "\ud835\udd36",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\ud835\udd50",
        yopf: "\ud835\udd6a",
        Yscr: "\ud835\udcb4",
        yscr: "\ud835\udcce",
        YUcy: "\u042e",
        yucy: "\u044e",
        Yuml: "\u0178",
        yuml: "\xff",
        Zacute: "\u0179",
        zacute: "\u017a",
        Zcaron: "\u017d",
        zcaron: "\u017e",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017b",
        zdot: "\u017c",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200b",
        Zeta: "\u0396",
        zeta: "\u03b6",
        Zfr: "\u2128",
        zfr: "\ud835\udd37",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21dd",
        Zopf: "\u2124",
        zopf: "\ud835\udd6b",
        Zscr: "\ud835\udcb5",
        zscr: "\ud835\udccf",
        zwj: "\u200d",
        zwnj: "\u200c"
    }, t3.NGSP_UNICODE = "\ue500", t3.NAMED_ENTITIES.ngsp = t3.NGSP_UNICODE;
}), hn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    class n4 {
        constructor({ closedByChildren: e6 , implicitNamespacePrefix: t4 , contentType: n5 = Dn.TagContentType.PARSABLE_DATA , closedByParent: r4 = !1 , isVoid: s4 = !1 , ignoreFirstLf: i4 = !1  } = {
        }){
            this.closedByChildren = {
            }, this.closedByParent = !1, this.canSelfClose = !1, e6 && e6.length > 0 && e6.forEach((e7)=>this.closedByChildren[e7] = !0
            ), this.isVoid = s4, this.closedByParent = r4 || s4, this.implicitNamespacePrefix = t4 || null, this.contentType = n5, this.ignoreFirstLf = i4;
        }
        isClosedByChild(e) {
            return this.isVoid || e.toLowerCase() in this.closedByChildren;
        }
    }
    let r5, s5;
    t3.HtmlTagDefinition = n4, t3.getHtmlTagDefinition = function(e7) {
        return s5 || (r5 = new n4, s5 = {
            base: new n4({
                isVoid: !0
            }),
            meta: new n4({
                isVoid: !0
            }),
            area: new n4({
                isVoid: !0
            }),
            embed: new n4({
                isVoid: !0
            }),
            link: new n4({
                isVoid: !0
            }),
            img: new n4({
                isVoid: !0
            }),
            input: new n4({
                isVoid: !0
            }),
            param: new n4({
                isVoid: !0
            }),
            hr: new n4({
                isVoid: !0
            }),
            br: new n4({
                isVoid: !0
            }),
            source: new n4({
                isVoid: !0
            }),
            track: new n4({
                isVoid: !0
            }),
            wbr: new n4({
                isVoid: !0
            }),
            p: new n4({
                closedByChildren: [
                    "address",
                    "article",
                    "aside",
                    "blockquote",
                    "div",
                    "dl",
                    "fieldset",
                    "footer",
                    "form",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                    "header",
                    "hgroup",
                    "hr",
                    "main",
                    "nav",
                    "ol",
                    "p",
                    "pre",
                    "section",
                    "table",
                    "ul"
                ],
                closedByParent: !0
            }),
            thead: new n4({
                closedByChildren: [
                    "tbody",
                    "tfoot"
                ]
            }),
            tbody: new n4({
                closedByChildren: [
                    "tbody",
                    "tfoot"
                ],
                closedByParent: !0
            }),
            tfoot: new n4({
                closedByChildren: [
                    "tbody"
                ],
                closedByParent: !0
            }),
            tr: new n4({
                closedByChildren: [
                    "tr"
                ],
                closedByParent: !0
            }),
            td: new n4({
                closedByChildren: [
                    "td",
                    "th"
                ],
                closedByParent: !0
            }),
            th: new n4({
                closedByChildren: [
                    "td",
                    "th"
                ],
                closedByParent: !0
            }),
            col: new n4({
                isVoid: !0
            }),
            svg: new n4({
                implicitNamespacePrefix: "svg"
            }),
            math: new n4({
                implicitNamespacePrefix: "math"
            }),
            li: new n4({
                closedByChildren: [
                    "li"
                ],
                closedByParent: !0
            }),
            dt: new n4({
                closedByChildren: [
                    "dt",
                    "dd"
                ]
            }),
            dd: new n4({
                closedByChildren: [
                    "dt",
                    "dd"
                ],
                closedByParent: !0
            }),
            rb: new n4({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rt: new n4({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rtc: new n4({
                closedByChildren: [
                    "rb",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            rp: new n4({
                closedByChildren: [
                    "rb",
                    "rt",
                    "rtc",
                    "rp"
                ],
                closedByParent: !0
            }),
            optgroup: new n4({
                closedByChildren: [
                    "optgroup"
                ],
                closedByParent: !0
            }),
            option: new n4({
                closedByChildren: [
                    "option",
                    "optgroup"
                ],
                closedByParent: !0
            }),
            pre: new n4({
                ignoreFirstLf: !0
            }),
            listing: new n4({
                ignoreFirstLf: !0
            }),
            style: new n4({
                contentType: Dn.TagContentType.RAW_TEXT
            }),
            script: new n4({
                contentType: Dn.TagContentType.RAW_TEXT
            }),
            title: new n4({
                contentType: Dn.TagContentType.ESCAPABLE_RAW_TEXT
            }),
            textarea: new n4({
                contentType: Dn.TagContentType.ESCAPABLE_RAW_TEXT,
                ignoreFirstLf: !0
            })
        }), s5[e7] || r5;
    };
}), dn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    t3.AstPath = class {
        constructor(e6, t4 = -1){
            this.path = e6, this.position = t4;
        }
        get empty() {
            return !this.path || !this.path.length;
        }
        get head() {
            return this.path[0];
        }
        get tail() {
            return this.path[this.path.length - 1];
        }
        parentOf(e) {
            return e && this.path[this.path.indexOf(e) - 1];
        }
        childOf(e) {
            return this.path[this.path.indexOf(e) + 1];
        }
        first(e) {
            for(let t6 = this.path.length - 1; t6 >= 0; t6--){
                let n4 = this.path[t6];
                if (n4 instanceof e) return n4;
            }
        }
        push(e) {
            this.path.push(e);
        }
        pop() {
            return this.path.pop();
        }
    };
}), fn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    t3.Text = class {
        constructor(e6, t4, n4){
            this.value = e6, this.sourceSpan = t4, this.i18n = n4;
        }
        visit(e, t) {
            return e.visitText(this, t);
        }
    };
    t3.CDATA = class {
        constructor(e7, t6){
            this.value = e7, this.sourceSpan = t6;
        }
        visit(e, t) {
            return e.visitCdata(this, t);
        }
    };
    t3.Expansion = class {
        constructor(e8, t7, n5, r4, s4, i4){
            this.switchValue = e8, this.type = t7, this.cases = n5, this.sourceSpan = r4, this.switchValueSourceSpan = s4, this.i18n = i4;
        }
        visit(e, t) {
            return e.visitExpansion(this, t);
        }
    };
    t3.ExpansionCase = class {
        constructor(e9, t8, n6, r5, s5){
            this.value = e9, this.expression = t8, this.sourceSpan = n6, this.valueSourceSpan = r5, this.expSourceSpan = s5;
        }
        visit(e, t) {
            return e.visitExpansionCase(this, t);
        }
    };
    t3.Attribute = class {
        constructor(e10, t9, n7, r6 = null, s6 = null, i5 = null){
            this.name = e10, this.value = t9, this.sourceSpan = n7, this.valueSpan = r6, this.nameSpan = s6, this.i18n = i5;
        }
        visit(e, t) {
            return e.visitAttribute(this, t);
        }
    };
    class n8 {
        constructor(e11, t10, n9, r7, s7 = null, i6 = null, o4 = null, a4 = null){
            this.name = e11, this.attrs = t10, this.children = n9, this.sourceSpan = r7, this.startSourceSpan = s7, this.endSourceSpan = i6, this.nameSpan = o4, this.i18n = a4;
        }
        visit(e, t) {
            return e.visitElement(this, t);
        }
    }
    t3.Element = n8;
    t3.Comment = class {
        constructor(e12, t11){
            this.value = e12, this.sourceSpan = t11;
        }
        visit(e, t) {
            return e.visitComment(this, t);
        }
    };
    function r8(e13, t12, n10 = null) {
        const r9 = [], s8 = e13.visit ? (t13)=>e13.visit(t13, n10) || t13.visit(e13, n10)
         : (t13)=>t13.visit(e13, n10)
        ;
        return (t12.forEach((e14)=>{
            const t13 = s8(e14);
            t13 && r9.push(t13);
        }), r9);
    }
    t3.DocType = class {
        constructor(e13, t12){
            this.value = e13, this.sourceSpan = t12;
        }
        visit(e, t) {
            return e.visitDocType(this, t);
        }
    }, t3.visitAll = r8;
    class s8 {
        constructor(){
        }
        visitElement(e, t) {
            this.visitChildren(t, (t13)=>{
                t13(e.attrs), t13(e.children);
            });
        }
        visitAttribute(e, t) {
        }
        visitText(e, t) {
        }
        visitCdata(e, t) {
        }
        visitComment(e, t) {
        }
        visitDocType(e, t) {
        }
        visitExpansion(e, t) {
            return this.visitChildren(t, (t13)=>{
                t13(e.cases);
            });
        }
        visitExpansionCase(e, t) {
        }
        visitChildren(e, t) {
            let n10 = [], s9 = this;
            return t(function(t13) {
                t13 && n10.push(r8(s9, t13, e));
            }), Array.prototype.concat.apply([], n10);
        }
    }
    function i7(e14) {
        const t13 = e14.sourceSpan.start.offset;
        let r9 = e14.sourceSpan.end.offset;
        return (e14 instanceof n8 && (e14.endSourceSpan ? r9 = e14.endSourceSpan.end.offset : e14.children && e14.children.length && (r9 = i7(e14.children[e14.children.length - 1]).end)), {
            start: t13,
            end: r9
        });
    }
    t3.RecursiveVisitor = s8, t3.findNode = function(e14, t13) {
        const n10 = [];
        return r8(new class extends s8 {
            visit(e, r) {
                const s9 = i7(e);
                if (!(s9.start <= t13 && t13 < s9.end)) return !0;
                n10.push(e);
            }
        }, e14), new dn.AstPath(n10, t13);
    };
}), mn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    }), t3.assertArrayOfStrings = function(e6, t4) {
        if (null != t4) {
            if (!Array.isArray(t4)) throw new Error("Expected '".concat(e6, "' to be an array of strings."));
            for(let n4 = 0; n4 < t4.length; n4 += 1)if ("string" != typeof t4[n4]) throw new Error("Expected '".concat(e6, "' to be an array of strings."));
        }
    };
    const n4 = [
        /^\s*$/,
        /[<>]/,
        /^[{}]$/,
        /&(#|[a-z])/i,
        /^\/\//
    ];
    t3.assertInterpolationSymbols = function(e6, t4) {
        if (!(null == t4 || Array.isArray(t4) && 2 == t4.length)) throw new Error("Expected '".concat(e6, "' to be an array, [start, end]."));
        if (null != t4) {
            const e7 = t4[0], r4 = t4[1];
            n4.forEach((t6)=>{
                if (t6.test(e7) || t6.test(r4)) throw new Error("['".concat(e7, "', '").concat(r4, "'] contains unusable interpolation symbol."));
            });
        }
    };
}), gn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    class n4 {
        constructor(e6, t4){
            this.start = e6, this.end = t4;
        }
        static fromArray(e) {
            return e ? (mn.assertInterpolationSymbols("interpolation", e), new n4(e[0], e[1])) : t3.DEFAULT_INTERPOLATION_CONFIG;
        }
    }
    t3.InterpolationConfig = n4, t3.DEFAULT_INTERPOLATION_CONFIG = new n4("{{", "}}");
}), En = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    const r4 = n3;
    var s4;
    !(function(e6) {
        e6[e6.TAG_OPEN_START = 0] = "TAG_OPEN_START", e6[e6.TAG_OPEN_END = 1] = "TAG_OPEN_END", e6[e6.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e6[e6.TAG_CLOSE = 3] = "TAG_CLOSE", e6[e6.TEXT = 4] = "TEXT", e6[e6.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", e6[e6.RAW_TEXT = 6] = "RAW_TEXT", e6[e6.COMMENT_START = 7] = "COMMENT_START", e6[e6.COMMENT_END = 8] = "COMMENT_END", e6[e6.CDATA_START = 9] = "CDATA_START", e6[e6.CDATA_END = 10] = "CDATA_END", e6[e6.ATTR_NAME = 11] = "ATTR_NAME", e6[e6.ATTR_QUOTE = 12] = "ATTR_QUOTE", e6[e6.ATTR_VALUE = 13] = "ATTR_VALUE", e6[e6.DOC_TYPE_START = 14] = "DOC_TYPE_START", e6[e6.DOC_TYPE_END = 15] = "DOC_TYPE_END", e6[e6.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e6[e6.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e6[e6.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e6[e6.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e6[e6.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e6[e6.EOF = 21] = "EOF";
    })(s4 = t3.TokenType || (t3.TokenType = {
    }));
    class i4 {
        constructor(e6, t4, n4){
            this.type = e6, this.parts = t4, this.sourceSpan = n4;
        }
    }
    t3.Token = i4;
    class a4 extends o3.ParseError {
        constructor(e7, t6, n5){
            super(n5, e7), this.tokenType = t6;
        }
    }
    t3.TokenError = a4;
    class u4 {
        constructor(e8, t7){
            this.tokens = e8, this.errors = t7;
        }
    }
    t3.TokenizeResult = u4, t3.tokenize = function(e9, t8, n6, r5 = {
    }) {
        return new h4(new o3.ParseSourceFile(e9, t8), n6, r5).tokenize();
    };
    const c4 = /\r\n?/g;
    function l4(e9) {
        const t8 = e9 === n3.$EOF ? "EOF" : String.fromCharCode(e9);
        return 'Unexpected character "'.concat(t8, '"');
    }
    function p4(e9) {
        return 'Unknown entity "'.concat(e9, '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax');
    }
    class D4 {
        constructor(e9){
            this.error = e9;
        }
    }
    class h4 {
        constructor(e10, t8, n6){
            this._getTagContentType = t8, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = n6.tokenizeExpansionForms || !1, this._interpolationConfig = n6.interpolationConfig || gn.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = n6.leadingTriviaChars && n6.leadingTriviaChars.map((e11)=>e11.codePointAt(0) || 0
            ), this._canSelfClose = n6.canSelfClose || !1, this._allowHtmComponentClosingTags = n6.allowHtmComponentClosingTags || !1;
            const r5 = n6.range || {
                endPos: e10.content.length,
                startPos: 0,
                startLine: 0,
                startCol: 0
            };
            this._cursor = n6.escapedString ? new T3(e10, r5) : new C3(e10, r5);
            try {
                this._cursor.init();
            } catch (e) {
                this.handleError(e);
            }
        }
        _processCarriageReturns(e) {
            return e.replace(c4, "\n");
        }
        tokenize() {
            for(; this._cursor.peek() !== n3.$EOF;){
                const e11 = this._cursor.clone();
                try {
                    if (this._attemptCharCode(n3.$LT)) {
                        if (this._attemptCharCode(n3.$BANG)) this._attemptStr("[CDATA[") ? this._consumeCdata(e11) : this._attemptStr("--") ? this._consumeComment(e11) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e11) : this._consumeBogusComment(e11);
                        else if (this._attemptCharCode(n3.$SLASH)) this._consumeTagClose(e11);
                        else {
                            const t9 = this._cursor.clone();
                            this._attemptCharCode(n3.$QUESTION) ? (this._cursor = t9, this._consumeBogusComment(e11)) : this._consumeTagOpen(e11);
                        }
                    } else this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
                } catch (e) {
                    this.handleError(e);
                }
            }
            return this._beginToken(s4.EOF), this._endToken([]), new u4(function(e11) {
                const t9 = [];
                let n7 = void 0;
                for(let r6 = 0; r6 < e11.length; r6++){
                    const i5 = e11[r6];
                    n7 && n7.type == s4.TEXT && i5.type == s4.TEXT ? (n7.parts[0] += i5.parts[0], n7.sourceSpan.end = i5.sourceSpan.end) : (n7 = i5, t9.push(n7));
                }
                return t9;
            }(this.tokens), this.errors);
        }
        _tokenizeExpansionForm() {
            if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
            if (((e11 = this._cursor.peek()) === n3.$EQ || n3.isAsciiLetter(e11) || n3.isDigit(e11)) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), !0;
            var e11;
            if (this._cursor.peek() === n3.$RBRACE) {
                if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
                if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
            }
            return !1;
        }
        _beginToken(e, t = this._cursor.clone()) {
            this._currentTokenStart = t, this._currentTokenType = e;
        }
        _endToken(e, t = this._cursor.clone()) {
            if (null === this._currentTokenStart) throw new a4("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t));
            if (null === this._currentTokenType) throw new a4("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
            const n7 = new i4(this._currentTokenType, e, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
            return this.tokens.push(n7), this._currentTokenStart = null, this._currentTokenType = null, n7;
        }
        _createError(e, t) {
            this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
            const n7 = new a4(e, this._currentTokenType, t);
            return this._currentTokenStart = null, this._currentTokenType = null, new D4(n7);
        }
        handleError(e) {
            if (e instanceof y4 && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof D4)) throw e;
            this.errors.push(e.error);
        }
        _attemptCharCode(e) {
            return this._cursor.peek() === e && (this._cursor.advance(), !0);
        }
        _attemptCharCodeCaseInsensitive(e) {
            return t9 = this._cursor.peek(), n7 = e, E4(t9) == E4(n7) && (this._cursor.advance(), !0);
            var t9, n7;
        }
        _requireCharCode(e) {
            const t9 = this._cursor.clone();
            if (!this._attemptCharCode(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t9));
        }
        _attemptStr(e) {
            const t9 = e.length;
            if (this._cursor.charsLeft() < t9) return !1;
            const n7 = this._cursor.clone();
            for(let r6 = 0; r6 < t9; r6++)if (!this._attemptCharCode(e.charCodeAt(r6))) return this._cursor = n7, !1;
            return !0;
        }
        _attemptStrCaseInsensitive(e) {
            for(let t9 = 0; t9 < e.length; t9++)if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t9))) return !1;
            return !0;
        }
        _requireStr(e) {
            const t9 = this._cursor.clone();
            if (!this._attemptStr(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t9));
        }
        _requireStrCaseInsensitive(e) {
            const t9 = this._cursor.clone();
            if (!this._attemptStrCaseInsensitive(e)) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(t9));
        }
        _attemptCharCodeUntilFn(e) {
            for(; !e(this._cursor.peek());)this._cursor.advance();
        }
        _requireCharCodeUntilFn(e, t) {
            const n7 = this._cursor.clone();
            this._attemptCharCodeUntilFn(e);
            if (this._cursor.clone().diff(n7) < t) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(n7));
        }
        _attemptUntilChar(e) {
            for(; this._cursor.peek() !== e;)this._cursor.advance();
        }
        _readChar(e) {
            if (e && this._cursor.peek() === n3.$AMPERSAND) return this._decodeEntity();
            {
                const e11 = String.fromCodePoint(this._cursor.peek());
                return this._cursor.advance(), e11;
            }
        }
        _decodeEntity() {
            const e11 = this._cursor.clone();
            if (this._cursor.advance(), !this._attemptCharCode(n3.$HASH)) {
                const t9 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(g3), this._cursor.peek() != n3.$SEMICOLON) return this._cursor = t9, "&";
                const n7 = this._cursor.getChars(t9);
                this._cursor.advance();
                const s5 = Dn.NAMED_ENTITIES[n7];
                if (!s5) throw this._createError(p4(n7), this._cursor.getSpan(e11));
                return s5;
            }
            {
                const t9 = this._attemptCharCode(n3.$x) || this._attemptCharCode(n3.$X), n7 = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(m4), this._cursor.peek() != n3.$SEMICOLON) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan());
                const s5 = this._cursor.getChars(n7);
                this._cursor.advance();
                try {
                    const e12 = parseInt(s5, t9 ? 16 : 10);
                    return String.fromCharCode(e12);
                } catch (t) {
                    throw this._createError(p4(this._cursor.getChars(e11)), this._cursor.getSpan());
                }
            }
        }
        _consumeRawText(e, t) {
            this._beginToken(e ? s4.ESCAPABLE_RAW_TEXT : s4.RAW_TEXT);
            const n7 = [];
            for(;;){
                const r6 = this._cursor.clone(), s5 = t();
                if (this._cursor = r6, s5) break;
                n7.push(this._readChar(e));
            }
            return this._endToken([
                this._processCarriageReturns(n7.join(""))
            ]);
        }
        _consumeComment(e) {
            this._beginToken(s4.COMMENT_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._attemptStr("--\x3e")
            ), this._beginToken(s4.COMMENT_END), this._requireStr("--\x3e"), this._endToken([]);
        }
        _consumeBogusComment(e) {
            this._beginToken(s4.COMMENT_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._cursor.peek() === n3.$GT
            ), this._beginToken(s4.COMMENT_END), this._cursor.advance(), this._endToken([]);
        }
        _consumeCdata(e) {
            this._beginToken(s4.CDATA_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._attemptStr("]]>")
            ), this._beginToken(s4.CDATA_END), this._requireStr("]]>"), this._endToken([]);
        }
        _consumeDocType(e) {
            this._beginToken(s4.DOC_TYPE_START, e), this._endToken([]), this._consumeRawText(!1, ()=>this._cursor.peek() === n3.$GT
            ), this._beginToken(s4.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
        }
        _consumePrefixAndName() {
            const e11 = this._cursor.clone();
            let t9 = "";
            for(; this._cursor.peek() !== n3.$COLON && !(((n7 = this._cursor.peek()) < n3.$a || n3.$z < n7) && (n7 < n3.$A || n3.$Z < n7) && (n7 < n3.$0 || n7 > n3.$9));)this._cursor.advance();
            var n7;
            let s5;
            this._cursor.peek() === n3.$COLON ? (t9 = this._cursor.getChars(e11), this._cursor.advance(), s5 = this._cursor.clone()) : s5 = e11, this._requireCharCodeUntilFn(f4, "" === t9 ? 0 : 1);
            return [
                t9,
                this._cursor.getChars(s5)
            ];
        }
        _consumeTagOpen(e) {
            let t9, n7, i5, o4 = this.tokens.length;
            const a5 = this._cursor.clone(), u5 = [];
            try {
                if (!n3.isAsciiLetter(this._cursor.peek())) throw this._createError(l4(this._cursor.peek()), this._cursor.getSpan(e));
                for(i5 = this._consumeTagOpenStart(e), n7 = i5.parts[0], t9 = i5.parts[1], this._attemptCharCodeUntilFn(d4); this._cursor.peek() !== n3.$SLASH && this._cursor.peek() !== n3.$GT;){
                    const [e11, t10] = this._consumeAttributeName();
                    if (this._attemptCharCodeUntilFn(d4), this._attemptCharCode(n3.$EQ)) {
                        this._attemptCharCodeUntilFn(d4);
                        const n8 = this._consumeAttributeValue();
                        u5.push({
                            prefix: e11,
                            name: t10,
                            value: n8
                        });
                    } else u5.push({
                        prefix: e11,
                        name: t10
                    });
                    this._attemptCharCodeUntilFn(d4);
                }
                this._consumeTagOpenEnd();
            } catch (t) {
                if (t instanceof D4) return this._cursor = a5, i5 && (this.tokens.length = o4), this._beginToken(s4.TEXT, e), void this._endToken([
                    "<"
                ]);
                throw t;
            }
            if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === s4.TAG_OPEN_END_VOID) return;
            const c5 = this._getTagContentType(t9, n7, this._fullNameStack.length > 0, u5);
            this._handleFullNameStackForTagOpen(n7, t9), c5 === Dn.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(n7, t9, !1) : c5 === Dn.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n7, t9, !0);
        }
        _consumeRawTextWithTagClose(e, t, n) {
            this._consumeRawText(n, ()=>!!this._attemptCharCode(n3.$LT) && (!!this._attemptCharCode(n3.$SLASH) && (this._attemptCharCodeUntilFn(d4), !!this._attemptStrCaseInsensitive(e ? "".concat(e, ":").concat(t) : t) && (this._attemptCharCodeUntilFn(d4), this._attemptCharCode(n3.$GT))))
            );
            this._beginToken(s4.TAG_CLOSE), this._requireCharCodeUntilFn((e11)=>e11 === n3.$GT
            , 3), this._cursor.advance(), this._endToken([
                e,
                t
            ]), this._handleFullNameStackForTagClose(e, t);
        }
        _consumeTagOpenStart(e) {
            this._beginToken(s4.TAG_OPEN_START, e);
            const t9 = this._consumePrefixAndName();
            return this._endToken(t9);
        }
        _consumeAttributeName() {
            const e11 = this._cursor.peek();
            if (e11 === n3.$SQ || e11 === n3.$DQ) throw this._createError(l4(e11), this._cursor.getSpan());
            this._beginToken(s4.ATTR_NAME);
            const t9 = this._consumePrefixAndName();
            return this._endToken(t9), t9;
        }
        _consumeAttributeValue() {
            let e11;
            if (this._cursor.peek() === n3.$SQ || this._cursor.peek() === n3.$DQ) {
                this._beginToken(s4.ATTR_QUOTE);
                const t9 = this._cursor.peek();
                this._cursor.advance(), this._endToken([
                    String.fromCodePoint(t9)
                ]), this._beginToken(s4.ATTR_VALUE);
                const n7 = [];
                for(; this._cursor.peek() !== t9;)n7.push(this._readChar(!0));
                e11 = this._processCarriageReturns(n7.join("")), this._endToken([
                    e11
                ]), this._beginToken(s4.ATTR_QUOTE), this._cursor.advance(), this._endToken([
                    String.fromCodePoint(t9)
                ]);
            } else {
                this._beginToken(s4.ATTR_VALUE);
                const t9 = this._cursor.clone();
                this._requireCharCodeUntilFn(f4, 1), e11 = this._processCarriageReturns(this._cursor.getChars(t9)), this._endToken([
                    e11
                ]);
            }
            return e11;
        }
        _consumeTagOpenEnd() {
            const e11 = this._attemptCharCode(n3.$SLASH) ? s4.TAG_OPEN_END_VOID : s4.TAG_OPEN_END;
            this._beginToken(e11), this._requireCharCode(n3.$GT), this._endToken([]);
        }
        _consumeTagClose(e) {
            if (this._beginToken(s4.TAG_CLOSE, e), this._attemptCharCodeUntilFn(d4), this._allowHtmComponentClosingTags && this._attemptCharCode(n3.$SLASH)) this._attemptCharCodeUntilFn(d4), this._requireCharCode(n3.$GT), this._endToken([]);
            else {
                const [e11, t9] = this._consumePrefixAndName();
                this._attemptCharCodeUntilFn(d4), this._requireCharCode(n3.$GT), this._endToken([
                    e11,
                    t9
                ]), this._handleFullNameStackForTagClose(e11, t9);
            }
        }
        _consumeExpansionFormStart() {
            this._beginToken(s4.EXPANSION_FORM_START), this._requireCharCode(n3.$LBRACE), this._endToken([]), this._expansionCaseStack.push(s4.EXPANSION_FORM_START), this._beginToken(s4.RAW_TEXT);
            const e11 = this._readUntil(n3.$COMMA);
            this._endToken([
                e11
            ]), this._requireCharCode(n3.$COMMA), this._attemptCharCodeUntilFn(d4), this._beginToken(s4.RAW_TEXT);
            const t9 = this._readUntil(n3.$COMMA);
            this._endToken([
                t9
            ]), this._requireCharCode(n3.$COMMA), this._attemptCharCodeUntilFn(d4);
        }
        _consumeExpansionCaseStart() {
            this._beginToken(s4.EXPANSION_CASE_VALUE);
            const e11 = this._readUntil(n3.$LBRACE).trim();
            this._endToken([
                e11
            ]), this._attemptCharCodeUntilFn(d4), this._beginToken(s4.EXPANSION_CASE_EXP_START), this._requireCharCode(n3.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(d4), this._expansionCaseStack.push(s4.EXPANSION_CASE_EXP_START);
        }
        _consumeExpansionCaseEnd() {
            this._beginToken(s4.EXPANSION_CASE_EXP_END), this._requireCharCode(n3.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(d4), this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
            this._beginToken(s4.EXPANSION_FORM_END), this._requireCharCode(n3.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
        }
        _consumeText() {
            const e11 = this._cursor.clone();
            this._beginToken(s4.TEXT, e11);
            const t9 = [];
            do {
                this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t9.push(this._interpolationConfig.start), this._inInterpolation = !0) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t9.push(this._interpolationConfig.end), this._inInterpolation = !1) : t9.push(this._readChar(!0));
            }while (!this._isTextEnd())
            this._endToken([
                this._processCarriageReturns(t9.join(""))
            ]);
        }
        _isTextEnd() {
            if (this._cursor.peek() === n3.$LT || this._cursor.peek() === n3.$EOF) return !0;
            if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart()) return !0;
                if (this._cursor.peek() === n3.$RBRACE && this._isInExpansionCase()) return !0;
            }
            return !1;
        }
        _readUntil(e) {
            const t9 = this._cursor.clone();
            return this._attemptUntilChar(e), this._cursor.getChars(t9);
        }
        _isInExpansionCase() {
            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s4.EXPANSION_CASE_EXP_START;
        }
        _isInExpansionForm() {
            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s4.EXPANSION_FORM_START;
        }
        isExpansionFormStart() {
            if (this._cursor.peek() !== n3.$LBRACE) return !1;
            if (this._interpolationConfig) {
                const e11 = this._cursor.clone(), t9 = this._attemptStr(this._interpolationConfig.start);
                return this._cursor = e11, !t9;
            }
            return !0;
        }
        _handleFullNameStackForTagOpen(e, t) {
            const n7 = Dn.mergeNsAndName(e, t);
            0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] !== n7 || this._fullNameStack.push(n7);
        }
        _handleFullNameStackForTagClose(e, t) {
            const n7 = Dn.mergeNsAndName(e, t);
            0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] === n7 && this._fullNameStack.pop();
        }
    }
    function d4(e11) {
        return !n3.isWhitespace(e11) || e11 === n3.$EOF;
    }
    function f4(e11) {
        return n3.isWhitespace(e11) || e11 === n3.$GT || e11 === n3.$SLASH || e11 === n3.$SQ || e11 === n3.$DQ || e11 === n3.$EQ;
    }
    function m4(e11) {
        return e11 == n3.$SEMICOLON || e11 == n3.$EOF || !n3.isAsciiHexDigit(e11);
    }
    function g3(e11) {
        return e11 == n3.$SEMICOLON || e11 == n3.$EOF || !n3.isAsciiLetter(e11);
    }
    function E4(e11) {
        return e11 >= n3.$a && e11 <= n3.$z ? e11 - n3.$a + n3.$A : e11;
    }
    class C3 {
        constructor(e11, t9){
            if (e11 instanceof C3) this.file = e11.file, this.input = e11.input, this.end = e11.end, this.state = Object.assign({
            }, e11.state);
            else {
                if (!t9) throw new Error("Programming error: the range argument must be provided with a file argument.");
                this.file = e11, this.input = e11.content, this.end = t9.endPos, this.state = {
                    peek: -1,
                    offset: t9.startPos,
                    line: t9.startLine,
                    column: t9.startCol
                };
            }
        }
        clone() {
            return new C3(this);
        }
        peek() {
            return this.state.peek;
        }
        charsLeft() {
            return this.end - this.state.offset;
        }
        diff(e) {
            return this.state.offset - e.state.offset;
        }
        advance() {
            this.advanceState(this.state);
        }
        init() {
            this.updatePeek(this.state);
        }
        getSpan(e, t) {
            if (e = e || this, t) for(e = e.clone(); this.diff(e) > 0 && -1 !== t.indexOf(e.peek());)e.advance();
            return new o3.ParseSourceSpan(new o3.ParseLocation(e.file, e.state.offset, e.state.line, e.state.column), new o3.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
        }
        getChars(e) {
            return this.input.substring(e.state.offset, this.state.offset);
        }
        charAt(e) {
            return this.input.charCodeAt(e);
        }
        advanceState(e) {
            if (e.offset >= this.end) throw this.state = e, new y4('Unexpected character "EOF"', this);
            const t10 = this.charAt(e.offset);
            t10 === n3.$LF ? (e.line++, e.column = 0) : n3.isNewLine(t10) || e.column++, e.offset++, this.updatePeek(e);
        }
        updatePeek(e) {
            e.peek = e.offset >= this.end ? n3.$EOF : this.charAt(e.offset);
        }
    }
    class T3 extends C3 {
        constructor(e12, t10){
            e12 instanceof T3 ? (super(e12), this.internalState = Object.assign({
            }, e12.internalState)) : (super(e12, t10), this.internalState = this.state);
        }
        advance() {
            this.state = this.internalState, super.advance(), this.processEscapeSequence();
        }
        init() {
            super.init(), this.processEscapeSequence();
        }
        clone() {
            return new T3(this);
        }
        getChars(e) {
            const t11 = e.clone();
            let n7 = "";
            for(; t11.internalState.offset < this.internalState.offset;)n7 += String.fromCodePoint(t11.peek()), t11.advance();
            return n7;
        }
        processEscapeSequence() {
            const e13 = ()=>this.internalState.peek
            ;
            if (e13() === n3.$BACKSLASH) {
                if (this.internalState = Object.assign({
                }, this.state), this.advanceState(this.internalState), e13() === n3.$n) this.state.peek = n3.$LF;
                else if (e13() === n3.$r) this.state.peek = n3.$CR;
                else if (e13() === n3.$v) this.state.peek = n3.$VTAB;
                else if (e13() === n3.$t) this.state.peek = n3.$TAB;
                else if (e13() === n3.$b) this.state.peek = n3.$BSPACE;
                else if (e13() === n3.$f) this.state.peek = n3.$FF;
                else if (e13() === n3.$u) {
                    if (this.advanceState(this.internalState), e13() === n3.$LBRACE) {
                        this.advanceState(this.internalState);
                        const t11 = this.clone();
                        let n7 = 0;
                        for(; e13() !== n3.$RBRACE;)this.advanceState(this.internalState), n7++;
                        this.state.peek = this.decodeHexDigits(t11, n7);
                    } else {
                        const e14 = this.clone();
                        this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e14, 4);
                    }
                } else if (e13() === n3.$x) {
                    this.advanceState(this.internalState);
                    const e14 = this.clone();
                    this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e14, 2);
                } else if (n3.isOctalDigit(e13())) {
                    let t11 = "", n7 = 0, s5 = this.clone();
                    for(; n3.isOctalDigit(e13()) && n7 < 3;)s5 = this.clone(), t11 += String.fromCodePoint(e13()), this.advanceState(this.internalState), n7++;
                    this.state.peek = parseInt(t11, 8), this.internalState = s5.internalState;
                } else n3.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
            }
        }
        decodeHexDigits(e, t) {
            const n7 = this.input.substr(e.internalState.offset, t), r6 = parseInt(n7, 16);
            if (isNaN(r6)) throw e.state = e.internalState, new y4("Invalid hexadecimal escape sequence", e);
            return r6;
        }
    }
    class y4 {
        constructor(e13, t11){
            this.msg = e13, this.cursor = t11;
        }
    }
    t3.CursorError = y4;
}), Cn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    class n4 extends o3.ParseError {
        constructor(e6, t4, n5){
            super(t4, n5), this.elementName = e6;
        }
        static create(e, t, r) {
            return new n4(e, t, r);
        }
    }
    t3.TreeError = n4;
    class r4 {
        constructor(e7, t6){
            this.rootNodes = e7, this.errors = t6;
        }
    }
    t3.ParseTreeResult = r4;
    t3.Parser = class {
        constructor(e8){
            this.getTagDefinition = e8;
        }
        parse(e, t, n, i = !1, o) {
            const a4 = (e9)=>(t7, ...n6)=>e9(t7.toLowerCase(), ...n6)
            , u4 = i ? this.getTagDefinition : a4(this.getTagDefinition), c4 = (e9)=>u4(e9).contentType
            , l4 = i ? o : a4(o), p4 = o ? (e9, t7, n6, r5)=>{
                const s4 = l4(e9, t7, n6, r5);
                return (void 0) !== s4 ? s4 : c4(e9);
            } : c4, D4 = En.tokenize(e, t, p4, n), h4 = n && n.canSelfClose || !1, d4 = n && n.allowHtmComponentClosingTags || !1, f4 = new s4(D4.tokens, u4, h4, d4, i).build();
            return new r4(f4.rootNodes, D4.errors.concat(f4.errors));
        }
    };
    class s4 {
        constructor(e9, t7, n6, r5, s5){
            this.tokens = e9, this.getTagDefinition = t7, this.canSelfClose = n6, this.allowHtmComponentClosingTags = r5, this.isTagNameCaseSensitive = s5, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
        }
        build() {
            for(; this._peek.type !== En.TokenType.EOF;)this._peek.type === En.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === En.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === En.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === En.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === En.TokenType.TEXT || this._peek.type === En.TokenType.RAW_TEXT || this._peek.type === En.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === En.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === En.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
            return new r4(this._rootNodes, this._errors);
        }
        _advance() {
            const e10 = this._peek;
            return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e10;
        }
        _advanceIf(e) {
            return this._peek.type === e ? this._advance() : null;
        }
        _consumeCdata(e) {
            const t8 = this._advance(), n7 = this._getText(t8), r6 = this._advanceIf(En.TokenType.CDATA_END);
            this._addToParent(new fn.CDATA(n7, new o3.ParseSourceSpan(e.sourceSpan.start, (r6 || t8).sourceSpan.end)));
        }
        _consumeComment(e) {
            const t8 = this._advanceIf(En.TokenType.RAW_TEXT), n7 = this._advanceIf(En.TokenType.COMMENT_END), r6 = null != t8 ? t8.parts[0].trim() : null, s6 = new o3.ParseSourceSpan(e.sourceSpan.start, (n7 || t8 || e).sourceSpan.end);
            this._addToParent(new fn.Comment(r6, s6));
        }
        _consumeDocType(e) {
            const t8 = this._advanceIf(En.TokenType.RAW_TEXT), n7 = this._advanceIf(En.TokenType.DOC_TYPE_END), r6 = null != t8 ? t8.parts[0].trim() : null, s6 = new o3.ParseSourceSpan(e.sourceSpan.start, (n7 || t8 || e).sourceSpan.end);
            this._addToParent(new fn.DocType(r6, s6));
        }
        _consumeExpansion(e) {
            const t8 = this._advance(), r6 = this._advance(), s6 = [];
            for(; this._peek.type === En.TokenType.EXPANSION_CASE_VALUE;){
                const e10 = this._parseExpansionCase();
                if (!e10) return;
                s6.push(e10);
            }
            if (this._peek.type !== En.TokenType.EXPANSION_FORM_END) return void this._errors.push(n4.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
            const i4 = new o3.ParseSourceSpan(e.sourceSpan.start, this._peek.sourceSpan.end);
            this._addToParent(new fn.Expansion(t8.parts[0], r6.parts[0], s6, i4, t8.sourceSpan)), this._advance();
        }
        _parseExpansionCase() {
            const e10 = this._advance();
            if (this._peek.type !== En.TokenType.EXPANSION_CASE_EXP_START) return this._errors.push(n4.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
            const t8 = this._advance(), r6 = this._collectExpansionExpTokens(t8);
            if (!r6) return null;
            const i4 = this._advance();
            r6.push(new En.Token(En.TokenType.EOF, [], i4.sourceSpan));
            const a4 = new s4(r6, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
            if (a4.errors.length > 0) return this._errors = this._errors.concat(a4.errors), null;
            const u4 = new o3.ParseSourceSpan(e10.sourceSpan.start, i4.sourceSpan.end), c4 = new o3.ParseSourceSpan(t8.sourceSpan.start, i4.sourceSpan.end);
            return new fn.ExpansionCase(e10.parts[0], a4.rootNodes, u4, e10.sourceSpan, c4);
        }
        _collectExpansionExpTokens(e) {
            const t8 = [], r6 = [
                En.TokenType.EXPANSION_CASE_EXP_START
            ];
            for(;;){
                if (this._peek.type !== En.TokenType.EXPANSION_FORM_START && this._peek.type !== En.TokenType.EXPANSION_CASE_EXP_START || r6.push(this._peek.type), this._peek.type === En.TokenType.EXPANSION_CASE_EXP_END) {
                    if (!i4(r6, En.TokenType.EXPANSION_CASE_EXP_START)) return this._errors.push(n4.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                    if (r6.pop(), 0 == r6.length) return t8;
                }
                if (this._peek.type === En.TokenType.EXPANSION_FORM_END) {
                    if (!i4(r6, En.TokenType.EXPANSION_FORM_START)) return this._errors.push(n4.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                    r6.pop();
                }
                if (this._peek.type === En.TokenType.EOF) return this._errors.push(n4.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                t8.push(this._advance());
            }
        }
        _getText(e) {
            let t8 = e.parts[0];
            if (t8.length > 0 && "\n" == t8[0]) {
                const e10 = this._getParentElement();
                null != e10 && 0 == e10.children.length && this.getTagDefinition(e10.name).ignoreFirstLf && (t8 = t8.substring(1));
            }
            return t8;
        }
        _consumeText(e) {
            const t8 = this._getText(e);
            t8.length > 0 && this._addToParent(new fn.Text(t8, e.sourceSpan));
        }
        _closeVoidElement() {
            const e10 = this._getParentElement();
            e10 && this.getTagDefinition(e10.name).isVoid && this._elementStack.pop();
        }
        _consumeStartTag(e) {
            const t8 = e.parts[0], r6 = e.parts[1], s6 = [];
            for(; this._peek.type === En.TokenType.ATTR_NAME;)s6.push(this._consumeAttr(this._advance()));
            const i4 = this._getElementFullName(t8, r6, this._getParentElement());
            let a4 = !1;
            if (this._peek.type === En.TokenType.TAG_OPEN_END_VOID) {
                this._advance(), a4 = !0;
                const t9 = this.getTagDefinition(i4);
                this.canSelfClose || t9.canSelfClose || null !== Dn.getNsPrefix(i4) || t9.isVoid || this._errors.push(n4.create(i4, e.sourceSpan, 'Only void and foreign elements can be self closed "'.concat(e.parts[1], '"')));
            } else this._peek.type === En.TokenType.TAG_OPEN_END && (this._advance(), a4 = !1);
            const u4 = this._peek.sourceSpan.start, c4 = new o3.ParseSourceSpan(e.sourceSpan.start, u4), l4 = new o3.ParseSourceSpan(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), p4 = new fn.Element(i4, s6, [], c4, c4, void 0, l4);
            this._pushElement(p4), a4 && (this._popElement(i4), p4.endSourceSpan = c4);
        }
        _pushElement(e) {
            const t8 = this._getParentElement();
            t8 && this.getTagDefinition(t8.name).isClosedByChild(e.name) && this._elementStack.pop(), this._addToParent(e), this._elementStack.push(e);
        }
        _consumeEndTag(e) {
            const t8 = this.allowHtmComponentClosingTags && 0 === e.parts.length ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getParentElement());
            if (this._getParentElement() && (this._getParentElement().endSourceSpan = e.sourceSpan), t8 && this.getTagDefinition(t8).isVoid) this._errors.push(n4.create(t8, e.sourceSpan, 'Void elements do not have end tags "'.concat(e.parts[1], '"')));
            else if (!this._popElement(t8)) {
                const r6 = 'Unexpected closing tag "'.concat(t8, '". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags');
                this._errors.push(n4.create(t8, e.sourceSpan, r6));
            }
        }
        _popElement(e) {
            for(let t8 = this._elementStack.length - 1; t8 >= 0; t8--){
                const n7 = this._elementStack[t8];
                if (!e || (Dn.getNsPrefix(n7.name) ? n7.name == e : n7.name.toLowerCase() == e.toLowerCase())) return this._elementStack.splice(t8, this._elementStack.length - t8), !0;
                if (!this.getTagDefinition(n7.name).closedByParent) return !1;
            }
            return !1;
        }
        _consumeAttr(e) {
            const t8 = Dn.mergeNsAndName(e.parts[0], e.parts[1]);
            let n7 = e.sourceSpan.end, r6 = "", s6 = void 0, i4 = void 0;
            if (this._peek.type === En.TokenType.ATTR_QUOTE) {
                i4 = this._advance().sourceSpan.start;
            }
            if (this._peek.type === En.TokenType.ATTR_VALUE) {
                const e10 = this._advance();
                r6 = e10.parts[0], n7 = e10.sourceSpan.end, s6 = e10.sourceSpan;
            }
            if (this._peek.type === En.TokenType.ATTR_QUOTE) {
                n7 = this._advance().sourceSpan.end, s6 = new o3.ParseSourceSpan(i4, n7);
            }
            return new fn.Attribute(t8, r6, new o3.ParseSourceSpan(e.sourceSpan.start, n7), s6, e.sourceSpan);
        }
        _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        _getParentElementSkippingContainers() {
            let e10 = null;
            for(let t8 = this._elementStack.length - 1; t8 >= 0; t8--){
                if (!Dn.isNgContainer(this._elementStack[t8].name)) return {
                    parent: this._elementStack[t8],
                    container: e10
                };
                e10 = this._elementStack[t8];
            }
            return {
                parent: null,
                container: e10
            };
        }
        _addToParent(e) {
            const t8 = this._getParentElement();
            null != t8 ? t8.children.push(e) : this._rootNodes.push(e);
        }
        _insertBeforeContainer(e, t, n) {
            if (t) {
                if (e) {
                    const r6 = e.children.indexOf(t);
                    e.children[r6] = n;
                } else this._rootNodes.push(n);
                n.children.push(t), this._elementStack.splice(this._elementStack.indexOf(t), 0, n);
            } else this._addToParent(n), this._elementStack.push(n);
        }
        _getElementFullName(e, t, n) {
            return "" === e && "" === (e = this.getTagDefinition(t).implicitNamespacePrefix || "") && null != n && (e = Dn.getNsPrefix(n.name)), Dn.mergeNsAndName(e, t);
        }
    }
    function i4(e10, t8) {
        return e10.length > 0 && e10[e10.length - 1] === t8;
    }
}), Tn1 = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    });
    var n4 = Cn;
    t3.ParseTreeResult = n4.ParseTreeResult, t3.TreeError = n4.TreeError;
    class r4 extends Cn.Parser {
        constructor(){
            super(hn.getHtmlTagDefinition);
        }
        parse(e, t, n, r = !1, s) {
            return super.parse(e, t, n, r, s);
        }
    }
    t3.HtmlParser = r4;
}), yn = t2(function(e5, t3) {
    Object.defineProperty(t3, "__esModule", {
        value: !0
    }), t3.TagContentType = Dn.TagContentType;
    let n4 = null;
    t3.parse = function(e6, t4 = {
    }) {
        const { canSelfClose: r4 = !1 , allowHtmComponentClosingTags: s4 = !1 , isTagNameCaseSensitive: i4 = !1 , getTagContentType: o4  } = t4;
        return (n4 || (n4 = new Tn1.HtmlParser), n4).parse(e6, "angular-html-parser", {
            tokenizeExpansionForms: !1,
            interpolationConfig: void 0,
            canSelfClose: r4,
            allowHtmComponentClosingTags: s4
        }, i4, o4);
    };
});
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
    }
    return getRandomValues(rnds8);
}
const __default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
    return typeof uuid === 'string' && __default.test(uuid);
}
var byteToHex = [];
for(var i4 = 0; i4 < 256; ++i4){
    byteToHex.push((i4 + 256).toString(16).substr(1));
}
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
function v41(options, buf, offset) {
    options = options || {
    };
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
        offset = offset || 0;
        for(var i5 = 0; i5 < 16; ++i5){
            buf[offset + i5] = rnds[i5];
        }
        return buf;
    }
    return stringify(rnds);
}
let ipfsKV;
async function saveToIPFS(content, type) {
    ipfsKV = ipfsKV || (await import("./ipfsKV.js")).ipfsKV;
    const cid = await ipfsKV.add(URL.createObjectURL(new Blob([
        content
    ], {
        type
    })));
    return `https://ipfs.io/ipfs/${cid}`;
}
let ipfsWorker;
const importScript = (src1, res = [])=>{
    const prefix = src1.slice(0, 8);
    if (prefix === "https://") {
        return window.document.head.querySelector(`script[src="${src1}"]`) || new Promise(function(resolve, reject) {
            const s4 = window.document.createElement("script");
            s4.src = src1;
            s4.type = "application/javascript";
            s4.onload = ()=>{
                if (res.length === 0) {
                    resolve(window);
                }
                const ret = {
                };
                res.forEach((x1)=>Object.assign(ret, window[x1])
                );
                resolve(ret);
            };
            s4.onerror = reject;
            window.document.head.appendChild(s4);
        });
    }
};
const getMonaco = async ()=>{
    const vsPath = "https://unpkg.com/monaco-editor@0.21.2/min/vs";
    const { require  } = await importScript("https://unpkg.com/monaco-editor@0.21.2/min/vs/loader.js");
    require.config({
        paths: {
            "vs": vsPath
        }
    });
    const monaco = await new Promise((resolve)=>require([
            "vs/editor/editor.main"
        ], (_m)=>resolve(_m)
        )
    );
    return monaco;
};
const isMobile = ()=>{
    if (typeof window === "undefined") return false;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent);
};
let aceEditor = {
};
const sha256 = async (x1)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof x1 === "string" ? new TextEncoder().encode(x1) : x1)).slice(0, 4)).map((b3)=>("00" + b3.toString(16)).slice(-2)
    ).join("")
;
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val)=>typeof val === "object" && val !== null || typeof val === "function"
;
const throwTransferHandler = {
    canHandle: (value)=>isObject(value) && throwMarker in value
    ,
    serialize ({ value  }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack
                }
            };
        } else {
            serialized = {
                isError: false,
                value
            };
        }
        return [
            serialized,
            []
        ];
    },
    deserialize (serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    }
};
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint)) endpoint.close();
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, {
        [proxyMarker]: true
    });
}
function generateUUID() {
    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)
    ).join("-");
}
const instanceOfAny = (object, constructors)=>constructors.some((c4)=>object instanceof c4
    )
;
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
        IDBDatabase,
        IDBObjectStore,
        IDBIndex,
        IDBCursor,
        IDBTransaction
    ]);
}
function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
        IDBCursor.prototype.advance,
        IDBCursor.prototype.continue,
        IDBCursor.prototype.continuePrimaryKey
    ]);
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx)) return;
    const done = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = ()=>{
            resolve();
            unlisten();
        };
        const error = ()=>{
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    transactionDoneMap.set(tx, done);
}
const unwrap = (value)=>reverseTransformCache.get(value)
;
const readMethods = [
    'get',
    'getKey',
    'getAll',
    'getAllKeys',
    'count'
];
const writeMethods = [
    'put',
    'add',
    'delete',
    'clear'
];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop)) return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function(storeName, ...args) {
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target1 = tx.store;
        if (useIndex) target1 = target1.index(args.shift());
        const returnVal = await target1[targetFuncName](...args);
        if (isWrite) await tx.done;
        return returnVal;
    };
    cachedMethods.set(prop, method);
    return method;
}
(function(d4, w3) {
    typeof exports == "object" && typeof module != "undefined" ? w3(exports) : typeof define == "function" && define.amd ? define([
        "exports"
    ], w3) : (d4 = d4 || self, w3(d4.Diff = {
    }));
})(this, function(d4) {
    "use strict";
    function w3() {
    }
    w3.prototype = {
        diff: function(n4, t3) {
            var r4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            }, f4 = r4.callback;
            typeof r4 == "function" && (f4 = r4, r4 = {
            }), this.options = r4;
            var i5 = this;
            function l4(c4) {
                return f4 ? (setTimeout(function() {
                    f4(void 0, c4);
                }, 0), !0) : c4;
            }
            n4 = this.castInput(n4), t3 = this.castInput(t3), n4 = this.removeEmpty(this.tokenize(n4)), t3 = this.removeEmpty(this.tokenize(t3));
            var s4 = t3.length, o4 = n4.length, u4 = 1, p4 = s4 + o4, v3 = [
                {
                    newPos: -1,
                    components: []
                }
            ], a4 = this.extractCommon(v3[0], t3, n4, 0);
            if (v3[0].newPos + 1 >= s4 && a4 + 1 >= o4) return l4([
                {
                    value: this.join(t3),
                    count: t3.length
                }
            ]);
            function h4() {
                for(var c4 = -1 * u4; c4 <= u4; c4 += 2){
                    var L = void 0, x1 = v3[c4 - 1], m4 = v3[c4 + 1], F3 = (m4 ? m4.newPos : 0) - c4;
                    x1 && (v3[c4 - 1] = void 0);
                    var y4 = x1 && x1.newPos + 1 < s4, E4 = m4 && 0 <= F3 && F3 < o4;
                    if (!y4 && !E4) {
                        v3[c4] = void 0;
                        continue;
                    }
                    if (!y4 || E4 && x1.newPos < m4.newPos ? (L = I3(m4), i5.pushComponent(L.components, void 0, !0)) : (L = x1, L.newPos++, i5.pushComponent(L.components, !0, void 0)), F3 = i5.extractCommon(L, t3, n4, c4), L.newPos + 1 >= s4 && F3 + 1 >= o4) return l4(H3(i5, L.components, t3, n4, i5.useLongestToken));
                    v3[c4] = L;
                }
                u4++;
            }
            if (f4) (function c4() {
                setTimeout(function() {
                    if (u4 > p4) return f4();
                    h4() || c4();
                }, 0);
            })();
            else for(; u4 <= p4;){
                var g3 = h4();
                if (g3) return g3;
            }
        },
        pushComponent: function(n4, t3, r4) {
            var f4 = n4[n4.length - 1];
            f4 && f4.added === t3 && f4.removed === r4 ? n4[n4.length - 1] = {
                count: f4.count + 1,
                added: t3,
                removed: r4
            } : n4.push({
                count: 1,
                added: t3,
                removed: r4
            });
        },
        extractCommon: function(n4, t3, r4, f4) {
            for(var i5 = t3.length, l4 = r4.length, s4 = n4.newPos, o4 = s4 - f4, u4 = 0; s4 + 1 < i5 && o4 + 1 < l4 && this.equals(t3[s4 + 1], r4[o4 + 1]);)s4++, o4++, u4++;
            return u4 && n4.components.push({
                count: u4
            }), n4.newPos = s4, o4;
        },
        equals: function(n4, t3) {
            return this.options.comparator ? this.options.comparator(n4, t3) : n4 === t3 || this.options.ignoreCase && n4.toLowerCase() === t3.toLowerCase();
        },
        removeEmpty: function(n4) {
            for(var t3 = [], r4 = 0; r4 < n4.length; r4++)n4[r4] && t3.push(n4[r4]);
            return t3;
        },
        castInput: function(n4) {
            return n4;
        },
        tokenize: function(n4) {
            return n4.split("");
        },
        join: function(n4) {
            return n4.join("");
        }
    };
    function H3(e5, n4, t3, r4, f4) {
        for(var i5 = 0, l4 = n4.length, s4 = 0, o4 = 0; i5 < l4; i5++){
            var u4 = n4[i5];
            if (u4.removed) {
                if ((u4.value = e5.join(r4.slice(o4, o4 + u4.count)), o4 += u4.count, i5 && n4[i5 - 1].added)) {
                    var v3 = n4[i5 - 1];
                    n4[i5 - 1] = n4[i5], n4[i5] = v3;
                }
            } else {
                if (!u4.added && f4) {
                    var p4 = t3.slice(s4, s4 + u4.count);
                    p4 = p4.map(function(h4, g3) {
                        var c4 = r4[o4 + g3];
                        return c4.length > h4.length ? c4 : h4;
                    }), u4.value = e5.join(p4);
                } else u4.value = e5.join(t3.slice(s4, s4 + u4.count));
                s4 += u4.count, u4.added || (o4 += u4.count);
            }
        }
        var a4 = n4[l4 - 1];
        return (l4 > 1 && typeof a4.value == "string" && (a4.added || a4.removed) && e5.equals("", a4.value) && (n4[l4 - 2].value += a4.value, n4.pop()), n4);
    }
    function I3(e5) {
        return {
            newPos: e5.newPos,
            components: e5.components.slice(0)
        };
    }
    var S2 = new w3;
    function W1(e5, n4, t3) {
        return S2.diff(e5, n4, t3);
    }
    function $2(e5, n4) {
        if (typeof e5 == "function") n4.callback = e5;
        else if (e5) for(var t3 in e5)e5.hasOwnProperty(t3) && (n4[t3] = e5[t3]);
        return n4;
    }
    var P2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, fe3 = /\S/, U3 = new w3;
    U3.equals = function(e5, n4) {
        return this.options.ignoreCase && (e5 = e5.toLowerCase(), n4 = n4.toLowerCase()), e5 === n4 || this.options.ignoreWhitespace && !fe3.test(e5) && !fe3.test(n4);
    }, U3.tokenize = function(e5) {
        for(var n4 = e5.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), t3 = 0; t3 < n4.length - 1; t3++)!n4[t3 + 1] && n4[t3 + 2] && P2.test(n4[t3]) && P2.test(n4[t3 + 2]) && (n4[t3] += n4[t3 + 2], n4.splice(t3 + 1, 2), t3--);
        return n4;
    };
    function me3(e5, n4, t3) {
        return (t3 = $2(t3, {
            ignoreWhitespace: !0
        }), U3.diff(e5, n4, t3));
    }
    function xe2(e5, n4, t3) {
        return U3.diff(e5, n4, t3);
    }
    var V3 = new w3;
    V3.tokenize = function(e5) {
        var n4 = [], t3 = e5.split(/(\n|\r\n)/);
        t3[t3.length - 1] || t3.pop();
        for(var r4 = 0; r4 < t3.length; r4++){
            var f4 = t3[r4];
            r4 % 2 && !this.options.newlineIsToken ? n4[n4.length - 1] += f4 : (this.options.ignoreWhitespace && (f4 = f4.trim()), n4.push(f4));
        }
        return n4;
    };
    function le2(e5, n4, t3) {
        return V3.diff(e5, n4, t3);
    }
    function Fe2(e5, n4, t3) {
        var r4 = $2(t3, {
            ignoreWhitespace: !0
        });
        return V3.diff(e5, n4, r4);
    }
    var se1 = new w3;
    se1.tokenize = function(e5) {
        return e5.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function Ne3(e5, n4, t3) {
        return se1.diff(e5, n4, t3);
    }
    var oe1 = new w3;
    oe1.tokenize = function(e5) {
        return e5.split(/([{}:;,]|\s+)/);
    };
    function Se1(e5, n4, t3) {
        return oe1.diff(e5, n4, t3);
    }
    function X2(e5) {
        return (typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? X2 = function(n4) {
            return typeof n4;
        } : X2 = function(n4) {
            return n4 && typeof Symbol == "function" && n4.constructor === Symbol && n4 !== Symbol.prototype ? "symbol" : typeof n4;
        }, X2(e5));
    }
    function b3(e5) {
        return He(e5) || Ie3(e5) || be3(e5) || Ee3();
    }
    function He(e5) {
        if (Array.isArray(e5)) return j3(e5);
    }
    function Ie3(e5) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e5)) return Array.from(e5);
    }
    function be3(e5, n4) {
        if (!e5) return;
        if (typeof e5 == "string") return j3(e5, n4);
        var t3 = Object.prototype.toString.call(e5).slice(8, -1);
        if ((t3 === "Object" && e5.constructor && (t3 = e5.constructor.name), t3 === "Map" || t3 === "Set")) return Array.from(e5);
        if (t3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3)) return j3(e5, n4);
    }
    function j3(e5, n4) {
        (n4 == null || n4 > e5.length) && (n4 = e5.length);
        for(var t3 = 0, r4 = new Array(n4); t3 < n4; t3++)r4[t3] = e5[t3];
        return r4;
    }
    function Ee3() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Ae2 = Object.prototype.toString, J = new w3;
    J.useLongestToken = !0, J.tokenize = V3.tokenize, J.castInput = function(e5) {
        var n4 = this.options, t3 = n4.undefinedReplacement, r4 = n4.stringifyReplacer, f4 = r4 === void 0 ? function(i5, l4) {
            return typeof l4 == "undefined" ? t3 : l4;
        } : r4;
        return typeof e5 == "string" ? e5 : JSON.stringify(Z3(e5, null, null, f4), f4, "  ");
    }, J.equals = function(e5, n4) {
        return w3.prototype.equals.call(J, e5.replace(/,([\r\n])/g, "$1"), n4.replace(/,([\r\n])/g, "$1"));
    };
    function Te2(e5, n4, t3) {
        return J.diff(e5, n4, t3);
    }
    function Z3(e5, n4, t3, r4, f4) {
        n4 = n4 || [], t3 = t3 || [], r4 && (e5 = r4(f4, e5));
        var i5;
        for(i5 = 0; i5 < n4.length; i5 += 1)if (n4[i5] === e5) return t3[i5];
        var l4;
        if (Ae2.call(e5) === "[object Array]") {
            for((n4.push(e5), l4 = new Array(e5.length), t3.push(l4), i5 = 0); i5 < e5.length; i5 += 1)l4[i5] = Z3(e5[i5], n4, t3, r4, f4);
            return (n4.pop(), t3.pop(), l4);
        }
        if ((e5 && e5.toJSON && (e5 = e5.toJSON()), X2(e5) === "object" && e5 !== null)) {
            n4.push(e5), l4 = {
            }, t3.push(l4);
            var s4 = [], o4;
            for(o4 in e5)e5.hasOwnProperty(o4) && s4.push(o4);
            for((s4.sort(), i5 = 0); i5 < s4.length; i5 += 1)o4 = s4[i5], l4[o4] = Z3(e5[o4], n4, t3, r4, o4);
            n4.pop(), t3.pop();
        } else l4 = e5;
        return l4;
    }
    var B2 = new w3;
    B2.tokenize = function(e5) {
        return e5.slice();
    }, B2.join = B2.removeEmpty = function(e5) {
        return e5;
    };
    function Oe2(e5, n4, t3) {
        return B2.diff(e5, n4, t3);
    }
    function G2(e5) {
        var n4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        }, t3 = e5.split(/\r\n|[\n\v\f\r\x85]/), r4 = e5.match(/\r\n|[\n\v\f\r\x85]/g) || [], f4 = [], i5 = 0;
        function l4() {
            var u4 = {
            };
            for(f4.push(u4); i5 < t3.length;){
                var p4 = t3[i5];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(p4)) break;
                var v3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(p4);
                v3 && (u4.index = v3[1]), i5++;
            }
            for((s4(u4), s4(u4), u4.hunks = []); i5 < t3.length;){
                var a4 = t3[i5];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(a4)) break;
                if (/^@@/.test(a4)) u4.hunks.push(o4());
                else {
                    if (a4 && n4.strict) throw new Error("Unknown line " + (i5 + 1) + " " + JSON.stringify(a4));
                    i5++;
                }
            }
        }
        function s4(u4) {
            var p4 = /^(---|\+\+\+)\s+(.*)$/.exec(t3[i5]);
            if (p4) {
                var v3 = p4[1] === "---" ? "old" : "new", a4 = p4[2].split("	", 2), h4 = a4[0].replace(/\\\\/g, "\\");
                /^".*"$/.test(h4) && (h4 = h4.substr(1, h4.length - 2)), u4[v3 + "FileName"] = h4, u4[v3 + "Header"] = (a4[1] || "").trim(), i5++;
            }
        }
        function o4() {
            var u4 = i5, p4 = t3[i5++], v3 = p4.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), a4 = {
                oldStart: +v3[1],
                oldLines: typeof v3[2] == "undefined" ? 1 : +v3[2],
                newStart: +v3[3],
                newLines: typeof v3[4] == "undefined" ? 1 : +v3[4],
                lines: [],
                linedelimiters: []
            };
            a4.oldLines === 0 && (a4.oldStart += 1), a4.newLines === 0 && (a4.newStart += 1);
            for(var h4 = 0, g3 = 0; i5 < t3.length && !(t3[i5].indexOf("--- ") === 0 && i5 + 2 < t3.length && t3[i5 + 1].indexOf("+++ ") === 0 && t3[i5 + 2].indexOf("@@") === 0); i5++){
                var c4 = t3[i5].length == 0 && i5 != t3.length - 1 ? " " : t3[i5][0];
                if (c4 === "+" || c4 === "-" || c4 === " " || c4 === "\\") a4.lines.push(t3[i5]), a4.linedelimiters.push(r4[i5] || `\n`), c4 === "+" ? h4++ : c4 === "-" ? g3++ : c4 === " " && (h4++, g3++);
                else break;
            }
            if ((!h4 && a4.newLines === 1 && (a4.newLines = 0), !g3 && a4.oldLines === 1 && (a4.oldLines = 0), n4.strict)) {
                if (h4 !== a4.newLines) throw new Error("Added line count did not match for hunk at line " + (u4 + 1));
                if (g3 !== a4.oldLines) throw new Error("Removed line count did not match for hunk at line " + (u4 + 1));
            }
            return a4;
        }
        for(; i5 < t3.length;)l4();
        return f4;
    }
    function ze1(e5, n4, t3) {
        var r4 = !0, f4 = !1, i5 = !1, l4 = 1;
        return function s4() {
            if (r4 && !i5) {
                if ((f4 ? l4++ : r4 = !1, e5 + l4 <= t3)) return l4;
                i5 = !0;
            }
            if (!f4) return (i5 || (r4 = !0), n4 <= e5 - l4 ? -l4++ : (f4 = !0, s4()));
        };
    }
    function ue1(e5, n4) {
        var t3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        };
        if ((typeof n4 == "string" && (n4 = G2(n4)), Array.isArray(n4))) {
            if (n4.length > 1) throw new Error("applyPatch only works with a single input.");
            n4 = n4[0];
        }
        var r4 = e5.split(/\r\n|[\n\v\f\r\x85]/), f4 = e5.match(/\r\n|[\n\v\f\r\x85]/g) || [], i5 = n4.hunks, l4 = t3.compareLine || function(re1, D4, K2, C3) {
            return D4 === C3;
        }, s4 = 0, o4 = t3.fuzzFactor || 0, u4 = 0, p4 = 0, v3, a4;
        function h4(re1, D4) {
            for(var K2 = 0; K2 < re1.lines.length; K2++){
                var C3 = re1.lines[K2], ie1 = C3.length > 0 ? C3[0] : " ", Ze = C3.length > 0 ? C3.substr(1) : C3;
                if (ie1 === " " || ie1 === "-") {
                    if (!l4(D4 + 1, r4[D4], ie1, Ze) && (s4++, s4 > o4)) return !1;
                    D4++;
                }
            }
            return !0;
        }
        for(var g3 = 0; g3 < i5.length; g3++){
            for(var c4 = i5[g3], L = r4.length - c4.oldLines, x1 = 0, m4 = p4 + c4.oldStart - 1, F3 = ze1(m4, u4, L); x1 !== void 0; x1 = F3())if (h4(c4, m4 + x1)) {
                c4.offset = p4 += x1;
                break;
            }
            if (x1 === void 0) return !1;
            u4 = c4.offset + c4.oldStart + c4.oldLines;
        }
        for(var y4 = 0, E4 = 0; E4 < i5.length; E4++){
            var N3 = i5[E4], A3 = N3.oldStart + N3.offset + y4 - 1;
            y4 += N3.newLines - N3.oldLines;
            for(var T3 = 0; T3 < N3.lines.length; T3++){
                var O2 = N3.lines[T3], z2 = O2.length > 0 ? O2[0] : " ", Y1 = O2.length > 0 ? O2.substr(1) : O2, te1 = N3.linedelimiters[T3];
                if (z2 === " ") A3++;
                else if (z2 === "-") r4.splice(A3, 1), f4.splice(A3, 1);
                else if (z2 === "+") r4.splice(A3, 0, Y1), f4.splice(A3, 0, te1), A3++;
                else if (z2 === "\\") {
                    var R3 = N3.lines[T3 - 1] ? N3.lines[T3 - 1][0] : null;
                    R3 === "+" ? v3 = !0 : R3 === "-" && (a4 = !0);
                }
            }
        }
        if (v3) for(; !r4[r4.length - 1];)r4.pop(), f4.pop();
        else a4 && (r4.push(""), f4.push(`\n`));
        for(var q3 = 0; q3 < r4.length - 1; q3++)r4[q3] = r4[q3] + f4[q3];
        return r4.join("");
    }
    function We(e5, n4) {
        typeof e5 == "string" && (e5 = G2(e5));
        var t3 = 0;
        function r4() {
            var f4 = e5[t3++];
            if (!f4) return n4.complete();
            n4.loadFile(f4, function(i5, l4) {
                if (i5) return n4.complete(i5);
                var s4 = ue1(l4, f4, n4);
                n4.patched(f4, s4, function(o4) {
                    if (o4) return n4.complete(o4);
                    r4();
                });
            });
        }
        r4();
    }
    function _3(e5, n4, t3, r4, f4, i5, l4) {
        l4 || (l4 = {
        }), typeof l4.context == "undefined" && (l4.context = 4);
        var s4 = le2(t3, r4, l4);
        s4.push({
            value: "",
            lines: []
        });
        function o4(x1) {
            return x1.map(function(m4) {
                return " " + m4;
            });
        }
        for(var u4 = [], p4 = 0, v3 = 0, a4 = [], h4 = 1, g3 = 1, c4 = function(m4) {
            var F3 = s4[m4], y4 = F3.lines || F3.value.replace(/\n$/, "").split(`\n`);
            if ((F3.lines = y4, F3.added || F3.removed)) {
                var E4;
                if (!p4) {
                    var N3 = s4[m4 - 1];
                    p4 = h4, v3 = g3, N3 && (a4 = l4.context > 0 ? o4(N3.lines.slice(-l4.context)) : [], p4 -= a4.length, v3 -= a4.length);
                }
                (E4 = a4).push.apply(E4, b3(y4.map(function(q3) {
                    return (F3.added ? "+" : "-") + q3;
                }))), F3.added ? g3 += y4.length : h4 += y4.length;
            } else {
                if (p4) {
                    if (y4.length <= l4.context * 2 && m4 < s4.length - 2) {
                        var A3;
                        (A3 = a4).push.apply(A3, b3(o4(y4)));
                    } else {
                        var T3, O2 = Math.min(y4.length, l4.context);
                        (T3 = a4).push.apply(T3, b3(o4(y4.slice(0, O2))));
                        var z2 = {
                            oldStart: p4,
                            oldLines: h4 - p4 + O2,
                            newStart: v3,
                            newLines: g3 - v3 + O2,
                            lines: a4
                        };
                        if (m4 >= s4.length - 2 && y4.length <= l4.context) {
                            var Y1 = /\n$/.test(t3), te1 = /\n$/.test(r4), R3 = y4.length == 0 && a4.length > z2.oldLines;
                            !Y1 && R3 && t3.length > 0 && a4.splice(z2.oldLines, 0, "\\ No newline at end of file"), (!Y1 && !R3 || !te1) && a4.push("\\ No newline at end of file");
                        }
                        u4.push(z2), p4 = 0, v3 = 0, a4 = [];
                    }
                }
                h4 += y4.length, g3 += y4.length;
            }
        }, L = 0; L < s4.length; L++)c4(L);
        return {
            oldFileName: e5,
            newFileName: n4,
            oldHeader: f4,
            newHeader: i5,
            hunks: u4
        };
    }
    function Me3(e5) {
        var n4 = [];
        e5.oldFileName == e5.newFileName && n4.push("Index: " + e5.oldFileName), n4.push("==================================================================="), n4.push("--- " + e5.oldFileName + (typeof e5.oldHeader == "undefined" ? "" : "	" + e5.oldHeader)), n4.push("+++ " + e5.newFileName + (typeof e5.newHeader == "undefined" ? "" : "	" + e5.newHeader));
        for(var t3 = 0; t3 < e5.hunks.length; t3++){
            var r4 = e5.hunks[t3];
            r4.oldLines === 0 && (r4.oldStart -= 1), r4.newLines === 0 && (r4.newStart -= 1), n4.push("@@ -" + r4.oldStart + "," + r4.oldLines + " +" + r4.newStart + "," + r4.newLines + " @@"), n4.push.apply(n4, r4.lines);
        }
        return n4.join(`\n`) + `\n`;
    }
    function ae1(e5, n4, t3, r4, f4, i5, l4) {
        return Me3(_3(e5, n4, t3, r4, f4, i5, l4));
    }
    function qe3(e5, n4, t3, r4, f4, i5) {
        return ae1(e5, e5, n4, t3, r4, f4, i5);
    }
    function Ce1(e5, n4) {
        return e5.length !== n4.length ? !1 : k4(e5, n4);
    }
    function k4(e5, n4) {
        if (n4.length > e5.length) return !1;
        for(var t3 = 0; t3 < n4.length; t3++)if (n4[t3] !== e5[t3]) return !1;
        return !0;
    }
    function Je(e5) {
        var n4 = ne2(e5.lines), t3 = n4.oldLines, r4 = n4.newLines;
        t3 !== void 0 ? e5.oldLines = t3 : delete e5.oldLines, r4 !== void 0 ? e5.newLines = r4 : delete e5.newLines;
    }
    function $e2(e5, n4, t3) {
        e5 = de4(e5, t3), n4 = de4(n4, t3);
        var r4 = {
        };
        (e5.index || n4.index) && (r4.index = e5.index || n4.index), (e5.newFileName || n4.newFileName) && (ce3(e5) ? ce3(n4) ? (r4.oldFileName = Q2(r4, e5.oldFileName, n4.oldFileName), r4.newFileName = Q2(r4, e5.newFileName, n4.newFileName), r4.oldHeader = Q2(r4, e5.oldHeader, n4.oldHeader), r4.newHeader = Q2(r4, e5.newHeader, n4.newHeader)) : (r4.oldFileName = e5.oldFileName, r4.newFileName = e5.newFileName, r4.oldHeader = e5.oldHeader, r4.newHeader = e5.newHeader) : (r4.oldFileName = n4.oldFileName || e5.oldFileName, r4.newFileName = n4.newFileName || e5.newFileName, r4.oldHeader = n4.oldHeader || e5.oldHeader, r4.newHeader = n4.newHeader || e5.newHeader)), r4.hunks = [];
        for(var f4 = 0, i5 = 0, l4 = 0, s4 = 0; f4 < e5.hunks.length || i5 < n4.hunks.length;){
            var o4 = e5.hunks[f4] || {
                oldStart: Infinity
            }, u4 = n4.hunks[i5] || {
                oldStart: Infinity
            };
            if (pe3(o4, u4)) r4.hunks.push(ve4(o4, l4)), f4++, s4 += o4.newLines - o4.oldLines;
            else if (pe3(u4, o4)) r4.hunks.push(ve4(u4, s4)), i5++, l4 += u4.newLines - u4.oldLines;
            else {
                var p4 = {
                    oldStart: Math.min(o4.oldStart, u4.oldStart),
                    oldLines: 0,
                    newStart: Math.min(o4.newStart + l4, u4.oldStart + s4),
                    newLines: 0,
                    lines: []
                };
                Re3(p4, o4.oldStart, o4.lines, u4.oldStart, u4.lines), i5++, f4++, r4.hunks.push(p4);
            }
        }
        return r4;
    }
    function de4(e5, n4) {
        if (typeof e5 == "string") {
            if (/^@@/m.test(e5) || /^Index:/m.test(e5)) return G2(e5)[0];
            if (!n4) throw new Error("Must provide a base reference or pass in a patch");
            return _3(void 0, void 0, n4, e5);
        }
        return e5;
    }
    function ce3(e5) {
        return e5.newFileName && e5.newFileName !== e5.oldFileName;
    }
    function Q2(e5, n4, t3) {
        return n4 === t3 ? n4 : (e5.conflict = !0, {
            mine: n4,
            theirs: t3
        });
    }
    function pe3(e5, n4) {
        return e5.oldStart < n4.oldStart && e5.oldStart + e5.oldLines < n4.oldStart;
    }
    function ve4(e5, n4) {
        return {
            oldStart: e5.oldStart,
            oldLines: e5.oldLines,
            newStart: e5.newStart + n4,
            newLines: e5.newLines,
            lines: e5.lines
        };
    }
    function Re3(e5, n4, t3, r4, f4) {
        var i5 = {
            offset: n4,
            lines: t3,
            index: 0
        }, l4 = {
            offset: r4,
            lines: f4,
            index: 0
        };
        for((we4(e5, i5, l4), we4(e5, l4, i5)); i5.index < i5.lines.length && l4.index < l4.lines.length;){
            var s4 = i5.lines[i5.index], o4 = l4.lines[l4.index];
            if ((s4[0] === "-" || s4[0] === "+") && (o4[0] === "-" || o4[0] === "+")) De3(e5, i5, l4);
            else if (s4[0] === "+" && o4[0] === " ") {
                var u4;
                (u4 = e5.lines).push.apply(u4, b3(M3(i5)));
            } else if (o4[0] === "+" && s4[0] === " ") {
                var p4;
                (p4 = e5.lines).push.apply(p4, b3(M3(l4)));
            } else s4[0] === "-" && o4[0] === " " ? he4(e5, i5, l4) : o4[0] === "-" && s4[0] === " " ? he4(e5, l4, i5, !0) : s4 === o4 ? (e5.lines.push(s4), i5.index++, l4.index++) : ee3(e5, M3(i5), M3(l4));
        }
        ge4(e5, i5), ge4(e5, l4), Je(e5);
    }
    function De3(e5, n4, t3) {
        var r4 = M3(n4), f4 = M3(t3);
        if (ye3(r4) && ye3(f4)) {
            if (k4(r4, f4) && Le4(t3, r4, r4.length - f4.length)) {
                var i5;
                (i5 = e5.lines).push.apply(i5, b3(r4));
                return;
            } else if (k4(f4, r4) && Le4(n4, f4, f4.length - r4.length)) {
                var l4;
                (l4 = e5.lines).push.apply(l4, b3(f4));
                return;
            }
        } else if (Ce1(r4, f4)) {
            var s4;
            (s4 = e5.lines).push.apply(s4, b3(r4));
            return;
        }
        ee3(e5, r4, f4);
    }
    function he4(e5, n4, t3, r4) {
        var f4 = M3(n4), i5 = Pe4(t3, f4);
        if (i5.merged) {
            var l4;
            (l4 = e5.lines).push.apply(l4, b3(i5.merged));
        } else ee3(e5, r4 ? i5 : f4, r4 ? f4 : i5);
    }
    function ee3(e5, n4, t3) {
        e5.conflict = !0, e5.lines.push({
            conflict: !0,
            mine: n4,
            theirs: t3
        });
    }
    function we4(e5, n4, t3) {
        for(; n4.offset < t3.offset && n4.index < n4.lines.length;){
            var r4 = n4.lines[n4.index++];
            e5.lines.push(r4), n4.offset++;
        }
    }
    function ge4(e5, n4) {
        for(; n4.index < n4.lines.length;){
            var t3 = n4.lines[n4.index++];
            e5.lines.push(t3);
        }
    }
    function M3(e5) {
        for(var n4 = [], t3 = e5.lines[e5.index][0]; e5.index < e5.lines.length;){
            var r4 = e5.lines[e5.index];
            if ((t3 === "-" && r4[0] === "+" && (t3 = "+"), t3 === r4[0])) n4.push(r4), e5.index++;
            else break;
        }
        return n4;
    }
    function Pe4(e5, n4) {
        for(var t3 = [], r4 = [], f4 = 0, i5 = !1, l4 = !1; f4 < n4.length && e5.index < e5.lines.length;){
            var s4 = e5.lines[e5.index], o4 = n4[f4];
            if (o4[0] === "+") break;
            if ((i5 = i5 || s4[0] !== " ", r4.push(o4), f4++, s4[0] === "+")) for(l4 = !0; s4[0] === "+";)t3.push(s4), s4 = e5.lines[++e5.index];
            o4.substr(1) === s4.substr(1) ? (t3.push(s4), e5.index++) : l4 = !0;
        }
        if (((n4[f4] || "")[0] === "+" && i5 && (l4 = !0), l4)) return t3;
        for(; f4 < n4.length;)r4.push(n4[f4++]);
        return {
            merged: r4,
            changes: t3
        };
    }
    function ye3(e5) {
        return e5.reduce(function(n4, t3) {
            return n4 && t3[0] === "-";
        }, !0);
    }
    function Le4(e5, n4, t3) {
        for(var r4 = 0; r4 < t3; r4++){
            var f4 = n4[n4.length - t3 + r4].substr(1);
            if (e5.lines[e5.index + r4] !== " " + f4) return !1;
        }
        return (e5.index += t3, !0);
    }
    function ne2(e5) {
        var n4 = 0, t3 = 0;
        return (e5.forEach(function(r4) {
            if (typeof r4 != "string") {
                var f4 = ne2(r4.mine), i5 = ne2(r4.theirs);
                n4 !== void 0 && (f4.oldLines === i5.oldLines ? n4 += f4.oldLines : n4 = void 0), t3 !== void 0 && (f4.newLines === i5.newLines ? t3 += f4.newLines : t3 = void 0);
            } else t3 !== void 0 && (r4[0] === "+" || r4[0] === " ") && t3++, n4 !== void 0 && (r4[0] === "-" || r4[0] === " ") && n4++;
        }), {
            oldLines: n4,
            newLines: t3
        });
    }
    function Ue2(e5) {
        for(var n4 = [], t3, r4, f4 = 0; f4 < e5.length; f4++)t3 = e5[f4], t3.added ? r4 = 1 : t3.removed ? r4 = -1 : r4 = 0, n4.push([
            r4,
            t3.value
        ]);
        return n4;
    }
    function Ve2(e5) {
        for(var n4 = [], t3 = 0; t3 < e5.length; t3++){
            var r4 = e5[t3];
            r4.added ? n4.push("<ins>") : r4.removed && n4.push("<del>"), n4.push(Xe(r4.value)), r4.added ? n4.push("</ins>") : r4.removed && n4.push("</del>");
        }
        return n4.join("");
    }
    function Xe(e5) {
        var n4 = e5;
        return (n4 = n4.replace(/&/g, "&amp;"), n4 = n4.replace(/</g, "&lt;"), n4 = n4.replace(/>/g, "&gt;"), n4 = n4.replace(/"/g, "&quot;"), n4);
    }
    d4.Diff = w3, d4.applyPatch = ue1, d4.applyPatches = We, d4.canonicalize = Z3, d4.convertChangesToDMP = Ue2, d4.convertChangesToXML = Ve2, d4.createPatch = qe3, d4.createTwoFilesPatch = ae1, d4.diffArrays = Oe2, d4.diffChars = W1, d4.diffCss = Se1, d4.diffJson = Te2, d4.diffLines = le2, d4.diffSentences = Ne3, d4.diffTrimmedLines = Fe2, d4.diffWords = me3, d4.diffWordsWithSpace = xe2, d4.merge = $e2, d4.parsePatch = G2, d4.structuredPatch = _3, Object.defineProperty(d4, "__esModule", {
        value: !0
    });
});
const Be2 = async (d4)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof d4 == "string" ? new TextEncoder().encode(d4) : d4)).slice(0, 4)).map((w3)=>("00" + w3.toString(16)).slice(-2)
    ).join("")
;
const diff = async (d4, w3)=>{
    const H3 = Be2(d4), I3 = Diff.diffChars(d4, w3);
    return {
        b: await H3,
        c: I3.map((S2)=>S2.added ? S2.value : S2.removed ? -S2.count : S2.count
        )
    };
}, isDiff = (d4)=>{
    if (d4.length < 10) return !1;
    const w3 = [
        ...d4.slice(0, 8)
    ].filter((I3)=>I3 < "0" || I3 > "f"
    ).length === 0, H3 = d4.slice(8);
    if (w3 && H3[0] === "[" && H3[H3.length - 1] === "]") try {
        return JSON.parse(H3).length > 1;
    } catch  {
        return !1;
    }
    return !1;
}, assemble = (d4, w3)=>{
    const H3 = JSON.parse(w3);
    let I3 = d4.slice(), S2 = "";
    return H3.forEach((W1)=>{
        if (Number(W1) === W1) {
            const $2 = Math.abs(W1), P2 = I3.slice(0, $2);
            I3 = I3.slice($2), W1 > 0 && (S2 += String(P2));
        } else S2 += String(W1);
    }), S2;
};
const sha2561 = async (x1)=>Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256", typeof x1 === "string" ? new TextEncoder().encode(x1) : x1)).slice(0, 4)).map((b3)=>("00" + b3.toString(16)).slice(-2)
    ).join("")
;
const getDbObj = (db1)=>{
    const dbObj = {
        async get (key, format = "string") {
            let data;
            try {
                data = await db1.get(key);
                if (!data) {
                    return null;
                }
            } catch (_) {
                return null;
            }
            if (format === "json") {
                return JSON.parse(data);
            }
            const allData = await data;
            if (format === "string") {
                if (typeof allData === "string" && format === "string") {
                    const text = allData;
                    if (isDiff(allData)) {
                        const keyOfDiff = allData.slice(0, 8);
                        const instructions = allData.slice(8);
                        const oldValue = await dbObj.get(keyOfDiff);
                        return assemble(oldValue, instructions);
                    }
                    return allData;
                }
                return new TextDecoder().decode(allData);
            }
            return data;
        },
        async put (key, val) {
            let prev;
            try {
                const oldKey = await dbObj.get(key);
                if (typeof oldKey === "string" && typeof val === "string" && oldKey.length === 8 && oldKey !== val) {
                    const actualValue = await dbObj.get(val);
                    const prevValue = await dbObj.get(oldKey);
                    if (typeof prevValue === "string") {
                        const prevSha = await sha2561(prevValue);
                        if (prevSha === oldKey) {
                            const diffObj = await diff(actualValue, prevValue);
                            const diffAsStr = diffObj.b + JSON.stringify(diffObj.c);
                            await dbObj.put(prevSha, diffAsStr);
                        }
                    }
                }
            } catch  {
                prev = "";
            }
            if (prev !== "" && val === prev) {
                return val;
            }
            let str;
            if (typeof val !== "string") {
                str = new TextDecoder().decode(val);
            } else {
                str = val;
            }
            return await db1.put(key, str);
        },
        async delete (key) {
            return await db1.delete(key);
        },
        async clear () {
            return await db1.clear();
        },
        async keys () {
            return await db1.getAllKeys();
        }
    };
    return dbObj;
};
export async function run(mode = "window", _w) {
    console.log("Runner");
    const { document , open  } = _w;
    const session = getSession();
    const { getCodeToLoad  } = await import("./data.js");
    const { code  } = await getCodeToLoad();
    session.code = await formatter(code);
    session.transpiled = await transpile(session.code);
    if (mode === "editor") {
        const { renderDraggableEditor  } = await import("./DraggableEditor.js");
        renderDraggableEditor();
    }
    if (mode === "window") {
        const onShare = async ()=>{
            const { shareItAsHtml  } = await import("./share.js");
            const link = await shareItAsHtml({
                code: session.transpiled,
                HTML: session.HTML
            });
            open(link);
        };
        const { renderDraggableWindow  } = await import("./DraggableWindow.js");
        await renderDraggableWindow({
            onShare
        }, src);
    }
    const transpiled = await transpile(session.code);
    await restartCode(transpiled);
    const startMonaco = (await import("https://unpkg.com/@zedvision/smart-monaco-editor@10.13.4/dist/editor.js")).default;
    let modules = await startMonaco({
        language: "typescript",
        code: session.code,
        onChange: (code1)=>runner(code1)
    });
    async function runner(c4) {
        const cd = await formatter(c4);
        try {
            const transpiled1 = await transpile(cd);
            if (session.transpiled === transpiled1 && transpiled1 !== "") return;
            let restartError = false;
            if (transpiled1.length && session.lastErrors === 0) {
                restartError = await restartCode(transpiled1);
            }
            const err = [
                ...restartError ? [
                    {
                        messageText: "Error while starting the app. Check the console!"
                    }, 
                ] : [],
                ...[
                    await getErrors(cd)
                ], 
            ];
            if (err.length) console.log({
                err
            });
            if (session.lastErrors && err.length === 0) restartCode(transpiled1);
            session.lastErrors = err.length;
            const errorDiv = document.getElementById("error");
            if (err.length === 0 && transpiled1.length) {
                session.code = cd;
                if (session.transpiled !== transpiled1) {
                    session.transpiled = transpiled1;
                    const { saveCode  } = await import("./data.js");
                    await saveCode(await formatter(cd), session.transpiled);
                }
            } else {
                session.error = cd;
                const { diff: diff1  } = await import("https://unpkg.com/@zedvision/diff@10.12.3/dist/diff.min.js");
                const slices = await diff1(session.code, cd);
                if (slices.c.length <= 3) {
                    session.lastErrors = 0;
                    return;
                }
                if (slices.c.length == 4) {
                    session.lastErrors = 0;
                    modules.monaco.editor.setTheme("hc-black");
                    return;
                }
                errorDiv.innerHTML = err[0].messageText.toString();
                errorDiv.style.display = "block";
                return;
            }
            errorDiv.style.display = "none";
            modules.monaco.editor.setTheme("vs-dark");
        } catch (err) {
            modules.monaco.editor.setTheme("vs-light");
            setTimeout(()=>{
                modules.monaco.editor.setTheme("hc-black");
            }, 50);
            console.error(err);
        }
    }
    async function getErrors(code1) {
        if (!modules || !modules.monaco) return;
        const { monaco  } = modules;
        const { sha256: sha2562  } = await import("./sha256.js");
        const shaCode = await sha2562(code1);
        const filename = `file:///${shaCode}.tsx`;
        const uri = monaco.Uri.parse(filename);
        const model = monaco.editor.getModel(uri) || await monaco.editor.createModel(code1, "typescript", uri);
        const worker = await monaco.languages.typescript.getTypeScriptWorker();
        const client = await worker(model.uri);
        const diag = client.getSemanticDiagnostics(filename);
        const comp = client.getCompilerOptionsDiagnostics(filename);
        const syntax = client.getSyntacticDiagnostics(filename);
        const fastError = await Promise.race([
            diag,
            comp,
            syntax
        ]);
        model.dispose();
        return [
            ...fastError, 
        ];
    }
    async function restartCode(transpiled1) {
        if (renderEmotion === null) {
            renderEmotion = (await import(src)).renderEmotion;
        }
        let hadError = false;
        if (typeof transpiled1 !== "string" || transpiled1 === "") {
            hadError = true;
            return hadError;
        }
        const codeToHydrate = mode === "window" ? transpiled1.replace("body{", "#zbody{") : transpiled1;
        const root = document.createElement("div");
        const Element1 = (await import(createJsBlob(codeToHydrate))).default;
        session.unmount();
        session.unmount = renderEmotion(Element1(), root);
        document.getElementById("zbody").children.length && document.getElementById("zbody").children[0].remove();
        document.getElementById("zbody").appendChild(root);
        session.HTML = root.innerHTML;
        return !session.HTML;
    }
}
function g3(e5) {
    return (function(e6) {
        if (Array.isArray(e6)) return D3(e6);
    })(e5) || (function(e6) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e6)) return Array.from(e6);
    })(e5) || (function(e6, t3) {
        if (!e6) return;
        if ("string" == typeof e6) return D3(e6, t3);
        var n4 = Object.prototype.toString.call(e6).slice(8, -1);
        "Object" === n4 && e6.constructor && (n4 = e6.constructor.name);
        if ("Map" === n4 || "Set" === n4) return Array.from(e6);
        if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return D3(e6, t3);
    })(e5) || (function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    })();
}
function x1(e5, t3, n4, r4, o4, u4, i5) {
    i5 || (i5 = {
    }), (void 0) === i5.context && (i5.context = 4);
    var a4 = d1(n4, r4, i5);
    function s4(e6) {
        return e6.map(function(e7) {
            return " " + e7;
        });
    }
    a4.push({
        value: "",
        lines: []
    });
    for(var l4 = [], c4 = 0, p4 = 0, f4 = [], h4 = 1, m4 = 1, D4 = function(e6) {
        var t4 = a4[e6], o5 = t4.lines || t4.value.replace(/\n$/, "").split("\n");
        if ((t4.lines = o5, t4.added || t4.removed)) {
            var u5;
            if (!c4) {
                var d4 = a4[e6 - 1];
                c4 = h4, p4 = m4, d4 && (f4 = i5.context > 0 ? s4(d4.lines.slice(-i5.context)) : [], c4 -= f4.length, p4 -= f4.length);
            }
            (u5 = f4).push.apply(u5, g3(o5.map(function(e7) {
                return (t4.added ? "+" : "-") + e7;
            }))), t4.added ? m4 += o5.length : h4 += o5.length;
        } else {
            if (c4) {
                if (o5.length <= 2 * i5.context && e6 < a4.length - 2) {
                    var D5;
                    (D4 = f4).push.apply(D4, g3(s4(o5)));
                } else {
                    var y4, E4 = Math.min(o5.length, i5.context);
                    (y4 = f4).push.apply(y4, g3(s4(o5.slice(0, E4))));
                    var C3 = {
                        oldStart: c4,
                        oldLines: h4 - c4 + E4,
                        newStart: p4,
                        newLines: m4 - p4 + E4,
                        lines: f4
                    };
                    if (e6 >= a4.length - 2 && o5.length <= i5.context) {
                        var b3 = /\n$/.test(n4), v3 = /\n$/.test(r4), A3 = 0 == o5.length && f4.length > C3.oldLines;
                        !b3 && A3 && n4.length > 0 && f4.splice(C3.oldLines, 0, "\\ No newline at end of file"), (b3 || A3) && v3 || f4.push("\\ No newline at end of file");
                    }
                    l4.push(C3), c4 = 0, p4 = 0, f4 = [];
                }
            }
            h4 += o5.length, m4 += o5.length;
        }
    }, y4 = 0; y4 < a4.length; y4++)D4(y4);
    return {
        oldFileName: e5,
        newFileName: t3,
        oldHeader: o4,
        newHeader: u4,
        hunks: l4
    };
}
function S2(e5, t3, n4, r4, o4, u4, i5) {
    return (function(e6) {
        var t4 = [];
        e6.oldFileName == e6.newFileName && t4.push("Index: " + e6.oldFileName), t4.push("==================================================================="), t4.push("--- " + e6.oldFileName + ((void 0) === e6.oldHeader ? "" : "\t" + e6.oldHeader)), t4.push("+++ " + e6.newFileName + ((void 0) === e6.newHeader ? "" : "\t" + e6.newHeader));
        for(var n5 = 0; n5 < e6.hunks.length; n5++){
            var r5 = e6.hunks[n5];
            0 === r5.oldLines && (r5.oldStart -= 1), 0 === r5.newLines && (r5.newStart -= 1), t4.push("@@ -" + r5.oldStart + "," + r5.oldLines + " +" + r5.newStart + "," + r5.newLines + " @@"), t4.push.apply(t4, r5.lines);
        }
        return t4.join("\n") + "\n";
    })(x1(e5, t3, n4, r4, o4, u4, i5));
}
function T3(e5) {
    var t3 = W(e5.lines), n4 = t3.oldLines, r4 = t3.newLines;
    (void 0) !== n4 ? e5.oldLines = n4 : delete e5.oldLines, (void 0) !== r4 ? e5.newLines = r4 : delete e5.newLines;
}
function B2(e5, t3) {
    if ("string" == typeof e5) {
        if (/^@@/m.test(e5) || /^Index:/m.test(e5)) return v(e5)[0];
        if (!t3) throw new Error("Must provide a base reference or pass in a patch");
        return x1(void 0, void 0, t3, e5);
    }
    return e5;
}
function L(e5, t3, n4) {
    var r4 = V(t3), o4 = V(n4);
    if ($(r4) && $(o4)) {
        var u4, i5;
        if (w(r4, o4) && q(n4, r4, r4.length - o4.length)) return void (u4 = e5.lines).push.apply(u4, g3(r4));
        if (w(o4, r4) && q(t3, o4, o4.length - r4.length)) return void (i5 = e5.lines).push.apply(i5, g3(o4));
    } else if ((function(e6, t4) {
        return e6.length === t4.length && w(e6, t4);
    })(r4, o4)) {
        var a4;
        return void (a4 = e5.lines).push.apply(a4, g3(r4));
    }
    j2(e5, r4, o4);
}
function M3(e5, t3, n4, r4) {
    var o4, u4 = V(t3), i5 = function(e6, t4) {
        var n5 = [], r5 = [], o5 = 0, u5 = !1, i5 = !1;
        for(; o5 < t4.length && e6.index < e6.lines.length;){
            var a4 = e6.lines[e6.index], s4 = t4[o5];
            if ("+" === s4[0]) break;
            if (u5 = u5 || " " !== a4[0], r5.push(s4), o5++, "+" === a4[0]) for(i5 = !0; "+" === a4[0];)n5.push(a4), a4 = e6.lines[++e6.index];
            s4.substr(1) === a4.substr(1) ? (n5.push(a4), e6.index++) : i5 = !0;
        }
        "+" === (t4[o5] || "")[0] && u5 && (i5 = !0);
        if (i5) return n5;
        for(; o5 < t4.length;)r5.push(t4[o5++]);
        return {
            merged: r5,
            changes: n5
        };
    }(n4, u4);
    i5.merged ? (o4 = e5.lines).push.apply(o4, g3(i5.merged)) : j2(e5, r4 ? i5 : u4, r4 ? u4 : i5);
}
function _t1(e5, t3) {
    return Vt(e5, {
        type: "indent"
    }, t3);
}
function Rt1(e5, t3, n4) {
    if (t3 === -1 / 0) return e5.root || {
        value: "",
        length: 0,
        queue: []
    };
    if (t3 < 0) return Vt(e5, {
        type: "dedent"
    }, n4);
    if (!t3) return e5;
    if ("root" === t3.type) return Object.assign({
    }, e5, {
        root: e5
    });
    return Vt(e5, {
        type: "string" == typeof t3 ? "stringAlign" : "numberAlign",
        n: t3
    }, n4);
}
function Vn(e5, t3, n4, r4) {
    return sr(ir(t3, e5.length - n4), e5, n4, r4);
}
function $n(e5, t3, n4, r4) {
    return sr(function(e6) {
        for(var t4 = [], n5 = 0; n5 < e6.length; ++n5)t4.push(255 & e6.charCodeAt(n5));
        return t4;
    }(t3), e5, n4, r4);
}
function qn(e5, t3, n4, r4) {
    return $n(e5, t3, n4, r4);
}
function Un(e5, t3, n4, r4) {
    return sr(function(e6, t4) {
        for(var n5, r5, o4, u4 = [], i5 = 0; i5 < e6.length && !((t4 -= 2) < 0); ++i5)r5 = (n5 = e6.charCodeAt(i5)) >> 8, o4 = n5 % 256, u4.push(o4), u4.push(r5);
        return u4;
    }(t3, e5.length - n4), e5, n4, r4);
}
function Xn(e5, t3, n4) {
    var r4 = e5.length;
    (!t3 || t3 < 0) && (t3 = 0), (!n4 || n4 < 0 || n4 > r4) && (n4 = r4);
    for(var o4 = "", u4 = t3; u4 < n4; ++u4)o4 += ur(e5[u4]);
    return o4;
}
function Ea(e5, t3) {
    const n4 = Ca(e5.stack, t3);
    return -1 === n4 ? null : e5.stack[n4];
}
var ba = class {
    constructor(e5){
        this.stack = [
            e5
        ];
    }
    getName() {
        const { stack: e6  } = this, { length: t3  } = e6;
        return t3 > 1 ? e6[t3 - 2] : null;
    }
    getValue() {
        return se(this.stack);
    }
    getNode(e = 0) {
        return Ea(this, e);
    }
    getParentNode(e = 0) {
        return Ea(this, e + 1);
    }
    call(e, ...t) {
        const { stack: n4  } = this, { length: r4  } = n4;
        let o4 = se(n4);
        for (const e6 of t)o4 = o4[e6], n4.push(e6, o4);
        const u4 = e(this);
        return n4.length = r4, u4;
    }
    callParent(e, t = 0) {
        const n4 = Ca(this.stack, t + 1), r4 = this.stack.splice(n4 + 1), o4 = e(this);
        return this.stack.push(...r4), o4;
    }
    each(e, ...t) {
        const { stack: n4  } = this, { length: r4  } = n4;
        let o4 = se(n4);
        for (const e6 of t)o4 = o4[e6], n4.push(e6, o4);
        for(let t3 = 0; t3 < o4.length; ++t3)n4.push(t3, o4[t3]), e(this, t3), n4.length -= 2;
        n4.length = r4;
    }
    map(e, ...t) {
        const n4 = [];
        return this.each((t3, r4)=>{
            n4[r4] = e(t3, r4);
        }, ...t), n4;
    }
    match(...e) {
        let t3 = this.stack.length - 1, n4 = null, r4 = this.stack[t3--];
        for (const o4 of e){
            if ((void 0) === r4) return !1;
            let e6 = null;
            if ("number" == typeof n4 && (e6 = n4, n4 = this.stack[t3--], r4 = this.stack[t3--]), o4 && !o4(r4, n4, e6)) return !1;
            n4 = this.stack[t3--], r4 = this.stack[t3--];
        }
        return !0;
    }
};
function ol(e6) {
    return Us(e6) && (rl.test(sl(e6)) || !/\n/.test(sl(e6)));
}
function Xv(e6) {
    return Yv(e6, [
        "TextNode"
    ]) && !/\S/.test(e6.chars);
}
var tA = {
    getNextNode: Zv,
    getPreviousNode: Qv,
    hasPrettierIgnore: function(e6) {
        const t3 = e6.getValue(), n4 = Qv(e6, 2);
        return eA(t3) || eA(n4);
    },
    isNextNodeOfSomeType: function(e6, t3) {
        return Yv(Zv(e6), t3);
    },
    isNodeOfSomeType: Yv,
    isParentOfSomeType: function(e6, t3) {
        return Yv(e6.getParentNode(0), t3);
    },
    isPreviousNodeOfSomeType: function(e6, t3) {
        return Yv(Qv(e6), t3);
    },
    isVoid: function(e6) {
        return function(e7) {
            return Yv(e7, [
                "ElementNode"
            ]) && "string" == typeof e7.tag && ((function(e8) {
                return e8.toUpperCase() === e8;
            })(e7.tag[0]) || e7.tag.includes("."));
        }(e6) && e6.children.every((e7)=>Xv(e7)
        ) || Hv.has(e6.tag);
    },
    isWhitespaceNode: Xv
};
function mS(e6) {
    return "element" === e6.type && ("script" === e6.fullName || "style" === e6.fullName || "svg:style" === e6.fullName || SS(e6) && ("script" === e6.name || "style" === e6.name));
}
function ES(e6) {
    return CS(e6) && bS(e6);
}
function BS(e6, t3) {
    return NS(e6, t3) && !TS.has(e6.fullName);
}
function kS(e6, t3) {
    return NS(e6, t3) && (BS(e6, t3) || e6.attrMap.lang && "html" !== e6.attrMap.lang);
}
function aT(e6) {
    return e6.firstChild && dT(e6.firstChild) ? "" : CT(e6);
}
function Be3(t3) {
    return De1(t3) && (we1.test(ve1(t3)) || !/\n/.test(ve1(t3)));
}
function Je(e6, t3) {
    return Ke(e6, {
        type: "indent"
    }, t3);
}
function Ze(e6, t3, n4) {
    if (t3 === -1 / 0) return e6.root || {
        value: "",
        length: 0,
        queue: []
    };
    if (t3 < 0) return Ke(e6, {
        type: "dedent"
    }, n4);
    if (!t3) return e6;
    if ("root" === t3.type) return Object.assign({
    }, e6, {
        root: e6
    });
    return Ke(e6, {
        type: "string" == typeof t3 ? "stringAlign" : "numberAlign",
        n: t3
    }, n4);
}
function It(e6) {
    return "element" === e6.type && ("script" === e6.fullName || "style" === e6.fullName || "svg:style" === e6.fullName || Wt(e6) && ("script" === e6.name || "style" === e6.name));
}
function Ut1(e6) {
    return Gt2(e6) && Vt1(e6);
}
function Jt2(e6, t3) {
    return Zt1(e6, t3) && !Yt2.has(e6.fullName);
}
function Kt2(e6, t3) {
    return Zt1(e6, t3) && (Jt2(e6, t3) || e6.attrMap.lang && "html" !== e6.attrMap.lang);
}
class rn {
    constructor(e6 = {
    }){
        for (const t3 of Object.keys(e6)){
            const n4 = e6[t3];
            t3 in nn1 ? this._setNodes(t3, n4) : this[t3] = n4;
        }
    }
    _setNodes(e, t) {
        t !== this[e] && (this[e] = (function(e7, t4) {
            const n4 = e7.map((e8)=>e8 instanceof rn ? e8.clone() : new rn(e8)
            );
            let r4 = null, s4 = n4[0], i5 = n4[1] || null;
            for(let e8 = 0; e8 < n4.length; e8++)on1(s4, {
                index: e8,
                siblings: n4,
                prev: r4,
                next: i5,
                parent: t4
            }), r4 = s4, s4 = i5, i5 = n4[e8 + 2] || null;
            return n4;
        })(t, this), "attrs" === e && on1(this, {
            attrMap: this[e].reduce((e7, t4)=>(e7[t4.fullName] = t4.value, e7)
            , Object.create(null))
        }));
    }
    map(e) {
        let t4 = null;
        for(const n4 in nn1){
            const r4 = this[n4];
            if (r4) {
                const s4 = sn1(r4, (t6)=>t6.map(e)
                );
                t4 !== r4 && (t4 || (t4 = new rn), t4._setNodes(n4, s4));
            }
        }
        if (t4) {
            for(const e7 in this)e7 in nn1 || (t4[e7] = this[e7]);
            const { index: e8 , siblings: n5 , prev: r4 , next: s4 , parent: i5  } = this;
            on1(t4, {
                index: e8,
                siblings: n5,
                prev: r4,
                next: s4,
                parent: i5
            });
        }
        return e(t4 || this);
    }
    clone(e) {
        return new rn(e ? Object.assign({
        }, this, e) : this);
    }
    get firstChild() {
        return this.children && 0 !== this.children.length ? this.children[0] : null;
    }
    get lastChild() {
        return this.children && 0 !== this.children.length ? this.children[this.children.length - 1] : null;
    }
    get rawName() {
        return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
        return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
}
var an1 = {
    Node: rn
};
function saveHtml(html) {
    return saveToIPFS(html, "text/html");
}
function requestResponseMessage(ep1, msg, transfers) {
    return new Promise((resolve)=>{
        const id = generateUUID();
        ep1.addEventListener("message", function l4(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep1.removeEventListener("message", l4);
            resolve(ev.data);
        });
        if (ep1.start) {
            ep1.start();
        }
        ep1.postMessage(Object.assign({
            id
        }, msg), transfers);
    });
}
function I3(e7, t4, n4, r4, o4) {
    var u4 = {
        offset: t4,
        lines: n4,
        index: 0
    }, i5 = {
        offset: r4,
        lines: o4,
        index: 0
    };
    for(_(e7, u4, i5), _(e7, i5, u4); u4.index < u4.lines.length && i5.index < i5.lines.length;){
        var a4 = u4.lines[u4.index], s4 = i5.lines[i5.index];
        if ("-" !== a4[0] && "+" !== a4[0] || "-" !== s4[0] && "+" !== s4[0]) {
            if ("+" === a4[0] && " " === s4[0]) {
                var l4;
                (l4 = e7.lines).push.apply(l4, g3(V(u4)));
            } else if ("+" === s4[0] && " " === a4[0]) {
                var c4;
                (c4 = e7.lines).push.apply(c4, g3(V(i5)));
            } else "-" === a4[0] && " " === s4[0] ? M3(e7, u4, i5) : "-" === s4[0] && " " === a4[0] ? M3(e7, i5, u4, !0) : a4 === s4 ? (e7.lines.push(a4), u4.index++, i5.index++) : j2(e7, V(u4), V(i5));
        } else L(e7, u4, i5);
    }
    R(e7, u4), R(e7, i5), T3(e7);
}
var J = Object.freeze({
    __proto__: null,
    Diff: r1,
    applyPatch: F,
    applyPatches: function(e7, t4) {
        "string" == typeof e7 && (e7 = v(e7));
        var n4 = 0;
        !(function r4() {
            var o4 = e7[n4++];
            if (!o4) return t4.complete();
            t4.loadFile(o4, function(e8, n5) {
                if (e8) return t4.complete(e8);
                var u4 = F(n5, o4, t4);
                t4.patched(o4, u4, function(e9) {
                    if (e9) return t4.complete(e9);
                    r4();
                });
            });
        })();
    },
    canonicalize: C1,
    convertChangesToDMP: function(e7) {
        for(var t4, n4, r4 = [], o4 = 0; o4 < e7.length; o4++)n4 = (t4 = e7[o4]).added ? 1 : t4.removed ? -1 : 0, r4.push([
            n4,
            t4.value
        ]);
        return r4;
    },
    convertChangesToXML: function(e7) {
        for(var t4 = [], n4 = 0; n4 < e7.length; n4++){
            var r4 = e7[n4];
            r4.added ? t4.push("<ins>") : r4.removed && t4.push("<del>"), t4.push(U(r4.value)), r4.added ? t4.push("</ins>") : r4.removed && t4.push("</del>");
        }
        return t4.join("");
    },
    createPatch: function(e7, t4, n4, r4, o4, u4) {
        return S2(e7, e7, t4, n4, r4, o4, u4);
    },
    createTwoFilesPatch: S2,
    diffArrays: function(e7, t4, n4) {
        return b.diff(e7, t4, n4);
    },
    diffChars: function(e7, t4, n4) {
        return i1.diff(e7, t4, n4);
    },
    diffCss: function(e7, t4, n4) {
        return h3.diff(e7, t4, n4);
    },
    diffJson: function(e7, t4, n4) {
        return E2.diff(e7, t4, n4);
    },
    diffLines: d1,
    diffSentences: function(e7, t4, n4) {
        return f2.diff(e7, t4, n4);
    },
    diffTrimmedLines: function(e7, t4, n4) {
        var r4 = a1(n4, {
            ignoreWhitespace: !0
        });
        return p1.diff(e7, t4, r4);
    },
    diffWords: function(e7, t4, n4) {
        return (n4 = a1(n4, {
            ignoreWhitespace: !0
        }), c1.diff(e7, t4, n4));
    },
    diffWordsWithSpace: function(e7, t4, n4) {
        return c1.diff(e7, t4, n4);
    },
    merge: function(e7, t4, n4) {
        e7 = B2(e7, n4), t4 = B2(t4, n4);
        var r4 = {
        };
        (e7.index || t4.index) && (r4.index = e7.index || t4.index), (e7.newFileName || t4.newFileName) && (N(e7) ? N(t4) ? (r4.oldFileName = k3(r4, e7.oldFileName, t4.oldFileName), r4.newFileName = k3(r4, e7.newFileName, t4.newFileName), r4.oldHeader = k3(r4, e7.oldHeader, t4.oldHeader), r4.newHeader = k3(r4, e7.newHeader, t4.newHeader)) : (r4.oldFileName = e7.oldFileName, r4.newFileName = e7.newFileName, r4.oldHeader = e7.oldHeader, r4.newHeader = e7.newHeader) : (r4.oldFileName = t4.oldFileName || e7.oldFileName, r4.newFileName = t4.newFileName || e7.newFileName, r4.oldHeader = t4.oldHeader || e7.oldHeader, r4.newHeader = t4.newHeader || e7.newHeader)), r4.hunks = [];
        for(var o4 = 0, u4 = 0, i5 = 0, a4 = 0; o4 < e7.hunks.length || u4 < t4.hunks.length;){
            var s4 = e7.hunks[o4] || {
                oldStart: 1 / 0
            }, l4 = t4.hunks[u4] || {
                oldStart: 1 / 0
            };
            if (P2(s4, l4)) r4.hunks.push(O(s4, i5)), o4++, a4 += s4.newLines - s4.oldLines;
            else if (P2(l4, s4)) r4.hunks.push(O(l4, a4)), u4++, i5 += l4.newLines - l4.oldLines;
            else {
                var c4 = {
                    oldStart: Math.min(s4.oldStart, l4.oldStart),
                    oldLines: 0,
                    newStart: Math.min(s4.newStart + i5, l4.oldStart + a4),
                    newLines: 0,
                    lines: []
                };
                I3(c4, s4.oldStart, s4.lines, l4.oldStart, l4.lines), u4++, o4++, r4.hunks.push(c4);
            }
        }
        return r4;
    },
    parsePatch: v,
    structuredPatch: x1
});
function yS(e7) {
    return vS(e7) || "element" === e7.type && "br" === e7.fullName || ES(e7);
}
function Mt(e7) {
    return jt1(e7) || "element" === e7.type && "br" === e7.fullName || Ut1(e7);
}
async function getIpfsiD() {
    if (node) return node;
    let ipfsId = await shaDB1.get("ipfs");
    if (!ipfsId) {
        ipfsId = v4();
        await shaDB1.put("ipfs", ipfsId);
    }
    return ipfsId;
}
function init() {
    const worker = new Worker("./src/transpile.worker.js");
    transform = wrap1(worker);
    return transform;
}
init();
function Ee3() {
    De2 && me && (De2 = !1, me.length ? ge3 = me.concat(ge3) : ye2 = -1, ge3.length && Ce2());
}
function Ce2() {
    if (!De2) {
        var e7 = he3(Ee3);
        De2 = !0;
        for(var t4 = ge3.length; t4;){
            for(me = ge3, ge3 = []; (++ye2) < t4;)me && me[ye2].run();
            ye2 = -1, t4 = ge3.length;
        }
        me = null, De2 = !1, (function(e8) {
            if (fe === clearTimeout) return clearTimeout(e8);
            if ((fe === pe2 || !fe) && clearTimeout) return fe = clearTimeout, clearTimeout(e8);
            try {
                fe(e8);
            } catch (t) {
                try {
                    return fe.call(null, e8);
                } catch (t) {
                    return fe.call(this, e8);
                }
            }
        })(e7);
    }
}
var Oe2 = {
    nextTick: function(e7) {
        var t4 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n4 = 1; n4 < arguments.length; n4++)t4[n4 - 1] = arguments[n4];
        ge3.push(new be2(e7, t4)), 1 !== ge3.length || De2 || he3(Ce2);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: Ae,
    addListener: Fe,
    once: xe,
    off: Se,
    removeListener: we3,
    removeAllListeners: Te,
    emit: Be,
    binding: function(e7) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(e7) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(e7) {
        var t4 = 0.001 * ke.call(Ne), n4 = Math.floor(t4), r4 = Math.floor(t4 % 1 * 1000000000);
        return (e7 && (n4 -= e7[0], (r4 -= e7[1]) < 0 && (n4--, r4 += 1000000000)), [
            n4,
            r4
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - Pe3) / 1000;
    }
};
var Ie3 = "object" == typeof Oe2 && Oe2.env && Oe2.env.NODE_DEBUG && /\bsemver\b/i.test(Oe2.env.NODE_DEBUG) ? (...e7)=>console.error("SEMVER", ...e7)
 : ()=>{
};
var Re3 = je(function(e7, t4) {
    const { MAX_SAFE_COMPONENT_LENGTH: n4  } = Le3, r4 = (t4 = e7.exports = {
    }).re = [], o4 = t4.src = [], u4 = t4.t = {
    };
    let i5 = 0;
    const a4 = (e8, t6, n5)=>{
        const a5 = i5++;
        Ie3(a5, t6), u4[e8] = a5, o4[a5] = t6, r4[a5] = new RegExp(t6, n5 ? "g" : void 0);
    };
    a4("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a4("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a4("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a4("MAINVERSION", "(".concat(o4[u4.NUMERICIDENTIFIER], ")\\.") + "(".concat(o4[u4.NUMERICIDENTIFIER], ")\\.") + "(".concat(o4[u4.NUMERICIDENTIFIER], ")")), a4("MAINVERSIONLOOSE", "(".concat(o4[u4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o4[u4.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o4[u4.NUMERICIDENTIFIERLOOSE], ")")), a4("PRERELEASEIDENTIFIER", "(?:".concat(o4[u4.NUMERICIDENTIFIER], "|").concat(o4[u4.NONNUMERICIDENTIFIER], ")")), a4("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(o4[u4.NUMERICIDENTIFIERLOOSE], "|").concat(o4[u4.NONNUMERICIDENTIFIER], ")")), a4("PRERELEASE", "(?:-(".concat(o4[u4.PRERELEASEIDENTIFIER], "(?:\\.").concat(o4[u4.PRERELEASEIDENTIFIER], ")*))")), a4("PRERELEASELOOSE", "(?:-?(".concat(o4[u4.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(o4[u4.PRERELEASEIDENTIFIERLOOSE], ")*))")), a4("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a4("BUILD", "(?:\\+(".concat(o4[u4.BUILDIDENTIFIER], "(?:\\.").concat(o4[u4.BUILDIDENTIFIER], ")*))")), a4("FULLPLAIN", "v?".concat(o4[u4.MAINVERSION]).concat(o4[u4.PRERELEASE], "?").concat(o4[u4.BUILD], "?")), a4("FULL", "^".concat(o4[u4.FULLPLAIN], "$")), a4("LOOSEPLAIN", "[v=\\s]*".concat(o4[u4.MAINVERSIONLOOSE]).concat(o4[u4.PRERELEASELOOSE], "?").concat(o4[u4.BUILD], "?")), a4("LOOSE", "^".concat(o4[u4.LOOSEPLAIN], "$")), a4("GTLT", "((?:<|>)?=?)"), a4("XRANGEIDENTIFIERLOOSE", "".concat(o4[u4.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a4("XRANGEIDENTIFIER", "".concat(o4[u4.NUMERICIDENTIFIER], "|x|X|\\*")), a4("XRANGEPLAIN", "[v=\\s]*(".concat(o4[u4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o4[u4.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o4[u4.XRANGEIDENTIFIER], ")") + "(?:".concat(o4[u4.PRERELEASE], ")?").concat(o4[u4.BUILD], "?") + ")?)?"), a4("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(o4[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o4[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o4[u4.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(o4[u4.PRERELEASELOOSE], ")?").concat(o4[u4.BUILD], "?") + ")?)?"), a4("XRANGE", "^".concat(o4[u4.GTLT], "\\s*").concat(o4[u4.XRANGEPLAIN], "$")), a4("XRANGELOOSE", "^".concat(o4[u4.GTLT], "\\s*").concat(o4[u4.XRANGEPLAINLOOSE], "$")), a4("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n4, "})") + "(?:\\.(\\d{1,".concat(n4, "}))?") + "(?:\\.(\\d{1,".concat(n4, "}))?") + "(?:$|[^\\d])"), a4("COERCERTL", o4[u4.COERCE], !0), a4("LONETILDE", "(?:~>?)"), a4("TILDETRIM", "(\\s*)".concat(o4[u4.LONETILDE], "\\s+"), !0), t4.tildeTrimReplace = "$1~", a4("TILDE", "^".concat(o4[u4.LONETILDE]).concat(o4[u4.XRANGEPLAIN], "$")), a4("TILDELOOSE", "^".concat(o4[u4.LONETILDE]).concat(o4[u4.XRANGEPLAINLOOSE], "$")), a4("LONECARET", "(?:\\^)"), a4("CARETTRIM", "(\\s*)".concat(o4[u4.LONECARET], "\\s+"), !0), t4.caretTrimReplace = "$1^", a4("CARET", "^".concat(o4[u4.LONECARET]).concat(o4[u4.XRANGEPLAIN], "$")), a4("CARETLOOSE", "^".concat(o4[u4.LONECARET]).concat(o4[u4.XRANGEPLAINLOOSE], "$")), a4("COMPARATORLOOSE", "^".concat(o4[u4.GTLT], "\\s*(").concat(o4[u4.LOOSEPLAIN], ")$|^$")), a4("COMPARATOR", "^".concat(o4[u4.GTLT], "\\s*(").concat(o4[u4.FULLPLAIN], ")$|^$")), a4("COMPARATORTRIM", "(\\s*)".concat(o4[u4.GTLT], "\\s*(").concat(o4[u4.LOOSEPLAIN], "|").concat(o4[u4.XRANGEPLAIN], ")"), !0), t4.comparatorTrimReplace = "$1$2$3", a4("HYPHENRANGE", "^\\s*(".concat(o4[u4.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(o4[u4.XRANGEPLAIN], ")") + "\\s*$"), a4("HYPHENRANGELOOSE", "^\\s*(".concat(o4[u4.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(o4[u4.XRANGEPLAINLOOSE], ")") + "\\s*$"), a4("STAR", "(<|>)?=?\\s*\\*"), a4("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a4("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: We , MAX_SAFE_INTEGER: Ue2  } = Le3, { re: Je1 , t: ze1  } = Re3, { compareIdentifiers: Ge1  } = qe;
class He {
    constructor(e7, t4){
        if (t4 && "object" == typeof t4 || (t4 = {
            loose: !!t4,
            includePrerelease: !1
        }), e7 instanceof He) {
            if (e7.loose === !!t4.loose && e7.includePrerelease === !!t4.includePrerelease) return e7;
            e7 = e7.version;
        } else if ("string" != typeof e7) throw new TypeError("Invalid Version: ".concat(e7));
        if (e7.length > We) throw new TypeError("version is longer than ".concat(We, " characters"));
        Ie3("SemVer", e7, t4), this.options = t4, this.loose = !!t4.loose, this.includePrerelease = !!t4.includePrerelease;
        const n4 = e7.trim().match(t4.loose ? Je1[ze1.LOOSE] : Je1[ze1.FULL]);
        if (!n4) throw new TypeError("Invalid Version: ".concat(e7));
        if (this.raw = e7, this.major = +n4[1], this.minor = +n4[2], this.patch = +n4[3], this.major > Ue2 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > Ue2 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > Ue2 || this.patch < 0) throw new TypeError("Invalid patch version");
        n4[4] ? this.prerelease = n4[4].split(".").map((e8)=>{
            if (/^[0-9]+$/.test(e8)) {
                const t6 = +e8;
                if (t6 >= 0 && t6 < Ue2) return t6;
            }
            return e8;
        }) : this.prerelease = [], this.build = n4[5] ? n4[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(e) {
        if (Ie3("SemVer.compare", this.version, this.options, e), !(e instanceof He)) {
            if ("string" == typeof e && e === this.version) return 0;
            e = new He(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
        return e instanceof He || (e = new He(e, this.options)), Ge1(this.major, e.major) || Ge1(this.minor, e.minor) || Ge1(this.patch, e.patch);
    }
    comparePre(e) {
        if (e instanceof He || (e = new He(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t6 = 0;
        do {
            const n5 = this.prerelease[t6], r4 = e.prerelease[t6];
            if (Ie3("prerelease compare", t6, n5, r4), (void 0) === n5 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === n5) return -1;
            if (n5 !== r4) return Ge1(n5, r4);
        }while (++t6)
    }
    compareBuild(e) {
        e instanceof He || (e = new He(e, this.options));
        let t6 = 0;
        do {
            const n5 = this.build[t6], r4 = e.build[t6];
            if (Ie3("prerelease compare", t6, n5, r4), (void 0) === n5 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === n5) return -1;
            if (n5 !== r4) return Ge1(n5, r4);
        }while (++t6)
    }
    inc(e, t) {
        switch(e){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let e8 = this.prerelease.length;
                    for(; (--e8) >= 0;)"number" == typeof this.prerelease[e8] && (this.prerelease[e8]++, e8 = -2);
                    -1 === e8 && this.prerelease.push(0);
                }
                t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    t,
                    0
                ]) : this.prerelease = [
                    t,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(e));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var Xe = He;
var Ye1 = (e8, t6, n5)=>new Xe(e8, n5).compare(new Xe(t6, n5))
;
var Ke1 = (e8, t6, n5)=>Ye1(e8, t6, n5) < 0
;
var Qe = (e8, t6, n5)=>Ye1(e8, t6, n5) >= 0
, Ze1 = je(function(e8, t6) {
    function n5() {
        for(var e9 = [], t7 = 0; t7 < arguments.length; t7++)e9[t7] = arguments[t7];
    }
    function r4() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: n5,
            delete: n5,
            get: n5,
            set: n5,
            has: function(e9) {
                return !1;
            }
        };
    }
    Object.defineProperty(t6, "__esModule", {
        value: !0
    });
    var o4 = Object.prototype.hasOwnProperty, u4 = function(e9, t7) {
        return o4.call(e9, t7);
    };
    function i5(e9, t7) {
        for(var n6 in t7)u4(t7, n6) && (e9[n6] = t7[n6]);
        return e9;
    }
    var a4 = /^[ \t]*(?:\r\n|\r|\n)/, s4 = /(?:\r\n|\r|\n)[ \t]*$/, l4 = /^(?:[\r\n]|$)/, c4 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p4 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function d4(e9, t7, n6) {
        var r5 = 0, o5 = e9[0].match(c4);
        o5 && (r5 = o5[1].length);
        var u5 = new RegExp("(\\r\\n|\\r|\\n).{0," + r5 + "}", "g");
        t7 && (e9 = e9.slice(1));
        var i6 = n6.newline, l5 = n6.trimLeadingNewline, p5 = n6.trimTrailingNewline, d4 = "string" == typeof i6, f4 = e9.length;
        return e9.map(function(e10, t8) {
            return (e10 = e10.replace(u5, "$1"), 0 === t8 && l5 && (e10 = e10.replace(a4, "")), t8 === f4 - 1 && p5 && (e10 = e10.replace(s4, "")), d4 && (e10 = e10.replace(/\r\n|\n|\r/g, function(e11) {
                return i6;
            })), e10);
        });
    }
    function f4(e9, t7) {
        for(var n6 = "", r5 = 0, o5 = e9.length; r5 < o5; r5++)n6 += e9[r5], r5 < o5 - 1 && (n6 += t7[r5]);
        return n6;
    }
    function h4(e9) {
        return u4(e9, "raw") && u4(e9, "length");
    }
    var m4 = function e8(t7) {
        var n6 = r4(), o5 = r4();
        return i5(function r5(u5) {
            for(var a5 = [], s5 = 1; s5 < arguments.length; s5++)a5[s5 - 1] = arguments[s5];
            if (h4(u5)) {
                var c5 = u5, g4 = (a5[0] === r5 || a5[0] === m4) && p4.test(c5[0]) && l4.test(c5[1]), D4 = g4 ? o5 : n6, y4 = D4.get(c5);
                if ((y4 || (y4 = d4(c5, g4, t7), D4.set(c5, y4)), 0 === a5.length)) return y4[0];
                var E4 = f4(y4, g4 ? a5.slice(1) : a5);
                return E4;
            }
            return e8(i5(i5({
            }, t7), u5 || {
            }));
        }, {
            string: function(e9) {
                return d4([
                    e9
                ], !1, t7)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    t6.outdent = m4, t6.default = m4;
    try {
        e8.exports = m4, Object.defineProperty(m4, "__esModule", {
            value: !0
        }), m4.default = m4, m4.outdent = m4;
    } catch (e) {
    }
});
const { outdent: it2  } = Ze1, at2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: it2(ut()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: it2(ot())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (e8)=>"string" == typeof e8 || "function" == typeof e8
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (e8)=>"string" == typeof e8 || "object" == typeof e8
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: it2(rt()),
        exception: (e8)=>"string" == typeof e8 || "object" == typeof e8
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: it2(nt()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: it2(tt()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: it2(et()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const st2 = {
    compare: Ye1,
    lt: Ke1,
    gte: Qe
}, lt1 = n2.version, ct1 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: at2
}.options;
var pt1 = {
    getSupportInfo: function({ plugins: t6 = [] , showUnreleased: n5 = !1 , showDeprecated: r4 = !1 , showInternal: o4 = !1  } = {
    }) {
        const u4 = lt1.split("-", 1)[0], i5 = t6.reduce((e8, t7)=>e8.concat(t7.languages || [])
        , []).filter(s4), a4 = ((e8, t7)=>Object.entries(e8).map(([e9, n6])=>Object.assign({
                    [t7]: e9
                }, n6)
            )
        )(Object.assign({
        }, ...t6.map(({ options: e8  })=>e8
        ), ct1), "name").filter((e8)=>s4(e8) && l4(e8)
        ).sort((e8, t7)=>e8.name === t7.name ? 0 : e8.name < t7.name ? -1 : 1
        ).map(function(t7) {
            if (o4) return t7;
            return e2(t7, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((e8)=>{
            e8 = Object.assign({
            }, e8), Array.isArray(e8.default) && (e8.default = 1 === e8.default.length ? e8.default[0].value : e8.default.filter(s4).sort((e9, t7)=>st2.compare(t7.since, e9.since)
            )[0].value), Array.isArray(e8.choices) && (e8.choices = e8.choices.filter((e9)=>s4(e9) && l4(e9)
            ), "parser" === e8.name && (function(e9, t7, n6) {
                const r5 = new Set(e9.choices.map((e10)=>e10.value
                ));
                for (const o5 of t7)if (o5.parsers) for (const t8 of o5.parsers)if (!r5.has(t8)) {
                    r5.add(t8);
                    const u5 = n6.find((e10)=>e10.parsers && e10.parsers[t8]
                    );
                    let i6 = o5.name;
                    u5 && u5.name && (i6 += " (plugin: ".concat(u5.name, ")")), e9.choices.push({
                        value: t8,
                        description: i6
                    });
                }
            })(e8, i5, t6));
            const n6 = t6.filter((t7)=>t7.defaultOptions && (void 0) !== t7.defaultOptions[e8.name]
            ).reduce((t7, n7)=>(t7[n7.name] = n7.defaultOptions[e8.name], t7)
            , {
            });
            return Object.assign({
            }, e8, {
                pluginDefaults: n6
            });
        });
        return {
            languages: i5,
            options: a4
        };
        function s4(e8) {
            return n5 || !("since" in e8) || e8.since && st2.gte(u4, e8.since);
        }
        function l4(e8) {
            return r4 || !("deprecated" in e8) || e8.deprecated && st2.lt(u4, e8.deprecated);
        }
    }
};
const { getSupportInfo: dt1  } = pt1, ft2 = /[^\x20-\x7F]/;
var Nt1 = {
    inferParserByLanguage: function(e8, t6) {
        const { languages: n5  } = dt1({
            plugins: t6.plugins
        }), r4 = n5.find(({ name: t7  })=>t7.toLowerCase() === e8
        ) || n5.find(({ aliases: t7  })=>Array.isArray(t7) && t7.includes(e8)
        ) || n5.find(({ extensions: t7  })=>Array.isArray(t7) && t7.includes(".".concat(e8))
        );
        return r4 && r4.parsers[0];
    },
    replaceEndOfLineWith: function(e8, t6) {
        const n5 = [];
        for (const r4 of e8.split("\n"))0 !== n5.length && n5.push(t6), n5.push(r4);
        return n5;
    },
    getStringWidth: function(e8) {
        return e8 ? ft2.test(e8) ? ue(e8) : e8.length : 0;
    },
    getMaxContinuousCount: function(e8, t6) {
        const n5 = e8.match(new RegExp("(".concat(ae(t6), ")+"), "g"));
        return null === n5 ? 0 : n5.reduce((e9, n6)=>Math.max(e9, n6.length / t6.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(e8, t6) {
        const n5 = e8.match(new RegExp("(".concat(ae(t6), ")+"), "g"));
        if (null === n5) return 0;
        const r4 = new Map;
        let o4 = 0;
        for (const e9 of n5){
            const n6 = e9.length / t6.length;
            r4.set(n6, !0), n6 > o4 && (o4 = n6);
        }
        for(let e10 = 1; e10 < o4; e10++)if (!r4.get(e10)) return e10;
        return o4 + 1;
    },
    getPenultimate: (e8)=>e8[e8.length - 2]
    ,
    getLast: se,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ft,
    getNextNonSpaceNonCommentCharacterIndex: xt,
    getNextNonSpaceNonCommentCharacter: function(e8, t6, n5) {
        return e8.charAt(xt(e8, t6, n5));
    },
    skip: ht,
    skipWhitespace: mt,
    skipSpaces: gt,
    skipToLineEnd: Dt,
    skipEverythingButNewLine: yt,
    skipInlineComment: Et,
    skipTrailingComment: Ct,
    skipNewline: bt,
    isNextLineEmptyAfterIndex: At,
    isNextLineEmpty: function(e8, t6, n5) {
        return At(e8, n5(t6));
    },
    isPreviousLineEmpty: function(e8, t6, n5) {
        let r4 = n5(t6) - 1;
        return (r4 = gt(e8, r4, {
            backwards: !0
        }), r4 = bt(e8, r4, {
            backwards: !0
        }), r4 = gt(e8, r4, {
            backwards: !0
        }), r4 !== bt(e8, r4, {
            backwards: !0
        }));
    },
    hasNewline: vt,
    hasNewlineInRange: function(e8, t6, n5) {
        for(let r4 = t6; r4 < n5; ++r4)if ("\n" === e8.charAt(r4)) return !0;
        return !1;
    },
    hasSpaces: function(e8, t6, n5) {
        return gt(e8, (n5 = n5 || {
        }).backwards ? t6 - 1 : t6, n5) !== t6;
    },
    getAlignmentSize: St2,
    getIndentSize: function(e8, t6) {
        const n5 = e8.lastIndexOf("\n");
        return -1 === n5 ? 0 : St2(e8.slice(n5 + 1).match(/^[\t ]*/)[0], t6);
    },
    getPreferredQuote: wt,
    printString: function(e8, t6, n5) {
        const r4 = e8.slice(1, -1), o4 = !r4.includes('"') && !r4.includes("'"), u4 = "json" === t6.parser ? '"' : t6.__isInHtmlAttribute ? "'" : wt(e8, t6.singleQuote ? "'" : '"');
        return n5 ? o4 ? u4 + r4 + u4 : e8 : Tt(r4, u4, !("css" === t6.parser || "less" === t6.parser || "scss" === t6.parser || t6.embeddedInHtml));
    },
    printNumber: function(e8) {
        return e8.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(e8) {
        return "prettier-ignore" === e8.value.trim();
    },
    makeString: Tt,
    addLeadingComment: function(e8, t6) {
        t6.leading = !0, t6.trailing = !1, Bt(e8, t6);
    },
    addDanglingComment: function(e8, t6, n5) {
        t6.leading = !1, t6.trailing = !1, n5 && (t6.marker = n5), Bt(e8, t6);
    },
    addTrailingComment: function(e8, t6) {
        t6.leading = !1, t6.trailing = !0, Bt(e8, t6);
    },
    isFrontMatterNode: function(e8) {
        return e8 && "front-matter" === e8.type;
    },
    getShebang: function(e8) {
        if (!e8.startsWith("#!")) return "";
        const t6 = e8.indexOf("\n");
        return -1 === t6 ? e8 : e8.slice(0, t6);
    }
};
const { getStringWidth: Pt1  } = Nt1, { convertEndOfLineToChars: Ot  } = kt, { concat: It1 , fill: Lt2 , cursor: Mt1  } = Z2;
function qt2(e8, t6, n5, r4, o4) {
    let u4 = t6.length;
    const i5 = [
        e8
    ], a4 = [];
    for(; n5 >= 0;){
        if (0 === i5.length) {
            if (0 === u4) return !0;
            i5.push(t6[u4 - 1]), u4--;
            continue;
        }
        const [e9, s4, l4] = i5.pop();
        if ("string" == typeof l4) a4.push(l4), n5 -= Pt1(l4);
        else switch(l4.type){
            case "concat":
                for(let t7 = l4.parts.length - 1; t7 >= 0; t7--)i5.push([
                    e9,
                    s4,
                    l4.parts[t7]
                ]);
                break;
            case "indent":
                i5.push([
                    _t1(e9, r4),
                    s4,
                    l4.contents
                ]);
                break;
            case "align":
                i5.push([
                    Rt1(e9, l4.n, r4),
                    s4,
                    l4.contents
                ]);
                break;
            case "trim":
                n5 += $t(a4);
                break;
            case "group":
                if (o4 && l4.break) return !1;
                i5.push([
                    e9,
                    l4.break ? 1 : s4,
                    l4.contents
                ]), l4.id && (jt[l4.id] = i5[i5.length - 1][1]);
                break;
            case "fill":
                for(let t8 = l4.parts.length - 1; t8 >= 0; t8--)i5.push([
                    e9,
                    s4,
                    l4.parts[t8]
                ]);
                break;
            case "if-break":
                {
                    const t9 = l4.groupId ? jt[l4.groupId] : s4;
                    1 === t9 && l4.breakContents && i5.push([
                        e9,
                        s4,
                        l4.breakContents
                    ]), 2 === t9 && l4.flatContents && i5.push([
                        e9,
                        s4,
                        l4.flatContents
                    ]);
                    break;
                }
            case "line":
                switch(s4){
                    case 2:
                        if (!l4.hard) {
                            l4.soft || (a4.push(" "), n5 -= 1);
                            break;
                        }
                        return !0;
                    case 1:
                        return !0;
                }
        }
    }
    return !1;
}
var Wt1 = {
    printDocToString: function(e8, t6) {
        jt = {
        };
        const n5 = t6.printWidth, r4 = Ot(t6.endOfLine);
        let o4 = 0;
        const u4 = [
            [
                {
                    value: "",
                    length: 0,
                    queue: []
                },
                1,
                e8
            ]
        ], i5 = [];
        let a4 = !1, s4 = [];
        for(; 0 !== u4.length;){
            const [e9, l4, c4] = u4.pop();
            if ("string" == typeof c4) {
                const e10 = "\n" !== r4 && c4.includes("\n") ? c4.replace(/\n/g, r4) : c4;
                i5.push(e10), o4 += Pt1(e10);
            } else switch(c4.type){
                case "cursor":
                    i5.push(Mt1.placeholder);
                    break;
                case "concat":
                    for(let t7 = c4.parts.length - 1; t7 >= 0; t7--)u4.push([
                        e9,
                        l4,
                        c4.parts[t7]
                    ]);
                    break;
                case "indent":
                    u4.push([
                        _t1(e9, t6),
                        l4,
                        c4.contents
                    ]);
                    break;
                case "align":
                    u4.push([
                        Rt1(e9, c4.n, t6),
                        l4,
                        c4.contents
                    ]);
                    break;
                case "trim":
                    o4 -= $t(i5);
                    break;
                case "group":
                    switch(l4){
                        case 2:
                            if (!a4) {
                                u4.push([
                                    e9,
                                    c4.break ? 1 : 2,
                                    c4.contents
                                ]);
                                break;
                            }
                        case 1:
                            {
                                a4 = !1;
                                const r5 = [
                                    e9,
                                    2,
                                    c4.contents
                                ], i6 = n5 - o4;
                                if (!c4.break && qt2(r5, u4, i6, t6)) u4.push(r5);
                                else if (c4.expandedStates) {
                                    const n6 = c4.expandedStates[c4.expandedStates.length - 1];
                                    if (c4.break) {
                                        u4.push([
                                            e9,
                                            1,
                                            n6
                                        ]);
                                        break;
                                    }
                                    for(let r6 = 1; r6 < c4.expandedStates.length + 1; r6++){
                                        if (r6 >= c4.expandedStates.length) {
                                            u4.push([
                                                e9,
                                                1,
                                                n6
                                            ]);
                                            break;
                                        }
                                        {
                                            const n7 = [
                                                e9,
                                                2,
                                                c4.expandedStates[r6]
                                            ];
                                            if (qt2(n7, u4, i6, t6)) {
                                                u4.push(n7);
                                                break;
                                            }
                                        }
                                    }
                                } else u4.push([
                                    e9,
                                    1,
                                    c4.contents
                                ]);
                                break;
                            }
                    }
                    c4.id && (jt[c4.id] = u4[u4.length - 1][1]);
                    break;
                case "fill":
                    {
                        const r5 = n5 - o4, { parts: i6  } = c4;
                        if (0 === i6.length) break;
                        const [a5, s5] = i6, p4 = [
                            e9,
                            2,
                            a5
                        ], d4 = [
                            e9,
                            1,
                            a5
                        ], f4 = qt2(p4, [], r5, t6, !0);
                        if (1 === i6.length) {
                            f4 ? u4.push(p4) : u4.push(d4);
                            break;
                        }
                        const h4 = [
                            e9,
                            2,
                            s5
                        ], m4 = [
                            e9,
                            1,
                            s5
                        ];
                        if (2 === i6.length) {
                            f4 ? (u4.push(h4), u4.push(p4)) : (u4.push(m4), u4.push(d4));
                            break;
                        }
                        i6.splice(0, 2);
                        const g4 = [
                            e9,
                            l4,
                            Lt2(i6)
                        ], D4 = i6[0];
                        qt2([
                            e9,
                            2,
                            It1([
                                a5,
                                s5,
                                D4
                            ])
                        ], [], r5, t6, !0) ? (u4.push(g4), u4.push(h4), u4.push(p4)) : f4 ? (u4.push(g4), u4.push(m4), u4.push(p4)) : (u4.push(g4), u4.push(m4), u4.push(d4));
                        break;
                    }
                case "if-break":
                    {
                        const t8 = c4.groupId ? jt[c4.groupId] : l4;
                        1 === t8 && c4.breakContents && u4.push([
                            e9,
                            l4,
                            c4.breakContents
                        ]), 2 === t8 && c4.flatContents && u4.push([
                            e9,
                            l4,
                            c4.flatContents
                        ]);
                        break;
                    }
                case "line-suffix":
                    s4.push([
                        e9,
                        l4,
                        c4.contents
                    ]);
                    break;
                case "line-suffix-boundary":
                    s4.length > 0 && u4.push([
                        e9,
                        l4,
                        {
                            type: "line",
                            hard: !0
                        }
                    ]);
                    break;
                case "line":
                    switch(l4){
                        case 2:
                            if (!c4.hard) {
                                c4.soft || (i5.push(" "), o4 += 1);
                                break;
                            }
                            a4 = !0;
                        case 1:
                            if (s4.length) {
                                u4.push([
                                    e9,
                                    l4,
                                    c4
                                ]), u4.push(...s4.reverse()), s4 = [];
                                break;
                            }
                            c4.literal ? e9.root ? (i5.push(r4, e9.root.value), o4 = e9.root.length) : (i5.push(r4), o4 = 0) : (o4 -= $t(i5), i5.push(r4 + e9.value), o4 = e9.length);
                    }
            }
            0 === u4.length && s4.length && (u4.push(...s4.reverse()), s4 = []);
        }
        const l4 = i5.indexOf(Mt1.placeholder);
        if (-1 !== l4) {
            const e9 = i5.indexOf(Mt1.placeholder, l4 + 1), t7 = i5.slice(0, l4).join(""), n6 = i5.slice(l4 + 1, e9).join("");
            return {
                formatted: t7 + n6 + i5.slice(e9 + 1).join(""),
                cursorNodeStart: t7.length,
                cursorNodeText: n6
            };
        }
        return {
            formatted: i5.join("")
        };
    }
};
var rn1 = {
    builders: Z2,
    printer: Wt1,
    utils: {
        isEmpty: function(e8) {
            return "string" == typeof e8 && 0 === e8.length;
        },
        willBreak: function(e8) {
            return Xt(e8, Kt, !1);
        },
        isLineNext: function(e8) {
            return Xt(e8, Yt, !1);
        },
        traverseDoc: Gt,
        findInDoc: Xt,
        mapDoc: Ht,
        propagateBreaks: function(e8) {
            const t6 = new Set, n5 = [];
            Gt(e8, function(e9) {
                if (("break-parent" === e9.type && Qt2(n5), "group" === e9.type)) {
                    if ((n5.push(e9), t6.has(e9))) return !1;
                    t6.add(e9);
                }
            }, function(e9) {
                if ("group" === e9.type) {
                    n5.pop().break && Qt2(n5);
                }
            }, !0);
        },
        removeLines: function(e8) {
            return Ht(e8, Zt);
        },
        stripTrailingHardline: function e8(t6, n5 = !1) {
            if ("concat" === t6.type && 0 !== t6.parts.length) {
                const r4 = n5 ? function(e9) {
                    let t7, { parts: n6  } = e9;
                    for(let r5 = e9.parts.length; r5 > 0 && !t7; r5--)t7 = n6[r5 - 1];
                    return "group" === t7.type && (n6 = t7.contents.parts), n6;
                }(t6) : t6.parts, o4 = r4[r4.length - 1];
                if ("concat" === o4.type) return 2 === o4.parts.length && o4.parts[0].hard && "break-parent" === o4.parts[1].type ? {
                    type: "concat",
                    parts: r4.slice(0, -1)
                } : {
                    type: "concat",
                    parts: t6.parts.slice(0, -1).concat(e8(o4))
                };
            }
            return t6;
        },
        normalizeParts: en,
        normalizeDoc: function(e9) {
            return Ht(e9, (e10)=>e10.parts ? Object.assign({
                }, e10, {
                    parts: en(e10.parts)
                }) : e10
            );
        },
        replaceNewlinesWithLiterallines: function(e9) {
            return Ht(e9, (e10)=>"string" == typeof e10 && e10.includes("\n") ? Jt(e10.split(/(\n)/g).map((e11, t6)=>t6 % 2 == 0 ? e11 : Ut
                )) : e10
            );
        }
    },
    debug: {
        printDocToDebug: (e8)=>nn(tn(e8))
    }
};
var pn1 = {
    resolve: function() {
        for(var e8, t6 = "", n5 = !1, r4 = arguments.length - 1; r4 >= -1 && !n5; r4--){
            var o4;
            r4 >= 0 ? o4 = arguments[r4] : ((void 0) === e8 && (e8 = Oe2.cwd()), o4 = e8), ln(o4), 0 !== o4.length && (t6 = o4 + "/" + t6, n5 = 47 === o4.charCodeAt(0));
        }
        return (t6 = cn(t6, !n5), n5 ? t6.length > 0 ? "/" + t6 : "/" : t6.length > 0 ? t6 : ".");
    },
    normalize: function(e8) {
        if ((ln(e8), 0 === e8.length)) return ".";
        var t6 = 47 === e8.charCodeAt(0), n5 = 47 === e8.charCodeAt(e8.length - 1);
        return (0 !== (e8 = cn(e8, !t6)).length || t6 || (e8 = "."), e8.length > 0 && n5 && (e8 += "/"), t6 ? "/" + e8 : e8);
    },
    isAbsolute: function(e8) {
        return (ln(e8), e8.length > 0 && 47 === e8.charCodeAt(0));
    },
    join: function() {
        if (0 === arguments.length) return ".";
        for(var e8, t6 = 0; t6 < arguments.length; ++t6){
            var n5 = arguments[t6];
            ln(n5), n5.length > 0 && ((void 0) === e8 ? e8 = n5 : e8 += "/" + n5);
        }
        return (void 0) === e8 ? "." : pn1.normalize(e8);
    },
    relative: function(e8, t6) {
        if ((ln(e8), ln(t6), e8 === t6)) return "";
        if ((e8 = pn1.resolve(e8)) === (t6 = pn1.resolve(t6))) return "";
        for(var n5 = 1; n5 < e8.length && 47 === e8.charCodeAt(n5); ++n5);
        for(var r4 = e8.length, o4 = r4 - n5, u4 = 1; u4 < t6.length && 47 === t6.charCodeAt(u4); ++u4);
        for(var i5 = t6.length - u4, a4 = o4 < i5 ? o4 : i5, s4 = -1, l4 = 0; l4 <= a4; ++l4){
            if (l4 === a4) {
                if (i5 > a4) {
                    if (47 === t6.charCodeAt(u4 + l4)) return t6.slice(u4 + l4 + 1);
                    if (0 === l4) return t6.slice(u4 + l4);
                } else o4 > a4 && (47 === e8.charCodeAt(n5 + l4) ? s4 = l4 : 0 === l4 && (s4 = 0));
                break;
            }
            var c4 = e8.charCodeAt(n5 + l4);
            if (c4 !== t6.charCodeAt(u4 + l4)) break;
            47 === c4 && (s4 = l4);
        }
        var p4 = "";
        for(l4 = n5 + s4 + 1; l4 <= r4; ++l4)l4 !== r4 && 47 !== e8.charCodeAt(l4) || (0 === p4.length ? p4 += ".." : p4 += "/..");
        return p4.length > 0 ? p4 + t6.slice(u4 + s4) : (u4 += s4, 47 === t6.charCodeAt(u4) && ++u4, t6.slice(u4));
    },
    _makeLong: function(e8) {
        return e8;
    },
    dirname: function(e8) {
        if ((ln(e8), 0 === e8.length)) return ".";
        for(var t6 = e8.charCodeAt(0), n5 = 47 === t6, r4 = -1, o4 = !0, u4 = e8.length - 1; u4 >= 1; --u4)if (47 === (t6 = e8.charCodeAt(u4))) {
            if (!o4) {
                r4 = u4;
                break;
            }
        } else o4 = !1;
        return -1 === r4 ? n5 ? "/" : "." : n5 && 1 === r4 ? "//" : e8.slice(0, r4);
    },
    basename: function(e8, t6) {
        if ((void 0) !== t6 && "string" != typeof t6) throw new TypeError('"ext" argument must be a string');
        ln(e8);
        var n5, r4 = 0, o4 = -1, u4 = !0;
        if ((void 0) !== t6 && t6.length > 0 && t6.length <= e8.length) {
            if (t6.length === e8.length && t6 === e8) return "";
            var i5 = t6.length - 1, a4 = -1;
            for(n5 = e8.length - 1; n5 >= 0; --n5){
                var s4 = e8.charCodeAt(n5);
                if (47 === s4) {
                    if (!u4) {
                        r4 = n5 + 1;
                        break;
                    }
                } else -1 === a4 && (u4 = !1, a4 = n5 + 1), i5 >= 0 && (s4 === t6.charCodeAt(i5) ? -1 == --i5 && (o4 = n5) : (i5 = -1, o4 = a4));
            }
            return (r4 === o4 ? o4 = a4 : -1 === o4 && (o4 = e8.length), e8.slice(r4, o4));
        }
        for(n5 = e8.length - 1; n5 >= 0; --n5)if (47 === e8.charCodeAt(n5)) {
            if (!u4) {
                r4 = n5 + 1;
                break;
            }
        } else -1 === o4 && (u4 = !1, o4 = n5 + 1);
        return -1 === o4 ? "" : e8.slice(r4, o4);
    },
    extname: function(e8) {
        ln(e8);
        for(var t6 = -1, n5 = 0, r4 = -1, o4 = !0, u4 = 0, i5 = e8.length - 1; i5 >= 0; --i5){
            var a4 = e8.charCodeAt(i5);
            if (47 !== a4) -1 === r4 && (o4 = !1, r4 = i5 + 1), 46 === a4 ? -1 === t6 ? t6 = i5 : 1 !== u4 && (u4 = 1) : -1 !== t6 && (u4 = -1);
            else if (!o4) {
                n5 = i5 + 1;
                break;
            }
        }
        return -1 === t6 || -1 === r4 || 0 === u4 || 1 === u4 && t6 === r4 - 1 && t6 === n5 + 1 ? "" : e8.slice(t6, r4);
    },
    format: function(e8) {
        if (null === e8 || "object" != typeof e8) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e8);
        return function(e9, t6) {
            var n5 = t6.dir || t6.root, r4 = t6.base || (t6.name || "") + (t6.ext || "");
            return n5 ? n5 === t6.root ? n5 + r4 : n5 + e9 + r4 : r4;
        }("/", e8);
    },
    parse: function(e8) {
        ln(e8);
        var t6 = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (0 === e8.length) return t6;
        var n5, r4 = e8.charCodeAt(0), o4 = 47 === r4;
        o4 ? (t6.root = "/", n5 = 1) : n5 = 0;
        for(var u4 = -1, i5 = 0, a4 = -1, s4 = !0, l4 = e8.length - 1, c4 = 0; l4 >= n5; --l4)if (47 !== (r4 = e8.charCodeAt(l4))) -1 === a4 && (s4 = !1, a4 = l4 + 1), 46 === r4 ? -1 === u4 ? u4 = l4 : 1 !== c4 && (c4 = 1) : -1 !== u4 && (c4 = -1);
        else if (!s4) {
            i5 = l4 + 1;
            break;
        }
        return (-1 === u4 || -1 === a4 || 0 === c4 || 1 === c4 && u4 === a4 - 1 && u4 === i5 + 1 ? -1 !== a4 && (t6.base = t6.name = 0 === i5 && o4 ? e8.slice(1, a4) : e8.slice(i5, a4)) : (0 === i5 && o4 ? (t6.name = e8.slice(1, u4), t6.base = e8.slice(1, a4)) : (t6.name = e8.slice(i5, u4), t6.base = e8.slice(i5, a4)), t6.ext = e8.slice(u4, a4)), i5 > 0 ? t6.dir = e8.slice(0, i5 - 1) : o4 && (t6.dir = "/"), t6);
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
};
pn1.posix = pn1;
var dn1 = pn1, fn1 = Object.freeze(Object.assign(Object.create(null), dn1, {
    default: dn1,
    __moduleExports: dn1
})), hn1 = [], mn1 = [], gn1 = "undefined" != typeof Uint8Array ? Uint8Array : Array, Dn1 = !1;
function yn1() {
    Dn1 = !0;
    for(var e8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t6 = 0, n5 = e8.length; t6 < n5; ++t6)hn1[t6] = e8[t6], mn1[e8.charCodeAt(t6)] = t6;
    mn1["-".charCodeAt(0)] = 62, mn1["_".charCodeAt(0)] = 63;
}
function En1(e8, t6, n5) {
    for(var r4, o4, u4 = [], i5 = t6; i5 < n5; i5 += 3)r4 = (e8[i5] << 16) + (e8[i5 + 1] << 8) + e8[i5 + 2], u4.push(hn1[(o4 = r4) >> 18 & 63] + hn1[o4 >> 12 & 63] + hn1[o4 >> 6 & 63] + hn1[63 & o4]);
    return u4.join("");
}
function Cn1(e8) {
    var t6;
    Dn1 || yn1();
    for(var n5 = e8.length, r4 = n5 % 3, o4 = "", u4 = [], i5 = 16383, a4 = 0, s4 = n5 - r4; a4 < s4; a4 += i5)u4.push(En1(e8, a4, a4 + i5 > s4 ? s4 : a4 + i5));
    return 1 === r4 ? (t6 = e8[n5 - 1], o4 += hn1[t6 >> 2], o4 += hn1[t6 << 4 & 63], o4 += "==") : 2 === r4 && (t6 = (e8[n5 - 2] << 8) + e8[n5 - 1], o4 += hn1[t6 >> 10], o4 += hn1[t6 >> 4 & 63], o4 += hn1[t6 << 2 & 63], o4 += "="), u4.push(o4), u4.join("");
}
function xn() {
    return wn.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Sn(e8, t6) {
    if (xn() < t6) throw new RangeError("Invalid typed array length");
    return wn.TYPED_ARRAY_SUPPORT ? (e8 = new Uint8Array(t6)).__proto__ = wn.prototype : (null === e8 && (e8 = new wn(t6)), e8.length = t6), e8;
}
function wn(e8, t6, n5) {
    if (!(wn.TYPED_ARRAY_SUPPORT || this instanceof wn)) return new wn(e8, t6, n5);
    if ("number" == typeof e8) {
        if ("string" == typeof t6) throw new Error("If encoding is specified then the first argument must be a string");
        return Nn(this, e8);
    }
    return Tn2(this, e8, t6, n5);
}
function Tn2(e8, t6, n5, r4) {
    if ("number" == typeof t6) throw new TypeError('"value" argument must not be a number');
    return "undefined" != typeof ArrayBuffer && t6 instanceof ArrayBuffer ? (function(e9, t7, n6, r5) {
        if (t7.byteLength, n6 < 0 || t7.byteLength < n6) throw new RangeError("'offset' is out of bounds");
        if (t7.byteLength < n6 + (r5 || 0)) throw new RangeError("'length' is out of bounds");
        t7 = (void 0) === n6 && (void 0) === r5 ? new Uint8Array(t7) : (void 0) === r5 ? new Uint8Array(t7, n6) : new Uint8Array(t7, n6, r5);
        wn.TYPED_ARRAY_SUPPORT ? (e9 = t7).__proto__ = wn.prototype : e9 = kn(e9, t7);
        return e9;
    })(e8, t6, n5, r4) : "string" == typeof t6 ? (function(e9, t7, n6) {
        "string" == typeof n6 && "" !== n6 || (n6 = "utf8");
        if (!wn.isEncoding(n6)) throw new TypeError('"encoding" must be a valid string encoding');
        var r5 = 0 | In(t7, n6), o4 = (e9 = Sn(e9, r5)).write(t7, n6);
        o4 !== r5 && (e9 = e9.slice(0, o4));
        return e9;
    })(e8, t6, n5) : (function(e9, t7) {
        if (On(t7)) {
            var n6 = 0 | Pn(t7.length);
            return 0 === (e9 = Sn(e9, n6)).length || t7.copy(e9, 0, 0, n6), e9;
        }
        if (t7) {
            if ("undefined" != typeof ArrayBuffer && t7.buffer instanceof ArrayBuffer || "length" in t7) return "number" != typeof t7.length || (r5 = t7.length) != r5 ? Sn(e9, 0) : kn(e9, t7);
            if ("Buffer" === t7.type && Fn(t7.data)) return kn(e9, t7.data);
        }
        var r5;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    })(e8, t6);
}
function Nn(e8, t6) {
    if (Bn(t6), e8 = Sn(e8, t6 < 0 ? 0 : 0 | Pn(t6)), !wn.TYPED_ARRAY_SUPPORT) for(var n5 = 0; n5 < t6; ++n5)e8[n5] = 0;
    return e8;
}
function kn(e8, t6) {
    var n5 = t6.length < 0 ? 0 : 0 | Pn(t6.length);
    e8 = Sn(e8, n5);
    for(var r4 = 0; r4 < n5; r4 += 1)e8[r4] = 255 & t6[r4];
    return e8;
}
function Pn(e8) {
    if (e8 >= xn()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + xn().toString(16) + " bytes");
    return 0 | e8;
}
function In(e8, t6) {
    if (On(e8)) return e8.length;
    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e8) || e8 instanceof ArrayBuffer)) return e8.byteLength;
    "string" != typeof e8 && (e8 = "" + e8);
    var n5 = e8.length;
    if (0 === n5) return 0;
    for(var r4 = !1;;)switch(t6){
        case "ascii":
        case "latin1":
        case "binary":
            return n5;
        case "utf8":
        case "utf-8":
        case void 0:
            return ir(e8).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return 2 * n5;
        case "hex":
            return n5 >>> 1;
        case "base64":
            return ar(e8).length;
        default:
            if (r4) return ir(e8).length;
            t6 = ("" + t6).toLowerCase(), r4 = !0;
    }
}
function Ln(e8, t6, n5) {
    var r4 = !1;
    if (((void 0) === t6 || t6 < 0) && (t6 = 0), t6 > this.length) return "";
    if (((void 0) === n5 || n5 > this.length) && (n5 = this.length), n5 <= 0) return "";
    if ((n5 >>>= 0) <= (t6 >>>= 0)) return "";
    for(e8 || (e8 = "utf8");;)switch(e8){
        case "hex":
            return Xn(this, t6, n5);
        case "utf8":
        case "utf-8":
            return zn(this, t6, n5);
        case "ascii":
            return Gn(this, t6, n5);
        case "latin1":
        case "binary":
            return Hn(this, t6, n5);
        case "base64":
            return Jn(this, t6, n5);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return Yn(this, t6, n5);
        default:
            if (r4) throw new TypeError("Unknown encoding: " + e8);
            e8 = (e8 + "").toLowerCase(), r4 = !0;
    }
}
function jn(e8, t6, n5, r4, o4) {
    if (0 === e8.length) return -1;
    if ("string" == typeof n5 ? (r4 = n5, n5 = 0) : n5 > 2147483647 ? n5 = 2147483647 : n5 < -2147483648 && (n5 = -2147483648), n5 = +n5, isNaN(n5) && (n5 = o4 ? 0 : e8.length - 1), n5 < 0 && (n5 = e8.length + n5), n5 >= e8.length) {
        if (o4) return -1;
        n5 = e8.length - 1;
    } else if (n5 < 0) {
        if (!o4) return -1;
        n5 = 0;
    }
    if ("string" == typeof t6 && (t6 = wn.from(t6, r4)), On(t6)) return 0 === t6.length ? -1 : _n(e8, t6, n5, r4, o4);
    if ("number" == typeof t6) return t6 &= 255, wn.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o4 ? Uint8Array.prototype.indexOf.call(e8, t6, n5) : Uint8Array.prototype.lastIndexOf.call(e8, t6, n5) : _n(e8, [
        t6
    ], n5, r4, o4);
    throw new TypeError("val must be string, number or Buffer");
}
function Wn(e8, t6, n5, r4) {
    return sr(ar(t6), e8, n5, r4);
}
function Jn(e8, t6, n5) {
    return 0 === t6 && n5 === e8.length ? Cn1(e8) : Cn1(e8.slice(t6, n5));
}
wn.TYPED_ARRAY_SUPPORT = (void 0) === le.TYPED_ARRAY_SUPPORT || le.TYPED_ARRAY_SUPPORT, wn.poolSize = 8192, wn._augment = function(e8) {
    return e8.__proto__ = wn.prototype, e8;
}, wn.from = function(e8, t6, n5) {
    return Tn2(null, e8, t6, n5);
}, wn.TYPED_ARRAY_SUPPORT && (wn.prototype.__proto__ = Uint8Array.prototype, wn.__proto__ = Uint8Array), wn.alloc = function(e8, t6, n5) {
    return (function(e9, t7, n6, r4) {
        return Bn(t7), t7 <= 0 ? Sn(e9, t7) : (void 0) !== n6 ? "string" == typeof r4 ? Sn(e9, t7).fill(n6, r4) : Sn(e9, t7).fill(n6) : Sn(e9, t7);
    })(null, e8, t6, n5);
}, wn.allocUnsafe = function(e8) {
    return Nn(null, e8);
}, wn.allocUnsafeSlow = function(e8) {
    return Nn(null, e8);
}, wn.isBuffer = function(e8) {
    return null != e8 && (!!e8._isBuffer || lr(e8) || (function(e9) {
        return "function" == typeof e9.readFloatLE && "function" == typeof e9.slice && lr(e9.slice(0, 0));
    })(e8));
}, wn.compare = function(e8, t6) {
    if (!On(e8) || !On(t6)) throw new TypeError("Arguments must be Buffers");
    if (e8 === t6) return 0;
    for(var n5 = e8.length, r4 = t6.length, o4 = 0, u4 = Math.min(n5, r4); o4 < u4; ++o4)if (e8[o4] !== t6[o4]) {
        n5 = e8[o4], r4 = t6[o4];
        break;
    }
    return n5 < r4 ? -1 : r4 < n5 ? 1 : 0;
}, wn.isEncoding = function(e8) {
    switch(String(e8).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1;
    }
}, wn.concat = function(e8, t6) {
    if (!Fn(e8)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e8.length) return wn.alloc(0);
    var n5;
    if ((void 0) === t6) for(t6 = 0, n5 = 0; n5 < e8.length; ++n5)t6 += e8[n5].length;
    var r4 = wn.allocUnsafe(t6), o4 = 0;
    for(n5 = 0; n5 < e8.length; ++n5){
        var u4 = e8[n5];
        if (!On(u4)) throw new TypeError('"list" argument must be an Array of Buffers');
        u4.copy(r4, o4), o4 += u4.length;
    }
    return r4;
}, wn.byteLength = In, wn.prototype._isBuffer = !0, wn.prototype.swap16 = function() {
    var e8 = this.length;
    if (e8 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var t6 = 0; t6 < e8; t6 += 2)Mn(this, t6, t6 + 1);
    return this;
}, wn.prototype.swap32 = function() {
    var e8 = this.length;
    if (e8 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var t6 = 0; t6 < e8; t6 += 4)Mn(this, t6, t6 + 3), Mn(this, t6 + 1, t6 + 2);
    return this;
}, wn.prototype.swap64 = function() {
    var e8 = this.length;
    if (e8 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var t6 = 0; t6 < e8; t6 += 8)Mn(this, t6, t6 + 7), Mn(this, t6 + 1, t6 + 6), Mn(this, t6 + 2, t6 + 5), Mn(this, t6 + 3, t6 + 4);
    return this;
}, wn.prototype.toString = function() {
    var e8 = 0 | this.length;
    return 0 === e8 ? "" : 0 === arguments.length ? zn(this, 0, e8) : Ln.apply(this, arguments);
}, wn.prototype.equals = function(e8) {
    if (!On(e8)) throw new TypeError("Argument must be a Buffer");
    return this === e8 || 0 === wn.compare(this, e8);
}, wn.prototype.inspect = function() {
    var e8 = "";
    return this.length > 0 && (e8 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e8 += " ... ")), "<Buffer " + e8 + ">";
}, wn.prototype.compare = function(e8, t6, n5, r4, o4) {
    if (!On(e8)) throw new TypeError("Argument must be a Buffer");
    if ((void 0) === t6 && (t6 = 0), (void 0) === n5 && (n5 = e8 ? e8.length : 0), (void 0) === r4 && (r4 = 0), (void 0) === o4 && (o4 = this.length), t6 < 0 || n5 > e8.length || r4 < 0 || o4 > this.length) throw new RangeError("out of range index");
    if (r4 >= o4 && t6 >= n5) return 0;
    if (r4 >= o4) return -1;
    if (t6 >= n5) return 1;
    if (this === e8) return 0;
    for(var u4 = (o4 >>>= 0) - (r4 >>>= 0), i5 = (n5 >>>= 0) - (t6 >>>= 0), a4 = Math.min(u4, i5), s4 = this.slice(r4, o4), l4 = e8.slice(t6, n5), c4 = 0; c4 < a4; ++c4)if (s4[c4] !== l4[c4]) {
        u4 = s4[c4], i5 = l4[c4];
        break;
    }
    return u4 < i5 ? -1 : i5 < u4 ? 1 : 0;
}, wn.prototype.includes = function(e8, t6, n5) {
    return -1 !== this.indexOf(e8, t6, n5);
}, wn.prototype.indexOf = function(e8, t6, n5) {
    return jn(this, e8, t6, n5, !0);
}, wn.prototype.lastIndexOf = function(e8, t6, n5) {
    return jn(this, e8, t6, n5, !1);
}, wn.prototype.write = function(e8, t6, n5, r4) {
    if ((void 0) === t6) r4 = "utf8", n5 = this.length, t6 = 0;
    else if ((void 0) === n5 && "string" == typeof t6) r4 = t6, n5 = this.length, t6 = 0;
    else {
        if (!isFinite(t6)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t6 |= 0, isFinite(n5) ? (n5 |= 0, (void 0) === r4 && (r4 = "utf8")) : (r4 = n5, n5 = void 0);
    }
    var o4 = this.length - t6;
    if (((void 0) === n5 || n5 > o4) && (n5 = o4), e8.length > 0 && (n5 < 0 || t6 < 0) || t6 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    r4 || (r4 = "utf8");
    for(var u4 = !1;;)switch(r4){
        case "hex":
            return Rn(this, e8, t6, n5);
        case "utf8":
        case "utf-8":
            return Vn(this, e8, t6, n5);
        case "ascii":
            return $n(this, e8, t6, n5);
        case "latin1":
        case "binary":
            return qn(this, e8, t6, n5);
        case "base64":
            return Wn(this, e8, t6, n5);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return Un(this, e8, t6, n5);
        default:
            if (u4) throw new TypeError("Unknown encoding: " + r4);
            r4 = ("" + r4).toLowerCase(), u4 = !0;
    }
}, wn.prototype.toJSON = function() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
wn.prototype.slice = function(e8, t6) {
    var n5, r4 = this.length;
    if ((e8 = ~~e8) < 0 ? (e8 += r4) < 0 && (e8 = 0) : e8 > r4 && (e8 = r4), (t6 = (void 0) === t6 ? r4 : ~~t6) < 0 ? (t6 += r4) < 0 && (t6 = 0) : t6 > r4 && (t6 = r4), t6 < e8 && (t6 = e8), wn.TYPED_ARRAY_SUPPORT) (n5 = this.subarray(e8, t6)).__proto__ = wn.prototype;
    else {
        var o4 = t6 - e8;
        n5 = new wn(o4, void 0);
        for(var u4 = 0; u4 < o4; ++u4)n5[u4] = this[u4 + e8];
    }
    return n5;
}, wn.prototype.readUIntLE = function(e8, t6, n5) {
    e8 |= 0, t6 |= 0, n5 || Kn(e8, t6, this.length);
    for(var r4 = this[e8], o4 = 1, u4 = 0; (++u4) < t6 && (o4 *= 256);)r4 += this[e8 + u4] * o4;
    return r4;
}, wn.prototype.readUIntBE = function(e8, t6, n5) {
    e8 |= 0, t6 |= 0, n5 || Kn(e8, t6, this.length);
    for(var r4 = this[e8 + --t6], o4 = 1; t6 > 0 && (o4 *= 256);)r4 += this[e8 + --t6] * o4;
    return r4;
}, wn.prototype.readUInt8 = function(e8, t6) {
    return t6 || Kn(e8, 1, this.length), this[e8];
}, wn.prototype.readUInt16LE = function(e8, t6) {
    return t6 || Kn(e8, 2, this.length), this[e8] | this[e8 + 1] << 8;
}, wn.prototype.readUInt16BE = function(e8, t6) {
    return t6 || Kn(e8, 2, this.length), this[e8] << 8 | this[e8 + 1];
}, wn.prototype.readUInt32LE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), (this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16) + 16777216 * this[e8 + 3];
}, wn.prototype.readUInt32BE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), 16777216 * this[e8] + (this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3]);
}, wn.prototype.readIntLE = function(e8, t6, n5) {
    e8 |= 0, t6 |= 0, n5 || Kn(e8, t6, this.length);
    for(var r4 = this[e8], o4 = 1, u4 = 0; (++u4) < t6 && (o4 *= 256);)r4 += this[e8 + u4] * o4;
    return r4 >= (o4 *= 128) && (r4 -= Math.pow(2, 8 * t6)), r4;
}, wn.prototype.readIntBE = function(e8, t6, n5) {
    e8 |= 0, t6 |= 0, n5 || Kn(e8, t6, this.length);
    for(var r4 = t6, o4 = 1, u4 = this[e8 + --r4]; r4 > 0 && (o4 *= 256);)u4 += this[e8 + --r4] * o4;
    return u4 >= (o4 *= 128) && (u4 -= Math.pow(2, 8 * t6)), u4;
}, wn.prototype.readInt8 = function(e8, t6) {
    return t6 || Kn(e8, 1, this.length), 128 & this[e8] ? -1 * (255 - this[e8] + 1) : this[e8];
}, wn.prototype.readInt16LE = function(e8, t6) {
    t6 || Kn(e8, 2, this.length);
    var n5 = this[e8] | this[e8 + 1] << 8;
    return 32768 & n5 ? 4294901760 | n5 : n5;
}, wn.prototype.readInt16BE = function(e8, t6) {
    t6 || Kn(e8, 2, this.length);
    var n5 = this[e8 + 1] | this[e8] << 8;
    return 32768 & n5 ? 4294901760 | n5 : n5;
}, wn.prototype.readInt32LE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16 | this[e8 + 3] << 24;
}, wn.prototype.readInt32BE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), this[e8] << 24 | this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3];
}, wn.prototype.readFloatLE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), bn(this, e8, !0, 23, 4);
}, wn.prototype.readFloatBE = function(e8, t6) {
    return t6 || Kn(e8, 4, this.length), bn(this, e8, !1, 23, 4);
}, wn.prototype.readDoubleLE = function(e8, t6) {
    return t6 || Kn(e8, 8, this.length), bn(this, e8, !0, 52, 8);
}, wn.prototype.readDoubleBE = function(e8, t6) {
    return t6 || Kn(e8, 8, this.length), bn(this, e8, !1, 52, 8);
}, wn.prototype.writeUIntLE = function(e8, t6, n5, r4) {
    (e8 = +e8, t6 |= 0, n5 |= 0, r4) || Qn(this, e8, t6, n5, Math.pow(2, 8 * n5) - 1, 0);
    var o4 = 1, u4 = 0;
    for(this[t6] = 255 & e8; (++u4) < n5 && (o4 *= 256);)this[t6 + u4] = e8 / o4 & 255;
    return t6 + n5;
}, wn.prototype.writeUIntBE = function(e8, t6, n5, r4) {
    (e8 = +e8, t6 |= 0, n5 |= 0, r4) || Qn(this, e8, t6, n5, Math.pow(2, 8 * n5) - 1, 0);
    var o4 = n5 - 1, u4 = 1;
    for(this[t6 + o4] = 255 & e8; (--o4) >= 0 && (u4 *= 256);)this[t6 + o4] = e8 / u4 & 255;
    return t6 + n5;
}, wn.prototype.writeUInt8 = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 1, 255, 0), wn.TYPED_ARRAY_SUPPORT || (e8 = Math.floor(e8)), this[t6] = 255 & e8, t6 + 1;
}, wn.prototype.writeUInt16LE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 2, 65535, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e8, this[t6 + 1] = e8 >>> 8) : Zn(this, e8, t6, !0), t6 + 2;
}, wn.prototype.writeUInt16BE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 2, 65535, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = e8 >>> 8, this[t6 + 1] = 255 & e8) : Zn(this, e8, t6, !1), t6 + 2;
}, wn.prototype.writeUInt32LE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 4, 4294967295, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t6 + 3] = e8 >>> 24, this[t6 + 2] = e8 >>> 16, this[t6 + 1] = e8 >>> 8, this[t6] = 255 & e8) : er(this, e8, t6, !0), t6 + 4;
}, wn.prototype.writeUInt32BE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 4, 4294967295, 0), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = e8 >>> 24, this[t6 + 1] = e8 >>> 16, this[t6 + 2] = e8 >>> 8, this[t6 + 3] = 255 & e8) : er(this, e8, t6, !1), t6 + 4;
}, wn.prototype.writeIntLE = function(e8, t6, n5, r4) {
    if (e8 = +e8, t6 |= 0, !r4) {
        var o4 = Math.pow(2, 8 * n5 - 1);
        Qn(this, e8, t6, n5, o4 - 1, -o4);
    }
    var u4 = 0, i5 = 1, a4 = 0;
    for(this[t6] = 255 & e8; (++u4) < n5 && (i5 *= 256);)e8 < 0 && 0 === a4 && 0 !== this[t6 + u4 - 1] && (a4 = 1), this[t6 + u4] = (e8 / i5 >> 0) - a4 & 255;
    return t6 + n5;
}, wn.prototype.writeIntBE = function(e8, t6, n5, r4) {
    if (e8 = +e8, t6 |= 0, !r4) {
        var o4 = Math.pow(2, 8 * n5 - 1);
        Qn(this, e8, t6, n5, o4 - 1, -o4);
    }
    var u4 = n5 - 1, i5 = 1, a4 = 0;
    for(this[t6 + u4] = 255 & e8; (--u4) >= 0 && (i5 *= 256);)e8 < 0 && 0 === a4 && 0 !== this[t6 + u4 + 1] && (a4 = 1), this[t6 + u4] = (e8 / i5 >> 0) - a4 & 255;
    return t6 + n5;
}, wn.prototype.writeInt8 = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 1, 127, -128), wn.TYPED_ARRAY_SUPPORT || (e8 = Math.floor(e8)), e8 < 0 && (e8 = 255 + e8 + 1), this[t6] = 255 & e8, t6 + 1;
}, wn.prototype.writeInt16LE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 2, 32767, -32768), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e8, this[t6 + 1] = e8 >>> 8) : Zn(this, e8, t6, !0), t6 + 2;
}, wn.prototype.writeInt16BE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 2, 32767, -32768), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = e8 >>> 8, this[t6 + 1] = 255 & e8) : Zn(this, e8, t6, !1), t6 + 2;
}, wn.prototype.writeInt32LE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 4, 2147483647, -2147483648), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e8, this[t6 + 1] = e8 >>> 8, this[t6 + 2] = e8 >>> 16, this[t6 + 3] = e8 >>> 24) : er(this, e8, t6, !0), t6 + 4;
}, wn.prototype.writeInt32BE = function(e8, t6, n5) {
    return e8 = +e8, t6 |= 0, n5 || Qn(this, e8, t6, 4, 2147483647, -2147483648), e8 < 0 && (e8 = 4294967295 + e8 + 1), wn.TYPED_ARRAY_SUPPORT ? (this[t6] = e8 >>> 24, this[t6 + 1] = e8 >>> 16, this[t6 + 2] = e8 >>> 8, this[t6 + 3] = 255 & e8) : er(this, e8, t6, !1), t6 + 4;
}, wn.prototype.writeFloatLE = function(e8, t6, n5) {
    return nr(this, e8, t6, !0, n5);
}, wn.prototype.writeFloatBE = function(e8, t6, n5) {
    return nr(this, e8, t6, !1, n5);
}, wn.prototype.writeDoubleLE = function(e8, t6, n5) {
    return rr(this, e8, t6, !0, n5);
}, wn.prototype.writeDoubleBE = function(e8, t6, n5) {
    return rr(this, e8, t6, !1, n5);
}, wn.prototype.copy = function(e8, t6, n5, r4) {
    if (n5 || (n5 = 0), r4 || 0 === r4 || (r4 = this.length), t6 >= e8.length && (t6 = e8.length), t6 || (t6 = 0), r4 > 0 && r4 < n5 && (r4 = n5), r4 === n5) return 0;
    if (0 === e8.length || 0 === this.length) return 0;
    if (t6 < 0) throw new RangeError("targetStart out of bounds");
    if (n5 < 0 || n5 >= this.length) throw new RangeError("sourceStart out of bounds");
    if (r4 < 0) throw new RangeError("sourceEnd out of bounds");
    r4 > this.length && (r4 = this.length), e8.length - t6 < r4 - n5 && (r4 = e8.length - t6 + n5);
    var o4, u4 = r4 - n5;
    if (this === e8 && n5 < t6 && t6 < r4) for(o4 = u4 - 1; o4 >= 0; --o4)e8[o4 + t6] = this[o4 + n5];
    else if (u4 < 1000 || !wn.TYPED_ARRAY_SUPPORT) for(o4 = 0; o4 < u4; ++o4)e8[o4 + t6] = this[o4 + n5];
    else Uint8Array.prototype.set.call(e8, this.subarray(n5, n5 + u4), t6);
    return u4;
}, wn.prototype.fill = function(e8, t6, n5, r4) {
    if ("string" == typeof e8) {
        if ("string" == typeof t6 ? (r4 = t6, t6 = 0, n5 = this.length) : "string" == typeof n5 && (r4 = n5, n5 = this.length), 1 === e8.length) {
            var o4 = e8.charCodeAt(0);
            o4 < 256 && (e8 = o4);
        }
        if ((void 0) !== r4 && "string" != typeof r4) throw new TypeError("encoding must be a string");
        if ("string" == typeof r4 && !wn.isEncoding(r4)) throw new TypeError("Unknown encoding: " + r4);
    } else "number" == typeof e8 && (e8 &= 255);
    if (t6 < 0 || this.length < t6 || this.length < n5) throw new RangeError("Out of range index");
    if (n5 <= t6) return this;
    var u4;
    if (t6 >>>= 0, n5 = (void 0) === n5 ? this.length : n5 >>> 0, e8 || (e8 = 0), "number" == typeof e8) for(u4 = t6; u4 < n5; ++u4)this[u4] = e8;
    else {
        var i5 = On(e8) ? e8 : ir(new wn(e8, r4).toString()), a4 = i5.length;
        for(u4 = 0; u4 < n5 - t6; ++u4)this[u4 + t6] = i5[u4 % a4];
    }
    return this;
};
function ar(e8) {
    return (function(e9) {
        var t6, n5, r4, o4, u4, i5;
        Dn1 || yn1();
        var a4 = e9.length;
        if (a4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        u4 = "=" === e9[a4 - 2] ? 2 : "=" === e9[a4 - 1] ? 1 : 0, i5 = new gn1(3 * a4 / 4 - u4), r4 = u4 > 0 ? a4 - 4 : a4;
        var s4 = 0;
        for(t6 = 0, n5 = 0; t6 < r4; t6 += 4, n5 += 3)o4 = mn1[e9.charCodeAt(t6)] << 18 | mn1[e9.charCodeAt(t6 + 1)] << 12 | mn1[e9.charCodeAt(t6 + 2)] << 6 | mn1[e9.charCodeAt(t6 + 3)], i5[s4++] = o4 >> 16 & 255, i5[s4++] = o4 >> 8 & 255, i5[s4++] = 255 & o4;
        return 2 === u4 ? (o4 = mn1[e9.charCodeAt(t6)] << 2 | mn1[e9.charCodeAt(t6 + 1)] >> 4, i5[s4++] = 255 & o4) : 1 === u4 && (o4 = mn1[e9.charCodeAt(t6)] << 10 | mn1[e9.charCodeAt(t6 + 1)] << 4 | mn1[e9.charCodeAt(t6 + 2)] >> 2, i5[s4++] = o4 >> 8 & 255, i5[s4++] = 255 & o4), i5;
    })(function(e9) {
        if ((e9 = (function(e10) {
            return e10.trim ? e10.trim() : e10.replace(/^\s+|\s+$/g, "");
        })(e9).replace(or, "")).length < 2) return "";
        for(; e9.length % 4 != 0;)e9 += "=";
        return e9;
    }(e8));
}
var pr = class {
    constructor(e8, t6){
        (t6 = t6 || {
        }).readChunk || (t6.readChunk = 1024), t6.newLineCharacter ? t6.newLineCharacter = t6.newLineCharacter.charCodeAt(0) : t6.newLineCharacter = 10, this.fd = "number" == typeof e8 ? e8 : cr.openSync(e8, "r"), this.options = t6, this.newLineCharacter = t6.newLineCharacter, this.reset();
    }
    _searchInBuffer(e, t) {
        let n5 = -1;
        for(let r4 = 0; r4 <= e.length; r4++){
            if (e[r4] === t) {
                n5 = r4;
                break;
            }
        }
        return n5;
    }
    reset() {
        this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
    }
    close() {
        cr.closeSync(this.fd), this.fd = null;
    }
    _extractLines(e) {
        let t7;
        const n5 = [];
        let r4 = 0, o4 = 0;
        for(;;){
            let u4 = e[r4++];
            if (u4 === this.newLineCharacter) t7 = e.slice(o4, r4), n5.push(t7), o4 = r4;
            else if ((void 0) === u4) break;
        }
        let u4 = e.slice(o4, r4);
        return u4.length && n5.push(u4), n5;
    }
    _readChunk(e) {
        let t7, n5 = 0;
        const r4 = [];
        do {
            const e9 = new wn(this.options.readChunk);
            t7 = cr.readSync(this.fd, e9, 0, this.options.readChunk, this.fdPosition), n5 += t7, this.fdPosition = this.fdPosition + t7, r4.push(e9);
        }while (t7 && -1 === this._searchInBuffer(r4[r4.length - 1], this.options.newLineCharacter))
        let o4 = wn.concat(r4);
        return t7 < this.options.readChunk && (this.eofReached = !0, o4 = o4.slice(0, n5)), n5 && (this.linesCache = this._extractLines(o4), e && (this.linesCache[0] = wn.concat([
            e,
            this.linesCache[0]
        ]))), n5;
    }
    next() {
        if (!this.fd) return !1;
        let e9, t7 = !1;
        if (this.eofReached && 0 === this.linesCache.length) return t7;
        if (this.linesCache.length || (e9 = this._readChunk()), this.linesCache.length) {
            t7 = this.linesCache.shift();
            t7[t7.length - 1] !== this.newLineCharacter && (e9 = this._readChunk(t7), e9 && (t7 = this.linesCache.shift()));
        }
        return this.eofReached && 0 === this.linesCache.length && this.close(), t7 && t7[t7.length - 1] === this.newLineCharacter && (t7 = t7.slice(0, t7.length - 1)), t7;
    }
};
var Or = Pr, Ir = je(function(e9) {
    const t7 = (e10, t8)=>function() {
            const n5 = e10.apply(Or, arguments);
            return "\x1b[".concat(n5 + t8, "m");
        }
    , n5 = (e10, t8)=>function() {
            const n6 = e10.apply(Or, arguments);
            return "\x1b[".concat(38 + t8, ";5;").concat(n6, "m");
        }
    , r4 = (e10, t8)=>function() {
            const n6 = e10.apply(Or, arguments);
            return "\x1b[".concat(38 + t8, ";2;").concat(n6[0], ";").concat(n6[1], ";").concat(n6[2], "m");
        }
    ;
    Object.defineProperty(e9, "exports", {
        enumerable: !0,
        get: function() {
            const e10 = new Map, o4 = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    gray: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            o4.color.grey = o4.color.gray;
            for (const t8 of Object.keys(o4)){
                const n6 = o4[t8];
                for (const t9 of Object.keys(n6)){
                    const r5 = n6[t9];
                    o4[t9] = {
                        open: "\x1b[".concat(r5[0], "m"),
                        close: "\x1b[".concat(r5[1], "m")
                    }, n6[t9] = o4[t9], e10.set(r5[0], r5[1]);
                }
                Object.defineProperty(o4, t8, {
                    value: n6,
                    enumerable: !1
                }), Object.defineProperty(o4, "codes", {
                    value: e10,
                    enumerable: !1
                });
            }
            const u4 = (e11)=>e11
            , i5 = (e11, t9, n6)=>[
                    e11,
                    t9,
                    n6
                ]
            ;
            o4.color.close = "\x1b[39m", o4.bgColor.close = "\x1b[49m", o4.color.ansi = {
                ansi: t7(u4, 0)
            }, o4.color.ansi256 = {
                ansi256: n5(u4, 0)
            }, o4.color.ansi16m = {
                rgb: r4(i5, 0)
            }, o4.bgColor.ansi = {
                ansi: t7(u4, 10)
            }, o4.bgColor.ansi256 = {
                ansi256: n5(u4, 10)
            }, o4.bgColor.ansi16m = {
                rgb: r4(i5, 10)
            };
            for (let e11 of Object.keys(Or)){
                if ("object" != typeof Or[e11]) continue;
                const u5 = Or[e11];
                "ansi16" === e11 && (e11 = "ansi"), "ansi16" in u5 && (o4.color.ansi[e11] = t7(u5.ansi16, 0), o4.bgColor.ansi[e11] = t7(u5.ansi16, 10)), "ansi256" in u5 && (o4.color.ansi256[e11] = n5(u5.ansi256, 0), o4.bgColor.ansi256[e11] = n5(u5.ansi256, 10)), "rgb" in u5 && (o4.color.ansi16m[e11] = r4(u5.rgb, 0), o4.bgColor.ansi16m[e11] = r4(u5.rgb, 10));
            }
            return o4;
        }
    });
}), Lr = (e9, t7)=>{
    t7 = t7 || Oe2.argv;
    const n5 = e9.startsWith("-") ? "" : 1 === e9.length ? "-" : "--", r4 = t7.indexOf(n5 + e9), o4 = t7.indexOf("--");
    return -1 !== r4 && (-1 === o4 || r4 < o4);
}, Mr = _e(Object.freeze({
    __proto__: null,
    default: {
        EOL: "\n",
        platform: ()=>"browser"
        ,
        cpus: ()=>[
                {
                    model: "Prettier"
                }
            ]
    }
}));
const jr = Oe2.env;
function Rr(e9) {
    return (function(e10) {
        return 0 !== e10 && {
            level: e10,
            hasBasic: !0,
            has256: e10 >= 2,
            has16m: e10 >= 3
        };
    })(function(e10) {
        if (!1 === _r) return 0;
        if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor")) return 3;
        if (Lr("color=256")) return 2;
        if (e10 && !e10.isTTY && !0 !== _r) return 0;
        const t7 = _r ? 1 : 0;
        if ("win32" === Oe2.platform) {
            const e11 = Mr.release().split(".");
            return Number(Oe2.versions.node.split(".")[0]) >= 8 && Number(e11[0]) >= 10 && Number(e11[2]) >= 10586 ? Number(e11[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in jr) return [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI"
        ].some((e11)=>e11 in jr
        ) || "codeship" === jr.CI_NAME ? 1 : t7;
        if ("TEAMCITY_VERSION" in jr) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(jr.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === jr.COLORTERM) return 3;
        if ("TERM_PROGRAM" in jr) {
            const e11 = parseInt((jr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch(jr.TERM_PROGRAM){
                case "iTerm.app":
                    return e11 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test(jr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(jr.TERM) || "COLORTERM" in jr ? 1 : (jr.TERM, t7);
    }(e9));
}
Lr("no-color") || Lr("no-colors") || Lr("color=false") ? _r = !1 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && (_r = !0), "FORCE_COLOR" in jr && (_r = 0 === jr.FORCE_COLOR.length || 0 !== parseInt(jr.FORCE_COLOR, 10));
var Vr = {
    supportsColor: Rr,
    stdout: Rr(Oe2.stdout),
    stderr: Rr(Oe2.stderr)
};
var Yr = (e9, t7)=>{
    const n5 = [], r4 = [];
    let o4 = [];
    if (t7.replace($r, (t8, u4, i5, a4, s4, l4)=>{
        if (u4) o4.push(zr(u4));
        else if (a4) {
            const t9 = o4.join("");
            o4 = [], r4.push(0 === n5.length ? t9 : Xr(e9, n5)(t9)), n5.push({
                inverse: i5,
                styles: Hr(a4)
            });
        } else if (s4) {
            if (0 === n5.length) throw new Error("Found extraneous } in Chalk template literal");
            r4.push(Xr(e9, n5)(o4.join(""))), o4 = [], n5.pop();
        } else o4.push(l4);
    }), r4.push(o4.join("")), n5.length > 0) {
        const e10 = "Chalk template literal is missing ".concat(n5.length, " closing bracket").concat(1 === n5.length ? "" : "s", " (`}`)");
        throw new Error(e10);
    }
    return r4.join("");
}, Kr = je(function(e9) {
    const t7 = Vr.stdout, n5 = "win32" === Oe2.platform && !(Oe2.env.TERM || "").toLowerCase().startsWith("xterm"), r4 = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
    ], o4 = new Set([
        "gray"
    ]), u4 = Object.create(null);
    function i5(e10, n6) {
        n6 = n6 || {
        };
        const r5 = t7 ? t7.level : 0;
        e10.level = (void 0) === n6.level ? r5 : n6.level, e10.enabled = "enabled" in n6 ? n6.enabled : e10.level > 0;
    }
    function a4(e10) {
        if (!this || !(this instanceof a4) || this.template) {
            const t8 = {
            };
            return (i5(t8, e10), t8.template = function() {
                const e11 = [].slice.call(arguments);
                return p4.apply(null, [
                    t8.template
                ].concat(e11));
            }, Object.setPrototypeOf(t8, a4.prototype), Object.setPrototypeOf(t8.template, t8), t8.template.constructor = a4, t8.template);
        }
        i5(this, e10);
    }
    n5 && (Ir.blue.open = "\x1b[94m");
    for (const e10 of Object.keys(Ir))Ir[e10].closeRe = new RegExp(Sr(Ir[e10].close), "g"), u4[e10] = {
        get () {
            const t8 = Ir[e10];
            return l4.call(this, this._styles ? this._styles.concat(t8) : [
                t8
            ], this._empty, e10);
        }
    };
    u4.visible = {
        get () {
            return l4.call(this, this._styles || [], !0, "visible");
        }
    }, Ir.color.closeRe = new RegExp(Sr(Ir.color.close), "g");
    for (const e11 of Object.keys(Ir.color.ansi))o4.has(e11) || (u4[e11] = {
        get () {
            const t8 = this.level;
            return function() {
                const n6 = Ir.color[r4[t8]][e11].apply(null, arguments), o5 = {
                    open: n6,
                    close: Ir.color.close,
                    closeRe: Ir.color.closeRe
                };
                return l4.call(this, this._styles ? this._styles.concat(o5) : [
                    o5
                ], this._empty, e11);
            };
        }
    });
    Ir.bgColor.closeRe = new RegExp(Sr(Ir.bgColor.close), "g");
    for (const e12 of Object.keys(Ir.bgColor.ansi)){
        if (o4.has(e12)) continue;
        u4["bg" + e12[0].toUpperCase() + e12.slice(1)] = {
            get () {
                const t8 = this.level;
                return function() {
                    const n6 = Ir.bgColor[r4[t8]][e12].apply(null, arguments), o5 = {
                        open: n6,
                        close: Ir.bgColor.close,
                        closeRe: Ir.bgColor.closeRe
                    };
                    return l4.call(this, this._styles ? this._styles.concat(o5) : [
                        o5
                    ], this._empty, e12);
                };
            }
        };
    }
    const s4 = Object.defineProperties(()=>{
    }, u4);
    function l4(e13, t8, n6) {
        const r5 = function() {
            return c4.apply(r5, arguments);
        };
        r5._styles = e13, r5._empty = t8;
        const o5 = this;
        return (Object.defineProperty(r5, "level", {
            enumerable: !0,
            get: ()=>o5.level
            ,
            set (e) {
                o5.level = e;
            }
        }), Object.defineProperty(r5, "enabled", {
            enumerable: !0,
            get: ()=>o5.enabled
            ,
            set (e) {
                o5.enabled = e;
            }
        }), r5.hasGrey = this.hasGrey || "gray" === n6 || "grey" === n6, r5.__proto__ = s4, r5);
    }
    function c4() {
        const e13 = arguments, t8 = e13.length;
        let r5 = String(arguments[0]);
        if (0 === t8) return "";
        if (t8 > 1) for(let n6 = 1; n6 < t8; n6++)r5 += " " + arguments[n6];
        if (!this.enabled || this.level <= 0 || !r5) return this._empty ? "" : r5;
        const o5 = Ir.dim.open;
        n5 && this.hasGrey && (Ir.dim.open = "");
        for (const e14 of this._styles.slice().reverse())r5 = e14.open + r5.replace(e14.closeRe, e14.open) + e14.close, r5 = r5.replace(/\r?\n/g, "".concat(e14.close, "$&").concat(e14.open));
        return (Ir.dim.open = o5, r5);
    }
    function p4(e13, t8) {
        if (!Array.isArray(t8)) return [].slice.call(arguments, 1).join(" ");
        const n6 = [].slice.call(arguments, 2), r5 = [
            t8.raw[0]
        ];
        for(let e14 = 1; e14 < t8.length; e14++)r5.push(String(n6[e14 - 1]).replace(/[{}\\]/g, "\\$&")), r5.push(String(t8.raw[e14]));
        return Yr(e13, r5.join(""));
    }
    Object.defineProperties(a4.prototype, u4), e9.exports = a4(), e9.exports.supportsColor = t7, e9.exports.default = e9.exports;
}), Qr = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.commonDeprecatedHandler = (e10, t8, { descriptor: n5  })=>{
        const r4 = [
            "".concat(Kr.default.yellow("string" == typeof e10 ? n5.key(e10) : n5.pair(e10)), " is deprecated")
        ];
        return t8 && r4.push("we now treat it as ".concat(Kr.default.blue("string" == typeof t8 ? n5.key(t8) : n5.pair(t8)))), r4.join("; ") + ".";
    };
}), Zr = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(Qr, t7);
}), eo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.commonInvalidHandler = (e10, t8, n5)=>[
            "Invalid ".concat(Kr.default.red(n5.descriptor.key(e10)), " value."),
            "Expected ".concat(Kr.default.blue(n5.schemas[e10].expected(n5)), ","),
            "but received ".concat(Kr.default.red(n5.descriptor.value(t8)), ".")
        ].join(" ")
    ;
}), to = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(eo, t7);
}), no = [], ro = [], oo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.levenUnknownHandler = (e10, t8, { descriptor: n5 , logger: r4 , schemas: o4  })=>{
        const u4 = [
            "Ignored unknown option ".concat(Kr.default.yellow(n5.pair({
                key: e10,
                value: t8
            })), ".")
        ], i5 = Object.keys(o4).sort().find((t9)=>(function(e11, t10) {
                if (e11 === t10) return 0;
                var n6 = e11;
                e11.length > t10.length && (e11 = t10, t10 = n6);
                var r5 = e11.length, o5 = t10.length;
                if (0 === r5) return o5;
                if (0 === o5) return r5;
                for(; r5 > 0 && e11.charCodeAt(~-r5) === t10.charCodeAt(~-o5);)r5--, o5--;
                if (0 === r5) return o5;
                for(var u5, i5, a4, s4, l4 = 0; l4 < r5 && e11.charCodeAt(l4) === t10.charCodeAt(l4);)l4++;
                if (o5 -= l4, 0 == (r5 -= l4)) return o5;
                for(var c4 = 0, p4 = 0; c4 < r5;)ro[l4 + c4] = e11.charCodeAt(l4 + c4), no[c4] = ++c4;
                for(; p4 < o5;)for(u5 = t10.charCodeAt(l4 + p4), a4 = p4++, i5 = p4, c4 = 0; c4 < r5; c4++)s4 = u5 === ro[l4 + c4] ? a4 : a4 + 1, a4 = no[c4], i5 = no[c4] = a4 > i5 ? s4 > i5 ? i5 + 1 : s4 : s4 > a4 ? a4 + 1 : s4;
                return i5;
            })(e10, t9) < 3
        );
        i5 && u4.push("Did you mean ".concat(Kr.default.blue(n5.key(i5)), "?")), r4.warn(u4.join(" "));
    };
}), uo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(oo, t7);
}), io = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(Zr, t7), vr.__exportStar(to, t7), vr.__exportStar(uo, t7);
}), ao = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    const n5 = [
        "default",
        "expected",
        "validate",
        "deprecated",
        "forward",
        "redirect",
        "overlap",
        "preprocess",
        "postprocess"
    ];
    function r4(e10, t8) {
        const r5 = new e10(t8), i5 = Object.create(r5);
        for (const e11 of n5)e11 in t8 && (i5[e11] = u4(t8[e11], r5, o4.prototype[e11].length));
        return i5;
    }
    t7.createSchema = r4;
    class o4 {
        constructor(e10){
            this.name = e10.name;
        }
        static create(e) {
            return r4(this, e);
        }
        default(e) {
        }
        expected(e) {
            return "nothing";
        }
        validate(e, t) {
            return !1;
        }
        deprecated(e, t) {
            return !1;
        }
        forward(e, t) {
        }
        redirect(e, t) {
        }
        overlap(e, t, n) {
            return e;
        }
        preprocess(e, t) {
            return e;
        }
        postprocess(e, t) {
            return e;
        }
    }
    function u4(e11, t8, n6) {
        return "function" == typeof e11 ? (...r5)=>e11(...r5.slice(0, n6 - 1), t8, ...r5.slice(n6 - 1))
         : ()=>e11
        ;
    }
    t7.Schema = o4;
}), so = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        constructor(e10){
            super(e10), this._sourceName = e10.sourceName;
        }
        expected(e) {
            return e.schemas[this._sourceName].expected(e);
        }
        validate(e, t) {
            return t.schemas[this._sourceName].validate(e, t);
        }
        redirect(e, t) {
            return this._sourceName;
        }
    }
    t7.AliasSchema = n5;
}), lo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        expected() {
            return "anything";
        }
        validate() {
            return !0;
        }
    }
    t7.AnySchema = n5;
}), co = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        constructor(e10){
            var { valueSchema: t8 , name: n6 = t8.name  } = e10, r4 = vr.__rest(e10, [
                "valueSchema",
                "name"
            ]);
            super(Object.assign({
            }, r4, {
                name: n6
            })), this._valueSchema = t8;
        }
        expected(e) {
            return "an array of ".concat(this._valueSchema.expected(e));
        }
        validate(e, t) {
            if (!Array.isArray(e)) return !1;
            const n7 = [];
            for (const r5 of e){
                const e11 = t.normalizeValidateResult(this._valueSchema.validate(r5, t), r5);
                !0 !== e11 && n7.push(e11.value);
            }
            return 0 === n7.length || {
                value: n7
            };
        }
        deprecated(e, t) {
            const n7 = [];
            for (const r5 of e){
                const e11 = t.normalizeDeprecatedResult(this._valueSchema.deprecated(r5, t), r5);
                !1 !== e11 && n7.push(...e11.map(({ value: e12  })=>({
                        value: [
                            e12
                        ]
                    })
                ));
            }
            return n7;
        }
        forward(e, t) {
            const n7 = [];
            for (const o4 of e){
                const e11 = t.normalizeForwardResult(this._valueSchema.forward(o4, t), o4);
                n7.push(...e11.map(r5));
            }
            return n7;
        }
        redirect(e, t) {
            const n7 = [], o4 = [];
            for (const u4 of e){
                const e11 = t.normalizeRedirectResult(this._valueSchema.redirect(u4, t), u4);
                "remain" in e11 && n7.push(e11.remain), o4.push(...e11.redirect.map(r5));
            }
            return 0 === n7.length ? {
                redirect: o4
            } : {
                redirect: o4,
                remain: n7
            };
        }
        overlap(e, t) {
            return e.concat(t);
        }
    }
    function r5({ from: e11 , to: t9  }) {
        return {
            from: [
                e11
            ],
            to: t9
        };
    }
    t7.ArraySchema = n5;
}), po = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        expected() {
            return "true or false";
        }
        validate(e) {
            return "boolean" == typeof e;
        }
    }
    t7.BooleanSchema = n5;
}), fo = je(function(e9, t7) {
    function n5(e10, t8) {
        return "string" == typeof e10 || "key" in e10 ? {
            from: t8,
            to: e10
        } : "from" in e10 ? {
            from: e10.from,
            to: e10.to
        } : {
            from: t8,
            to: e10.to
        };
    }
    function r4(e10, t8) {
        return (void 0) === e10 ? [] : Array.isArray(e10) ? e10.map((e11)=>n5(e11, t8)
        ) : [
            n5(e10, t8)
        ];
    }
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.recordFromArray = function(e10, t8) {
        const n6 = Object.create(null);
        for (const r5 of e10){
            const e11 = r5[t8];
            if (n6[e11]) throw new Error("Duplicate ".concat(t8, " ").concat(JSON.stringify(e11)));
            n6[e11] = r5;
        }
        return n6;
    }, t7.mapFromArray = function(e10, t8) {
        const n6 = new Map;
        for (const r5 of e10){
            const e11 = r5[t8];
            if (n6.has(e11)) throw new Error("Duplicate ".concat(t8, " ").concat(JSON.stringify(e11)));
            n6.set(e11, r5);
        }
        return n6;
    }, t7.createAutoChecklist = function() {
        const e10 = Object.create(null);
        return (t8)=>{
            const n6 = JSON.stringify(t8);
            return !!e10[n6] || (e10[n6] = !0, !1);
        };
    }, t7.partition = function(e10, t8) {
        const n6 = [], r5 = [];
        for (const o4 of e10)t8(o4) ? n6.push(o4) : r5.push(o4);
        return [
            n6,
            r5
        ];
    }, t7.isInt = function(e10) {
        return e10 === Math.floor(e10);
    }, t7.comparePrimitive = function(e10, t8) {
        if (e10 === t8) return 0;
        const n6 = typeof e10, r5 = typeof t8, o4 = [
            "undefined",
            "object",
            "boolean",
            "number",
            "string"
        ];
        return n6 !== r5 ? o4.indexOf(n6) - o4.indexOf(r5) : "string" !== n6 ? Number(e10) - Number(t8) : e10.localeCompare(t8);
    }, t7.normalizeDefaultResult = function(e10) {
        return (void 0) === e10 ? {
        } : e10;
    }, t7.normalizeValidateResult = function(e10, t8) {
        return !0 === e10 || (!1 === e10 ? {
            value: t8
        } : e10);
    }, t7.normalizeDeprecatedResult = function(e10, t8, n6 = !1) {
        return !1 !== e10 && (!0 === e10 ? !!n6 || [
            {
                value: t8
            }
        ] : "value" in e10 ? [
            e10
        ] : 0 !== e10.length && e10);
    }, t7.normalizeTransferResult = n5, t7.normalizeForwardResult = r4, t7.normalizeRedirectResult = function(e10, t8) {
        const n6 = r4("object" == typeof e10 && "redirect" in e10 ? e10.redirect : e10, t8);
        return 0 === n6.length ? {
            remain: t8,
            redirect: n6
        } : "object" == typeof e10 && "remain" in e10 ? {
            remain: e10.remain,
            redirect: n6
        } : {
            redirect: n6
        };
    };
}), ho = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        constructor(e10){
            super(e10), this._choices = fo.mapFromArray(e10.choices.map((e11)=>e11 && "object" == typeof e11 ? e11 : {
                    value: e11
                }
            ), "value");
        }
        expected({ descriptor: e  }) {
            const t8 = Array.from(this._choices.keys()).map((e11)=>this._choices.get(e11)
            ).filter((e11)=>!e11.deprecated
            ).map((e11)=>e11.value
            ).sort(fo.comparePrimitive).map(e.value), n6 = t8.slice(0, -2), r4 = t8.slice(-2);
            return n6.concat(r4.join(" or ")).join(", ");
        }
        validate(e) {
            return this._choices.has(e);
        }
        deprecated(e) {
            const t8 = this._choices.get(e);
            return !(!t8 || !t8.deprecated) && {
                value: e
            };
        }
        forward(e) {
            const t8 = this._choices.get(e);
            return t8 ? t8.forward : void 0;
        }
        redirect(e) {
            const t8 = this._choices.get(e);
            return t8 ? t8.redirect : void 0;
        }
    }
    t7.ChoiceSchema = n5;
}), mo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        expected() {
            return "a number";
        }
        validate(e, t) {
            return "number" == typeof e;
        }
    }
    t7.NumberSchema = n5;
}), go = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends mo.NumberSchema {
        expected() {
            return "an integer";
        }
        validate(e, t) {
            return !0 === t.normalizeValidateResult(super.validate(e, t), e) && fo.isInt(e);
        }
    }
    t7.IntegerSchema = n5;
}), Do = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    });
    class n5 extends ao.Schema {
        expected() {
            return "a string";
        }
        validate(e) {
            return "string" == typeof e;
        }
    }
    t7.StringSchema = n5;
}), yo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(so, t7), vr.__exportStar(lo, t7), vr.__exportStar(co, t7), vr.__exportStar(po, t7), vr.__exportStar(ho, t7), vr.__exportStar(go, t7), vr.__exportStar(mo, t7), vr.__exportStar(Do, t7);
}), Eo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.defaultDescriptor = Ar.apiDescriptor, t7.defaultUnknownHandler = oo.levenUnknownHandler, t7.defaultInvalidHandler = to.commonInvalidHandler, t7.defaultDeprecatedHandler = Qr.commonDeprecatedHandler;
}), Co = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), t7.normalize = (e10, t8, r4)=>new n5(t8, r4).normalize(e10)
    ;
    class n5 {
        constructor(e10, t8){
            const { logger: n6 = console , descriptor: r4 = Eo.defaultDescriptor , unknown: o4 = Eo.defaultUnknownHandler , invalid: u4 = Eo.defaultInvalidHandler , deprecated: i5 = Eo.defaultDeprecatedHandler  } = t8 || {
            };
            this._utils = {
                descriptor: r4,
                logger: n6 || {
                    warn: ()=>{
                    }
                },
                schemas: fo.recordFromArray(e10, "name"),
                normalizeDefaultResult: fo.normalizeDefaultResult,
                normalizeDeprecatedResult: fo.normalizeDeprecatedResult,
                normalizeForwardResult: fo.normalizeForwardResult,
                normalizeRedirectResult: fo.normalizeRedirectResult,
                normalizeValidateResult: fo.normalizeValidateResult
            }, this._unknownHandler = o4, this._invalidHandler = u4, this._deprecatedHandler = i5, this.cleanHistory();
        }
        cleanHistory() {
            this._hasDeprecationWarned = fo.createAutoChecklist();
        }
        normalize(e) {
            const t9 = {
            }, n7 = [
                e
            ], r5 = ()=>{
                for(; 0 !== n7.length;){
                    const e11 = n7.shift(), r6 = this._applyNormalization(e11, t9);
                    n7.push(...r6);
                }
            };
            r5();
            for (const e11 of Object.keys(this._utils.schemas)){
                const r6 = this._utils.schemas[e11];
                if (!(e11 in t9)) {
                    const t10 = fo.normalizeDefaultResult(r6.default(this._utils));
                    "value" in t10 && n7.push({
                        [e11]: t10.value
                    });
                }
            }
            r5();
            for (const e12 of Object.keys(this._utils.schemas)){
                const n8 = this._utils.schemas[e12];
                e12 in t9 && (t9[e12] = n8.postprocess(t9[e12], this._utils));
            }
            return t9;
        }
        _applyNormalization(e, t) {
            const n7 = [], [r5, o5] = fo.partition(Object.keys(e), (e11)=>e11 in this._utils.schemas
            );
            for (const o6 of r5){
                const r6 = this._utils.schemas[o6], u5 = r6.preprocess(e[o6], this._utils), i6 = fo.normalizeValidateResult(r6.validate(u5, this._utils), u5);
                if (!0 !== i6) {
                    const { value: e11  } = i6, t9 = this._invalidHandler(o6, e11, this._utils);
                    throw "string" == typeof t9 ? new Error(t9) : t9;
                }
                const a4 = ({ from: e11 , to: t9  })=>{
                    n7.push("string" == typeof t9 ? {
                        [t9]: e11
                    } : {
                        [t9.key]: t9.value
                    });
                }, s4 = ({ value: e11 , redirectTo: t9  })=>{
                    const n8 = fo.normalizeDeprecatedResult(r6.deprecated(e11, this._utils), u5, !0);
                    if (!1 !== n8) {
                        if (!0 === n8) this._hasDeprecationWarned(o6) || this._utils.logger.warn(this._deprecatedHandler(o6, t9, this._utils));
                        else for (const { value: e12  } of n8){
                            const n9 = {
                                key: o6,
                                value: e12
                            };
                            if (!this._hasDeprecationWarned(n9)) {
                                const r7 = "string" == typeof t9 ? {
                                    key: t9,
                                    value: e12
                                } : t9;
                                this._utils.logger.warn(this._deprecatedHandler(n9, r7, this._utils));
                            }
                        }
                    }
                };
                fo.normalizeForwardResult(r6.forward(u5, this._utils), u5).forEach(a4);
                const l4 = fo.normalizeRedirectResult(r6.redirect(u5, this._utils), u5);
                if (l4.redirect.forEach(a4), "remain" in l4) {
                    const e11 = l4.remain;
                    t[o6] = o6 in t ? r6.overlap(t[o6], e11, this._utils) : e11, s4({
                        value: e11
                    });
                }
                for (const { from: e11 , to: t9  } of l4.redirect)s4({
                    value: e11,
                    redirectTo: t9
                });
            }
            for (const r6 of o5){
                const o7 = e[r6], u5 = this._unknownHandler(r6, o7, this._utils);
                if (u5) for (const e11 of Object.keys(u5)){
                    const r7 = {
                        [e11]: u5[e11]
                    };
                    e11 in this._utils.schemas ? n7.push(r7) : Object.assign(t, r7);
                }
            }
            return n7;
        }
    }
    t7.Normalizer = n5;
}), bo = je(function(e9, t7) {
    Object.defineProperty(t7, "__esModule", {
        value: !0
    }), vr.__exportStar(Fr, t7), vr.__exportStar(io, t7), vr.__exportStar(yo, t7), vr.__exportStar(Co, t7), vr.__exportStar(ao, t7);
});
const { env: Vo  } = Oe2;
function Wo(e9, t7) {
    if (0 === $o) return 0;
    if (_o("color=16m") || _o("color=full") || _o("color=truecolor")) return 3;
    if (_o("color=256")) return 2;
    if (e9 && !t7 && (void 0) === $o) return 0;
    const n5 = $o || 0;
    if ("dumb" === Vo.TERM) return n5;
    if ("win32" === Oe2.platform) {
        const e10 = Mr.release().split(".");
        return Number(e10[0]) >= 10 && Number(e10[2]) >= 10586 ? Number(e10[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Vo) return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI"
    ].some((e10)=>e10 in Vo
    ) || "codeship" === Vo.CI_NAME ? 1 : n5;
    if ("TEAMCITY_VERSION" in Vo) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Vo.TEAMCITY_VERSION) ? 1 : 0;
    if ("GITHUB_ACTIONS" in Vo) return 1;
    if ("truecolor" === Vo.COLORTERM) return 3;
    if ("TERM_PROGRAM" in Vo) {
        const e10 = parseInt((Vo.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch(Vo.TERM_PROGRAM){
            case "iTerm.app":
                return e10 >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    return /-256(color)?$/i.test(Vo.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Vo.TERM) || "COLORTERM" in Vo ? 1 : n5;
}
_o("no-color") || _o("no-colors") || _o("color=false") || _o("color=never") ? $o = 0 : (_o("color") || _o("colors") || _o("color=true") || _o("color=always")) && ($o = 1), "FORCE_COLOR" in Vo && ($o = "true" === Vo.FORCE_COLOR ? 1 : "false" === Vo.FORCE_COLOR ? 0 : 0 === Vo.FORCE_COLOR.length ? 1 : Math.min(parseInt(Vo.FORCE_COLOR, 10), 3));
var Uo = {
    supportsColor: function(e9) {
        return qo(Wo(e9, e9 && e9.isTTY));
    },
    stdout: qo(Wo(!0, Ro.isatty(1))),
    stderr: qo(Wo(!0, Ro.isatty(2)))
};
const { stdout: nu , stderr: ru  } = Uo, { stringReplaceAll: ou , stringEncaseCRLFWithFirstIndex: uu  } = Jo, { isArray: iu  } = Array, au = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
], su = Object.create(null);
const cu = (e9)=>{
    const t7 = {
    };
    return ((e10, t8 = {
    })=>{
        if (t8.level && !(Number.isInteger(t8.level) && t8.level >= 0 && t8.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
        const n5 = nu ? nu.level : 0;
        e10.level = (void 0) === t8.level ? n5 : t8.level;
    })(t7, e9), t7.template = (...e10)=>yu(t7.template, ...e10)
    , Object.setPrototypeOf(t7, pu.prototype), Object.setPrototypeOf(t7.template, t7), t7.template.constructor = ()=>{
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    }, t7.template.Instance = lu, t7.template;
};
function pu(e9) {
    return cu(e9);
}
for (const [e9, t7] of Object.entries(Mo))su[e9] = {
    get () {
        const n5 = mu(this, hu(t7.open, t7.close, this._styler), this._isEmpty);
        return Object.defineProperty(this, e9, {
            value: n5
        }), n5;
    }
};
su.visible = {
    get () {
        const e10 = mu(this, this._styler, !0);
        return Object.defineProperty(this, "visible", {
            value: e10
        }), e10;
    }
};
for (const e10 of du)su[e10] = {
    get () {
        const { level: t8  } = this;
        return function(...n5) {
            const r4 = hu(Mo.color[au[t8]][e10](...n5), Mo.color.close, this._styler);
            return mu(this, r4, this._isEmpty);
        };
    }
};
for (const e11 of du){
    su["bg" + e11[0].toUpperCase() + e11.slice(1)] = {
        get () {
            const { level: t8  } = this;
            return function(...n5) {
                const r4 = hu(Mo.bgColor[au[t8]][e11](...n5), Mo.bgColor.close, this._styler);
                return mu(this, r4, this._isEmpty);
            };
        }
    };
}
const fu = Object.defineProperties(()=>{
}, Object.assign({
}, su, {
    level: {
        enumerable: !0,
        get () {
            return this._generator.level;
        },
        set (e) {
            this._generator.level = e;
        }
    }
})), hu = (e12, t8, n5)=>{
    let r4, o4;
    return (void 0) === n5 ? (r4 = e12, o4 = t8) : (r4 = n5.openAll + e12, o4 = t8 + n5.closeAll), {
        open: e12,
        close: t8,
        openAll: r4,
        closeAll: o4,
        parent: n5
    };
}, mu = (e12, t8, n5)=>{
    const r4 = (...e13)=>iu(e13[0]) && iu(e13[0].raw) ? gu(r4, yu(r4, ...e13)) : gu(r4, 1 === e13.length ? "" + e13[0] : e13.join(" "))
    ;
    return Object.setPrototypeOf(r4, fu), r4._generator = e12, r4._styler = t8, r4._isEmpty = n5, r4;
}, gu = (e12, t8)=>{
    if (e12.level <= 0 || !t8) return e12._isEmpty ? "" : t8;
    let n5 = e12._styler;
    if ((void 0) === n5) return t8;
    const { openAll: r4 , closeAll: o4  } = n5;
    if (-1 !== t8.indexOf("\x1b")) for(; (void 0) !== n5;)t8 = ou(t8, n5.close, n5.open), n5 = n5.parent;
    const u4 = t8.indexOf("\n");
    return -1 !== u4 && (t8 = uu(t8, o4, r4, u4)), r4 + t8 + o4;
};
const yu = (e12, ...t8)=>{
    const [n5] = t8;
    if (!iu(n5) || !iu(n5.raw)) return t8.join(" ");
    const r4 = t8.slice(1), o4 = [
        n5.raw[0]
    ];
    for(let e13 = 1; e13 < n5.length; e13++)o4.push(String(r4[e13 - 1]).replace(/[{}\\]/g, "\\$&"), String(n5.raw[e13]));
    return (void 0) === Du && (Du = tu), Du(e12, o4.join(""));
};
Object.defineProperties(pu.prototype, su);
const Eu = pu();
Eu.supportsColor = nu, Eu.stderr = pu({
    level: ru ? ru.level : 0
}), Eu.stderr.supportsColor = ru;
var Cu = Eu;
const Ju = {
    key: (e12)=>1 === e12.length ? "-".concat(e12) : "--".concat(e12)
    ,
    value: (e12)=>bo.apiDescriptor.value(e12)
    ,
    pair: ({ key: e12 , value: t8  })=>!1 === t8 ? "--no-".concat(e12) : !0 === t8 ? Ju.key(e12) : "" === t8 ? "".concat(Ju.key(e12), " without an argument") : "".concat(Ju.key(e12), "=").concat(t8)
};
class zu extends bo.ChoiceSchema {
    constructor({ name: e12 , flags: t8  }){
        super({
            name: e12,
            choices: t8
        }), this._flags = t8.slice().sort();
    }
    preprocess(e, t) {
        if ("string" == typeof e && 0 !== e.length && !this._flags.includes(e)) {
            const n5 = this._flags.find((t9)=>xo(t9, e) < 3
            );
            if (n5) return t.logger.warn([
                "Unknown flag ".concat(Cu.yellow(t.descriptor.value(e)), ","),
                "did you mean ".concat(Cu.blue(t.descriptor.value(n5)), "?")
            ].join(" ")), n5;
        }
        return e;
    }
    expected() {
        return "a flag";
    }
}
function Hu(t9, n5, { logger: r4 , isCLI: o4 = !1 , passThrough: u4 = !1  } = {
}) {
    const i5 = u4 ? Array.isArray(u4) ? (e13, t10)=>u4.includes(e13) ? {
            [e13]: t10
        } : void 0
     : (e13, t10)=>({
            [e13]: t10
        })
     : (t10, n6, r5)=>{
        const o5 = e2(r5.schemas, [
            "_"
        ]);
        return bo.levenUnknownHandler(t10, n6, Object.assign({
        }, r5, {
            schemas: o5
        }));
    }, a4 = o4 ? Ju : bo.apiDescriptor, s4 = function(e13, { isCLI: t10  }) {
        const n6 = [];
        t10 && n6.push(bo.AnySchema.create({
            name: "_"
        }));
        for (const r5 of e13)n6.push(Xu(r5, {
            isCLI: t10,
            optionInfos: e13
        })), r5.alias && t10 && n6.push(bo.AliasSchema.create({
            name: r5.alias,
            sourceName: r5.name
        }));
        return n6;
    }(n5, {
        isCLI: o4
    }), l4 = new bo.Normalizer(s4, {
        logger: r4,
        unknown: i5,
        descriptor: a4
    }), c4 = !1 !== r4;
    c4 && Gu && (l4._hasDeprecationWarned = Gu);
    const p4 = l4.normalize(t9);
    return c4 && (Gu = l4._hasDeprecationWarned), p4;
}
function Xu(e13, { isCLI: t9 , optionInfos: n5  }) {
    let r4;
    const o4 = {
        name: e13.name
    }, u4 = {
    };
    switch(e13.type){
        case "int":
            r4 = bo.IntegerSchema, t9 && (o4.preprocess = (e14)=>Number(e14)
            );
            break;
        case "string":
            r4 = bo.StringSchema;
            break;
        case "choice":
            r4 = bo.ChoiceSchema, o4.choices = e13.choices.map((t10)=>"object" == typeof t10 && t10.redirect ? Object.assign({
                }, t10, {
                    redirect: {
                        to: {
                            key: e13.name,
                            value: t10.redirect
                        }
                    }
                }) : t10
            );
            break;
        case "boolean":
            r4 = bo.BooleanSchema;
            break;
        case "flag":
            r4 = zu, o4.flags = Uu(n5.map((e14)=>[
                    e14.alias,
                    e14.description && e14.name,
                    e14.oppositeDescription && "no-".concat(e14.name)
                ].filter(Boolean)
            ));
            break;
        case "path":
            r4 = bo.StringSchema;
            break;
        default:
            throw new Error("Unexpected type ".concat(e13.type));
    }
    if (e13.exception ? o4.validate = (t10, n6, r5)=>e13.exception(t10) || n6.validate(t10, r5)
     : o4.validate = (e14, t10, n6)=>(void 0) === e14 || t10.validate(e14, n6)
    , e13.redirect && (u4.redirect = (t10)=>t10 ? {
            to: {
                key: e13.redirect.option,
                value: e13.redirect.value
            }
        } : void 0
    ), e13.deprecated && (u4.deprecated = !0), t9 && !e13.array) {
        const e14 = o4.preprocess || ((e15)=>e15
        );
        o4.preprocess = (t10, n6, r5)=>n6.preprocess(e14(Array.isArray(t10) ? t10[t10.length - 1] : t10), r5)
        ;
    }
    return e13.array ? bo.ArraySchema.create(Object.assign({
    }, t9 ? {
        preprocess: (e14)=>[].concat(e14)
    } : {
    }, u4, {
        valueSchema: r4.create(o4)
    })) : r4.create(Object.assign({
    }, o4, u4));
}
var Yu = {
    normalizeApiOptions: function(e13, t9, n5) {
        return Hu(e13, t9, n5);
    },
    normalizeCliOptions: function(e13, t9, n5) {
        return Hu(e13, t9, Object.assign({
            isCLI: !0
        }, n5));
    }
};
const mi = Oe2.env;
function Di(e13) {
    return (function(e14) {
        return 0 !== e14 && {
            level: e14,
            hasBasic: !0,
            has256: e14 >= 2,
            has16m: e14 >= 3
        };
    })(function(e14) {
        if (!1 === gi) return 0;
        if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor")) return 3;
        if (Lr("color=256")) return 2;
        if (e14 && !e14.isTTY && !0 !== gi) return 0;
        const t9 = gi ? 1 : 0;
        if ("win32" === Oe2.platform) {
            const e15 = Mr.release().split(".");
            return Number(Oe2.versions.node.split(".")[0]) >= 8 && Number(e15[0]) >= 10 && Number(e15[2]) >= 10586 ? Number(e15[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in mi) return [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI"
        ].some((e15)=>e15 in mi
        ) || "codeship" === mi.CI_NAME ? 1 : t9;
        if ("TEAMCITY_VERSION" in mi) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(mi.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === mi.COLORTERM) return 3;
        if ("TERM_PROGRAM" in mi) {
            const e15 = parseInt((mi.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch(mi.TERM_PROGRAM){
                case "iTerm.app":
                    return e15 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test(mi.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(mi.TERM) || "COLORTERM" in mi ? 1 : (mi.TERM, t9);
    }(e13));
}
Lr("no-color") || Lr("no-colors") || Lr("color=false") ? gi = !1 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && (gi = !0), "FORCE_COLOR" in mi && (gi = 0 === mi.FORCE_COLOR.length || 0 !== parseInt(mi.FORCE_COLOR, 10));
var yi = {
    supportsColor: Di,
    stdout: Di(Oe2.stdout),
    stderr: Di(Oe2.stderr)
};
var Ti = (e13, t9)=>{
    const n5 = [], r4 = [];
    let o4 = [];
    if (t9.replace(Ei, (t10, u4, i5, a4, s4, l4)=>{
        if (u4) o4.push(Fi(u4));
        else if (a4) {
            const t11 = o4.join("");
            o4 = [], r4.push(0 === n5.length ? t11 : wi(e13, n5)(t11)), n5.push({
                inverse: i5,
                styles: Si(a4)
            });
        } else if (s4) {
            if (0 === n5.length) throw new Error("Found extraneous } in Chalk template literal");
            r4.push(wi(e13, n5)(o4.join(""))), o4 = [], n5.pop();
        } else o4.push(l4);
    }), r4.push(o4.join("")), n5.length > 0) {
        const e14 = "Chalk template literal is missing ".concat(n5.length, " closing bracket").concat(1 === n5.length ? "" : "s", " (`}`)");
        throw new Error(e14);
    }
    return r4.join("");
}, Bi = je(function(e13) {
    const t9 = yi.stdout, n5 = "win32" === Oe2.platform && !(Oe2.env.TERM || "").toLowerCase().startsWith("xterm"), r4 = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
    ], o4 = new Set([
        "gray"
    ]), u4 = Object.create(null);
    function i5(e14, n6) {
        n6 = n6 || {
        };
        const r5 = t9 ? t9.level : 0;
        e14.level = (void 0) === n6.level ? r5 : n6.level, e14.enabled = "enabled" in n6 ? n6.enabled : e14.level > 0;
    }
    function a4(e14) {
        if (!this || !(this instanceof a4) || this.template) {
            const t10 = {
            };
            return (i5(t10, e14), t10.template = function() {
                const e15 = [].slice.call(arguments);
                return p4.apply(null, [
                    t10.template
                ].concat(e15));
            }, Object.setPrototypeOf(t10, a4.prototype), Object.setPrototypeOf(t10.template, t10), t10.template.constructor = a4, t10.template);
        }
        i5(this, e14);
    }
    n5 && (hi.blue.open = "\x1b[94m");
    for (const e14 of Object.keys(hi))hi[e14].closeRe = new RegExp(ii(hi[e14].close), "g"), u4[e14] = {
        get () {
            const t10 = hi[e14];
            return l4.call(this, this._styles ? this._styles.concat(t10) : [
                t10
            ], this._empty, e14);
        }
    };
    u4.visible = {
        get () {
            return l4.call(this, this._styles || [], !0, "visible");
        }
    }, hi.color.closeRe = new RegExp(ii(hi.color.close), "g");
    for (const e15 of Object.keys(hi.color.ansi))o4.has(e15) || (u4[e15] = {
        get () {
            const t10 = this.level;
            return function() {
                const n6 = hi.color[r4[t10]][e15].apply(null, arguments), o5 = {
                    open: n6,
                    close: hi.color.close,
                    closeRe: hi.color.closeRe
                };
                return l4.call(this, this._styles ? this._styles.concat(o5) : [
                    o5
                ], this._empty, e15);
            };
        }
    });
    hi.bgColor.closeRe = new RegExp(ii(hi.bgColor.close), "g");
    for (const e16 of Object.keys(hi.bgColor.ansi)){
        if (o4.has(e16)) continue;
        u4["bg" + e16[0].toUpperCase() + e16.slice(1)] = {
            get () {
                const t10 = this.level;
                return function() {
                    const n6 = hi.bgColor[r4[t10]][e16].apply(null, arguments), o5 = {
                        open: n6,
                        close: hi.bgColor.close,
                        closeRe: hi.bgColor.closeRe
                    };
                    return l4.call(this, this._styles ? this._styles.concat(o5) : [
                        o5
                    ], this._empty, e16);
                };
            }
        };
    }
    const s4 = Object.defineProperties(()=>{
    }, u4);
    function l4(e17, t10, n6) {
        const r5 = function() {
            return c4.apply(r5, arguments);
        };
        r5._styles = e17, r5._empty = t10;
        const o5 = this;
        return (Object.defineProperty(r5, "level", {
            enumerable: !0,
            get: ()=>o5.level
            ,
            set (e) {
                o5.level = e;
            }
        }), Object.defineProperty(r5, "enabled", {
            enumerable: !0,
            get: ()=>o5.enabled
            ,
            set (e) {
                o5.enabled = e;
            }
        }), r5.hasGrey = this.hasGrey || "gray" === n6 || "grey" === n6, r5.__proto__ = s4, r5);
    }
    function c4() {
        const e17 = arguments, t10 = e17.length;
        let r5 = String(arguments[0]);
        if (0 === t10) return "";
        if (t10 > 1) for(let n6 = 1; n6 < t10; n6++)r5 += " " + arguments[n6];
        if (!this.enabled || this.level <= 0 || !r5) return this._empty ? "" : r5;
        const o5 = hi.dim.open;
        n5 && this.hasGrey && (hi.dim.open = "");
        for (const e18 of this._styles.slice().reverse())r5 = e18.open + r5.replace(e18.closeRe, e18.open) + e18.close, r5 = r5.replace(/\r?\n/g, "".concat(e18.close, "$&").concat(e18.open));
        return (hi.dim.open = o5, r5);
    }
    function p4(e17, t10) {
        if (!Array.isArray(t10)) return [].slice.call(arguments, 1).join(" ");
        const n6 = [].slice.call(arguments, 2), r5 = [
            t10.raw[0]
        ];
        for(let e18 = 1; e18 < t10.length; e18++)r5.push(String(n6[e18 - 1]).replace(/[{}\\]/g, "\\$&")), r5.push(String(t10.raw[e18]));
        return Ti(e17, r5.join(""));
    }
    Object.defineProperties(a4.prototype, u4), e13.exports = a4(), e13.exports.supportsColor = t9, e13.exports.default = e13.exports;
}), Ni = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    }), t9.shouldHighlight = l4, t9.getChalk = c4, t9.default = function(e14, t10 = {
    }) {
        if (l4(t10)) {
            const n5 = c4(t10);
            return (function(e15, t11) {
                return t11.replace(r4.default, function(...t12) {
                    const n6 = function(e16) {
                        const [t13, n7] = e16.slice(-2), o4 = r4.matchToToken(e16);
                        if ("name" === o4.type) {
                            if (oi.isKeyword(o4.value) || oi.isReservedWord(o4.value)) return "keyword";
                            if (a4.test(o4.value) && ("<" === n7[t13 - 1] || "</" == n7.substr(t13 - 2, 2))) return "jsx_tag";
                            if (o4.value[0] !== o4.value[0].toLowerCase()) return "capitalized";
                        }
                        if ("punctuator" === o4.type && s4.test(o4.value)) return "bracket";
                        if ("invalid" === o4.type && ("@" === o4.value || "#" === o4.value)) return "punctuator";
                        return o4.type;
                    }(t12), o4 = e15[n6];
                    return o4 ? t12[0].split(i5).map((e16)=>o4(e16)
                    ).join("\n") : t12[0];
                });
            })(function(e15) {
                return {
                    keyword: e15.cyan,
                    capitalized: e15.yellow,
                    jsx_tag: e15.yellow,
                    punctuator: e15.yellow,
                    number: e15.magenta,
                    string: e15.green,
                    regex: e15.magenta,
                    comment: e15.grey,
                    invalid: e15.white.bgRed.bold
                };
            }(n5), e14);
        }
        return e14;
    };
    var n5, r4 = function(e14) {
        if (e14 && e14.__esModule) return e14;
        if (null === e14 || "object" != typeof e14 && "function" != typeof e14) return {
            default: e14
        };
        var t10 = u4();
        if (t10 && t10.has(e14)) return t10.get(e14);
        var n6 = {
        }, r4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var o4 in e14)if (Object.prototype.hasOwnProperty.call(e14, o4)) {
            var i5 = r4 ? Object.getOwnPropertyDescriptor(e14, o4) : null;
            i5 && (i5.get || i5.set) ? Object.defineProperty(n6, o4, i5) : n6[o4] = e14[o4];
        }
        n6.default = e14, t10 && t10.set(e14, n6);
        return n6;
    }(ti), o4 = (n5 = Bi) && n5.__esModule ? n5 : {
        default: n5
    };
    function u4() {
        if ("function" != typeof WeakMap) return null;
        var e14 = new WeakMap;
        return (u4 = function() {
            return e14;
        }, e14);
    }
    const i5 = /\r\n|[\n\r\u2028\u2029]/, a4 = /^[a-z][\w-]*$/i, s4 = /^[()[\]{}]$/;
    function l4(e14) {
        return o4.default.supportsColor || e14.forceColor;
    }
    function c4(e14) {
        let t10 = o4.default;
        return (e14.forceColor && (t10 = new o4.default.constructor({
            enabled: !0,
            level: 1
        })), t10);
    }
}), ki = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    }), t9.codeFrameColumns = i5, t9.default = function(e14, t10, n5, r4 = {
    }) {
        if (!o4) {
            o4 = !0;
            const e15 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (Oe2.emitWarning) Oe2.emitWarning(e15, "DeprecationWarning");
            else {
                new Error(e15).name = "DeprecationWarning", console.warn(new Error(e15));
            }
        }
        n5 = Math.max(n5, 0);
        return i5(e14, {
            start: {
                column: n5,
                line: t10
            }
        }, r4);
    };
    var n5 = function(e14) {
        if (e14 && e14.__esModule) return e14;
        if (null === e14 || "object" != typeof e14 && "function" != typeof e14) return {
            default: e14
        };
        var t10 = r4();
        if (t10 && t10.has(e14)) return t10.get(e14);
        var n5 = {
        }, o4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var u4 in e14)if (Object.prototype.hasOwnProperty.call(e14, u4)) {
            var i5 = o4 ? Object.getOwnPropertyDescriptor(e14, u4) : null;
            i5 && (i5.get || i5.set) ? Object.defineProperty(n5, u4, i5) : n5[u4] = e14[u4];
        }
        n5.default = e14, t10 && t10.set(e14, n5);
        return n5;
    }(Ni);
    function r4() {
        if ("function" != typeof WeakMap) return null;
        var e14 = new WeakMap;
        return (r4 = function() {
            return e14;
        }, e14);
    }
    let o4 = !1;
    const u4 = /\r\n|[\n\r\u2028\u2029]/;
    function i5(e14, t10, r5 = {
    }) {
        const o5 = (r5.highlightCode || r5.forceColor) && n5.shouldHighlight(r5), i6 = n5.getChalk(r5), a4 = function(e15) {
            return {
                gutter: e15.grey,
                marker: e15.red.bold,
                message: e15.red.bold
            };
        }(i6), s4 = (e15, t11)=>o5 ? e15(t11) : t11
        , l4 = e14.split(u4), { start: c4 , end: p4 , markerLines: d4  } = function(e15, t11, n6) {
            const r6 = Object.assign({
                column: 0,
                line: -1
            }, e15.start), o6 = Object.assign({
            }, r6, e15.end), { linesAbove: u5 = 2 , linesBelow: i7 = 3  } = n6 || {
            }, a5 = r6.line, s5 = r6.column, l5 = o6.line, c5 = o6.column;
            let p5 = Math.max(a5 - (u5 + 1), 0), d5 = Math.min(t11.length, l5 + i7);
            -1 === a5 && (p5 = 0), -1 === l5 && (d5 = t11.length);
            const f4 = l5 - a5, h4 = {
            };
            if (f4) for(let e16 = 0; e16 <= f4; e16++){
                const n7 = e16 + a5;
                if (s5) {
                    if (0 === e16) {
                        const e17 = t11[n7 - 1].length;
                        h4[n7] = [
                            s5,
                            e17 - s5 + 1
                        ];
                    } else if (e16 === f4) h4[n7] = [
                        0,
                        c5
                    ];
                    else {
                        const r7 = t11[n7 - e16].length;
                        h4[n7] = [
                            0,
                            r7
                        ];
                    }
                } else h4[n7] = !0;
            }
            else h4[a5] = s5 === c5 ? !s5 || [
                s5,
                0
            ] : [
                s5,
                c5 - s5
            ];
            return {
                start: p5,
                end: d5,
                markerLines: h4
            };
        }(t10, l4, r5), f4 = t10.start && "number" == typeof t10.start.column, h4 = String(p4).length;
        let m4 = (o5 ? n5.default(e14, r5) : e14).split(u4).slice(c4, p4).map((e15, t11)=>{
            const n6 = c4 + 1 + t11, o6 = " ".concat(n6).slice(-h4), u5 = " ".concat(o6, " | "), i7 = d4[n6], l5 = !d4[n6 + 1];
            if (i7) {
                let t12 = "";
                if (Array.isArray(i7)) {
                    const n7 = e15.slice(0, Math.max(i7[0] - 1, 0)).replace(/[^\t]/g, " "), o7 = i7[1] || 1;
                    t12 = [
                        "\n ",
                        s4(a4.gutter, u5.replace(/\d/g, " ")),
                        n7,
                        s4(a4.marker, "^").repeat(o7)
                    ].join(""), l5 && r5.message && (t12 += " " + s4(a4.message, r5.message));
                }
                return [
                    s4(a4.marker, ">"),
                    s4(a4.gutter, u5),
                    e15,
                    t12
                ].join("");
            }
            return " ".concat(s4(a4.gutter, u5)).concat(e15);
        }).join("\n");
        return (r5.message && !f4 && (m4 = "".concat(" ".repeat(h4 + 1)).concat(r5.message, "\n").concat(m4)), o5 ? i6.reset(m4) : m4);
    }
}), Pi = _e(fn1);
var Vi = {
    parse: function(e13, t9) {
        const n5 = _i(t9), r4 = Object.keys(n5).reduce((e14, t10)=>Object.defineProperty(e14, t10, {
                enumerable: !0,
                get: ()=>n5[t10].parse
            })
        , {
        }), o4 = Ri(t9, n5);
        try {
            return (o4.preprocess && (e13 = o4.preprocess(e13, t9)), {
                text: e13,
                ast: o4.parse(e13, r4, t9)
            });
        } catch (t) {
            const { loc: n6  } = t;
            if (n6) {
                const { codeFrameColumns: r5  } = ki;
                throw (t.codeFrame = r5(e13, n6, {
                    highlightCode: !0
                }), t.message += "\n" + t.codeFrame, t);
            }
            throw t.stack;
        }
    },
    resolveParser: Ri
};
const { getSupportInfo: qi  } = pt1, { resolveParser: Wi  } = Vi, Ui = {
    astFormat: "estree",
    printer: {
    },
    originalText: void 0,
    locStart: null,
    locEnd: null
};
function Ji(e13, t9) {
    const n5 = Pi.basename(e13).toLowerCase(), r4 = qi({
        plugins: t9
    }).languages.filter((e14)=>null !== e14.since
    );
    let o4 = r4.find((e14)=>e14.extensions && e14.extensions.some((e15)=>n5.endsWith(e15)
        ) || e14.filenames && e14.filenames.some((e15)=>e15.toLowerCase() === n5
        )
    );
    if (!o4 && !n5.includes(".")) {
        const t10 = function(e14) {
            if ("string" != typeof e14) return "";
            let t11;
            try {
                t11 = cr.openSync(e14, "r");
            } catch (e) {
                return "";
            }
            try {
                const e15 = new pr(t11).next().toString("utf8"), n6 = e15.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
                if (n6) return n6[1];
                const r5 = e15.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
                return r5 ? r5[1] : "";
            } catch (e) {
                return "";
            } finally{
                try {
                    cr.closeSync(t11);
                } catch (e) {
                }
            }
        }(e13);
        o4 = r4.find((e14)=>e14.interpreters && e14.interpreters.includes(t10)
        );
    }
    return o4 && o4.parsers[0];
}
var zi = {
    normalize: function(e13, t9) {
        t9 = t9 || {
        };
        const n5 = Object.assign({
        }, e13), r4 = qi({
            plugins: e13.plugins,
            showUnreleased: !0,
            showDeprecated: !0
        }).options, o4 = Object.assign({
        }, Ui, dr(r4.filter((e14)=>(void 0) !== e14.default
        ).map((e14)=>[
                e14.name,
                e14.default
            ]
        )));
        if (!n5.parser) {
            if (n5.filepath) {
                if ((n5.parser = Ji(n5.filepath, n5.plugins), !n5.parser)) throw new $i("No parser could be inferred for file: ".concat(n5.filepath));
            } else {
                (t9.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n5.parser = "babel";
            }
        }
        const u4 = Wi(Yu.normalizeApiOptions(n5, [
            r4.find((e14)=>"parser" === e14.name
            )
        ], {
            passThrough: !0,
            logger: !1
        }));
        n5.astFormat = u4.astFormat, n5.locEnd = u4.locEnd, n5.locStart = u4.locStart;
        const i5 = function(e14) {
            const { astFormat: t10  } = e14;
            if (!t10) throw new Error("getPlugin() requires astFormat to be set");
            const n6 = e14.plugins.find((e15)=>e15.printers && e15.printers[t10]
            );
            if (!n6) throw new Error("Couldn't find plugin for AST format \"".concat(t10, '"'));
            return n6;
        }(n5);
        n5.printer = i5.printers[n5.astFormat];
        const a4 = r4.filter((e14)=>e14.pluginDefaults && (void 0) !== e14.pluginDefaults[i5.name]
        ).reduce((e14, t10)=>Object.assign(e14, {
                [t10.name]: t10.pluginDefaults[i5.name]
            })
        , {
        }), s4 = Object.assign({
        }, o4, a4);
        return (Object.keys(s4).forEach((e14)=>{
            null == n5[e14] && (n5[e14] = s4[e14]);
        }), "json" === n5.parser && (n5.trailingComma = "none"), Yu.normalizeApiOptions(n5, r4, Object.assign({
            passThrough: Object.keys(Ui)
        }, t9)));
    },
    hiddenDefaults: Ui,
    inferParser: Ji
};
const { builders: { concat: Yi , line: Ki , hardline: Qi , breakParent: Zi , indent: ea , lineSuffix: ta , join: na , cursor: ra  }  } = rn1, { hasNewline: oa , skipNewline: ua , skipSpaces: ia , isPreviousLineEmpty: aa , addLeadingComment: sa , addDanglingComment: la , addTrailingComment: ca  } = Nt1, pa = Symbol("child-nodes");
function da(e13, t9, n5) {
    if (!e13) return;
    const { printer: r4 , locStart: o4 , locEnd: u4  } = t9;
    if (n5) {
        if (r4.canAttachComment && r4.canAttachComment(e13)) {
            let t10;
            for(t10 = n5.length - 1; t10 >= 0 && !(o4(n5[t10]) <= o4(e13) && u4(n5[t10]) <= u4(e13)); --t10);
            return void n5.splice(t10 + 1, 0, e13);
        }
    } else if (e13[pa]) return e13[pa];
    const i5 = r4.getCommentChildNodes && r4.getCommentChildNodes(e13, t9) || "object" == typeof e13 && Object.keys(e13).filter((e14)=>"enclosingNode" !== e14 && "precedingNode" !== e14 && "followingNode" !== e14 && "tokens" !== e14 && "comments" !== e14
    ).map((t10)=>e13[t10]
    );
    return i5 ? (n5 || Object.defineProperty(e13, pa, {
        value: n5 = [],
        enumerable: !1
    }), i5.forEach((e14)=>{
        da(e14, t9, n5);
    }), n5) : void 0;
}
function fa(e13, t9, n5) {
    const { locStart: r4 , locEnd: o4  } = n5, u4 = r4(t9), i5 = o4(t9), a4 = da(e13, n5);
    let s4, l4, c4 = 0, p4 = a4.length;
    for(; c4 < p4;){
        const e14 = c4 + p4 >> 1, d4 = a4[e14], f4 = r4(d4), h4 = o4(d4);
        if (f4 <= u4 && i5 <= h4) return t9.enclosingNode = d4, void fa(d4, t9, n5);
        if (f4 <= u4) s4 = d4, c4 = e14 + 1;
        else {
            if (!(i5 <= f4)) throw new Error("Comment location overlaps with node location");
            l4 = d4, p4 = e14;
        }
    }
    if (t9.enclosingNode && "TemplateLiteral" === t9.enclosingNode.type) {
        const { quasis: e14  } = t9.enclosingNode, r5 = ga(e14, t9, n5);
        s4 && ga(e14, s4, n5) !== r5 && (s4 = null), l4 && ga(e14, l4, n5) !== r5 && (l4 = null);
    }
    s4 && (t9.precedingNode = s4), l4 && (t9.followingNode = l4);
}
function ha(e13, t9, n5) {
    const r4 = e13.length;
    if (0 === r4) return;
    const { precedingNode: o4 , followingNode: u4 , enclosingNode: i5  } = e13[0], a4 = n5.printer.getGapRegex && n5.printer.getGapRegex(i5) || /^[\s(]*$/;
    let s4, l4 = n5.locStart(u4);
    for(s4 = r4; s4 > 0; --s4){
        const r5 = e13[s4 - 1];
        Xi.strictEqual(r5.precedingNode, o4), Xi.strictEqual(r5.followingNode, u4);
        const i6 = t9.slice(n5.locEnd(r5), l4);
        if (!a4.test(i6)) break;
        l4 = n5.locStart(r5);
    }
    e13.forEach((e14, t10)=>{
        t10 < s4 ? ca(o4, e14) : sa(u4, e14);
    });
    for (const e14 of [
        o4,
        u4
    ])e14.comments && e14.comments.length > 1 && e14.comments.sort((e15, t10)=>n5.locStart(e15) - n5.locStart(t10)
    );
    e13.length = 0;
}
function Da(e13, t9, n5) {
    return e13.getNode() === t9.cursorNode && e13.getValue() ? Yi([
        ra,
        n5,
        ra
    ]) : n5;
}
var ya = {
    attach: function(e13, t9, n5, r4) {
        if (!Array.isArray(e13)) return;
        const o4 = [], { locStart: u4 , locEnd: i5  } = r4;
        e13.forEach((a4, s4)=>{
            if ("json" === r4.parser || "json5" === r4.parser || "__js_expression" === r4.parser || "__vue_expression" === r4.parser) {
                if (u4(a4) - u4(t9) <= 0) return void sa(t9, a4);
                if (i5(a4) - i5(t9) >= 0) return void ca(t9, a4);
            }
            fa(t9, a4, r4);
            const { precedingNode: l4 , enclosingNode: c4 , followingNode: p4  } = a4, d4 = r4.printer.handleComments && r4.printer.handleComments.ownLine ? r4.printer.handleComments.ownLine : ()=>!1
            , f4 = r4.printer.handleComments && r4.printer.handleComments.endOfLine ? r4.printer.handleComments.endOfLine : ()=>!1
            , h4 = r4.printer.handleComments && r4.printer.handleComments.remaining ? r4.printer.handleComments.remaining : ()=>!1
            , m4 = e13.length - 1 === s4;
            if (oa(n5, u4(a4), {
                backwards: !0
            })) d4(a4, n5, r4, t9, m4) || (p4 ? sa(p4, a4) : l4 ? ca(l4, a4) : la(c4 || t9, a4));
            else if (oa(n5, i5(a4))) f4(a4, n5, r4, t9, m4) || (l4 ? ca(l4, a4) : p4 ? sa(p4, a4) : la(c4 || t9, a4));
            else if (h4(a4, n5, r4, t9, m4)) ;
            else if (l4 && p4) {
                const e14 = o4.length;
                if (e14 > 0) {
                    o4[e14 - 1].followingNode !== a4.followingNode && ha(o4, n5, r4);
                }
                o4.push(a4);
            } else l4 ? ca(l4, a4) : p4 ? sa(p4, a4) : la(c4 || t9, a4);
        }), ha(o4, n5, r4), e13.forEach((e14)=>{
            delete e14.precedingNode, delete e14.enclosingNode, delete e14.followingNode;
        });
    },
    printComments: function(e13, t9, n5, r4) {
        const o4 = e13.getValue(), u4 = t9(e13), i5 = o4 && o4.comments;
        if (!i5 || 0 === i5.length) return Da(e13, n5, u4);
        const a4 = [], s4 = [
            r4 ? ";" : "",
            u4
        ];
        return (e13.each((e14)=>{
            const t10 = e14.getValue(), { leading: r5 , trailing: o5  } = t10;
            if (r5) {
                const r6 = function(e15, t11) {
                    const n6 = e15.getValue(), r7 = ma(e15, t11);
                    if (!r7) return "";
                    if (t11.printer.isBlockComment && t11.printer.isBlockComment(n6)) {
                        const e16 = oa(t11.originalText, t11.locEnd(n6)) ? oa(t11.originalText, t11.locStart(n6), {
                            backwards: !0
                        }) ? Qi : Ki : " ";
                        return Yi([
                            r7,
                            e16
                        ]);
                    }
                    return Yi([
                        r7,
                        Qi
                    ]);
                }(e14, n5);
                if (!r6) return;
                a4.push(r6);
                const o6 = n5.originalText, u5 = ua(o6, ia(o6, n5.locEnd(t10)));
                !1 !== u5 && oa(o6, u5) && a4.push(Qi);
            } else o5 && s4.push(function(e15, t11) {
                const n6 = e15.getValue(), r6 = ma(e15, t11);
                if (!r6) return "";
                const { printer: o6 , originalText: u5 , locStart: i6  } = t11, a5 = o6.isBlockComment && o6.isBlockComment(n6);
                if (oa(u5, i6(n6), {
                    backwards: !0
                })) {
                    const e16 = aa(u5, n6, i6);
                    return ta(Yi([
                        Qi,
                        e16 ? Qi : "",
                        r6
                    ]));
                }
                let s5 = Yi([
                    " ",
                    r6
                ]);
                return a5 || (s5 = Yi([
                    ta(s5),
                    Zi
                ])), s5;
            }(e14, n5));
        }, "comments"), Da(e13, n5, Yi(a4.concat(s4))));
    },
    printDanglingComments: function(e13, t9, n5, r4) {
        const o4 = [], u4 = e13.getValue();
        return u4 && u4.comments ? (e13.each((e14)=>{
            const n6 = e14.getValue();
            !n6 || n6.leading || n6.trailing || r4 && !r4(n6) || o4.push(ma(e14, t9));
        }, "comments"), 0 === o4.length ? "" : n5 ? na(Qi, o4) : ea(Yi([
            Qi,
            na(Qi, o4)
        ]))) : "";
    },
    getSortedChildNodes: da,
    ensureAllCommentsPrinted: function(e13) {
        e13 && e13.forEach((e14)=>{
            if (!e14.printed) throw new Error('Comment "' + e14.value.trim() + '" was not printed. Please report this error!');
            delete e14.printed;
        });
    }
};
const { utils: { stripTrailingHardline: va  }  } = rn1, { normalize: Aa  } = zi;
var Fa = {
    printSubtree: function(e13, t9, n5, r4) {
        if (n5.printer.embed && "auto" === n5.embeddedLanguageFormatting) return n5.printer.embed(e13, t9, (e14, t10, o4)=>(function(e15, t11, n6, r5, { stripTrailingHardline: o5 = !1  } = {
            }) {
                const u4 = Aa(Object.assign({
                }, n6, t11, {
                    parentParser: n6.parser,
                    embeddedInHtml: !(!n6.embeddedInHtml && "html" !== n6.parser && "vue" !== n6.parser && "angular" !== n6.parser && "lwc" !== n6.parser),
                    originalText: e15
                }), {
                    passThrough: !0
                }), i5 = Vi.parse(e15, u4), { ast: a4  } = i5;
                e15 = i5.text;
                const s4 = a4.comments;
                delete a4.comments, ya.attach(s4, a4, e15, u4), u4[Symbol.for("comments")] = s4 || [], u4[Symbol.for("tokens")] = a4.tokens || [];
                const l4 = r5(a4, u4);
                if (ya.ensureAllCommentsPrinted(s4), o5) return "string" == typeof l4 ? l4.replace(/(?:\r?\n)*$/, "") : va(l4, !0);
                return l4;
            })(e14, t10, n5, r4, o4)
        , n5);
    }
};
const xa = rn1, Sa = xa.builders, { concat: wa , hardline: Ta , addAlignmentToDoc: Ba  } = Sa, Na = xa.utils;
function ka(e13, t9, n5 = 0) {
    const { printer: r4  } = t9;
    r4.preprocess && (e13 = r4.preprocess(e13, t9));
    const o4 = new Map;
    let u4 = function e13(n6, u5) {
        const i5 = n6.getValue(), a4 = i5 && "object" == typeof i5 && (void 0) === u5;
        if (a4 && o4.has(i5)) return o4.get(i5);
        let s4;
        return s4 = r4.willPrintOwnComments && r4.willPrintOwnComments(n6, t9) ? Pa(n6, t9, e13, u5) : ya.printComments(n6, (n7)=>Pa(n7, t9, e13, u5)
        , t9, u5 && u5.needsSemi), a4 && o4.set(i5, s4), s4;
    }(new ba(e13));
    return n5 > 0 && (u4 = Ba(wa([
        Ta,
        u4
    ]), n5, t9.tabWidth)), Na.propagateBreaks(u4), u4;
}
function Pa(e13, t9, n5, r4) {
    Xi.ok(e13 instanceof ba);
    const o4 = e13.getValue(), { printer: u4  } = t9;
    if (u4.hasPrettierIgnore && u4.hasPrettierIgnore(e13)) return (function(e14, t10) {
        const { originalText: n6 , [Symbol.for("comments")]: r5 , locStart: o5 , locEnd: u5  } = t10, i5 = o5(e14), a4 = u5(e14);
        for (const e15 of r5)o5(e15) >= i5 && u5(e15) <= a4 && (e15.printed = !0);
        return n6.slice(i5, a4);
    })(o4, t9);
    if (o4) try {
        const r5 = Fa.printSubtree(e13, n5, t9, ka);
        if (r5) return r5;
    } catch (e) {
        if (Me.PRETTIER_DEBUG) throw e;
    }
    return u4.print(e13, t9, n5, r4);
}
var Oa = ka;
function Ia(e13, t9, n5, r4, o4 = []) {
    if (!(t9 < n5.locStart(e13) || t9 > n5.locEnd(e13))) {
        for (const u4 of ya.getSortedChildNodes(e13, n5)){
            const i5 = Ia(u4, t9, n5, r4, [
                e13,
                ...o4
            ]);
            if (i5) return i5;
        }
        return !r4 || r4(e13) ? {
            node: e13,
            parentNodes: o4
        } : void 0;
    }
}
var _a = {
    calculateRange: function(e13, t9, n5) {
        const r4 = e13.slice(t9.rangeStart, t9.rangeEnd), o4 = Math.max(t9.rangeStart + r4.search(/\S/), t9.rangeStart);
        let u4;
        for(u4 = t9.rangeEnd; u4 > t9.rangeStart && !/\S/.test(e13[u4 - 1]); --u4);
        const i5 = Ia(n5, o4, t9, (e14)=>ja(t9, e14)
        ), a4 = Ia(n5, u4, t9, (e14)=>ja(t9, e14)
        );
        if (!i5 || !a4) return {
            rangeStart: 0,
            rangeEnd: 0
        };
        const { startNode: s4 , endNode: l4  } = function(e14, t10, n6) {
            let r5 = e14.node, o5 = t10.node;
            if (r5 === o5) return {
                startNode: r5,
                endNode: o5
            };
            for (const r6 of t10.parentNodes){
                if (!("Program" !== r6.type && "File" !== r6.type && n6.locStart(r6) >= n6.locStart(e14.node))) break;
                o5 = r6;
            }
            for (const o6 of e14.parentNodes){
                if (!("Program" !== o6.type && "File" !== o6.type && n6.locEnd(o6) <= n6.locEnd(t10.node))) break;
                r5 = o6;
            }
            return {
                startNode: r5,
                endNode: o5
            };
        }(i5, a4, t9);
        return {
            rangeStart: Math.min(t9.locStart(s4), t9.locStart(l4)),
            rangeEnd: Math.max(t9.locEnd(s4), t9.locEnd(l4))
        };
    },
    findNodeAtOffset: Ia
};
const { printer: { printDocToString: Ra  } , debug: { printDocToDebug: Va  }  } = rn1, { getAlignmentSize: $a  } = Nt1, { guessEndOfLine: qa , convertEndOfLineToChars: Wa , countEndOfLineChars: Ua , normalizeEndOfLine: Ja  } = kt, za = zi.normalize, Ga = Symbol("cursor");
function Ha(e13, t9, n5) {
    const r4 = t9.comments;
    return r4 && (delete t9.comments, ya.attach(r4, t9, e13, n5)), n5[Symbol.for("comments")] = r4 || [], n5[Symbol.for("tokens")] = t9.tokens || [], n5.originalText = e13, r4;
}
function Xa(e13, t9, n5) {
    if (!e13 || !e13.trim().length) return {
        formatted: "",
        cursorOffset: -1
    };
    n5 = n5 || 0;
    const { ast: r4 , text: o4  } = Vi.parse(e13, t9);
    if (t9.cursorOffset >= 0) {
        const e14 = _a.findNodeAtOffset(r4, t9.cursorOffset, t9);
        e14 && e14.node && (t9.cursorNode = e14.node);
    }
    const u4 = Ha(o4, r4, t9), i5 = Oa(r4, t9, n5), a4 = Ra(i5, t9);
    if (ya.ensureAllCommentsPrinted(u4), n5 > 0) {
        const e14 = a4.formatted.trim();
        (void 0) !== a4.cursorNodeStart && (a4.cursorNodeStart -= a4.formatted.indexOf(e14)), a4.formatted = e14 + Wa(t9.endOfLine);
    }
    if (t9.cursorOffset >= 0) {
        let e14, n6, r5, u5, i6;
        if (t9.cursorNode && a4.cursorNodeText ? (e14 = t9.locStart(t9.cursorNode), n6 = o4.slice(e14, t9.locEnd(t9.cursorNode)), r5 = t9.cursorOffset - e14, u5 = a4.cursorNodeStart, i6 = a4.cursorNodeText) : (e14 = 0, n6 = o4, r5 = t9.cursorOffset, u5 = 0, i6 = a4.formatted), n6 === i6) return {
            formatted: a4.formatted,
            cursorOffset: u5 + r5
        };
        const s4 = n6.split("");
        s4.splice(r5, 0, Ga);
        const l4 = i6.split(""), c4 = J.diffArrays(s4, l4);
        let p4 = u5;
        for (const e15 of c4)if (e15.removed) {
            if (e15.value.includes(Ga)) break;
        } else p4 += e15.count;
        return {
            formatted: a4.formatted,
            cursorOffset: p4
        };
    }
    return {
        formatted: a4.formatted,
        cursorOffset: -1
    };
}
function Qa(e13, t9) {
    let { cursorOffset: n5 , rangeStart: r4 , rangeEnd: o4 , endOfLine: u4  } = Ka(e13, t9);
    const i5 = "\ufeff" === e13.charAt(0);
    if (i5 && (e13 = e13.slice(1), n5--, r4--, o4--), "auto" === u4 && (u4 = qa(e13)), e13.includes("\r")) {
        const t10 = (t11)=>Ua(e13.slice(0, Math.max(t11, 0)), "\r\n")
        ;
        n5 -= t10(n5), r4 -= t10(r4), o4 -= t10(o4), e13 = Ja(e13);
    }
    return {
        hasBOM: i5,
        text: e13,
        options: Ka(e13, Object.assign({
        }, t9, {
            cursorOffset: n5,
            rangeStart: r4,
            rangeEnd: o4,
            endOfLine: u4
        }))
    };
}
function Za(e13, t9) {
    let { hasBOM: n5 , text: r4 , options: o4  } = Qa(e13, za(t9));
    const u4 = Vi.resolveParser(o4), i5 = !u4.hasPragma || u4.hasPragma(r4);
    if (o4.requirePragma && !i5) return {
        formatted: e13,
        cursorOffset: t9.cursorOffset
    };
    let a4;
    return o4.rangeStart > 0 || o4.rangeEnd < r4.length ? a4 = (function(e14, t10) {
        const { ast: n6 , text: r5  } = Vi.parse(e14, t10), { rangeStart: o5 , rangeEnd: u5  } = _a.calculateRange(r5, t10, n6), i6 = r5.slice(o5, u5), a5 = Math.min(o5, r5.lastIndexOf("\n", o5) + 1), s4 = r5.slice(a5, o5).match(/^\s*/)[0], l4 = $a(s4, t10.tabWidth), c4 = Xa(i6, Object.assign({
        }, t10, {
            rangeStart: 0,
            rangeEnd: 1 / 0,
            cursorOffset: t10.cursorOffset > o5 && t10.cursorOffset < u5 ? t10.cursorOffset - o5 : -1,
            endOfLine: "lf"
        }), l4), p4 = c4.formatted.trimEnd();
        let { cursorOffset: d4  } = t10;
        d4 >= u5 ? d4 = t10.cursorOffset + (p4.length - i6.length) : c4.cursorOffset >= 0 && (d4 = c4.cursorOffset + o5);
        let f4 = r5.slice(0, o5) + p4 + r5.slice(u5);
        if ("lf" !== t10.endOfLine) {
            const e15 = Wa(t10.endOfLine);
            d4 >= 0 && "\r\n" === e15 && (d4 += Ua(f4.slice(0, d4), "\n")), f4 = f4.replace(/\n/g, e15);
        }
        return {
            formatted: f4,
            cursorOffset: d4
        };
    })(r4, o4) : (!i5 && o4.insertPragma && o4.printer.insertPragma && (r4 = o4.printer.insertPragma(r4)), a4 = Xa(r4, o4)), n5 && (a4.formatted = "\ufeff" + a4.formatted, a4.cursorOffset >= 0 && a4.cursorOffset++), a4;
}
var es = {
    formatWithCursor: Za,
    parse (e, t, n) {
        const { text: r4 , options: o4  } = Qa(e, za(t)), u4 = Vi.parse(r4, o4);
        return (n && (u4.ast = Gi(u4.ast, o4)), u4);
    },
    formatAST (e, t) {
        t = za(t);
        const n5 = Oa(e, t);
        return Ra(n5, t);
    },
    formatDoc: (e13, t9)=>Za(Va(e13), Object.assign({
        }, t9, {
            parser: "babel"
        })).formatted
    ,
    printToDoc (e, t) {
        t = za(t);
        const { ast: n5 , text: r4  } = Vi.parse(e, t);
        return (Ha(r4, n5, t), Oa(n5, t));
    },
    printDocToString: (e13, t9)=>Ra(e13, za(t9))
};
const { getMaxContinuousCount: ts , getStringWidth: ns , getAlignmentSize: rs , getIndentSize: os , skip: us , skipWhitespace: is , skipSpaces: as , skipNewline: ss , skipToLineEnd: ls , skipEverythingButNewLine: cs , skipInlineComment: ps , skipTrailingComment: ds , hasNewline: fs , hasNewlineInRange: hs , hasSpaces: ms , isNextLineEmpty: gs , isNextLineEmptyAfterIndex: Ds , isPreviousLineEmpty: ys , getNextNonSpaceNonCommentCharacterIndex: Es , makeString: Cs , addLeadingComment: bs , addDanglingComment: vs1 , addTrailingComment: As  } = Nt1;
var xs1 = function(t9, n5) {
    const { languageId: r4  } = t9, o4 = e2(t9, [
        "languageId"
    ]);
    return Object.assign({
        linguistLanguageId: r4
    }, o4, n5(t9));
}, Ss = je(function(e13) {
    !(function() {
        function t9(e14) {
            if (null == e14) return !1;
            switch(e14.type){
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                    return !0;
            }
            return !1;
        }
        function n5(e14) {
            switch(e14.type){
                case "IfStatement":
                    return null != e14.alternate ? e14.alternate : e14.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                    return e14.body;
            }
            return null;
        }
        e13.exports = {
            isExpression: function(e14) {
                if (null == e14) return !1;
                switch(e14.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                        return !0;
                }
                return !1;
            },
            isStatement: t9,
            isIterationStatement: function(e14) {
                if (null == e14) return !1;
                switch(e14.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                        return !0;
                }
                return !1;
            },
            isSourceElement: function(e14) {
                return t9(e14) || null != e14 && "FunctionDeclaration" === e14.type;
            },
            isProblematicIfStatement: function(e14) {
                var t10;
                if ("IfStatement" !== e14.type) return !1;
                if (null == e14.alternate) return !1;
                t10 = e14.consequent;
                do {
                    if ("IfStatement" === t10.type && null == t10.alternate) return !0;
                    t10 = n5(t10);
                }while (t10)
                return !1;
            },
            trailingStatement: n5
        };
    })();
}), ws = je(function(e13) {
    !(function() {
        var t9, n5, r4, o4, u4, i5;
        function a4(e14) {
            return e14 <= 65535 ? String.fromCharCode(e14) : String.fromCharCode(Math.floor((e14 - 65536) / 1024) + 55296) + String.fromCharCode((e14 - 65536) % 1024 + 56320);
        }
        for(n5 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        }, t9 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        }, r4 = [
            5760,
            8192,
            8193,
            8194,
            8195,
            8196,
            8197,
            8198,
            8199,
            8200,
            8201,
            8202,
            8239,
            8287,
            12288,
            65279
        ], o4 = new Array(128), i5 = 0; i5 < 128; ++i5)o4[i5] = i5 >= 97 && i5 <= 122 || i5 >= 65 && i5 <= 90 || 36 === i5 || 95 === i5;
        for(u4 = new Array(128), i5 = 0; i5 < 128; ++i5)u4[i5] = i5 >= 97 && i5 <= 122 || i5 >= 65 && i5 <= 90 || i5 >= 48 && i5 <= 57 || 36 === i5 || 95 === i5;
        e13.exports = {
            isDecimalDigit: function(e14) {
                return 48 <= e14 && e14 <= 57;
            },
            isHexDigit: function(e14) {
                return 48 <= e14 && e14 <= 57 || 97 <= e14 && e14 <= 102 || 65 <= e14 && e14 <= 70;
            },
            isOctalDigit: function(e14) {
                return e14 >= 48 && e14 <= 55;
            },
            isWhiteSpace: function(e14) {
                return 32 === e14 || 9 === e14 || 11 === e14 || 12 === e14 || 160 === e14 || e14 >= 5760 && r4.indexOf(e14) >= 0;
            },
            isLineTerminator: function(e14) {
                return 10 === e14 || 13 === e14 || 8232 === e14 || 8233 === e14;
            },
            isIdentifierStartES5: function(e14) {
                return e14 < 128 ? o4[e14] : n5.NonAsciiIdentifierStart.test(a4(e14));
            },
            isIdentifierPartES5: function(e14) {
                return e14 < 128 ? u4[e14] : n5.NonAsciiIdentifierPart.test(a4(e14));
            },
            isIdentifierStartES6: function(e14) {
                return e14 < 128 ? o4[e14] : t9.NonAsciiIdentifierStart.test(a4(e14));
            },
            isIdentifierPartES6: function(e14) {
                return e14 < 128 ? u4[e14] : t9.NonAsciiIdentifierPart.test(a4(e14));
            }
        };
    })();
}), Ts = je(function(e13) {
    !(function() {
        var t9 = ws;
        function n5(e14, t10) {
            return !(!t10 && "yield" === e14) && r4(e14, t10);
        }
        function r4(e14, t10) {
            if (t10 && (function(e15) {
                switch(e15){
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                        return !0;
                    default:
                        return !1;
                }
            })(e14)) return !0;
            switch(e14.length){
                case 2:
                    return "if" === e14 || "in" === e14 || "do" === e14;
                case 3:
                    return "var" === e14 || "for" === e14 || "new" === e14 || "try" === e14;
                case 4:
                    return "this" === e14 || "else" === e14 || "case" === e14 || "void" === e14 || "with" === e14 || "enum" === e14;
                case 5:
                    return "while" === e14 || "break" === e14 || "catch" === e14 || "throw" === e14 || "const" === e14 || "yield" === e14 || "class" === e14 || "super" === e14;
                case 6:
                    return "return" === e14 || "typeof" === e14 || "delete" === e14 || "switch" === e14 || "export" === e14 || "import" === e14;
                case 7:
                    return "default" === e14 || "finally" === e14 || "extends" === e14;
                case 8:
                    return "function" === e14 || "continue" === e14 || "debugger" === e14;
                case 10:
                    return "instanceof" === e14;
                default:
                    return !1;
            }
        }
        function o4(e14, t10) {
            return "null" === e14 || "true" === e14 || "false" === e14 || n5(e14, t10);
        }
        function u4(e14, t10) {
            return "null" === e14 || "true" === e14 || "false" === e14 || r4(e14, t10);
        }
        function i5(e14) {
            var n6, r5, o5;
            if (0 === e14.length) return !1;
            if (o5 = e14.charCodeAt(0), !t9.isIdentifierStartES5(o5)) return !1;
            for(n6 = 1, r5 = e14.length; n6 < r5; ++n6)if (o5 = e14.charCodeAt(n6), !t9.isIdentifierPartES5(o5)) return !1;
            return !0;
        }
        function a4(e14) {
            var n6, r5, o5, u5, i6;
            if (0 === e14.length) return !1;
            for(i6 = t9.isIdentifierStartES6, n6 = 0, r5 = e14.length; n6 < r5; ++n6){
                if (55296 <= (o5 = e14.charCodeAt(n6)) && o5 <= 56319) {
                    if ((++n6) >= r5) return !1;
                    if (!(56320 <= (u5 = e14.charCodeAt(n6)) && u5 <= 57343)) return !1;
                    o5 = 1024 * (o5 - 55296) + (u5 - 56320) + 65536;
                }
                if (!i6(o5)) return !1;
                i6 = t9.isIdentifierPartES6;
            }
            return !0;
        }
        e13.exports = {
            isKeywordES5: n5,
            isKeywordES6: r4,
            isReservedWordES5: o4,
            isReservedWordES6: u4,
            isRestrictedWord: function(e14) {
                return "eval" === e14 || "arguments" === e14;
            },
            isIdentifierNameES5: i5,
            isIdentifierNameES6: a4,
            isIdentifierES5: function(e14, t10) {
                return i5(e14) && !o4(e14, t10);
            },
            isIdentifierES6: function(e14, t10) {
                return a4(e14) && !u4(e14, t10);
            }
        };
    })();
});
const Bs = je(function(e13, t9) {
    t9.ast = Ss, t9.code = ws, t9.keyword = Ts;
}).keyword.isIdentifierNameES5, { getLast: Ns , hasNewline: ks1 , hasNewlineInRange: Ps , skipWhitespace: Os  } = Nt1, { locStart: Is1 , locEnd: Ls , hasSameLocStart: Ms  } = ei, js = new RegExp("^".concat("(?:(?=.)\\s)", "*:")), _s = new RegExp("^".concat("(?:(?=.)\\s)", "*::"));
function Ks1(e13) {
    return Ys(e13) || Ms(e13, e13.value);
}
function ul(e13, t9) {
    if (Xs(t9)) return yl(t9);
    return t9.comments && t9.comments.some((t10)=>t10.leading && ks1(e13, Ls(t10))
    );
}
var Cl = {
    classChildNeedsASIProtection: function(e13) {
        if (e13) {
            if (e13.static || e13.accessibility) return !1;
            if (!e13.computed) {
                const t9 = e13.key && e13.key.name;
                if ("in" === t9 || "instanceof" === t9) return !0;
            }
            switch(e13.type){
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                    return e13.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    {
                        const t9 = e13.value ? e13.value.async : e13.async, n5 = e13.value ? e13.value.generator : e13.generator;
                        return !t9 && "get" !== e13.kind && "set" !== e13.kind && !(!e13.computed && !n5);
                    }
                case "TSIndexSignature":
                    return !0;
                default:
                    return !1;
            }
        }
    },
    classPropMayCauseASIProblems: function(e13) {
        const t9 = e13.getNode();
        if ("ClassProperty" !== t9.type && "FieldDefinition" !== t9.type) return !1;
        const n5 = t9.key && t9.key.name;
        return !("static" !== n5 && "get" !== n5 && "set" !== n5 || t9.value || t9.typeAnnotation) || void 0;
    },
    getFunctionParameters: ml,
    iterateFunctionParametersPath: function(e13, t9) {
        const n5 = e13.getValue();
        let r4 = 0;
        const o4 = (e14)=>t9(e14, r4++)
        ;
        n5.this && e13.call(o4, "this"), Array.isArray(n5.parameters) ? e13.each(o4, "parameters") : Array.isArray(n5.params) && e13.each(o4, "params"), n5.rest && e13.call(o4, "rest");
    },
    getCallArguments: function(e13) {
        if (gl.has(e13)) return gl.get(e13);
        const t9 = "ImportExpression" === e13.type ? [
            e13.source
        ] : e13.arguments;
        return (gl.set(e13, t9), t9);
    },
    iterateCallArgumentsPath: function(e13, t9) {
        "ImportExpression" === e13.getValue().type ? e13.call((e14)=>t9(e14, 0)
        , "source") : e13.each(t9, "arguments");
    },
    hasRestParameter: function(e13) {
        if (e13.rest) return !0;
        const t9 = ml(e13);
        return t9.length > 0 && "RestElement" === Ns(t9).type;
    },
    getLeftSidePathName: function(e13, t9) {
        if (t9.expressions) return [
            "expressions",
            0
        ];
        if (t9.left) return [
            "left"
        ];
        if (t9.test) return [
            "test"
        ];
        if (t9.object) return [
            "object"
        ];
        if (t9.callee) return [
            "callee"
        ];
        if (t9.tag) return [
            "tag"
        ];
        if (t9.argument) return [
            "argument"
        ];
        if (t9.expression) return [
            "expression"
        ];
        throw new Error("Unexpected node has no left side.");
    },
    getParentExportDeclaration: function(e13) {
        const t9 = e13.getParentNode();
        return "declaration" === e13.getName() && Ws1(t9) ? t9 : null;
    },
    getTypeScriptMappedTypeModifier: function(e13, t9) {
        return "+" === e13 ? "+" + t9 : "-" === e13 ? "-" + t9 : t9;
    },
    hasDanglingComments: function(e13) {
        return e13.comments && e13.comments.some((e14)=>!e14.leading && !e14.trailing
        );
    },
    hasFlowAnnotationComment: function(e13) {
        return e13 && $s(e13[0]) && _s.test(e13[0].value);
    },
    hasFlowShorthandAnnotationComment: function(e13) {
        return e13.extra && e13.extra.parenthesized && e13.trailingComments && $s(e13.trailingComments[0]) && js.test(e13.trailingComments[0].value);
    },
    hasLeadingComment: function(e13) {
        return e13.comments && e13.comments.some((e14)=>e14.leading
        );
    },
    hasLeadingOwnLineComment: ul,
    hasNakedLeftSide: Vs,
    hasNewlineBetweenOrAfterDecorators: function(e13, t9) {
        return Ps(t9.originalText, Is1(e13.decorators[0]), Ls(Ns(e13.decorators))) || ks1(t9.originalText, Ls(Ns(e13.decorators)));
    },
    hasNgSideEffect: function(e13) {
        return Rs(e13.getValue(), (e14)=>{
            switch(e14.type){
                case void 0:
                    return !1;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                    return !0;
            }
        });
    },
    hasNode: Rs,
    hasPrettierIgnore: function(e13) {
        return El(e13) || function(e14) {
            const t9 = e14.getValue(), n5 = e14.getParentNode();
            if (!(n5 && t9 && Xs(t9) && Xs(n5))) return !1;
            let r4 = null;
            for(let e15 = n5.children.indexOf(t9); e15 > 0; e15--){
                const t10 = n5.children[e15 - 1];
                if ("JSXText" !== t10.type || ol(t10)) {
                    r4 = t10;
                    break;
                }
            }
            return r4 && "JSXExpressionContainer" === r4.type && "JSXEmptyExpression" === r4.expression.type && r4.expression.comments && r4.expression.comments.some((e16)=>Dl(e16)
            );
        }(e13);
    },
    hasTrailingComment: function(e13) {
        return e13.comments && e13.comments.some((e14)=>e14.trailing
        );
    },
    hasTrailingLineComment: function(e13) {
        return e13.comments && e13.comments.some((e14)=>e14.trailing && !$s(e14)
        );
    },
    hasIgnoreComment: El,
    hasNodeIgnoreComment: yl,
    identity: function(e13) {
        return e13;
    },
    isBinaryish: function(e13) {
        return Qs.has(e13.type);
    },
    isBlockComment: $s,
    isLineComment: function(e13) {
        return "Line" === e13.type || "CommentLine" === e13.type || "SingleLine" === e13.type || "HashbangComment" === e13.type || "HTMLOpen" === e13.type || "HTMLClose" === e13.type;
    },
    isPrettierIgnoreComment: Dl,
    isCallOrOptionalCallExpression: tl,
    isEmptyJSXElement: function(e13) {
        if (0 === e13.children.length) return !0;
        if (e13.children.length > 1) return !1;
        const t9 = e13.children[0];
        return Us(t9) && !ol(t9);
    },
    isExportDeclaration: Ws1,
    isFlowAnnotationComment: function(e13, t9) {
        const n5 = Is1(t9), r4 = Os(e13, Ls(t9));
        return !1 !== r4 && "/*" === e13.slice(n5, n5 + 2) && "*/" === e13.slice(r4, r4 + 2);
    },
    isFunctionCompositionArgs: function(e13) {
        if (e13.length <= 1) return !1;
        let t9 = 0;
        for (const n5 of e13)if (Gs(n5)) {
            if ((t9 += 1, t9 > 1)) return !0;
        } else if (tl(n5)) for (const e14 of n5.arguments)if (Gs(e14)) return !0;
        return !1;
    },
    isFunctionNotation: Ks1,
    isFunctionOrArrowExpression: Gs,
    isGetterOrSetter: Ys,
    isJestEachTemplateLiteral: function(e13, t9) {
        const n5 = /^[fx]?(describe|it|test)$/;
        return "TaggedTemplateExpression" === t9.type && t9.quasi === e13 && "MemberExpression" === t9.tag.type && "Identifier" === t9.tag.property.type && "each" === t9.tag.property.name && ("Identifier" === t9.tag.object.type && n5.test(t9.tag.object.name) || "MemberExpression" === t9.tag.object.type && "Identifier" === t9.tag.object.property.type && ("only" === t9.tag.object.property.name || "skip" === t9.tag.object.property.name) && "Identifier" === t9.tag.object.object.type && n5.test(t9.tag.object.object.name));
    },
    isJSXNode: Xs,
    isJSXWhitespaceExpression: function(e13) {
        return "JSXExpressionContainer" === e13.type && Us(e13.expression) && " " === e13.expression.value && !e13.expression.comments;
    },
    isLastStatement: function(e13) {
        const t9 = e13.getParentNode();
        if (!t9) return !0;
        const n5 = e13.getValue(), r4 = (t9.body || t9.consequent).filter((e14)=>"EmptyStatement" !== e14.type
        );
        return r4[r4.length - 1] === n5;
    },
    isLiteral: Us,
    isLongCurriedCallExpression: function(e13) {
        const t9 = e13.getValue(), n5 = e13.getParentNode();
        return tl(t9) && tl(n5) && n5.callee === t9 && t9.arguments.length > n5.arguments.length && n5.arguments.length > 0;
    },
    isSimpleCallArgument: function e13(t9, n5) {
        if (n5 >= 2) return !1;
        const r4 = (t10)=>e13(t10, n5 + 1)
        , o4 = "Literal" === t9.type && "regex" in t9 && t9.regex.pattern || "RegExpLiteral" === t9.type && t9.pattern;
        return !(o4 && o4.length > 5) && ("Literal" === t9.type || "BigIntLiteral" === t9.type || "DecimalLiteral" === t9.type || "BooleanLiteral" === t9.type || "NullLiteral" === t9.type || "NumericLiteral" === t9.type || "RegExpLiteral" === t9.type || "StringLiteral" === t9.type || "Identifier" === t9.type || "ThisExpression" === t9.type || "Super" === t9.type || "PrivateName" === t9.type || "ArgumentPlaceholder" === t9.type || "Import" === t9.type || ("TemplateLiteral" === t9.type ? t9.expressions.every(r4) : "ObjectExpression" === t9.type ? t9.properties.every((e14)=>!e14.computed && (e14.shorthand || e14.value && r4(e14.value))
        ) : "ArrayExpression" === t9.type ? t9.elements.every((e14)=>null === e14 || r4(e14)
        ) : "ImportExpression" === t9.type ? r4(t9.source) : "CallExpression" === t9.type || "OptionalCallExpression" === t9.type || "NewExpression" === t9.type ? e13(t9.callee, n5) && t9.arguments.every(r4) : "MemberExpression" === t9.type || "OptionalMemberExpression" === t9.type ? e13(t9.object, n5) && e13(t9.property, n5) : "UnaryExpression" !== t9.type || "!" !== t9.operator && "-" !== t9.operator ? "TSNonNullExpression" === t9.type && e13(t9.expression, n5) : e13(t9.argument, n5)));
    },
    isMeaningfulJSXText: ol,
    isMemberExpressionChain: function e13(t9) {
        return ("MemberExpression" === t9.type || "OptionalMemberExpression" === t9.type) && ("Identifier" === t9.object.type || e13(t9.object));
    },
    isMemberish: function(e14) {
        return "MemberExpression" === e14.type || "OptionalMemberExpression" === e14.type || "BindExpression" === e14.type && Boolean(e14.object);
    },
    isNgForOf: function(e14, t9, n5) {
        return "NGMicrosyntaxKeyedExpression" === e14.type && "of" === e14.key.name && 1 === t9 && "NGMicrosyntaxLet" === n5.body[0].type && null === n5.body[0].value;
    },
    isNumericLiteral: Js,
    isObjectType: function(e14) {
        return "ObjectTypeAnnotation" === e14.type || "TSTypeLiteral" === e14.type;
    },
    isObjectTypePropertyAFunction: function(e14) {
        return !("ObjectTypeProperty" !== e14.type && "ObjectTypeInternalSlot" !== e14.type || "FunctionTypeAnnotation" !== e14.value.type || e14.static || Ks1(e14));
    },
    isSimpleType: function(e14) {
        return !!e14 && (!("GenericTypeAnnotation" !== e14.type && "TSTypeReference" !== e14.type || e14.typeParameters) || !!Zs.has(e14.type));
    },
    isSimpleNumber: il,
    isSimpleTemplateLiteral: function(e14) {
        let t9 = "expressions";
        "TSTemplateLiteralType" === e14.type && (t9 = "types");
        const n5 = e14[t9];
        return 0 !== n5.length && n5.every((e15)=>{
            if (e15.comments) return !1;
            if ("Identifier" === e15.type || "ThisExpression" === e15.type) return !0;
            if ("MemberExpression" === e15.type || "OptionalMemberExpression" === e15.type) {
                let t10 = e15;
                for(; "MemberExpression" === t10.type || "OptionalMemberExpression" === t10.type;){
                    if ("Identifier" !== t10.property.type && "Literal" !== t10.property.type && "StringLiteral" !== t10.property.type && "NumericLiteral" !== t10.property.type) return !1;
                    if (t10 = t10.object, t10.comments) return !1;
                }
                return "Identifier" === t10.type || "ThisExpression" === t10.type;
            }
            return !1;
        });
    },
    isStringLiteral: zs,
    isStringPropSafeToUnquote: function(e14, t9) {
        return "json" !== t9.parser && zs(e14.key) && sl(e14.key).slice(1, -1) === e14.key.value && (Bs(e14.key.value) && !(("typescript" === t9.parser || "babel-ts" === t9.parser) && "ClassProperty" === e14.type) || il(e14.key.value) && String(Number(e14.key.value)) === e14.key.value && ("babel" === t9.parser || "espree" === t9.parser || "meriyah" === t9.parser));
    },
    isTemplateOnItsOwnLine: function(e14, t9) {
        return ("TemplateLiteral" === e14.type && al(e14) || "TaggedTemplateExpression" === e14.type && al(e14.quasi)) && !ks1(t9, Is1(e14), {
            backwards: !0
        });
    },
    isTestCall: function e13(t9, n5) {
        if ("CallExpression" !== t9.type) return !1;
        if (1 === t9.arguments.length) {
            if (Hs(t9) && n5 && e13(n5)) return Gs(t9.arguments[0]);
            if ("Identifier" === (r4 = t9).callee.type && /^(before|after)(Each|All)$/.test(r4.callee.name) && 1 === r4.arguments.length) return Hs(t9.arguments[0]);
        } else if ((2 === t9.arguments.length || 3 === t9.arguments.length) && ("Identifier" === t9.callee.type && el.test(t9.callee.name) || function(e14) {
            return ("MemberExpression" === e14.callee.type || "OptionalMemberExpression" === e14.callee.type) && "Identifier" === e14.callee.object.type && "Identifier" === e14.callee.property.type && el.test(e14.callee.object.name) && ("only" === e14.callee.property.name || "skip" === e14.callee.property.name);
        }(t9)) && (function(e14) {
            return "TemplateLiteral" === e14.type;
        }(t9.arguments[0]) || zs(t9.arguments[0]))) return !(t9.arguments[2] && !Js(t9.arguments[2])) && ((2 === t9.arguments.length ? Gs(t9.arguments[1]) : function(e14) {
            return "FunctionExpression" === e14.type || "ArrowFunctionExpression" === e14.type && "BlockStatement" === e14.body.type;
        }(t9.arguments[1]) && ml(t9.arguments[1]).length <= 1) || Hs(t9.arguments[1]));
        var r4;
        return !1;
    },
    isTheOnlyJSXElementInMarkdown: function(e14, t9) {
        if ("markdown" !== e14.parentParser && "mdx" !== e14.parentParser) return !1;
        const n5 = t9.getNode();
        if (!n5.expression || !Xs(n5.expression)) return !1;
        const r4 = t9.getParentNode();
        return "Program" === r4.type && 1 === r4.body.length;
    },
    isTSXFile: function(e14) {
        return e14.filepath && /\.tsx$/i.test(e14.filepath);
    },
    isTypeAnnotationAFunction: function(e14) {
        return !("TypeAnnotation" !== e14.type && "TSTypeAnnotation" !== e14.type || "FunctionTypeAnnotation" !== e14.typeAnnotation.type || e14.static || Ms(e14, e14.typeAnnotation));
    },
    matchJsxWhitespaceRegex: nl,
    needsHardlineAfterDanglingComment: function(e14) {
        if (!e14.comments) return !1;
        const t9 = Ns(e14.comments.filter((e15)=>!e15.leading && !e15.trailing
        ));
        return t9 && !$s(t9);
    },
    rawText: sl,
    returnArgumentHasLeadingComment: function(e14, t9) {
        if (ul(e14.originalText, t9)) return !0;
        if (Vs(t9)) {
            let r4, o4 = t9;
            for(; r4 = (n5 = o4).expressions ? n5.expressions[0] : n5.left || n5.test || n5.callee || n5.object || n5.tag || n5.argument || n5.expression;)if ((o4 = r4, ul(e14.originalText, o4))) return !0;
        }
        var n5;
        return !1;
    },
    shouldPrintComma: function(e14, t9 = "es5") {
        return "es5" === e14.trailingComma && "es5" === t9 || "all" === e14.trailingComma && ("all" === t9 || "es5" === t9);
    },
    isBitwiseOperator: function(e14) {
        return !!pl[e14] || "|" === e14 || "^" === e14 || "&" === e14;
    },
    shouldFlatten: function(e14, t9) {
        return fl(t9) === fl(e14) && ("**" !== e14 && ((!ll[e14] || !ll[t9]) && (!("%" === t9 && cl[e14] || "%" === e14 && cl[t9]) && ((t9 === e14 || !cl[t9] || !cl[e14]) && (!pl[e14] || !pl[t9])))));
    },
    startsWithNoLookaheadToken: function e13(t9, n5) {
        switch((t9 = function(e14) {
            for(; e14.left;)e14 = e14.left;
            return e14;
        }(t9)).type){
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
                return n5;
            case "ObjectExpression":
                return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
                return e13(t9.object, n5);
            case "TaggedTemplateExpression":
                return "FunctionExpression" !== t9.tag.type && e13(t9.tag, n5);
            case "CallExpression":
            case "OptionalCallExpression":
                return "FunctionExpression" !== t9.callee.type && e13(t9.callee, n5);
            case "ConditionalExpression":
                return e13(t9.test, n5);
            case "UpdateExpression":
                return !t9.prefix && e13(t9.argument, n5);
            case "BindExpression":
                return t9.object && e13(t9.object, n5);
            case "SequenceExpression":
                return e13(t9.expressions[0], n5);
            case "TSAsExpression":
                return e13(t9.expression, n5);
            default:
                return !1;
        }
    },
    getPrecedence: fl
};
const { getLast: bl , hasNewline: vl , getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Al , getNextNonSpaceNonCommentCharacter: Fl , hasNewlineInRange: xl , addLeadingComment: Sl , addTrailingComment: wl , addDanglingComment: Tl , getNextNonSpaceNonCommentCharacterIndex: Bl  } = Nt1, { isBlockComment: Nl , getFunctionParameters: kl , isPrettierIgnoreComment: Pl , isJSXNode: Ol , hasFlowShorthandAnnotationComment: Il , hasFlowAnnotationComment: Ll , hasIgnoreComment: Ml  } = Cl, { locStart: jl , locEnd: _l  } = ei;
function Rl(e13, t9) {
    const n5 = (e13.body || e13.properties).find(({ type: e14  })=>"EmptyStatement" !== e14
    );
    n5 ? Sl(n5, t9) : Tl(e13, t9);
}
function Vl(e13, t9) {
    "BlockStatement" === e13.type ? Rl(e13, t9) : Sl(e13, t9);
}
function $l(e13, t9) {
    const { precedingNode: n5 , enclosingNode: r4 , followingNode: o4  } = e13;
    if (!r4 || "IfStatement" !== r4.type || !o4) return !1;
    return ")" === Fl(t9, e13, _l) ? (wl(n5, e13), !0) : n5 === r4.consequent && o4 === r4.alternate ? ("BlockStatement" === n5.type ? wl(n5, e13) : Tl(r4, e13), !0) : "BlockStatement" === o4.type ? (Rl(o4, e13), !0) : "IfStatement" === o4.type ? (Vl(o4.consequent, e13), !0) : r4.consequent === o4 && (Sl(o4, e13), !0);
}
function ql(e13, t9) {
    const { precedingNode: n5 , enclosingNode: r4 , followingNode: o4  } = e13;
    if (!r4 || "WhileStatement" !== r4.type || !o4) return !1;
    return ")" === Fl(t9, e13, _l) ? (wl(n5, e13), !0) : "BlockStatement" === o4.type ? (Rl(o4, e13), !0) : r4.body === o4 && (Sl(o4, e13), !0);
}
function Wl(e13) {
    const { precedingNode: t9 , enclosingNode: n5 , followingNode: r4  } = e13;
    return !(!n5 || "TryStatement" !== n5.type && "CatchClause" !== n5.type || !r4) && ("CatchClause" === n5.type && t9 ? (wl(t9, e13), !0) : "BlockStatement" === r4.type ? (Rl(r4, e13), !0) : "TryStatement" === r4.type ? (Vl(r4.finalizer, e13), !0) : "CatchClause" === r4.type && (Vl(r4.body, e13), !0));
}
function Ul(e13) {
    const { precedingNode: t9 , enclosingNode: n5 , followingNode: r4  } = e13;
    if (n5 && ("ClassDeclaration" === n5.type || "ClassExpression" === n5.type || "DeclareClass" === n5.type || "DeclareInterface" === n5.type || "InterfaceDeclaration" === n5.type || "TSInterfaceDeclaration" === n5.type)) {
        if (n5.decorators && n5.decorators.length > 0 && (!r4 || "Decorator" !== r4.type)) return wl(n5.decorators[n5.decorators.length - 1], e13), !0;
        if (n5.body && r4 === n5.body) return Rl(n5.body, e13), !0;
        if (r4) for (const o4 of [
            "implements",
            "extends",
            "mixins"
        ])if (n5[o4] && r4 === n5[o4][0]) return !t9 || t9 !== n5.id && t9 !== n5.typeParameters && t9 !== n5.superClass ? Tl(n5, e13, o4) : wl(t9, e13), !0;
    }
    return !1;
}
function Jl(e13, t9) {
    const { precedingNode: n5 , enclosingNode: r4  } = e13;
    return (r4 && n5 && ("Property" === r4.type || "TSDeclareMethod" === r4.type || "TSAbstractMethodDefinition" === r4.type) && "Identifier" === n5.type && r4.key === n5 && ":" !== Fl(t9, n5, _l) || !(!n5 || !r4 || "Decorator" !== n5.type || "ClassMethod" !== r4.type && "ClassProperty" !== r4.type && "FieldDefinition" !== r4.type && "TSAbstractClassProperty" !== r4.type && "TSAbstractMethodDefinition" !== r4.type && "TSDeclareMethod" !== r4.type && "MethodDefinition" !== r4.type)) && (wl(n5, e13), !0);
}
function zl(e13, t9) {
    const { precedingNode: n5 , enclosingNode: r4 , followingNode: o4  } = e13;
    if (n5 && "FunctionTypeParam" === n5.type && r4 && "FunctionTypeAnnotation" === r4.type && o4 && "FunctionTypeParam" !== o4.type) return wl(n5, e13), !0;
    if (n5 && ("Identifier" === n5.type || "AssignmentPattern" === n5.type) && r4 && Kl(r4) && ")" === Fl(t9, e13, _l)) return wl(n5, e13), !0;
    if (r4 && "FunctionDeclaration" === r4.type && o4 && "BlockStatement" === o4.type) {
        const n6 = (()=>{
            const e14 = kl(r4);
            if (0 !== e14.length) return Al(t9, _l(bl(e14)));
            const n7 = Al(t9, _l(r4.id));
            return !1 !== n7 && Al(t9, n7 + 1);
        })();
        if (jl(e13) > n6) return Rl(o4, e13), !0;
    }
    return !1;
}
function Gl(e13) {
    const { enclosingNode: t9  } = e13;
    return !(!t9 || "ImportSpecifier" !== t9.type) && (Sl(t9, e13), !0);
}
function Hl(e13) {
    const { enclosingNode: t9  } = e13;
    return !(!t9 || "LabeledStatement" !== t9.type) && (Sl(t9, e13), !0);
}
function Xl(e13, t9, n5) {
    const { enclosingNode: r4  } = e13;
    return t9 && t9.body && 0 === t9.body.length ? (n5 ? Tl(t9, e13) : Sl(t9, e13), !0) : !(!r4 || "Program" !== r4.type || 0 !== r4.body.length || !r4.directives || 0 !== r4.directives.length) && (n5 ? Tl(r4, e13) : Sl(r4, e13), !0);
}
function Yl(e13) {
    const { enclosingNode: t9 , followingNode: n5  } = e13;
    if (Pl(e13) && t9 && "TSMappedType" === t9.type && n5 && "TSTypeParameter" === n5.type && n5.constraint) return t9.prettierIgnore = !0, e13.unignore = !0, !0;
}
function Ql(e13) {
    return Nl(e13) && "*" === e13.value[0] && /@type\b/.test(e13.value);
}
var Zl = {
    handleOwnLineComment: function(e13, t9, n5, r4, o4) {
        return Yl(e13) || zl(e13, t9) || function(e14) {
            const { enclosingNode: t10 , followingNode: n6  } = e14;
            if (t10 && ("MemberExpression" === t10.type || "OptionalMemberExpression" === t10.type) && n6 && "Identifier" === n6.type) return Sl(t10, e14), !0;
            return !1;
        }(e13) || $l(e13, t9) || ql(e13, t9) || Wl(e13) || Ul(e13) || Gl(e13) || function(e14) {
            const { enclosingNode: t10  } = e14;
            if (t10 && ("ForInStatement" === t10.type || "ForOfStatement" === t10.type)) return Sl(t10, e14), !0;
            return !1;
        }(e13) || function(e14) {
            const { precedingNode: t10 , enclosingNode: n6 , followingNode: r5  } = e14;
            if (n6 && ("UnionTypeAnnotation" === n6.type || "TSUnionType" === n6.type)) return Pl(e14) && (r5.prettierIgnore = !0, e14.unignore = !0), !!t10 && (wl(t10, e14), !0);
            r5 && ("UnionTypeAnnotation" === r5.type || "TSUnionType" === r5.type) && Pl(e14) && (r5.types[0].prettierIgnore = !0, e14.unignore = !0);
            return !1;
        }(e13) || Xl(e13, r4, o4) || function(e14, t10) {
            const { precedingNode: n6 , enclosingNode: r5  } = e14;
            if (n6 && "ImportSpecifier" === n6.type && r5 && "ImportDeclaration" === r5.type && vl(t10, _l(e14))) return wl(n6, e14), !0;
            return !1;
        }(e13, t9) || function(e14) {
            const { enclosingNode: t10  } = e14;
            if (t10 && "AssignmentPattern" === t10.type) return Sl(t10, e14), !0;
            return !1;
        }(e13) || Jl(e13, t9) || Hl(e13);
    },
    handleEndOfLineComment: function(e13, t9, n5, r4, o4) {
        return function(e14) {
            const { followingNode: t10  } = e14;
            if (t10 && Ql(e14)) return Sl(t10, e14), !0;
            return !1;
        }(e13) || zl(e13, t9) || function(e14, t10) {
            const { precedingNode: n6 , enclosingNode: r5 , followingNode: o5  } = e14, u4 = n6 && !xl(t10, _l(n6), jl(e14));
            if ((!n6 || !u4) && r5 && ("ConditionalExpression" === r5.type || "TSConditionalType" === r5.type) && o5) return Sl(o5, e14), !0;
            return !1;
        }(e13, t9) || Gl(e13) || $l(e13, t9) || ql(e13, t9) || Wl(e13) || Ul(e13) || Hl(e13) || function(e14) {
            const { precedingNode: t10 , enclosingNode: n6  } = e14;
            if (n6 && ("CallExpression" === n6.type || "OptionalCallExpression" === n6.type) && t10 && n6.callee === t10 && n6.arguments.length > 0) return Sl(n6.arguments[0], e14), !0;
            return !1;
        }(e13) || function(e14) {
            const { enclosingNode: t10  } = e14;
            if (t10 && ("Property" === t10.type || "ObjectProperty" === t10.type)) return Sl(t10, e14), !0;
            return !1;
        }(e13) || Xl(e13, r4, o4) || function(e14) {
            const { enclosingNode: t10  } = e14;
            if (t10 && "TypeAlias" === t10.type) return Sl(t10, e14), !0;
            return !1;
        }(e13) || function(e14) {
            const { enclosingNode: t10 , followingNode: n6  } = e14;
            if (t10 && ("VariableDeclarator" === t10.type || "AssignmentExpression" === t10.type) && n6 && ("ObjectExpression" === n6.type || "ArrayExpression" === n6.type || "TemplateLiteral" === n6.type || "TaggedTemplateExpression" === n6.type || Nl(e14))) return Sl(n6, e14), !0;
            return !1;
        }(e13);
    },
    handleRemainingComment: function(e13, t9, n5, r4, o4) {
        return !!(Yl(e13) || $l(e13, t9) || ql(e13, t9) || function(e14) {
            const { precedingNode: t10 , enclosingNode: n6  } = e14;
            if (n6 && ("ObjectProperty" === n6.type || "Property" === n6.type) && n6.shorthand && n6.key === t10 && "AssignmentPattern" === n6.value.type) return wl(n6.value.left, e14), !0;
            return !1;
        }(e13) || function(e14, t10) {
            if (")" !== Fl(t10, e14, _l)) return !1;
            const { enclosingNode: n6  } = e14;
            if (n6 && (Kl(n6) && 0 === kl(n6).length || ("CallExpression" === n6.type || "OptionalCallExpression" === n6.type || "NewExpression" === n6.type) && 0 === n6.arguments.length)) return Tl(n6, e14), !0;
            if (n6 && "MethodDefinition" === n6.type && 0 === kl(n6.value).length) return Tl(n6.value, e14), !0;
            return !1;
        }(e13, t9) || Jl(e13, t9) || Xl(e13, r4, o4) || function(e14, t10) {
            const { enclosingNode: n6  } = e14;
            if (!n6 || "ArrowFunctionExpression" !== n6.type) return !1;
            const r5 = Bl(t10, e14, _l);
            if (!1 !== r5 && "=>" === t10.slice(r5, r5 + 2)) return Tl(n6, e14), !0;
            return !1;
        }(e13, t9) || function(e14, t10) {
            if ("(" !== Fl(t10, e14, _l)) return !1;
            const { precedingNode: n6 , enclosingNode: r5  } = e14;
            if (n6 && r5 && ("FunctionDeclaration" === r5.type || "FunctionExpression" === r5.type || "ClassMethod" === r5.type || "MethodDefinition" === r5.type || "ObjectMethod" === r5.type)) return wl(n6, e14), !0;
            return !1;
        }(e13, t9) || function(e14) {
            const { precedingNode: t10 , enclosingNode: n6 , followingNode: r5  } = e14;
            if (!n6 || "TSMappedType" !== n6.type) return !1;
            if (r5 && "TSTypeParameter" === r5.type && r5.name) return Sl(r5.name, e14), !0;
            if (t10 && "TSTypeParameter" === t10.type && t10.constraint) return wl(t10.constraint, e14), !0;
            return !1;
        }(e13) || function(e14) {
            const { enclosingNode: t10  } = e14;
            if (t10 && ("ContinueStatement" === t10.type || "BreakStatement" === t10.type) && !t10.label) return wl(t10, e14), !0;
            return !1;
        }(e13) || function(e14, t10) {
            const { enclosingNode: n6 , followingNode: r5  } = e14;
            if (!r5 && n6 && ("TSMethodSignature" === n6.type || "TSDeclareFunction" === n6.type || "TSAbstractMethodDefinition" === n6.type) && ";" === Fl(t10, e14, _l)) return wl(n6, e14), !0;
            return !1;
        }(e13, t9));
    },
    hasLeadingComment: function(e13, t9 = ()=>!0
    ) {
        return e13.leadingComments ? e13.leadingComments.some(t9) : !!e13.comments && e13.comments.some((e14)=>e14.leading && t9(e14)
        );
    },
    isTypeCastComment: Ql,
    getGapRegex: function(e13) {
        if (e13 && "BinaryExpression" !== e13.type && "LogicalExpression" !== e13.type) return /^[\s&(|]*$/;
    },
    getCommentChildNodes: function(e13, t9) {
        if (("typescript" === t9.parser || "flow" === t9.parser || "espree" === t9.parser || "meriyah" === t9.parser) && "MethodDefinition" === e13.type && e13.value && "FunctionExpression" === e13.value.type && 0 === kl(e13.value).length && !e13.value.returnType && (!e13.value.typeParameters || 0 === e13.value.typeParameters.length) && e13.value.body) return [
            ...e13.decorators || [],
            e13.key,
            e13.value.body
        ];
    },
    willPrintOwnComments: function(e13) {
        const t9 = e13.getValue(), n5 = e13.getParentNode();
        return (t9 && (Ol(t9) || Il(t9) || n5 && ("CallExpression" === n5.type || "OptionalCallExpression" === n5.type) && (Ll(t9.leadingComments) || Ll(t9.trailingComments))) || n5 && ("JSXSpreadAttribute" === n5.type || "JSXSpreadChild" === n5.type || "UnionTypeAnnotation" === n5.type || "TSUnionType" === n5.type || ("ClassDeclaration" === n5.type || "ClassExpression" === n5.type) && n5.superClass === t9)) && (!Ml(e13) || "UnionTypeAnnotation" === n5.type || "TSUnionType" === n5.type);
    }
};
const { getStringWidth: ec , getIndentSize: tc  } = Nt1, { builders: { concat: nc , join: rc , hardline: oc , softline: uc , group: ic , indent: ac , align: sc , lineSuffixBoundary: lc , addAlignmentToDoc: cc  } , printer: { printDocToString: pc  } , utils: { mapDoc: dc  }  } = rn1, { isBinaryish: fc , isJestEachTemplateLiteral: hc , isSimpleTemplateLiteral: mc  } = Cl;
var Dc = {
    printTemplateLiteral: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if ("TemplateLiteral" === r4.type && hc(r4, e13.getParentNode())) {
            const r5 = function(e14, t10, n6) {
                const r6 = e14.getNode(), o4 = r6.quasis[0].value.raw.trim().split(/\s*\|\s*/);
                if (o4.length > 1 || o4.some((e15)=>0 !== e15.length
                )) {
                    t10.__inJestEach = !0;
                    const u4 = e14.map(n6, "expressions");
                    t10.__inJestEach = !1;
                    const i5 = [], a4 = u4.map((e15)=>"${" + pc(e15, Object.assign({
                        }, t10, {
                            printWidth: 1 / 0,
                            endOfLine: "lf"
                        })).formatted + "}"
                    ), s4 = [
                        {
                            hasLineBreak: !1,
                            cells: []
                        }
                    ];
                    for(let e15 = 1; e15 < r6.quasis.length; e15++){
                        const t11 = s4[s4.length - 1], n7 = a4[e15 - 1];
                        t11.cells.push(n7), n7.includes("\n") && (t11.hasLineBreak = !0), r6.quasis[e15].value.raw.includes("\n") && s4.push({
                            hasLineBreak: !1,
                            cells: []
                        });
                    }
                    const l4 = Math.max(o4.length, ...s4.map((e16)=>e16.cells.length
                    )), c4 = Array.from({
                        length: l4
                    }).fill(0), p4 = [
                        {
                            cells: o4
                        },
                        ...s4.filter((e16)=>0 !== e16.cells.length
                        )
                    ];
                    for (const { cells: e16  } of p4.filter((e17)=>!e17.hasLineBreak
                    ))e16.forEach((e17, t11)=>{
                        c4[t11] = Math.max(c4[t11], ec(e17));
                    });
                    return i5.push(lc, "`", ac(nc([
                        oc,
                        rc(oc, p4.map((e17)=>rc(" | ", e17.cells.map((t11, n7)=>e17.hasLineBreak ? t11 : t11 + " ".repeat(c4[n7] - ec(t11))
                            ))
                        ))
                    ])), oc, "`"), nc(i5);
                }
            }(e13, n5, t9);
            if (r5) return r5;
        }
        let o4 = "expressions";
        "TSTemplateLiteralType" === r4.type && (o4 = "types");
        const u4 = [];
        let i5 = e13.map(t9, o4);
        const a4 = mc(r4);
        return (a4 && (i5 = i5.map((e14)=>pc(e14, Object.assign({
            }, n5, {
                printWidth: 1 / 0
            })).formatted
        )), u4.push(lc, "`"), e13.each((e14)=>{
            const s4 = e14.getName();
            if (u4.push(t9(e14)), s4 < i5.length) {
                const { tabWidth: t10  } = n5, l4 = e14.getValue(), c4 = tc(l4.value.raw, t10);
                let p4 = i5[s4];
                if (!a4) {
                    const e15 = r4[o4][s4];
                    (e15.comments && e15.comments.length || "MemberExpression" === e15.type || "OptionalMemberExpression" === e15.type || "ConditionalExpression" === e15.type || "SequenceExpression" === e15.type || "TSAsExpression" === e15.type || fc(e15)) && (p4 = nc([
                        ac(nc([
                            uc,
                            p4
                        ])),
                        uc
                    ]));
                }
                const d4 = 0 === c4 && l4.value.raw.endsWith("\n") ? sc(-1 / 0, p4) : cc(p4, c4, t10);
                u4.push(ic(nc([
                    "${",
                    d4,
                    lc,
                    "}"
                ])));
            }
        }, "quasis"), u4.push("`"), nc(u4));
    },
    printTemplateExpressions: function(e13, t9) {
        return e13.map((e14)=>(function(e15, t10) {
                const n5 = e15.getValue();
                let r4 = t10(e15);
                return n5.comments && n5.comments.length && (r4 = ic(nc([
                    ac(nc([
                        uc,
                        r4
                    ])),
                    uc
                ]))), nc([
                    "${",
                    r4,
                    lc,
                    "}"
                ]);
            })(e14, t9)
        , "expressions");
    },
    escapeTemplateCharacters: function(e13, t9) {
        return dc(e13, (e14)=>{
            if (!e14.parts) return e14;
            const n5 = e14.parts.map((e15)=>"string" == typeof e15 ? t9 ? e15.replace(/(\\*)`/g, "$1$1\\`") : gc(e15) : e15
            );
            return Object.assign({
            }, e14, {
                parts: n5
            });
        });
    },
    uncookTemplateElementValue: gc
};
const { builders: { indent: yc , softline: Ec , literalline: Cc , concat: bc , dedentToRoot: vc  }  } = rn1, { escapeTemplateCharacters: Ac  } = Dc;
var Fc = function(e13, t9, n5) {
    let r4 = e13.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e14, t10)=>"\\".repeat(t10.length / 2) + "`"
    );
    const o4 = function(e14) {
        const t10 = e14.match(/^([^\S\n]*)\S/m);
        return null === t10 ? "" : t10[1];
    }(r4), u4 = "" !== o4;
    u4 && (r4 = r4.replace(new RegExp("^".concat(o4), "gm"), ""));
    const i5 = Ac(n5(r4, {
        parser: "markdown",
        __inJsTemplate: !0
    }, {
        stripTrailingHardline: !0
    }), !0);
    return bc([
        "`",
        u4 ? yc(bc([
            Ec,
            i5
        ])) : bc([
            Cc,
            vc(i5)
        ]),
        Ec,
        "`"
    ]);
};
const { builders: { indent: xc , hardline: Sc , softline: wc , concat: Tc  } , utils: { mapDoc: Bc , replaceNewlinesWithLiterallines: Nc  }  } = rn1, { printTemplateExpressions: kc  } = Dc;
var Pc = function(e13, t9, n5) {
    const r4 = e13.getValue(), o4 = r4.quasis.map((e14)=>e14.value.raw
    );
    let u4 = 0;
    return function(e14, t10, n6) {
        if (1 === t10.quasis.length && !t10.quasis[0].value.raw.trim()) return "``";
        const r5 = function(e15, t11) {
            if (!t11 || !t11.length) return e15;
            let n7 = 0;
            const r6 = Bc(e15, (e16)=>{
                if (!e16 || !e16.parts || !e16.parts.length) return e16;
                let { parts: r7  } = e16;
                const o5 = r7.indexOf("@"), u5 = o5 + 1;
                if (o5 > -1 && "string" == typeof r7[u5] && r7[u5].startsWith("prettier-placeholder")) {
                    const e17 = r7[o5], t12 = r7[u5], n8 = r7.slice(u5 + 1);
                    r7 = r7.slice(0, o5).concat([
                        e17 + t12
                    ]).concat(n8);
                }
                const i5 = [];
                return r7.forEach((e17)=>{
                    "string" == typeof e17 && e17.includes("@prettier-placeholder") ? e17.split(/@prettier-placeholder-(\d+)-id/).forEach((e18, r8)=>{
                        r8 % 2 != 0 ? (i5.push(t11[e18]), n7++) : i5.push(Nc(e18));
                    }) : i5.push(e17);
                }), Object.assign({
                }, e16, {
                    parts: i5
                });
            });
            return t11.length === n7 ? r6 : null;
        }(e14, n6);
        if (!r5) throw new Error("Couldn't insert all the expressions");
        return Tc([
            "`",
            xc(Tc([
                Sc,
                r5
            ])),
            wc,
            "`"
        ]);
    }(n5(o4.reduce((e14, t10, n6)=>0 === n6 ? t10 : e14 + "@prettier-placeholder-" + u4++ + "-id" + t10
    , ""), {
        parser: "scss"
    }, {
        stripTrailingHardline: !0
    }), r4, kc(e13, t9));
};
const { builders: { indent: Oc , join: Ic , hardline: Lc , concat: Mc  }  } = rn1, { escapeTemplateCharacters: jc , printTemplateExpressions: _c  } = Dc;
function Rc(e13) {
    const t9 = [];
    let n5 = !1;
    return e13.map((e14)=>e14.trim()
    ).forEach((e14, r4, o4)=>{
        "" !== e14 && ("" === o4[r4 - 1] && n5 ? t9.push(Mc([
            Lc,
            e14
        ])) : t9.push(e14), n5 = !0);
    }), 0 === t9.length ? null : Ic(Lc, t9);
}
var Vc = function(e13, t9, n5) {
    const r4 = e13.getValue(), o4 = r4.quasis.length;
    if (1 === o4 && "" === r4.quasis[0].value.raw.trim()) return "``";
    const u4 = _c(e13, t9), i5 = [];
    for(let e14 = 0; e14 < o4; e14++){
        const t10 = 0 === e14, a4 = e14 === o4 - 1, s4 = r4.quasis[e14].value.cooked, l4 = s4.split("\n"), c4 = l4.length, p4 = u4[e14], d4 = c4 > 2 && "" === l4[0].trim() && "" === l4[1].trim(), f4 = c4 > 2 && "" === l4[c4 - 1].trim() && "" === l4[c4 - 2].trim(), h4 = l4.every((e15)=>/^\s*(?:#[^\n\r]*)?$/.test(e15)
        );
        if (!a4 && /#[^\n\r]*$/.test(l4[c4 - 1])) return null;
        let m4 = null;
        m4 = h4 ? Rc(l4) : n5(s4, {
            parser: "graphql"
        }, {
            stripTrailingHardline: !0
        }), m4 ? (m4 = jc(m4, !1), !t10 && d4 && i5.push(""), i5.push(m4), !a4 && f4 && i5.push("")) : t10 || a4 || !d4 || i5.push(""), p4 && i5.push(p4);
    }
    return Mc([
        "`",
        Oc(Mc([
            Lc,
            Ic(Lc, i5)
        ])),
        Lc,
        "`"
    ]);
};
const { builders: { indent: $c , line: qc , hardline: Wc , concat: Uc , group: Jc  } , utils: { mapDoc: zc  }  } = rn1, { printTemplateExpressions: Gc , uncookTemplateElementValue: Hc  } = Dc;
var Yc = function(e13, t9, n5, r4, { parser: o4  }) {
    const u4 = e13.getValue(), i5 = Xc;
    Xc = Xc + 1 >>> 0;
    const a4 = (e14)=>"PRETTIER_HTML_PLACEHOLDER_".concat(e14, "_").concat(Xc, "_IN_JS")
    , s4 = u4.quasis.map((e14, t10, n6)=>t10 === n6.length - 1 ? e14.value.cooked : e14.value.cooked + a4(t10)
    ).join(""), l4 = Gc(e13, t9);
    if (0 === l4.length && 0 === s4.trim().length) return "``";
    const c4 = new RegExp(a4("(\\d+)"), "g");
    let p4 = 0;
    const d4 = n5(s4, {
        parser: o4,
        __onHtmlRoot (e) {
            p4 = e.children.length;
        }
    }, {
        stripTrailingHardline: !0
    }), f4 = zc(d4, (e14)=>{
        if ("string" != typeof e14) return e14;
        const t10 = [], n6 = e14.split(c4);
        for(let e15 = 0; e15 < n6.length; e15++){
            let o5 = n6[e15];
            if (e15 % 2 == 0) {
                o5 && (o5 = Hc(o5), r4.embeddedInHtml && (o5 = o5.replace(/<\/(script)\b/gi, "<\\/$1")), t10.push(o5));
                continue;
            }
            const u5 = +o5;
            t10.push(l4[u5]);
        }
        return Uc(t10);
    }), h4 = /^\s/.test(s4) ? " " : "", m4 = /\s$/.test(s4) ? " " : "", g4 = "ignore" === r4.htmlWhitespaceSensitivity ? Wc : h4 && m4 ? qc : null;
    return Jc(Uc(g4 ? [
        "`",
        $c(Uc([
            g4,
            Jc(f4)
        ])),
        g4,
        "`"
    ] : [
        "`",
        h4,
        p4 > 1 ? $c(Jc(f4)) : Jc(f4),
        m4,
        "`"
    ]));
};
const { isBlockComment: Kc  } = Cl, { hasLeadingComment: Qc  } = Zl;
function Zc(e13) {
    return (function(e14) {
        const t9 = e14.getValue(), n5 = e14.getParentNode(), r4 = e14.getParentNode(1);
        return r4 && t9.quasis && "JSXExpressionContainer" === n5.type && "JSXElement" === r4.type && "style" === r4.openingElement.name.name && r4.openingElement.attributes.some((e15)=>"jsx" === e15.name.name
        ) || n5 && "TaggedTemplateExpression" === n5.type && "Identifier" === n5.tag.type && "css" === n5.tag.name || n5 && "TaggedTemplateExpression" === n5.type && "MemberExpression" === n5.tag.type && "css" === n5.tag.object.name && ("global" === n5.tag.property.name || "resolve" === n5.tag.property.name);
    })(e13) || (function(e14) {
        const t9 = e14.getParentNode();
        if (!t9 || "TaggedTemplateExpression" !== t9.type) return !1;
        const { tag: n5  } = t9;
        switch(n5.type){
            case "MemberExpression":
                return tp(n5.object) || np(n5);
            case "CallExpression":
                return tp(n5.callee) || "MemberExpression" === n5.callee.type && ("MemberExpression" === n5.callee.object.type && (tp(n5.callee.object.object) || np(n5.callee.object)) || "CallExpression" === n5.callee.object.type && tp(n5.callee.object.callee));
            case "Identifier":
                return "css" === n5.name;
            default:
                return !1;
        }
    })(e13) || (function(e14) {
        const t9 = e14.getParentNode(), n5 = e14.getParentNode(1);
        return n5 && "JSXExpressionContainer" === t9.type && "JSXAttribute" === n5.type && "JSXIdentifier" === n5.name.type && "css" === n5.name.name;
    })(e13) || (function(e14) {
        return e14.match((e15)=>"TemplateLiteral" === e15.type
        , (e15, t9)=>"ArrayExpression" === e15.type && "elements" === t9
        , (e15, t9)=>("Property" === e15.type || "ObjectProperty" === e15.type) && "Identifier" === e15.key.type && "styles" === e15.key.name && "value" === t9
        , ...ep);
    })(e13) ? "css" : (function(e14) {
        const t9 = e14.getValue(), n5 = e14.getParentNode();
        return rp(t9, "GraphQL") || n5 && ("TaggedTemplateExpression" === n5.type && ("MemberExpression" === n5.tag.type && "graphql" === n5.tag.object.name && "experimental" === n5.tag.property.name || "Identifier" === n5.tag.type && ("gql" === n5.tag.name || "graphql" === n5.tag.name)) || "CallExpression" === n5.type && "Identifier" === n5.callee.type && "graphql" === n5.callee.name);
    })(e13) ? "graphql" : (function(e14) {
        return rp(e14.getValue(), "HTML") || e14.match((e15)=>"TemplateLiteral" === e15.type
        , (e15, t9)=>"TaggedTemplateExpression" === e15.type && "Identifier" === e15.tag.type && "html" === e15.tag.name && "quasi" === t9
        );
    })(e13) ? "html" : (function(e14) {
        return e14.match((e15)=>"TemplateLiteral" === e15.type
        , (e15, t9)=>("Property" === e15.type || "ObjectProperty" === e15.type) && "Identifier" === e15.key.type && "template" === e15.key.name && "value" === t9
        , ...ep);
    })(e13) ? "angular" : (function(e14) {
        const t9 = e14.getValue(), n5 = e14.getParentNode();
        return n5 && "TaggedTemplateExpression" === n5.type && 1 === t9.quasis.length && "Identifier" === n5.tag.type && ("md" === n5.tag.name || "markdown" === n5.tag.name);
    })(e13) ? "markdown" : void 0;
}
function rp(e13, t9) {
    return Qc(e13, (e14)=>Kc(e14) && e14.value === " ".concat(t9, " ")
    );
}
var op = function(e13, t9, n5, r4) {
    const o4 = e13.getValue();
    if ("TemplateLiteral" !== o4.type || function({ quasis: e14  }) {
        return e14.some(({ value: { cooked: e15  }  })=>null === e15
        );
    }(o4)) return;
    const u4 = Zc(e13);
    return u4 ? "markdown" === u4 ? Fc(e13, t9, n5) : "css" === u4 ? Pc(e13, t9, n5) : "graphql" === u4 ? Vc(e13, t9, n5) : "html" === u4 || "angular" === u4 ? Yc(e13, t9, n5, r4, {
        parser: u4
    }) : void 0 : void 0;
};
const { isBlockComment: up  } = Cl, ip = new Set([
    "range",
    "raw",
    "comments",
    "leadingComments",
    "trailingComments",
    "innerComments",
    "extra",
    "start",
    "end",
    "loc",
    "flags",
    "errors",
    "tokens"
]);
function ap(e13, t9, n5) {
    if ("Program" === e13.type && delete t9.sourceType, "BigIntLiteral" !== e13.type && "BigIntLiteralTypeAnnotation" !== e13.type || t9.value && (t9.value = t9.value.toLowerCase()), "BigIntLiteral" !== e13.type && "Literal" !== e13.type || t9.bigint && (t9.bigint = t9.bigint.toLowerCase()), "DecimalLiteral" === e13.type && (t9.value = Number(t9.value)), "EmptyStatement" === e13.type) return null;
    if ("JSXText" === e13.type) return null;
    if ("JSXExpressionContainer" === e13.type && ("Literal" === e13.expression.type || "StringLiteral" === e13.expression.type) && " " === e13.expression.value) return null;
    if ("Property" !== e13.type && "ObjectProperty" !== e13.type && "MethodDefinition" !== e13.type && "ClassProperty" !== e13.type && "ClassMethod" !== e13.type && "FieldDefinition" !== e13.type && "TSDeclareMethod" !== e13.type && "TSPropertySignature" !== e13.type && "ObjectTypeProperty" !== e13.type || "object" != typeof e13.key || !e13.key || "Literal" !== e13.key.type && "NumericLiteral" !== e13.key.type && "StringLiteral" !== e13.key.type && "Identifier" !== e13.key.type || delete t9.key, "OptionalMemberExpression" === e13.type && !1 === e13.optional && (t9.type = "MemberExpression", delete t9.optional), "JSXElement" === e13.type && "style" === e13.openingElement.name.name && e13.openingElement.attributes.some((e14)=>"jsx" === e14.name.name
    )) {
        t9.children.filter((e14)=>"JSXExpressionContainer" === e14.type && "TemplateLiteral" === e14.expression.type
        ).map((e14)=>e14.expression
        ).reduce((e14, t10)=>e14.concat(t10.quasis)
        , []).forEach((e14)=>delete e14.value
        );
    }
    "JSXAttribute" === e13.type && "css" === e13.name.name && "JSXExpressionContainer" === e13.value.type && "TemplateLiteral" === e13.value.expression.type && t9.value.expression.quasis.forEach((e14)=>delete e14.value
    ), "JSXAttribute" === e13.type && e13.value && "Literal" === e13.value.type && /["']|&quot;|&apos;/.test(e13.value.value) && (t9.value.value = t9.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    const r4 = e13.expression || e13.callee;
    if ("Decorator" === e13.type && "CallExpression" === r4.type && "Component" === r4.callee.name && 1 === r4.arguments.length) {
        const n6 = e13.expression.arguments[0].properties;
        t9.expression.arguments[0].properties.forEach((e14, t10)=>{
            let r5 = null;
            switch(n6[t10].key.name){
                case "styles":
                    "ArrayExpression" === e14.value.type && (r5 = e14.value.elements[0]);
                    break;
                case "template":
                    "TemplateLiteral" === e14.value.type && (r5 = e14.value);
            }
            r5 && r5.quasis.forEach((e15)=>delete e15.value
            );
        });
    }
    if ("TaggedTemplateExpression" !== e13.type || "MemberExpression" !== e13.tag.type && ("Identifier" !== e13.tag.type || "gql" !== e13.tag.name && "graphql" !== e13.tag.name && "css" !== e13.tag.name && "md" !== e13.tag.name && "markdown" !== e13.tag.name && "html" !== e13.tag.name) && "CallExpression" !== e13.tag.type || t9.quasi.quasis.forEach((e14)=>delete e14.value
    ), "TemplateLiteral" === e13.type) {
        (e13.leadingComments && e13.leadingComments.some((e14)=>up(e14) && [
                "GraphQL",
                "HTML"
            ].some((t10)=>e14.value === " ".concat(t10, " ")
            )
        ) || "CallExpression" === n5.type && "graphql" === n5.callee.name) && t9.quasis.forEach((e14)=>delete e14.value
        ), e13.leadingComments || t9.quasis.forEach((e14)=>{
            e14.value && delete e14.value.cooked;
        });
    }
    "InterpreterDirective" === e13.type && (t9.value = t9.value.trimEnd());
}
ap.ignoredProperties = ip;
var sp = ap;
var pp = je(function(e13, t9) {
    function n5() {
        const e14 = Mr;
        return (n5 = function() {
            return Mr;
        }, Mr);
    }
    function r4() {
        const e14 = (t10 = cp) && t10.__esModule ? t10 : {
            default: t10
        };
        var t10;
        return (r4 = function() {
            return e14;
        }, e14);
    }
    Object.defineProperty(t9, "__esModule", {
        value: !0
    }), t9.extract = function(e14) {
        const t10 = e14.match(i5);
        return t10 ? t10[0].trimLeft() : "";
    }, t9.strip = function(e14) {
        const t10 = e14.match(i5);
        return t10 && t10[0] ? e14.substring(t10[0].length) : e14;
    }, t9.parse = function(e14) {
        return f4(e14).pragmas;
    }, t9.parseWithComments = f4, t9.print = function({ comments: e14 = "" , pragmas: t10 = {
    }  }) {
        const o4 = r4().default(e14) || n5().EOL, u4 = " *", i5 = Object.keys(t10), a4 = i5.map((e15)=>h4(e15, t10[e15])
        ).reduce((e15, t11)=>e15.concat(t11)
        , []).map((e15)=>" * " + e15 + o4
        ).join("");
        if (!e14) {
            if (0 === i5.length) return "";
            if (1 === i5.length && !Array.isArray(t10[i5[0]])) {
                const e15 = t10[i5[0]];
                return "".concat("/**", " ").concat(h4(i5[0], e15)[0]).concat(" */");
            }
        }
        const s4 = e14.split(o4).map((e15)=>"".concat(u4, " ").concat(e15)
        ).join(o4) + o4;
        return "/**" + o4 + (e14 ? s4 : "") + (e14 && i5.length ? u4 + o4 : "") + a4 + " */";
    };
    const o4 = /\*\/$/, u4 = /^\/\*\*/, i5 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a4 = /(^|\s+)\/\/([^\r\n]*)/g, s4 = /^(\r?\n)+/, l4 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c4 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p4 = /(\r?\n|^) *\* ?/g, d4 = [];
    function f4(e14) {
        const t10 = r4().default(e14) || n5().EOL;
        e14 = e14.replace(u4, "").replace(o4, "").replace(p4, "$1");
        let i6 = "";
        for(; i6 !== e14;)i6 = e14, e14 = e14.replace(l4, "".concat(t10, "$1 $2").concat(t10));
        e14 = e14.replace(s4, "").trimRight();
        const f5 = Object.create(null), h4 = e14.replace(c4, "").replace(s4, "").trimRight();
        let m4;
        for(; m4 = c4.exec(e14);){
            const e15 = m4[2].replace(a4, "");
            "string" == typeof f5[m4[1]] || Array.isArray(f5[m4[1]]) ? f5[m4[1]] = d4.concat(f5[m4[1]], e15) : f5[m4[1]] = e15;
        }
        return {
            comments: h4,
            pragmas: f5
        };
    }
    function h4(e14, t10) {
        return d4.concat(t10).map((t11)=>"@".concat(e14, " ").concat(t11).trim()
        );
    }
});
const { parseWithComments: dp , strip: fp , extract: hp , print: mp  } = pp, { getShebang: gp  } = Nt1, { normalizeEndOfLine: Dp  } = kt;
function yp(e13) {
    const t9 = gp(e13);
    t9 && (e13 = e13.slice(t9.length + 1));
    const n5 = hp(e13), { pragmas: r4 , comments: o4  } = dp(n5);
    return {
        shebang: t9,
        text: e13,
        pragmas: r4,
        comments: o4
    };
}
var Ep = {
    hasPragma: function(e13) {
        const t9 = Object.keys(yp(e13).pragmas);
        return t9.includes("prettier") || t9.includes("format");
    },
    insertPragma: function(e13) {
        const { shebang: t9 , text: n5 , pragmas: r4 , comments: o4  } = yp(e13), u4 = fp(n5), i5 = mp({
            pragmas: Object.assign({
                format: ""
            }, r4),
            comments: o4.trimStart()
        });
        return (t9 ? "".concat(t9, "\n") : "") + Dp(i5) + (u4.startsWith("\n") ? "\n" : "\n\n") + u4;
    }
};
const { getFunctionParameters: Cp , getLeftSidePathName: bp , hasFlowShorthandAnnotationComment: vp , hasNakedLeftSide: Ap , hasNode: Fp , isBitwiseOperator: xp , startsWithNoLookaheadToken: Sp , shouldFlatten: wp , getPrecedence: Tp  } = Cl;
function Bp(e13, t9) {
    const n5 = e13.getParentNode();
    if (!n5) return !1;
    const r4 = e13.getName(), o4 = e13.getNode();
    if (t9.__isInHtmlInterpolation && !t9.bracketSpacing && (function(e14) {
        switch(e14.type){
            case "ObjectExpression":
                return !0;
            default:
                return !1;
        }
    })(o4) && Np(e13)) return !0;
    if ((function(e14) {
        return "BlockStatement" === e14.type || "BreakStatement" === e14.type || "ClassBody" === e14.type || "ClassDeclaration" === e14.type || "ClassMethod" === e14.type || "ClassProperty" === e14.type || "FieldDefinition" === e14.type || "ClassPrivateProperty" === e14.type || "ContinueStatement" === e14.type || "DebuggerStatement" === e14.type || "DeclareClass" === e14.type || "DeclareExportAllDeclaration" === e14.type || "DeclareExportDeclaration" === e14.type || "DeclareFunction" === e14.type || "DeclareInterface" === e14.type || "DeclareModule" === e14.type || "DeclareModuleExports" === e14.type || "DeclareVariable" === e14.type || "DoWhileStatement" === e14.type || "EnumDeclaration" === e14.type || "ExportAllDeclaration" === e14.type || "ExportDefaultDeclaration" === e14.type || "ExportNamedDeclaration" === e14.type || "ExpressionStatement" === e14.type || "ForInStatement" === e14.type || "ForOfStatement" === e14.type || "ForStatement" === e14.type || "FunctionDeclaration" === e14.type || "IfStatement" === e14.type || "ImportDeclaration" === e14.type || "InterfaceDeclaration" === e14.type || "LabeledStatement" === e14.type || "MethodDefinition" === e14.type || "ReturnStatement" === e14.type || "SwitchStatement" === e14.type || "ThrowStatement" === e14.type || "TryStatement" === e14.type || "TSDeclareFunction" === e14.type || "TSEnumDeclaration" === e14.type || "TSImportEqualsDeclaration" === e14.type || "TSInterfaceDeclaration" === e14.type || "TSModuleDeclaration" === e14.type || "TSNamespaceExportDeclaration" === e14.type || "TypeAlias" === e14.type || "VariableDeclaration" === e14.type || "WhileStatement" === e14.type || "WithStatement" === e14.type;
    })(o4)) return !1;
    if ("flow" !== t9.parser && vp(e13.getValue())) return !0;
    if ("Identifier" === o4.type) return !!(o4.extra && o4.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o4.name));
    switch(n5.type){
        case "ParenthesizedExpression":
            return !1;
        case "ClassDeclaration":
        case "ClassExpression":
            if ("superClass" === r4 && ("ArrowFunctionExpression" === o4.type || "AssignmentExpression" === o4.type || "AwaitExpression" === o4.type || "BinaryExpression" === o4.type || "ConditionalExpression" === o4.type || "LogicalExpression" === o4.type || "NewExpression" === o4.type || "ObjectExpression" === o4.type || "ParenthesizedExpression" === o4.type || "SequenceExpression" === o4.type || "TaggedTemplateExpression" === o4.type || "UnaryExpression" === o4.type || "UpdateExpression" === o4.type || "YieldExpression" === o4.type)) return !0;
            break;
        case "ExportDefaultDeclaration":
            return kp(e13, t9) || "SequenceExpression" === o4.type;
        case "Decorator":
            if ("expression" === r4) {
                let e14 = !1, t10 = !1, n6 = o4;
                for(; n6;)switch(n6.type){
                    case "MemberExpression":
                        t10 = !0, n6 = n6.object;
                        break;
                    case "CallExpression":
                        if (t10 || e14) return !0;
                        e14 = !0, n6 = n6.callee;
                        break;
                    case "Identifier":
                        return !1;
                    default:
                        return !0;
                }
                return !0;
            }
            break;
        case "ExpressionStatement":
            if (Sp(o4, !0)) return !0;
            break;
        case "ArrowFunctionExpression":
            if ("body" === r4 && "SequenceExpression" !== o4.type && Sp(o4, !1)) return !0;
    }
    switch(o4.type){
        case "SpreadElement":
        case "SpreadProperty":
            return "object" === r4 && "MemberExpression" === n5.type;
        case "UpdateExpression":
            if ("UnaryExpression" === n5.type) return o4.prefix && ("++" === o4.operator && "+" === n5.operator || "--" === o4.operator && "-" === n5.operator);
        case "UnaryExpression":
            switch(n5.type){
                case "UnaryExpression":
                    return o4.operator === n5.operator && ("+" === o4.operator || "-" === o4.operator);
                case "BindExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r4;
                case "TaggedTemplateExpression":
                    return !0;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "BinaryExpression":
                    return "left" === r4 && "**" === n5.operator;
                case "TSNonNullExpression":
                    return !0;
                default:
                    return !1;
            }
        case "BinaryExpression":
            if ("UpdateExpression" === n5.type || "PipelineTopicExpression" === n5.type && "|>" === o4.operator) return !0;
            if ("in" === o4.operator && (function(e14) {
                let t10 = 0, n6 = e14.getValue();
                for(; n6;){
                    const r5 = e14.getParentNode(t10++);
                    if (r5 && "ForStatement" === r5.type && r5.init === n6) return !0;
                    n6 = r5;
                }
                return !1;
            })(e13)) return !0;
            if ("|>" === o4.operator && o4.extra && o4.extra.parenthesized) {
                const t10 = e13.getParentNode(1);
                if ("BinaryExpression" === t10.type && "|>" === t10.operator) return !0;
            }
        case "TSTypeAssertion":
        case "TSAsExpression":
        case "LogicalExpression":
            switch(n5.type){
                case "ConditionalExpression":
                    return "TSAsExpression" === o4.type;
                case "CallExpression":
                case "NewExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "ClassExpression":
                case "ClassDeclaration":
                    return "superClass" === r4;
                case "TSTypeAssertion":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "JSXSpreadAttribute":
                case "SpreadElement":
                case "SpreadProperty":
                case "BindExpression":
                case "AwaitExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "UpdateExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r4;
                case "AssignmentExpression":
                    return "left" === r4 && ("TSTypeAssertion" === o4.type || "TSAsExpression" === o4.type);
                case "LogicalExpression":
                    if ("LogicalExpression" === o4.type) return n5.operator !== o4.operator;
                case "BinaryExpression":
                    {
                        const { operator: e14 , type: t10  } = o4;
                        if (!e14 && "TSTypeAssertion" !== t10) return !0;
                        const u4 = Tp(e14), i5 = n5.operator, a4 = Tp(i5);
                        return a4 > u4 || ("right" === r4 && a4 === u4 || (a4 === u4 && !wp(i5, e14) || (a4 < u4 && "%" === e14 ? "+" === i5 || "-" === i5 : !!xp(i5))));
                    }
                default:
                    return !1;
            }
        case "SequenceExpression":
            switch(n5.type){
                case "ReturnStatement":
                case "ForStatement":
                    return !1;
                case "ExpressionStatement":
                    return "expression" !== r4;
                case "ArrowFunctionExpression":
                    return "body" !== r4;
                default:
                    return !0;
            }
        case "YieldExpression":
            if ("UnaryExpression" === n5.type || "AwaitExpression" === n5.type || "TSAsExpression" === n5.type || "TSNonNullExpression" === n5.type) return !0;
        case "AwaitExpression":
            switch(n5.type){
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "BindExpression":
                    return !0;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r4;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "ConditionalExpression":
                    return "test" === r4;
                case "BinaryExpression":
                    return !(!o4.argument && "|>" === n5.operator);
                default:
                    return !1;
            }
        case "TSJSDocFunctionType":
        case "TSConditionalType":
            if ("extendsType" === r4 && "TSConditionalType" === n5.type) return !0;
        case "TSFunctionType":
        case "TSConstructorType":
            if ("checkType" === r4 && "TSConditionalType" === n5.type) return !0;
        case "TSUnionType":
        case "TSIntersectionType":
            if ("TSUnionType" === n5.type || "TSIntersectionType" === n5.type) return !0;
        case "TSInferType":
            if ("TSInferType" === o4.type && "TSRestType" === n5.type) return !1;
        case "TSTypeOperator":
            return "TSArrayType" === n5.type || "TSOptionalType" === n5.type || "TSRestType" === n5.type || "objectType" === r4 && "TSIndexedAccessType" === n5.type || "TSTypeOperator" === n5.type || "TSTypeAnnotation" === n5.type && /^TSJSDoc/.test(e13.getParentNode(1).type);
        case "ArrayTypeAnnotation":
            return "NullableTypeAnnotation" === n5.type;
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
            return "ArrayTypeAnnotation" === n5.type || "NullableTypeAnnotation" === n5.type || "IntersectionTypeAnnotation" === n5.type || "UnionTypeAnnotation" === n5.type;
        case "NullableTypeAnnotation":
            return "ArrayTypeAnnotation" === n5.type;
        case "FunctionTypeAnnotation":
            {
                const t10 = "NullableTypeAnnotation" === n5.type ? e13.getParentNode(1) : n5;
                return "UnionTypeAnnotation" === t10.type || "IntersectionTypeAnnotation" === t10.type || "ArrayTypeAnnotation" === t10.type || "NullableTypeAnnotation" === t10.type || "FunctionTypeParam" === n5.type && null === n5.name && Cp(o4).some((e14)=>e14.typeAnnotation && "NullableTypeAnnotation" === e14.typeAnnotation.type
                );
            }
        case "StringLiteral":
        case "NumericLiteral":
        case "Literal":
            if ("string" == typeof o4.value && "ExpressionStatement" === n5.type && !n5.directive) {
                const t10 = e13.getParentNode(1);
                return "Program" === t10.type || "BlockStatement" === t10.type;
            }
            return "object" === r4 && "MemberExpression" === n5.type && "number" == typeof o4.value;
        case "AssignmentExpression":
            {
                const t10 = e13.getParentNode(1);
                return "body" === r4 && "ArrowFunctionExpression" === n5.type || ("key" !== r4 || "ClassProperty" !== n5.type && "FieldDefinition" !== n5.type || !n5.computed) && (("init" !== r4 && "update" !== r4 || "ForStatement" !== n5.type) && ("ExpressionStatement" === n5.type ? "ObjectPattern" === o4.left.type : ("key" !== r4 || "TSPropertySignature" !== n5.type) && ("AssignmentExpression" !== n5.type && (("SequenceExpression" !== n5.type || !t10 || "ForStatement" !== t10.type || t10.init !== n5 && t10.update !== n5) && (("value" !== r4 || "Property" !== n5.type || !t10 || "ObjectPattern" !== t10.type || !t10.properties.includes(n5)) && "NGChainedExpression" !== n5.type)))));
            }
        case "ConditionalExpression":
            switch(n5.type){
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "SpreadElement":
                case "SpreadProperty":
                case "BinaryExpression":
                case "LogicalExpression":
                case "NGPipeExpression":
                case "ExportDefaultDeclaration":
                case "AwaitExpression":
                case "JSXSpreadAttribute":
                case "TSTypeAssertion":
                case "TypeCastExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                    return !0;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "ConditionalExpression":
                    return "test" === r4;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r4;
                default:
                    return !1;
            }
        case "FunctionExpression":
            switch(n5.type){
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "TaggedTemplateExpression":
                    return !0;
                default:
                    return !1;
            }
        case "ArrowFunctionExpression":
            switch(n5.type){
                case "PipelineTopicExpression":
                    return !(!o4.extra || !o4.extra.parenthesized);
                case "BinaryExpression":
                    return "|>" !== n5.operator || o4.extra && o4.extra.parenthesized;
                case "NewExpression":
                case "CallExpression":
                case "OptionalCallExpression":
                    return "callee" === r4;
                case "MemberExpression":
                case "OptionalMemberExpression":
                    return "object" === r4;
                case "TSAsExpression":
                case "BindExpression":
                case "TaggedTemplateExpression":
                case "UnaryExpression":
                case "LogicalExpression":
                case "AwaitExpression":
                case "TSTypeAssertion":
                    return !0;
                case "ConditionalExpression":
                    return "test" === r4;
                default:
                    return !1;
            }
        case "ClassExpression":
            switch(n5.type){
                case "NewExpression":
                    return "callee" === r4;
                default:
                    return !1;
            }
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
            {
                const t10 = e13.getParentNode(1);
                if ("object" === r4 && "MemberExpression" === n5.type || "callee" === r4 && ("CallExpression" === n5.type || "NewExpression" === n5.type) || "TSNonNullExpression" === n5.type && "MemberExpression" === t10.type && t10.object === n5) return !0;
            }
        case "CallExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "TSNonNullExpression":
            if ("callee" === r4 && ("BindExpression" === n5.type || "NewExpression" === n5.type)) {
                let e14 = o4;
                for(; e14;)switch(e14.type){
                    case "CallExpression":
                    case "OptionalCallExpression":
                        return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "BindExpression":
                        e14 = e14.object;
                        break;
                    case "TaggedTemplateExpression":
                        e14 = e14.tag;
                        break;
                    case "TSNonNullExpression":
                        e14 = e14.expression;
                        break;
                    default:
                        return !1;
                }
            }
            return !1;
        case "BindExpression":
            return "callee" === r4 && ("BindExpression" === n5.type || "NewExpression" === n5.type) || "object" === r4 && ("MemberExpression" === n5.type || "OptionalMemberExpression" === n5.type);
        case "NGPipeExpression":
            return !("NGRoot" === n5.type || "NGMicrosyntaxExpression" === n5.type || !("ObjectProperty" !== n5.type || o4.extra && o4.extra.parenthesized) || "ArrayExpression" === n5.type || ("CallExpression" === n5.type || "OptionalCallExpression" === n5.type) && n5.arguments[r4] === o4 || "right" === r4 && "NGPipeExpression" === n5.type || "property" === r4 && "MemberExpression" === n5.type || "AssignmentExpression" === n5.type);
        case "JSXFragment":
        case "JSXElement":
            return "callee" === r4 || "left" === r4 && "BinaryExpression" === n5.type && "<" === n5.operator || "ArrayExpression" !== n5.type && "ArrowFunctionExpression" !== n5.type && "AssignmentExpression" !== n5.type && "AssignmentPattern" !== n5.type && "BinaryExpression" !== n5.type && "CallExpression" !== n5.type && "NewExpression" !== n5.type && "ConditionalExpression" !== n5.type && "ExpressionStatement" !== n5.type && "JsExpressionRoot" !== n5.type && "JSXAttribute" !== n5.type && "JSXElement" !== n5.type && "JSXExpressionContainer" !== n5.type && "JSXFragment" !== n5.type && "LogicalExpression" !== n5.type && "ObjectProperty" !== n5.type && "OptionalCallExpression" !== n5.type && "Property" !== n5.type && "ReturnStatement" !== n5.type && "ThrowStatement" !== n5.type && "TypeCastExpression" !== n5.type && "VariableDeclarator" !== n5.type && "YieldExpression" !== n5.type;
        case "TypeAnnotation":
            return "returnType" === r4 && "ArrowFunctionExpression" === n5.type && (function(e14) {
                return Fp(e14, (e15)=>"ObjectTypeAnnotation" === e15.type && Fp(e15, (e16)=>"FunctionTypeAnnotation" === e16.type || void 0
                    ) || void 0
                );
            })(o4);
    }
    return !1;
}
function kp(e13, t9) {
    const n5 = e13.getValue(), r4 = e13.getParentNode();
    return "FunctionExpression" === n5.type || "ClassExpression" === n5.type ? "ExportDefaultDeclaration" === r4.type || !Bp(e13, t9) : !(!Ap(n5) || "ExportDefaultDeclaration" !== r4.type && Bp(e13, t9)) && e13.call((e14)=>kp(e14, t9)
    , ...bp(e13, n5));
}
var Pp = Bp;
const { builders: { concat: Op , join: Ip , line: Lp , group: Mp , softline: jp , indent: _p  }  } = rn1;
var Rp = {
    isVueEventBindingExpression: function e13(t9) {
        switch(t9.type){
            case "MemberExpression":
                switch(t9.property.type){
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                        return e13(t9.object);
                }
                return !1;
            case "Identifier":
                return !0;
            default:
                return !1;
        }
    },
    printHtmlBinding: function(e14, t9, n5) {
        const r4 = e14.getValue();
        if ((t9.__onHtmlBindingRoot && null === e14.getName() && t9.__onHtmlBindingRoot(r4, t9), "File" === r4.type)) return t9.__isVueForBindingLeft ? e14.call((e15)=>{
            const t10 = Ip(Op([
                ",",
                Lp
            ]), e15.map(n5, "params")), { params: r5  } = e15.getValue();
            return 1 === r5.length ? t10 : Op([
                "(",
                _p(Op([
                    jp,
                    Mp(t10)
                ])),
                jp,
                ")"
            ]);
        }, "program", "body", 0) : t9.__isVueBindings ? e14.call((e15)=>Ip(Op([
                ",",
                Lp
            ]), e15.map(n5, "params"))
        , "program", "body", 0) : void 0;
    }
};
const { builders: { concat: $p , group: qp , indent: Wp , join: Up , line: Jp , hardline: zp  }  } = rn1, { hasNewlineBetweenOrAfterDecorators: Gp , getParentExportDeclaration: Hp  } = Cl;
var Xp = {
    printOptionalToken: function(e13) {
        const t9 = e13.getValue();
        return !t9.optional || "Identifier" === t9.type && t9 === e13.getParentNode().key ? "" : "OptionalCallExpression" === t9.type || "OptionalMemberExpression" === t9.type && t9.computed ? "?." : "?";
    },
    printFunctionTypeParameters: function(e13, t9, n5) {
        const r4 = e13.getValue();
        return r4.typeArguments ? e13.call(n5, "typeArguments") : r4.typeParameters ? e13.call(n5, "typeParameters") : "";
    },
    printBindExpressionCallee: function(e13, t9, n5) {
        return $p([
            "::",
            e13.call(n5, "callee")
        ]);
    },
    printTypeScriptModifiers: function(e13, t9, n5) {
        const r4 = e13.getValue();
        return r4.modifiers && r4.modifiers.length ? $p([
            Up(" ", e13.map(n5, "modifiers")),
            " "
        ]) : "";
    },
    printDecorators: function(e13, t9, n5) {
        const r4 = e13.getValue();
        return qp($p([
            Up(Jp, e13.map(n5, "decorators")),
            Gp(r4, t9) ? zp : Jp
        ]));
    },
    printFlowDeclaration: function(e13, t9) {
        const n5 = Hp(e13);
        return n5 ? (Xi.strictEqual(n5.type, "DeclareExportDeclaration"), t9) : $p([
            "declare ",
            t9
        ]);
    },
    adjustClause: function(e13, t9, n5) {
        return "EmptyStatement" === e13.type ? ";" : "BlockStatement" === e13.type || n5 ? $p([
            " ",
            t9
        ]) : Wp($p([
            Jp,
            t9
        ]));
    }
};
const { builders: { concat: Yp , softline: Kp , group: Qp , indent: Zp , join: ed , line: td , ifBreak: nd , hardline: rd  }  } = rn1, { printDanglingComments: od  } = ya, { hasDanglingComments: ud , shouldPrintComma: id , needsHardlineAfterDanglingComment: ad  } = Cl, { locStart: sd , hasSameLoc: ld  } = ei;
function cd(e13, t9, n5) {
    const r4 = e13.getValue();
    if (!r4.source) return "";
    const o4 = [];
    return dd(r4, t9) || o4.push(" from"), o4.push(" ", e13.call(n5, "source")), Yp(o4);
}
function pd(e13, t9, n5) {
    const r4 = e13.getValue();
    if (dd(r4, t9)) return "";
    const o4 = [
        " "
    ];
    if (r4.specifiers && r4.specifiers.length > 0) {
        const u4 = [], i5 = [];
        if (e13.each((t10)=>{
            const r5 = e13.getValue().type;
            if ("ExportNamespaceSpecifier" === r5 || "ExportDefaultSpecifier" === r5 || "ImportNamespaceSpecifier" === r5 || "ImportDefaultSpecifier" === r5) u4.push(n5(t10));
            else {
                if ("ExportSpecifier" !== r5 && "ImportSpecifier" !== r5) throw new Error("Unknown specifier type ".concat(JSON.stringify(r5)));
                i5.push(n5(t10));
            }
        }, "specifiers"), o4.push(ed(", ", u4)), 0 !== i5.length) {
            0 !== u4.length && o4.push(", ");
            i5.length > 1 || u4.length > 0 || r4.specifiers.some((e14)=>e14.comments
            ) ? o4.push(Qp(Yp([
                "{",
                Zp(Yp([
                    t9.bracketSpacing ? td : Kp,
                    ed(Yp([
                        ",",
                        td
                    ]), i5)
                ])),
                nd(id(t9) ? "," : ""),
                t9.bracketSpacing ? td : Kp,
                "}"
            ]))) : o4.push(Yp([
                "{",
                t9.bracketSpacing ? " " : "",
                Yp(i5),
                t9.bracketSpacing ? " " : "",
                "}"
            ]));
        }
    } else o4.push("{}");
    return Yp(o4);
}
function dd(e13, t9) {
    const { type: n5 , importKind: r4 , source: o4 , specifiers: u4  } = e13;
    return !("ImportDeclaration" !== n5 || Array.isArray(u4) && u4.length > 0 || "type" === r4) && !/{\s*}/.test(t9.originalText.slice(sd(e13), sd(o4)));
}
function fd(e13, t9, n5) {
    const r4 = e13.getNode();
    return Array.isArray(r4.assertions) && 0 !== r4.assertions.length ? Yp([
        " assert {",
        t9.bracketSpacing ? " " : "",
        ed(", ", e13.map(n5, "assertions")),
        t9.bracketSpacing ? " " : "",
        "}"
    ]) : "";
}
var hd = {
    printImportDeclaration: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = t9.semi ? ";" : "", u4 = [], { importKind: i5  } = r4;
        return (u4.push("import"), i5 && "value" !== i5 && u4.push(" ", i5), u4.push(pd(e13, t9, n5), cd(e13, t9, n5), fd(e13, t9, n5)), u4.push(o4), Yp(u4));
    },
    printExportDeclaration: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [], { type: u4 , exportKind: i5 , declaration: a4  } = r4;
        return ("DeclareExportDeclaration" === u4 && o4.push("declare "), o4.push("export"), (r4.default || "ExportDefaultDeclaration" === u4) && o4.push(" default"), ud(r4) && (o4.push(" ", od(e13, t9, !0)), ad(r4) && o4.push(rd)), a4 ? o4.push(" ", e13.call(n5, "declaration")) : o4.push("type" === i5 ? " type" : "", pd(e13, t9, n5), cd(e13, t9, n5), fd(e13, t9, n5)), function(e14, t10) {
            if (!t10.semi) return !1;
            const { type: n6 , declaration: r5  } = e14, o5 = e14.default || "ExportDefaultDeclaration" === n6;
            if (!r5) return !0;
            const { type: u5  } = r5;
            if (o5 && "ClassDeclaration" !== u5 && "FunctionDeclaration" !== u5 && "TSInterfaceDeclaration" !== u5 && "DeclareClass" !== u5 && "DeclareFunction" !== u5 && "TSDeclareFunction" !== u5 && "EnumDeclaration" !== u5) return !0;
            return !1;
        }(r4, t9) && o4.push(";"), Yp(o4));
    },
    printExportAllDeclaration: function(e13, t9, n5) {
        const r4 = e13.getValue();
        let o4 = t9.semi ? ";" : "";
        const u4 = [], { type: i5 , exportKind: a4 , exported: s4  } = r4;
        return ("DeclareExportAllDeclaration" === i5 && (u4.push("declare "), o4 = ""), u4.push("export"), "type" === a4 && u4.push(" type"), u4.push(" *"), s4 && u4.push(" as ", e13.call(n5, "exported")), u4.push(cd(e13, t9, n5), fd(e13, t9, n5), o4), Yp(u4));
    },
    printModuleSpecifier: function(e13, t9, n5) {
        const r4 = e13.getNode(), { type: o4 , importKind: u4  } = r4, i5 = [];
        "ImportSpecifier" === o4 && u4 && i5.push(u4, " ");
        const a4 = o4.startsWith("Import"), s4 = a4 ? "imported" : "local", l4 = a4 ? "local" : "exported";
        let c4 = "", p4 = "";
        return ("ExportNamespaceSpecifier" === o4 || "ImportNamespaceSpecifier" === o4 ? c4 = "*" : r4[s4] && (c4 = e13.call(n5, s4)), !r4[l4] || r4[s4] && ld(r4[s4], r4[l4]) || (p4 = e13.call(n5, l4)), i5.push(c4, c4 && p4 ? " as " : "", p4), Yp(i5));
    }
};
const { hasNewlineInRange: md  } = Nt1, { isJSXNode: gd , isBlockComment: Dd  } = Cl, { locStart: yd , locEnd: Ed  } = ei, { builders: { concat: Cd , line: bd , softline: vd , group: Ad , indent: Fd , align: xd , ifBreak: Sd , dedent: wd , breakParent: Td  }  } = rn1;
var Bd = function(e13, t9, n5, r4) {
    const o4 = e13.getValue(), u4 = o4[r4.consequentNodePropertyName], i5 = o4[r4.alternateNodePropertyName], a4 = [];
    let s4 = !1;
    const l4 = e13.getParentNode(), c4 = l4.type === r4.conditionalNodeType && r4.testNodePropertyNames.some((e14)=>l4[e14] === o4
    );
    let p4, d4, f4 = l4.type === r4.conditionalNodeType && !c4, h4 = 0;
    do {
        d4 = p4 || o4, p4 = e13.getParentNode(h4), h4++;
    }while (p4 && p4.type === r4.conditionalNodeType && r4.testNodePropertyNames.every((e14)=>p4[e14] !== d4
    ))
    const m4 = p4 || l4, g4 = d4;
    if (r4.shouldCheckJsx && (gd(o4[r4.testNodePropertyNames[0]]) || gd(u4) || gd(i5) || function(e14) {
        return (function(e15) {
            const t10 = [];
            return (function e15(n6) {
                "ConditionalExpression" === n6.type ? (e15(n6.test), e15(n6.consequent), e15(n6.alternate)) : t10.push(n6);
            })(e15), t10;
        })(e14).some(gd);
    }(d4))) {
        s4 = !0, f4 = !0;
        const t10 = (e14)=>Cd([
                Sd("(", ""),
                Fd(Cd([
                    vd,
                    e14
                ])),
                vd,
                Sd(")", "")
            ])
        , o5 = (e14)=>"NullLiteral" === e14.type || "Literal" === e14.type && null === e14.value || "Identifier" === e14.type && "undefined" === e14.name
        ;
        a4.push(" ? ", o5(u4) ? e13.call(n5, r4.consequentNodePropertyName) : t10(e13.call(n5, r4.consequentNodePropertyName)), " : ", i5.type === r4.conditionalNodeType || o5(i5) ? e13.call(n5, r4.alternateNodePropertyName) : t10(e13.call(n5, r4.alternateNodePropertyName)));
    } else {
        const s5 = Cd([
            bd,
            "? ",
            u4.type === r4.conditionalNodeType ? Sd("", "(") : "",
            xd(2, e13.call(n5, r4.consequentNodePropertyName)),
            u4.type === r4.conditionalNodeType ? Sd("", ")") : "",
            bd,
            ": ",
            i5.type === r4.conditionalNodeType ? e13.call(n5, r4.alternateNodePropertyName) : xd(2, e13.call(n5, r4.alternateNodePropertyName))
        ]);
        a4.push(l4.type !== r4.conditionalNodeType || l4[r4.alternateNodePropertyName] === o4 || c4 ? s5 : t9.useTabs ? wd(Fd(s5)) : xd(Math.max(0, t9.tabWidth - 2), s5));
    }
    const D4 = Uu([
        ...r4.testNodePropertyNames.map((e14)=>o4[e14].comments
        ),
        u4.comments,
        i5.comments
    ]).filter(Boolean).some((e14)=>Dd(e14) && md(t9.originalText, yd(e14), Ed(e14))
    ), y4 = !s4 && ("MemberExpression" === l4.type || "OptionalMemberExpression" === l4.type || "NGPipeExpression" === l4.type && l4.left === o4) && !l4.computed, E4 = ((e14)=>l4 === m4 ? Ad(e14, {
            shouldBreak: D4
        }) : D4 ? Cd([
            e14,
            Td
        ]) : e14
    )(Cd([].concat((C3 = Cd(r4.beforeParts()), l4.type === r4.conditionalNodeType && l4[r4.alternateNodePropertyName] === o4 ? xd(2, C3) : C3), f4 ? Cd(a4) : Fd(Cd(a4)), r4.afterParts(y4))));
    var C3;
    return c4 ? Ad(Cd([
        Fd(Cd([
            vd,
            E4
        ])),
        vd
    ])) : E4;
};
const { getNextNonSpaceNonCommentCharacter: Nd , isNextLineEmpty: kd  } = Nt1, { printDanglingComments: Pd  } = ya, { builders: { concat: Od , line: Id , hardline: Ld , softline: Md , group: jd , indent: _d , ifBreak: Rd  } , utils: { removeLines: Vd  }  } = rn1, { getFunctionParameters: $d , iterateFunctionParametersPath: qd , isSimpleType: Wd , isTestCall: Ud , isTypeAnnotationAFunction: Jd , isObjectType: zd , isObjectTypePropertyAFunction: Gd , hasRestParameter: Hd , shouldPrintComma: Xd  } = Cl, { locEnd: Yd  } = ei, { printFunctionTypeParameters: Kd  } = Xp;
function Qd(e13) {
    if (!e13) return !1;
    const t9 = $d(e13);
    if (1 !== t9.length) return !1;
    const [n5] = t9;
    return !n5.comments && ("ObjectPattern" === n5.type || "ArrayPattern" === n5.type || "Identifier" === n5.type && n5.typeAnnotation && ("TypeAnnotation" === n5.typeAnnotation.type || "TSTypeAnnotation" === n5.typeAnnotation.type) && zd(n5.typeAnnotation.typeAnnotation) || "FunctionTypeParam" === n5.type && zd(n5.typeAnnotation) || "AssignmentPattern" === n5.type && ("ObjectPattern" === n5.left.type || "ArrayPattern" === n5.left.type) && ("Identifier" === n5.right.type || "ObjectExpression" === n5.right.type && 0 === n5.right.properties.length || "ArrayExpression" === n5.right.type && 0 === n5.right.elements.length));
}
var Zd = {
    printFunctionParameters: function(e13, t9, n5, r4, o4) {
        const u4 = e13.getValue(), i5 = $d(u4), a4 = o4 ? Kd(e13, n5, t9) : "";
        if (0 === i5.length) return Od([
            a4,
            "(",
            Pd(e13, n5, !0, (e14)=>")" === Nd(n5.originalText, e14, Yd)
            ),
            ")"
        ]);
        const s4 = e13.getParentNode(), l4 = Ud(s4), c4 = Qd(u4), p4 = r4 && !i5.some((e14)=>e14.comments
        ), d4 = [];
        if ((qd(e13, (e14, r5)=>{
            const o5 = r5 === i5.length - 1;
            o5 && u4.rest && d4.push("..."), d4.push(e14.call(t9)), o5 || (d4.push(","), l4 || c4 || p4 ? d4.push(" ") : kd(n5.originalText, i5[r5], Yd) ? d4.push(Ld, Ld) : d4.push(Id));
        }), p4)) return jd(Od([
            Vd(a4),
            "(",
            Od(d4.map(Vd)),
            ")"
        ]));
        const f4 = i5.every((e14)=>!e14.decorators
        );
        return c4 && f4 || l4 ? Od([
            a4,
            "(",
            Od(d4),
            ")"
        ]) : (Gd(s4) || Jd(s4) || "TypeAlias" === s4.type || "UnionTypeAnnotation" === s4.type || "TSUnionType" === s4.type || "IntersectionTypeAnnotation" === s4.type || "FunctionTypeAnnotation" === s4.type && s4.returnType === u4) && 1 === i5.length && null === i5[0].name && u4.this !== i5[0] && i5[0].typeAnnotation && null === u4.typeParameters && Wd(i5[0].typeAnnotation) && !u4.rest ? "always" === n5.arrowParens ? Od([
            "(",
            Od(d4),
            ")"
        ]) : Od(d4) : Od([
            a4,
            "(",
            _d(Od([
                Md,
                Od(d4)
            ])),
            Rd(!Hd(u4) && Xd(n5, "all") ? "," : ""),
            Md,
            ")"
        ]);
    },
    shouldHugFunctionParameters: Qd
};
const { builders: { concat: ef  }  } = rn1, { isFlowAnnotationComment: tf , isSimpleType: nf , isObjectType: rf  } = Cl;
var of = {
    printTypeAnnotation: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if (!r4.typeAnnotation) return "";
        const o4 = e13.getParentNode(), u4 = r4.definite || o4 && "VariableDeclarator" === o4.type && o4.definite, i5 = "DeclareFunction" === o4.type && o4.id === r4;
        return tf(t9.originalText, r4.typeAnnotation) ? ef([
            " /*: ",
            e13.call(n5, "typeAnnotation"),
            " */"
        ]) : ef([
            i5 ? "" : u4 ? "!: " : ": ",
            e13.call(n5, "typeAnnotation")
        ]);
    },
    shouldHugType: function(e13) {
        if (nf(e13) || rf(e13)) return !0;
        if ("UnionTypeAnnotation" === e13.type || "TSUnionType" === e13.type) {
            const t9 = e13.types.filter((e14)=>"VoidTypeAnnotation" === e14.type || "TSVoidKeyword" === e14.type || "NullLiteralTypeAnnotation" === e14.type || "TSNullKeyword" === e14.type
            ).length, n5 = e13.types.some((e14)=>"ObjectTypeAnnotation" === e14.type || "TSTypeLiteral" === e14.type || "GenericTypeAnnotation" === e14.type || "TSTypeReference" === e14.type
            );
            if (e13.types.length - 1 === t9 && n5) return !0;
        }
        return !1;
    }
};
const { printDanglingComments: uf  } = ya, { builders: { concat: af , line: sf , softline: lf , group: cf , indent: pf , ifBreak: df  }  } = rn1, { getLast: ff , isNextLineEmpty: hf  } = Nt1, { hasDanglingComments: mf , shouldPrintComma: gf  } = Cl, { locEnd: Df  } = ei, { printOptionalToken: yf  } = Xp, { printTypeAnnotation: Ef  } = of;
function Cf(e13, t9, n5, r4) {
    const o4 = [];
    let u4 = [];
    return e13.each((e14)=>{
        o4.push(af(u4)), o4.push(cf(r4(e14))), u4 = [
            ",",
            sf
        ], e14.getValue() && hf(t9.originalText, e14.getValue(), Df) && u4.push(lf);
    }, n5), af(o4);
}
var bf = {
    printArray: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [], u4 = "TupleExpression" === r4.type ? "#[" : "[";
        if (0 === r4.elements.length) mf(r4) ? o4.push(cf(af([
            u4,
            uf(e13, t9),
            lf,
            "]"
        ]))) : o4.push(u4, "]");
        else {
            const i5 = ff(r4.elements), a4 = !(i5 && "RestElement" === i5.type), s4 = a4 && null === i5, l4 = !t9.__inJestEach && r4.elements.length > 1 && r4.elements.every((e14, t10, n6)=>{
                const r5 = e14 && e14.type;
                if ("ArrayExpression" !== r5 && "ObjectExpression" !== r5) return !1;
                const o5 = n6[t10 + 1];
                if (o5 && r5 !== o5.type) return !1;
                const u5 = "ArrayExpression" === r5 ? "elements" : "properties";
                return e14[u5] && e14[u5].length > 1;
            });
            o4.push(cf(af([
                u4,
                pf(af([
                    lf,
                    Cf(e13, t9, "elements", n5)
                ])),
                s4 ? "," : "",
                df(a4 && !s4 && gf(t9) ? "," : ""),
                uf(e13, t9, !0),
                lf,
                "]"
            ]), {
                shouldBreak: l4
            }));
        }
        return (o4.push(yf(e13), Ef(e13, t9, n5)), af(o4));
    },
    printArrayItems: Cf
};
const { printDanglingComments: vf  } = ya, { builders: { concat: Af , line: Ff , softline: xf , group: Sf , indent: wf , ifBreak: Tf , hardline: Bf  }  } = rn1, { getLast: Nf , isNextLineEmpty: kf , hasNewlineInRange: Pf , hasNewline: Of  } = Nt1, { hasDanglingComments: If , shouldPrintComma: Lf , hasNodeIgnoreComment: Mf , isBlockComment: jf  } = Cl, { locStart: _f , locEnd: Rf  } = ei, { printOptionalToken: Vf  } = Xp, { shouldHugFunctionParameters: $f  } = Zd, { printTypeAnnotation: qf , shouldHugType: Wf  } = of;
var Uf = {
    printObject: function(e13, t9, n5) {
        const r4 = t9.semi ? ";" : "", o4 = e13.getValue();
        let u4;
        u4 = "TSTypeLiteral" === o4.type ? "members" : "TSInterfaceBody" === o4.type ? "body" : "properties";
        const i5 = "ObjectTypeAnnotation" === o4.type, a4 = [];
        i5 && a4.push("indexers", "callProperties", "internalSlots"), a4.push(u4);
        const s4 = a4.map((e14)=>o4[e14][0]
        ).sort((e14, t10)=>_f(e14) - _f(t10)
        )[0], l4 = e13.getParentNode(0), c4 = i5 && l4 && ("InterfaceDeclaration" === l4.type || "DeclareInterface" === l4.type || "DeclareClass" === l4.type) && "body" === e13.getName(), p4 = "TSInterfaceBody" === o4.type || c4 || "ObjectPattern" === o4.type && "FunctionDeclaration" !== l4.type && "FunctionExpression" !== l4.type && "ArrowFunctionExpression" !== l4.type && "ObjectMethod" !== l4.type && "ClassMethod" !== l4.type && "ClassPrivateMethod" !== l4.type && "AssignmentPattern" !== l4.type && "CatchClause" !== l4.type && o4.properties.some((e14)=>e14.value && ("ObjectPattern" === e14.value.type || "ArrayPattern" === e14.value.type)
        ) || "ObjectPattern" !== o4.type && s4 && Pf(t9.originalText, _f(o4), _f(s4)), d4 = c4 ? ";" : "TSInterfaceBody" === o4.type || "TSTypeLiteral" === o4.type ? Tf(r4, ";") : ",", f4 = "RecordExpression" === o4.type ? "#{" : o4.exact ? "{|" : "{", h4 = o4.exact ? "|}" : "}", m4 = [];
        a4.forEach((t10)=>{
            e13.each((e14)=>{
                const t11 = e14.getValue();
                m4.push({
                    node: t11,
                    printed: n5(e14),
                    loc: _f(t11)
                });
            }, t10);
        });
        let g4 = [];
        const D4 = m4.sort((e14, t10)=>e14.loc - t10.loc
        ).map((e14)=>{
            const n6 = Af(g4.concat(Sf(e14.printed)));
            return g4 = [
                d4,
                Ff
            ], "TSPropertySignature" !== e14.node.type && "TSMethodSignature" !== e14.node.type && "TSConstructSignatureDeclaration" !== e14.node.type || !Mf(e14.node) || g4.shift(), kf(t9.originalText, e14.node, Rf) && g4.push(Bf), n6;
        });
        if (o4.inexact) {
            let n6;
            if (If(o4)) {
                const r5 = !o4.comments.every((e14)=>jf(e14)
                ), u5 = vf(e13, t9, !0);
                n6 = Af([
                    u5,
                    r5 || Of(t9.originalText, Rf(o4.comments[o4.comments.length - 1])) ? Bf : Ff,
                    "..."
                ]);
            } else n6 = "...";
            D4.push(Af(g4.concat(n6)));
        }
        const y4 = Nf(o4[u4]), E4 = !(o4.inexact || y4 && "RestElement" === y4.type || y4 && ("TSPropertySignature" === y4.type || "TSCallSignatureDeclaration" === y4.type || "TSMethodSignature" === y4.type || "TSConstructSignatureDeclaration" === y4.type) && Mf(y4));
        let C3;
        if (0 === D4.length) {
            if (!If(o4)) return Af([
                f4,
                h4,
                qf(e13, t9, n5)
            ]);
            C3 = Sf(Af([
                f4,
                vf(e13, t9),
                xf,
                h4,
                Vf(e13),
                qf(e13, t9, n5)
            ]));
        } else C3 = Af([
            f4,
            wf(Af([
                t9.bracketSpacing ? Ff : xf,
                Af(D4)
            ])),
            Tf(E4 && ("," !== d4 || Lf(t9)) ? d4 : ""),
            Af([
                t9.bracketSpacing ? Ff : xf,
                h4
            ]),
            Vf(e13),
            qf(e13, t9, n5)
        ]);
        return e13.match((e14)=>"ObjectPattern" === e14.type && !e14.decorators
        , (e14, t10, n6)=>$f(e14) && ("params" === t10 || "parameters" === t10 || "this" === t10 || "rest" === t10) && 0 === n6
        ) || e13.match(Wf, (e14, t10)=>"typeAnnotation" === t10
        , (e14, t10)=>"typeAnnotation" === t10
        , (e14, t10, n6)=>$f(e14) && ("params" === t10 || "parameters" === t10 || "this" === t10 || "rest" === t10) && 0 === n6
        ) ? C3 : Sf(C3, {
            shouldBreak: p4
        });
    }
};
const { printComments: Jf , printDanglingComments: zf  } = ya, { builders: { concat: Gf , line: Hf , hardline: Xf , softline: Yf , group: Kf , indent: Qf , conditionalGroup: Zf , fill: eh , ifBreak: th , lineSuffixBoundary: nh  } , utils: { willBreak: rh , isLineNext: oh , isEmpty: uh  }  } = rn1, { getLast: ih , getPreferredQuote: ah  } = Nt1, { hasTrailingComment: sh , isEmptyJSXElement: lh , isJSXWhitespaceExpression: ch , isJSXNode: ph , isMeaningfulJSXText: dh , matchJsxWhitespaceRegex: fh , rawText: hh , isLiteral: mh , isCallOrOptionalCallExpression: gh , isStringLiteral: Dh , isBinaryish: yh , isBlockComment: Eh  } = Cl, { willPrintOwnComments: Ch  } = Zl;
function bh(e13, t9, n5) {
    const r4 = e13.getValue();
    if ("JSXElement" === r4.type && lh(r4)) return Gf([
        e13.call(n5, "openingElement"),
        e13.call(n5, "closingElement")
    ]);
    const o4 = "JSXElement" === r4.type ? e13.call(n5, "openingElement") : e13.call(n5, "openingFragment"), u4 = "JSXElement" === r4.type ? e13.call(n5, "closingElement") : e13.call(n5, "closingFragment");
    if (1 === r4.children.length && "JSXExpressionContainer" === r4.children[0].type && ("TemplateLiteral" === r4.children[0].expression.type || "TaggedTemplateExpression" === r4.children[0].expression.type)) return Gf([
        o4,
        Gf(e13.map(n5, "children")),
        u4
    ]);
    r4.children = r4.children.map((e14)=>ch(e14) ? {
            type: "JSXText",
            value: " ",
            raw: " "
        } : e14
    );
    const i5 = r4.children.filter(ph).length > 0, a4 = r4.children.filter((e14)=>"JSXExpressionContainer" === e14.type
    ).length > 1, s4 = "JSXElement" === r4.type && r4.openingElement.attributes.length > 1;
    let l4 = rh(o4) || i5 || s4 || a4;
    const c4 = "mdx" === e13.getParentNode().rootMarker, p4 = t9.singleQuote ? "{' '}" : '{" "}', d4 = c4 ? Gf([
        " "
    ]) : th(Gf([
        p4,
        Yf
    ]), " "), f4 = r4.openingElement && r4.openingElement.name && "fbt" === r4.openingElement.name.name, h4 = function(e14, t10, n6, r5, o5) {
        const u5 = e14.getValue(), i6 = [];
        return e14.each((e15, t11)=>{
            const a5 = e15.getValue();
            if (mh(a5)) {
                const e16 = hh(a5);
                if (dh(a5)) {
                    const n7 = e16.split(fh);
                    if ("" === n7[0]) {
                        if (i6.push(""), n7.shift(), /\n/.test(n7[0])) {
                            const e17 = u5.children[t11 + 1];
                            i6.push(Ah(o5, n7[1], a5, e17));
                        } else i6.push(r5);
                        n7.shift();
                    }
                    let s5;
                    if ("" === ih(n7) && (n7.pop(), s5 = n7.pop()), 0 === n7.length) return;
                    if (n7.forEach((e17, t12)=>{
                        t12 % 2 == 1 ? i6.push(Hf) : i6.push(e17);
                    }), (void 0) !== s5) {
                        if (/\n/.test(s5)) {
                            const e17 = u5.children[t11 + 1];
                            i6.push(Ah(o5, ih(i6), a5, e17));
                        } else i6.push(r5);
                    } else {
                        const e17 = u5.children[t11 + 1];
                        i6.push(vh(o5, ih(i6), a5, e17));
                    }
                } else /\n/.test(e16) ? e16.match(/\n/g).length > 1 && (i6.push(""), i6.push(Xf)) : (i6.push(""), i6.push(r5));
            } else {
                const r6 = n6(e15);
                i6.push(r6);
                const s5 = u5.children[t11 + 1];
                if (s5 && dh(s5)) {
                    const e16 = hh(s5).trim().split(fh)[0];
                    i6.push(vh(o5, e16, a5, s5));
                } else i6.push(Xf);
            }
        }, "children"), i6;
    }(e13, 0, n5, d4, f4), m4 = r4.children.some((e14)=>dh(e14)
    );
    for(let e14 = h4.length - 2; e14 >= 0; e14--){
        const t10 = "" === h4[e14] && "" === h4[e14 + 1], n6 = h4[e14] === Xf && "" === h4[e14 + 1] && h4[e14 + 2] === Xf, r5 = (h4[e14] === Yf || h4[e14] === Xf) && "" === h4[e14 + 1] && h4[e14 + 2] === d4, o5 = h4[e14] === d4 && "" === h4[e14 + 1] && (h4[e14 + 2] === Yf || h4[e14 + 2] === Xf), u5 = h4[e14] === d4 && "" === h4[e14 + 1] && h4[e14 + 2] === d4, i6 = h4[e14] === Yf && "" === h4[e14 + 1] && h4[e14 + 2] === Xf || h4[e14] === Xf && "" === h4[e14 + 1] && h4[e14 + 2] === Yf;
        n6 && m4 || t10 || r5 || u5 || i6 ? h4.splice(e14, 2) : o5 && h4.splice(e14 + 1, 2);
    }
    for(; h4.length && (oh(ih(h4)) || uh(ih(h4)));)h4.pop();
    for(; h4.length && (oh(h4[0]) || uh(h4[0])) && (oh(h4[1]) || uh(h4[1]));)h4.shift(), h4.shift();
    const g4 = [];
    h4.forEach((e15, t10)=>{
        if (e15 === d4) {
            if (1 === t10 && "" === h4[t10 - 1]) return 2 === h4.length ? void g4.push(p4) : void g4.push(Gf([
                p4,
                Xf
            ]));
            if (t10 === h4.length - 1) return void g4.push(p4);
            if ("" === h4[t10 - 1] && h4[t10 - 2] === Xf) return void g4.push(p4);
        }
        g4.push(e15), rh(e15) && (l4 = !0);
    });
    const D4 = m4 ? eh(g4) : Kf(Gf(g4), {
        shouldBreak: !0
    });
    if (c4) return D4;
    const y4 = Kf(Gf([
        o4,
        Qf(Gf([
            Xf,
            D4
        ])),
        Xf,
        u4
    ]));
    return l4 ? y4 : Zf([
        Kf(Gf([
            o4,
            Gf(h4),
            u4
        ])),
        y4
    ]);
}
function vh(e13, t9, n5, r4) {
    return e13 ? "" : "JSXElement" === n5.type && !n5.closingElement || r4 && "JSXElement" === r4.type && !r4.closingElement ? 1 === t9.length ? Yf : Xf : Yf;
}
function Ah(e13, t9, n5, r4) {
    return e13 ? Xf : 1 === t9.length ? "JSXElement" === n5.type && !n5.closingElement || r4 && "JSXElement" === r4.type && !r4.closingElement ? Xf : Yf : Xf;
}
function Fh(e13, t9, n5) {
    const r4 = e13.getValue();
    return Gf([
        "{",
        e13.call((e14)=>{
            const r5 = Gf([
                "...",
                n5(e14)
            ]), o4 = e14.getValue();
            return o4.comments && o4.comments.length && Ch(e14) ? Gf([
                Qf(Gf([
                    Yf,
                    Jf(e14, ()=>r5
                    , t9)
                ])),
                Yf
            ]) : r5;
        }, "JSXSpreadAttribute" === r4.type ? "argument" : "expression"),
        "}"
    ]);
}
var xh = {
    printJsxElement: function(e13, t9, n5) {
        const r4 = Jf(e13, ()=>bh(e13, t9, n5)
        , t9);
        return function(e14, t10, n6) {
            const r5 = e14.getParentNode();
            if (!r5) return t10;
            if (({
                ArrayExpression: !0,
                JSXAttribute: !0,
                JSXElement: !0,
                JSXExpressionContainer: !0,
                JSXFragment: !0,
                ExpressionStatement: !0,
                CallExpression: !0,
                OptionalCallExpression: !0,
                ConditionalExpression: !0,
                JsExpressionRoot: !0
            })[r5.type]) return t10;
            const o4 = e14.match(void 0, (e15)=>"ArrowFunctionExpression" === e15.type
            , gh, (e15)=>"JSXExpressionContainer" === e15.type
            ), u4 = Pp(e14, n6);
            return Kf(Gf([
                u4 ? "" : th("("),
                Qf(Gf([
                    Yf,
                    t10
                ])),
                Yf,
                u4 ? "" : th(")")
            ]), {
                shouldBreak: o4
            });
        }(e13, r4, t9);
    },
    printJsxAttribute: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [];
        if ((o4.push(e13.call(n5, "name")), r4.value)) {
            let u4;
            if (Dh(r4.value)) {
                let e14 = hh(r4.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                const n6 = ah(e14, t9.jsxSingleQuote ? "'" : '"'), o5 = "'" === n6 ? "&apos;" : "&quot;";
                e14 = e14.slice(1, -1).replace(new RegExp(n6, "g"), o5), u4 = Gf([
                    n6,
                    e14,
                    n6
                ]);
            } else u4 = e13.call(n5, "value");
            o4.push("=", u4);
        }
        return Gf(o4);
    },
    printJsxOpeningElement: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = r4.name && r4.name.comments && r4.name.comments.length > 0 || r4.typeParameters && r4.typeParameters.comments && r4.typeParameters.comments.length > 0;
        if (r4.selfClosing && !r4.attributes.length && !o4) return Gf([
            "<",
            e13.call(n5, "name"),
            e13.call(n5, "typeParameters"),
            " />"
        ]);
        if (r4.attributes && 1 === r4.attributes.length && r4.attributes[0].value && Dh(r4.attributes[0].value) && !r4.attributes[0].value.value.includes("\n") && !o4 && (!r4.attributes[0].comments || !r4.attributes[0].comments.length)) return Kf(Gf([
            "<",
            e13.call(n5, "name"),
            e13.call(n5, "typeParameters"),
            " ",
            Gf(e13.map(n5, "attributes")),
            r4.selfClosing ? " />" : ">"
        ]));
        const u4 = r4.attributes.length && sh(ih(r4.attributes)), i5 = !r4.attributes.length && !o4 || t9.jsxBracketSameLine && (!o4 || r4.attributes.length) && !u4, a4 = r4.attributes && r4.attributes.some((e14)=>e14.value && Dh(e14.value) && e14.value.value.includes("\n")
        );
        return Kf(Gf([
            "<",
            e13.call(n5, "name"),
            e13.call(n5, "typeParameters"),
            Gf([
                Qf(Gf(e13.map((e14)=>Gf([
                        Hf,
                        n5(e14)
                    ])
                , "attributes"))),
                r4.selfClosing ? Hf : i5 ? ">" : Yf
            ]),
            r4.selfClosing ? "/>" : i5 ? "" : ">"
        ]), {
            shouldBreak: a4
        });
    },
    printJsxClosingElement: function(e13, t9, n5) {
        return Gf([
            "</",
            e13.call(n5, "name"),
            ">"
        ]);
    },
    printJsxOpeningClosingFragment: function(e13, t9) {
        const n5 = e13.getValue(), r4 = n5.comments && n5.comments.length, o4 = r4 && !n5.comments.every((e14)=>Eh(e14)
        ), u4 = "JSXOpeningFragment" === n5.type;
        return Gf([
            u4 ? "<" : "</",
            Qf(Gf([
                o4 ? Xf : r4 && !u4 ? " " : "",
                zf(e13, t9, !0)
            ])),
            o4 ? Xf : "",
            ">"
        ]);
    },
    printJsxExpressionContainer: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = e13.getParentNode(0), u4 = r4.expression.comments && r4.expression.comments.length > 0, i5 = "JSXEmptyExpression" === r4.expression.type || !u4 && ("ArrayExpression" === r4.expression.type || "ObjectExpression" === r4.expression.type || "ArrowFunctionExpression" === r4.expression.type || "CallExpression" === r4.expression.type || "OptionalCallExpression" === r4.expression.type || "FunctionExpression" === r4.expression.type || "TemplateLiteral" === r4.expression.type || "TaggedTemplateExpression" === r4.expression.type || "DoExpression" === r4.expression.type || ph(o4) && ("ConditionalExpression" === r4.expression.type || yh(r4.expression)));
        return Kf(Gf(i5 ? [
            "{",
            e13.call(n5, "expression"),
            nh,
            "}"
        ] : [
            "{",
            Qf(Gf([
                Yf,
                e13.call(n5, "expression")
            ])),
            Yf,
            nh,
            "}"
        ]));
    },
    printJsxEmptyExpression: function(e13, t9) {
        const n5 = e13.getValue(), r4 = n5.comments && !n5.comments.every((e14)=>Eh(e14)
        );
        return Gf([
            zf(e13, t9, !r4),
            r4 ? Xf : ""
        ]);
    },
    printJsxSpreadAttribute: Fh,
    printJsxSpreadChild: Fh
};
const { printDanglingComments: Sh  } = ya, { builders: { concat: wh , join: Th , line: Bh , hardline: Nh , softline: kh , group: Ph , indent: Oh , ifBreak: Ih  }  } = rn1, { hasDanglingComments: Lh , isTestCall: Mh , isBlockComment: jh , shouldPrintComma: _h  } = Cl, { shouldHugType: Rh  } = of, Vh = new WeakMap;
function $h(e13) {
    return Vh.has(e13) || Vh.set(e13, Symbol("typeParameters")), Vh.get(e13);
}
function qh(e13, t9) {
    const n5 = e13.getValue();
    if (!Lh(n5)) return "";
    const r4 = n5.comments.every((e14)=>jh(e14)
    ), o4 = Sh(e13, t9, r4);
    return r4 ? o4 : wh([
        o4,
        Nh
    ]);
}
var Wh = {
    printTypeParameters: function(e13, t9, n5, r4) {
        const o4 = e13.getValue();
        if (!o4[r4]) return "";
        if (!Array.isArray(o4[r4])) return e13.call(n5, r4);
        const u4 = e13.getNode(2);
        return null != u4 && Mh(u4) || 0 === o4[r4].length || 1 === o4[r4].length && (Rh(o4[r4][0]) || "GenericTypeAnnotation" === o4[r4][0].type && Rh(o4[r4][0].id) || "TSTypeReference" === o4[r4][0].type && Rh(o4[r4][0].typeName) || "NullableTypeAnnotation" === o4[r4][0].type) ? wh([
            "<",
            Th(", ", e13.map(n5, r4)),
            qh(e13, t9),
            ">"
        ]) : Ph(wh([
            "<",
            Oh(wh([
                kh,
                Th(wh([
                    ",",
                    Bh
                ]), e13.map(n5, r4))
            ])),
            Ih("typescript" !== t9.parser && "babel-ts" !== t9.parser && _h(t9, "all") ? "," : ""),
            kh,
            ">"
        ]), {
            id: $h(o4)
        });
    },
    getTypeParametersGroupId: $h
};
const { printComments: Uh  } = ya, { printString: Jh , printNumber: zh  } = Nt1, { builders: { concat: Gh  }  } = rn1, { isNumericLiteral: Hh , isSimpleNumber: Xh , isStringLiteral: Yh , isStringPropSafeToUnquote: Kh , rawText: Qh  } = Cl, Zh = new WeakMap;
var em = {
    printPropertyKey: function(e13, t9, n5) {
        const r4 = e13.getNode();
        if (r4.computed) return Gh([
            "[",
            e13.call(n5, "key"),
            "]"
        ]);
        const o4 = e13.getParentNode(), { key: u4  } = r4;
        if ("ClassPrivateProperty" === r4.type && "Identifier" === u4.type) return Gh([
            "#",
            e13.call(n5, "key")
        ]);
        if ("consistent" === t9.quoteProps && !Zh.has(o4)) {
            const e14 = (o4.properties || o4.body || o4.members).some((e15)=>!e15.computed && e15.key && Yh(e15.key) && !Kh(e15, t9)
            );
            Zh.set(o4, e14);
        }
        if (("Identifier" === u4.type || Hh(u4) && Xh(zh(Qh(u4))) && String(u4.value) === zh(Qh(u4)) && "typescript" !== t9.parser && "babel-ts" !== t9.parser) && ("json" === t9.parser || "consistent" === t9.quoteProps && Zh.get(o4))) {
            const n6 = Jh(JSON.stringify("Identifier" === u4.type ? u4.name : u4.value.toString()), t9);
            return e13.call((e14)=>Uh(e14, ()=>n6
                , t9)
            , "key");
        }
        return Kh(r4, t9) && ("as-needed" === t9.quoteProps || "consistent" === t9.quoteProps && !Zh.get(o4)) ? e13.call((e14)=>Uh(e14, ()=>/^\d/.test(u4.value) ? zh(u4.value) : u4.value
            , t9)
        , "key") : e13.call(n5, "key");
    }
};
const { printDanglingComments: tm  } = ya, { getNextNonSpaceNonCommentCharacterIndex: nm  } = Nt1, { builders: { concat: rm , line: om , softline: um , group: im , indent: am , ifBreak: sm , hardline: lm  }  } = rn1, { getFunctionParameters: cm , hasDanglingComments: pm , hasLeadingOwnLineComment: dm , isFlowAnnotationComment: fm , isJSXNode: hm , isTemplateOnItsOwnLine: mm , shouldPrintComma: gm , startsWithNoLookaheadToken: Dm , returnArgumentHasLeadingComment: ym , isBinaryish: Em , isLineComment: Cm  } = Cl, { locEnd: bm  } = ei, { printFunctionParameters: vm  } = Zd, { printPropertyKey: Am  } = em, { printFunctionTypeParameters: Fm  } = Xp;
function xm(e13, t9, n5) {
    const r4 = [
        Fm(e13, t9, n5),
        im(rm([
            vm(e13, n5, t9),
            wm(e13, n5, t9)
        ]))
    ];
    return e13.getNode().body ? r4.push(" ", e13.call(n5, "body")) : r4.push(t9.semi ? ";" : ""), rm(r4);
}
function Sm(e13, t9) {
    if ("always" === t9.arrowParens) return !1;
    if ("avoid" === t9.arrowParens) {
        return (function(e14) {
            const t10 = cm(e14);
            return !(1 !== t10.length || e14.typeParameters || pm(e14) || "Identifier" !== t10[0].type || t10[0].typeAnnotation || t10[0].comments || t10[0].optional || e14.predicate || e14.returnType);
        })(e13.getValue());
    }
    return !1;
}
function wm(e13, t9, n5) {
    const r4 = e13.getValue(), o4 = e13.call(t9, "returnType");
    if (r4.returnType && fm(n5.originalText, r4.returnType)) return rm([
        " /*: ",
        o4,
        " */"
    ]);
    const u4 = [
        o4
    ];
    return r4.returnType && r4.returnType.typeAnnotation && u4.unshift(": "), r4.predicate && u4.push(r4.returnType ? " " : ": ", e13.call(t9, "predicate")), rm(u4);
}
var Tm = {
    printFunctionDeclaration: function(e13, t9, n5, r4) {
        const o4 = e13.getValue(), u4 = [];
        return (o4.async && u4.push("async "), o4.generator ? u4.push("function* ") : u4.push("function "), o4.id && u4.push(e13.call(t9, "id")), u4.push(Fm(e13, n5, t9), im(rm([
            vm(e13, t9, n5, r4),
            wm(e13, t9, n5)
        ])), o4.body ? " " : "", e13.call(t9, "body")), rm(u4));
    },
    printArrowFunctionExpression: function(e13, t9, n5, r4) {
        const o4 = e13.getValue(), u4 = [];
        o4.async && u4.push("async "), Sm(e13, t9) ? u4.push(e13.call(n5, "params", 0)) : u4.push(im(rm([
            vm(e13, n5, t9, r4 && (r4.expandLastArg || r4.expandFirstArg), !0),
            wm(e13, n5, t9)
        ])));
        const i5 = tm(e13, t9, !0, (e14)=>{
            const n6 = nm(t9.originalText, e14, bm);
            return !1 !== n6 && "=>" === t9.originalText.slice(n6, n6 + 2);
        });
        i5 && u4.push(" ", i5), u4.push(" =>");
        const a4 = e13.call((e14)=>n5(e14, r4)
        , "body");
        if (!dm(t9.originalText, o4.body) && ("ArrayExpression" === o4.body.type || "ObjectExpression" === o4.body.type || "BlockStatement" === o4.body.type || hm(o4.body) || mm(o4.body, t9.originalText) || "ArrowFunctionExpression" === o4.body.type || "DoExpression" === o4.body.type)) return im(rm([
            rm(u4),
            " ",
            a4
        ]));
        if ("SequenceExpression" === o4.body.type) return im(rm([
            rm(u4),
            im(rm([
                " (",
                am(rm([
                    um,
                    a4
                ])),
                um,
                ")"
            ]))
        ]));
        const s4 = (r4 && r4.expandLastArg || "JSXExpressionContainer" === e13.getParentNode().type) && !(o4.comments && o4.comments.length), l4 = r4 && r4.expandLastArg && gm(t9, "all"), c4 = "ConditionalExpression" === o4.body.type && !Dm(o4.body, !1);
        return im(rm([
            rm(u4),
            im(rm([
                am(rm([
                    om,
                    c4 ? sm("", "(") : "",
                    a4,
                    c4 ? sm("", ")") : ""
                ])),
                s4 ? rm([
                    sm(l4 ? "," : ""),
                    um
                ]) : ""
            ]))
        ]));
    },
    printMethod: function(e13, t9, n5) {
        const r4 = e13.getNode(), { kind: o4  } = r4, u4 = r4.value || r4, i5 = [];
        return (o4 && "init" !== o4 && "method" !== o4 && "constructor" !== o4 ? (Xi.ok("get" === o4 || "set" === o4), i5.push(o4, " ")) : u4.async && i5.push("async "), u4.generator && i5.push("*"), i5.push(Am(e13, t9, n5), r4.optional || r4.key.optional ? "?" : "", r4 === u4 ? xm(e13, t9, n5) : e13.call((e14)=>xm(e14, t9, n5)
        , "value")), rm(i5));
    },
    printReturnAndThrowArgument: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = t9.semi ? ";" : "", u4 = [];
        r4.argument && (ym(t9, r4.argument) ? u4.push(rm([
            " (",
            am(rm([
                lm,
                e13.call(n5, "argument")
            ])),
            lm,
            ")"
        ])) : Em(r4.argument) || "SequenceExpression" === r4.argument.type ? u4.push(im(rm([
            sm(" (", " "),
            am(rm([
                um,
                e13.call(n5, "argument")
            ])),
            um,
            sm(")")
        ]))) : u4.push(" ", e13.call(n5, "argument")));
        const i5 = Array.isArray(r4.comments) && r4.comments[r4.comments.length - 1], a4 = i5 && Cm(i5);
        return (a4 && u4.push(o4), pm(r4) && u4.push(" ", tm(e13, t9, !0)), a4 || u4.push(o4), rm(u4));
    },
    shouldPrintParamsWithoutParens: Sm
};
const { printComments: Bm , printDanglingComments: Nm  } = ya, { builders: { concat: km , join: Pm , line: Om , hardline: Im , softline: Lm , group: Mm , indent: jm , ifBreak: _m  }  } = rn1, { hasTrailingComment: Rm , hasTrailingLineComment: Vm  } = Cl, { getTypeParametersGroupId: $m  } = Wh, { printMethod: qm  } = Tm, { printDecorators: Wm  } = Xp;
function Um(e13) {
    return e13.typeParameters && !Vm(e13.typeParameters) && !(function(e14) {
        return [
            "superClass",
            "extends",
            "mixins",
            "implements"
        ].filter((t9)=>!!e14[t9]
        ).length > 1;
    })(e13);
}
function Jm(e13, t9, n5, r4) {
    const o4 = e13.getValue();
    if (!o4[r4] || 0 === o4[r4].length) return "";
    const u4 = Nm(e13, t9, !0, ({ marker: e14  })=>e14 === r4
    );
    return km([
        Um(o4) ? _m(" ", Om, {
            groupId: $m(o4.typeParameters)
        }) : Om,
        u4,
        u4 && Im,
        r4,
        Mm(jm(km([
            Om,
            Pm(km([
                ",",
                Om
            ]), e13.map(n5, r4))
        ])))
    ]);
}
function zm(e13, t9, n5) {
    const r4 = e13.call(n5, "superClass");
    return "AssignmentExpression" === e13.getParentNode().type ? Mm(_m(km([
        "(",
        jm(km([
            Lm,
            r4
        ])),
        Lm,
        ")"
    ]), r4)) : r4;
}
var Gm = {
    printClass: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [];
        r4.abstract && o4.push("abstract "), o4.push("class");
        const u4 = r4.id && Rm(r4.id) || r4.superClass && r4.superClass.comments && 0 !== r4.superClass.comments.length || r4.extends && 0 !== r4.extends.length || r4.mixins && 0 !== r4.mixins.length || r4.implements && 0 !== r4.implements.length, i5 = [], a4 = [];
        if ((r4.id && i5.push(" ", e13.call(n5, "id")), i5.push(e13.call(n5, "typeParameters")), r4.superClass)) {
            const r5 = km([
                "extends ",
                zm(e13, t9, n5),
                e13.call(n5, "superTypeParameters")
            ]), o5 = e13.call((e14)=>Bm(e14, ()=>r5
                , t9)
            , "superClass");
            u4 ? a4.push(Om, Mm(o5)) : a4.push(" ", o5);
        } else a4.push(Jm(e13, t9, n5, "extends"));
        if ((a4.push(Jm(e13, t9, n5, "mixins")), a4.push(Jm(e13, t9, n5, "implements")), u4)) {
            const e14 = km(a4);
            Um(r4) ? o4.push(Mm(km(i5.concat(_m(jm(e14), e14))))) : o4.push(Mm(jm(km(i5.concat(e14)))));
        } else o4.push(...i5, ...a4);
        return (o4.push(" ", e13.call(n5, "body")), km(o4));
    },
    printClassMethod: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [];
        return (r4.decorators && 0 !== r4.decorators.length && o4.push(Wm(e13, t9, n5)), r4.accessibility && o4.push(r4.accessibility + " "), r4.static && o4.push("static "), ("TSAbstractMethodDefinition" === r4.type || r4.abstract) && o4.push("abstract "), o4.push(qm(e13, t9, n5)), km(o4));
    }
};
const { getLast: Hm , getPenultimate: Xm , isNextLineEmpty: Ym  } = Nt1, { getFunctionParameters: Km , iterateFunctionParametersPath: Qm , hasLeadingComment: Zm , hasTrailingComment: eg , isFunctionCompositionArgs: tg , isJSXNode: ng , isLongCurriedCallExpression: rg , shouldPrintComma: og , getCallArguments: ug , iterateCallArgumentsPath: ig  } = Cl, { locEnd: ag  } = ei, { builders: { concat: sg , line: lg , hardline: cg , softline: pg , group: dg , indent: fg , conditionalGroup: hg , ifBreak: mg , breakParent: gg  } , utils: { willBreak: Dg  }  } = rn1;
function yg(e13) {
    return "ObjectExpression" === e13.type && (e13.properties.length > 0 || e13.comments) || "ArrayExpression" === e13.type && (e13.elements.length > 0 || e13.comments) || "TSTypeAssertion" === e13.type && yg(e13.expression) || "TSAsExpression" === e13.type && yg(e13.expression) || "FunctionExpression" === e13.type || "ArrowFunctionExpression" === e13.type && (!e13.returnType || !e13.returnType.typeAnnotation || "TSTypeReference" !== e13.returnType.typeAnnotation.type) && ("BlockStatement" === e13.body.type || "ArrowFunctionExpression" === e13.body.type || "ObjectExpression" === e13.body.type || "ArrayExpression" === e13.body.type || "CallExpression" === e13.body.type || "OptionalCallExpression" === e13.body.type || "ConditionalExpression" === e13.body.type || ng(e13.body));
}
var Eg = function(e13, t9, n5) {
    const r4 = e13.getValue(), o4 = "ImportExpression" === r4.type, u4 = ug(r4);
    if (0 === u4.length) return sg([
        "(",
        ya.printDanglingComments(e13, t9, !0),
        ")"
    ]);
    if (2 === u4.length && "ArrowFunctionExpression" === u4[0].type && 0 === Km(u4[0]).length && "BlockStatement" === u4[0].body.type && "ArrayExpression" === u4[1].type && !u4.some((e14)=>e14.comments
    )) return sg([
        "(",
        e13.call(n5, "arguments", 0),
        ", ",
        e13.call(n5, "arguments", 1),
        ")"
    ]);
    let i5 = !1, a4 = !1, s4 = !1;
    const l4 = u4.length - 1, c4 = [];
    ig(e13, (e14, r5)=>{
        const o5 = e14.getNode(), u5 = [
            n5(e14)
        ];
        r5 === l4 || (Ym(t9.originalText, o5, ag) ? (0 === r5 && (s4 = !0), i5 = !0, u5.push(",", cg, cg)) : u5.push(",", lg)), a4 = (function(e15, t10) {
            if (!e15 || "ArrowFunctionExpression" !== e15.type || !e15.body || "BlockStatement" !== e15.body.type || 0 === Km(e15).length) return !1;
            let r6 = !1;
            return Qm(t10, (e16)=>{
                r6 = r6 || Dg(sg([
                    n5(e16)
                ]));
            }), r6;
        })(o5, e14), c4.push(sg(u5));
    });
    const p4 = o4 || r4.callee && "Import" === r4.callee.type || !og(t9, "all") ? "" : ",";
    function d4() {
        return dg(sg([
            "(",
            fg(sg([
                lg,
                sg(c4)
            ])),
            p4,
            lg,
            ")"
        ]), {
            shouldBreak: !0
        });
    }
    if ("Decorator" !== e13.getParentNode().type && tg(u4)) return d4();
    const f4 = function(e14) {
        if (2 !== e14.length) return !1;
        const [t10, n6] = e14;
        return !(t10.comments && t10.comments.length || "FunctionExpression" !== t10.type && ("ArrowFunctionExpression" !== t10.type || "BlockStatement" !== t10.body.type) || "FunctionExpression" === n6.type || "ArrowFunctionExpression" === n6.type || "ConditionalExpression" === n6.type || yg(n6));
    }(u4), h4 = function(e14) {
        const t10 = Hm(e14), n6 = Xm(e14);
        return !Zm(t10) && !eg(t10) && yg(t10) && (!n6 || n6.type !== t10.type);
    }(u4);
    if (f4 || h4) {
        const t10 = (f4 ? c4.slice(1).some(Dg) : c4.slice(0, -1).some(Dg)) || i5 || a4;
        let o5 = [];
        ig(e13, (e14, t11)=>{
            f4 && 0 === t11 && (o5 = [
                sg([
                    e14.call((e15)=>n5(e15, {
                            expandFirstArg: !0
                        })
                    ),
                    c4.length > 1 ? "," : "",
                    s4 ? cg : lg,
                    s4 ? cg : ""
                ])
            ].concat(c4.slice(1))), h4 && t11 === u4.length - 1 && (o5 = c4.slice(0, -1).concat(e14.call((e15)=>n5(e15, {
                    expandLastArg: !0
                })
            )));
        });
        const l5 = c4.some(Dg), p5 = sg([
            "(",
            sg(o5),
            ")"
        ]);
        return sg([
            l5 ? gg : "",
            hg([
                l5 || r4.typeArguments || r4.typeParameters ? mg(d4(), p5) : p5,
                sg(f4 ? [
                    "(",
                    dg(o5[0], {
                        shouldBreak: !0
                    }),
                    sg(o5.slice(1)),
                    ")"
                ] : [
                    "(",
                    sg(c4.slice(0, -1)),
                    dg(Hm(o5), {
                        shouldBreak: !0
                    }),
                    ")"
                ]),
                d4()
            ], {
                shouldBreak: t10
            })
        ]);
    }
    const m4 = sg([
        "(",
        fg(sg([
            pg,
            sg(c4)
        ])),
        mg(p4),
        pg,
        ")"
    ]);
    return rg(e13) ? m4 : dg(m4, {
        shouldBreak: c4.some(Dg) || i5
    });
};
const { builders: { concat: Cg , softline: bg , group: vg , indent: Ag  }  } = rn1, { isNumericLiteral: Fg  } = Cl, { printOptionalToken: xg  } = Xp;
function Sg(e13, t9, n5) {
    const r4 = e13.call(n5, "property"), o4 = e13.getValue(), u4 = xg(e13);
    return o4.computed ? !o4.property || Fg(o4.property) ? Cg([
        u4,
        "[",
        r4,
        "]"
    ]) : vg(Cg([
        u4,
        "[",
        Ag(Cg([
            bg,
            r4
        ])),
        bg,
        "]"
    ])) : Cg([
        u4,
        ".",
        r4
    ]);
}
var wg = {
    printMemberExpression: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = e13.getParentNode();
        let u4, i5 = 0;
        do {
            u4 = e13.getParentNode(i5), i5++;
        }while (u4 && ("MemberExpression" === u4.type || "OptionalMemberExpression" === u4.type || "TSNonNullExpression" === u4.type))
        const a4 = u4 && ("NewExpression" === u4.type || "BindExpression" === u4.type || "VariableDeclarator" === u4.type && "Identifier" !== u4.id.type || "AssignmentExpression" === u4.type && "Identifier" !== u4.left.type) || r4.computed || "Identifier" === r4.object.type && "Identifier" === r4.property.type && "MemberExpression" !== o4.type && "OptionalMemberExpression" !== o4.type;
        return Cg([
            e13.call(n5, "object"),
            a4 ? Sg(e13, t9, n5) : vg(Ag(Cg([
                bg,
                Sg(e13, t9, n5)
            ])))
        ]);
    },
    printMemberLookup: Sg
};
const { getLast: Tg , isNextLineEmpty: Bg , isNextLineEmptyAfterIndex: Ng , getNextNonSpaceNonCommentCharacterIndex: kg  } = Nt1, { hasLeadingComment: Pg , hasTrailingComment: Og , isCallOrOptionalCallExpression: Ig , isFunctionOrArrowExpression: Lg , isLongCurriedCallExpression: Mg , isMemberish: jg , isNumericLiteral: _g , isSimpleCallArgument: Rg  } = Cl, { locEnd: Vg  } = ei, { builders: { concat: $g , join: qg , hardline: Wg , group: Ug , indent: Jg , conditionalGroup: zg , breakParent: Gg  } , utils: { willBreak: Hg  }  } = rn1, { printMemberLookup: Xg  } = wg, { printOptionalToken: Yg , printFunctionTypeParameters: Kg , printBindExpressionCallee: Qg  } = Xp;
var Zg = function(e13, t9, n5) {
    const r4 = e13.getParentNode(), o4 = !r4 || "ExpressionStatement" === r4.type, u4 = [];
    function i5(e14) {
        const { originalText: n6  } = t9, r5 = kg(n6, e14, Vg);
        return ")" === n6.charAt(r5) ? !1 !== r5 && Ng(n6, r5 + 1) : Bg(n6, e14, Vg);
    }
    function a4(e14) {
        const r5 = e14.getValue();
        Ig(r5) && (jg(r5.callee) || Ig(r5.callee)) ? (u4.unshift({
            node: r5,
            printed: $g([
                ya.printComments(e14, ()=>$g([
                        Yg(e14),
                        Kg(e14, t9, n5),
                        Eg(e14, t9, n5)
                    ])
                , t9),
                i5(r5) ? Wg : ""
            ])
        }), e14.call((e15)=>a4(e15)
        , "callee")) : jg(r5) ? (u4.unshift({
            node: r5,
            needsParens: Pp(e14, t9),
            printed: ya.printComments(e14, ()=>"OptionalMemberExpression" === r5.type || "MemberExpression" === r5.type ? Xg(e14, t9, n5) : Qg(e14, t9, n5)
            , t9)
        }), e14.call((e15)=>a4(e15)
        , "object")) : "TSNonNullExpression" === r5.type ? (u4.unshift({
            node: r5,
            printed: ya.printComments(e14, ()=>"!"
            , t9)
        }), e14.call((e15)=>a4(e15)
        , "expression")) : u4.unshift({
            node: r5,
            printed: e14.call(n5)
        });
    }
    const s4 = e13.getValue();
    u4.unshift({
        node: s4,
        printed: $g([
            Yg(e13),
            Kg(e13, t9, n5),
            Eg(e13, t9, n5)
        ])
    }), s4.callee && e13.call((e14)=>a4(e14)
    , "callee");
    const l4 = [];
    let c4 = [
        u4[0]
    ], p4 = 1;
    for(; p4 < u4.length && ("TSNonNullExpression" === u4[p4].node.type || Ig(u4[p4].node) || ("MemberExpression" === u4[p4].node.type || "OptionalMemberExpression" === u4[p4].node.type) && u4[p4].node.computed && _g(u4[p4].node.property)); ++p4)c4.push(u4[p4]);
    if (!Ig(u4[0].node)) for(; p4 + 1 < u4.length && (jg(u4[p4].node) && jg(u4[p4 + 1].node)); ++p4)c4.push(u4[p4]);
    l4.push(c4), c4 = [];
    let d4 = !1;
    for(; p4 < u4.length; ++p4){
        if (d4 && jg(u4[p4].node)) {
            if (u4[p4].node.computed && _g(u4[p4].node.property)) {
                c4.push(u4[p4]);
                continue;
            }
            l4.push(c4), c4 = [], d4 = !1;
        }
        (Ig(u4[p4].node) || "ImportExpression" === u4[p4].node.type) && (d4 = !0), c4.push(u4[p4]), u4[p4].node.comments && u4[p4].node.comments.some((e14)=>e14.trailing
        ) && (l4.push(c4), c4 = [], d4 = !1);
    }
    function f4(e14) {
        return /^[A-Z]|^[$_]+$/.test(e14);
    }
    c4.length > 0 && l4.push(c4);
    const h4 = l4.length >= 2 && !l4[1][0].node.comments && function(e14) {
        const n6 = e14[1].length && e14[1][0].node.computed;
        if (1 === e14[0].length) {
            const r5 = e14[0][0].node;
            return "ThisExpression" === r5.type || "Identifier" === r5.type && (f4(r5.name) || o4 && (function(e15) {
                return e15.length <= t9.tabWidth;
            })(r5.name) || n6);
        }
        const r5 = Tg(e14[0]).node;
        return ("MemberExpression" === r5.type || "OptionalMemberExpression" === r5.type) && "Identifier" === r5.property.type && (f4(r5.property.name) || n6);
    }(l4);
    function m4(e14) {
        const t10 = e14.map((e15)=>e15.printed
        );
        return e14.length > 0 && e14[e14.length - 1].needsParens ? $g([
            "(",
            ...t10,
            ")"
        ]) : $g(t10);
    }
    const g4 = l4.map(m4), D4 = $g(g4), y4 = h4 ? 3 : 2, E4 = Uu(l4), C3 = E4.slice(1, -1).some((e14)=>Pg(e14.node)
    ) || E4.slice(0, -1).some((e14)=>Og(e14.node)
    ) || l4[y4] && Pg(l4[y4][0].node);
    if (l4.length <= y4 && !C3) return Mg(e13) ? D4 : Ug(D4);
    const b3 = Tg(l4[h4 ? 1 : 0]).node, v3 = !Ig(b3) && i5(b3), A3 = $g([
        m4(l4[0]),
        h4 ? $g(l4.slice(1, 2).map(m4)) : "",
        v3 ? Wg : "",
        function(e14) {
            return 0 === e14.length ? "" : Jg(Ug($g([
                Wg,
                qg(Wg, e14.map(m4))
            ])));
        }(l4.slice(h4 ? 2 : 1))
    ]), F3 = u4.map(({ node: e14  })=>e14
    ).filter(Ig);
    return C3 || F3.length > 2 && F3.some((e14)=>!e14.arguments.every((e15)=>Rg(e15, 0)
        )
    ) || g4.slice(0, -1).some(Hg) || function() {
        const e14 = Tg(Tg(l4)).node, t10 = Tg(g4);
        return Ig(e14) && Hg(t10) && F3.slice(0, -1).some((e15)=>e15.arguments.some(Lg)
        );
    }() ? Ug(A3) : $g([
        Hg(D4) || v3 ? Gg : "",
        zg([
            D4,
            A3
        ])
    ]);
};
const { builders: { concat: eD , join: tD , group: nD  }  } = rn1, { getCallArguments: rD , hasFlowAnnotationComment: oD , isCallOrOptionalCallExpression: uD , isMemberish: iD , isTemplateOnItsOwnLine: aD , isTestCall: sD , iterateCallArgumentsPath: lD  } = Cl, { printOptionalToken: cD , printFunctionTypeParameters: pD  } = Xp;
var dD = {
    printCallExpression: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = "NewExpression" === r4.type, u4 = "ImportExpression" === r4.type, i5 = cD(e13), a4 = rD(r4);
        if (a4.length > 0 && (!u4 && !o4 && "Identifier" === r4.callee.type && ("require" === r4.callee.name || "define" === r4.callee.name) || 1 === a4.length && aD(a4[0], t9.originalText) || !o4 && sD(r4, e13.getParentNode()))) {
            const r5 = [];
            return (lD(e13, (e14)=>{
                r5.push(n5(e14));
            }), eD([
                o4 ? "new " : "",
                e13.call(n5, "callee"),
                i5,
                pD(e13, t9, n5),
                eD([
                    "(",
                    tD(", ", r5),
                    ")"
                ])
            ]));
        }
        const s4 = ("babel" === t9.parser || "babel-flow" === t9.parser) && r4.callee && "Identifier" === r4.callee.type && oD(r4.callee.trailingComments);
        if ((s4 && (r4.callee.trailingComments[0].printed = !0), !u4 && !o4 && iD(r4.callee) && !e13.call((e14)=>Pp(e14, t9)
        , "callee"))) return Zg(e13, t9, n5);
        const l4 = eD([
            o4 ? "new " : "",
            u4 ? "import" : e13.call(n5, "callee"),
            i5,
            s4 ? "/*:: ".concat(r4.callee.trailingComments[0].value.slice(2).trim(), " */") : "",
            pD(e13, t9, n5),
            Eg(e13, t9, n5)
        ]);
        return u4 || uD(r4.callee) ? nD(l4) : l4;
    }
};
const { builders: { concat: fD , join: hD , line: mD , group: gD , indent: DD , ifBreak: yD  }  } = rn1, { hasTrailingComment: ED , hasTrailingLineComment: CD , identity: bD  } = Cl, { getTypeParametersGroupId: vD  } = Wh, { printTypeScriptModifiers: AD  } = Xp;
var FD = {
    printInterface: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [];
        ("DeclareInterface" === r4.type || r4.declare) && o4.push("declare "), "TSInterfaceDeclaration" === r4.type && o4.push(r4.abstract ? "abstract " : "", AD(e13, t9, n5)), o4.push("interface");
        const u4 = [], i5 = [];
        "InterfaceTypeAnnotation" !== r4.type && u4.push(" ", e13.call(n5, "id"), e13.call(n5, "typeParameters"));
        const a4 = r4.typeParameters && !CD(r4.typeParameters);
        if ((r4.extends && 0 !== r4.extends.length && i5.push(a4 ? yD(" ", mD, {
            groupId: vD(r4.typeParameters)
        }) : mD, "extends ", (1 === r4.extends.length ? bD : DD)(hD(fD([
            ",",
            mD
        ]), e13.map(n5, "extends")))), r4.id && ED(r4.id) || r4.extends && 0 !== r4.extends.length)) {
            const e14 = fD(i5);
            a4 ? o4.push(gD(fD(u4.concat(yD(DD(e14), e14))))) : o4.push(gD(DD(fD(u4.concat(e14)))));
        } else o4.push(...u4, ...i5);
        return (o4.push(" ", e13.call(n5, "body")), gD(fD(o4)));
    }
};
const { printComments: xD  } = ya, { getLast: SD  } = Nt1, { builders: { concat: wD , join: TD , line: BD , softline: ND , group: kD , indent: PD , align: OD , ifBreak: ID  } , utils: { normalizeParts: LD  }  } = rn1, { hasLeadingOwnLineComment: MD , hasTrailingLineComment: jD , isBinaryish: _D , isJSXNode: RD , shouldFlatten: VD  } = Cl;
function qD(e13, t9, n5, r4, o4) {
    let u4 = [];
    const i5 = e13.getValue();
    if (_D(i5)) {
        VD(i5.operator, i5.left.operator) ? u4 = u4.concat(e13.call((e14)=>qD(e14, t9, n5, !0, o4)
        , "left")) : u4.push(kD(e13.call(t9, "left")));
        const a4 = WD(i5), s4 = ("|>" === i5.operator || "NGPipeExpression" === i5.type || "|" === i5.operator && "__vue_expression" === n5.parser) && !MD(n5.originalText, i5.right), l4 = "NGPipeExpression" === i5.type ? "|" : i5.operator, c4 = "NGPipeExpression" === i5.type && 0 !== i5.arguments.length ? kD(PD(wD([
            ND,
            ": ",
            TD(wD([
                ND,
                ":",
                ID(" ")
            ]), e13.map(t9, "arguments").map((e14)=>OD(2, kD(e14))
            ))
        ]))) : "", p4 = wD(a4 ? [
            l4,
            " ",
            e13.call(t9, "right"),
            c4
        ] : [
            s4 ? BD : "",
            l4,
            s4 ? " " : BD,
            e13.call(t9, "right"),
            c4
        ]), d4 = e13.getParentNode(), f4 = jD(i5.left), h4 = f4 || !(o4 && "LogicalExpression" === i5.type) && d4.type !== i5.type && i5.left.type !== i5.type && i5.right.type !== i5.type;
        u4.push(s4 ? "" : " ", h4 ? kD(p4, {
            shouldBreak: f4
        }) : p4), r4 && i5.comments && (u4 = LD(xD(e13, ()=>wD(u4)
        , n5).parts));
    } else u4.push(kD(e13.call(t9)));
    return u4;
}
function WD(e13) {
    return "LogicalExpression" === e13.type && ("ObjectExpression" === e13.right.type && 0 !== e13.right.properties.length || ("ArrayExpression" === e13.right.type && 0 !== e13.right.elements.length || !!RD(e13.right)));
}
var UD = {
    printBinaryishExpression: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = e13.getParentNode(), u4 = e13.getParentNode(1), i5 = r4 !== o4.body && ("IfStatement" === o4.type || "WhileStatement" === o4.type || "SwitchStatement" === o4.type || "DoWhileStatement" === o4.type), a4 = qD(e13, n5, t9, !1, i5);
        if (i5) return wD(a4);
        if (("CallExpression" === o4.type || "OptionalCallExpression" === o4.type) && o4.callee === r4 || "UnaryExpression" === o4.type || ("MemberExpression" === o4.type || "OptionalMemberExpression" === o4.type) && !o4.computed) return kD(wD([
            PD(wD([
                ND,
                wD(a4)
            ])),
            ND
        ]));
        const s4 = "ReturnStatement" === o4.type || "ThrowStatement" === o4.type || "JSXExpressionContainer" === o4.type && "JSXAttribute" === u4.type || "|" !== r4.operator && "JsExpressionRoot" === o4.type || "NGPipeExpression" !== r4.type && ("NGRoot" === o4.type && "__ng_binding" === t9.parser || "NGMicrosyntaxExpression" === o4.type && "NGMicrosyntax" === u4.type && 1 === u4.body.length) || r4 === o4.body && "ArrowFunctionExpression" === o4.type || r4 !== o4.body && "ForStatement" === o4.type || "ConditionalExpression" === o4.type && "ReturnStatement" !== u4.type && "ThrowStatement" !== u4.type && "CallExpression" !== u4.type && "OptionalCallExpression" !== u4.type || "TemplateLiteral" === o4.type, l4 = "AssignmentExpression" === o4.type || "VariableDeclarator" === o4.type || "ClassProperty" === o4.type || "FieldDefinition" === o4.type || "TSAbstractClassProperty" === o4.type || "ClassPrivateProperty" === o4.type || "ObjectProperty" === o4.type || "Property" === o4.type, c4 = _D(r4.left) && VD(r4.operator, r4.left.operator);
        if (s4 || WD(r4) && !c4 || !WD(r4) && l4) return kD(wD(a4));
        if (0 === a4.length) return "";
        const p4 = RD(r4.right), d4 = a4.findIndex((e14)=>"string" != typeof e14 && "group" === e14.type
        ), f4 = a4.slice(0, -1 === d4 ? 1 : d4 + 1), h4 = wD(a4.slice(f4.length, p4 ? -1 : void 0)), m4 = Symbol("logicalChain-" + ++$D), g4 = kD(wD([
            ...f4,
            PD(h4)
        ]), {
            id: m4
        });
        if (!p4) return g4;
        const D4 = SD(a4);
        return kD(wD([
            g4,
            ID(PD(D4), D4, {
                groupId: m4
            })
        ]));
    },
    shouldInlineLogicalExpression: WD
};
const { builders: { concat: JD , line: zD , group: GD , indent: HD  }  } = rn1, { hasLeadingOwnLineComment: XD , isBinaryish: YD , isMemberExpressionChain: KD , isStringLiteral: QD  } = Cl, { shouldInlineLogicalExpression: ZD  } = UD;
function ey(e13, t9, n5, r4, o4, u4) {
    if (!r4) return t9;
    const i5 = ty(e13, r4, o4, u4);
    return GD(JD([
        t9,
        n5,
        i5
    ]));
}
function ty(e13, t9, n5, r4) {
    if (XD(r4.originalText, t9)) return HD(JD([
        zD,
        n5
    ]));
    return YD(t9) && !ZD(t9) || "ConditionalExpression" === t9.type && YD(t9.test) && !ZD(t9.test) || "StringLiteralTypeAnnotation" === t9.type || "ClassExpression" === t9.type && t9.decorators && t9.decorators.length || ("Identifier" === e13.type || QD(e13) || "MemberExpression" === e13.type) && (QD(t9) || KD(t9)) && "json" !== r4.parser && "json5" !== r4.parser || "SequenceExpression" === t9.type ? GD(HD(JD([
        zD,
        n5
    ]))) : JD([
        " ",
        n5
    ]);
}
var ny = {
    printVariableDeclarator: function(e13, t9, n5) {
        const r4 = e13.getValue();
        return ey(r4.id, e13.call(n5, "id"), " =", r4.init, r4.init && e13.call(n5, "init"), t9);
    },
    printAssignmentExpression: function(e13, t9, n5) {
        const r4 = e13.getValue();
        return ey(r4.left, e13.call(n5, "left"), JD([
            " ",
            r4.operator
        ]), r4.right, e13.call(n5, "right"), t9);
    },
    printAssignment: ey,
    printAssignmentRight: ty
};
const { isNextLineEmpty: ry  } = Nt1, { builders: { concat: oy , join: uy , hardline: iy  }  } = rn1, { classChildNeedsASIProtection: ay , classPropMayCauseASIProblems: sy , getLeftSidePathName: ly , hasNakedLeftSide: cy , isJSXNode: py , isLastStatement: dy , isTheOnlyJSXElementInMarkdown: fy  } = Cl, { locEnd: hy  } = ei, { shouldPrintParamsWithoutParens: my  } = Tm;
function gy({ path: e13 , index: t9 , bodyNode: n5 , isClass: r4  }, o4, u4) {
    const i5 = e13.getValue();
    if (!i5) return;
    if ("EmptyStatement" === i5.type) return;
    const a4 = u4(e13), s4 = o4.originalText, l4 = [];
    if (o4.semi || r4 || fy(o4, e13) || !(function(e14, t10) {
        if ("ExpressionStatement" !== e14.getNode().type) return !1;
        return e14.call((e15)=>Dy(e15, t10)
        , "expression");
    })(e13, o4) ? l4.push(a4) : i5.comments && i5.comments.some((e14)=>e14.leading
    ) ? l4.push(u4(e13, {
        needsSemi: !0
    })) : l4.push(";", a4), !o4.semi && r4) {
        if (sy(e13)) l4.push(";");
        else if ("ClassProperty" === i5.type || "FieldDefinition" === i5.type) {
            const e14 = n5.body[t9 + 1];
            ay(e14) && l4.push(";");
        }
    }
    return ry(s4, i5, hy) && !dy(e13) && l4.push(iy), oy(l4);
}
function Dy(e13, t9) {
    const n5 = e13.getValue();
    return !!(Pp(e13, t9) || "ParenthesizedExpression" === n5.type || "TypeCastExpression" === n5.type || "ArrowFunctionExpression" === n5.type && !my(e13, t9) || "ArrayExpression" === n5.type || "ArrayPattern" === n5.type || "UnaryExpression" === n5.type && n5.prefix && ("+" === n5.operator || "-" === n5.operator) || "TemplateLiteral" === n5.type || "TemplateElement" === n5.type || py(n5) || "BindExpression" === n5.type && !n5.object || "RegExpLiteral" === n5.type || "Literal" === n5.type && n5.pattern || "Literal" === n5.type && n5.regex) || !!cy(n5) && e13.call((e14)=>Dy(e14, t9)
    , ...ly(e13, n5));
}
var yy = {
    printStatementSequence: function(e13, t9, n5) {
        const r4 = e13.getNode(), o4 = "ClassBody" === r4.type, u4 = e13.map((u5, i5)=>gy({
                path: e13,
                index: i5,
                bodyNode: r4,
                isClass: o4
            }, t9, n5)
        ).filter(Boolean);
        return uy(iy, u4);
    }
};
const { printDanglingComments: Ey  } = ya, { isNextLineEmpty: Cy  } = Nt1, { builders: { concat: by , hardline: vy , indent: Ay  }  } = rn1, { hasDanglingComments: Fy  } = Cl, { locEnd: xy  } = ei, { printStatementSequence: Sy  } = yy;
var wy = {
    printBlock: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = [], u4 = t9.semi ? ";" : "", i5 = e13.call((e14)=>Sy(e14, t9, n5)
        , "body");
        "StaticBlock" === r4.type && o4.push("static ");
        const a4 = r4.body.some((e14)=>"EmptyStatement" !== e14.type
        ), s4 = r4.directives && r4.directives.length > 0, l4 = e13.getParentNode(), c4 = e13.getParentNode(1);
        return a4 || s4 || Fy(r4) || "ArrowFunctionExpression" !== l4.type && "FunctionExpression" !== l4.type && "FunctionDeclaration" !== l4.type && "ObjectMethod" !== l4.type && "ClassMethod" !== l4.type && "ClassPrivateMethod" !== l4.type && "ForStatement" !== l4.type && "WhileStatement" !== l4.type && "DoWhileStatement" !== l4.type && "DoExpression" !== l4.type && ("CatchClause" !== l4.type || c4.finalizer) && "TSModuleDeclaration" !== l4.type && "TSDeclareFunction" !== l4.type && "StaticBlock" !== r4.type ? (o4.push("{"), s4 && e13.each((e14)=>{
            o4.push(Ay(by([
                vy,
                n5(e14),
                u4
            ]))), Cy(t9.originalText, e14.getValue(), xy) && o4.push(vy);
        }, "directives"), a4 && o4.push(Ay(by([
            vy,
            i5
        ]))), o4.push(Ey(e13, t9)), o4.push(vy, "}"), by(o4)) : by([
            ...o4,
            "{}"
        ]);
    }
};
const { hasNewline: Ty  } = Nt1, { builders: { concat: By , join: Ny , hardline: ky  }  } = rn1, { isLineComment: Py , isBlockComment: Oy  } = Cl, { locStart: Iy , locEnd: Ly  } = ei;
var My = {
    printComment: function(e13, t9) {
        const n5 = e13.getValue();
        if (Py(n5)) return t9.originalText.slice(Iy(n5), Ly(n5)).trimEnd();
        if (Oy(n5)) {
            if (function(e14) {
                const t10 = "*".concat(e14.value, "*").split("\n");
                return t10.length > 1 && t10.every((e15)=>"*" === e15.trim()[0]
                );
            }(n5)) {
                const e14 = function(e15) {
                    const t10 = e15.value.split("\n");
                    return By([
                        "/*",
                        Ny(ky, t10.map((e16, n6)=>0 === n6 ? e16.trimEnd() : " " + (n6 < t10.length - 1 ? e16.trim() : e16.trimStart())
                        )),
                        "*/"
                    ]);
                }(n5);
                return n5.trailing && !Ty(t9.originalText, Iy(n5), {
                    backwards: !0
                }) ? By([
                    ky,
                    e14
                ]) : e14;
            }
            const e14 = Ly(n5), r4 = "*-/" === t9.originalText.slice(e14 - 3, e14);
            return "/*" + n5.value + (r4 ? "*-/" : "*/");
        }
        throw new Error("Not a comment: " + JSON.stringify(n5));
    }
};
const { hasNewline: jy , hasNewlineInRange: _y , getLast: Ry , printString: Vy , printNumber: $y , isNextLineEmpty: qy  } = Nt1, { builders: { concat: Wy , join: Uy , line: Jy , hardline: zy , softline: Gy , literalline: Hy , group: Xy , indent: Yy , align: Ky , conditionalGroup: Qy , ifBreak: Zy  } , utils: { isEmpty: eE  }  } = rn1, { insertPragma: tE  } = Ep, { printHtmlBinding: nE , isVueEventBindingExpression: rE  } = Rp, { getFunctionParameters: oE , getCallArguments: uE , getParentExportDeclaration: iE , getTypeScriptMappedTypeModifier: aE , hasDanglingComments: sE , hasFlowShorthandAnnotationComment: lE , hasLeadingOwnLineComment: cE , hasNewlineBetweenOrAfterDecorators: pE , hasNgSideEffect: dE , hasPrettierIgnore: fE , hasTrailingComment: hE , isExportDeclaration: mE , isFunctionNotation: gE , isGetterOrSetter: DE , isLiteral: yE , isNgForOf: EE , isObjectType: CE , isObjectTypePropertyAFunction: bE , isTheOnlyJSXElementInMarkdown: vE , isTSXFile: AE , isBlockComment: FE , needsHardlineAfterDanglingComment: xE , rawText: SE , shouldPrintComma: wE  } = Cl, { locStart: TE , locEnd: BE  } = ei, { printOptionalToken: NE , printBindExpressionCallee: kE , printTypeScriptModifiers: PE , printDecorators: OE , printFlowDeclaration: IE , adjustClause: LE  } = Xp, { printImportDeclaration: ME , printExportDeclaration: jE , printExportAllDeclaration: _E , printModuleSpecifier: RE  } = hd, { printFunctionParameters: VE  } = Zd, { printTemplateLiteral: $E  } = Dc, { printArray: qE , printArrayItems: WE  } = bf, { printObject: UE  } = Uf, { printTypeAnnotation: JE , shouldHugType: zE  } = of, { printJsxElement: GE , printJsxAttribute: HE , printJsxOpeningElement: XE , printJsxClosingElement: YE , printJsxOpeningClosingFragment: KE , printJsxExpressionContainer: QE , printJsxEmptyExpression: ZE , printJsxSpreadAttribute: eC , printJsxSpreadChild: tC  } = xh, { printClass: nC , printClassMethod: rC  } = Gm, { printTypeParameters: oC  } = Wh, { printPropertyKey: uC  } = em, { printFunctionDeclaration: iC , printArrowFunctionExpression: aC , printMethod: sC , printReturnAndThrowArgument: lC  } = Tm, { printCallExpression: cC  } = dD, { printInterface: pC  } = FD, { printVariableDeclarator: dC , printAssignmentExpression: fC , printAssignment: hC , printAssignmentRight: mC  } = ny, { printBinaryishExpression: gC  } = UD, { printStatementSequence: DC  } = yy, { printMemberExpression: yC  } = wg, { printBlock: EC  } = wy, { printComment: CC  } = My;
function bC(e13, t9, n5) {
    const r4 = SE(e13), o4 = n5 || "DirectiveLiteral" === e13.type;
    return Vy(r4, t9, o4);
}
var AC = {
    preprocess: Vp,
    print: function(e13, t9, n5, r4) {
        const o4 = e13.getValue();
        let u4 = !1;
        const i5 = function(e14, t10, n6, r5) {
            const o5 = e14.getValue(), u5 = t10.semi ? ";" : "";
            if (!o5) return "";
            if ("string" == typeof o5) return o5;
            const i6 = nE(e14, t10, n6);
            if (i6) return i6;
            let a4 = [];
            switch(o5.type){
                case "JsExpressionRoot":
                    return e14.call(n6, "node");
                case "JsonRoot":
                    return Wy([
                        e14.call(n6, "node"),
                        zy
                    ]);
                case "File":
                    return o5.program && o5.program.interpreter && a4.push(e14.call((e15)=>e15.call(n6, "interpreter")
                    , "program")), a4.push(e14.call(n6, "program")), Wy(a4);
                case "Program":
                    {
                        const r6 = !o5.body.every(({ type: e15  })=>"EmptyStatement" === e15
                        ) || o5.comments;
                        if (o5.directives) {
                            const i7 = o5.directives.length;
                            e14.each((e15, o6)=>{
                                a4.push(n6(e15), u5, zy), (o6 < i7 - 1 || r6) && qy(t10.originalText, e15.getValue(), BE) && a4.push(zy);
                            }, "directives");
                        }
                        return a4.push(e14.call((e15)=>DC(e15, t10, n6)
                        , "body")), a4.push(ya.printDanglingComments(e14, t10, !0)), r6 && a4.push(zy), Wy(a4);
                    }
                case "EmptyStatement":
                    return "";
                case "ExpressionStatement":
                    if (o5.directive) return Wy([
                        bC(o5.expression, t10, !0),
                        u5
                    ]);
                    if ("__vue_event_binding" === t10.parser) {
                        const t11 = e14.getParentNode();
                        if ("Program" === t11.type && 1 === t11.body.length && t11.body[0] === o5) return Wy([
                            e14.call(n6, "expression"),
                            rE(o5.expression) ? ";" : ""
                        ]);
                    }
                    return Wy([
                        e14.call(n6, "expression"),
                        vE(t10, e14) ? "" : u5
                    ]);
                case "ParenthesizedExpression":
                    return !o5.expression.comments ? Wy([
                        "(",
                        e14.call(n6, "expression"),
                        ")"
                    ]) : Xy(Wy([
                        "(",
                        Yy(Wy([
                            Gy,
                            e14.call(n6, "expression")
                        ])),
                        Gy,
                        ")"
                    ]));
                case "AssignmentExpression":
                    return fC(e14, t10, n6);
                case "VariableDeclarator":
                    return dC(e14, t10, n6);
                case "BinaryExpression":
                case "LogicalExpression":
                case "NGPipeExpression":
                    return gC(e14, t10, n6);
                case "AssignmentPattern":
                    return Wy([
                        e14.call(n6, "left"),
                        " = ",
                        e14.call(n6, "right")
                    ]);
                case "TSTypeAssertion":
                    {
                        const t11 = !("ArrayExpression" === o5.expression.type || "ObjectExpression" === o5.expression.type), r6 = Xy(Wy([
                            "<",
                            Yy(Wy([
                                Gy,
                                e14.call(n6, "typeAnnotation")
                            ])),
                            Gy,
                            ">"
                        ])), u6 = Wy([
                            Zy("("),
                            Yy(Wy([
                                Gy,
                                e14.call(n6, "expression")
                            ])),
                            Gy,
                            Zy(")")
                        ]);
                        return t11 ? Qy([
                            Wy([
                                r6,
                                e14.call(n6, "expression")
                            ]),
                            Wy([
                                r6,
                                Xy(u6, {
                                    shouldBreak: !0
                                })
                            ]),
                            Wy([
                                r6,
                                e14.call(n6, "expression")
                            ])
                        ]) : Xy(Wy([
                            r6,
                            e14.call(n6, "expression")
                        ]));
                    }
                case "OptionalMemberExpression":
                case "MemberExpression":
                    return yC(e14, t10, n6);
                case "MetaProperty":
                    return Wy([
                        e14.call(n6, "meta"),
                        ".",
                        e14.call(n6, "property")
                    ]);
                case "BindExpression":
                    return o5.object && a4.push(e14.call(n6, "object")), a4.push(Xy(Yy(Wy([
                        Gy,
                        kE(e14, t10, n6)
                    ])))), Wy(a4);
                case "Identifier":
                    return Wy([
                        o5.name,
                        NE(e14),
                        JE(e14, t10, n6)
                    ]);
                case "V8IntrinsicIdentifier":
                    return Wy([
                        "%",
                        o5.name
                    ]);
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                case "ObjectTypeSpreadProperty":
                    return Wy([
                        "...",
                        e14.call(n6, "argument"),
                        JE(e14, t10, n6)
                    ]);
                case "FunctionDeclaration":
                case "FunctionExpression":
                    return a4.push(iC(e14, n6, t10, r5 && r5.expandLastArg && uE(e14.getParentNode()).length > 1)), o5.body || a4.push(u5), Wy(a4);
                case "ArrowFunctionExpression":
                    return aC(e14, t10, n6, r5);
                case "YieldExpression":
                    return a4.push("yield"), o5.delegate && a4.push("*"), o5.argument && a4.push(" ", e14.call(n6, "argument")), Wy(a4);
                case "AwaitExpression":
                    {
                        a4.push("await"), o5.argument && a4.push(" ", e14.call(n6, "argument"));
                        const t11 = e14.getParentNode();
                        return ("CallExpression" === t11.type || "OptionalCallExpression" === t11.type) && t11.callee === o5 || ("MemberExpression" === t11.type || "OptionalMemberExpression" === t11.type) && t11.object === o5 ? Xy(Wy([
                            Yy(Wy([
                                Gy,
                                Wy(a4)
                            ])),
                            Gy
                        ])) : Wy(a4);
                    }
                case "TSExportAssignment":
                    return Wy([
                        "export = ",
                        e14.call(n6, "expression"),
                        u5
                    ]);
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                case "DeclareExportDeclaration":
                    return jE(e14, t10, n6);
                case "ExportAllDeclaration":
                case "DeclareExportAllDeclaration":
                    return _E(e14, t10, n6);
                case "ImportDeclaration":
                    return ME(e14, t10, n6);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                    return RE(e14, t10, n6);
                case "ImportAttribute":
                    return Wy([
                        e14.call(n6, "key"),
                        ": ",
                        e14.call(n6, "value")
                    ]);
                case "Import":
                    return "import";
                case "TSModuleBlock":
                case "BlockStatement":
                case "StaticBlock":
                    return EC(e14, t10, n6);
                case "ThrowStatement":
                case "ReturnStatement":
                    return Wy([
                        "ReturnStatement" === o5.type ? "return" : "throw",
                        lC(e14, t10, n6)
                    ]);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                    return cC(e14, t10, n6);
                case "ObjectTypeInternalSlot":
                    return Wy([
                        o5.static ? "static " : "",
                        "[[",
                        e14.call(n6, "id"),
                        "]]",
                        NE(e14),
                        o5.method ? "" : ": ",
                        e14.call(n6, "value")
                    ]);
                case "ObjectExpression":
                case "ObjectPattern":
                case "ObjectTypeAnnotation":
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                case "RecordExpression":
                    return UE(e14, t10, n6);
                case "ObjectProperty":
                case "Property":
                    return o5.method || "get" === o5.kind || "set" === o5.kind ? sC(e14, t10, n6) : (o5.shorthand ? a4.push(e14.call(n6, "value")) : a4.push(hC(o5.key, uC(e14, t10, n6), ":", o5.value, e14.call(n6, "value"), t10)), Wy(a4));
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                    return rC(e14, t10, n6);
                case "ObjectMethod":
                    return sC(e14, t10, n6);
                case "Decorator":
                    return Wy([
                        "@",
                        e14.call(n6, "expression"),
                        e14.call(n6, "callee")
                    ]);
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                    return qE(e14, t10, n6);
                case "SequenceExpression":
                    {
                        const t11 = e14.getParentNode(0);
                        if ("ExpressionStatement" === t11.type || "ForStatement" === t11.type) {
                            const t12 = [];
                            return e14.each((e15)=>{
                                0 === e15.getName() ? t12.push(n6(e15)) : t12.push(",", Yy(Wy([
                                    Jy,
                                    n6(e15)
                                ])));
                            }, "expressions"), Xy(Wy(t12));
                        }
                        return Xy(Wy([
                            Uy(Wy([
                                ",",
                                Jy
                            ]), e14.map(n6, "expressions"))
                        ]));
                    }
                case "ThisExpression":
                    return "this";
                case "Super":
                    return "super";
                case "NullLiteral":
                    return "null";
                case "RegExpLiteral":
                    return vC(o5);
                case "NumericLiteral":
                    return $y(o5.extra.raw);
                case "DecimalLiteral":
                    return $y(o5.value) + "m";
                case "BigIntLiteral":
                    return (o5.bigint || o5.extra.raw).toLowerCase();
                case "BooleanLiteral":
                case "StringLiteral":
                case "Literal":
                    return o5.regex ? vC(o5.regex) : o5.bigint ? o5.raw.toLowerCase() : "number" == typeof o5.value ? $y(o5.raw) : "string" != typeof o5.value ? "" + o5.value : bC(o5, t10);
                case "Directive":
                    return e14.call(n6, "value");
                case "DirectiveLiteral":
                    return bC(o5, t10);
                case "UnaryExpression":
                    return a4.push(o5.operator), /[a-z]$/.test(o5.operator) && a4.push(" "), o5.argument.comments && o5.argument.comments.length > 0 ? a4.push(Xy(Wy([
                        "(",
                        Yy(Wy([
                            Gy,
                            e14.call(n6, "argument")
                        ])),
                        Gy,
                        ")"
                    ]))) : a4.push(e14.call(n6, "argument")), Wy(a4);
                case "UpdateExpression":
                    return a4.push(e14.call(n6, "argument"), o5.operator), o5.prefix && a4.reverse(), Wy(a4);
                case "ConditionalExpression":
                    return Bd(e14, t10, n6, {
                        beforeParts: ()=>[
                                e14.call(n6, "test")
                            ]
                        ,
                        afterParts: (e15)=>[
                                e15 ? Gy : ""
                            ]
                        ,
                        shouldCheckJsx: !0,
                        conditionalNodeType: "ConditionalExpression",
                        consequentNodePropertyName: "consequent",
                        alternateNodePropertyName: "alternate",
                        testNodePropertyNames: [
                            "test"
                        ]
                    });
                case "VariableDeclaration":
                    {
                        const t11 = e14.map((e15)=>n6(e15)
                        , "declarations"), r6 = e14.getParentNode(), i7 = "ForStatement" === r6.type || "ForInStatement" === r6.type || "ForOfStatement" === r6.type, s4 = o5.declarations.some((e15)=>e15.init
                        );
                        let l4;
                        return 1 !== t11.length || o5.declarations[0].comments ? t11.length > 0 && (l4 = Yy(t11[0])) : l4 = t11[0], a4 = [
                            o5.declare ? "declare " : "",
                            o5.kind,
                            l4 ? Wy([
                                " ",
                                l4
                            ]) : "",
                            Yy(Wy(t11.slice(1).map((e15)=>Wy([
                                    ",",
                                    s4 && !i7 ? zy : Jy,
                                    e15
                                ])
                            )))
                        ], i7 && r6.body !== o5 || a4.push(u5), Xy(Wy(a4));
                    }
                case "TSTypeAliasDeclaration":
                    {
                        o5.declare && a4.push("declare ");
                        const r6 = mC(o5.id, o5.typeAnnotation, o5.typeAnnotation && e14.call(n6, "typeAnnotation"), t10);
                        return a4.push("type ", e14.call(n6, "id"), e14.call(n6, "typeParameters"), " =", r6, u5), Xy(Wy(a4));
                    }
                case "WithStatement":
                    return Xy(Wy([
                        "with (",
                        e14.call(n6, "object"),
                        ")",
                        LE(o5.body, e14.call(n6, "body"))
                    ]));
                case "IfStatement":
                    {
                        const r6 = LE(o5.consequent, e14.call(n6, "consequent")), u6 = Xy(Wy([
                            "if (",
                            Xy(Wy([
                                Yy(Wy([
                                    Gy,
                                    e14.call(n6, "test")
                                ])),
                                Gy
                            ])),
                            ")",
                            r6
                        ]));
                        if (a4.push(u6), o5.alternate) {
                            const r7 = hE(o5.consequent) && o5.consequent.comments.some((e15)=>e15.trailing && !FE(e15)
                            ) || xE(o5), u7 = "BlockStatement" === o5.consequent.type && !r7;
                            a4.push(u7 ? " " : zy), sE(o5) && a4.push(ya.printDanglingComments(e14, t10, !0), r7 ? zy : " "), a4.push("else", Xy(LE(o5.alternate, e14.call(n6, "alternate"), "IfStatement" === o5.alternate.type)));
                        }
                        return Wy(a4);
                    }
                case "ForStatement":
                    {
                        const r6 = LE(o5.body, e14.call(n6, "body")), u6 = ya.printDanglingComments(e14, t10, !0), i7 = u6 ? Wy([
                            u6,
                            Gy
                        ]) : "";
                        return o5.init || o5.test || o5.update ? Wy([
                            i7,
                            Xy(Wy([
                                "for (",
                                Xy(Wy([
                                    Yy(Wy([
                                        Gy,
                                        e14.call(n6, "init"),
                                        ";",
                                        Jy,
                                        e14.call(n6, "test"),
                                        ";",
                                        Jy,
                                        e14.call(n6, "update")
                                    ])),
                                    Gy
                                ])),
                                ")",
                                r6
                            ]))
                        ]) : Wy([
                            i7,
                            Xy(Wy([
                                "for (;;)",
                                r6
                            ]))
                        ]);
                    }
                case "WhileStatement":
                    return Xy(Wy([
                        "while (",
                        Xy(Wy([
                            Yy(Wy([
                                Gy,
                                e14.call(n6, "test")
                            ])),
                            Gy
                        ])),
                        ")",
                        LE(o5.body, e14.call(n6, "body"))
                    ]));
                case "ForInStatement":
                    return Xy(Wy([
                        "for (",
                        e14.call(n6, "left"),
                        " in ",
                        e14.call(n6, "right"),
                        ")",
                        LE(o5.body, e14.call(n6, "body"))
                    ]));
                case "ForOfStatement":
                    return Xy(Wy([
                        "for",
                        o5.await ? " await" : "",
                        " (",
                        e14.call(n6, "left"),
                        " of ",
                        e14.call(n6, "right"),
                        ")",
                        LE(o5.body, e14.call(n6, "body"))
                    ]));
                case "DoWhileStatement":
                    {
                        const t11 = LE(o5.body, e14.call(n6, "body")), r6 = Xy(Wy([
                            "do",
                            t11
                        ]));
                        return a4 = [
                            r6
                        ], "BlockStatement" === o5.body.type ? a4.push(" ") : a4.push(zy), a4.push("while ("), a4.push(Xy(Wy([
                            Yy(Wy([
                                Gy,
                                e14.call(n6, "test")
                            ])),
                            Gy
                        ])), ")", u5), Wy(a4);
                    }
                case "DoExpression":
                    return Wy([
                        "do ",
                        e14.call(n6, "body")
                    ]);
                case "BreakStatement":
                    return a4.push("break"), o5.label && a4.push(" ", e14.call(n6, "label")), a4.push(u5), Wy(a4);
                case "ContinueStatement":
                    return a4.push("continue"), o5.label && a4.push(" ", e14.call(n6, "label")), a4.push(u5), Wy(a4);
                case "LabeledStatement":
                    return "EmptyStatement" === o5.body.type ? Wy([
                        e14.call(n6, "label"),
                        ":;"
                    ]) : Wy([
                        e14.call(n6, "label"),
                        ": ",
                        e14.call(n6, "body")
                    ]);
                case "TryStatement":
                    return Wy([
                        "try ",
                        e14.call(n6, "block"),
                        o5.handler ? Wy([
                            " ",
                            e14.call(n6, "handler")
                        ]) : "",
                        o5.finalizer ? Wy([
                            " finally ",
                            e14.call(n6, "finalizer")
                        ]) : ""
                    ]);
                case "CatchClause":
                    if (o5.param) {
                        const r6 = o5.param.comments && o5.param.comments.some((e15)=>!FE(e15) || e15.leading && jy(t10.originalText, BE(e15)) || e15.trailing && jy(t10.originalText, TE(e15), {
                                backwards: !0
                            })
                        ), u6 = e14.call(n6, "param");
                        return Wy([
                            "catch ",
                            Wy(r6 ? [
                                "(",
                                Yy(Wy([
                                    Gy,
                                    u6
                                ])),
                                Gy,
                                ") "
                            ] : [
                                "(",
                                u6,
                                ") "
                            ]),
                            e14.call(n6, "body")
                        ]);
                    }
                    return Wy([
                        "catch ",
                        e14.call(n6, "body")
                    ]);
                case "SwitchStatement":
                    return Wy([
                        Xy(Wy([
                            "switch (",
                            Yy(Wy([
                                Gy,
                                e14.call(n6, "discriminant")
                            ])),
                            Gy,
                            ")"
                        ])),
                        " {",
                        o5.cases.length > 0 ? Yy(Wy([
                            zy,
                            Uy(zy, e14.map((e15)=>{
                                const r6 = e15.getValue();
                                return Wy([
                                    e15.call(n6),
                                    o5.cases.indexOf(r6) !== o5.cases.length - 1 && qy(t10.originalText, r6, BE) ? zy : ""
                                ]);
                            }, "cases"))
                        ])) : "",
                        zy,
                        "}"
                    ]);
                case "SwitchCase":
                    {
                        o5.test ? a4.push("case ", e14.call(n6, "test"), ":") : a4.push("default:");
                        const r6 = o5.consequent.filter((e15)=>"EmptyStatement" !== e15.type
                        );
                        if (r6.length > 0) {
                            const o6 = e14.call((e15)=>DC(e15, t10, n6)
                            , "consequent");
                            a4.push(1 === r6.length && "BlockStatement" === r6[0].type ? Wy([
                                " ",
                                o6
                            ]) : Yy(Wy([
                                zy,
                                o6
                            ])));
                        }
                        return Wy(a4);
                    }
                case "DebuggerStatement":
                    return Wy([
                        "debugger",
                        u5
                    ]);
                case "JSXAttribute":
                    return HE(e14, t10, n6);
                case "JSXIdentifier":
                    return "" + o5.name;
                case "JSXNamespacedName":
                    return Uy(":", [
                        e14.call(n6, "namespace"),
                        e14.call(n6, "name")
                    ]);
                case "JSXMemberExpression":
                    return Uy(".", [
                        e14.call(n6, "object"),
                        e14.call(n6, "property")
                    ]);
                case "TSQualifiedName":
                    return Uy(".", [
                        e14.call(n6, "left"),
                        e14.call(n6, "right")
                    ]);
                case "JSXSpreadAttribute":
                    return eC(e14, t10, n6);
                case "JSXSpreadChild":
                    return tC(e14, t10, n6);
                case "JSXExpressionContainer":
                    return QE(e14, t10, n6);
                case "JSXFragment":
                case "JSXElement":
                    return GE(e14, t10, n6);
                case "JSXOpeningElement":
                    return XE(e14, t10, n6);
                case "JSXClosingElement":
                    return YE(e14, t10, n6);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                    return KE(e14, t10);
                case "JSXText":
                    throw new Error("JSXTest should be handled by JSXElement");
                case "JSXEmptyExpression":
                    return ZE(e14, t10);
                case "ClassBody":
                    return o5.comments || 0 !== o5.body.length ? Wy([
                        "{",
                        o5.body.length > 0 ? Yy(Wy([
                            zy,
                            e14.call((e15)=>DC(e15, t10, n6)
                            , "body")
                        ])) : ya.printDanglingComments(e14, t10),
                        zy,
                        "}"
                    ]) : "{}";
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                case "ClassPrivateProperty":
                    return o5.decorators && 0 !== o5.decorators.length && a4.push(OE(e14, t10, n6)), o5.accessibility && a4.push(o5.accessibility + " "), o5.declare && a4.push("declare "), o5.static && a4.push("static "), ("TSAbstractClassProperty" === o5.type || o5.abstract) && a4.push("abstract "), o5.readonly && a4.push("readonly "), o5.variance && a4.push(e14.call(n6, "variance")), a4.push(uC(e14, t10, n6), NE(e14), JE(e14, t10, n6)), o5.value && a4.push(" =", mC(o5.key, o5.value, e14.call(n6, "value"), t10)), a4.push(u5), Xy(Wy(a4));
                case "ClassDeclaration":
                case "ClassExpression":
                    return o5.declare && a4.push("declare "), a4.push(nC(e14, t10, n6)), Wy(a4);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                    return a4.push(e14.call(n6, "expression")), o5.typeParameters && a4.push(e14.call(n6, "typeParameters")), Wy(a4);
                case "TemplateElement":
                    return Uy(Hy, o5.value.raw.split(/\r?\n/g));
                case "TSTemplateLiteralType":
                case "TemplateLiteral":
                    return $E(e14, n6, t10);
                case "TaggedTemplateExpression":
                    return Wy([
                        e14.call(n6, "tag"),
                        e14.call(n6, "typeParameters"),
                        e14.call(n6, "quasi")
                    ]);
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                    throw new Error("unprintable type: " + JSON.stringify(o5.type));
                case "TypeAnnotation":
                case "TSTypeAnnotation":
                    return o5.typeAnnotation ? e14.call(n6, "typeAnnotation") : "";
                case "TSNamedTupleMember":
                    return Wy([
                        e14.call(n6, "label"),
                        o5.optional ? "?" : "",
                        ": ",
                        e14.call(n6, "elementType")
                    ]);
                case "TSTupleType":
                case "TupleTypeAnnotation":
                    {
                        const r6 = "TSTupleType" === o5.type ? "elementTypes" : "types", u6 = o5[r6].length > 0 && "TSRestType" === Ry(o5[r6]).type;
                        return Xy(Wy([
                            "[",
                            Yy(Wy([
                                Gy,
                                WE(e14, t10, r6, n6)
                            ])),
                            Zy(wE(t10, "all") && !u6 ? "," : ""),
                            ya.printDanglingComments(e14, t10, !0),
                            Gy,
                            "]"
                        ]));
                    }
                case "ExistsTypeAnnotation":
                    return "*";
                case "EmptyTypeAnnotation":
                    return "empty";
                case "MixedTypeAnnotation":
                    return "mixed";
                case "ArrayTypeAnnotation":
                    return Wy([
                        e14.call(n6, "elementType"),
                        "[]"
                    ]);
                case "BooleanLiteralTypeAnnotation":
                    return "" + o5.value;
                case "DeclareClass":
                    return IE(e14, nC(e14, t10, n6));
                case "TSDeclareFunction":
                    return Wy([
                        o5.declare ? "declare " : "",
                        iC(e14, n6, t10),
                        u5
                    ]);
                case "DeclareFunction":
                    return IE(e14, Wy([
                        "function ",
                        e14.call(n6, "id"),
                        o5.predicate ? " " : "",
                        e14.call(n6, "predicate"),
                        u5
                    ]));
                case "DeclareModule":
                    return IE(e14, Wy([
                        "module ",
                        e14.call(n6, "id"),
                        " ",
                        e14.call(n6, "body")
                    ]));
                case "DeclareModuleExports":
                    return IE(e14, Wy([
                        "module.exports",
                        ": ",
                        e14.call(n6, "typeAnnotation"),
                        u5
                    ]));
                case "DeclareVariable":
                    return IE(e14, Wy([
                        "var ",
                        e14.call(n6, "id"),
                        u5
                    ]));
                case "DeclareOpaqueType":
                case "OpaqueType":
                    return a4.push("opaque type ", e14.call(n6, "id"), e14.call(n6, "typeParameters")), o5.supertype && a4.push(": ", e14.call(n6, "supertype")), o5.impltype && a4.push(" = ", e14.call(n6, "impltype")), a4.push(u5), "DeclareOpaqueType" === o5.type ? IE(e14, Wy(a4)) : Wy(a4);
                case "EnumDeclaration":
                    return Wy([
                        "enum ",
                        e14.call(n6, "id"),
                        " ",
                        e14.call(n6, "body")
                    ]);
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody":
                    if ("EnumSymbolBody" === o5.type || o5.explicitType) {
                        let e15 = null;
                        switch(o5.type){
                            case "EnumBooleanBody":
                                e15 = "boolean";
                                break;
                            case "EnumNumberBody":
                                e15 = "number";
                                break;
                            case "EnumStringBody":
                                e15 = "string";
                                break;
                            case "EnumSymbolBody":
                                e15 = "symbol";
                        }
                        a4.push("of ", e15, " ");
                    }
                    if (0 !== o5.members.length || o5.hasUnknownMembers) {
                        const r6 = o5.members.length ? [
                            zy,
                            WE(e14, t10, "members", n6),
                            o5.hasUnknownMembers || wE(t10) ? "," : ""
                        ] : [];
                        a4.push(Xy(Wy([
                            "{",
                            Yy(Wy([
                                ...r6,
                                ...o5.hasUnknownMembers ? [
                                    zy,
                                    "..."
                                ] : []
                            ])),
                            ya.printDanglingComments(e14, t10, !0),
                            zy,
                            "}"
                        ])));
                    } else a4.push(Xy(Wy([
                        "{",
                        ya.printDanglingComments(e14, t10),
                        Gy,
                        "}"
                    ])));
                    return Wy(a4);
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                    return Wy([
                        e14.call(n6, "id"),
                        " = ",
                        "object" == typeof o5.init ? e14.call(n6, "init") : String(o5.init)
                    ]);
                case "EnumDefaultedMember":
                    return e14.call(n6, "id");
                case "FunctionTypeAnnotation":
                case "TSFunctionType":
                    {
                        const r6 = e14.getParentNode(0), u6 = e14.getParentNode(1), i7 = e14.getParentNode(2);
                        let s4 = "TSFunctionType" === o5.type || !(("ObjectTypeProperty" === r6.type || "ObjectTypeInternalSlot" === r6.type) && !r6.variance && !r6.optional && TE(r6) === TE(o5) || "ObjectTypeCallProperty" === r6.type || i7 && "DeclareFunction" === i7.type), l4 = s4 && ("TypeAnnotation" === r6.type || "TSTypeAnnotation" === r6.type);
                        const c4 = l4 && s4 && ("TypeAnnotation" === r6.type || "TSTypeAnnotation" === r6.type) && "ArrowFunctionExpression" === u6.type;
                        return bE(r6) && (s4 = !0, l4 = !0), c4 && a4.push("("), a4.push(VE(e14, n6, t10, !1, !0)), (o5.returnType || o5.predicate || o5.typeAnnotation) && a4.push(s4 ? " => " : ": ", e14.call(n6, "returnType"), e14.call(n6, "predicate"), e14.call(n6, "typeAnnotation")), c4 && a4.push(")"), Xy(Wy(a4));
                    }
                case "TSRestType":
                    return Wy([
                        "...",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "TSOptionalType":
                    return Wy([
                        e14.call(n6, "typeAnnotation"),
                        "?"
                    ]);
                case "FunctionTypeParam":
                    {
                        const t11 = o5.name ? e14.call(n6, "name") : e14.getParentNode().this === o5 ? "this" : "";
                        return Wy([
                            t11,
                            NE(e14),
                            t11 ? ": " : "",
                            e14.call(n6, "typeAnnotation")
                        ]);
                    }
                case "DeclareInterface":
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                case "TSInterfaceDeclaration":
                    return pC(e14, t10, n6);
                case "ClassImplements":
                case "InterfaceExtends":
                    return Wy([
                        e14.call(n6, "id"),
                        e14.call(n6, "typeParameters")
                    ]);
                case "TSClassImplements":
                    return Wy([
                        e14.call(n6, "expression"),
                        e14.call(n6, "typeParameters")
                    ]);
                case "TSIntersectionType":
                case "IntersectionTypeAnnotation":
                    {
                        const t11 = e14.map(n6, "types"), r6 = [];
                        let u6 = !1;
                        for(let e15 = 0; e15 < t11.length; ++e15)0 === e15 ? r6.push(t11[e15]) : CE(o5.types[e15 - 1]) && CE(o5.types[e15]) ? r6.push(Wy([
                            " & ",
                            u6 ? Yy(t11[e15]) : t11[e15]
                        ])) : CE(o5.types[e15 - 1]) || CE(o5.types[e15]) ? (e15 > 1 && (u6 = !0), r6.push(" & ", e15 > 1 ? Yy(t11[e15]) : t11[e15])) : r6.push(Yy(Wy([
                            " &",
                            Jy,
                            t11[e15]
                        ])));
                        return Xy(Wy(r6));
                    }
                case "TSUnionType":
                case "UnionTypeAnnotation":
                    {
                        const r6 = e14.getParentNode(), u6 = !("TypeParameterInstantiation" === r6.type || "TSTypeParameterInstantiation" === r6.type || "GenericTypeAnnotation" === r6.type || "TSTypeReference" === r6.type || "TSTypeAssertion" === r6.type || "TupleTypeAnnotation" === r6.type || "TSTupleType" === r6.type || "FunctionTypeParam" === r6.type && !r6.name && e14.getParentNode(1).this !== r6 || ("TypeAlias" === r6.type || "VariableDeclarator" === r6.type || "TSTypeAliasDeclaration" === r6.type) && cE(t10.originalText, o5)), i7 = zE(o5), a5 = e14.map((e15)=>{
                            let r7 = e15.call(n6);
                            return i7 || (r7 = Ky(2, r7)), ya.printComments(e15, ()=>r7
                            , t10);
                        }, "types");
                        if (i7) return Uy(" | ", a5);
                        const s4 = u6 && !cE(t10.originalText, o5), l4 = Wy([
                            Zy(Wy([
                                s4 ? Jy : "",
                                "| "
                            ])),
                            Uy(Wy([
                                Jy,
                                "| "
                            ]), a5)
                        ]);
                        return Pp(e14, t10) ? Xy(Wy([
                            Yy(l4),
                            Gy
                        ])) : "TupleTypeAnnotation" === r6.type && r6.types.length > 1 || "TSTupleType" === r6.type && r6.elementTypes.length > 1 ? Xy(Wy([
                            Yy(Wy([
                                Zy(Wy([
                                    "(",
                                    Gy
                                ])),
                                l4
                            ])),
                            Gy,
                            Zy(")")
                        ])) : Xy(u6 ? Yy(l4) : l4);
                    }
                case "NullableTypeAnnotation":
                    return Wy([
                        "?",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "Variance":
                    {
                        const { kind: e15  } = o5;
                        return Xi.ok("plus" === e15 || "minus" === e15), "plus" === e15 ? "+" : "-";
                    }
                case "ObjectTypeCallProperty":
                    return o5.static && a4.push("static "), a4.push(e14.call(n6, "value")), Wy(a4);
                case "ObjectTypeIndexer":
                    return Wy([
                        o5.variance ? e14.call(n6, "variance") : "",
                        "[",
                        e14.call(n6, "id"),
                        o5.id ? ": " : "",
                        e14.call(n6, "key"),
                        "]: ",
                        e14.call(n6, "value")
                    ]);
                case "ObjectTypeProperty":
                    {
                        let r6 = "";
                        return o5.proto ? r6 = "proto " : o5.static && (r6 = "static "), Wy([
                            r6,
                            DE(o5) ? o5.kind + " " : "",
                            o5.variance ? e14.call(n6, "variance") : "",
                            uC(e14, t10, n6),
                            NE(e14),
                            gE(o5) ? "" : ": ",
                            e14.call(n6, "value")
                        ]);
                    }
                case "QualifiedTypeIdentifier":
                    return Wy([
                        e14.call(n6, "qualification"),
                        ".",
                        e14.call(n6, "id")
                    ]);
                case "StringLiteralTypeAnnotation":
                    return bC(o5, t10);
                case "NumberLiteralTypeAnnotation":
                    Xi.strictEqual(typeof o5.value, "number");
                case "BigIntLiteralTypeAnnotation":
                    return null != o5.extra ? $y(o5.extra.raw) : $y(o5.raw);
                case "DeclareTypeAlias":
                case "TypeAlias":
                    {
                        ("DeclareTypeAlias" === o5.type || o5.declare) && a4.push("declare ");
                        const r6 = mC(o5.id, o5.right, e14.call(n6, "right"), t10);
                        return a4.push("type ", e14.call(n6, "id"), e14.call(n6, "typeParameters"), " =", r6, u5), Xy(Wy(a4));
                    }
                case "TypeCastExpression":
                    return Wy([
                        "(",
                        e14.call(n6, "expression"),
                        JE(e14, t10, n6),
                        ")"
                    ]);
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation":
                    {
                        const r6 = oC(e14, t10, n6, "params");
                        if ("flow" === t10.parser) {
                            const e15 = TE(o5), n7 = BE(o5), u6 = t10.originalText.lastIndexOf("/*", e15), i7 = t10.originalText.indexOf("*/", n7);
                            if (-1 !== u6 && -1 !== i7) {
                                const e16 = t10.originalText.slice(u6 + 2, i7).trim();
                                if (e16.startsWith("::") && !e16.includes("/*") && !e16.includes("*/")) return Wy([
                                    "/*:: ",
                                    r6,
                                    " */"
                                ]);
                            }
                        }
                        return r6;
                    }
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                    return oC(e14, t10, n6, "params");
                case "TSTypeParameter":
                case "TypeParameter":
                    {
                        const r6 = e14.getParentNode();
                        if ("TSMappedType" === r6.type) return a4.push("[", e14.call(n6, "name")), o5.constraint && a4.push(" in ", e14.call(n6, "constraint")), r6.nameType && a4.push(" as ", e14.callParent((e15)=>e15.call(n6, "nameType")
                        )), a4.push("]"), Wy(a4);
                        o5.variance && a4.push(e14.call(n6, "variance")), a4.push(e14.call(n6, "name")), o5.bound && (a4.push(": "), a4.push(e14.call(n6, "bound"))), o5.constraint && a4.push(" extends ", e14.call(n6, "constraint")), o5.default && a4.push(" = ", e14.call(n6, "default"));
                        const u6 = e14.getNode(2);
                        return 1 === oE(r6).length && AE(t10) && !o5.constraint && "ArrowFunctionExpression" === u6.type && a4.push(","), Wy(a4);
                    }
                case "TypeofTypeAnnotation":
                    return Wy([
                        "typeof ",
                        e14.call(n6, "argument")
                    ]);
                case "InferredPredicate":
                    return "%checks";
                case "DeclaredPredicate":
                    return Wy([
                        "%checks(",
                        e14.call(n6, "value"),
                        ")"
                    ]);
                case "TSAbstractKeyword":
                    return "abstract";
                case "AnyTypeAnnotation":
                case "TSAnyKeyword":
                    return "any";
                case "TSAsyncKeyword":
                    return "async";
                case "BooleanTypeAnnotation":
                case "TSBooleanKeyword":
                    return "boolean";
                case "BigIntTypeAnnotation":
                case "TSBigIntKeyword":
                    return "bigint";
                case "TSConstKeyword":
                    return "const";
                case "TSDeclareKeyword":
                    return "declare";
                case "TSExportKeyword":
                    return "export";
                case "NullLiteralTypeAnnotation":
                case "TSNullKeyword":
                    return "null";
                case "TSNeverKeyword":
                    return "never";
                case "NumberTypeAnnotation":
                case "TSNumberKeyword":
                    return "number";
                case "TSObjectKeyword":
                    return "object";
                case "TSProtectedKeyword":
                    return "protected";
                case "TSPrivateKeyword":
                    return "private";
                case "TSPublicKeyword":
                    return "public";
                case "TSReadonlyKeyword":
                    return "readonly";
                case "SymbolTypeAnnotation":
                case "TSSymbolKeyword":
                    return "symbol";
                case "TSStaticKeyword":
                    return "static";
                case "StringTypeAnnotation":
                case "TSStringKeyword":
                    return "string";
                case "TSUndefinedKeyword":
                    return "undefined";
                case "TSUnknownKeyword":
                    return "unknown";
                case "VoidTypeAnnotation":
                case "TSVoidKeyword":
                    return "void";
                case "TSAsExpression":
                    return Wy([
                        e14.call(n6, "expression"),
                        " as ",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "TSArrayType":
                    return Wy([
                        e14.call(n6, "elementType"),
                        "[]"
                    ]);
                case "TSPropertySignature":
                    return o5.export && a4.push("export "), o5.accessibility && a4.push(o5.accessibility + " "), o5.static && a4.push("static "), o5.readonly && a4.push("readonly "), a4.push(uC(e14, t10, n6), NE(e14)), o5.typeAnnotation && (a4.push(": "), a4.push(e14.call(n6, "typeAnnotation"))), o5.initializer && a4.push(" = ", e14.call(n6, "initializer")), Wy(a4);
                case "TSParameterProperty":
                    return o5.accessibility && a4.push(o5.accessibility + " "), o5.export && a4.push("export "), o5.static && a4.push("static "), o5.readonly && a4.push("readonly "), a4.push(e14.call(n6, "parameter")), Wy(a4);
                case "GenericTypeAnnotation":
                case "TSTypeReference":
                    return Wy([
                        e14.call(n6, "TSTypeReference" === o5.type ? "typeName" : "id"),
                        oC(e14, t10, n6, "typeParameters")
                    ]);
                case "TSTypeQuery":
                    return Wy([
                        "typeof ",
                        e14.call(n6, "exprName")
                    ]);
                case "TSIndexSignature":
                    {
                        const r6 = e14.getParentNode(), i7 = o5.parameters.length > 1 ? Zy(wE(t10) ? "," : "") : "", a5 = Xy(Wy([
                            Yy(Wy([
                                Gy,
                                Uy(Wy([
                                    ", ",
                                    Gy
                                ]), e14.map(n6, "parameters"))
                            ])),
                            i7,
                            Gy
                        ]));
                        return Wy([
                            o5.export ? "export " : "",
                            o5.accessibility ? Wy([
                                o5.accessibility,
                                " "
                            ]) : "",
                            o5.static ? "static " : "",
                            o5.readonly ? "readonly " : "",
                            o5.declare ? "declare " : "",
                            "[",
                            o5.parameters ? a5 : "",
                            o5.typeAnnotation ? "]: " : "]",
                            o5.typeAnnotation ? e14.call(n6, "typeAnnotation") : "",
                            "ClassBody" === r6.type ? u5 : ""
                        ]);
                    }
                case "TSTypePredicate":
                    return Wy([
                        o5.asserts ? "asserts " : "",
                        e14.call(n6, "parameterName"),
                        o5.typeAnnotation ? Wy([
                            " is ",
                            e14.call(n6, "typeAnnotation")
                        ]) : ""
                    ]);
                case "TSNonNullExpression":
                    return Wy([
                        e14.call(n6, "expression"),
                        "!"
                    ]);
                case "ThisTypeAnnotation":
                case "TSThisType":
                    return "this";
                case "TSImportType":
                    return Wy([
                        o5.isTypeOf ? "typeof " : "",
                        "import(",
                        e14.call(n6, o5.parameter ? "parameter" : "argument"),
                        ")",
                        o5.qualifier ? Wy([
                            ".",
                            e14.call(n6, "qualifier")
                        ]) : "",
                        oC(e14, t10, n6, "typeParameters")
                    ]);
                case "TSLiteralType":
                    return e14.call(n6, "literal");
                case "TSIndexedAccessType":
                    return Wy([
                        e14.call(n6, "objectType"),
                        "[",
                        e14.call(n6, "indexType"),
                        "]"
                    ]);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType":
                    if ("TSCallSignatureDeclaration" !== o5.type && a4.push("new "), a4.push(Xy(VE(e14, n6, t10, !1, !0))), o5.returnType || o5.typeAnnotation) {
                        const t11 = "TSConstructorType" === o5.type;
                        a4.push(t11 ? " => " : ": ", e14.call(n6, "returnType"), e14.call(n6, "typeAnnotation"));
                    }
                    return Wy(a4);
                case "TSTypeOperator":
                    return Wy([
                        o5.operator,
                        " ",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "TSMappedType":
                    {
                        const r6 = _y(t10.originalText, TE(o5), BE(o5));
                        return Xy(Wy([
                            "{",
                            Yy(Wy([
                                t10.bracketSpacing ? Jy : Gy,
                                o5.readonly ? Wy([
                                    aE(o5.readonly, "readonly"),
                                    " "
                                ]) : "",
                                PE(e14, t10, n6),
                                e14.call(n6, "typeParameter"),
                                o5.optional ? aE(o5.optional, "?") : "",
                                o5.typeAnnotation ? ": " : "",
                                e14.call(n6, "typeAnnotation"),
                                Zy(u5, "")
                            ])),
                            ya.printDanglingComments(e14, t10, !0),
                            t10.bracketSpacing ? Jy : Gy,
                            "}"
                        ]), {
                            shouldBreak: r6
                        });
                    }
                case "TSMethodSignature":
                    return a4.push(o5.accessibility ? Wy([
                        o5.accessibility,
                        " "
                    ]) : "", o5.export ? "export " : "", o5.static ? "static " : "", o5.readonly ? "readonly " : "", o5.computed ? "[" : "", e14.call(n6, "key"), o5.computed ? "]" : "", NE(e14), VE(e14, n6, t10, !1, !0)), (o5.returnType || o5.typeAnnotation) && a4.push(": ", e14.call(n6, "returnType"), e14.call(n6, "typeAnnotation")), Xy(Wy(a4));
                case "TSNamespaceExportDeclaration":
                    return a4.push("export as namespace ", e14.call(n6, "id")), t10.semi && a4.push(";"), Xy(Wy(a4));
                case "TSEnumDeclaration":
                    return o5.declare && a4.push("declare "), o5.modifiers && a4.push(PE(e14, t10, n6)), o5.const && a4.push("const "), a4.push("enum ", e14.call(n6, "id"), " "), 0 === o5.members.length ? a4.push(Xy(Wy([
                        "{",
                        ya.printDanglingComments(e14, t10),
                        Gy,
                        "}"
                    ]))) : a4.push(Xy(Wy([
                        "{",
                        Yy(Wy([
                            zy,
                            WE(e14, t10, "members", n6),
                            wE(t10, "es5") ? "," : ""
                        ])),
                        ya.printDanglingComments(e14, t10, !0),
                        zy,
                        "}"
                    ]))), Wy(a4);
                case "TSEnumMember":
                    return a4.push(e14.call(n6, "id")), o5.initializer && a4.push(" = ", e14.call(n6, "initializer")), Wy(a4);
                case "TSImportEqualsDeclaration":
                    return o5.isExport && a4.push("export "), a4.push("import ", e14.call(n6, "id"), " = ", e14.call(n6, "moduleReference")), t10.semi && a4.push(";"), Xy(Wy(a4));
                case "TSExternalModuleReference":
                    return Wy([
                        "require(",
                        e14.call(n6, "expression"),
                        ")"
                    ]);
                case "TSModuleDeclaration":
                    {
                        const r6 = e14.getParentNode(), i7 = yE(o5.id), s4 = "TSModuleDeclaration" === r6.type, l4 = o5.body && "TSModuleDeclaration" === o5.body.type;
                        if (s4) a4.push(".");
                        else {
                            o5.declare && a4.push("declare "), a4.push(PE(e14, t10, n6));
                            const r7 = t10.originalText.slice(TE(o5), TE(o5.id));
                            "Identifier" === o5.id.type && "global" === o5.id.name && !/namespace|module/.test(r7) || a4.push(i7 || /(^|\s)module(\s|$)/.test(r7) ? "module " : "namespace ");
                        }
                        return a4.push(e14.call(n6, "id")), l4 ? a4.push(e14.call(n6, "body")) : o5.body ? a4.push(" ", Xy(e14.call(n6, "body"))) : a4.push(u5), Wy(a4);
                    }
                case "PrivateName":
                    return Wy([
                        "#",
                        e14.call(n6, o5.id ? "id" : "name")
                    ]);
                case "TSPrivateIdentifier":
                    return o5.escapedText;
                case "TSConditionalType":
                    return Bd(e14, t10, n6, {
                        beforeParts: ()=>[
                                e14.call(n6, "checkType"),
                                " ",
                                "extends",
                                " ",
                                e14.call(n6, "extendsType")
                            ]
                        ,
                        afterParts: ()=>[]
                        ,
                        shouldCheckJsx: !1,
                        conditionalNodeType: "TSConditionalType",
                        consequentNodePropertyName: "trueType",
                        alternateNodePropertyName: "falseType",
                        testNodePropertyNames: [
                            "checkType",
                            "extendsType"
                        ]
                    });
                case "TSInferType":
                    return Wy([
                        "infer",
                        " ",
                        e14.call(n6, "typeParameter")
                    ]);
                case "InterpreterDirective":
                    return a4.push("#!", o5.value, zy), qy(t10.originalText, o5, BE) && a4.push(zy), Wy(a4);
                case "NGRoot":
                    return Wy([].concat(e14.call(n6, "node"), o5.node.comments && 0 !== o5.node.comments.length ? Wy([
                        " //",
                        o5.node.comments[0].value.trimEnd()
                    ]) : []));
                case "NGChainedExpression":
                    return Xy(Uy(Wy([
                        ";",
                        Jy
                    ]), e14.map((e15)=>dE(e15) ? n6(e15) : Wy([
                            "(",
                            n6(e15),
                            ")"
                        ])
                    , "expressions")));
                case "NGEmptyExpression":
                    return "";
                case "NGQuotedExpression":
                    return Wy([
                        o5.prefix,
                        ": ",
                        o5.value.trim()
                    ]);
                case "NGMicrosyntax":
                    return Wy(e14.map((e15, t11)=>Wy([
                            0 === t11 ? "" : EE(e15.getValue(), t11, o5) ? " " : Wy([
                                ";",
                                Jy
                            ]),
                            n6(e15)
                        ])
                    , "body"));
                case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(-[$_a-z][\w$])*$/i.test(o5.name) ? o5.name : JSON.stringify(o5.name);
                case "NGMicrosyntaxExpression":
                    return Wy([
                        e14.call(n6, "expression"),
                        null === o5.alias ? "" : Wy([
                            " as ",
                            e14.call(n6, "alias")
                        ])
                    ]);
                case "NGMicrosyntaxKeyedExpression":
                    {
                        const t11 = e14.getName(), r6 = e14.getParentNode(), u6 = EE(o5, t11, r6) || (1 === t11 && ("then" === o5.key.name || "else" === o5.key.name) || 2 === t11 && "else" === o5.key.name && "NGMicrosyntaxKeyedExpression" === r6.body[t11 - 1].type && "then" === r6.body[t11 - 1].key.name) && "NGMicrosyntaxExpression" === r6.body[0].type;
                        return Wy([
                            e14.call(n6, "key"),
                            u6 ? " " : ": ",
                            e14.call(n6, "expression")
                        ]);
                    }
                case "NGMicrosyntaxLet":
                    return Wy([
                        "let ",
                        e14.call(n6, "key"),
                        null === o5.value ? "" : Wy([
                            " = ",
                            e14.call(n6, "value")
                        ])
                    ]);
                case "NGMicrosyntaxAs":
                    return Wy([
                        e14.call(n6, "key"),
                        " as ",
                        e14.call(n6, "alias")
                    ]);
                case "PipelineBareFunction":
                    return e14.call(n6, "callee");
                case "PipelineTopicExpression":
                    return e14.call(n6, "expression");
                case "PipelinePrimaryTopicReference":
                    return a4.push("#"), Wy(a4);
                case "ArgumentPlaceholder":
                    return "?";
                case "TSJSDocAllType":
                    return "*";
                case "TSJSDocUnknownType":
                    return "?";
                case "TSJSDocNullableType":
                    return Wy([
                        "?",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "TSJSDocNonNullableType":
                    return Wy([
                        "!",
                        e14.call(n6, "typeAnnotation")
                    ]);
                case "TSJSDocFunctionType":
                    return Wy([
                        "function(",
                        "): ",
                        e14.call(n6, "typeAnnotation")
                    ]);
                default:
                    throw new Error("unknown type: " + JSON.stringify(o5.type));
            }
        }(e13, t9, n5, r4);
        if (!o4 || eE(i5)) return i5;
        const a4 = iE(e13), s4 = [];
        if ("ClassMethod" === o4.type || "ClassPrivateMethod" === o4.type || "ClassProperty" === o4.type || "FieldDefinition" === o4.type || "TSAbstractClassProperty" === o4.type || "ClassPrivateProperty" === o4.type || "MethodDefinition" === o4.type || "TSAbstractMethodDefinition" === o4.type || "TSDeclareMethod" === o4.type) ;
        else if (o4.decorators && o4.decorators.length > 0 && !(a4 && TE(a4, {
            ignoreDecorators: !0
        }) > TE(o4.decorators[0]))) {
            const r5 = "ClassExpression" === o4.type || "ClassDeclaration" === o4.type || pE(o4, t9) ? zy : Jy;
            e13.each((e14)=>{
                let t10 = e14.getValue();
                t10 = t10.expression ? t10.expression : t10.callee, s4.push(n5(e14), r5);
            }, "decorators"), a4 && s4.unshift(zy);
        } else mE(o4) && o4.declaration && o4.declaration.decorators && o4.declaration.decorators.length > 0 && TE(o4, {
            ignoreDecorators: !0
        }) > TE(o4.declaration.decorators[0]) ? e13.each((e14)=>{
            const t10 = "Decorator" === e14.getValue().type ? "" : "@";
            s4.push(t10, n5(e14), zy);
        }, "declaration", "decorators") : u4 = Pp(e13, t9);
        const l4 = [];
        if ((u4 && l4.unshift("("), l4.push(i5), u4)) {
            const t10 = e13.getValue();
            lE(t10) && (l4.push(" /*"), l4.push(t10.trailingComments[0].value.trimStart()), l4.push("*/"), t10.trailingComments[0].printed = !0), l4.push(")");
        }
        return s4.length > 0 ? Xy(Wy(s4.concat(l4))) : Wy(l4);
    },
    embed: op,
    insertPragma: tE,
    massageAstNode: sp,
    hasPrettierIgnore: fE,
    willPrintOwnComments: Zl.willPrintOwnComments,
    canAttachComment: function(e13) {
        return e13.type && "CommentBlock" !== e13.type && "CommentLine" !== e13.type && "Line" !== e13.type && "Block" !== e13.type && "EmptyStatement" !== e13.type && "TemplateElement" !== e13.type && "Import" !== e13.type;
    },
    printComment: CC,
    isBlockComment: FE,
    handleComments: {
        ownLine: Zl.handleOwnLineComment,
        endOfLine: Zl.handleEndOfLineComment,
        remaining: Zl.handleRemainingComment
    },
    getGapRegex: Zl.getGapRegex,
    getCommentChildNodes: Zl.getCommentChildNodes
};
const { builders: { concat: FC , hardline: xC , indent: SC , join: wC  }  } = rn1;
var NC = {
    preprocess: Vp,
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        switch(r4.type){
            case "JsonRoot":
                return FC([
                    e13.call(n5, "node"),
                    xC
                ]);
            case "ArrayExpression":
                return 0 === r4.elements.length ? "[]" : FC([
                    "[",
                    SC(FC([
                        xC,
                        wC(FC([
                            ",",
                            xC
                        ]), e13.map(n5, "elements"))
                    ])),
                    xC,
                    "]"
                ]);
            case "ObjectExpression":
                return 0 === r4.properties.length ? "{}" : FC([
                    "{",
                    SC(FC([
                        xC,
                        wC(FC([
                            ",",
                            xC
                        ]), e13.map(n5, "properties"))
                    ])),
                    xC,
                    "}"
                ]);
            case "ObjectProperty":
                return FC([
                    e13.call(n5, "key"),
                    ": ",
                    e13.call(n5, "value")
                ]);
            case "UnaryExpression":
                return FC([
                    "+" === r4.operator ? "" : r4.operator,
                    e13.call(n5, "argument")
                ]);
            case "NullLiteral":
                return "null";
            case "BooleanLiteral":
                return r4.value ? "true" : "false";
            case "StringLiteral":
            case "NumericLiteral":
                return JSON.stringify(r4.value);
            case "Identifier":
                return JSON.stringify(r4.name);
            default:
                throw new Error("unknown type: " + JSON.stringify(r4.type));
        }
    },
    massageAstNode: BC
};
var VC = {
    languages: [
        xs1(OC, (e13)=>({
                since: "0.0.0",
                parsers: [
                    "babel",
                    "espree",
                    "meriyah",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript"
                ],
                vscodeLanguageIds: [
                    "javascript",
                    "mongo"
                ],
                extensions: [
                    ...e13.extensions,
                    ".wxs"
                ]
            })
        ),
        xs1(OC, ()=>({
                name: "Flow",
                since: "0.0.0",
                parsers: [
                    "flow",
                    "babel-flow"
                ],
                vscodeLanguageIds: [
                    "javascript"
                ],
                aliases: [],
                filenames: [],
                extensions: [
                    ".js.flow"
                ]
            })
        ),
        xs1(IC, ()=>({
                since: "0.0.0",
                parsers: [
                    "babel",
                    "babel-flow",
                    "babel-ts",
                    "flow",
                    "typescript",
                    "espree",
                    "meriyah"
                ],
                vscodeLanguageIds: [
                    "javascriptreact"
                ]
            })
        ),
        xs1(LC, ()=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescript"
                ]
            })
        ),
        xs1(MC, ()=>({
                since: "1.4.0",
                parsers: [
                    "typescript",
                    "babel-ts"
                ],
                vscodeLanguageIds: [
                    "typescriptreact"
                ]
            })
        ),
        xs1(jC, ()=>({
                name: "JSON.stringify",
                since: "1.13.0",
                parsers: [
                    "json-stringify"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                extensions: [],
                filenames: [
                    "package.json",
                    "package-lock.json",
                    "composer.json"
                ]
            })
        ),
        xs1(jC, (e13)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "json"
                ],
                filenames: [
                    ...e13.filenames,
                    ".prettierrc"
                ],
                extensions: e13.extensions.filter((e14)=>".jsonl" !== e14
                )
            })
        ),
        xs1(_C, (e13)=>({
                since: "1.5.0",
                parsers: [
                    "json"
                ],
                vscodeLanguageIds: [
                    "jsonc"
                ],
                filenames: [
                    ...e13.filenames,
                    ".eslintrc"
                ]
            })
        ),
        xs1(RC, ()=>({
                since: "1.13.0",
                parsers: [
                    "json5"
                ],
                vscodeLanguageIds: [
                    "json5"
                ]
            })
        )
    ],
    options: PC,
    printers: {
        estree: AC,
        "estree-json": NC
    },
    parsers: {
        get babel () {
            return {
            }.parsers.babel;
        },
        get "babel-flow" () {
            return {
            }.parsers["babel-flow"];
        },
        get "babel-ts" () {
            return {
            }.parsers["babel-ts"];
        },
        get json () {
            return {
            }.parsers.json;
        },
        get json5 () {
            return {
            }.parsers.json5;
        },
        get "json-stringify" () {
            return {
            }.parsers["json-stringify"];
        },
        get __js_expression () {
            return {
            }.parsers.__js_expression;
        },
        get __vue_expression () {
            return {
            }.parsers.__vue_expression;
        },
        get __vue_event_binding () {
            return {
            }.parsers.__vue_event_binding;
        },
        get flow () {
            return {
            }.parsers.flow;
        },
        get typescript () {
            return {
            }.parsers.typescript;
        },
        get __ng_action () {
            return {
            }.parsers.__ng_action;
        },
        get __ng_binding () {
            return {
            }.parsers.__ng_binding;
        },
        get __ng_interpolation () {
            return {
            }.parsers.__ng_interpolation;
        },
        get __ng_directive () {
            return {
            }.parsers.__ng_directive;
        },
        get espree () {
            return {
            }.parsers.espree;
        },
        get meriyah () {
            return {
            }.parsers.meriyah;
        }
    }
};
const { isFrontMatterNode: $C  } = Nt1, qC = new Set([
    "raw",
    "raws",
    "sourceIndex",
    "source",
    "before",
    "after",
    "trailingComma"
]);
function WC(e13, t9, n5) {
    if ($C(e13) && "yaml" === e13.lang && delete t9.value, "css-comment" === e13.type && "css-root" === n5.type && 0 !== n5.nodes.length) {
        if ((n5.nodes[0] === e13 || $C(n5.nodes[0]) && n5.nodes[1] === e13) && (delete t9.text, /^\*\s*@(format|prettier)\s*$/.test(e13.text))) return null;
        if ("css-root" === n5.type && se(n5.nodes) === e13) return null;
    }
    if ("value-root" === e13.type && delete t9.text, "media-query" !== e13.type && "media-query-list" !== e13.type && "media-feature-expression" !== e13.type || delete t9.value, "css-rule" === e13.type && delete t9.params, "selector-combinator" === e13.type && (t9.value = t9.value.replace(/\s+/g, " ")), "media-feature" === e13.type && (t9.value = t9.value.replace(/ /g, "")), ("value-word" === e13.type && (e13.isColor && e13.isHex || [
        "initial",
        "inherit",
        "unset",
        "revert"
    ].includes(t9.value.replace().toLowerCase())) || "media-feature" === e13.type || "selector-root-invalid" === e13.type || "selector-pseudo" === e13.type) && (t9.value = t9.value.toLowerCase()), "css-decl" === e13.type && (t9.prop = t9.prop.toLowerCase()), "css-atrule" !== e13.type && "css-import" !== e13.type || (t9.name = t9.name.toLowerCase()), "value-number" === e13.type && (t9.unit = t9.unit.toLowerCase()), "media-feature" !== e13.type && "media-keyword" !== e13.type && "media-type" !== e13.type && "media-unknown" !== e13.type && "media-url" !== e13.type && "media-value" !== e13.type && "selector-attribute" !== e13.type && "selector-string" !== e13.type && "selector-class" !== e13.type && "selector-combinator" !== e13.type && "value-string" !== e13.type || !t9.value || (t9.value = t9.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), "selector-attribute" === e13.type && (t9.attribute = t9.attribute.trim(), t9.namespace && "string" == typeof t9.namespace && (t9.namespace = t9.namespace.trim(), 0 === t9.namespace.length && (t9.namespace = !0)), t9.value && (t9.value = t9.value.trim().replace(/^["']|["']$/g, ""), delete t9.quoted)), "media-value" !== e13.type && "media-type" !== e13.type && "value-number" !== e13.type && "selector-root-invalid" !== e13.type && "selector-class" !== e13.type && "selector-combinator" !== e13.type && "selector-tag" !== e13.type || !t9.value || (t9.value = t9.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e14, t10, n6)=>{
        const r4 = Number(t10);
        return isNaN(r4) ? e14 : r4 + n6.toLowerCase();
    })), "selector-tag" === e13.type) {
        const n6 = e13.value.toLowerCase();
        [
            "from",
            "to"
        ].includes(n6) && (t9.value = n6);
    }
    "css-atrule" === e13.type && "supports" === e13.name.toLowerCase() && delete t9.value, "selector-unknown" === e13.type && delete t9.value;
}
WC.ignoredProperties = qC;
var UC = WC;
const { builders: { hardline: JC , concat: zC , markAsRoot: GC  }  } = rn1, HC = {
    "---": "yaml",
    "+++": "toml"
};
var XC = {
    parse: function(e13) {
        const t9 = Object.keys(HC).map(ae).join("|"), n5 = e13.match(new RegExp("^(".concat(t9, ")([^\\n]*)\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));
        if (null === n5) return {
            frontMatter: null,
            content: e13
        };
        const [r4, o4, u4, i5] = n5;
        let a4 = HC[o4];
        return ("toml" !== a4 && u4 && u4.trim() && (a4 = u4.trim()), {
            frontMatter: {
                type: "front-matter",
                lang: a4,
                value: i5,
                raw: r4.replace(/\n$/, "")
            },
            content: r4.replace(/[^\n]/g, " ") + e13.slice(r4.length)
        });
    },
    print: function(e13, t9) {
        if ("yaml" === e13.lang) {
            const n5 = e13.value.trim(), r4 = n5 ? t9(n5, {
                parser: "yaml"
            }, {
                stripTrailingHardline: !0
            }) : "";
            return GC(zC([
                "---",
                JC,
                r4,
                r4 ? JC : "",
                "---"
            ]));
        }
    }
};
const { builders: { hardline: YC , concat: KC  }  } = rn1, { print: QC  } = XC;
var ZC = function(e13, t9, n5) {
    const r4 = e13.getValue();
    if ("front-matter" === r4.type) {
        const e14 = QC(r4, n5);
        return e14 ? KC([
            e14,
            YC
        ]) : "";
    }
};
const { parse: eb  } = XC;
var tb = {
    hasPragma: function(e13) {
        return Ep.hasPragma(eb(e13).content);
    },
    insertPragma: function(e13) {
        const { frontMatter: t9 , content: n5  } = eb(e13);
        return (t9 ? t9.raw + "\n\n" : "") + Ep.insertPragma(n5);
    }
};
const { getLast: hb , skipEverythingButNewLine: mb  } = Nt1;
function Db(e13, t9) {
    if ("css-comment" === e13.type && e13.inline) return mb(t9, e13.source.startOffset);
    const n5 = e13.nodes && hb(e13.nodes);
    return n5 && e13.source && !e13.source.end && (e13 = n5), e13.source && e13.source.end ? fb(e13.source.end, t9) : null;
}
function yb(e13, t9, n5) {
    e13.source && (e13.source.startOffset = gb(e13, n5) + t9, e13.source.endOffset = Db(e13, n5) + t9);
    for(const r4 in e13){
        const o4 = e13[r4];
        "source" !== r4 && o4 && "object" == typeof o4 && yb(o4, t9, n5);
    }
}
var Cb = {
    locStart: function(e13) {
        return e13.source.startOffset;
    },
    locEnd: function(e13) {
        return e13.source.endOffset;
    },
    calculateLoc: function e13(t9, n5) {
        t9.source && (t9.source.startOffset = gb(t9, n5), t9.source.endOffset = Db(t9, n5));
        for(const r4 in t9){
            const o4 = t9[r4];
            "source" !== r4 && o4 && "object" == typeof o4 && ("value-root" === o4.type || "value-unknown" === o4.type ? yb(o4, Eb(t9), o4.text || o4.value) : e13(o4, n5));
        }
    },
    replaceQuotesInInlineComments: function(e14) {
        let t9, n5 = "initial", r4 = "initial", o4 = !1;
        const u4 = [];
        for(let i5 = 0; i5 < e14.length; i5++){
            const a4 = e14[i5];
            switch(n5){
                case "initial":
                    if ("'" === a4) {
                        n5 = "single-quotes";
                        continue;
                    }
                    if ('"' === a4) {
                        n5 = "double-quotes";
                        continue;
                    }
                    if (("u" === a4 || "U" === a4) && "url(" === e14.slice(i5, i5 + 4).toLowerCase()) {
                        n5 = "url", i5 += 3;
                        continue;
                    }
                    if ("*" === a4 && "/" === e14[i5 - 1]) {
                        n5 = "comment-block";
                        continue;
                    }
                    if ("/" === a4 && "/" === e14[i5 - 1]) {
                        n5 = "comment-inline", t9 = i5 - 1;
                        continue;
                    }
                    continue;
                case "single-quotes":
                    if (("'" === a4 && "\\" !== e14[i5 - 1] && (n5 = r4, r4 = "initial"), "\n" === a4 || "\r" === a4)) return e14;
                    continue;
                case "double-quotes":
                    if (('"' === a4 && "\\" !== e14[i5 - 1] && (n5 = r4, r4 = "initial"), "\n" === a4 || "\r" === a4)) return e14;
                    continue;
                case "url":
                    if ((")" === a4 && (n5 = "initial"), "\n" === a4 || "\r" === a4)) return e14;
                    if ("'" === a4) {
                        n5 = "single-quotes", r4 = "url";
                        continue;
                    }
                    if ('"' === a4) {
                        n5 = "double-quotes", r4 = "url";
                        continue;
                    }
                    continue;
                case "comment-block":
                    "/" === a4 && "*" === e14[i5 - 1] && (n5 = "initial");
                    continue;
                case "comment-inline":
                    '"' !== a4 && "'" !== a4 && "*" !== a4 || (o4 = !0), "\n" !== a4 && "\r" !== a4 || (o4 && u4.push([
                        t9,
                        i5
                    ]), n5 = "initial", o4 = !1);
                    continue;
            }
        }
        for (const [t10, n6] of u4)e14 = e14.slice(0, t10) + e14.slice(t10, n6).replace(/["'*]/g, " ") + e14.slice(n6);
        return e14;
    }
};
const { printNumber: bb , printString: vb , hasNewline: Ab , isFrontMatterNode: Fb , isNextLineEmpty: xb  } = Nt1, { builders: { concat: Sb , join: wb , line: Tb , hardline: Bb , softline: Nb , group: kb , fill: Pb , indent: Ob , dedent: Ib , ifBreak: Lb , breakParent: Mb  } , utils: { removeLines: jb  }  } = rn1, { insertPragma: _b  } = tb, { getAncestorNode: Rb , getPropOfDeclNode: Vb , maybeToLowerCase: $b , insideValueFunctionNode: qb , insideICSSRuleNode: Wb , insideAtRuleNode: Ub , insideURLFunctionInImportAtRuleNode: Jb , isKeyframeAtRuleKeywords: zb , isWideKeywords: Gb , isSCSS: Hb , isLastNode: Xb , isLessParser: Yb , isSCSSControlDirectiveNode: Kb , isDetachedRulesetDeclarationNode: Qb , isRelationalOperatorNode: Zb , isEqualityOperatorNode: ev , isMultiplicationNode: tv , isDivisionNode: nv , isAdditionNode: rv , isSubtractionNode: ov , isMathOperatorNode: uv , isEachKeywordNode: iv , isForKeywordNode: av , isURLFunctionNode: sv , isIfElseKeywordNode: lv , hasComposesNode: cv , hasParensAroundNode: pv , hasEmptyRawBefore: dv , isKeyValuePairNode: fv , isDetachedRulesetCallNode: hv , isTemplatePlaceholderNode: mv , isTemplatePropNode: gv , isPostcssSimpleVarNode: Dv , isSCSSMapItemNode: yv , isInlineValueCommentNode: Ev , isHashNode: Cv , isLeftCurlyBraceNode: bv , isRightCurlyBraceNode: vv , isWordNode: Av , isColonNode: Fv , isMediaAndSupportsKeywords: xv , isColorAdjusterFuncNode: Sv , lastLineHasInlineComment: wv , isAtWordPlaceholderNode: Tv  } = db1, { locStart: Bv , locEnd: Nv  } = Cb;
function Pv(e13, t9, n5) {
    const r4 = e13.getValue(), o4 = [];
    return e13.each((e14, u4)=>{
        const i5 = r4.nodes[u4 - 1];
        if (i5 && "css-comment" === i5.type && "prettier-ignore" === i5.text.trim()) {
            const n6 = e14.getValue();
            o4.push(t9.originalText.slice(Bv(n6), Nv(n6)));
        } else o4.push(e14.call(n5));
        u4 !== r4.nodes.length - 1 && ("css-comment" === r4.nodes[u4 + 1].type && !Ab(t9.originalText, Bv(r4.nodes[u4 + 1]), {
            backwards: !0
        }) && !Fb(r4.nodes[u4]) || "css-atrule" === r4.nodes[u4 + 1].type && "else" === r4.nodes[u4 + 1].name && "css-comment" !== r4.nodes[u4].type ? o4.push(" ") : (o4.push(t9.__isHTMLStyleAttribute ? Tb : Bb), xb(t9.originalText, e14.getValue(), Nv) && !Fb(r4.nodes[u4]) && o4.push(Bb)));
    }, "nodes"), Sb(o4);
}
function Lv(e13, t9) {
    return e13.replace(Ov, (e14)=>vb(e14, t9)
    );
}
function jv(e13) {
    return e13.replace(Iv, (e14, t9, n5, r4, o4)=>!n5 && r4 ? _v(r4) + $b(o4 || "") : e14
    );
}
function _v(e13) {
    return bb(e13).replace(/\.0(?=$|e)/, "");
}
var Rv = {
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if (!r4) return "";
        if ("string" == typeof r4) return r4;
        switch(r4.type){
            case "front-matter":
                return Sb([
                    r4.raw,
                    Bb
                ]);
            case "css-root":
                {
                    const o4 = Pv(e13, t9, n5), u4 = r4.raws.after.trim();
                    return Sb([
                        o4,
                        u4 ? " ".concat(u4) : "",
                        o4.parts.length ? Bb : ""
                    ]);
                }
            case "css-comment":
                {
                    const e14 = r4.inline || r4.raws.inline, n6 = t9.originalText.slice(Bv(r4), Nv(r4));
                    return e14 ? n6.trimEnd() : n6;
                }
            case "css-rule":
                return Sb([
                    e13.call(n5, "selector"),
                    r4.important ? " !important" : "",
                    r4.nodes ? Sb([
                        r4.selector && "selector-unknown" === r4.selector.type && wv(r4.selector.value) ? Tb : " ",
                        "{",
                        r4.nodes.length > 0 ? Ob(Sb([
                            Bb,
                            Pv(e13, t9, n5)
                        ])) : "",
                        Bb,
                        "}",
                        Qb(r4) ? ";" : ""
                    ]) : ";"
                ]);
            case "css-decl":
                {
                    const o4 = e13.getParentNode(), { between: u4  } = r4.raws, i5 = u4.trim(), a4 = ":" === i5;
                    let s4 = cv(r4) ? jb(e13.call(n5, "value")) : e13.call(n5, "value");
                    return (!a4 && wv(i5) && (s4 = Ob(Sb([
                        Bb,
                        Ib(s4)
                    ]))), Sb([
                        r4.raws.before.replace(/[\s;]/g, ""),
                        Wb(e13) ? r4.prop : $b(r4.prop),
                        i5.startsWith("//") ? " " : "",
                        i5,
                        r4.extend ? "" : " ",
                        Yb(t9) && r4.extend && r4.selector ? Sb([
                            "extend(",
                            e13.call(n5, "selector"),
                            ")"
                        ]) : "",
                        s4,
                        r4.raws.important ? r4.raws.important.replace(/\s*!\s*important/i, " !important") : r4.important ? " !important" : "",
                        r4.raws.scssDefault ? r4.raws.scssDefault.replace(/\s*!default/i, " !default") : r4.scssDefault ? " !default" : "",
                        r4.raws.scssGlobal ? r4.raws.scssGlobal.replace(/\s*!global/i, " !global") : r4.scssGlobal ? " !global" : "",
                        r4.nodes ? Sb([
                            " {",
                            Ob(Sb([
                                Nb,
                                Pv(e13, t9, n5)
                            ])),
                            Nb,
                            "}"
                        ]) : gv(r4) && !o4.raws.semicolon && ";" !== t9.originalText[Nv(r4) - 1] ? "" : t9.__isHTMLStyleAttribute && Xb(e13, r4) ? Lb(";", "") : ";"
                    ]));
                }
            case "css-atrule":
                {
                    const o4 = e13.getParentNode(), u4 = mv(r4) && !o4.raws.semicolon && ";" !== t9.originalText[Nv(r4) - 1];
                    if (Yb(t9)) {
                        if (r4.mixin) return Sb([
                            e13.call(n5, "selector"),
                            r4.important ? " !important" : "",
                            u4 ? "" : ";"
                        ]);
                        if (r4.function) return Sb([
                            r4.name,
                            Sb([
                                e13.call(n5, "params")
                            ]),
                            u4 ? "" : ";"
                        ]);
                        if (r4.variable) return Sb([
                            "@",
                            r4.name,
                            ": ",
                            r4.value ? Sb([
                                e13.call(n5, "value")
                            ]) : "",
                            r4.raws.between.trim() ? r4.raws.between.trim() + " " : "",
                            r4.nodes ? Sb([
                                "{",
                                Ob(Sb([
                                    r4.nodes.length > 0 ? Nb : "",
                                    Pv(e13, t9, n5)
                                ])),
                                Nb,
                                "}"
                            ]) : "",
                            u4 ? "" : ";"
                        ]);
                    }
                    return Sb([
                        "@",
                        hv(r4) || r4.name.endsWith(":") ? r4.name : $b(r4.name),
                        r4.params ? Sb([
                            hv(r4) ? "" : mv(r4) ? "" === r4.raws.afterName ? "" : r4.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r4.raws.afterName) ? Sb([
                                Bb,
                                Bb
                            ]) : /^\s*\n/.test(r4.raws.afterName) ? Bb : " " : " ",
                            e13.call(n5, "params")
                        ]) : "",
                        r4.selector ? Ob(Sb([
                            " ",
                            e13.call(n5, "selector")
                        ])) : "",
                        r4.value ? kb(Sb([
                            " ",
                            e13.call(n5, "value"),
                            Kb(r4) ? pv(r4) ? " " : Tb : ""
                        ])) : "else" === r4.name ? " " : "",
                        r4.nodes ? Sb([
                            Kb(r4) ? "" : r4.selector && !r4.selector.nodes && "string" == typeof r4.selector.value && wv(r4.selector.value) || !r4.selector && "string" == typeof r4.params && wv(r4.params) ? Tb : " ",
                            "{",
                            Ob(Sb([
                                r4.nodes.length > 0 ? Nb : "",
                                Pv(e13, t9, n5)
                            ])),
                            Nb,
                            "}"
                        ]) : u4 ? "" : ";"
                    ]);
                }
            case "media-query-list":
                {
                    const t10 = [];
                    return (e13.each((e14)=>{
                        const r5 = e14.getValue();
                        "media-query" === r5.type && "" === r5.value || t10.push(e14.call(n5));
                    }, "nodes"), kb(Ob(wb(Tb, t10))));
                }
            case "media-query":
                return Sb([
                    wb(" ", e13.map(n5, "nodes")),
                    Xb(e13, r4) ? "" : ","
                ]);
            case "media-type":
                return jv(Lv(r4.value, t9));
            case "media-feature-expression":
                return r4.nodes ? Sb([
                    "(",
                    Sb(e13.map(n5, "nodes")),
                    ")"
                ]) : r4.value;
            case "media-feature":
                return $b(Lv(r4.value.replace(/ +/g, " "), t9));
            case "media-colon":
                return Sb([
                    r4.value,
                    " "
                ]);
            case "media-value":
                return jv(Lv(r4.value, t9));
            case "media-keyword":
                return Lv(r4.value, t9);
            case "media-url":
                return Lv(r4.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), t9);
            case "media-unknown":
                return r4.value;
            case "selector-root":
                return kb(Sb([
                    Ub(e13, "custom-selector") ? Sb([
                        Rb(e13, "css-atrule").customSelector,
                        Tb
                    ]) : "",
                    wb(Sb([
                        ",",
                        Ub(e13, [
                            "extend",
                            "custom-selector",
                            "nest"
                        ]) ? Tb : Bb
                    ]), e13.map(n5, "nodes"))
                ]));
            case "selector-selector":
                return kb(Ob(Sb(e13.map(n5, "nodes"))));
            case "selector-comment":
                return r4.value;
            case "selector-string":
                return Lv(r4.value, t9);
            case "selector-tag":
                {
                    const t10 = e13.getParentNode(), n6 = t10 && t10.nodes.indexOf(r4), o4 = n6 && t10.nodes[n6 - 1];
                    return Sb([
                        r4.namespace ? Sb([
                            !0 === r4.namespace ? "" : r4.namespace.trim(),
                            "|"
                        ]) : "",
                        "selector-nesting" === o4.type ? r4.value : jv(zb(e13, r4.value) ? r4.value.toLowerCase() : r4.value)
                    ]);
                }
            case "selector-id":
                return Sb([
                    "#",
                    r4.value
                ]);
            case "selector-class":
                return Sb([
                    ".",
                    jv(Lv(r4.value, t9))
                ]);
            case "selector-attribute":
                return Sb([
                    "[",
                    r4.namespace ? Sb([
                        !0 === r4.namespace ? "" : r4.namespace.trim(),
                        "|"
                    ]) : "",
                    r4.attribute.trim(),
                    r4.operator ? r4.operator : "",
                    r4.value ? Mv(Lv(r4.value.trim(), t9), t9) : "",
                    r4.insensitive ? " i" : "",
                    "]"
                ]);
            case "selector-combinator":
                {
                    if ("+" === r4.value || ">" === r4.value || "~" === r4.value || ">>>" === r4.value) {
                        const t10 = e13.getParentNode(), n6 = "selector-selector" === t10.type && t10.nodes[0] === r4 ? "" : Tb;
                        return Sb([
                            n6,
                            r4.value,
                            Xb(e13, r4) ? "" : " "
                        ]);
                    }
                    const n6 = r4.value.trim().startsWith("(") ? Tb : "", o4 = jv(Lv(r4.value.trim(), t9)) || Tb;
                    return Sb([
                        n6,
                        o4
                    ]);
                }
            case "selector-universal":
                return Sb([
                    r4.namespace ? Sb([
                        !0 === r4.namespace ? "" : r4.namespace.trim(),
                        "|"
                    ]) : "",
                    r4.value
                ]);
            case "selector-pseudo":
                return Sb([
                    $b(r4.value),
                    r4.nodes && r4.nodes.length > 0 ? Sb([
                        "(",
                        wb(", ", e13.map(n5, "nodes")),
                        ")"
                    ]) : ""
                ]);
            case "selector-nesting":
                return r4.value;
            case "selector-unknown":
                {
                    const n6 = Rb(e13, "css-rule");
                    if (n6 && n6.isSCSSNesterProperty) return jv(Lv($b(r4.value), t9));
                    const o4 = e13.getParentNode();
                    if (o4.raws && o4.raws.selector) {
                        const e14 = Bv(o4), n7 = e14 + o4.raws.selector.length;
                        return t9.originalText.slice(e14, n7).trim();
                    }
                    const u4 = e13.getParentNode(1);
                    if ("value-paren_group" === o4.type && u4 && "value-func" === u4.type && "selector" === u4.value) {
                        const e14 = Bv(o4.open) + 1, n7 = Nv(o4.close) - 1, r5 = t9.originalText.slice(e14, n7).trim();
                        return wv(r5) ? Sb([
                            Mb,
                            r5
                        ]) : r5;
                    }
                    return r4.value;
                }
            case "value-value":
            case "value-root":
                return e13.call(n5, "group");
            case "value-comment":
                return t9.originalText.slice(Bv(r4), Nv(r4));
            case "value-comma_group":
                {
                    const t10 = e13.getParentNode(), o4 = e13.getParentNode(1), u4 = Vb(e13), i5 = u4 && "value-value" === t10.type && ("grid" === u4 || u4.startsWith("grid-template")), a4 = Rb(e13, "css-atrule"), s4 = a4 && Kb(a4), l4 = e13.map(n5, "groups"), c4 = [], p4 = qb(e13, "url");
                    let d4 = !1, f4 = !1;
                    for(let n6 = 0; n6 < r4.groups.length; ++n6){
                        c4.push(l4[n6]);
                        const u5 = r4.groups[n6 - 1], h4 = r4.groups[n6], m4 = r4.groups[n6 + 1], g4 = r4.groups[n6 + 2];
                        if (p4) {
                            (m4 && rv(m4) || rv(h4)) && c4.push(" ");
                            continue;
                        }
                        if (!m4) continue;
                        if ("value-word" === h4.type && h4.value.endsWith("-") && Tv(m4)) continue;
                        const D4 = "value-string" === h4.type && h4.value.startsWith("#{"), y4 = d4 && "value-string" === m4.type && m4.value.endsWith("}");
                        if (D4 || y4) {
                            d4 = !d4;
                            continue;
                        }
                        if (d4) continue;
                        if (Fv(h4) || Fv(m4)) continue;
                        if ("value-atword" === h4.type && "" === h4.value) continue;
                        if ("~" === h4.value) continue;
                        if (h4.value && h4.value.includes("\\") && m4 && "value-comment" !== m4.type) continue;
                        if (u5 && u5.value && u5.value.indexOf("\\") === u5.value.length - 1 && "value-operator" === h4.type && "/" === h4.value) continue;
                        if ("\\" === h4.value) continue;
                        if (Dv(h4, m4)) continue;
                        if (Cv(h4) || bv(h4) || vv(m4) || bv(m4) && dv(m4) || vv(h4) && dv(m4)) continue;
                        if ("--" === h4.value && Cv(m4)) continue;
                        const E4 = uv(h4), C3 = uv(m4);
                        if ((E4 && Cv(m4) || C3 && vv(h4)) && dv(m4)) continue;
                        if (qb(e13, "calc") && (rv(h4) || rv(m4) || ov(h4) || ov(m4)) && dv(m4)) continue;
                        const b3 = (rv(h4) || ov(h4)) && 0 === n6 && ("value-number" === m4.type || m4.isHex) && o4 && Sv(o4) && !dv(m4), v3 = g4 && "value-func" === g4.type || g4 && Av(g4) || "value-func" === h4.type || Av(h4), A3 = "value-func" === m4.type || Av(m4) || u5 && "value-func" === u5.type || u5 && Av(u5);
                        if (tv(m4) || tv(h4) || qb(e13, "calc") || b3 || !(nv(m4) && !v3 || nv(h4) && !A3 || rv(m4) && !v3 || rv(h4) && !A3 || ov(m4) || ov(h4)) || !(dv(m4) || E4 && (!u5 || u5 && uv(u5)))) {
                            if (Ev(h4)) {
                                if ("value-paren_group" === t10.type) {
                                    c4.push(Ib(Bb));
                                    continue;
                                }
                                c4.push(Bb);
                            } else s4 && (ev(m4) || Zb(m4) || lv(m4) || iv(h4) || av(h4)) || a4 && "namespace" === a4.name.toLowerCase() ? c4.push(" ") : i5 ? h4.source && m4.source && h4.source.start.line !== m4.source.start.line ? (c4.push(Bb), f4 = !0) : c4.push(" ") : C3 ? c4.push(" ") : m4 && "..." === m4.value || Tv(h4) && Tv(m4) && Nv(h4) === Bv(m4) || c4.push(Tb);
                        }
                    }
                    return (f4 && c4.unshift(Bb), s4 ? kb(Ob(Sb(c4))) : Jb(e13) ? kb(Pb(c4)) : kb(Ob(Pb(c4))));
                }
            case "value-paren_group":
                {
                    const o4 = e13.getParentNode();
                    if (o4 && sv(o4) && (1 === r4.groups.length || r4.groups.length > 0 && "value-comma_group" === r4.groups[0].type && r4.groups[0].groups.length > 0 && "value-word" === r4.groups[0].groups[0].type && r4.groups[0].groups[0].value.startsWith("data:"))) return Sb([
                        r4.open ? e13.call(n5, "open") : "",
                        wb(",", e13.map(n5, "groups")),
                        r4.close ? e13.call(n5, "close") : ""
                    ]);
                    if (!r4.open) {
                        const t10 = e13.map(n5, "groups"), r5 = [];
                        for(let e14 = 0; e14 < t10.length; e14++)0 !== e14 && r5.push(Sb([
                            ",",
                            Tb
                        ])), r5.push(t10[e14]);
                        return kb(Ob(Pb(r5)));
                    }
                    const u4 = yv(e13), i5 = r4.groups[r4.groups.length - 1], a4 = i5 && "value-comment" === i5.type;
                    return kb(Sb([
                        r4.open ? e13.call(n5, "open") : "",
                        Ob(Sb([
                            Nb,
                            wb(Sb([
                                ",",
                                Tb
                            ]), e13.map((e14)=>{
                                const t10 = e14.getValue(), r5 = n5(e14);
                                return fv(t10) && "value-comma_group" === t10.type && t10.groups && t10.groups[2] && "value-paren_group" === t10.groups[2].type ? (r5.contents.contents.parts[1] = kb(r5.contents.contents.parts[1]), kb(Ib(r5))) : r5;
                            }, "groups"))
                        ])),
                        Lb(!a4 && Hb(t9.parser, t9.originalText) && u4 && kv(t9) ? "," : ""),
                        Nb,
                        r4.close ? e13.call(n5, "close") : ""
                    ]), {
                        shouldBreak: u4
                    });
                }
            case "value-func":
                return Sb([
                    r4.value,
                    Ub(e13, "supports") && xv(r4) ? " " : "",
                    e13.call(n5, "group")
                ]);
            case "value-paren":
                return r4.value;
            case "value-number":
                return Sb([
                    _v(r4.value),
                    $b(r4.unit)
                ]);
            case "value-operator":
                return r4.value;
            case "value-word":
                return r4.isColor && r4.isHex || Gb(r4.value) ? r4.value.toLowerCase() : r4.value;
            case "value-colon":
                {
                    const t10 = e13.getParentNode(), n6 = t10 && t10.groups.indexOf(r4), o4 = n6 && t10.groups[n6 - 1];
                    return Sb([
                        r4.value,
                        o4 && "\\" === o4.value[o4.value.length - 1] || qb(e13, "url") ? "" : Tb
                    ]);
                }
            case "value-comma":
                return Sb([
                    r4.value,
                    " "
                ]);
            case "value-string":
                return vb(r4.raws.quote + r4.value + r4.raws.quote, t9);
            case "value-atword":
                return Sb([
                    "@",
                    r4.value
                ]);
            case "value-unicode-range":
            case "value-unknown":
                return r4.value;
            default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(r4.type)));
        }
    },
    embed: ZC,
    insertPragma: _b,
    massageAstNode: UC
}, Vv = {
    singleQuote: kC.singleQuote
}, $v = {
    name: "PostCSS",
    type: "markup",
    tmScope: "source.postcss",
    group: "CSS",
    extensions: [
        ".pcss",
        ".postcss"
    ],
    aceMode: "text",
    languageId: 262764437
}, qv = {
    name: "Less",
    type: "markup",
    color: "#1d365d",
    extensions: [
        ".less"
    ],
    tmScope: "source.css.less",
    aceMode: "less",
    codemirrorMode: "css",
    codemirrorMimeType: "text/css",
    languageId: 198
}, Wv = {
    name: "SCSS",
    type: "markup",
    color: "#c6538c",
    tmScope: "source.css.scss",
    aceMode: "scss",
    codemirrorMode: "css",
    codemirrorMimeType: "text/x-scss",
    extensions: [
        ".scss"
    ],
    languageId: 329
};
var Uv = {
    languages: [
        xs1({
            name: "CSS",
            type: "markup",
            tmScope: "source.css",
            aceMode: "css",
            codemirrorMode: "css",
            codemirrorMimeType: "text/css",
            color: "#563d7c",
            extensions: [
                ".css"
            ],
            languageId: 50
        }, (e13)=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "css"
                ],
                extensions: [
                    ...e13.extensions,
                    ".wxss"
                ]
            })
        ),
        xs1($v, ()=>({
                since: "1.4.0",
                parsers: [
                    "css"
                ],
                vscodeLanguageIds: [
                    "postcss"
                ]
            })
        ),
        xs1(qv, ()=>({
                since: "1.4.0",
                parsers: [
                    "less"
                ],
                vscodeLanguageIds: [
                    "less"
                ]
            })
        ),
        xs1(Wv, ()=>({
                since: "1.4.0",
                parsers: [
                    "scss"
                ],
                vscodeLanguageIds: [
                    "scss"
                ]
            })
        )
    ],
    options: Vv,
    printers: {
        postcss: Rv
    },
    parsers: {
        get css () {
            return {
            }.parsers.css;
        },
        get less () {
            return {
            }.parsers.less;
        },
        get scss () {
            return {
            }.parsers.scss;
        }
    }
};
const { builders: { concat: nA , group: rA , hardline: oA , ifBreak: uA , indent: iA , join: aA , line: sA , softline: lA  }  } = rn1, { locStart: cA , locEnd: pA  } = Jv, { getNextNode: dA , getPreviousNode: fA , hasPrettierIgnore: hA , isNextNodeOfSomeType: mA , isNodeOfSomeType: gA , isParentOfSomeType: DA , isPreviousNodeOfSomeType: yA , isVoid: EA , isWhitespaceNode: CA  } = tA;
function bA(e13, t9) {
    const n5 = e13.getValue();
    return nA([
        "<",
        n5.tag,
        vA(e13, t9),
        HA(n5),
        FA(n5)
    ]);
}
function vA(e13, t9) {
    const n5 = e13.getValue();
    return iA(nA([
        n5.attributes.length ? sA : "",
        aA(sA, e13.map(t9, "attributes")),
        n5.modifiers.length ? sA : "",
        aA(sA, e13.map(t9, "modifiers")),
        n5.comments.length ? sA : "",
        aA(sA, e13.map(t9, "comments"))
    ]));
}
function AA(e13, t9, n5) {
    return nA(e13.map((e14, r4)=>0 === r4 ? nA([
            lA,
            n5(e14, t9, n5)
        ]) : n5(e14, t9, n5)
    , "children"));
}
function FA(e13) {
    return EA(e13) ? uA(nA([
        lA,
        "/>"
    ]), nA([
        " />",
        lA
    ])) : uA(nA([
        lA,
        ">"
    ]), ">");
}
function xA(e13) {
    const t9 = !1 === e13.escaped ? "{{{" : "{{", n5 = e13.strip && e13.strip.open ? "~" : "";
    return nA([
        t9,
        n5
    ]);
}
function SA(e13) {
    const t9 = !1 === e13.escaped ? "}}}" : "}}", n5 = e13.strip && e13.strip.close ? "~" : "";
    return nA([
        n5,
        t9
    ]);
}
function wA(e13) {
    const t9 = xA(e13), n5 = e13.openStrip.open ? "~" : "";
    return nA([
        t9,
        n5,
        "#"
    ]);
}
function TA(e13) {
    const t9 = SA(e13), n5 = e13.openStrip.close ? "~" : "";
    return nA([
        n5,
        t9
    ]);
}
function BA(e13) {
    const t9 = xA(e13), n5 = e13.closeStrip.open ? "~" : "";
    return nA([
        t9,
        n5,
        "/"
    ]);
}
function NA(e13) {
    const t9 = SA(e13), n5 = e13.closeStrip.close ? "~" : "";
    return nA([
        n5,
        t9
    ]);
}
function kA(e13) {
    const t9 = xA(e13), n5 = e13.inverseStrip.open ? "~" : "";
    return nA([
        t9,
        n5
    ]);
}
function PA(e13) {
    const t9 = SA(e13), n5 = e13.inverseStrip.close ? "~" : "";
    return nA([
        n5,
        t9
    ]);
}
function OA(e13, t9) {
    const n5 = e13.getValue();
    return rA(nA([
        wA(n5),
        JA(e13, t9),
        HA(n5.program),
        lA,
        TA(n5)
    ]));
}
function IA(e13) {
    return nA([
        oA,
        kA(e13),
        "else",
        PA(e13)
    ]);
}
function LA(e13, t9) {
    const n5 = e13.getParentNode(1);
    return nA([
        kA(n5),
        "else ",
        JA(e13, t9),
        PA(n5)
    ]);
}
function MA(e13, t9) {
    const n5 = e13.getValue();
    return nA([
        jA(n5) ? lA : oA,
        BA(n5),
        e13.call(t9, "path"),
        NA(n5)
    ]);
}
function jA(e13) {
    return gA(e13, [
        "BlockStatement"
    ]) && e13.program.body.every((e14)=>CA(e14)
    );
}
function _A(e13) {
    return gA(e13, [
        "BlockStatement"
    ]) && e13.inverse;
}
function RA(e13, t9) {
    if (jA(e13.getValue())) return "";
    const n5 = e13.call(t9, "program");
    return iA(nA([
        oA,
        n5
    ]));
}
function VA(e13, t9) {
    const n5 = e13.getValue(), r4 = e13.call(t9, "inverse"), o4 = nA([
        oA,
        r4
    ]);
    return (function(e14) {
        return _A(e14) && 1 === e14.inverse.body.length && gA(e14.inverse.body[0], [
            "BlockStatement"
        ]) && "if" === e14.inverse.body[0].path.parts[0];
    })(n5) ? o4 : _A(n5) ? nA([
        IA(n5),
        iA(o4)
    ]) : "";
}
function qA(e13 = 0, t9 = 0) {
    return new Array(Math.min(e13, t9)).fill(oA);
}
function WA(e13, t9) {
    const n5 = {
        quote: '"',
        regex: /"/g
    }, r4 = {
        quote: "'",
        regex: /'/g
    }, o4 = t9.singleQuote ? r4 : n5, u4 = o4 === r4 ? n5 : r4;
    let i5 = !1;
    if (e13.includes(o4.quote) || e13.includes(u4.quote)) {
        i5 = (e13.match(o4.regex) || []).length > (e13.match(u4.regex) || []).length;
    }
    const a4 = i5 ? u4 : o4, s4 = e13.replace(a4.regex, "\\".concat(a4.quote));
    return nA([
        a4.quote,
        s4,
        a4.quote
    ]);
}
function UA(e13, t9) {
    const n5 = zA(e13, t9), r4 = GA(e13, t9);
    return r4 ? iA(nA([
        n5,
        sA,
        rA(r4)
    ])) : n5;
}
function JA(e13, t9) {
    const n5 = zA(e13, t9), r4 = GA(e13, t9);
    return r4 ? iA(rA(nA([
        n5,
        sA,
        r4
    ]))) : n5;
}
function GA(e13, t9) {
    const n5 = e13.getValue(), r4 = [];
    if (n5.params.length) {
        const n6 = e13.map(t9, "params");
        r4.push(...n6);
    }
    if (n5.hash && n5.hash.pairs.length > 0) {
        const n6 = e13.call(t9, "hash");
        r4.push(n6);
    }
    return r4.length ? aA(sA, r4) : "";
}
function HA(e13) {
    return e13 && e13.blockParams.length ? nA([
        " as |",
        e13.blockParams.join(" "),
        "|"
    ]) : "";
}
var XA = {
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if (!r4) return "";
        if (hA(e13)) return t9.originalText.slice(cA(r4), pA(r4));
        switch(r4.type){
            case "Block":
            case "Program":
            case "Template":
                return rA(nA(e13.map(n5, "body")));
            case "ElementNode":
                {
                    const o4 = mA(e13, [
                        "ElementNode"
                    ]) ? oA : "";
                    if (EA(r4)) return nA([
                        rA(bA(e13, n5)),
                        o4
                    ]);
                    const u4 = r4.children.every((e14)=>CA(e14)
                    );
                    return nA([
                        rA(bA(e13, n5)),
                        rA(nA([
                            u4 ? "" : iA(AA(e13, t9, n5)),
                            r4.children.length ? oA : "",
                            nA([
                                "</",
                                r4.tag,
                                ">"
                            ])
                        ])),
                        o4
                    ]);
                }
            case "BlockStatement":
                {
                    const t10 = e13.getParentNode(1), o4 = t10 && t10.inverse && 1 === t10.inverse.body.length && t10.inverse.body[0] === r4 && "if" === t10.inverse.body[0].path.parts[0];
                    return nA(o4 ? [
                        LA(e13, n5),
                        RA(e13, n5),
                        VA(e13, n5)
                    ] : [
                        OA(e13, n5),
                        rA(nA([
                            RA(e13, n5),
                            VA(e13, n5),
                            MA(e13, n5)
                        ]))
                    ]);
                }
            case "ElementModifierStatement":
                return rA(nA([
                    "{{",
                    JA(e13, n5),
                    lA,
                    "}}"
                ]));
            case "MustacheStatement":
                {
                    const t10 = DA(e13, [
                        "AttrNode",
                        "ConcatStatement"
                    ]), o4 = DA(e13, [
                        "ElementNode"
                    ]) && 0 === r4.hash.pairs.length && function(e14) {
                        return 0 === e14.params.length;
                    }(r4), u4 = t10 || o4;
                    return rA(nA([
                        xA(r4),
                        u4 ? iA(lA) : "",
                        JA(e13, n5),
                        lA,
                        SA(r4)
                    ]));
                }
            case "SubExpression":
                return rA(nA([
                    "(",
                    UA(e13, n5),
                    lA,
                    ")"
                ]));
            case "AttrNode":
                {
                    const o4 = "TextNode" === r4.value.type;
                    if (o4 && "" === r4.value.chars && cA(r4.value) === pA(r4.value)) return nA([
                        r4.name
                    ]);
                    const u4 = e13.call(n5, "value"), i5 = o4 ? WA(u4.parts.join(), t9) : u4;
                    return nA([
                        r4.name,
                        "=",
                        i5
                    ]);
                }
            case "ConcatStatement":
                {
                    const r5 = t9.singleQuote ? "'" : '"';
                    return nA([
                        r5,
                        ...e13.map((e14)=>n5(e14)
                        , "parts"),
                        r5
                    ]);
                }
            case "Hash":
                return nA([
                    aA(sA, e13.map(n5, "pairs"))
                ]);
            case "HashPair":
                return nA([
                    r4.key,
                    "=",
                    e13.call(n5, "value")
                ]);
            case "TextNode":
                {
                    const t10 = 2, n6 = !fA(e13), o4 = !dA(e13), u4 = !/\S/.test(r4.chars), i5 = $A(r4.chars);
                    let a4 = function(e14) {
                        return $A(((e14 = "string" == typeof e14 ? e14 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
                    }(r4.chars), s4 = function(e14) {
                        return $A(((e14 = "string" == typeof e14 ? e14 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
                    }(r4.chars);
                    if ((n6 || o4) && u4 && DA(e13, [
                        "Block",
                        "ElementNode",
                        "Template"
                    ])) return "";
                    u4 && i5 ? (a4 = Math.min(i5, 2), s4 = 0) : (mA(e13, [
                        "BlockStatement",
                        "ElementNode"
                    ]) && (s4 = Math.max(s4, 1)), yA(e13, [
                        "BlockStatement",
                        "ElementNode"
                    ]) && (a4 = Math.max(a4, 1)));
                    if (e13.stack.includes("attributes")) {
                        if (!function(e14, t11) {
                            return DA(e14, [
                                "AttrNode"
                            ]) && e14.getParentNode().name.toLowerCase() === t11 || DA(e14, [
                                "ConcatStatement"
                            ]) && e14.getParentNode(1).name.toLowerCase() === t11;
                        }(e13, "class")) return nA([
                            r4.chars
                        ]);
                        let n7 = "", o5 = "";
                        return (DA(e13, [
                            "ConcatStatement"
                        ]) && (yA(e13, [
                            "MustacheStatement"
                        ]) && (n7 = " "), mA(e13, [
                            "MustacheStatement"
                        ]) && (o5 = " ")), nA([
                            ...qA(a4, 2),
                            r4.chars.replace(/^\s+/g, n7).replace(/\s+$/, o5),
                            ...qA(s4, 2)
                        ]));
                    }
                    let l4 = "", c4 = "";
                    0 === s4 && mA(e13, [
                        "MustacheStatement"
                    ]) && (c4 = " "), 0 === a4 && yA(e13, [
                        "MustacheStatement"
                    ]) && (l4 = " "), n6 && (a4 = 0, l4 = ""), o4 && (s4 = 0, c4 = "");
                    let p4 = r4.chars;
                    return (p4.startsWith("{{") && p4.includes("}}") && (p4 = "\\" + p4), nA([
                        ...qA(a4, 2),
                        p4.replace(/^\s+/g, l4).replace(/\s+$/, c4),
                        ...qA(s4, 2)
                    ]));
                }
            case "MustacheCommentStatement":
                {
                    const e14 = r4.value.includes("}}") ? "--" : "";
                    return nA([
                        "{{!",
                        e14,
                        r4.value,
                        e14,
                        "}}"
                    ]);
                }
            case "PathExpression":
                return r4.original;
            case "BooleanLiteral":
                return String(r4.value);
            case "CommentStatement":
                return nA([
                    "\x3c!--",
                    r4.value,
                    "--\x3e"
                ]);
            case "StringLiteral":
                return WA(r4.value, t9);
            case "NumberLiteral":
                return String(r4.value);
            case "UndefinedLiteral":
                return "undefined";
            case "NullLiteral":
                return "null";
            default:
                throw new Error("unknown glimmer type: " + JSON.stringify(r4.type));
        }
    },
    massageAstNode: Gv
};
var YA = {
    languages: [
        xs1({
            name: "Handlebars",
            type: "markup",
            color: "#f7931e",
            aliases: [
                "hbs",
                "htmlbars"
            ],
            extensions: [
                ".handlebars",
                ".hbs"
            ],
            tmScope: "text.html.handlebars",
            aceMode: "handlebars",
            languageId: 155
        }, ()=>({
                since: null,
                parsers: [
                    "glimmer"
                ],
                vscodeLanguageIds: [
                    "handlebars"
                ]
            })
        )
    ],
    printers: {
        glimmer: XA
    },
    parsers: {
        get glimmer () {
            return {
            }.parsers.glimmer;
        }
    }
};
const { builders: { concat: ZA , join: eF , hardline: tF , line: nF , softline: rF , group: oF , indent: uF , ifBreak: iF  }  } = rn1, { isNextLineEmpty: aF  } = Nt1, { insertPragma: sF  } = KA, { locStart: lF , locEnd: cF  } = QA;
function pF(e13, t9, n5) {
    if (0 === n5.directives.length) return "";
    const r4 = eF(nF, e13.map(t9, "directives"));
    return "FragmentDefinition" === n5.kind || "OperationDefinition" === n5.kind ? oF(ZA([
        nF,
        r4
    ])) : ZA([
        " ",
        oF(uF(ZA([
            rF,
            r4
        ])))
    ]);
}
function dF(e13, t9, n5) {
    const r4 = e13.getValue().length;
    return e13.map((e14, o4)=>{
        const u4 = n5(e14);
        return aF(t9.originalText, e14.getValue(), cF) && o4 < r4 - 1 ? ZA([
            u4,
            tF
        ]) : u4;
    });
}
function fF(e13, t9, n5) {
    const r4 = e13.getNode(), o4 = [], { interfaces: u4  } = r4, i5 = e13.map((e14)=>n5(e14)
    , "interfaces");
    for(let e14 = 0; e14 < u4.length; e14++){
        const n6 = u4[e14];
        o4.push(i5[e14]);
        const r5 = u4[e14 + 1];
        if (r5) {
            const e15 = t9.originalText.slice(n6.loc.end, r5.loc.start), u5 = e15.includes("#"), i6 = e15.replace(/#.*/g, "").trim();
            o4.push("," === i6 ? "," : " &"), o4.push(u5 ? nF : " ");
        }
    }
    return o4;
}
var mF = {
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if (!r4) return "";
        if ("string" == typeof r4) return r4;
        switch(r4.kind){
            case "Document":
                {
                    const o4 = [];
                    return (e13.each((e14, u4)=>{
                        o4.push(ZA([
                            e14.call(n5)
                        ])), u4 !== r4.definitions.length - 1 && (o4.push(tF), aF(t9.originalText, e14.getValue(), cF) && o4.push(tF));
                    }, "definitions"), ZA([
                        ZA(o4),
                        tF
                    ]));
                }
            case "OperationDefinition":
                {
                    const o4 = "{" !== t9.originalText[lF(r4)], u4 = !!r4.name;
                    return ZA([
                        o4 ? r4.operation : "",
                        o4 && u4 ? ZA([
                            " ",
                            e13.call(n5, "name")
                        ]) : "",
                        r4.variableDefinitions && r4.variableDefinitions.length ? oF(ZA([
                            "(",
                            uF(ZA([
                                rF,
                                eF(ZA([
                                    iF("", ", "),
                                    rF
                                ]), e13.map(n5, "variableDefinitions"))
                            ])),
                            rF,
                            ")"
                        ])) : "",
                        pF(e13, n5, r4),
                        r4.selectionSet && (o4 || u4) ? " " : "",
                        e13.call(n5, "selectionSet")
                    ]);
                }
            case "FragmentDefinition":
                return ZA([
                    "fragment ",
                    e13.call(n5, "name"),
                    r4.variableDefinitions && r4.variableDefinitions.length ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e13.map(n5, "variableDefinitions"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    " on ",
                    e13.call(n5, "typeCondition"),
                    pF(e13, n5, r4),
                    " ",
                    e13.call(n5, "selectionSet")
                ]);
            case "SelectionSet":
                return ZA([
                    "{",
                    uF(ZA([
                        tF,
                        eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                        , "selections"))
                    ])),
                    tF,
                    "}"
                ]);
            case "Field":
                return oF(ZA([
                    r4.alias ? ZA([
                        e13.call(n5, "alias"),
                        ": "
                    ]) : "",
                    e13.call(n5, "name"),
                    r4.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e13.call((e14)=>dF(e14, t9, n5)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    pF(e13, n5, r4),
                    r4.selectionSet ? " " : "",
                    e13.call(n5, "selectionSet")
                ]));
            case "Name":
                return r4.value;
            case "StringValue":
                return r4.block ? ZA([
                    '"""',
                    tF,
                    eF(tF, r4.value.replace(/"""/g, "\\$&").split("\n")),
                    tF,
                    '"""'
                ]) : ZA([
                    '"',
                    r4.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"),
                    '"'
                ]);
            case "IntValue":
            case "FloatValue":
            case "EnumValue":
                return r4.value;
            case "BooleanValue":
                return r4.value ? "true" : "false";
            case "NullValue":
                return "null";
            case "Variable":
                return ZA([
                    "$",
                    e13.call(n5, "name")
                ]);
            case "ListValue":
                return oF(ZA([
                    "[",
                    uF(ZA([
                        rF,
                        eF(ZA([
                            iF("", ", "),
                            rF
                        ]), e13.map(n5, "values"))
                    ])),
                    rF,
                    "]"
                ]));
            case "ObjectValue":
                return oF(ZA([
                    "{",
                    t9.bracketSpacing && r4.fields.length > 0 ? " " : "",
                    uF(ZA([
                        rF,
                        eF(ZA([
                            iF("", ", "),
                            rF
                        ]), e13.map(n5, "fields"))
                    ])),
                    rF,
                    iF("", t9.bracketSpacing && r4.fields.length > 0 ? " " : ""),
                    "}"
                ]));
            case "ObjectField":
            case "Argument":
                return ZA([
                    e13.call(n5, "name"),
                    ": ",
                    e13.call(n5, "value")
                ]);
            case "Directive":
                return ZA([
                    "@",
                    e13.call(n5, "name"),
                    r4.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e13.call((e14)=>dF(e14, t9, n5)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : ""
                ]);
            case "NamedType":
                return e13.call(n5, "name");
            case "VariableDefinition":
                return ZA([
                    e13.call(n5, "variable"),
                    ": ",
                    e13.call(n5, "type"),
                    r4.defaultValue ? ZA([
                        " = ",
                        e13.call(n5, "defaultValue")
                    ]) : "",
                    pF(e13, n5, r4)
                ]);
            case "ObjectTypeExtension":
            case "ObjectTypeDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "ObjectTypeExtension" === r4.kind ? "extend " : "",
                    "type ",
                    e13.call(n5, "name"),
                    r4.interfaces.length > 0 ? ZA([
                        " implements ",
                        ZA(fF(e13, t9, n5))
                    ]) : "",
                    pF(e13, n5, r4),
                    r4.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "FieldDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    e13.call(n5, "name"),
                    r4.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e13.call((e14)=>dF(e14, t9, n5)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    ": ",
                    e13.call(n5, "type"),
                    pF(e13, n5, r4)
                ]);
            case "DirectiveDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "directive ",
                    "@",
                    e13.call(n5, "name"),
                    r4.arguments.length > 0 ? oF(ZA([
                        "(",
                        uF(ZA([
                            rF,
                            eF(ZA([
                                iF("", ", "),
                                rF
                            ]), e13.call((e14)=>dF(e14, t9, n5)
                            , "arguments"))
                        ])),
                        rF,
                        ")"
                    ])) : "",
                    r4.repeatable ? " repeatable" : "",
                    ZA([
                        " on ",
                        eF(" | ", e13.map(n5, "locations"))
                    ])
                ]);
            case "EnumTypeExtension":
            case "EnumTypeDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "EnumTypeExtension" === r4.kind ? "extend " : "",
                    "enum ",
                    e13.call(n5, "name"),
                    pF(e13, n5, r4),
                    r4.values.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                            , "values"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "EnumValueDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    e13.call(n5, "name"),
                    pF(e13, n5, r4)
                ]);
            case "InputValueDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? r4.description.block ? tF : nF : "",
                    e13.call(n5, "name"),
                    ": ",
                    e13.call(n5, "type"),
                    r4.defaultValue ? ZA([
                        " = ",
                        e13.call(n5, "defaultValue")
                    ]) : "",
                    pF(e13, n5, r4)
                ]);
            case "InputObjectTypeExtension":
            case "InputObjectTypeDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "InputObjectTypeExtension" === r4.kind ? "extend " : "",
                    "input ",
                    e13.call(n5, "name"),
                    pF(e13, n5, r4),
                    r4.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "SchemaDefinition":
                return ZA([
                    "schema",
                    pF(e13, n5, r4),
                    " {",
                    r4.operationTypes.length > 0 ? uF(ZA([
                        tF,
                        eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                        , "operationTypes"))
                    ])) : "",
                    tF,
                    "}"
                ]);
            case "OperationTypeDefinition":
                return ZA([
                    e13.call(n5, "operation"),
                    ": ",
                    e13.call(n5, "type")
                ]);
            case "InterfaceTypeExtension":
            case "InterfaceTypeDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "InterfaceTypeExtension" === r4.kind ? "extend " : "",
                    "interface ",
                    e13.call(n5, "name"),
                    r4.interfaces.length > 0 ? ZA([
                        " implements ",
                        ZA(fF(e13, t9, n5))
                    ]) : "",
                    pF(e13, n5, r4),
                    r4.fields.length > 0 ? ZA([
                        " {",
                        uF(ZA([
                            tF,
                            eF(tF, e13.call((e14)=>dF(e14, t9, n5)
                            , "fields"))
                        ])),
                        tF,
                        "}"
                    ]) : ""
                ]);
            case "FragmentSpread":
                return ZA([
                    "...",
                    e13.call(n5, "name"),
                    pF(e13, n5, r4)
                ]);
            case "InlineFragment":
                return ZA([
                    "...",
                    r4.typeCondition ? ZA([
                        " on ",
                        e13.call(n5, "typeCondition")
                    ]) : "",
                    pF(e13, n5, r4),
                    " ",
                    e13.call(n5, "selectionSet")
                ]);
            case "UnionTypeExtension":
            case "UnionTypeDefinition":
                return oF(ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    oF(ZA([
                        "UnionTypeExtension" === r4.kind ? "extend " : "",
                        "union ",
                        e13.call(n5, "name"),
                        pF(e13, n5, r4),
                        r4.types.length > 0 ? ZA([
                            " =",
                            iF("", " "),
                            uF(ZA([
                                iF(ZA([
                                    nF,
                                    "  "
                                ])),
                                eF(ZA([
                                    nF,
                                    "| "
                                ]), e13.map(n5, "types"))
                            ]))
                        ]) : ""
                    ]))
                ]));
            case "ScalarTypeExtension":
            case "ScalarTypeDefinition":
                return ZA([
                    e13.call(n5, "description"),
                    r4.description ? tF : "",
                    "ScalarTypeExtension" === r4.kind ? "extend " : "",
                    "scalar ",
                    e13.call(n5, "name"),
                    pF(e13, n5, r4)
                ]);
            case "NonNullType":
                return ZA([
                    e13.call(n5, "type"),
                    "!"
                ]);
            case "ListType":
                return ZA([
                    "[",
                    e13.call(n5, "type"),
                    "]"
                ]);
            default:
                throw new Error("unknown graphql type: " + JSON.stringify(r4.kind));
        }
    },
    massageAstNode: hF,
    hasPrettierIgnore: function(e13) {
        const t9 = e13.getValue();
        return t9 && Array.isArray(t9.comments) && t9.comments.some((e14)=>"prettier-ignore" === e14.value.trim()
        );
    },
    insertPragma: sF,
    printComment: function(e13) {
        const t9 = e13.getValue();
        if ("Comment" === t9.kind) return "#" + t9.value.trimEnd();
        throw new Error("Not a comment: " + JSON.stringify(t9));
    },
    canAttachComment: function(e13) {
        return e13.kind && "Comment" !== e13.kind;
    }
}, gF = {
    bracketSpacing: kC.bracketSpacing
};
var DF = {
    languages: [
        xs1({
            name: "GraphQL",
            type: "data",
            color: "#e10098",
            extensions: [
                ".graphql",
                ".gql",
                ".graphqls"
            ],
            tmScope: "source.graphql",
            aceMode: "text",
            languageId: 139
        }, ()=>({
                since: "1.5.0",
                parsers: [
                    "graphql"
                ],
                vscodeLanguageIds: [
                    "graphql"
                ]
            })
        )
    ],
    options: gF,
    printers: {
        graphql: mF
    },
    parsers: {
        get graphql () {
            return {
            }.parsers.graphql;
        }
    }
};
const { getLast: EF  } = Nt1, { locStart: CF , locEnd: bF  } = yF, { cjkPattern: vF , kPattern: AF , punctuationPattern: FF  } = {
    cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
    kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
    punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
}, xF = [
    "liquidNode",
    "inlineCode",
    "emphasis",
    "strong",
    "delete",
    "wikiLink",
    "link",
    "linkReference",
    "image",
    "imageReference",
    "footnote",
    "footnoteReference",
    "sentence",
    "whitespace",
    "word",
    "break",
    "inlineMath"
], SF = xF.concat([
    "tableCell",
    "paragraph",
    "heading"
]), wF = new RegExp(AF), TF = new RegExp(FF);
var NF = {
    mapAst: function(e13, t9) {
        return function e13(n5, r4, o4) {
            o4 = o4 || [];
            const u4 = Object.assign({
            }, t9(n5, r4, o4));
            return u4.children && (u4.children = u4.children.map((t10, n6)=>e13(t10, n6, [
                    u4
                ].concat(o4))
            )), u4;
        }(e13, null, null);
    },
    splitText: function(e13, t9) {
        const n5 = "non-cjk", r4 = "cj-letter", o4 = "cjk-punctuation", u4 = [];
        return (("preserve" === t9.proseWrap ? e13 : e13.replace(new RegExp("(".concat(vF, ")\n(").concat(vF, ")"), "g"), "$1$2")).split(/([\t\n ]+)/).forEach((e14, t10, a4)=>{
            t10 % 2 != 1 ? (0 !== t10 && t10 !== a4.length - 1 || "" !== e14) && e14.split(new RegExp("(".concat(vF, ")"))).forEach((e15, t11, u5)=>{
                (0 !== t11 && t11 !== u5.length - 1 || "" !== e15) && (t11 % 2 != 0 ? i5(TF.test(e15) ? {
                    type: "word",
                    value: e15,
                    kind: o4,
                    hasLeadingPunctuation: !0,
                    hasTrailingPunctuation: !0
                } : {
                    type: "word",
                    value: e15,
                    kind: wF.test(e15) ? "k-letter" : r4,
                    hasLeadingPunctuation: !1,
                    hasTrailingPunctuation: !1
                }) : "" !== e15 && i5({
                    type: "word",
                    value: e15,
                    kind: n5,
                    hasLeadingPunctuation: TF.test(e15[0]),
                    hasTrailingPunctuation: TF.test(EF(e15))
                }));
            }) : u4.push({
                type: "whitespace",
                value: /\n/.test(e14) ? "\n" : " "
            });
        }), u4);
        function i5(e14) {
            const t10 = EF(u4);
            var i5, a4;
            t10 && "word" === t10.type && (t10.kind === n5 && e14.kind === r4 && !t10.hasTrailingPunctuation || t10.kind === r4 && e14.kind === n5 && !e14.hasLeadingPunctuation ? u4.push({
                type: "whitespace",
                value: " "
            }) : (i5 = n5, a4 = o4, t10.kind === i5 && e14.kind === a4 || t10.kind === a4 && e14.kind === i5 || [
                t10.value,
                e14.value
            ].some((e15)=>/\u3000/.test(e15)
            ) || u4.push({
                type: "whitespace",
                value: ""
            }))), u4.push(e14);
        }
    },
    punctuationPattern: FF,
    getFencedCodeBlockValue: function(e13, t9) {
        const { value: n5  } = e13;
        return e13.position.end.offset === t9.length && n5.endsWith("\n") && t9.endsWith("\n") ? n5.slice(0, -1) : n5;
    },
    getOrderedListItemInfo: BF,
    hasGitDiffFriendlyOrderedList: function(e13, t9) {
        if (!e13.ordered) return !1;
        if (e13.children.length < 2) return !1;
        const n5 = Number(BF(e13.children[0], t9.originalText).numberText), r4 = Number(BF(e13.children[1], t9.originalText).numberText);
        if (0 === n5 && e13.children.length > 2) {
            const n6 = Number(BF(e13.children[2], t9.originalText).numberText);
            return 1 === r4 && 1 === n6;
        }
        return 1 === r4;
    },
    INLINE_NODE_TYPES: xF,
    INLINE_NODE_WRAPPER_TYPES: SF,
    isAutolink: function(e13) {
        if (!e13 || "link" !== e13.type || 1 !== e13.children.length) return !1;
        const t9 = e13.children[0];
        return t9 && CF(e13) === CF(t9) && bF(e13) === bF(t9);
    }
};
const { inferParserByLanguage: kF , getMaxContinuousCount: PF  } = Nt1, { builders: { hardline: OF , concat: IF , markAsRoot: LF  } , utils: { replaceNewlinesWithLiterallines: MF  }  } = rn1, { print: jF  } = XC, { getFencedCodeBlockValue: _F  } = NF;
var RF = function(e13, t9, n5, r4) {
    const o4 = e13.getValue();
    if ("code" === o4.type && null !== o4.lang) {
        const e14 = kF(o4.lang, r4);
        if (e14) {
            const t10 = r4.__inJsTemplate ? "~" : "`", u4 = t10.repeat(Math.max(3, PF(o4.value, t10) + 1)), i5 = n5(_F(o4, r4.originalText), {
                parser: e14
            }, {
                stripTrailingHardline: !0
            });
            return LF(IF([
                u4,
                o4.lang,
                o4.meta ? " " + o4.meta : "",
                OF,
                MF(i5),
                OF,
                u4
            ]));
        }
    }
    switch(o4.type){
        case "front-matter":
            return jF(o4, n5);
        case "importExport":
            return IF([
                n5(o4.value, {
                    parser: "babel"
                }, {
                    stripTrailingHardline: !0
                }),
                OF
            ]);
        case "jsx":
            return n5("<$>".concat(o4.value, "</$>"), {
                parser: "__js_expression",
                rootMarker: "mdx"
            }, {
                stripTrailingHardline: !0
            });
    }
    return null;
};
const { parse: VF  } = XC, $F = [
    "format",
    "prettier"
];
function qF(e13) {
    const t9 = "@(".concat($F.join("|"), ")"), n5 = new RegExp([
        "\x3c!--\\s*".concat(t9, "\\s*--\x3e"),
        "\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t9, "[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e")
    ].join("|"), "m"), r4 = e13.match(n5);
    return r4 && 0 === r4.index;
}
var WF = {
    startWithPragma: qF,
    hasPragma: (e13)=>qF(VF(e13).content.trimStart())
    ,
    insertPragma: (e13)=>{
        const t9 = VF(e13), n5 = "\x3c!-- @".concat($F[0], " --\x3e");
        return t9.frontMatter ? "".concat(t9.frontMatter.raw, "\n\n").concat(n5, "\n\n").concat(t9.content) : "".concat(n5, "\n\n").concat(t9.content);
    }
};
const { getOrderedListItemInfo: UF , mapAst: JF , splitText: zF  } = NF, GF = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;
function HF(e13, t9, n5) {
    return JF(e13, (e14)=>{
        if (!e14.children) return e14;
        const r4 = e14.children.reduce((e15, r5)=>{
            const o4 = e15[e15.length - 1];
            return o4 && t9(o4, r5) ? e15.splice(-1, 1, n5(o4, r5)) : e15.push(r5), e15;
        }, []);
        return Object.assign({
        }, e14, {
            children: r4
        });
    });
}
var XF = function(e13, t9) {
    return e13 = function(e14) {
        return HF(e14, (e15, t10)=>"importExport" === e15.type && "importExport" === t10.type
        , (e15, t10)=>({
                type: "importExport",
                value: e15.value + "\n\n" + t10.value,
                position: {
                    start: e15.position.start,
                    end: t10.position.end
                }
            })
        );
    }(e13 = function(e14) {
        return JF(e14, (e15)=>"import" !== e15.type && "export" !== e15.type ? e15 : Object.assign({
            }, e15, {
                type: "importExport"
            })
        );
    }(e13 = function(e14, t10) {
        return JF(e14, (e15, n5, [r4])=>{
            if ("text" !== e15.type) return e15;
            let { value: o4  } = e15;
            return "paragraph" === r4.type && (0 === n5 && (o4 = o4.trimStart()), n5 === r4.children.length - 1 && (o4 = o4.trimEnd())), {
                type: "sentence",
                position: e15.position,
                children: zF(o4, t10)
            };
        });
    }(e13 = function(e14, t10) {
        return JF(e14, (e15, t11, n5)=>{
            if ("list" === e15.type && 0 !== e15.children.length) {
                for(let t12 = 0; t12 < n5.length; t12++){
                    const r4 = n5[t12];
                    if ("list" === r4.type && !r4.isAligned) return e15.isAligned = !1, e15;
                }
                e15.isAligned = r4(e15);
            }
            return e15;
        });
        function n5(e15) {
            return 0 === e15.children.length ? -1 : e15.children[0].position.start.column - 1;
        }
        function r4(e15) {
            if (!e15.ordered) return !0;
            const [r5, o4] = e15.children;
            if (UF(r5, t10.originalText).leadingSpaces.length > 1) return !0;
            const u4 = n5(r5);
            if (-1 === u4) return !1;
            if (1 === e15.children.length) return u4 % t10.tabWidth == 0;
            if (u4 !== n5(o4)) return !1;
            if (u4 % t10.tabWidth == 0) return !0;
            return UF(o4, t10.originalText).leadingSpaces.length > 1;
        }
    }(e13 = function(e14, t10) {
        return JF(e14, (e15, n5, r4)=>{
            if ("code" === e15.type) {
                const n6 = /^\n?( {4,}|\t)/.test(t10.originalText.slice(e15.position.start.offset, e15.position.end.offset));
                if (e15.isIndented = n6, n6) for(let e16 = 0; e16 < r4.length; e16++){
                    const t11 = r4[e16];
                    if (t11.hasIndentedCodeblock) break;
                    "list" === t11.type && (t11.hasIndentedCodeblock = !0);
                }
            }
            return e15;
        });
    }(e13 = function(e14) {
        return JF(e14, (e15)=>"inlineCode" !== e15.type ? e15 : Object.assign({
            }, e15, {
                value: e15.value.replace(/\s+/g, " ")
            })
        );
    }(e13 = function(e14) {
        return HF(e14, (e15, t10)=>"text" === e15.type && "text" === t10.type
        , (e15, t10)=>({
                type: "text",
                value: e15.value + t10.value,
                position: {
                    start: e15.position.start,
                    end: t10.position.end
                }
            })
        );
    }(e13 = function(e14, t10) {
        return JF(e14, (e15)=>"text" === e15.type && "*" !== e15.value && "_" !== e15.value && GF.test(e15.value) && e15.position.end.offset - e15.position.start.offset !== e15.value.length ? Object.assign({
            }, e15, {
                value: t10.originalText.slice(e15.position.start.offset, e15.position.end.offset)
            }) : e15
        );
    }(e13, t9))), t9), t9), t9)));
};
const { isFrontMatterNode: YF  } = Nt1, { startWithPragma: KF  } = WF, QF = new Set([
    "position",
    "raw"
]);
function ZF(e13, t9, n5) {
    return "front-matter" !== e13.type && "code" !== e13.type && "yaml" !== e13.type && "import" !== e13.type && "export" !== e13.type && "jsx" !== e13.type || delete t9.value, "list" === e13.type && delete t9.isAligned, "list" !== e13.type && "listItem" !== e13.type || (delete t9.spread, delete t9.loose), "text" === e13.type ? null : ("inlineCode" === e13.type && (t9.value = e13.value.replace(/[\t\n ]+/g, " ")), "wikiLink" === e13.type && (t9.value = e13.value.trim().replace(/[\t\n]+/g, " ")), "definition" !== e13.type && "linkReference" !== e13.type || (t9.label = e13.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), "definition" !== e13.type && "link" !== e13.type && "image" !== e13.type || !e13.title || (t9.title = e13.title.replace(/\\(["')])/g, "$1")), n5 && "root" === n5.type && n5.children.length > 0 && (n5.children[0] === e13 || YF(n5.children[0]) && n5.children[1] === e13) && "html" === e13.type && KF(e13.value) ? null : void 0);
}
ZF.ignoredProperties = QF;
var ex = ZF;
const { getLast: tx , getMinNotPresentContinuousCount: nx , getMaxContinuousCount: rx , getStringWidth: ox  } = Nt1, { builders: { breakParent: ux , concat: ix , join: ax , line: sx , literalline: lx , markAsRoot: cx , hardline: px , softline: dx , ifBreak: fx , fill: hx , align: mx , indent: gx , group: Dx  } , utils: { normalizeDoc: yx  } , printer: { printDocToString: Ex  }  } = rn1, { replaceEndOfLineWith: Cx  } = Nt1, { insertPragma: bx  } = WF, { locStart: vx , locEnd: Ax  } = yF, { getFencedCodeBlockValue: Fx , hasGitDiffFriendlyOrderedList: xx , splitText: Sx , punctuationPattern: wx , INLINE_NODE_TYPES: Tx , INLINE_NODE_WRAPPER_TYPES: Bx , isAutolink: Nx  } = NF, kx = new Set([
    "importExport"
]), Px = [
    "heading",
    "tableCell",
    "link",
    "wikiLink"
], Ox = new Set([
    "listItem",
    "definition",
    "footnoteDefinition"
]);
function Ix(e13, t9, n5, r4) {
    const o4 = e13.getValue(), u4 = null === o4.checked ? "" : o4.checked ? "[x] " : "[ ] ";
    return ix([
        u4,
        Vx(e13, t9, n5, {
            processor: (e14, o5)=>{
                if (0 === o5 && "list" !== e14.getValue().type) return mx(" ".repeat(u4.length), e14.call(n5));
                const i5 = " ".repeat((a4 = t9.tabWidth - r4.length, l4 = 3, a4 < (s4 = 0) ? s4 : a4 > l4 ? l4 : a4));
                var a4, s4, l4;
                return ix([
                    i5,
                    mx(i5, e14.call(n5))
                ]);
            }
        })
    ]);
}
function _x(e13, t9, n5) {
    if ("preserve" === n5.proseWrap && "\n" === t9) return px;
    const r4 = "always" === n5.proseWrap && !jx(e13, Px);
    return "" !== t9 ? r4 ? sx : " " : r4 ? dx : "";
}
function Rx(e13, t9, n5) {
    const r4 = [];
    let o4 = null;
    const { children: u4  } = e13.getValue();
    return u4.forEach((e14, t10)=>{
        switch(qx(e14)){
            case "start":
                null === o4 && (o4 = {
                    index: t10,
                    offset: e14.position.end.offset
                });
                break;
            case "end":
                null !== o4 && (r4.push({
                    start: o4,
                    end: {
                        index: t10,
                        offset: e14.position.start.offset
                    }
                }), o4 = null);
        }
    }), Vx(e13, t9, n5, {
        processor: (e14, o5)=>{
            if (0 !== r4.length) {
                const e15 = r4[0];
                if (o5 === e15.start.index) return ix([
                    u4[e15.start.index].value,
                    t9.originalText.slice(e15.start.offset, e15.end.offset),
                    u4[e15.end.index].value
                ]);
                if (e15.start.index < o5 && o5 < e15.end.index) return !1;
                if (o5 === e15.end.index) return r4.shift(), !1;
            }
            return e14.call(n5);
        }
    });
}
function Vx(e13, t9, n5, r4) {
    const o4 = (r4 = r4 || {
    }).postprocessor || ix, u4 = r4.processor || ((e14)=>e14.call(n5)
    ), i5 = e13.getValue(), a4 = [];
    let s4;
    return e13.each((e14, n6)=>{
        const r5 = e14.getValue(), o5 = u4(e14, n6);
        if (!1 !== o5) {
            const e15 = {
                parts: a4,
                prevNode: s4,
                parentNode: i5,
                options: t9
            };
            (function(e16, t10) {
                const n7 = 0 === t10.parts.length, r6 = Tx.includes(e16.type), o6 = "html" === e16.type && Bx.includes(t10.parentNode.type);
                return n7 || r6 || o6;
            })(r5, e15) || (a4.push(px), s4 && kx.has(s4.type) || ((function(e16, t10) {
                const n7 = (t10.prevNode && t10.prevNode.type) === e16.type && Ox.has(e16.type), r6 = "listItem" === t10.parentNode.type && !t10.parentNode.loose, o6 = t10.prevNode && "listItem" === t10.prevNode.type && t10.prevNode.loose, u5 = "next" === qx(t10.prevNode), i6 = "html" === e16.type && t10.prevNode && "html" === t10.prevNode.type && t10.prevNode.position.end.line + 1 === e16.position.start.line, a5 = "html" === e16.type && "listItem" === t10.parentNode.type && t10.prevNode && "paragraph" === t10.prevNode.type && t10.prevNode.position.end.line + 1 === e16.position.start.line;
                return o6 || !(n7 || r6 || u5 || i6 || a5);
            })(r5, e15) || Wx(r5, e15)) && a4.push(px), Wx(r5, e15) && a4.push(px)), a4.push(o5), s4 = r5;
        }
    }, "children"), o4(a4);
}
var zx = {
    preprocess: XF,
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        if (function(e14) {
            const t10 = jx(e14, [
                "linkReference",
                "imageReference"
            ]);
            return t10 && ("linkReference" !== t10.type || "full" !== t10.referenceType);
        }(e13)) return ix(Sx(t9.originalText.slice(r4.position.start.offset, r4.position.end.offset), t9).map((n6)=>"word" === n6.type ? n6.value : "" === n6.value ? "" : _x(e13, n6.value, t9)
        ));
        switch(r4.type){
            case "front-matter":
                return t9.originalText.slice(r4.position.start.offset, r4.position.end.offset);
            case "root":
                return 0 === r4.children.length ? "" : ix([
                    yx(Rx(e13, t9, n5)),
                    kx.has($x(r4).type) ? "" : px
                ]);
            case "paragraph":
                return Vx(e13, t9, n5, {
                    postprocessor: hx
                });
            case "sentence":
                return Vx(e13, t9, n5);
            case "word":
                {
                    let t10 = r4.value.replace(/\*/g, "\\$&").replace(new RegExp([
                        "(^|".concat(wx, ")(_+)"),
                        "(_+)(".concat(wx, "|$)")
                    ].join("|"), "g"), (e14, t11, n6, r5, o4)=>(n6 ? "".concat(t11).concat(n6) : "".concat(r5).concat(o4)).replace(/_/g, "\\_")
                    );
                    const n6 = (e14, t11, n7)=>"sentence" === e14.type && 0 === n7
                    , o4 = (e14, t11, n7)=>Nx(e14.children[n7 - 1])
                    ;
                    return (t10 !== r4.value && (e13.match(void 0, n6, o4) || e13.match(void 0, n6, (e14, t11, n7)=>"emphasis" === e14.type && 0 === n7
                    , o4)) && (t10 = t10.replace(/^(\\?[*_])+/, (e14)=>e14.replace(/\\/g, "")
                    )), t10);
                }
            case "whitespace":
                {
                    const n6 = e13.getParentNode(), o4 = n6.children.indexOf(r4), u4 = n6.children[o4 + 1], i5 = u4 && /^>|^([*+-]|#{1,6}|\d+[).])$/.test(u4.value) ? "never" : t9.proseWrap;
                    return _x(e13, r4.value, {
                        proseWrap: i5
                    });
                }
            case "emphasis":
                {
                    let o4;
                    if (Nx(r4.children[0])) o4 = t9.originalText[r4.position.start.offset];
                    else {
                        const t10 = e13.getParentNode(), n6 = t10.children.indexOf(r4), u4 = t10.children[n6 - 1], i5 = t10.children[n6 + 1];
                        o4 = u4 && "sentence" === u4.type && u4.children.length > 0 && "word" === tx(u4.children).type && !tx(u4.children).hasTrailingPunctuation || i5 && "sentence" === i5.type && i5.children.length > 0 && "word" === i5.children[0].type && !i5.children[0].hasLeadingPunctuation || jx(e13, "emphasis") ? "*" : "_";
                    }
                    return ix([
                        o4,
                        Vx(e13, t9, n5),
                        o4
                    ]);
                }
            case "strong":
                return ix([
                    "**",
                    Vx(e13, t9, n5),
                    "**"
                ]);
            case "delete":
                return ix([
                    "~~",
                    Vx(e13, t9, n5),
                    "~~"
                ]);
            case "inlineCode":
                {
                    const e14 = nx(r4.value, "`"), t10 = "`".repeat(e14 || 1), n6 = e14 && !/^\s/.test(r4.value) ? " " : "";
                    return ix([
                        t10,
                        n6,
                        r4.value,
                        n6,
                        t10
                    ]);
                }
            case "wikiLink":
                {
                    let e14 = "";
                    return (e14 = "preserve" === t9.proseWrap ? r4.value : r4.value.replace(/[\t\n]+/g, " "), ix([
                        "[[",
                        e14,
                        "]]"
                    ]));
                }
            case "link":
                switch(t9.originalText[r4.position.start.offset]){
                    case "<":
                        {
                            const e14 = "mailto:", n6 = r4.url.startsWith(e14) && t9.originalText.slice(r4.position.start.offset + 1, r4.position.start.offset + 1 + e14.length) !== e14 ? r4.url.slice(e14.length) : r4.url;
                            return ix([
                                "<",
                                n6,
                                ">"
                            ]);
                        }
                    case "[":
                        return ix([
                            "[",
                            Vx(e13, t9, n5),
                            "](",
                            Ux(r4.url, ")"),
                            Jx(r4.title, t9),
                            ")"
                        ]);
                    default:
                        return t9.originalText.slice(r4.position.start.offset, r4.position.end.offset);
                }
            case "image":
                return ix([
                    "![",
                    r4.alt || "",
                    "](",
                    Ux(r4.url, ")"),
                    Jx(r4.title, t9),
                    ")"
                ]);
            case "blockquote":
                return ix([
                    "> ",
                    mx("> ", Vx(e13, t9, n5))
                ]);
            case "heading":
                return ix([
                    "#".repeat(r4.depth) + " ",
                    Vx(e13, t9, n5)
                ]);
            case "code":
                {
                    if (r4.isIndented) {
                        const e14 = " ".repeat(4);
                        return mx(e14, ix([
                            e14,
                            ix(Cx(r4.value, px))
                        ]));
                    }
                    const e14 = t9.__inJsTemplate ? "~" : "`", n6 = e14.repeat(Math.max(3, rx(r4.value, e14) + 1));
                    return ix([
                        n6,
                        r4.lang || "",
                        r4.meta ? " " + r4.meta : "",
                        px,
                        ix(Cx(Fx(r4, t9.originalText), px)),
                        px,
                        n6
                    ]);
                }
            case "html":
                {
                    const t10 = e13.getParentNode(), n6 = "root" === t10.type && tx(t10.children) === r4 ? r4.value.trimEnd() : r4.value, o4 = /^<!--[\S\s]*-->$/.test(n6);
                    return ix(Cx(n6, o4 ? px : cx(lx)));
                }
            case "list":
                {
                    const o4 = Lx(r4, e13.getParentNode()), u4 = xx(r4, t9);
                    return Vx(e13, t9, n5, {
                        processor: (e14, i5)=>{
                            const a4 = function() {
                                const e15 = r4.ordered ? (0 === i5 ? r4.start : u4 ? 1 : r4.start + i5) + (o4 % 2 == 0 ? ". " : ") ") : o4 % 2 == 0 ? "- " : "* ";
                                return r4.isAligned || r4.hasIndentedCodeblock ? (function(e16, t10) {
                                    const n6 = r5();
                                    return e16 + " ".repeat(n6 >= 4 ? 0 : n6);
                                    function r5() {
                                        const n7 = e16.length % t10.tabWidth;
                                        return 0 === n7 ? 0 : t10.tabWidth - n7;
                                    }
                                })(e15, t9) : e15;
                            }(), s4 = e14.getValue();
                            return 2 === s4.children.length && "html" === s4.children[1].type && s4.children[0].position.start.column !== s4.children[1].position.start.column ? ix([
                                a4,
                                Ix(e14, t9, n5, a4)
                            ]) : ix([
                                a4,
                                mx(" ".repeat(a4.length), Ix(e14, t9, n5, a4))
                            ]);
                        }
                    });
                }
            case "thematicBreak":
                {
                    const t10 = Mx(e13, "list");
                    if (-1 === t10) return "---";
                    return Lx(e13.getParentNode(t10), e13.getParentNode(t10 + 1)) % 2 == 0 ? "***" : "---";
                }
            case "linkReference":
                return ix([
                    "[",
                    Vx(e13, t9, n5),
                    "]",
                    "full" === r4.referenceType ? ix([
                        "[",
                        r4.identifier,
                        "]"
                    ]) : "collapsed" === r4.referenceType ? "[]" : ""
                ]);
            case "imageReference":
                switch(r4.referenceType){
                    case "full":
                        return ix([
                            "![",
                            r4.alt || "",
                            "][",
                            r4.identifier,
                            "]"
                        ]);
                    default:
                        return ix([
                            "![",
                            r4.alt,
                            "]",
                            "collapsed" === r4.referenceType ? "[]" : ""
                        ]);
                }
            case "definition":
                {
                    const e14 = "always" === t9.proseWrap ? sx : " ";
                    return Dx(ix([
                        ix([
                            "[",
                            r4.identifier,
                            "]:"
                        ]),
                        gx(ix([
                            e14,
                            Ux(r4.url),
                            null === r4.title ? "" : ix([
                                e14,
                                Jx(r4.title, t9, !1)
                            ])
                        ]))
                    ]));
                }
            case "footnote":
                return ix([
                    "[^",
                    Vx(e13, t9, n5),
                    "]"
                ]);
            case "footnoteReference":
                return ix([
                    "[^",
                    r4.identifier,
                    "]"
                ]);
            case "footnoteDefinition":
                {
                    const o4 = e13.getParentNode().children[e13.getName() + 1], u4 = 1 === r4.children.length && "paragraph" === r4.children[0].type && ("never" === t9.proseWrap || "preserve" === t9.proseWrap && r4.children[0].position.start.line === r4.children[0].position.end.line);
                    return ix([
                        "[^",
                        r4.identifier,
                        "]: ",
                        u4 ? Vx(e13, t9, n5) : Dx(ix([
                            mx(" ".repeat(4), Vx(e13, t9, n5, {
                                processor: (e14, t10)=>0 === t10 ? Dx(ix([
                                        dx,
                                        e14.call(n5)
                                    ])) : e14.call(n5)
                            })),
                            o4 && "footnoteDefinition" === o4.type ? dx : ""
                        ]))
                    ]);
                }
            case "table":
                return function(e14, t10, n6) {
                    const r5 = px.parts[0], o4 = e14.getValue(), u4 = [], i5 = e14.map((e15)=>e15.map((e16, r6)=>{
                            const o5 = Ex(e16.call(n6), t10).formatted, i6 = ox(o5);
                            return u4[r6] = Math.max(u4[r6] || 3, i6), {
                                text: o5,
                                width: i6
                            };
                        }, "children")
                    , "children"), a4 = l4(!1);
                    if ("never" !== t10.proseWrap) return ix([
                        ux,
                        a4
                    ]);
                    const s4 = l4(!0);
                    return ix([
                        ux,
                        Dx(fx(s4, a4))
                    ]);
                    function l4(e15) {
                        const t11 = [
                            p4(i5[0], e15),
                            c4(e15)
                        ];
                        return i5.length > 1 && t11.push(ax(r5, i5.slice(1).map((t12)=>p4(t12, e15)
                        ))), ax(r5, t11);
                    }
                    function c4(e15) {
                        const t11 = u4.map((t12, n7)=>{
                            const r6 = o4.align[n7], u5 = "center" === r6 || "left" === r6 ? ":" : "-", i6 = "center" === r6 || "right" === r6 ? ":" : "-", a5 = e15 ? "-" : "-".repeat(t12 - 2);
                            return "".concat(u5).concat(a5).concat(i6);
                        });
                        return "| ".concat(t11.join(" | "), " |");
                    }
                    function p4(e15, t11) {
                        const n7 = e15.map(({ text: e16 , width: n8  }, r6)=>{
                            if (t11) return e16;
                            const i6 = u4[r6] - n8, a5 = o4.align[r6];
                            let s5 = 0;
                            "right" === a5 ? s5 = i6 : "center" === a5 && (s5 = Math.floor(i6 / 2));
                            const l5 = i6 - s5;
                            return "".concat(" ".repeat(s5)).concat(e16).concat(" ".repeat(l5));
                        });
                        return "| ".concat(n7.join(" | "), " |");
                    }
                }(e13, t9, n5);
            case "tableCell":
                return Vx(e13, t9, n5);
            case "break":
                return /\s/.test(t9.originalText[r4.position.start.offset]) ? ix([
                    "  ",
                    cx(lx)
                ]) : ix([
                    "\\",
                    px
                ]);
            case "liquidNode":
                return ix(Cx(r4.value, px));
            case "importExport":
                return ix([
                    r4.value,
                    px
                ]);
            case "jsx":
                return r4.value;
            case "math":
                return ix([
                    "$$",
                    px,
                    r4.value ? ix([
                        ix(Cx(r4.value, px)),
                        px
                    ]) : "",
                    "$$"
                ]);
            case "inlineMath":
                return t9.originalText.slice(vx(r4), Ax(r4));
            case "tableRow":
            case "listItem":
            default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(r4.type)));
        }
    },
    embed: RF,
    massageAstNode: ex,
    hasPrettierIgnore: function(e13) {
        const t9 = +e13.getName();
        return 0 !== t9 && "next" === qx(e13.getParentNode().children[t9 - 1]);
    },
    insertPragma: bx
}, Gx = {
    proseWrap: kC.proseWrap,
    singleQuote: kC.singleQuote
}, Hx = {
    name: "Markdown",
    type: "prose",
    color: "#083fa1",
    aliases: [
        "pandoc"
    ],
    aceMode: "markdown",
    codemirrorMode: "gfm",
    codemirrorMimeType: "text/x-gfm",
    wrap: !0,
    extensions: [
        ".md",
        ".markdown",
        ".mdown",
        ".mdwn",
        ".mdx",
        ".mkd",
        ".mkdn",
        ".mkdown",
        ".ronn",
        ".workbook"
    ],
    filenames: [
        "contents.lr"
    ],
    tmScope: "source.gfm",
    languageId: 222
};
var Xx = {
    languages: [
        xs1(Hx, (e13)=>({
                since: "1.8.0",
                parsers: [
                    "markdown"
                ],
                vscodeLanguageIds: [
                    "markdown"
                ],
                filenames: e13.filenames.concat([
                    "README"
                ]),
                extensions: e13.extensions.filter((e14)=>".mdx" !== e14
                )
            })
        ),
        xs1(Hx, ()=>({
                name: "MDX",
                since: "1.15.0",
                parsers: [
                    "mdx"
                ],
                vscodeLanguageIds: [
                    "mdx"
                ],
                filenames: [],
                extensions: [
                    ".mdx"
                ]
            })
        )
    ],
    options: Gx,
    printers: {
        mdast: zx
    },
    parsers: {
        get remark () {
            return {
            }.parsers.remark;
        },
        get markdown () {
            return {
            }.parsers.remark;
        },
        get mdx () {
            return {
            }.parsers.mdx;
        }
    }
};
const { isFrontMatterNode: Yx  } = Nt1, Kx = new Set([
    "sourceSpan",
    "startSourceSpan",
    "endSourceSpan",
    "nameSpan",
    "valueSpan"
]);
function Qx(e13, t9) {
    return "text" === e13.type || "comment" === e13.type || Yx(e13) || "yaml" === e13.type || "toml" === e13.type ? null : ("attribute" === e13.type && delete t9.value, void ("docType" === e13.type && delete t9.value));
}
Qx.ignoredProperties = Kx;
var Zx = Qx, eS = {
    "*": [
        "accesskey",
        "autocapitalize",
        "autofocus",
        "class",
        "contenteditable",
        "dir",
        "draggable",
        "enterkeyhint",
        "hidden",
        "id",
        "inputmode",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemscope",
        "itemtype",
        "lang",
        "nonce",
        "slot",
        "spellcheck",
        "style",
        "tabindex",
        "title",
        "translate"
    ],
    a: [
        "accesskey",
        "charset",
        "coords",
        "download",
        "href",
        "hreflang",
        "name",
        "ping",
        "referrerpolicy",
        "rel",
        "rev",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    abbr: [
        "title"
    ],
    applet: [
        "align",
        "alt",
        "archive",
        "code",
        "codebase",
        "height",
        "hspace",
        "name",
        "object",
        "vspace",
        "width"
    ],
    area: [
        "accesskey",
        "alt",
        "coords",
        "download",
        "href",
        "hreflang",
        "nohref",
        "ping",
        "referrerpolicy",
        "rel",
        "shape",
        "tabindex",
        "target",
        "type"
    ],
    audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
    ],
    base: [
        "href",
        "target"
    ],
    basefont: [
        "color",
        "face",
        "size"
    ],
    bdo: [
        "dir"
    ],
    blockquote: [
        "cite"
    ],
    body: [
        "alink",
        "background",
        "bgcolor",
        "link",
        "text",
        "vlink"
    ],
    br: [
        "clear"
    ],
    button: [
        "accesskey",
        "autofocus",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "name",
        "tabindex",
        "type",
        "value"
    ],
    canvas: [
        "height",
        "width"
    ],
    caption: [
        "align"
    ],
    col: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    colgroup: [
        "align",
        "char",
        "charoff",
        "span",
        "valign",
        "width"
    ],
    data: [
        "value"
    ],
    del: [
        "cite",
        "datetime"
    ],
    details: [
        "open"
    ],
    dfn: [
        "title"
    ],
    dialog: [
        "open"
    ],
    dir: [
        "compact"
    ],
    div: [
        "align"
    ],
    dl: [
        "compact"
    ],
    embed: [
        "height",
        "src",
        "type",
        "width"
    ],
    fieldset: [
        "disabled",
        "form",
        "name"
    ],
    font: [
        "color",
        "face",
        "size"
    ],
    form: [
        "accept",
        "accept-charset",
        "action",
        "autocomplete",
        "enctype",
        "method",
        "name",
        "novalidate",
        "target"
    ],
    frame: [
        "frameborder",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "noresize",
        "scrolling",
        "src"
    ],
    frameset: [
        "cols",
        "rows"
    ],
    h1: [
        "align"
    ],
    h2: [
        "align"
    ],
    h3: [
        "align"
    ],
    h4: [
        "align"
    ],
    h5: [
        "align"
    ],
    h6: [
        "align"
    ],
    head: [
        "profile"
    ],
    hr: [
        "align",
        "noshade",
        "size",
        "width"
    ],
    html: [
        "manifest",
        "version"
    ],
    iframe: [
        "align",
        "allow",
        "allowfullscreen",
        "allowpaymentrequest",
        "allowusermedia",
        "frameborder",
        "height",
        "loading",
        "longdesc",
        "marginheight",
        "marginwidth",
        "name",
        "referrerpolicy",
        "sandbox",
        "scrolling",
        "src",
        "srcdoc",
        "width"
    ],
    img: [
        "align",
        "alt",
        "border",
        "crossorigin",
        "decoding",
        "height",
        "hspace",
        "ismap",
        "loading",
        "longdesc",
        "name",
        "referrerpolicy",
        "sizes",
        "src",
        "srcset",
        "usemap",
        "vspace",
        "width"
    ],
    input: [
        "accept",
        "accesskey",
        "align",
        "alt",
        "autocomplete",
        "autofocus",
        "checked",
        "dirname",
        "disabled",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formnovalidate",
        "formtarget",
        "height",
        "ismap",
        "list",
        "max",
        "maxlength",
        "min",
        "minlength",
        "multiple",
        "name",
        "pattern",
        "placeholder",
        "readonly",
        "required",
        "size",
        "src",
        "step",
        "tabindex",
        "title",
        "type",
        "usemap",
        "value",
        "width"
    ],
    ins: [
        "cite",
        "datetime"
    ],
    isindex: [
        "prompt"
    ],
    label: [
        "accesskey",
        "for",
        "form"
    ],
    legend: [
        "accesskey",
        "align"
    ],
    li: [
        "type",
        "value"
    ],
    link: [
        "as",
        "charset",
        "color",
        "crossorigin",
        "disabled",
        "href",
        "hreflang",
        "imagesizes",
        "imagesrcset",
        "integrity",
        "media",
        "nonce",
        "referrerpolicy",
        "rel",
        "rev",
        "sizes",
        "target",
        "title",
        "type"
    ],
    map: [
        "name"
    ],
    menu: [
        "compact"
    ],
    meta: [
        "charset",
        "content",
        "http-equiv",
        "name",
        "scheme"
    ],
    meter: [
        "high",
        "low",
        "max",
        "min",
        "optimum",
        "value"
    ],
    object: [
        "align",
        "archive",
        "border",
        "classid",
        "codebase",
        "codetype",
        "data",
        "declare",
        "form",
        "height",
        "hspace",
        "name",
        "standby",
        "tabindex",
        "type",
        "typemustmatch",
        "usemap",
        "vspace",
        "width"
    ],
    ol: [
        "compact",
        "reversed",
        "start",
        "type"
    ],
    optgroup: [
        "disabled",
        "label"
    ],
    option: [
        "disabled",
        "label",
        "selected",
        "value"
    ],
    output: [
        "for",
        "form",
        "name"
    ],
    p: [
        "align"
    ],
    param: [
        "name",
        "type",
        "value",
        "valuetype"
    ],
    pre: [
        "width"
    ],
    progress: [
        "max",
        "value"
    ],
    q: [
        "cite"
    ],
    script: [
        "async",
        "charset",
        "crossorigin",
        "defer",
        "integrity",
        "language",
        "nomodule",
        "nonce",
        "referrerpolicy",
        "src",
        "type"
    ],
    select: [
        "autocomplete",
        "autofocus",
        "disabled",
        "form",
        "multiple",
        "name",
        "required",
        "size",
        "tabindex"
    ],
    slot: [
        "name"
    ],
    source: [
        "media",
        "sizes",
        "src",
        "srcset",
        "type"
    ],
    style: [
        "media",
        "nonce",
        "title",
        "type"
    ],
    table: [
        "align",
        "bgcolor",
        "border",
        "cellpadding",
        "cellspacing",
        "frame",
        "rules",
        "summary",
        "width"
    ],
    tbody: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    td: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    textarea: [
        "accesskey",
        "autocomplete",
        "autofocus",
        "cols",
        "dirname",
        "disabled",
        "form",
        "maxlength",
        "minlength",
        "name",
        "placeholder",
        "readonly",
        "required",
        "rows",
        "tabindex",
        "wrap"
    ],
    tfoot: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    th: [
        "abbr",
        "align",
        "axis",
        "bgcolor",
        "char",
        "charoff",
        "colspan",
        "headers",
        "height",
        "nowrap",
        "rowspan",
        "scope",
        "valign",
        "width"
    ],
    thead: [
        "align",
        "char",
        "charoff",
        "valign"
    ],
    time: [
        "datetime"
    ],
    tr: [
        "align",
        "bgcolor",
        "char",
        "charoff",
        "valign"
    ],
    track: [
        "default",
        "kind",
        "label",
        "src",
        "srclang"
    ],
    ul: [
        "compact",
        "type"
    ],
    video: [
        "autoplay",
        "controls",
        "crossorigin",
        "height",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "width"
    ]
};
const { inferParserByLanguage: tS , isFrontMatterNode: nS  } = Nt1, { CSS_DISPLAY_TAGS: rS , CSS_DISPLAY_DEFAULT: oS , CSS_WHITE_SPACE_TAGS: uS , CSS_WHITE_SPACE_DEFAULT: iS  } = {
    CSS_DISPLAY_TAGS: {
        area: "none",
        base: "none",
        basefont: "none",
        datalist: "none",
        head: "none",
        link: "none",
        meta: "none",
        noembed: "none",
        noframes: "none",
        param: "block",
        rp: "none",
        script: "block",
        source: "block",
        style: "none",
        template: "inline",
        track: "block",
        title: "none",
        html: "block",
        body: "block",
        address: "block",
        blockquote: "block",
        center: "block",
        div: "block",
        figure: "block",
        figcaption: "block",
        footer: "block",
        form: "block",
        header: "block",
        hr: "block",
        legend: "block",
        listing: "block",
        main: "block",
        p: "block",
        plaintext: "block",
        pre: "block",
        xmp: "block",
        slot: "contents",
        ruby: "ruby",
        rt: "ruby-text",
        article: "block",
        aside: "block",
        h1: "block",
        h2: "block",
        h3: "block",
        h4: "block",
        h5: "block",
        h6: "block",
        hgroup: "block",
        nav: "block",
        section: "block",
        dir: "block",
        dd: "block",
        dl: "block",
        dt: "block",
        ol: "block",
        ul: "block",
        li: "list-item",
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell",
        fieldset: "block",
        button: "inline-block",
        details: "block",
        summary: "block",
        dialog: "block",
        meter: "inline-block",
        progress: "inline-block",
        object: "inline-block",
        video: "inline-block",
        audio: "inline-block",
        select: "inline-block",
        option: "block",
        optgroup: "block"
    },
    CSS_DISPLAY_DEFAULT: "inline",
    CSS_WHITE_SPACE_TAGS: {
        listing: "pre",
        plaintext: "pre",
        pre: "pre",
        xmp: "pre",
        nobr: "nowrap",
        table: "initial",
        textarea: "pre-wrap"
    },
    CSS_WHITE_SPACE_DEFAULT: "normal"
}, aS = dS([
    "a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "command",
    "content",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "image",
    "img",
    "input",
    "ins",
    "isindex",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "math",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "multicol",
    "nav",
    "nextid",
    "nobr",
    "noembed",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "plaintext",
    "pre",
    "progress",
    "q",
    "rb",
    "rbc",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "slot",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "svg",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp"
]), sS = function(e13, t9) {
    const n5 = Object.create(null);
    for (const r4 of Object.keys(e13))n5[r4] = t9(e13[r4], r4);
    return n5;
}(eS, dS), lS = new Set([
    "\t",
    "\n",
    "\f",
    "\r",
    " "
]), cS = (e13)=>e13.replace(/[\t\n\f\r ]+$/, "")
, pS = (e13)=>e13.match(/^[\t\n\f\r ]*/)[0]
;
function fS(e13, t9) {
    return !("ieConditionalComment" !== e13.type || !e13.lastChild || e13.lastChild.isSelfClosing || e13.lastChild.endSourceSpan) || ("ieConditionalComment" === e13.type && !e13.complete || (!(!xS(e13) || !e13.children.some((e14)=>"text" !== e14.type && "interpolation" !== e14.type
    )) || !(!kS(e13, t9) || mS(e13) || "interpolation" === e13.type)));
}
function gS(e13) {
    return wS(e13).startsWith("pre");
}
function xS(e13) {
    return wS(e13).startsWith("pre");
}
function wS(e13) {
    return "element" === e13.type && (!e13.namespace || SS(e13)) && uS[e13.name] || iS;
}
var PS = {
    HTML_ELEMENT_ATTRIBUTES: sS,
    HTML_TAGS: aS,
    htmlTrim: (e13)=>((e14)=>e14.replace(/^[\t\n\f\r ]+/, "")
        )(cS(e13))
    ,
    htmlTrimPreserveIndentation: (e13)=>((e14)=>e14.replace(/^[\t\f\r ]*?\n/g, "")
        )(cS(e13))
    ,
    splitByHtmlWhitespace: (e13)=>e13.split(/[\t\n\f\r ]+/)
    ,
    hasHtmlWhitespace: (e13)=>/[\t\n\f\r ]/.test(e13)
    ,
    getLeadingAndTrailingHtmlWhitespace: (e13)=>{
        const [, t9, n5, r4] = e13.match(/^([\t\n\f\r ]*)([\S\s]*?)([\t\n\f\r ]*)$/);
        return {
            leadingWhitespace: t9,
            trailingWhitespace: r4,
            text: n5
        };
    },
    canHaveInterpolation: function(e13) {
        return e13.children && !mS(e13);
    },
    countChars: function(e13, t9) {
        let n5 = 0;
        for(let r4 = 0; r4 < e13.length; r4++)e13[r4] === t9 && n5++;
        return n5;
    },
    countParents: function(e13, t9) {
        let n5 = 0;
        for(let r4 = e13.stack.length - 1; r4 >= 0; r4--){
            const o4 = e13.stack[r4];
            o4 && "object" == typeof o4 && !Array.isArray(o4) && t9(o4) && n5++;
        }
        return n5;
    },
    dedentString: function(e13, t9 = function(e14) {
        let t10 = 1 / 0;
        for (const n5 of e14.split("\n")){
            if (0 === n5.length) continue;
            if (!lS.has(n5[0])) return 0;
            const e15 = pS(n5).length;
            n5.length !== e15 && e15 < t10 && (t10 = e15);
        }
        return t10 === 1 / 0 ? 0 : t10;
    }(e13)) {
        return 0 === t9 ? e13 : e13.split("\n").map((e14)=>e14.slice(t9)
        ).join("\n");
    },
    forceBreakChildren: DS,
    forceBreakContent: function(e13) {
        return DS(e13) || "element" === e13.type && 0 !== e13.children.length && ([
            "body",
            "script",
            "style"
        ].includes(e13.name) || e13.children.some((e14)=>(function(e15) {
                return e15.children && e15.children.some((e16)=>"text" !== e16.type
                );
            })(e14)
        )) || e13.firstChild && e13.firstChild === e13.lastChild && "text" !== e13.firstChild.type && CS(e13.firstChild) && (!e13.lastChild.isTrailingSpaceSensitive || bS(e13.lastChild));
    },
    forceNextEmptyLine: function(e13) {
        return nS(e13) || e13.next && e13.sourceSpan.end && e13.sourceSpan.end.line + 1 < e13.next.sourceSpan.start.line;
    },
    getLastDescendant: function e13(t9) {
        return t9.lastChild ? e13(t9.lastChild) : t9;
    },
    getNodeCssStyleDisplay: function(e14, t9) {
        if (e14.prev && "comment" === e14.prev.type) {
            const t10 = e14.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t10) return t10[1];
        }
        let n5 = !1;
        if ("element" === e14.type && "svg" === e14.namespace) {
            if (!function(e15, t10) {
                let n6 = e15;
                for(; n6;){
                    if (t10(n6)) return !0;
                    n6 = n6.parent;
                }
                return !1;
            }(e14, (e15)=>"svg:foreignObject" === e15.fullName
            )) return "svg" === e14.name ? "inline-block" : "block";
            n5 = !0;
        }
        switch(t9.htmlWhitespaceSensitivity){
            case "strict":
                return "inline";
            case "ignore":
                return "block";
            default:
                return "vue" === t9.parser && e14.parent && "root" === e14.parent.type ? "block" : "element" === e14.type && (!e14.namespace || n5 || SS(e14)) && rS[e14.name] || oS;
        }
    },
    getNodeCssStyleWhiteSpace: wS,
    getPrettierIgnoreAttributeCommentData: function(e14) {
        const t9 = e14.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);
        return !!t9 && (!t9[1] || t9[1].split(/\s+/));
    },
    hasPrettierIgnore: hS,
    inferScriptParser: function(e14, t9) {
        return "script" !== e14.name || e14.attrMap.src ? "style" === e14.name ? function(e15) {
            const { lang: t10  } = e15.attrMap;
            return t10 && "postcss" !== t10 && "css" !== t10 ? "scss" === t10 ? "scss" : "less" === t10 ? "less" : void 0 : "css";
        }(e14) : t9 && kS(e14, t9) ? AS(e14) || !("src" in e14.attrMap) && tS(e14.attrMap.lang, t9) : void 0 : e14.attrMap.lang || e14.attrMap.type ? AS(e14) : "babel";
    },
    isVueCustomBlock: BS,
    isVueNonHtmlBlock: kS,
    isVueSlotAttribute: function(e14) {
        const t9 = e14.fullName;
        return "#" === t9.charAt(0) || "slot-scope" === t9 || "v-slot" === t9 || t9.startsWith("v-slot:");
    },
    isVueSfcBindingsAttribute: function(e14, t9) {
        const n5 = e14.parent;
        if (!NS(n5, t9)) return !1;
        const r4 = n5.fullName, o4 = e14.fullName;
        return "script" === r4 && "setup" === o4 || "style" === r4 && "vars" === o4;
    },
    isDanglingSpaceSensitiveNode: function(e14) {
        return !(t9 = e14.cssDisplay, FS(t9) || "inline-block" === t9 || mS(e14));
        var t9;
    },
    isIndentationSensitiveNode: gS,
    isLeadingSpaceSensitiveNode: function(e14, t9) {
        const n5 = function() {
            if (nS(e14)) return !1;
            if (("text" === e14.type || "interpolation" === e14.type) && e14.prev && ("text" === e14.prev.type || "interpolation" === e14.prev.type)) return !0;
            if (!e14.parent || "none" === e14.parent.cssDisplay) return !1;
            if (xS(e14.parent)) return !0;
            if (!e14.prev && ("root" === e14.parent.type || xS(e14) && e14.parent || mS(e14.parent) || BS(e14.parent, t9) || (n5 = e14.parent.cssDisplay, FS(n5) || "inline-block" === n5))) return !1;
            var n5;
            if (e14.prev && !(function(e15) {
                return !FS(e15);
            })(e14.prev.cssDisplay)) return !1;
            return !0;
        }();
        return n5 && !e14.prev && e14.parent && e14.parent.tagDefinition && e14.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e14.type : n5;
    },
    isPreLikeNode: xS,
    isScriptLikeTag: mS,
    isTextLikeNode: function(e14) {
        return "text" === e14.type || "comment" === e14.type;
    },
    isTrailingSpaceSensitiveNode: function(e14, t9) {
        return !nS(e14) && (!("text" !== e14.type && "interpolation" !== e14.type || !e14.next || "text" !== e14.next.type && "interpolation" !== e14.next.type) || !(!e14.parent || "none" === e14.parent.cssDisplay) && (!!xS(e14.parent) || !(!e14.next && ("root" === e14.parent.type || xS(e14) && e14.parent || mS(e14.parent) || BS(e14.parent, t9) || (n5 = e14.parent.cssDisplay, FS(n5) || "inline-block" === n5))) && !(e14.next && !function(e15) {
            return !FS(e15);
        }(e14.next.cssDisplay))));
        var n5;
    },
    isWhitespaceSensitiveNode: function(e14) {
        return mS(e14) || "interpolation" === e14.type || gS(e14);
    },
    isUnknownNamespace: SS,
    preferHardlineAsLeadingSpaces: function(e14) {
        return vS(e14) || e14.prev && yS(e14.prev) || ES(e14);
    },
    preferHardlineAsTrailingSpaces: yS,
    shouldNotPrintClosingTag: function(e14, t9) {
        return !e14.isSelfClosing && !e14.endSourceSpan && (hS(e14) || fS(e14.parent, t9));
    },
    shouldPreserveContent: fS,
    unescapeQuoteEntities: function(e14) {
        return e14.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
}, OS = je(function(e13, t9) {
    function n5(e14) {
        return t9.$0 <= e14 && e14 <= t9.$9;
    }
    Object.defineProperty(t9, "__esModule", {
        value: !0
    }), t9.$EOF = 0, t9.$BSPACE = 8, t9.$TAB = 9, t9.$LF = 10, t9.$VTAB = 11, t9.$FF = 12, t9.$CR = 13, t9.$SPACE = 32, t9.$BANG = 33, t9.$DQ = 34, t9.$HASH = 35, t9.$$ = 36, t9.$PERCENT = 37, t9.$AMPERSAND = 38, t9.$SQ = 39, t9.$LPAREN = 40, t9.$RPAREN = 41, t9.$STAR = 42, t9.$PLUS = 43, t9.$COMMA = 44, t9.$MINUS = 45, t9.$PERIOD = 46, t9.$SLASH = 47, t9.$COLON = 58, t9.$SEMICOLON = 59, t9.$LT = 60, t9.$EQ = 61, t9.$GT = 62, t9.$QUESTION = 63, t9.$0 = 48, t9.$7 = 55, t9.$9 = 57, t9.$A = 65, t9.$E = 69, t9.$F = 70, t9.$X = 88, t9.$Z = 90, t9.$LBRACKET = 91, t9.$BACKSLASH = 92, t9.$RBRACKET = 93, t9.$CARET = 94, t9.$_ = 95, t9.$a = 97, t9.$b = 98, t9.$e = 101, t9.$f = 102, t9.$n = 110, t9.$r = 114, t9.$t = 116, t9.$u = 117, t9.$v = 118, t9.$x = 120, t9.$z = 122, t9.$LBRACE = 123, t9.$BAR = 124, t9.$RBRACE = 125, t9.$NBSP = 160, t9.$PIPE = 124, t9.$TILDA = 126, t9.$AT = 64, t9.$BT = 96, t9.isWhitespace = function(e14) {
        return e14 >= t9.$TAB && e14 <= t9.$SPACE || e14 == t9.$NBSP;
    }, t9.isDigit = n5, t9.isAsciiLetter = function(e14) {
        return e14 >= t9.$a && e14 <= t9.$z || e14 >= t9.$A && e14 <= t9.$Z;
    }, t9.isAsciiHexDigit = function(e14) {
        return e14 >= t9.$a && e14 <= t9.$f || e14 >= t9.$A && e14 <= t9.$F || n5(e14);
    }, t9.isNewLine = function(e14) {
        return e14 === t9.$LF || e14 === t9.$CR;
    }, t9.isOctalDigit = function(e14) {
        return t9.$0 <= e14 && e14 <= t9.$7;
    };
}), IS = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    });
    class n5 {
        constructor(e14, t10, n6){
            this.filePath = e14, this.name = t10, this.members = n6;
        }
        assertNoMembers() {
            if (this.members.length) throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
        }
    }
    t9.StaticSymbol = n5;
    t9.StaticSymbolCache = class {
        constructor(){
            this.cache = new Map;
        }
        get(e, t, r) {
            const o4 = (r = r || []).length ? ".".concat(r.join(".")) : "", u4 = '"'.concat(e, '".').concat(t).concat(o4);
            let i5 = this.cache.get(u4);
            return i5 || (i5 = new n5(e, t, r), this.cache.set(u4, i5)), i5;
        }
    };
}), LS = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    });
    const n5 = /-+([a-z0-9])/g;
    function r4(e14, t10, n6) {
        const r5 = e14.indexOf(t10);
        return -1 == r5 ? n6 : [
            e14.slice(0, r5).trim(),
            e14.slice(r5 + 1).trim()
        ];
    }
    function o4(e14, t10, n6) {
        return Array.isArray(e14) ? t10.visitArray(e14, n6) : "object" == typeof (r5 = e14) && null !== r5 && Object.getPrototypeOf(r5) === a4 ? t10.visitStringMap(e14, n6) : null == e14 || "string" == typeof e14 || "number" == typeof e14 || "boolean" == typeof e14 ? t10.visitPrimitive(e14, n6) : t10.visitOther(e14, n6);
        var r5;
    }
    t9.dashCaseToCamelCase = function(e14) {
        return e14.replace(n5, (...e15)=>e15[1].toUpperCase()
        );
    }, t9.splitAtColon = function(e14, t10) {
        return r4(e14, ":", t10);
    }, t9.splitAtPeriod = function(e14, t10) {
        return r4(e14, ".", t10);
    }, t9.visitValue = o4, t9.isDefined = function(e14) {
        return null != e14;
    }, t9.noUndefined = function(e14) {
        return (void 0) === e14 ? null : e14;
    };
    t9.ValueTransformer = class {
        visitArray(e, t) {
            return e.map((e14)=>o4(e14, this, t)
            );
        }
        visitStringMap(e, t) {
            const n6 = {
            };
            return Object.keys(e).forEach((r5)=>{
                n6[r5] = o4(e[r5], this, t);
            }), n6;
        }
        visitPrimitive(e, t) {
            return e;
        }
        visitOther(e, t) {
            return e;
        }
    }, t9.SyncAsync = {
        assertSync: (e14)=>{
            if (s4(e14)) throw new Error("Illegal state: value cannot be a promise");
            return e14;
        },
        then: (e14, t10)=>s4(e14) ? e14.then(t10) : t10(e14)
        ,
        all: (e14)=>e14.some(s4) ? Promise.all(e14) : e14
    }, t9.error = function(e14) {
        throw new Error("Internal Error: ".concat(e14));
    }, t9.syntaxError = function(e14, t10) {
        const n6 = Error(e14);
        return n6[u4] = !0, t10 && (n6[i5] = t10), n6;
    };
    const u4 = "ngSyntaxError", i5 = "ngParseErrors";
    t9.isSyntaxError = function(e14) {
        return e14[u4];
    }, t9.getParseErrors = function(e14) {
        return e14[i5] || [];
    }, t9.escapeRegExp = function(e14) {
        return e14.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    };
    const a4 = Object.getPrototypeOf({
    });
    function s4(e14) {
        return !!e14 && "function" == typeof e14.then;
    }
    t9.utf8Encode = function(e14) {
        let t10 = "";
        for(let n6 = 0; n6 < e14.length; n6++){
            let r5 = e14.charCodeAt(n6);
            if (r5 >= 55296 && r5 <= 56319 && e14.length > n6 + 1) {
                const t11 = e14.charCodeAt(n6 + 1);
                t11 >= 56320 && t11 <= 57343 && (n6++, r5 = (r5 - 55296 << 10) + t11 - 56320 + 65536);
            }
            r5 <= 127 ? t10 += String.fromCharCode(r5) : r5 <= 2047 ? t10 += String.fromCharCode(r5 >> 6 & 31 | 192, 63 & r5 | 128) : r5 <= 65535 ? t10 += String.fromCharCode(r5 >> 12 | 224, r5 >> 6 & 63 | 128, 63 & r5 | 128) : r5 <= 2097151 && (t10 += String.fromCharCode(r5 >> 18 & 7 | 240, r5 >> 12 & 63 | 128, r5 >> 6 & 63 | 128, 63 & r5 | 128));
        }
        return t10;
    }, t9.stringify = function e13(t10) {
        if ("string" == typeof t10) return t10;
        if (t10 instanceof Array) return "[" + t10.map(e13).join(", ") + "]";
        if (null == t10) return "" + t10;
        if (t10.overriddenName) return "".concat(t10.overriddenName);
        if (t10.name) return "".concat(t10.name);
        if (!t10.toString) return "object";
        const n6 = t10.toString();
        if (null == n6) return "" + n6;
        const r5 = n6.indexOf("\n");
        return -1 === r5 ? n6 : n6.substring(0, r5);
    }, t9.resolveForwardRef = function(e14) {
        return "function" == typeof e14 && e14.hasOwnProperty("__forward_ref__") ? e14() : e14;
    }, t9.isPromise = s4;
    t9.Version = class {
        constructor(e14){
            this.full = e14;
            const t10 = e14.split(".");
            this.major = t10[0], this.minor = t10[1], this.patch = t10.slice(2).join(".");
        }
    };
    const l4 = "undefined" != typeof window && window, c4 = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, p4 = (void 0) !== Me && Me || l4 || c4;
    t9.global = p4;
}), MS = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    });
    const n5 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function r4(e14) {
        return e14.replace(/\W/g, "_");
    }
    t9.sanitizeIdentifier = r4;
    let o4 = 0;
    function u4(e14) {
        if (!e14 || !e14.reference) return null;
        const t10 = e14.reference;
        if (t10 instanceof IS.StaticSymbol) return t10.name;
        if (t10.__anonymousType) return t10.__anonymousType;
        let n6 = LS.stringify(t10);
        return (n6.indexOf("(") >= 0 ? (n6 = "anonymous_".concat(o4++), t10.__anonymousType = n6) : n6 = r4(n6), n6);
    }
    var i5;
    t9.identifierName = u4, t9.identifierModuleUrl = function(e14) {
        const t10 = e14.reference;
        return t10 instanceof IS.StaticSymbol ? t10.filePath : "./".concat(LS.stringify(t10));
    }, t9.viewClassName = function(e14, t10) {
        return "View_".concat(u4({
            reference: e14
        }), "_").concat(t10);
    }, t9.rendererTypeName = function(e14) {
        return "RenderType_".concat(u4({
            reference: e14
        }));
    }, t9.hostViewClassName = function(e14) {
        return "HostView_".concat(u4({
            reference: e14
        }));
    }, t9.componentFactoryName = function(e14) {
        return "".concat(u4({
            reference: e14
        }), "NgFactory");
    }, (function(e14) {
        e14[e14.Pipe = 0] = "Pipe", e14[e14.Directive = 1] = "Directive", e14[e14.NgModule = 2] = "NgModule", e14[e14.Injectable = 3] = "Injectable";
    })(i5 = t9.CompileSummaryKind || (t9.CompileSummaryKind = {
    })), t9.tokenName = function(e14) {
        return null != e14.value ? r4(e14.value) : u4(e14.identifier);
    }, t9.tokenReference = function(e14) {
        return null != e14.identifier ? e14.identifier.reference : e14.value;
    };
    t9.CompileStylesheetMetadata = class {
        constructor({ moduleUrl: e14 , styles: t10 , styleUrls: n6  } = {
        }){
            this.moduleUrl = e14 || null, this.styles = s4(t10), this.styleUrls = s4(n6);
        }
    };
    t9.CompileTemplateMetadata = class {
        constructor({ encapsulation: e15 , template: t11 , templateUrl: n7 , htmlAst: r5 , styles: o5 , styleUrls: u5 , externalStylesheets: i6 , animations: a4 , ngContentSelectors: c4 , interpolation: p4 , isInline: d4 , preserveWhitespaces: f4  }){
            if (this.encapsulation = e15, this.template = t11, this.templateUrl = n7, this.htmlAst = r5, this.styles = s4(o5), this.styleUrls = s4(u5), this.externalStylesheets = s4(i6), this.animations = a4 ? l6(a4) : [], this.ngContentSelectors = c4 || [], p4 && 2 != p4.length) throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = p4, this.isInline = d4, this.preserveWhitespaces = f4;
        }
        toSummary() {
            return {
                ngContentSelectors: this.ngContentSelectors,
                encapsulation: this.encapsulation,
                styles: this.styles,
                animations: this.animations
            };
        }
    };
    class a5 {
        static create({ isHost: e , type: t , isComponent: r , selector: o , exportAs: u , changeDetection: i , inputs: s , outputs: l , host: c , providers: p , viewProviders: d , queries: f , guards: h , viewQueries: m , entryComponents: g , template: D , componentViewType: y , rendererType: E , componentFactory: C  }) {
            const b3 = {
            }, v3 = {
            }, A3 = {
            };
            null != c && Object.keys(c).forEach((e16)=>{
                const t12 = c[e16], r6 = e16.match(n5);
                null === r6 ? A3[e16] = t12 : null != r6[1] ? v3[r6[1]] = t12 : null != r6[2] && (b3[r6[2]] = t12);
            });
            const F3 = {
            };
            null != s && s.forEach((e16)=>{
                const t12 = LS.splitAtColon(e16, [
                    e16,
                    e16
                ]);
                F3[t12[0]] = t12[1];
            });
            const x2 = {
            };
            return null != l && l.forEach((e16)=>{
                const t12 = LS.splitAtColon(e16, [
                    e16,
                    e16
                ]);
                x2[t12[0]] = t12[1];
            }), new a5({
                isHost: e,
                type: t,
                isComponent: !!r,
                selector: o,
                exportAs: u,
                changeDetection: i,
                inputs: F3,
                outputs: x2,
                hostListeners: b3,
                hostProperties: v3,
                hostAttributes: A3,
                providers: p,
                viewProviders: d,
                queries: f,
                guards: h,
                viewQueries: m,
                entryComponents: g,
                template: D,
                componentViewType: y,
                rendererType: E,
                componentFactory: C
            });
        }
        constructor({ isHost: e16 , type: t12 , isComponent: n8 , selector: r6 , exportAs: o6 , changeDetection: u6 , inputs: i7 , outputs: a6 , hostListeners: l4 , hostProperties: c5 , hostAttributes: p5 , providers: d5 , viewProviders: f5 , queries: h4 , guards: m4 , viewQueries: g4 , entryComponents: D4 , template: y4 , componentViewType: E4 , rendererType: C3 , componentFactory: b3  }){
            this.isHost = !!e16, this.type = t12, this.isComponent = n8, this.selector = r6, this.exportAs = o6, this.changeDetection = u6, this.inputs = i7, this.outputs = a6, this.hostListeners = l4, this.hostProperties = c5, this.hostAttributes = p5, this.providers = s4(d5), this.viewProviders = s4(f5), this.queries = s4(h4), this.guards = m4, this.viewQueries = s4(g4), this.entryComponents = s4(D4), this.template = y4, this.componentViewType = E4, this.rendererType = C3, this.componentFactory = b3;
        }
        toSummary() {
            return {
                summaryKind: i5.Directive,
                type: this.type,
                isComponent: this.isComponent,
                selector: this.selector,
                exportAs: this.exportAs,
                inputs: this.inputs,
                outputs: this.outputs,
                hostListeners: this.hostListeners,
                hostProperties: this.hostProperties,
                hostAttributes: this.hostAttributes,
                providers: this.providers,
                viewProviders: this.viewProviders,
                queries: this.queries,
                guards: this.guards,
                viewQueries: this.viewQueries,
                entryComponents: this.entryComponents,
                changeDetection: this.changeDetection,
                template: this.template && this.template.toSummary(),
                componentViewType: this.componentViewType,
                rendererType: this.rendererType,
                componentFactory: this.componentFactory
            };
        }
    }
    t9.CompileDirectiveMetadata = a5;
    t9.CompilePipeMetadata = class {
        constructor({ type: e17 , name: t13 , pure: n9  }){
            this.type = e17, this.name = t13, this.pure = !!n9;
        }
        toSummary() {
            return {
                summaryKind: i5.Pipe,
                type: this.type,
                name: this.name,
                pure: this.pure
            };
        }
    };
    t9.CompileShallowModuleMetadata = class {
    };
    t9.CompileNgModuleMetadata = class {
        constructor({ type: e18 , providers: t14 , declaredDirectives: n10 , exportedDirectives: r7 , declaredPipes: o7 , exportedPipes: u7 , entryComponents: i8 , bootstrapComponents: a7 , importedModules: l5 , exportedModules: c6 , schemas: p6 , transitiveModule: d6 , id: f6  }){
            this.type = e18 || null, this.declaredDirectives = s4(n10), this.exportedDirectives = s4(r7), this.declaredPipes = s4(o7), this.exportedPipes = s4(u7), this.providers = s4(t14), this.entryComponents = s4(i8), this.bootstrapComponents = s4(a7), this.importedModules = s4(l5), this.exportedModules = s4(c6), this.schemas = s4(p6), this.id = f6 || null, this.transitiveModule = d6 || null;
        }
        toSummary() {
            const e19 = this.transitiveModule;
            return {
                summaryKind: i5.NgModule,
                type: this.type,
                entryComponents: e19.entryComponents,
                providers: e19.providers,
                modules: e19.modules,
                exportedDirectives: e19.exportedDirectives,
                exportedPipes: e19.exportedPipes
            };
        }
    };
    function s4(e19) {
        return e19 || [];
    }
    t9.TransitiveCompileNgModuleMetadata = class {
        constructor(){
            this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = [];
        }
        addProvider(e, t) {
            this.providers.push({
                provider: e,
                module: t
            });
        }
        addDirective(e) {
            this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e));
        }
        addExportedDirective(e) {
            this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e));
        }
        addPipe(e) {
            this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e));
        }
        addExportedPipe(e) {
            this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e));
        }
        addModule(e) {
            this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e));
        }
        addEntryComponent(e) {
            this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e));
        }
    };
    function l6(e19) {
        return e19.reduce((e20, t15)=>{
            const n11 = Array.isArray(t15) ? l6(t15) : t15;
            return e20.concat(n11);
        }, []);
    }
    function c7(e19) {
        return e19.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    t9.ProviderMeta = class {
        constructor(e19, { useClass: t15 , useValue: n11 , useExisting: r8 , useFactory: o8 , deps: u8 , multi: i9  }){
            this.token = e19, this.useClass = t15 || null, this.useValue = n11, this.useExisting = r8, this.useFactory = o8 || null, this.dependencies = u8 || null, this.multi = !!i9;
        }
    }, t9.flatten = l6, t9.templateSourceUrl = function(e20, t16, n12) {
        let r9;
        return r9 = n12.isInline ? t16.type.reference instanceof IS.StaticSymbol ? "".concat(t16.type.reference.filePath, ".").concat(t16.type.reference.name, ".html") : "".concat(u4(e20), "/").concat(u4(t16.type), ".html") : n12.templateUrl, t16.type.reference instanceof IS.StaticSymbol ? r9 : c7(r9);
    }, t9.sharedStylesheetJitUrl = function(e20, t16) {
        const n12 = e20.moduleUrl.split(/\/\\/g), r9 = n12[n12.length - 1];
        return c7("css/".concat(t16).concat(r9, ".ngstyle.js"));
    }, t9.ngModuleJitUrl = function(e20) {
        return c7("".concat(u4(e20.type), "/module.ngfactory.js"));
    }, t9.templateJitUrl = function(e20, t16) {
        return c7("".concat(u4(e20), "/").concat(u4(t16.type), ".ngfactory.js"));
    };
}), jS = je(function(e13, t9) {
    Object.defineProperty(t9, "__esModule", {
        value: !0
    });
    class n5 {
        constructor(e14, t10, n6, r4){
            this.file = e14, this.offset = t10, this.line = n6, this.col = r4;
        }
        toString() {
            return null != this.offset ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
        }
        moveBy(e) {
            const t11 = this.file.content, r5 = t11.length;
            let o4 = this.offset, u4 = this.line, i5 = this.col;
            for(; o4 > 0 && e < 0;){
                o4--, e++;
                if (t11.charCodeAt(o4) == OS.$LF) {
                    u4--;
                    const e15 = t11.substr(0, o4 - 1).lastIndexOf(String.fromCharCode(OS.$LF));
                    i5 = e15 > 0 ? o4 - e15 : o4;
                } else i5--;
            }
            for(; o4 < r5 && e > 0;){
                const n7 = t11.charCodeAt(o4);
                o4++, e--, n7 == OS.$LF ? (u4++, i5 = 0) : i5++;
            }
            return new n5(this.file, o4, u4, i5);
        }
        getContext(e, t) {
            const n7 = this.file.content;
            let r5 = this.offset;
            if (null != r5) {
                r5 > n7.length - 1 && (r5 = n7.length - 1);
                let o4 = r5, u4 = 0, i5 = 0;
                for(; u4 < e && r5 > 0 && (r5--, u4++, "\n" != n7[r5] || (++i5) != t););
                for(u4 = 0, i5 = 0; u4 < e && o4 < n7.length - 1 && (o4++, u4++, "\n" != n7[o4] || (++i5) != t););
                return {
                    before: n7.substring(r5, this.offset),
                    after: n7.substring(this.offset, o4 + 1)
                };
            }
            return null;
        }
    }
    t9.ParseLocation = n5;
    class r5 {
        constructor(e15, t11){
            this.content = e15, this.url = t11;
        }
    }
    t9.ParseSourceFile = r5;
    class o4 {
        constructor(e16, t12, n7 = null){
            this.start = e16, this.end = t12, this.details = n7;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var u4;
    t9.ParseSourceSpan = o4, t9.EMPTY_PARSE_LOCATION = new n5(new r5("", ""), 0, 0, 0), t9.EMPTY_SOURCE_SPAN = new o4(t9.EMPTY_PARSE_LOCATION, t9.EMPTY_PARSE_LOCATION), (function(e17) {
        e17[e17.WARNING = 0] = "WARNING", e17[e17.ERROR = 1] = "ERROR";
    })(u4 = t9.ParseErrorLevel || (t9.ParseErrorLevel = {
    }));
    t9.ParseError = class {
        constructor(e17, t13, n8 = u4.ERROR){
            this.span = e17, this.msg = t13, this.level = n8;
        }
        contextualMessage() {
            const e18 = this.span.start.getContext(100, 3);
            return e18 ? "".concat(this.msg, ' ("').concat(e18.before, "[").concat(u4[this.level], " ->]").concat(e18.after, '")') : this.msg;
        }
        toString() {
            const e18 = this.span.details ? ", ".concat(this.span.details) : "";
            return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(e18);
        }
    }, t9.typeSourceSpan = function(e18, t14) {
        const u5 = MS.identifierModuleUrl(t14), i5 = null != u5 ? "in ".concat(e18, " ").concat(MS.identifierName(t14), " in ").concat(u5) : "in ".concat(e18, " ").concat(MS.identifierName(t14)), a4 = new r5("", i5);
        return new o4(new n5(a4, -1, -1, -1), new n5(a4, -1, -1, -1));
    }, t9.r3JitTypeSourceSpan = function(e18, t14, u5) {
        const i5 = "in ".concat(e18, " ").concat(t14, " in ").concat(u5), a4 = new r5("", i5);
        return new o4(new n5(a4, -1, -1, -1), new n5(a4, -1, -1, -1));
    };
});
const { ParseSourceSpan: _S  } = jS, { htmlTrim: RS , getLeadingAndTrailingHtmlWhitespace: VS , hasHtmlWhitespace: $S , canHaveInterpolation: qS , getNodeCssStyleDisplay: WS , isDanglingSpaceSensitiveNode: US , isIndentationSensitiveNode: JS , isLeadingSpaceSensitiveNode: zS , isTrailingSpaceSensitiveNode: GS , isWhitespaceSensitiveNode: HS  } = PS, XS = [
    function(e13) {
        return e13.map((e14)=>{
            if ("element" === e14.type && e14.tagDefinition.ignoreFirstLf && 0 !== e14.children.length && "text" === e14.children[0].type && "\n" === e14.children[0].value[0]) {
                const [t9, ...n5] = e14.children;
                return e14.clone({
                    children: 1 === t9.value.length ? n5 : [
                        t9.clone({
                            value: t9.value.slice(1)
                        }),
                        ...n5
                    ]
                });
            }
            return e14;
        });
    },
    function(e13) {
        const t9 = (e14)=>"element" === e14.type && e14.prev && "ieConditionalStartComment" === e14.prev.type && e14.prev.sourceSpan.end.offset === e14.startSourceSpan.start.offset && e14.firstChild && "ieConditionalEndComment" === e14.firstChild.type && e14.firstChild.sourceSpan.start.offset === e14.startSourceSpan.end.offset
        ;
        return e13.map((e14)=>{
            if (e14.children) {
                const n5 = e14.children.map(t9);
                if (n5.some(Boolean)) {
                    const t10 = [];
                    for(let r4 = 0; r4 < e14.children.length; r4++){
                        const o4 = e14.children[r4];
                        if (!n5[r4 + 1]) {
                            if (n5[r4]) {
                                const e15 = o4.prev, n6 = o4.firstChild, r5 = new _S(e15.sourceSpan.start, n6.sourceSpan.end), u4 = new _S(r5.start, o4.sourceSpan.end);
                                t10.push(o4.clone({
                                    condition: e15.condition,
                                    sourceSpan: u4,
                                    startSourceSpan: r5,
                                    children: o4.children.slice(1)
                                }));
                            } else t10.push(o4);
                        }
                    }
                    return e14.clone({
                        children: t10
                    });
                }
            }
            return e14;
        });
    },
    function(e13) {
        return function(e14, t9, n5) {
            return e14.map((e15)=>{
                if (e15.children) {
                    const r4 = e15.children.map(t9);
                    if (r4.some(Boolean)) {
                        const t10 = [];
                        for(let o4 = 0; o4 < e15.children.length; o4++){
                            const u4 = e15.children[o4];
                            if ("text" !== u4.type && !r4[o4]) {
                                t10.push(u4);
                                continue;
                            }
                            const i5 = "text" === u4.type ? u4 : u4.clone({
                                type: "text",
                                value: n5(u4)
                            });
                            if (0 === t10.length || "text" !== t10[t10.length - 1].type) {
                                t10.push(i5);
                                continue;
                            }
                            const a4 = t10.pop();
                            t10.push(a4.clone({
                                value: a4.value + i5.value,
                                sourceSpan: new _S(a4.sourceSpan.start, i5.sourceSpan.end)
                            }));
                        }
                        return e15.clone({
                            children: t10
                        });
                    }
                }
                return e15;
            });
        }(e13, (e14)=>"cdata" === e14.type
        , (e14)=>"<![CDATA[".concat(e14.value, "]]>")
        );
    },
    function(e13, t9) {
        if ("html" === t9.parser) return e13;
        const n5 = /{{([\S\s]+?)}}/g;
        return e13.map((e14)=>{
            if (!qS(e14)) return e14;
            const t10 = [];
            for (const r4 of e14.children){
                if ("text" !== r4.type) {
                    t10.push(r4);
                    continue;
                }
                let e15 = r4.sourceSpan.start, o4 = null;
                const u4 = r4.value.split(n5);
                for(let n6 = 0; n6 < u4.length; n6++, e15 = o4){
                    const r5 = u4[n6];
                    n6 % 2 != 0 ? (o4 = e15.moveBy(r5.length + 4), t10.push({
                        type: "interpolation",
                        sourceSpan: new _S(e15, o4),
                        children: 0 === r5.length ? [] : [
                            {
                                type: "text",
                                value: r5,
                                sourceSpan: new _S(e15.moveBy(2), o4.moveBy(-2))
                            }
                        ]
                    })) : (o4 = e15.moveBy(r5.length), 0 !== r5.length && t10.push({
                        type: "text",
                        value: r5,
                        sourceSpan: new _S(e15, o4)
                    }));
                }
            }
            return e14.clone({
                children: t10
            });
        });
    },
    function(e13) {
        const t9 = "whitespace";
        return e13.map((e14)=>{
            if (!e14.children) return e14;
            if (0 === e14.children.length || 1 === e14.children.length && "text" === e14.children[0].type && 0 === RS(e14.children[0].value).length) return e14.clone({
                children: [],
                hasDanglingSpaces: 0 !== e14.children.length
            });
            const n5 = HS(e14), r4 = JS(e14);
            return e14.clone({
                isWhitespaceSensitive: n5,
                isIndentationSensitive: r4,
                children: e14.children.reduce((e15, r5)=>{
                    if ("text" !== r5.type || n5) return e15.concat(r5);
                    const o4 = [], { leadingWhitespace: u4 , text: i5 , trailingWhitespace: a4  } = VS(r5.value);
                    return u4 && o4.push({
                        type: t9
                    }), i5 && o4.push({
                        type: "text",
                        value: i5,
                        sourceSpan: new _S(r5.sourceSpan.start.moveBy(u4.length), r5.sourceSpan.end.moveBy(-a4.length))
                    }), a4 && o4.push({
                        type: t9
                    }), e15.concat(o4);
                }, []).reduce((e15, n6, r5, o4)=>{
                    if (n6.type === t9) return e15;
                    const u4 = 0 !== r5 && o4[r5 - 1].type === t9, i5 = r5 !== o4.length - 1 && o4[r5 + 1].type === t9;
                    return e15.concat(Object.assign({
                    }, n6, {
                        hasLeadingSpaces: u4,
                        hasTrailingSpaces: i5
                    }));
                }, [])
            });
        });
    },
    function(e13, t9) {
        return e13.map((e14)=>Object.assign(e14, {
                cssDisplay: WS(e14, t9)
            })
        );
    },
    function(e13) {
        return e13.map((e14)=>Object.assign(e14, {
                isSelfClosing: !e14.children || "element" === e14.type && (e14.tagDefinition.isVoid || e14.startSourceSpan === e14.endSourceSpan)
            })
        );
    },
    function(e13, t9) {
        return e13.map((e14)=>"element" !== e14.type ? e14 : Object.assign(e14, {
                hasHtmComponentClosingTag: e14.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t9.originalText.slice(e14.endSourceSpan.start.offset, e14.endSourceSpan.end.offset))
            })
        );
    },
    function(e13, t9) {
        return e13.map((e14)=>e14.children ? 0 === e14.children.length ? e14.clone({
                isDanglingSpaceSensitive: US(e14)
            }) : e14.clone({
                children: e14.children.map((e15)=>Object.assign({
                    }, e15, {
                        isLeadingSpaceSensitive: zS(e15, t9),
                        isTrailingSpaceSensitive: GS(e15, t9)
                    })
                ).map((e15, t10, n5)=>Object.assign({
                    }, e15, {
                        isLeadingSpaceSensitive: (0 === t10 || n5[t10 - 1].isTrailingSpaceSensitive) && e15.isLeadingSpaceSensitive,
                        isTrailingSpaceSensitive: (t10 === n5.length - 1 || n5[t10 + 1].isLeadingSpaceSensitive) && e15.isTrailingSpaceSensitive
                    })
                )
            }) : e14
        );
    },
    function(e13) {
        const t9 = (e14)=>"element" === e14.type && 0 === e14.attrs.length && 1 === e14.children.length && "text" === e14.firstChild.type && !$S(e14.children[0].value) && !e14.firstChild.hasLeadingSpaces && !e14.firstChild.hasTrailingSpaces && e14.isLeadingSpaceSensitive && !e14.hasLeadingSpaces && e14.isTrailingSpaceSensitive && !e14.hasTrailingSpaces && e14.prev && "text" === e14.prev.type && e14.next && "text" === e14.next.type
        ;
        return e13.map((e14)=>{
            if (e14.children) {
                const n5 = e14.children.map(t9);
                if (n5.some(Boolean)) {
                    const t10 = [];
                    for(let r4 = 0; r4 < e14.children.length; r4++){
                        const o4 = e14.children[r4];
                        if (n5[r4]) {
                            const n6 = t10.pop(), u4 = e14.children[++r4], { isTrailingSpaceSensitive: i5 , hasTrailingSpaces: a4  } = u4;
                            t10.push(n6.clone({
                                value: n6.value + "<".concat(o4.rawName, ">") + o4.firstChild.value + "</".concat(o4.rawName, ">") + u4.value,
                                sourceSpan: new _S(n6.sourceSpan.start, u4.sourceSpan.end),
                                isTrailingSpaceSensitive: i5,
                                hasTrailingSpaces: a4
                            }));
                        } else t10.push(o4);
                    }
                    return e14.clone({
                        children: t10
                    });
                }
            }
            return e14;
        });
    }
];
var YS = function(e13, t9) {
    for (const n5 of XS)e13 = n5(e13, t9);
    return e13;
};
const { builders: { concat: ZS , group: ew  }  } = rn1;
var tw = {
    isVueEventBindingExpression: function(e13) {
        const t9 = e13.trim();
        return /^([\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t9) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t9);
    },
    printVueFor: function(e13, t9) {
        const { left: n5 , operator: r4 , right: o4  } = function(e14) {
            const t10 = /([^]*?)\s+(in|of)\s+([^]*)/, n6 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r5 = /^\(|\)$/g, o5 = e14.match(t10);
            if (!o5) return;
            const u4 = {
            };
            u4.for = o5[3].trim();
            const i5 = o5[1].trim().replace(r5, ""), a4 = i5.match(n6);
            a4 ? (u4.alias = i5.replace(n6, ""), u4.iterator1 = a4[1].trim(), a4[2] && (u4.iterator2 = a4[2].trim())) : u4.alias = i5;
            return {
                left: "".concat([
                    u4.alias,
                    u4.iterator1,
                    u4.iterator2
                ].filter(Boolean).join(",")),
                operator: o5[2],
                right: u4.for
            };
        }(e13);
        return ZS([
            ew(t9("function _(".concat(n5, ") {}"), {
                parser: "babel",
                __isVueForBindingLeft: !0
            })),
            " ",
            r4,
            " ",
            t9(o4, {
                parser: "__js_expression"
            }, {
                stripTrailingHardline: !0
            })
        ]);
    },
    printVueBindings: function(e13, t9) {
        return t9("function _(".concat(e13, ") {}"), {
            parser: "babel",
            __isVueBindings: !0
        }, {
            stripTrailingHardline: !0
        });
    }
}, nw = je(function(e13) {
    !(function(t9, n5) {
        e13.exports ? e13.exports = n5() : t9.parseSrcset = n5();
    })(Me, function() {
        return function(e14, t9) {
            var n5 = t9 && t9.logger || console;
            function r4(e15) {
                return " " === e15 || "\t" === e15 || "\n" === e15 || "\f" === e15 || "\r" === e15;
            }
            function o4(t10) {
                var n6, r5 = t10.exec(e14.substring(D4));
                if (r5) return (n6 = r5[0], D4 += n6.length, n6);
            }
            for(var u4, i5, a4, s4, l4, c4 = e14.length, p4 = /^[ \t\n\r\u000c]+/, d4 = /^[, \t\n\r\u000c]+/, f4 = /^[^ \t\n\r\u000c]+/, h4 = /[,]+$/, m4 = /^\d+$/, g4 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D4 = 0, y4 = [];;){
                if ((o4(d4), D4 >= c4)) return y4;
                u4 = o4(f4), i5 = [], "," === u4.slice(-1) ? (u4 = u4.replace(h4, ""), C3()) : E4();
            }
            function E4() {
                for((o4(p4), a4 = "", s4 = "in descriptor");;){
                    if ((l4 = e14.charAt(D4), "in descriptor" === s4)) {
                        if (r4(l4)) a4 && (i5.push(a4), a4 = "", s4 = "after descriptor");
                        else {
                            if ("," === l4) return (D4 += 1, a4 && i5.push(a4), void C3());
                            if ("(" === l4) a4 += l4, s4 = "in parens";
                            else {
                                if ("" === l4) return (a4 && i5.push(a4), void C3());
                                a4 += l4;
                            }
                        }
                    } else if ("in parens" === s4) {
                        if (")" === l4) a4 += l4, s4 = "in descriptor";
                        else {
                            if ("" === l4) return (i5.push(a4), void C3());
                            a4 += l4;
                        }
                    } else if ("after descriptor" === s4) {
                        if (r4(l4)) ;
                        else {
                            if ("" === l4) return void C3();
                            s4 = "in descriptor", D4 -= 1;
                        }
                    }
                    D4 += 1;
                }
            }
            function C3() {
                var t10, r5, o5, a5, s5, l5, c5, p5, d5, f5 = !1, h5 = {
                };
                for(a5 = 0; a5 < i5.length; a5++)l5 = (s5 = i5[a5])[s5.length - 1], c5 = s5.substring(0, s5.length - 1), p5 = parseInt(c5, 10), d5 = parseFloat(c5), m4.test(c5) && "w" === l5 ? ((t10 || r5) && (f5 = !0), 0 === p5 ? f5 = !0 : t10 = p5) : g4.test(c5) && "x" === l5 ? ((t10 || r5 || o5) && (f5 = !0), d5 < 0 ? f5 = !0 : r5 = d5) : m4.test(c5) && "h" === l5 ? ((o5 || r5) && (f5 = !0), 0 === p5 ? f5 = !0 : o5 = p5) : f5 = !0;
                f5 ? n5 && n5.error && n5.error("Invalid srcset descriptor found in '" + e14 + "' at '" + s5 + "'.") : (h5.url = u4, t10 && (h5.w = t10), r5 && (h5.d = r5), o5 && (h5.h = o5), y4.push(h5));
            }
        };
    });
});
const { builders: { concat: rw , ifBreak: ow , join: uw , line: iw  }  } = rn1;
var aw = {
    printImgSrcset: function(e13) {
        const t9 = nw(e13, {
            logger: {
                error (e) {
                    throw new Error(e);
                }
            }
        }), n5 = t9.some(({ w: e14  })=>e14
        ), r4 = t9.some(({ h: e14  })=>e14
        );
        if (n5 + r4 + t9.some(({ d: e14  })=>e14
        ) > 1) throw new Error("Mixed descriptor in srcset is not supported");
        const o4 = n5 ? "w" : r4 ? "h" : "d", u4 = n5 ? "w" : r4 ? "h" : "x", i5 = (e14)=>Math.max(...e14)
        , a4 = t9.map((e14)=>e14.url
        ), s4 = i5(a4.map((e14)=>e14.length
        )), l4 = t9.map((e14)=>e14[o4]
        ).map((e14)=>e14 ? e14.toString() : ""
        ), c4 = l4.map((e14)=>{
            const t10 = e14.indexOf(".");
            return -1 === t10 ? e14.length : t10;
        }), p4 = i5(c4);
        return uw(rw([
            ",",
            iw
        ]), a4.map((e14, t10)=>{
            const n6 = [
                e14
            ], r5 = l4[t10];
            if (r5) {
                const o5 = s4 - e14.length + 1, i6 = p4 - c4[t10], a5 = " ".repeat(o5 + i6);
                n6.push(ow(a5, " "), r5 + u4);
            }
            return rw(n6);
        }));
    },
    printClassNames: function(e13) {
        return e13.trim().split(/\s+/).join(" ");
    }
};
const { builders: sw , utils: { mapDoc: lw , normalizeParts: cw  }  } = rn1, { replaceEndOfLineWith: pw  } = Nt1, { print: dw  } = XC, { breakParent: fw , dedentToRoot: hw , fill: mw , group: gw , hardline: Dw , ifBreak: yw , indent: Ew , join: Cw , line: bw , literalline: vw , softline: Aw  } = sw, { htmlTrimPreserveIndentation: Fw , splitByHtmlWhitespace: xw , countChars: Sw , countParents: ww , dedentString: Tw , forceBreakChildren: Bw , forceBreakContent: Nw , forceNextEmptyLine: kw , getLastDescendant: Pw , getPrettierIgnoreAttributeCommentData: Ow , hasPrettierIgnore: Iw , inferScriptParser: Lw , isVueCustomBlock: Mw , isVueNonHtmlBlock: jw , isVueSlotAttribute: _w , isVueSfcBindingsAttribute: Rw , isScriptLikeTag: Vw , isTextLikeNode: $w , preferHardlineAsLeadingSpaces: qw , shouldNotPrintClosingTag: Ww , shouldPreserveContent: Uw , unescapeQuoteEntities: Jw , isPreLikeNode: zw  } = PS, { insertPragma: Gw  } = KS, { locStart: Hw , locEnd: Xw  } = QS, { printVueFor: Yw , printVueBindings: Kw , isVueEventBindingExpression: Qw  } = tw, { printImgSrcset: Zw , printClassNames: eT  } = aw;
function tT(e13) {
    const t9 = cw(e13);
    return 0 === t9.length ? "" : 1 === t9.length ? t9[0] : sw.concat(t9);
}
function nT(e13, t9, n5) {
    const r4 = e13.getValue();
    if (Bw(r4)) return tT([
        fw,
        tT(e13.map((e14)=>{
            const t10 = e14.getValue(), n6 = t10.prev ? i5(t10.prev, t10) : "";
            return tT([
                n6 ? tT([
                    n6,
                    kw(t10.prev) ? Dw : ""
                ]) : "",
                u4(e14)
            ]);
        }, "children"))
    ]);
    const o4 = r4.children.map(()=>Symbol("")
    );
    return tT(e13.map((e14, t10)=>{
        const n6 = e14.getValue();
        if ($w(n6)) {
            if (n6.prev && $w(n6.prev)) {
                const t11 = i5(n6.prev, n6);
                if (t11) return kw(n6.prev) ? tT([
                    Dw,
                    Dw,
                    u4(e14)
                ]) : tT([
                    t11,
                    u4(e14)
                ]);
            }
            return u4(e14);
        }
        const r5 = [], a4 = [], s4 = [], l4 = [], c4 = n6.prev ? i5(n6.prev, n6) : "", p4 = n6.next ? i5(n6, n6.next) : "";
        return c4 && (kw(n6.prev) ? r5.push(Dw, Dw) : c4 === Dw ? r5.push(Dw) : $w(n6.prev) ? a4.push(c4) : a4.push(yw("", Aw, {
            groupId: o4[t10 - 1]
        }))), p4 && (kw(n6) ? $w(n6.next) && l4.push(Dw, Dw) : p4 === Dw ? $w(n6.next) && l4.push(Dw) : s4.push(p4)), tT([].concat(r5, gw(tT([
            tT(a4),
            gw(tT([
                u4(e14),
                tT(s4)
            ]), {
                id: o4[t10]
            })
        ])), l4));
    }, "children"));
    function u4(e14) {
        const r5 = e14.getValue();
        return Iw(r5) ? tT([].concat(gT(r5, t9), pw(t9.originalText.slice(Hw(r5) + (r5.prev && pT(r5.prev) ? ET(r5).length : 0), Xw(r5) - (r5.next && fT(r5.next) ? vT(r5, t9).length : 0)), vw), yT(r5, t9))) : n5(e14);
    }
    function i5(e14, t10) {
        return $w(e14) && $w(t10) ? e14.isTrailingSpaceSensitive ? e14.hasTrailingSpaces ? qw(t10) ? Dw : bw : "" : qw(t10) ? Dw : Aw : pT(e14) && (Iw(t10) || t10.firstChild || t10.isSelfClosing || "element" === t10.type && 0 !== t10.attrs.length) || "element" === e14.type && e14.isSelfClosing && fT(t10) ? "" : !t10.isLeadingSpaceSensitive || qw(t10) || fT(t10) && e14.lastChild && mT(e14.lastChild) && e14.lastChild.lastChild && mT(e14.lastChild.lastChild) ? Dw : t10.hasLeadingSpaces ? bw : Aw;
    }
}
function rT(e13, t9) {
    let n5 = e13.startSourceSpan.end.offset;
    e13.firstChild && dT(e13.firstChild) && (n5 -= CT(e13).length);
    let r4 = e13.endSourceSpan.start.offset;
    return e13.lastChild && mT(e13.lastChild) ? r4 += bT(e13, t9).length : hT(e13) && (r4 -= vT(e13.lastChild, t9).length), t9.originalText.slice(n5, r4);
}
function oT(e13, t9, n5) {
    const r4 = e13.getValue();
    if (!r4.attrs || 0 === r4.attrs.length) return r4.isSelfClosing ? " " : "";
    const o4 = r4.prev && "comment" === r4.prev.type && Ow(r4.prev.value), u4 = "boolean" == typeof o4 ? ()=>o4
     : Array.isArray(o4) ? (e14)=>o4.includes(e14.rawName)
     : ()=>!1
    , i5 = e13.map((e14)=>{
        const r5 = e14.getValue();
        return u4(r5) ? tT(pw(t9.originalText.slice(Hw(r5), Xw(r5)), vw)) : n5(e14);
    }, "attrs"), a4 = "element" === r4.type && "script" === r4.fullName && 1 === r4.attrs.length && "src" === r4.attrs[0].fullName && 0 === r4.children.length, s4 = [
        Ew(tT([
            a4 ? " " : bw,
            Cw(bw, i5)
        ]))
    ];
    return r4.firstChild && dT(r4.firstChild) || r4.isSelfClosing && hT(r4.parent) || a4 ? s4.push(r4.isSelfClosing ? " " : "") : s4.push(r4.isSelfClosing ? bw : Aw), tT(s4);
}
function uT(e13, t9, n5) {
    const r4 = e13.getValue();
    return tT([
        iT(r4, t9),
        oT(e13, t9, n5),
        r4.isSelfClosing ? "" : aT(r4)
    ]);
}
function iT(e13, t9) {
    return e13.prev && pT(e13.prev) ? "" : tT([
        gT(e13, t9),
        ET(e13)
    ]);
}
function sT(e13, t9) {
    return tT([
        e13.isSelfClosing ? "" : lT(e13, t9),
        cT(e13, t9)
    ]);
}
function lT(e13, t9) {
    return e13.lastChild && mT(e13.lastChild) ? "" : tT([
        DT(e13, t9),
        bT(e13, t9)
    ]);
}
function cT(e13, t9) {
    return (e13.next ? fT(e13.next) : hT(e13.parent)) ? "" : tT([
        vT(e13, t9),
        yT(e13, t9)
    ]);
}
function pT(e13) {
    return e13.next && !$w(e13.next) && $w(e13) && e13.isTrailingSpaceSensitive && !e13.hasTrailingSpaces;
}
function fT(e13) {
    return e13.prev && "docType" !== e13.prev.type && !$w(e13.prev) && e13.isLeadingSpaceSensitive && !e13.hasLeadingSpaces;
}
function hT(e13) {
    return e13.lastChild && e13.lastChild.isTrailingSpaceSensitive && !e13.lastChild.hasTrailingSpaces && !$w(Pw(e13.lastChild)) && !zw(e13);
}
function mT(e13) {
    return !e13.next && !e13.hasTrailingSpaces && e13.isTrailingSpaceSensitive && $w(Pw(e13));
}
function gT(e13, t9) {
    return dT(e13) ? CT(e13.parent) : fT(e13) ? vT(e13.prev, t9) : "";
}
function DT(e13, t9) {
    return hT(e13) ? vT(e13.lastChild, t9) : "";
}
function yT(e13, t9) {
    return mT(e13) ? bT(e13.parent, t9) : pT(e13) ? ET(e13.next) : "";
}
function bT(e13, t9) {
    if (Xi(!e13.isSelfClosing), Ww(e13, t9)) return "";
    switch(e13.type){
        case "ieConditionalComment":
            return "<!";
        case "element":
            if (e13.hasHtmComponentClosingTag) return "<//";
        default:
            return "</".concat(e13.rawName);
    }
}
function vT(e13, t9) {
    if (Ww(e13, t9)) return "";
    switch(e13.type){
        case "ieConditionalComment":
        case "ieConditionalEndComment":
            return "[endif]--\x3e";
        case "ieConditionalStartComment":
            return "]>\x3c!--\x3e";
        case "interpolation":
            return "}}";
        case "element":
            if (e13.isSelfClosing) return "/>";
        default:
            return ">";
    }
}
function AT(e13, t9 = e13.value) {
    return e13.parent.isWhitespaceSensitive ? e13.parent.isIndentationSensitive ? pw(t9, vw) : pw(Tw(Fw(t9)), Dw) : Cw(bw, xw(t9)).parts;
}
var FT = {
    preprocess: YS,
    print: function(e13, t9, n5) {
        const r4 = e13.getValue();
        switch(r4.type){
            case "front-matter":
                return tT(pw(r4.raw, vw));
            case "root":
                return (t9.__onHtmlRoot && t9.__onHtmlRoot(r4), sw.concat([
                    gw(nT(e13, t9, n5)),
                    Dw
                ]));
            case "element":
            case "ieConditionalComment":
                {
                    if (Uw(r4, t9)) return tT([].concat(gT(r4, t9), gw(uT(e13, t9, n5)), pw(rT(r4, t9), vw), sT(r4, t9), yT(r4, t9)));
                    const u4 = 1 === r4.children.length && "interpolation" === r4.firstChild.type && r4.firstChild.isLeadingSpaceSensitive && !r4.firstChild.hasLeadingSpaces && r4.lastChild.isTrailingSpaceSensitive && !r4.lastChild.hasTrailingSpaces, i5 = Symbol("element-attr-group-id");
                    return tT([
                        gw(tT([
                            gw(uT(e13, t9, n5), {
                                id: i5
                            }),
                            0 === r4.children.length ? r4.hasDanglingSpaces && r4.isDanglingSpaceSensitive ? bw : "" : tT([
                                Nw(r4) ? fw : "",
                                (o4 = tT([
                                    u4 ? yw(Aw, "", {
                                        groupId: i5
                                    }) : r4.firstChild.hasLeadingSpaces && r4.firstChild.isLeadingSpaceSensitive ? bw : "text" === r4.firstChild.type && r4.isWhitespaceSensitive && r4.isIndentationSensitive ? hw(Aw) : Aw,
                                    nT(e13, t9, n5)
                                ]), u4 ? yw(Ew(o4), o4, {
                                    groupId: i5
                                }) : !Vw(r4) && !Mw(r4, t9) || "root" !== r4.parent.type || "vue" !== t9.parser || t9.vueIndentScriptAndStyle ? Ew(o4) : o4),
                                (r4.next ? fT(r4.next) : hT(r4.parent)) ? r4.lastChild.hasTrailingSpaces && r4.lastChild.isTrailingSpaceSensitive ? " " : "" : u4 ? yw(Aw, "", {
                                    groupId: i5
                                }) : r4.lastChild.hasTrailingSpaces && r4.lastChild.isTrailingSpaceSensitive ? bw : ("comment" === r4.lastChild.type || "text" === r4.lastChild.type && r4.isWhitespaceSensitive && r4.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(t9.tabWidth * ww(e13, (e14)=>e14.parent && "root" !== e14.parent.type
                                ), "}$")).test(r4.lastChild.value) ? "" : Aw
                            ])
                        ])),
                        sT(r4, t9)
                    ]);
                }
            case "ieConditionalStartComment":
            case "ieConditionalEndComment":
                return tT([
                    iT(r4),
                    cT(r4)
                ]);
            case "interpolation":
                return tT([
                    iT(r4, t9),
                    tT(e13.map(n5, "children")),
                    cT(r4, t9)
                ]);
            case "text":
                if ("interpolation" === r4.parent.type) {
                    const e14 = /\n[^\S\n]*?$/, t10 = e14.test(r4.value), n6 = t10 ? r4.value.replace(e14, "") : r4.value;
                    return tT([
                        tT(pw(n6, vw)),
                        t10 ? Dw : ""
                    ]);
                }
                return mw(cw([].concat(gT(r4, t9), AT(r4), yT(r4, t9))));
            case "docType":
                return tT([
                    gw(tT([
                        iT(r4, t9),
                        " ",
                        r4.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")
                    ])),
                    cT(r4, t9)
                ]);
            case "comment":
                return tT([
                    gT(r4, t9),
                    tT(pw(t9.originalText.slice(Hw(r4), Xw(r4)), vw)),
                    yT(r4, t9)
                ]);
            case "attribute":
                {
                    if (null === r4.value) return r4.rawName;
                    const e14 = Jw(r4.value), t10 = Sw(e14, "'") < Sw(e14, '"') ? "'" : '"';
                    return tT([
                        r4.rawName,
                        tT([
                            "=",
                            t10,
                            tT(pw('"' === t10 ? e14.replace(/"/g, "&quot;") : e14.replace(/'/g, "&apos;"), vw)),
                            t10
                        ])
                    ]);
                }
            default:
                throw new Error("Unexpected node type ".concat(r4.type));
        }
        var o4;
    },
    insertPragma: Gw,
    massageAstNode: Zx,
    embed: function(e13, t9, n5, r4) {
        const o4 = e13.getValue();
        switch(o4.type){
            case "element":
                if (Vw(o4) || "interpolation" === o4.type) return;
                if (!o4.isSelfClosing && jw(o4, r4)) {
                    const u4 = Lw(o4, r4);
                    if (!u4) return;
                    const i5 = rT(o4, r4);
                    let a4 = /^\s*$/.test(i5), s4 = "";
                    return (a4 || (s4 = n5(Fw(i5), {
                        parser: u4
                    }, {
                        stripTrailingHardline: !0
                    }), a4 = "" === s4), tT([
                        gT(o4, r4),
                        gw(uT(e13, r4, t9)),
                        a4 ? "" : Dw,
                        s4,
                        a4 ? "" : Dw,
                        sT(o4, r4),
                        yT(o4, r4)
                    ]));
                }
                break;
            case "text":
                if (Vw(o4.parent)) {
                    const e14 = Lw(o4.parent);
                    if (e14) {
                        const t10 = "markdown" === e14 ? Tw(o4.value.replace(/^[^\S\n]*?\n/, "")) : o4.value, u4 = {
                            parser: e14
                        };
                        if ("html" === r4.parser && "babel" === e14) {
                            let e15 = "script";
                            const { attrMap: t11  } = o4.parent;
                            t11 && ("module" === t11.type || "text/babel" === t11.type && "module" === t11["data-type"]) && (e15 = "module"), u4.__babelSourceType = e15;
                        }
                        return sw.concat([
                            tT([
                                fw,
                                gT(o4, r4),
                                n5(t10, u4, {
                                    stripTrailingHardline: !0
                                }),
                                yT(o4, r4)
                            ])
                        ]);
                    }
                } else if ("interpolation" === o4.parent.type) return tT([
                    Ew(tT([
                        bw,
                        n5(o4.value, Object.assign({
                            __isInHtmlInterpolation: !0
                        }, "angular" === r4.parser ? {
                            parser: "__ng_interpolation",
                            trailingComma: "none"
                        } : "vue" === r4.parser ? {
                            parser: "__vue_expression"
                        } : {
                            parser: "__js_expression"
                        }), {
                            stripTrailingHardline: !0
                        })
                    ])),
                    o4.parent.next && fT(o4.parent.next) ? " " : bw
                ]);
                break;
            case "attribute":
                {
                    if (!o4.value) break;
                    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r4.originalText.slice(o4.valueSpan.start.offset, o4.valueSpan.end.offset))) return tT([
                        o4.rawName,
                        "=",
                        o4.value
                    ]);
                    if ("lwc" === r4.parser) {
                        if (/^{[\S\s]*}$/.test(r4.originalText.slice(o4.valueSpan.start.offset, o4.valueSpan.end.offset))) return tT([
                            o4.rawName,
                            "=",
                            o4.value
                        ]);
                    }
                    const e14 = function(e15, t10, n6) {
                        const r5 = (t11)=>new RegExp(t11.join("|")).test(e15.fullName)
                        , o5 = ()=>Jw(e15.value)
                        ;
                        let u4 = !1;
                        const i5 = (e16, t11)=>{
                            const n7 = "NGRoot" === e16.type ? "NGMicrosyntax" === e16.node.type && 1 === e16.node.body.length && "NGMicrosyntaxExpression" === e16.node.body[0].type ? e16.node.body[0].expression : e16.node : "JsExpressionRoot" === e16.type ? e16.node : e16;
                            !n7 || "ObjectExpression" !== n7.type && "ArrayExpression" !== n7.type && ("__vue_expression" !== t11.parser || "TemplateLiteral" !== n7.type && "StringLiteral" !== n7.type) || (u4 = !0);
                        }, a4 = (e16)=>gw(e16)
                        , s4 = (e16, t11 = !0)=>gw(tT([
                                Ew(tT([
                                    Aw,
                                    e16
                                ])),
                                t11 ? Aw : ""
                            ]))
                        , l4 = (e16)=>u4 ? a4(e16) : s4(e16)
                        , c4 = (e16, n7)=>t10(e16, Object.assign({
                                __onHtmlBindingRoot: i5
                            }, n7), {
                                stripTrailingHardline: !0
                            })
                        ;
                        if ("srcset" === e15.fullName && ("img" === e15.parent.fullName || "source" === e15.parent.fullName)) return s4(Zw(o5()));
                        if ("class" === e15.fullName && !n6.parentParser) {
                            const e16 = o5();
                            if (!e16.includes("{{")) return eT(e16);
                        }
                        if ("style" === e15.fullName && !n6.parentParser) {
                            const e16 = o5();
                            if (!e16.includes("{{")) return s4(c4(e16, {
                                parser: "css",
                                __isHTMLStyleAttribute: !0
                            }));
                        }
                        if ("vue" === n6.parser) {
                            if ("v-for" === e15.fullName) return Yw(o5(), c4);
                            if (_w(e15) || Rw(e15, n6)) return Kw(o5(), c4);
                            const t11 = [
                                "^:",
                                "^v-bind:"
                            ], u5 = [
                                "^v-"
                            ];
                            if (r5([
                                "^@",
                                "^v-on:"
                            ])) {
                                const e16 = o5();
                                return l4(c4(e16, {
                                    parser: Qw(e16) ? "__js_expression" : "__vue_event_binding"
                                }));
                            }
                            if (r5(t11)) return l4(c4(o5(), {
                                parser: "__vue_expression"
                            }));
                            if (r5(u5)) return l4(c4(o5(), {
                                parser: "__js_expression"
                            }));
                        }
                        if ("angular" === n6.parser) {
                            const t11 = (e16, t12)=>c4(e16, Object.assign({
                                }, t12, {
                                    trailingComma: "none"
                                }))
                            , n7 = [
                                "^\\*"
                            ], u5 = [
                                "^\\[.+\\]$",
                                "^bind(on)?-",
                                "^ng-(if|show|hide|class|style)$"
                            ], i6 = [
                                "^i18n(-.+)?$"
                            ];
                            if (r5([
                                "^\\(.+\\)$",
                                "^on-"
                            ])) return l4(t11(o5(), {
                                parser: "__ng_action"
                            }));
                            if (r5(u5)) return l4(t11(o5(), {
                                parser: "__ng_binding"
                            }));
                            if (r5(i6)) {
                                const t12 = o5().trim();
                                return s4(mw(AT(e15, t12)), !t12.includes("@@"));
                            }
                            if (r5(n7)) return l4(t11(o5(), {
                                parser: "__ng_directive"
                            }));
                            const a5 = /{{([\S\s]+?)}}/g, p4 = o5();
                            if (a5.test(p4)) {
                                const e16 = [];
                                return p4.split(a5).forEach((n8, r6)=>{
                                    if (r6 % 2 == 0) e16.push(tT(pw(n8, vw)));
                                    else try {
                                        e16.push(gw(tT([
                                            "{{",
                                            Ew(tT([
                                                bw,
                                                t11(n8, {
                                                    parser: "__ng_interpolation",
                                                    __isInHtmlInterpolation: !0
                                                })
                                            ])),
                                            bw,
                                            "}}"
                                        ])));
                                    } catch (t) {
                                        e16.push("{{", tT(pw(n8, vw)), "}}");
                                    }
                                }), gw(tT(e16));
                            }
                        }
                        return null;
                    }(o4, (e15, t10)=>n5(e15, Object.assign({
                            __isInHtmlAttribute: !0
                        }, t10), {
                            stripTrailingHardline: !0
                        })
                    , r4);
                    if (e14) return tT([
                        o4.rawName,
                        '="',
                        gw(lw(e14, (e15)=>"string" == typeof e15 ? e15.replace(/"/g, "&quot;") : e15
                        )),
                        '"'
                    ]);
                    break;
                }
            case "front-matter":
                return dw(o4, n5);
        }
    }
};
var TT = {
    languages: [
        xs1(ST, ()=>({
                name: "Angular",
                since: "1.15.0",
                parsers: [
                    "angular"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [
                    ".component.html"
                ],
                filenames: []
            })
        ),
        xs1(ST, (e13)=>({
                since: "1.15.0",
                parsers: [
                    "html"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: e13.extensions.concat([
                    ".mjml"
                ])
            })
        ),
        xs1(ST, ()=>({
                name: "Lightning Web Components",
                since: "1.17.0",
                parsers: [
                    "lwc"
                ],
                vscodeLanguageIds: [
                    "html"
                ],
                extensions: [],
                filenames: []
            })
        ),
        xs1(wT, ()=>({
                since: "1.10.0",
                parsers: [
                    "vue"
                ],
                vscodeLanguageIds: [
                    "vue"
                ]
            })
        )
    ],
    printers: {
        html: FT
    },
    options: xT,
    parsers: {
        get html () {
            return {
            }.parsers.html;
        },
        get vue () {
            return {
            }.parsers.vue;
        },
        get angular () {
            return {
            }.parsers.angular;
        },
        get lwc () {
            return {
            }.parsers.lwc;
        }
    }
};
const { getLast: kT  } = Nt1;
var VT = {
    getLast: kT,
    getAncestorCount: function(e13, t9) {
        let n5 = 0;
        const r4 = e13.stack.length - 1;
        for(let o4 = 0; o4 < r4; o4++){
            const r5 = e13.stack[o4];
            PT(r5) && t9(r5) && n5++;
        }
        return n5;
    },
    isNode: PT,
    isEmptyNode: function(e13) {
        return !(e13.children && 0 !== e13.children.length || function(e14) {
            return IT(e14) || LT(e14) || MT(e14) || jT(e14) || _T(e14);
        }(e13));
    },
    mapNode: function e13(t9, n5, r4) {
        return n5("children" in t9 ? Object.assign({
        }, t9, {
            children: t9.children.map((r5)=>e13(r5, n5, t9)
            )
        }) : t9, r4);
    },
    defineShortcut: function(e14, t9, n5) {
        Object.defineProperty(e14, t9, {
            get: n5,
            enumerable: !1
        });
    },
    isNextLineEmpty: function(e14, t9) {
        let n5 = 0;
        const r4 = t9.length;
        for(let o4 = e14.position.end.offset - 1; o4 < r4; o4++){
            const e15 = t9[o4];
            if (("\n" === e15 && n5++, 1 === n5 && /\S/.test(e15))) return !1;
            if (2 === n5) return !0;
        }
        return !1;
    },
    isLastDescendantNode: function(e14) {
        switch(e14.getValue().type){
            case "tag":
            case "anchor":
            case "comment":
                return !1;
        }
        const t9 = e14.stack.length;
        for(let n5 = 1; n5 < t9; n5++){
            const t10 = e14.stack[n5], r4 = e14.stack[n5 - 1];
            if (Array.isArray(r4) && "number" == typeof t10 && t10 !== r4.length - 1) return !1;
        }
        return !0;
    },
    getBlockValueLineContents: function(e14, { parentIndent: t9 , isLastDescendant: n5 , options: r4  }) {
        const o4 = e14.position.start.line === e14.position.end.line ? "" : r4.originalText.slice(e14.position.start.offset, e14.position.end.offset).match(/^[^\n]*?\n([\S\s]*)$/)[1], u4 = null === e14.indent ? (i5 = o4.match(/^( *)\S/m)) ? i5[1].length : 1 / 0 : e14.indent - 1 + t9;
        var i5;
        const a4 = o4.split("\n").map((e15)=>e15.slice(u4)
        );
        return "preserve" === r4.proseWrap || "blockLiteral" === e14.type ? s4(a4.map((e15)=>0 === e15.length ? [] : [
                e15
            ]
        )) : s4(a4.map((e15)=>0 === e15.length ? [] : RT(e15)
        ).reduce((e15, t10, n6)=>0 === n6 || 0 === a4[n6 - 1].length || 0 === t10.length || /^\s/.test(t10[0]) || /^\s|\s$/.test(kT(e15)) ? e15.concat([
                t10
            ]) : e15.concat([
                e15.pop().concat(t10)
            ])
        , []).map((e15)=>e15.reduce((e16, t10)=>0 !== e16.length && /\s$/.test(kT(e16)) ? e16.concat(e16.pop() + " " + t10) : e16.concat(t10)
            , [])
        ).map((e15)=>"never" === r4.proseWrap ? [
                e15.join(" ")
            ] : e15
        ));
        function s4(t10) {
            if ("keep" === e14.chomping) return 0 === kT(t10).length ? t10.slice(0, -1) : t10;
            let r5 = 0;
            for(let e15 = t10.length - 1; e15 >= 0 && 0 === t10[e15].length; e15--)r5++;
            return 0 === r5 ? t10 : r5 >= 2 && !n5 ? t10.slice(0, -(r5 - 1)) : t10.slice(0, -r5);
        }
    },
    getFlowScalarLineContents: function(e14, t9, n5) {
        const r4 = t9.split("\n").map((e15, t10, n6)=>0 === t10 && t10 === n6.length - 1 ? e15 : 0 !== t10 && t10 !== n6.length - 1 ? e15.trim() : 0 === t10 ? e15.trimEnd() : e15.trimStart()
        );
        return "preserve" === n5.proseWrap ? r4.map((e15)=>0 === e15.length ? [] : [
                e15
            ]
        ) : r4.map((e15)=>0 === e15.length ? [] : RT(e15)
        ).reduce((t10, n6, o4)=>0 === o4 || 0 === r4[o4 - 1].length || 0 === n6.length || "quoteDouble" === e14 && kT(kT(t10)).endsWith("\\") ? t10.concat([
                n6
            ]) : t10.concat([
                t10.pop().concat(n6)
            ])
        , []).map((e15)=>"never" === n5.proseWrap ? [
                e15.join(" ")
            ] : e15
        );
    },
    getLastDescendantNode: function e13(t9) {
        return "children" in t9 && 0 !== t9.children.length ? e13(kT(t9.children)) : t9;
    },
    hasPrettierIgnore: function(e14) {
        const t9 = e14.getValue();
        if ("documentBody" === t9.type) {
            const t10 = e14.getParentNode();
            return _T(t10.head) && OT(kT(t10.head.endComments));
        }
        return IT(t9) && OT(kT(t9.leadingComments));
    },
    hasLeadingComments: IT,
    hasMiddleComments: LT,
    hasIndicatorComment: MT,
    hasTrailingComment: jT,
    hasEndComments: _T
};
const $T = rn1.builders, { conditionalGroup: qT , breakParent: WT , concat: UT , dedent: JT , dedentToRoot: zT , fill: GT , group: HT , hardline: XT , ifBreak: YT , join: KT , line: QT , lineSuffix: ZT , literalline: eB , markAsRoot: tB , softline: nB  } = $T, { replaceEndOfLineWith: rB , isPreviousLineEmpty: oB  } = Nt1, { insertPragma: uB , isPragma: iB  } = BT, { locStart: aB  } = NT, { getAncestorCount: sB , getBlockValueLineContents: lB , getFlowScalarLineContents: cB , getLast: pB , getLastDescendantNode: dB , hasLeadingComments: fB , hasMiddleComments: hB , hasIndicatorComment: mB , hasTrailingComment: gB , hasEndComments: DB , hasPrettierIgnore: yB , isLastDescendantNode: EB , isNextLineEmpty: CB , isNode: bB , isEmptyNode: vB , defineShortcut: AB , mapNode: FB  } = VT;
function xB(e13) {
    switch(e13.type){
        case "document":
            AB(e13, "head", ()=>e13.children[0]
            ), AB(e13, "body", ()=>e13.children[1]
            );
            break;
        case "documentBody":
        case "sequenceItem":
        case "flowSequenceItem":
        case "mappingKey":
        case "mappingValue":
            AB(e13, "content", ()=>e13.children[0]
            );
            break;
        case "mappingItem":
        case "flowMappingItem":
            AB(e13, "key", ()=>e13.children[0]
            ), AB(e13, "value", ()=>e13.children[1]
            );
    }
    return e13;
}
function SB(e13, t9, n5, r4, o4) {
    switch(e13.type){
        case "root":
            return UT([
                KT(XT, n5.map((t10, r5)=>{
                    const u4 = e13.children[r5], i5 = e13.children[r5 + 1];
                    return UT([
                        o4(t10),
                        NB(u4, i5) ? UT([
                            XT,
                            "...",
                            gB(u4) ? UT([
                                " ",
                                n5.call(o4, "trailingComment")
                            ]) : ""
                        ]) : !i5 || gB(i5.head) ? "" : UT([
                            XT,
                            "---"
                        ])
                    ]);
                }, "children")),
                0 === e13.children.length || (i5 = dB(e13), bB(i5, [
                    "blockLiteral",
                    "blockFolded"
                ]) && "keep" === i5.chomping) ? "" : XT
            ]);
        case "document":
            {
                const u4 = t9.children[n5.getName() + 1];
                return KT(XT, [
                    "head" === kB(e13, u4, t9, r4) ? KT(XT, [
                        0 === e13.head.children.length && 0 === e13.head.endComments.length ? "" : n5.call(o4, "head"),
                        UT([
                            "---",
                            gB(e13.head) ? UT([
                                " ",
                                n5.call(o4, "head", "trailingComment")
                            ]) : ""
                        ])
                    ].filter(Boolean)) : "",
                    BB(e13) ? n5.call(o4, "body") : ""
                ].filter(Boolean));
            }
        case "documentHead":
            return KT(XT, [].concat(n5.map(o4, "children"), n5.map(o4, "endComments")));
        case "documentBody":
            {
                const t10 = KT(XT, n5.map(o4, "children")).parts, r5 = KT(XT, n5.map(o4, "endComments")).parts, u4 = 0 === t10.length || 0 === r5.length ? "" : ((e14)=>bB(e14, [
                        "blockFolded",
                        "blockLiteral"
                    ]) ? "keep" === e14.chomping ? "" : UT([
                        XT,
                        XT
                    ]) : XT
                )(dB(e13));
                return UT([].concat(t10, u4, r5));
            }
        case "directive":
            return UT([
                "%",
                KT(" ", [
                    e13.name
                ].concat(e13.parameters))
            ]);
        case "comment":
            return UT([
                "#",
                e13.value
            ]);
        case "alias":
            return UT([
                "*",
                e13.value
            ]);
        case "tag":
            return r4.originalText.slice(e13.position.start.offset, e13.position.end.offset);
        case "anchor":
            return UT([
                "&",
                e13.value
            ]);
        case "plain":
            return jB(e13.type, r4.originalText.slice(e13.position.start.offset, e13.position.end.offset), r4);
        case "quoteDouble":
        case "quoteSingle":
            {
                const t10 = "'", n6 = '"', o5 = r4.originalText.slice(e13.position.start.offset + 1, e13.position.end.offset - 1);
                if ("quoteSingle" === e13.type && o5.includes("\\") || "quoteDouble" === e13.type && /\\[^"]/.test(o5)) {
                    const u4 = "quoteDouble" === e13.type ? n6 : t10;
                    return UT([
                        u4,
                        jB(e13.type, o5, r4),
                        u4
                    ]);
                }
                if (o5.includes(n6)) return UT([
                    t10,
                    jB(e13.type, "quoteDouble" === e13.type ? o5.replace(/\\"/g, n6).replace(/'/g, t10.repeat(2)) : o5, r4),
                    t10
                ]);
                if (o5.includes(t10)) return UT([
                    n6,
                    jB(e13.type, "quoteSingle" === e13.type ? o5.replace(/''/g, t10) : o5, r4),
                    n6
                ]);
                const u4 = r4.singleQuote ? t10 : n6;
                return UT([
                    u4,
                    jB(e13.type, o5, r4),
                    u4
                ]);
            }
        case "blockFolded":
        case "blockLiteral":
            {
                const t10 = sB(n5, (e14)=>bB(e14, [
                        "sequence",
                        "mapping"
                    ])
                ), u4 = EB(n5);
                return UT([
                    "blockFolded" === e13.type ? ">" : "|",
                    null === e13.indent ? "" : e13.indent.toString(),
                    "clip" === e13.chomping ? "" : "keep" === e13.chomping ? "+" : "-",
                    mB(e13) ? UT([
                        " ",
                        n5.call(o4, "indicatorComment")
                    ]) : "",
                    (null === e13.indent ? JT : zT)(wB(null === e13.indent ? r4.tabWidth : e13.indent - 1 + t10, UT(lB(e13, {
                        parentIndent: t10,
                        isLastDescendant: u4,
                        options: r4
                    }).reduce((t11, n6, r5, o5)=>t11.concat(0 === r5 ? XT : "", GT(KT(QT, n6).parts), r5 !== o5.length - 1 ? 0 === n6.length ? XT : tB(eB) : "keep" === e13.chomping && u4 ? 0 === n6.length ? zT(XT) : zT(eB) : "")
                    , []))))
                ]);
            }
        case "sequence":
            return KT(XT, n5.map(o4, "children"));
        case "sequenceItem":
            return UT([
                "- ",
                wB(2, e13.content ? n5.call(o4, "content") : "")
            ]);
        case "mappingKey":
        case "mappingValue":
            return e13.content ? n5.call(o4, "content") : "";
        case "mapping":
            return KT(XT, n5.map(o4, "children"));
        case "mappingItem":
        case "flowMappingItem":
            {
                const u4 = vB(e13.key), i5 = vB(e13.value);
                if (u4 && i5) return UT([
                    ": "
                ]);
                const s4 = n5.call(o4, "key"), l4 = n5.call(o4, "value");
                if (i5) return "flowMappingItem" === e13.type && "flowMapping" === t9.type ? s4 : "mappingItem" !== e13.type || !PB(e13.key.content, r4) || gB(e13.key.content) || t9.tag && "tag:yaml.org,2002:set" === t9.tag.value ? UT([
                    "? ",
                    wB(2, s4)
                ]) : UT([
                    s4,
                    OB(e13) ? " " : "",
                    ":"
                ]);
                if (u4) return UT([
                    ": ",
                    wB(2, l4)
                ]);
                const c4 = Symbol("mappingKey");
                return fB(e13.value) || !TB(e13.key.content) ? UT([
                    "? ",
                    wB(2, s4),
                    XT,
                    KT("", n5.map(o4, "value", "leadingComments").map((e14)=>UT([
                            e14,
                            XT
                        ])
                    )),
                    ": ",
                    wB(2, l4)
                ]) : !(function(e14) {
                    if (!e14) return !0;
                    switch(e14.type){
                        case "plain":
                        case "quoteDouble":
                        case "quoteSingle":
                            return e14.position.start.line === e14.position.end.line;
                        case "alias":
                            return !0;
                        default:
                            return !1;
                    }
                })(e13.key.content) || fB(e13.key.content) || hB(e13.key.content) || gB(e13.key.content) || DB(e13.key) || fB(e13.value.content) || hB(e13.value.content) || DB(e13.value) || !PB(e13.value.content, r4) ? qT([
                    UT([
                        HT(UT([
                            YT("? "),
                            HT(wB(2, s4), {
                                id: c4
                            })
                        ])),
                        YT(UT([
                            XT,
                            ": ",
                            wB(2, l4)
                        ]), a4(UT([
                            OB(e13) ? " " : "",
                            ":",
                            fB(e13.value.content) || DB(e13.value) && e13.value.content && !bB(e13.value.content, [
                                "mapping",
                                "sequence"
                            ]) || "mapping" === t9.type && gB(e13.key.content) && TB(e13.value.content) || bB(e13.value.content, [
                                "mapping",
                                "sequence"
                            ]) && null === e13.value.content.tag && null === e13.value.content.anchor ? XT : e13.value.content ? QT : "",
                            l4
                        ])), {
                            groupId: c4
                        })
                    ])
                ]) : UT([
                    s4,
                    OB(e13) ? " " : "",
                    ": ",
                    l4
                ]);
            }
        case "flowMapping":
        case "flowSequence":
            {
                const t10 = "flowMapping" === e13.type ? "{" : "[", i5 = "flowMapping" === e13.type ? "}" : "]", s4 = "flowMapping" === e13.type && 0 !== e13.children.length && r4.bracketSpacing ? QT : nB, l4 = 0 !== e13.children.length && ("flowMappingItem" === (u4 = pB(e13.children)).type && vB(u4.key) && vB(u4.value)), c4 = "none" === r4.trailingComma ? "" : YT(",", "");
                return UT([
                    t10,
                    a4(UT([
                        s4,
                        UT(n5.map((t11, n6)=>UT([
                                o4(t11),
                                n6 === e13.children.length - 1 ? "" : UT([
                                    ",",
                                    QT,
                                    e13.children[n6].position.start.line !== e13.children[n6 + 1].position.start.line ? MB(t11, r4.originalText) : ""
                                ])
                            ])
                        , "children")),
                        c4,
                        DB(e13) ? UT([
                            XT,
                            KT(XT, n5.map(o4, "endComments"))
                        ]) : ""
                    ])),
                    l4 ? "" : s4,
                    i5
                ]);
            }
        case "flowSequenceItem":
            return n5.call(o4, "content");
        default:
            throw new Error("Unexpected node type ".concat(e13.type));
    }
    var u4, i5;
    function a4(e14) {
        return $T.align(" ".repeat(r4.tabWidth), e14);
    }
}
function wB(e13, t9) {
    return "number" == typeof e13 && e13 > 0 ? $T.align(" ".repeat(e13), t9) : $T.align(e13, t9);
}
function BB(e13) {
    return 0 !== e13.body.children.length || DB(e13.body);
}
function NB(e13, t9) {
    return gB(e13) || t9 && (0 !== t9.head.children.length || DB(t9.head));
}
function kB(e13, t9, n5, r4) {
    return n5.children[0] === e13 && /---(\s|$)/.test(r4.originalText.slice(aB(e13), aB(e13) + 4)) || 0 !== e13.head.children.length || DB(e13.head) || gB(e13.head) ? "head" : !NB(e13, t9) && (!!t9 && "root");
}
function IB(e13) {
    return DB(e13) && !bB(e13, [
        "documentHead",
        "documentBody",
        "flowMapping",
        "flowSequence"
    ]);
}
function MB(e13, t9) {
    const n5 = e13.getValue(), r4 = e13.stack[0];
    let o4;
    return LB.has(r4) ? o4 = LB.get(r4) : (o4 = new Set, LB.set(r4, o4)), o4.has(n5.position.end.line) || (o4.add(n5.position.end.line), !CB(n5, t9) || IB(e13.getParentNode())) ? "" : nB;
}
function jB(e13, t9, n5) {
    const r4 = cB(e13, t9, n5);
    return KT(XT, r4.map((e14)=>GT(KT(QT, e14).parts)
    ));
}
var _B = {
    preprocess: function(e13) {
        return FB(e13, xB);
    },
    print: function(e13, t9, n5) {
        const r4 = e13.getValue(), o4 = e13.getParentNode(), u4 = r4.tag ? e13.call(n5, "tag") : "", i5 = r4.anchor ? e13.call(n5, "anchor") : "", a4 = bB(r4, [
            "mapping",
            "sequence",
            "comment",
            "directive",
            "mappingItem",
            "sequenceItem"
        ]) && !EB(e13) ? MB(e13, t9.originalText) : "";
        return UT([
            "mappingValue" !== r4.type && fB(r4) ? UT([
                KT(XT, e13.map(n5, "leadingComments")),
                XT
            ]) : "",
            u4,
            u4 && i5 ? " " : "",
            i5,
            u4 || i5 ? bB(r4, [
                "sequence",
                "mapping"
            ]) && !hB(r4) ? XT : " " : "",
            hB(r4) ? UT([
                1 === r4.middleComments.length ? "" : XT,
                KT(XT, e13.map(n5, "middleComments")),
                XT
            ]) : "",
            yB(e13) ? UT(rB(t9.originalText.slice(r4.position.start.offset, r4.position.end.offset).trimEnd(), eB)) : HT(SB(r4, o4, e13, t9, n5)),
            gB(r4) && !bB(r4, [
                "document",
                "documentHead"
            ]) ? ZT(UT([
                "mappingValue" !== r4.type || r4.content ? " " : "",
                "mappingKey" === o4.type && "mapping" === e13.getParentNode(2).type && TB(r4) ? "" : WT,
                e13.call(n5, "trailingComment")
            ])) : "",
            IB(r4) ? wB("sequenceItem" === r4.type ? 2 : 0, UT([
                XT,
                KT(XT, e13.map((e14)=>UT([
                        oB(t9.originalText, e14.getValue(), aB) ? XT : "",
                        n5(e14)
                    ])
                , "endComments"))
            ])) : "",
            a4
        ]);
    },
    massageAstNode: function(e13, t9) {
        if (bB(t9)) switch((delete t9.position, t9.type)){
            case "comment":
                if (iB(t9.value)) return null;
                break;
            case "quoteDouble":
            case "quoteSingle":
                t9.type = "quote";
        }
    },
    insertPragma: uB
}, RB = {
    bracketSpacing: kC.bracketSpacing,
    singleQuote: kC.singleQuote,
    proseWrap: kC.proseWrap
};
var VB = [
    VC,
    Uv,
    YA,
    DF,
    Xx,
    TT,
    {
        languages: [
            xs1({
                name: "YAML",
                type: "data",
                color: "#cb171e",
                tmScope: "source.yaml",
                aliases: [
                    "yml"
                ],
                extensions: [
                    ".yml",
                    ".mir",
                    ".reek",
                    ".rviz",
                    ".sublime-syntax",
                    ".syntax",
                    ".yaml",
                    ".yaml-tmlanguage",
                    ".yaml.sed",
                    ".yml.mysql"
                ],
                filenames: [
                    ".clang-format",
                    ".clang-tidy",
                    ".gemrc",
                    "glide.lock",
                    "yarn.lock"
                ],
                aceMode: "yaml",
                codemirrorMode: "yaml",
                codemirrorMimeType: "text/x-yaml",
                languageId: 407
            }, (e13)=>({
                    since: "1.14.0",
                    parsers: [
                        "yaml"
                    ],
                    vscodeLanguageIds: [
                        "yaml",
                        "ansible",
                        "home-assistant"
                    ],
                    filenames: e13.filenames.filter((e14)=>"yarn.lock" !== e14
                    )
                })
            )
        ],
        printers: {
            yaml: _B
        },
        options: RB,
        parsers: {
            get yaml () {
                return ({
                }).parsers.yaml;
            }
        }
    }
];
const { version: $B  } = n2, { getSupportInfo: qB  } = pt1, WB = VB.map((t9)=>e2(t9, [
        "parsers"
    ])
);
function UB(e13, t9 = 1) {
    return (...n5)=>{
        const r4 = n5[t9] || {
        }, o4 = r4.plugins || [];
        return n5[t9] = Object.assign({
        }, r4, {
            plugins: [
                ...WB,
                ...Array.isArray(o4) ? o4 : Object.values(o4)
            ]
        }), e13(...n5);
    };
}
const JB = UB(es.formatWithCursor);
function C3() {
    E1 && f1 && (E1 = !1, f1.length ? y1 = f1.concat(y1) : A1 = -1, y1.length && x3());
}
function x3() {
    if (!E1) {
        var t9 = m1(C3);
        E1 = !0;
        for(var e13 = y1.length; e13;){
            for(f1 = y1, y1 = []; (++A1) < e13;)f1 && f1[A1].run();
            A1 = -1, e13 = y1.length;
        }
        f1 = null, E1 = !1, (function(t10) {
            if (D1 === clearTimeout) return clearTimeout(t10);
            if ((D1 === l2 || !D1) && clearTimeout) return D1 = clearTimeout, clearTimeout(t10);
            try {
                D1(t10);
            } catch (e) {
                try {
                    return D1.call(null, t10);
                } catch (e) {
                    return D1.call(this, t10);
                }
            }
        })(t9);
    }
}
var L1 = {
    nextTick: function(t9) {
        var e13 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var s4 = 1; s4 < arguments.length; s4++)e13[s4 - 1] = arguments[s4];
        y1.push(new F1(t9, e13)), 1 !== y1.length || E1 || m1(x3);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: b1,
    addListener: P1,
    once: T1,
    off: w1,
    removeListener: B,
    removeAllListeners: S,
    emit: N1,
    binding: function(t9) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(t9) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(t9) {
        var e13 = 0.001 * v1.call(I2), s4 = Math.floor(e13), r4 = Math.floor(e13 % 1 * 1000000000);
        return (t9 && (s4 -= t9[0], (r4 -= t9[1]) < 0 && (s4--, r4 += 1000000000)), [
            s4,
            r4
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - k1) / 1000;
    }
};
var O2 = "object" == typeof L1 && L1.env && L1.env.NODE_DEBUG && /\bsemver\b/i.test(L1.env.NODE_DEBUG) ? (...t9)=>console.error("SEMVER", ...t9)
 : ()=>{
};
var j3 = R1(function(t9, e13) {
    const { MAX_SAFE_COMPONENT_LENGTH: s4  } = M2, r4 = (e13 = t9.exports = {
    }).re = [], i5 = e13.src = [], n5 = e13.t = {
    };
    let a4 = 0;
    const o4 = (t10, e14, s5)=>{
        const o5 = a4++;
        O2(o5, e14), n5[t10] = o5, i5[o5] = e14, r4[o5] = new RegExp(e14, s5 ? "g" : void 0);
    };
    o4("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o4("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o4("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o4("MAINVERSION", "(".concat(i5[n5.NUMERICIDENTIFIER], ")\\.") + "(".concat(i5[n5.NUMERICIDENTIFIER], ")\\.") + "(".concat(i5[n5.NUMERICIDENTIFIER], ")")), o4("MAINVERSIONLOOSE", "(".concat(i5[n5.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i5[n5.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i5[n5.NUMERICIDENTIFIERLOOSE], ")")), o4("PRERELEASEIDENTIFIER", "(?:".concat(i5[n5.NUMERICIDENTIFIER], "|").concat(i5[n5.NONNUMERICIDENTIFIER], ")")), o4("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i5[n5.NUMERICIDENTIFIERLOOSE], "|").concat(i5[n5.NONNUMERICIDENTIFIER], ")")), o4("PRERELEASE", "(?:-(".concat(i5[n5.PRERELEASEIDENTIFIER], "(?:\\.").concat(i5[n5.PRERELEASEIDENTIFIER], ")*))")), o4("PRERELEASELOOSE", "(?:-?(".concat(i5[n5.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i5[n5.PRERELEASEIDENTIFIERLOOSE], ")*))")), o4("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o4("BUILD", "(?:\\+(".concat(i5[n5.BUILDIDENTIFIER], "(?:\\.").concat(i5[n5.BUILDIDENTIFIER], ")*))")), o4("FULLPLAIN", "v?".concat(i5[n5.MAINVERSION]).concat(i5[n5.PRERELEASE], "?").concat(i5[n5.BUILD], "?")), o4("FULL", "^".concat(i5[n5.FULLPLAIN], "$")), o4("LOOSEPLAIN", "[v=\\s]*".concat(i5[n5.MAINVERSIONLOOSE]).concat(i5[n5.PRERELEASELOOSE], "?").concat(i5[n5.BUILD], "?")), o4("LOOSE", "^".concat(i5[n5.LOOSEPLAIN], "$")), o4("GTLT", "((?:<|>)?=?)"), o4("XRANGEIDENTIFIERLOOSE", "".concat(i5[n5.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o4("XRANGEIDENTIFIER", "".concat(i5[n5.NUMERICIDENTIFIER], "|x|X|\\*")), o4("XRANGEPLAIN", "[v=\\s]*(".concat(i5[n5.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i5[n5.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i5[n5.XRANGEIDENTIFIER], ")") + "(?:".concat(i5[n5.PRERELEASE], ")?").concat(i5[n5.BUILD], "?") + ")?)?"), o4("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i5[n5.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i5[n5.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i5[n5.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i5[n5.PRERELEASELOOSE], ")?").concat(i5[n5.BUILD], "?") + ")?)?"), o4("XRANGE", "^".concat(i5[n5.GTLT], "\\s*").concat(i5[n5.XRANGEPLAIN], "$")), o4("XRANGELOOSE", "^".concat(i5[n5.GTLT], "\\s*").concat(i5[n5.XRANGEPLAINLOOSE], "$")), o4("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(s4, "})") + "(?:\\.(\\d{1,".concat(s4, "}))?") + "(?:\\.(\\d{1,".concat(s4, "}))?") + "(?:$|[^\\d])"), o4("COERCERTL", i5[n5.COERCE], !0), o4("LONETILDE", "(?:~>?)"), o4("TILDETRIM", "(\\s*)".concat(i5[n5.LONETILDE], "\\s+"), !0), e13.tildeTrimReplace = "$1~", o4("TILDE", "^".concat(i5[n5.LONETILDE]).concat(i5[n5.XRANGEPLAIN], "$")), o4("TILDELOOSE", "^".concat(i5[n5.LONETILDE]).concat(i5[n5.XRANGEPLAINLOOSE], "$")), o4("LONECARET", "(?:\\^)"), o4("CARETTRIM", "(\\s*)".concat(i5[n5.LONECARET], "\\s+"), !0), e13.caretTrimReplace = "$1^", o4("CARET", "^".concat(i5[n5.LONECARET]).concat(i5[n5.XRANGEPLAIN], "$")), o4("CARETLOOSE", "^".concat(i5[n5.LONECARET]).concat(i5[n5.XRANGEPLAINLOOSE], "$")), o4("COMPARATORLOOSE", "^".concat(i5[n5.GTLT], "\\s*(").concat(i5[n5.LOOSEPLAIN], ")$|^$")), o4("COMPARATOR", "^".concat(i5[n5.GTLT], "\\s*(").concat(i5[n5.FULLPLAIN], ")$|^$")), o4("COMPARATORTRIM", "(\\s*)".concat(i5[n5.GTLT], "\\s*(").concat(i5[n5.LOOSEPLAIN], "|").concat(i5[n5.XRANGEPLAIN], ")"), !0), e13.comparatorTrimReplace = "$1$2$3", o4("HYPHENRANGE", "^\\s*(".concat(i5[n5.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i5[n5.XRANGEPLAIN], ")") + "\\s*$"), o4("HYPHENRANGELOOSE", "^\\s*(".concat(i5[n5.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i5[n5.XRANGEPLAINLOOSE], ")") + "\\s*$"), o4("STAR", "(<|>)?=?\\s*\\*"), o4("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o4("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: z2 , MAX_SAFE_INTEGER: H3  } = M2, { re: W1 , t: G2  } = j3, { compareIdentifiers: X2  } = V1;
class K2 {
    constructor(t9, e13){
        if (e13 && "object" == typeof e13 || (e13 = {
            loose: !!e13,
            includePrerelease: !1
        }), t9 instanceof K2) {
            if (t9.loose === !!e13.loose && t9.includePrerelease === !!e13.includePrerelease) return t9;
            t9 = t9.version;
        } else if ("string" != typeof t9) throw new TypeError("Invalid Version: ".concat(t9));
        if (t9.length > z2) throw new TypeError("version is longer than ".concat(z2, " characters"));
        O2("SemVer", t9, e13), this.options = e13, this.loose = !!e13.loose, this.includePrerelease = !!e13.includePrerelease;
        const s4 = t9.trim().match(e13.loose ? W1[G2.LOOSE] : W1[G2.FULL]);
        if (!s4) throw new TypeError("Invalid Version: ".concat(t9));
        if (this.raw = t9, this.major = +s4[1], this.minor = +s4[2], this.patch = +s4[3], this.major > H3 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > H3 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > H3 || this.patch < 0) throw new TypeError("Invalid patch version");
        s4[4] ? this.prerelease = s4[4].split(".").map((t10)=>{
            if (/^[0-9]+$/.test(t10)) {
                const e14 = +t10;
                if (e14 >= 0 && e14 < H3) return e14;
            }
            return t10;
        }) : this.prerelease = [], this.build = s4[5] ? s4[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(t) {
        if (O2("SemVer.compare", this.version, this.options, t), !(t instanceof K2)) {
            if ("string" == typeof t && t === this.version) return 0;
            t = new K2(t, this.options);
        }
        return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
    }
    compareMain(t) {
        return t instanceof K2 || (t = new K2(t, this.options)), X2(this.major, t.major) || X2(this.minor, t.minor) || X2(this.patch, t.patch);
    }
    comparePre(t) {
        if (t instanceof K2 || (t = new K2(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
        if (!this.prerelease.length && t.prerelease.length) return 1;
        if (!this.prerelease.length && !t.prerelease.length) return 0;
        let e14 = 0;
        do {
            const s5 = this.prerelease[e14], r4 = t.prerelease[e14];
            if (O2("prerelease compare", e14, s5, r4), (void 0) === s5 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === s5) return -1;
            if (s5 !== r4) return X2(s5, r4);
        }while (++e14)
    }
    compareBuild(t) {
        t instanceof K2 || (t = new K2(t, this.options));
        let e14 = 0;
        do {
            const s5 = this.build[e14], r4 = t.build[e14];
            if (O2("prerelease compare", e14, s5, r4), (void 0) === s5 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === s5) return -1;
            if (s5 !== r4) return X2(s5, r4);
        }while (++e14)
    }
    inc(t, e) {
        switch(t){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", e), this.inc("pre", e);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", e), this.inc("pre", e);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let t10 = this.prerelease.length;
                    for(; (--t10) >= 0;)"number" == typeof this.prerelease[t10] && (this.prerelease[t10]++, t10 = -2);
                    -1 === t10 && this.prerelease.push(0);
                }
                e && (this.prerelease[0] === e ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    e,
                    0
                ]) : this.prerelease = [
                    e,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(t));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var J1 = K2;
var $2 = (t10, e14, s5)=>new J1(t10, s5).compare(new J1(e14, s5))
;
var Y1 = (t10, e14, s5)=>$2(t10, e14, s5) < 0
;
var Q2 = (t10, e14, s5)=>$2(t10, e14, s5) >= 0
, Z3 = "2.2.1", tt1 = R1(function(t10, e14) {
    function s5() {
        for(var t11 = [], e15 = 0; e15 < arguments.length; e15++)t11[e15] = arguments[e15];
    }
    function r4() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: s5,
            delete: s5,
            get: s5,
            set: s5,
            has: function(t11) {
                return !1;
            }
        };
    }
    Object.defineProperty(e14, "__esModule", {
        value: !0
    });
    var i5 = Object.prototype.hasOwnProperty, n5 = function(t11, e15) {
        return i5.call(t11, e15);
    };
    function a4(t11, e15) {
        for(var s6 in e15)n5(e15, s6) && (t11[s6] = e15[s6]);
        return t11;
    }
    var o4 = /^[ \t]*(?:\r\n|\r|\n)/, u4 = /(?:\r\n|\r|\n)[ \t]*$/, h4 = /^(?:[\r\n]|$)/, c4 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p4 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function l4(t11, e15, s6) {
        var r5 = 0, i6 = t11[0].match(c4);
        i6 && (r5 = i6[1].length);
        var n6 = new RegExp("(\\r\\n|\\r|\\n).{0," + r5 + "}", "g");
        e15 && (t11 = t11.slice(1));
        var a5 = s6.newline, h5 = s6.trimLeadingNewline, p5 = s6.trimTrailingNewline, l4 = "string" == typeof a5, d4 = t11.length;
        return t11.map(function(t12, e16) {
            return (t12 = t12.replace(n6, "$1"), 0 === e16 && h5 && (t12 = t12.replace(o4, "")), e16 === d4 - 1 && p5 && (t12 = t12.replace(u4, "")), l4 && (t12 = t12.replace(/\r\n|\n|\r/g, function(t13) {
                return a5;
            })), t12);
        });
    }
    function d4(t11, e15) {
        for(var s6 = "", r5 = 0, i6 = t11.length; r5 < i6; r5++)s6 += t11[r5], r5 < i6 - 1 && (s6 += e15[r5]);
        return s6;
    }
    function D4(t11) {
        return n5(t11, "raw") && n5(t11, "length");
    }
    var m4 = function t10(e15) {
        var s6 = r4(), i6 = r4();
        return a4(function r5(n6) {
            for(var o5 = [], u5 = 1; u5 < arguments.length; u5++)o5[u5 - 1] = arguments[u5];
            if (D4(n6)) {
                var c5 = n6, f4 = (o5[0] === r5 || o5[0] === m4) && p4.test(c5[0]) && h4.test(c5[1]), y4 = f4 ? i6 : s6, E4 = y4.get(c5);
                if ((E4 || (E4 = l4(c5, f4, e15), y4.set(c5, E4)), 0 === o5.length)) return E4[0];
                var A3 = d4(E4, f4 ? o5.slice(1) : o5);
                return A3;
            }
            return t10(a4(a4({
            }, e15), n6 || {
            }));
        }, {
            string: function(t11) {
                return l4([
                    t11
                ], !1, e15)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    e14.outdent = m4, e14.default = m4;
    try {
        t10.exports = m4, Object.defineProperty(m4, "__esModule", {
            value: !0
        }), m4.default = m4, m4.outdent = m4;
    } catch (t) {
    }
});
const { outdent: ot2  } = tt1, ut2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: ot2(at()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: ot2(nt1())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (t10)=>"string" == typeof t10 || "function" == typeof t10
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (t10)=>"string" == typeof t10 || "object" == typeof t10
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: ot2(it()),
        exception: (t10)=>"string" == typeof t10 || "object" == typeof t10
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: ot2(rt1()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: ot2(st()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: ot2(et1()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const ht2 = {
    compare: $2,
    lt: Y1,
    gte: Q2
}, pt2 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: ut2
}.options;
var lt2 = {
    getSupportInfo: function({ plugins: t10 = [] , showUnreleased: e14 = !1 , showDeprecated: s5 = !1 , showInternal: r4 = !1  } = {
    }) {
        const i5 = Z3.split("-", 1)[0], n5 = t10.reduce((t11, e15)=>t11.concat(e15.languages || [])
        , []).filter(h4), a4 = (o4 = Object.assign({
        }, ...t10.map(({ options: t11  })=>t11
        ), pt2), u4 = "name", Object.entries(o4).map(([t11, e15])=>Object.assign({
                [u4]: t11
            }, e15)
        )).filter((t11)=>h4(t11) && c4(t11)
        ).sort((t11, e15)=>t11.name === e15.name ? 0 : t11.name < e15.name ? -1 : 1
        ).map(function(t11) {
            if (r4) return t11;
            return function(t12, e15) {
                if (null == t12) return {
                };
                var s6, r5, i6 = {
                }, n6 = Object.keys(t12);
                for(r5 = 0; r5 < n6.length; r5++)s6 = n6[r5], e15.indexOf(s6) >= 0 || (i6[s6] = t12[s6]);
                return i6;
            }(t11, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((e15)=>{
            e15 = Object.assign({
            }, e15), Array.isArray(e15.default) && (e15.default = 1 === e15.default.length ? e15.default[0].value : e15.default.filter(h4).sort((t11, e16)=>ht2.compare(e16.since, t11.since)
            )[0].value), Array.isArray(e15.choices) && (e15.choices = e15.choices.filter((t11)=>h4(t11) && c4(t11)
            ), "parser" === e15.name && (function(t11, e16, s6) {
                const r5 = new Set(t11.choices.map((t12)=>t12.value
                ));
                for (const i6 of e16)if (i6.parsers) for (const e17 of i6.parsers)if (!r5.has(e17)) {
                    r5.add(e17);
                    const n6 = s6.find((t12)=>t12.parsers && t12.parsers[e17]
                    );
                    let a5 = i6.name;
                    n6 && n6.name && (a5 += " (plugin: ".concat(n6.name, ")")), t11.choices.push({
                        value: e17,
                        description: a5
                    });
                }
            })(e15, n5, t10));
            const s6 = t10.filter((t11)=>t11.defaultOptions && (void 0) !== t11.defaultOptions[e15.name]
            ).reduce((t11, s7)=>(t11[s7.name] = s7.defaultOptions[e15.name], t11)
            , {
            });
            return Object.assign({
            }, e15, {
                pluginDefaults: s6
            });
        });
        var o4, u4;
        return {
            languages: n5,
            options: a4
        };
        function h4(t11) {
            return e14 || !("since" in t11) || t11.since && ht2.gte(i5, t11.since);
        }
        function c4(t11) {
            return s5 || !("deprecated" in t11) || t11.deprecated && ht2.lt(i5, t11.deprecated);
        }
    }
};
const { getSupportInfo: dt2  } = lt2, Dt2 = /[^\x20-\x7F]/;
var It2 = {
    inferParserByLanguage: function(t10, e14) {
        const { languages: s5  } = dt2({
            plugins: e14.plugins
        }), r4 = s5.find(({ name: e15  })=>e15.toLowerCase() === t10
        ) || s5.find(({ aliases: e15  })=>Array.isArray(e15) && e15.includes(t10)
        ) || s5.find(({ extensions: e15  })=>Array.isArray(e15) && e15.includes(".".concat(t10))
        );
        return r4 && r4.parsers[0];
    },
    replaceEndOfLineWith: function(t10, e14) {
        const s5 = [];
        for (const r4 of t10.split("\n"))0 !== s5.length && s5.push(e14), s5.push(r4);
        return s5;
    },
    getStringWidth: function(t10) {
        return t10 ? Dt2.test(t10) ? a2(t10) : t10.length : 0;
    },
    getMaxContinuousCount: function(t10, e14) {
        const s5 = t10.match(new RegExp("(".concat(u2(e14), ")+"), "g"));
        return null === s5 ? 0 : s5.reduce((t11, s6)=>Math.max(t11, s6.length / e14.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(t10, e14) {
        const s5 = t10.match(new RegExp("(".concat(u2(e14), ")+"), "g"));
        if (null === s5) return 0;
        const r4 = new Map;
        let i5 = 0;
        for (const t11 of s5){
            const s6 = t11.length / e14.length;
            r4.set(s6, !0), s6 > i5 && (i5 = s6);
        }
        for(let t12 = 1; t12 < i5; t12++)if (!r4.get(t12)) return t12;
        return i5 + 1;
    },
    getPenultimate: (t10)=>t10[t10.length - 2]
    ,
    getLast: (t10)=>t10[t10.length - 1]
    ,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Pt,
    getNextNonSpaceNonCommentCharacterIndex: Tt1,
    getNextNonSpaceNonCommentCharacter: function(t10, e14, s5) {
        return t10.charAt(Tt1(t10, e14, s5));
    },
    skip: mt1,
    skipWhitespace: ft,
    skipSpaces: yt1,
    skipToLineEnd: Et1,
    skipEverythingButNewLine: At1,
    skipInlineComment: Ct1,
    skipTrailingComment: xt1,
    skipNewline: Ft1,
    isNextLineEmptyAfterIndex: bt1,
    isNextLineEmpty: function(t10, e14, s5) {
        return bt1(t10, s5(e14));
    },
    isPreviousLineEmpty: function(t10, e14, s5) {
        let r4 = s5(e14) - 1;
        return (r4 = yt1(t10, r4, {
            backwards: !0
        }), r4 = Ft1(t10, r4, {
            backwards: !0
        }), r4 = yt1(t10, r4, {
            backwards: !0
        }), r4 !== Ft1(t10, r4, {
            backwards: !0
        }));
    },
    hasNewline: gt1,
    hasNewlineInRange: function(t10, e14, s5) {
        for(let r4 = e14; r4 < s5; ++r4)if ("\n" === t10.charAt(r4)) return !0;
        return !1;
    },
    hasSpaces: function(t10, e14, s5) {
        return yt1(t10, (s5 = s5 || {
        }).backwards ? e14 - 1 : e14, s5) !== e14;
    },
    getAlignmentSize: wt1,
    getIndentSize: function(t10, e14) {
        const s5 = t10.lastIndexOf("\n");
        return -1 === s5 ? 0 : wt1(t10.slice(s5 + 1).match(/^[\t ]*/)[0], e14);
    },
    getPreferredQuote: Bt1,
    printString: function(t10, e14, s5) {
        const r4 = t10.slice(1, -1), i5 = !r4.includes('"') && !r4.includes("'"), n5 = "json" === e14.parser ? '"' : e14.__isInHtmlAttribute ? "'" : Bt1(t10, e14.singleQuote ? "'" : '"');
        return s5 ? i5 ? n5 + r4 + n5 : t10 : St1(r4, n5, !("css" === e14.parser || "less" === e14.parser || "scss" === e14.parser || e14.embeddedInHtml));
    },
    printNumber: function(t10) {
        return t10.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(t10) {
        return "prettier-ignore" === t10.value.trim();
    },
    makeString: St1,
    addLeadingComment: function(t10, e14) {
        e14.leading = !0, e14.trailing = !1, Nt(t10, e14);
    },
    addDanglingComment: function(t10, e14, s5) {
        e14.leading = !1, e14.trailing = !1, s5 && (e14.marker = s5), Nt(t10, e14);
    },
    addTrailingComment: function(t10, e14) {
        e14.leading = !1, e14.trailing = !0, Nt(t10, e14);
    },
    isFrontMatterNode: function(t10) {
        return t10 && "front-matter" === t10.type;
    },
    getShebang: function(t10) {
        if (!t10.startsWith("#!")) return "";
        const e14 = t10.indexOf("\n");
        return -1 === e14 ? t10 : t10.slice(0, e14);
    }
}, vt1 = Object.freeze({
    __proto__: null,
    default: {
        EOL: "\n",
        platform: ()=>"browser"
        ,
        cpus: ()=>[
                {
                    model: "Prettier"
                }
            ]
    }
});
var Ot1 = _1(vt1), Mt2 = R1(function(t10, e14) {
    function s5() {
        const t11 = Ot1;
        return (s5 = function() {
            return Ot1;
        }, Ot1);
    }
    function r4() {
        const t11 = (e15 = Lt) && e15.__esModule ? e15 : {
            default: e15
        };
        var e15;
        return (r4 = function() {
            return t11;
        }, t11);
    }
    Object.defineProperty(e14, "__esModule", {
        value: !0
    }), e14.extract = function(t11) {
        const e15 = t11.match(a4);
        return e15 ? e15[0].trimLeft() : "";
    }, e14.strip = function(t11) {
        const e15 = t11.match(a4);
        return e15 && e15[0] ? t11.substring(e15[0].length) : t11;
    }, e14.parse = function(t11) {
        return d4(t11).pragmas;
    }, e14.parseWithComments = d4, e14.print = function({ comments: t11 = "" , pragmas: e15 = {
    }  }) {
        const i5 = r4().default(t11) || s5().EOL, n5 = " *", a4 = Object.keys(e15), o4 = a4.map((t12)=>D4(t12, e15[t12])
        ).reduce((t12, e16)=>t12.concat(e16)
        , []).map((t12)=>" * " + t12 + i5
        ).join("");
        if (!t11) {
            if (0 === a4.length) return "";
            if (1 === a4.length && !Array.isArray(e15[a4[0]])) {
                const t12 = e15[a4[0]];
                return "".concat("/**", " ").concat(D4(a4[0], t12)[0]).concat(" */");
            }
        }
        const u4 = t11.split(i5).map((t12)=>"".concat(n5, " ").concat(t12)
        ).join(i5) + i5;
        return "/**" + i5 + (t11 ? u4 : "") + (t11 && a4.length ? n5 + i5 : "") + o4 + " */";
    };
    const i5 = /\*\/$/, n5 = /^\/\*\*/, a4 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, o4 = /(^|\s+)\/\/([^\r\n]*)/g, u4 = /^(\r?\n)+/, h4 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, c4 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p4 = /(\r?\n|^) *\* ?/g, l4 = [];
    function d4(t11) {
        const e15 = r4().default(t11) || s5().EOL;
        t11 = t11.replace(n5, "").replace(i5, "").replace(p4, "$1");
        let a5 = "";
        for(; a5 !== t11;)a5 = t11, t11 = t11.replace(h4, "".concat(e15, "$1 $2").concat(e15));
        t11 = t11.replace(u4, "").trimRight();
        const d5 = Object.create(null), D4 = t11.replace(c4, "").replace(u4, "").trimRight();
        let m4;
        for(; m4 = c4.exec(t11);){
            const t12 = m4[2].replace(o4, "");
            "string" == typeof d5[m4[1]] || Array.isArray(d5[m4[1]]) ? d5[m4[1]] = l4.concat(d5[m4[1]], t12) : d5[m4[1]] = t12;
        }
        return {
            comments: D4,
            pragmas: d5
        };
    }
    function D4(t11, e15) {
        return l4.concat(e15).map((e16)=>"@".concat(t11, " ").concat(e16).trim()
        );
    }
});
const { parseWithComments: _t2 , strip: jt2 , extract: Ut2 , print: qt1  } = Mt2, { getShebang: Vt2  } = It2, { normalizeEndOfLine: zt1  } = Rt;
function Ht2(t10) {
    const e14 = Vt2(t10);
    e14 && (t10 = t10.slice(e14.length + 1));
    const s5 = Ut2(t10), { pragmas: r4 , comments: i5  } = _t2(s5);
    return {
        shebang: e14,
        text: t10,
        pragmas: r4,
        comments: i5
    };
}
var Wt2 = {
    hasPragma: function(t10) {
        const e14 = Object.keys(Ht2(t10).pragmas);
        return e14.includes("prettier") || e14.includes("format");
    },
    insertPragma: function(t10) {
        const { shebang: e14 , text: s5 , pragmas: r4 , comments: i5  } = Ht2(t10), n5 = jt2(s5), a4 = qt1({
            pragmas: Object.assign({
                format: ""
            }, r4),
            comments: i5.trimStart()
        });
        return (e14 ? "".concat(e14, "\n") : "") + zt1(a4) + (n5.startsWith("\n") ? "\n" : "\n\n") + n5;
    }
};
const Zt2 = R1(function(t10, e14) {
    e14.ast = $t1, e14.code = Yt1, e14.keyword = Qt1;
}).keyword.isIdentifierNameES5, { getLast: te1 , hasNewline: ee3 , hasNewlineInRange: se1 , skipWhitespace: re1  } = It2, { locStart: ie1 , locEnd: ne2 , hasSameLocStart: ae1  } = Jt1, oe1 = new RegExp("^".concat("(?:(?=.)\\s)", "*:")), ue1 = new RegExp("^".concat("(?:(?=.)\\s)", "*::"));
function xe2(t10) {
    return Ce1(t10) || ae1(t10, t10.value);
}
function Se1(t10, e14) {
    if (Ae1(e14)) return Ve1(e14);
    return e14.comments && e14.comments.some((e15)=>e15.leading && ee3(t10, ne2(e15))
    );
}
var He1 = {
    classChildNeedsASIProtection: function(t10) {
        if (t10) {
            if (t10.static || t10.accessibility) return !1;
            if (!t10.computed) {
                const e14 = t10.key && t10.key.name;
                if ("in" === e14 || "instanceof" === e14) return !0;
            }
            switch(t10.type){
                case "ClassProperty":
                case "FieldDefinition":
                case "TSAbstractClassProperty":
                    return t10.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod":
                    {
                        const e14 = t10.value ? t10.value.async : t10.async, s5 = t10.value ? t10.value.generator : t10.generator;
                        return !e14 && "get" !== t10.kind && "set" !== t10.kind && !(!t10.computed && !s5);
                    }
                case "TSIndexSignature":
                    return !0;
                default:
                    return !1;
            }
        }
    },
    classPropMayCauseASIProblems: function(t10) {
        const e14 = t10.getNode();
        if ("ClassProperty" !== e14.type && "FieldDefinition" !== e14.type) return !1;
        const s5 = e14.key && e14.key.name;
        return !("static" !== s5 && "get" !== s5 && "set" !== s5 || e14.value || e14.typeAnnotation) || void 0;
    },
    getFunctionParameters: je1,
    iterateFunctionParametersPath: function(t10, e14) {
        const s5 = t10.getValue();
        let r4 = 0;
        const i5 = (t11)=>e14(t11, r4++)
        ;
        s5.this && t10.call(i5, "this"), Array.isArray(s5.parameters) ? t10.each(i5, "parameters") : Array.isArray(s5.params) && t10.each(i5, "params"), s5.rest && t10.call(i5, "rest");
    },
    getCallArguments: function(t10) {
        if (Ue.has(t10)) return Ue.get(t10);
        const e14 = "ImportExpression" === t10.type ? [
            t10.source
        ] : t10.arguments;
        return (Ue.set(t10, e14), e14);
    },
    iterateCallArgumentsPath: function(t10, e14) {
        "ImportExpression" === t10.getValue().type ? t10.call((t11)=>e14(t11, 0)
        , "source") : t10.each(e14, "arguments");
    },
    hasRestParameter: function(t10) {
        if (t10.rest) return !0;
        const e14 = je1(t10);
        return e14.length > 0 && "RestElement" === te1(e14).type;
    },
    getLeftSidePathName: function(t10, e14) {
        if (e14.expressions) return [
            "expressions",
            0
        ];
        if (e14.left) return [
            "left"
        ];
        if (e14.test) return [
            "test"
        ];
        if (e14.object) return [
            "object"
        ];
        if (e14.callee) return [
            "callee"
        ];
        if (e14.tag) return [
            "tag"
        ];
        if (e14.argument) return [
            "argument"
        ];
        if (e14.expression) return [
            "expression"
        ];
        throw new Error("Unexpected node has no left side.");
    },
    getParentExportDeclaration: function(t10) {
        const e14 = t10.getParentNode();
        return "declaration" === t10.getName() && de1(e14) ? e14 : null;
    },
    getTypeScriptMappedTypeModifier: function(t10, e14) {
        return "+" === t10 ? "+" + e14 : "-" === t10 ? "-" + e14 : e14;
    },
    hasDanglingComments: function(t10) {
        return t10.comments && t10.comments.some((t11)=>!t11.leading && !t11.trailing
        );
    },
    hasFlowAnnotationComment: function(t10) {
        return t10 && pe1(t10[0]) && ue1.test(t10[0].value);
    },
    hasFlowShorthandAnnotationComment: function(t10) {
        return t10.extra && t10.extra.parenthesized && t10.trailingComments && pe1(t10.trailingComments[0]) && oe1.test(t10.trailingComments[0].value);
    },
    hasLeadingComment: function(t10) {
        return t10.comments && t10.comments.some((t11)=>t11.leading
        );
    },
    hasLeadingOwnLineComment: Se1,
    hasNakedLeftSide: ce1,
    hasNewlineBetweenOrAfterDecorators: function(t10, e14) {
        return se1(e14.originalText, ie1(t10.decorators[0]), ne2(te1(t10.decorators))) || ee3(e14.originalText, ne2(te1(t10.decorators)));
    },
    hasNgSideEffect: function(t10) {
        return he1(t10.getValue(), (t11)=>{
            switch(t11.type){
                case void 0:
                    return !1;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                    return !0;
            }
        });
    },
    hasNode: he1,
    hasPrettierIgnore: function(t10) {
        return ze(t10) || function(t11) {
            const e14 = t11.getValue(), s5 = t11.getParentNode();
            if (!(s5 && e14 && Ae1(e14) && Ae1(s5))) return !1;
            let r4 = null;
            for(let t12 = s5.children.indexOf(e14); t12 > 0; t12--){
                const e15 = s5.children[t12 - 1];
                if ("JSXText" !== e15.type || Be3(e15)) {
                    r4 = e15;
                    break;
                }
            }
            return r4 && "JSXExpressionContainer" === r4.type && "JSXEmptyExpression" === r4.expression.type && r4.expression.comments && r4.expression.comments.some((t13)=>qe1(t13)
            );
        }(t10);
    },
    hasTrailingComment: function(t10) {
        return t10.comments && t10.comments.some((t11)=>t11.trailing
        );
    },
    hasTrailingLineComment: function(t10) {
        return t10.comments && t10.comments.some((t11)=>t11.trailing && !pe1(t11)
        );
    },
    hasIgnoreComment: ze,
    hasNodeIgnoreComment: Ve1,
    identity: function(t10) {
        return t10;
    },
    isBinaryish: function(t10) {
        return Fe1.has(t10.type);
    },
    isBlockComment: pe1,
    isLineComment: function(t10) {
        return "Line" === t10.type || "CommentLine" === t10.type || "SingleLine" === t10.type || "HashbangComment" === t10.type || "HTMLOpen" === t10.type || "HTMLClose" === t10.type;
    },
    isPrettierIgnoreComment: qe1,
    isCallOrOptionalCallExpression: Pe1,
    isEmptyJSXElement: function(t10) {
        if (0 === t10.children.length) return !0;
        if (t10.children.length > 1) return !1;
        const e14 = t10.children[0];
        return De1(e14) && !Be3(e14);
    },
    isExportDeclaration: de1,
    isFlowAnnotationComment: function(t10, e14) {
        const s5 = ie1(e14), r4 = re1(t10, ne2(e14));
        return !1 !== r4 && "/*" === t10.slice(s5, s5 + 2) && "*/" === t10.slice(r4, r4 + 2);
    },
    isFunctionCompositionArgs: function(t10) {
        if (t10.length <= 1) return !1;
        let e14 = 0;
        for (const s5 of t10)if (ye1(s5)) {
            if ((e14 += 1, e14 > 1)) return !0;
        } else if (Pe1(s5)) for (const t11 of s5.arguments)if (ye1(t11)) return !0;
        return !1;
    },
    isFunctionNotation: xe2,
    isFunctionOrArrowExpression: ye1,
    isGetterOrSetter: Ce1,
    isJestEachTemplateLiteral: function(t10, e14) {
        const s5 = /^[fx]?(describe|it|test)$/;
        return "TaggedTemplateExpression" === e14.type && e14.quasi === t10 && "MemberExpression" === e14.tag.type && "Identifier" === e14.tag.property.type && "each" === e14.tag.property.name && ("Identifier" === e14.tag.object.type && s5.test(e14.tag.object.name) || "MemberExpression" === e14.tag.object.type && "Identifier" === e14.tag.object.property.type && ("only" === e14.tag.object.property.name || "skip" === e14.tag.object.property.name) && "Identifier" === e14.tag.object.object.type && s5.test(e14.tag.object.object.name));
    },
    isJSXNode: Ae1,
    isJSXWhitespaceExpression: function(t10) {
        return "JSXExpressionContainer" === t10.type && De1(t10.expression) && " " === t10.expression.value && !t10.expression.comments;
    },
    isLastStatement: function(t10) {
        const e14 = t10.getParentNode();
        if (!e14) return !0;
        const s5 = t10.getValue(), r4 = (e14.body || e14.consequent).filter((t11)=>"EmptyStatement" !== t11.type
        );
        return r4[r4.length - 1] === s5;
    },
    isLiteral: De1,
    isLongCurriedCallExpression: function(t10) {
        const e14 = t10.getValue(), s5 = t10.getParentNode();
        return Pe1(e14) && Pe1(s5) && s5.callee === e14 && e14.arguments.length > s5.arguments.length && s5.arguments.length > 0;
    },
    isSimpleCallArgument: function t10(e14, s5) {
        if (s5 >= 2) return !1;
        const r4 = (e15)=>t10(e15, s5 + 1)
        , i5 = "Literal" === e14.type && "regex" in e14 && e14.regex.pattern || "RegExpLiteral" === e14.type && e14.pattern;
        return !(i5 && i5.length > 5) && ("Literal" === e14.type || "BigIntLiteral" === e14.type || "DecimalLiteral" === e14.type || "BooleanLiteral" === e14.type || "NullLiteral" === e14.type || "NumericLiteral" === e14.type || "RegExpLiteral" === e14.type || "StringLiteral" === e14.type || "Identifier" === e14.type || "ThisExpression" === e14.type || "Super" === e14.type || "PrivateName" === e14.type || "ArgumentPlaceholder" === e14.type || "Import" === e14.type || ("TemplateLiteral" === e14.type ? e14.expressions.every(r4) : "ObjectExpression" === e14.type ? e14.properties.every((t11)=>!t11.computed && (t11.shorthand || t11.value && r4(t11.value))
        ) : "ArrayExpression" === e14.type ? e14.elements.every((t11)=>null === t11 || r4(t11)
        ) : "ImportExpression" === e14.type ? r4(e14.source) : "CallExpression" === e14.type || "OptionalCallExpression" === e14.type || "NewExpression" === e14.type ? t10(e14.callee, s5) && e14.arguments.every(r4) : "MemberExpression" === e14.type || "OptionalMemberExpression" === e14.type ? t10(e14.object, s5) && t10(e14.property, s5) : "UnaryExpression" !== e14.type || "!" !== e14.operator && "-" !== e14.operator ? "TSNonNullExpression" === e14.type && t10(e14.expression, s5) : t10(e14.argument, s5)));
    },
    isMeaningfulJSXText: Be3,
    isMemberExpressionChain: function t10(e14) {
        return ("MemberExpression" === e14.type || "OptionalMemberExpression" === e14.type) && ("Identifier" === e14.object.type || t10(e14.object));
    },
    isMemberish: function(t11) {
        return "MemberExpression" === t11.type || "OptionalMemberExpression" === t11.type || "BindExpression" === t11.type && Boolean(t11.object);
    },
    isNgForOf: function(t11, e14, s5) {
        return "NGMicrosyntaxKeyedExpression" === t11.type && "of" === t11.key.name && 1 === e14 && "NGMicrosyntaxLet" === s5.body[0].type && null === s5.body[0].value;
    },
    isNumericLiteral: me1,
    isObjectType: function(t11) {
        return "ObjectTypeAnnotation" === t11.type || "TSTypeLiteral" === t11.type;
    },
    isObjectTypePropertyAFunction: function(t11) {
        return !("ObjectTypeProperty" !== t11.type && "ObjectTypeInternalSlot" !== t11.type || "FunctionTypeAnnotation" !== t11.value.type || t11.static || xe2(t11));
    },
    isSimpleType: function(t11) {
        return !!t11 && (!("GenericTypeAnnotation" !== t11.type && "TSTypeReference" !== t11.type || t11.typeParameters) || !!ge1.has(t11.type));
    },
    isSimpleNumber: Ne1,
    isSimpleTemplateLiteral: function(t11) {
        let e14 = "expressions";
        "TSTemplateLiteralType" === t11.type && (e14 = "types");
        const s5 = t11[e14];
        return 0 !== s5.length && s5.every((t12)=>{
            if (t12.comments) return !1;
            if ("Identifier" === t12.type || "ThisExpression" === t12.type) return !0;
            if ("MemberExpression" === t12.type || "OptionalMemberExpression" === t12.type) {
                let e15 = t12;
                for(; "MemberExpression" === e15.type || "OptionalMemberExpression" === e15.type;){
                    if ("Identifier" !== e15.property.type && "Literal" !== e15.property.type && "StringLiteral" !== e15.property.type && "NumericLiteral" !== e15.property.type) return !1;
                    if (e15 = e15.object, e15.comments) return !1;
                }
                return "Identifier" === e15.type || "ThisExpression" === e15.type;
            }
            return !1;
        });
    },
    isStringLiteral: fe1,
    isStringPropSafeToUnquote: function(t11, e14) {
        return "json" !== e14.parser && fe1(t11.key) && ve1(t11.key).slice(1, -1) === t11.key.value && (Zt2(t11.key.value) && !(("typescript" === e14.parser || "babel-ts" === e14.parser) && "ClassProperty" === t11.type) || Ne1(t11.key.value) && String(Number(t11.key.value)) === t11.key.value && ("babel" === e14.parser || "espree" === e14.parser || "meriyah" === e14.parser));
    },
    isTemplateOnItsOwnLine: function(t11, e14) {
        return ("TemplateLiteral" === t11.type && Ie2(t11) || "TaggedTemplateExpression" === t11.type && Ie2(t11.quasi)) && !ee3(e14, ie1(t11), {
            backwards: !0
        });
    },
    isTestCall: function t10(e14, s5) {
        if ("CallExpression" !== e14.type) return !1;
        if (1 === e14.arguments.length) {
            if (Ee2(e14) && s5 && t10(s5)) return ye1(e14.arguments[0]);
            if ("Identifier" === (r4 = e14).callee.type && /^(before|after)(Each|All)$/.test(r4.callee.name) && 1 === r4.arguments.length) return Ee2(e14.arguments[0]);
        } else if ((2 === e14.arguments.length || 3 === e14.arguments.length) && ("Identifier" === e14.callee.type && be1.test(e14.callee.name) || function(t11) {
            return ("MemberExpression" === t11.callee.type || "OptionalMemberExpression" === t11.callee.type) && "Identifier" === t11.callee.object.type && "Identifier" === t11.callee.property.type && be1.test(t11.callee.object.name) && ("only" === t11.callee.property.name || "skip" === t11.callee.property.name);
        }(e14)) && (function(t11) {
            return "TemplateLiteral" === t11.type;
        }(e14.arguments[0]) || fe1(e14.arguments[0]))) return !(e14.arguments[2] && !me1(e14.arguments[2])) && ((2 === e14.arguments.length ? ye1(e14.arguments[1]) : function(t11) {
            return "FunctionExpression" === t11.type || "ArrowFunctionExpression" === t11.type && "BlockStatement" === t11.body.type;
        }(e14.arguments[1]) && je1(e14.arguments[1]).length <= 1) || Ee2(e14.arguments[1]));
        var r4;
        return !1;
    },
    isTheOnlyJSXElementInMarkdown: function(t11, e14) {
        if ("markdown" !== t11.parentParser && "mdx" !== t11.parentParser) return !1;
        const s5 = e14.getNode();
        if (!s5.expression || !Ae1(s5.expression)) return !1;
        const r4 = e14.getParentNode();
        return "Program" === r4.type && 1 === r4.body.length;
    },
    isTSXFile: function(t11) {
        return t11.filepath && /\.tsx$/i.test(t11.filepath);
    },
    isTypeAnnotationAFunction: function(t11) {
        return !("TypeAnnotation" !== t11.type && "TSTypeAnnotation" !== t11.type || "FunctionTypeAnnotation" !== t11.typeAnnotation.type || t11.static || ae1(t11, t11.typeAnnotation));
    },
    matchJsxWhitespaceRegex: Te1,
    needsHardlineAfterDanglingComment: function(t11) {
        if (!t11.comments) return !1;
        const e14 = te1(t11.comments.filter((t12)=>!t12.leading && !t12.trailing
        ));
        return e14 && !pe1(e14);
    },
    rawText: ve1,
    returnArgumentHasLeadingComment: function(t11, e14) {
        if (Se1(t11.originalText, e14)) return !0;
        if (ce1(e14)) {
            let r4, i5 = e14;
            for(; r4 = (s5 = i5).expressions ? s5.expressions[0] : s5.left || s5.test || s5.callee || s5.object || s5.tag || s5.argument || s5.expression;)if ((i5 = r4, Se1(t11.originalText, i5))) return !0;
        }
        var s5;
        return !1;
    },
    shouldPrintComma: function(t11, e14 = "es5") {
        return "es5" === t11.trailingComma && "es5" === e14 || "all" === t11.trailingComma && ("all" === e14 || "es5" === e14);
    },
    isBitwiseOperator: function(t11) {
        return !!Oe[t11] || "|" === t11 || "^" === t11 || "&" === t11;
    },
    shouldFlatten: function(t11, e14) {
        return Re2(e14) === Re2(t11) && ("**" !== t11 && ((!ke1[t11] || !ke1[e14]) && (!("%" === e14 && Le1[t11] || "%" === t11 && Le1[e14]) && ((e14 === t11 || !Le1[e14] || !Le1[t11]) && (!Oe[t11] || !Oe[e14])))));
    },
    startsWithNoLookaheadToken: function t10(e14, s5) {
        switch((e14 = function(t11) {
            for(; t11.left;)t11 = t11.left;
            return t11;
        }(e14)).type){
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
                return s5;
            case "ObjectExpression":
                return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
                return t10(e14.object, s5);
            case "TaggedTemplateExpression":
                return "FunctionExpression" !== e14.tag.type && t10(e14.tag, s5);
            case "CallExpression":
            case "OptionalCallExpression":
                return "FunctionExpression" !== e14.callee.type && t10(e14.callee, s5);
            case "ConditionalExpression":
                return t10(e14.test, s5);
            case "UpdateExpression":
                return !e14.prefix && t10(e14.argument, s5);
            case "BindExpression":
                return e14.object && t10(e14.object, s5);
            case "SequenceExpression":
                return t10(e14.expressions[0], s5);
            case "TSAsExpression":
                return t10(e14.expression, s5);
            default:
                return !1;
        }
    },
    getPrecedence: Re2
};
const { getLast: We1 , hasNewline: Ge2 , getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Xe1 , getNextNonSpaceNonCommentCharacter: Ke2 , hasNewlineInRange: Je2 , addLeadingComment: $e2 , addTrailingComment: Ye2 , addDanglingComment: Qe1 , getNextNonSpaceNonCommentCharacterIndex: Ze2  } = It2, { isBlockComment: ts1 , getFunctionParameters: es1 , isPrettierIgnoreComment: ss1 , isJSXNode: rs1 , hasFlowShorthandAnnotationComment: is1 , hasFlowAnnotationComment: ns1 , hasIgnoreComment: as1  } = He1, { locStart: os1 , locEnd: us1  } = Jt1;
function hs1(t10, e14) {
    const s5 = (t10.body || t10.properties).find(({ type: t11  })=>"EmptyStatement" !== t11
    );
    s5 ? $e2(s5, e14) : Qe1(t10, e14);
}
function cs1(t10, e14) {
    "BlockStatement" === t10.type ? hs1(t10, e14) : $e2(t10, e14);
}
function ps1(t10, e14) {
    const { precedingNode: s5 , enclosingNode: r4 , followingNode: i5  } = t10;
    if (!r4 || "IfStatement" !== r4.type || !i5) return !1;
    return ")" === Ke2(e14, t10, us1) ? (Ye2(s5, t10), !0) : s5 === r4.consequent && i5 === r4.alternate ? ("BlockStatement" === s5.type ? Ye2(s5, t10) : Qe1(r4, t10), !0) : "BlockStatement" === i5.type ? (hs1(i5, t10), !0) : "IfStatement" === i5.type ? (cs1(i5.consequent, t10), !0) : r4.consequent === i5 && ($e2(i5, t10), !0);
}
function ls1(t10, e14) {
    const { precedingNode: s5 , enclosingNode: r4 , followingNode: i5  } = t10;
    if (!r4 || "WhileStatement" !== r4.type || !i5) return !1;
    return ")" === Ke2(e14, t10, us1) ? (Ye2(s5, t10), !0) : "BlockStatement" === i5.type ? (hs1(i5, t10), !0) : r4.body === i5 && ($e2(i5, t10), !0);
}
function ds1(t10) {
    const { precedingNode: e14 , enclosingNode: s5 , followingNode: r4  } = t10;
    return !(!s5 || "TryStatement" !== s5.type && "CatchClause" !== s5.type || !r4) && ("CatchClause" === s5.type && e14 ? (Ye2(e14, t10), !0) : "BlockStatement" === r4.type ? (hs1(r4, t10), !0) : "TryStatement" === r4.type ? (cs1(r4.finalizer, t10), !0) : "CatchClause" === r4.type && (cs1(r4.body, t10), !0));
}
function Ds1(t10) {
    const { precedingNode: e14 , enclosingNode: s5 , followingNode: r4  } = t10;
    if (s5 && ("ClassDeclaration" === s5.type || "ClassExpression" === s5.type || "DeclareClass" === s5.type || "DeclareInterface" === s5.type || "InterfaceDeclaration" === s5.type || "TSInterfaceDeclaration" === s5.type)) {
        if (s5.decorators && s5.decorators.length > 0 && (!r4 || "Decorator" !== r4.type)) return Ye2(s5.decorators[s5.decorators.length - 1], t10), !0;
        if (s5.body && r4 === s5.body) return hs1(s5.body, t10), !0;
        if (r4) for (const i5 of [
            "implements",
            "extends",
            "mixins"
        ])if (s5[i5] && r4 === s5[i5][0]) return !e14 || e14 !== s5.id && e14 !== s5.typeParameters && e14 !== s5.superClass ? Qe1(s5, t10, i5) : Ye2(e14, t10), !0;
    }
    return !1;
}
function ms1(t10, e14) {
    const { precedingNode: s5 , enclosingNode: r4  } = t10;
    return (r4 && s5 && ("Property" === r4.type || "TSDeclareMethod" === r4.type || "TSAbstractMethodDefinition" === r4.type) && "Identifier" === s5.type && r4.key === s5 && ":" !== Ke2(e14, s5, us1) || !(!s5 || !r4 || "Decorator" !== s5.type || "ClassMethod" !== r4.type && "ClassProperty" !== r4.type && "FieldDefinition" !== r4.type && "TSAbstractClassProperty" !== r4.type && "TSAbstractMethodDefinition" !== r4.type && "TSDeclareMethod" !== r4.type && "MethodDefinition" !== r4.type)) && (Ye2(s5, t10), !0);
}
function fs1(t10, e14) {
    const { precedingNode: s5 , enclosingNode: r4 , followingNode: i5  } = t10;
    if (s5 && "FunctionTypeParam" === s5.type && r4 && "FunctionTypeAnnotation" === r4.type && i5 && "FunctionTypeParam" !== i5.type) return Ye2(s5, t10), !0;
    if (s5 && ("Identifier" === s5.type || "AssignmentPattern" === s5.type) && r4 && xs(r4) && ")" === Ke2(e14, t10, us1)) return Ye2(s5, t10), !0;
    if (r4 && "FunctionDeclaration" === r4.type && i5 && "BlockStatement" === i5.type) {
        const s6 = (()=>{
            const t11 = es1(r4);
            if (0 !== t11.length) return Xe1(e14, us1(We1(t11)));
            const s7 = Xe1(e14, us1(r4.id));
            return !1 !== s7 && Xe1(e14, s7 + 1);
        })();
        if (os1(t10) > s6) return hs1(i5, t10), !0;
    }
    return !1;
}
function ys1(t10) {
    const { enclosingNode: e14  } = t10;
    return !(!e14 || "ImportSpecifier" !== e14.type) && ($e2(e14, t10), !0);
}
function Es1(t10) {
    const { enclosingNode: e14  } = t10;
    return !(!e14 || "LabeledStatement" !== e14.type) && ($e2(e14, t10), !0);
}
function As1(t10, e14, s5) {
    const { enclosingNode: r4  } = t10;
    return e14 && e14.body && 0 === e14.body.length ? (s5 ? Qe1(e14, t10) : $e2(e14, t10), !0) : !(!r4 || "Program" !== r4.type || 0 !== r4.body.length || !r4.directives || 0 !== r4.directives.length) && (s5 ? Qe1(r4, t10) : $e2(r4, t10), !0);
}
function Cs1(t10) {
    const { enclosingNode: e14 , followingNode: s5  } = t10;
    if (ss1(t10) && e14 && "TSMappedType" === e14.type && s5 && "TSTypeParameter" === s5.type && s5.constraint) return e14.prettierIgnore = !0, t10.unignore = !0, !0;
}
function Fs(t10) {
    return ts1(t10) && "*" === t10.value[0] && /@type\b/.test(t10.value);
}
var gs1 = {
    handleOwnLineComment: function(t10, e14, s5, r4, i5) {
        return Cs1(t10) || fs1(t10, e14) || function(t11) {
            const { enclosingNode: e15 , followingNode: s6  } = t11;
            if (e15 && ("MemberExpression" === e15.type || "OptionalMemberExpression" === e15.type) && s6 && "Identifier" === s6.type) return $e2(e15, t11), !0;
            return !1;
        }(t10) || ps1(t10, e14) || ls1(t10, e14) || ds1(t10) || Ds1(t10) || ys1(t10) || function(t11) {
            const { enclosingNode: e15  } = t11;
            if (e15 && ("ForInStatement" === e15.type || "ForOfStatement" === e15.type)) return $e2(e15, t11), !0;
            return !1;
        }(t10) || function(t11) {
            const { precedingNode: e15 , enclosingNode: s6 , followingNode: r5  } = t11;
            if (s6 && ("UnionTypeAnnotation" === s6.type || "TSUnionType" === s6.type)) return ss1(t11) && (r5.prettierIgnore = !0, t11.unignore = !0), !!e15 && (Ye2(e15, t11), !0);
            r5 && ("UnionTypeAnnotation" === r5.type || "TSUnionType" === r5.type) && ss1(t11) && (r5.types[0].prettierIgnore = !0, t11.unignore = !0);
            return !1;
        }(t10) || As1(t10, r4, i5) || function(t11, e15) {
            const { precedingNode: s6 , enclosingNode: r5  } = t11;
            if (s6 && "ImportSpecifier" === s6.type && r5 && "ImportDeclaration" === r5.type && Ge2(e15, us1(t11))) return Ye2(s6, t11), !0;
            return !1;
        }(t10, e14) || function(t11) {
            const { enclosingNode: e15  } = t11;
            if (e15 && "AssignmentPattern" === e15.type) return $e2(e15, t11), !0;
            return !1;
        }(t10) || ms1(t10, e14) || Es1(t10);
    },
    handleEndOfLineComment: function(t10, e14, s5, r4, i5) {
        return function(t11) {
            const { followingNode: e15  } = t11;
            if (e15 && Fs(t11)) return $e2(e15, t11), !0;
            return !1;
        }(t10) || fs1(t10, e14) || function(t11, e15) {
            const { precedingNode: s6 , enclosingNode: r5 , followingNode: i6  } = t11, n5 = s6 && !Je2(e15, us1(s6), os1(t11));
            if ((!s6 || !n5) && r5 && ("ConditionalExpression" === r5.type || "TSConditionalType" === r5.type) && i6) return $e2(i6, t11), !0;
            return !1;
        }(t10, e14) || ys1(t10) || ps1(t10, e14) || ls1(t10, e14) || ds1(t10) || Ds1(t10) || Es1(t10) || function(t11) {
            const { precedingNode: e15 , enclosingNode: s6  } = t11;
            if (s6 && ("CallExpression" === s6.type || "OptionalCallExpression" === s6.type) && e15 && s6.callee === e15 && s6.arguments.length > 0) return $e2(s6.arguments[0], t11), !0;
            return !1;
        }(t10) || function(t11) {
            const { enclosingNode: e15  } = t11;
            if (e15 && ("Property" === e15.type || "ObjectProperty" === e15.type)) return $e2(e15, t11), !0;
            return !1;
        }(t10) || As1(t10, r4, i5) || function(t11) {
            const { enclosingNode: e15  } = t11;
            if (e15 && "TypeAlias" === e15.type) return $e2(e15, t11), !0;
            return !1;
        }(t10) || function(t11) {
            const { enclosingNode: e15 , followingNode: s6  } = t11;
            if (e15 && ("VariableDeclarator" === e15.type || "AssignmentExpression" === e15.type) && s6 && ("ObjectExpression" === s6.type || "ArrayExpression" === s6.type || "TemplateLiteral" === s6.type || "TaggedTemplateExpression" === s6.type || ts1(t11))) return $e2(s6, t11), !0;
            return !1;
        }(t10);
    },
    handleRemainingComment: function(t10, e14, s5, r4, i5) {
        return !!(Cs1(t10) || ps1(t10, e14) || ls1(t10, e14) || function(t11) {
            const { precedingNode: e15 , enclosingNode: s6  } = t11;
            if (s6 && ("ObjectProperty" === s6.type || "Property" === s6.type) && s6.shorthand && s6.key === e15 && "AssignmentPattern" === s6.value.type) return Ye2(s6.value.left, t11), !0;
            return !1;
        }(t10) || function(t11, e15) {
            if (")" !== Ke2(e15, t11, us1)) return !1;
            const { enclosingNode: s6  } = t11;
            if (s6 && (xs(s6) && 0 === es1(s6).length || ("CallExpression" === s6.type || "OptionalCallExpression" === s6.type || "NewExpression" === s6.type) && 0 === s6.arguments.length)) return Qe1(s6, t11), !0;
            if (s6 && "MethodDefinition" === s6.type && 0 === es1(s6.value).length) return Qe1(s6.value, t11), !0;
            return !1;
        }(t10, e14) || ms1(t10, e14) || As1(t10, r4, i5) || function(t11, e15) {
            const { enclosingNode: s6  } = t11;
            if (!s6 || "ArrowFunctionExpression" !== s6.type) return !1;
            const r5 = Ze2(e15, t11, us1);
            if (!1 !== r5 && "=>" === e15.slice(r5, r5 + 2)) return Qe1(s6, t11), !0;
            return !1;
        }(t10, e14) || function(t11, e15) {
            if ("(" !== Ke2(e15, t11, us1)) return !1;
            const { precedingNode: s6 , enclosingNode: r5  } = t11;
            if (s6 && r5 && ("FunctionDeclaration" === r5.type || "FunctionExpression" === r5.type || "ClassMethod" === r5.type || "MethodDefinition" === r5.type || "ObjectMethod" === r5.type)) return Ye2(s6, t11), !0;
            return !1;
        }(t10, e14) || function(t11) {
            const { precedingNode: e15 , enclosingNode: s6 , followingNode: r5  } = t11;
            if (!s6 || "TSMappedType" !== s6.type) return !1;
            if (r5 && "TSTypeParameter" === r5.type && r5.name) return $e2(r5.name, t11), !0;
            if (e15 && "TSTypeParameter" === e15.type && e15.constraint) return Ye2(e15.constraint, t11), !0;
            return !1;
        }(t10) || function(t11) {
            const { enclosingNode: e15  } = t11;
            if (e15 && ("ContinueStatement" === e15.type || "BreakStatement" === e15.type) && !e15.label) return Ye2(e15, t11), !0;
            return !1;
        }(t10) || function(t11, e15) {
            const { enclosingNode: s6 , followingNode: r5  } = t11;
            if (!r5 && s6 && ("TSMethodSignature" === s6.type || "TSDeclareFunction" === s6.type || "TSAbstractMethodDefinition" === s6.type) && ";" === Ke2(e15, t11, us1)) return Ye2(s6, t11), !0;
            return !1;
        }(t10, e14));
    },
    hasLeadingComment: function(t10, e14 = ()=>!0
    ) {
        return t10.leadingComments ? t10.leadingComments.some(e14) : !!t10.comments && t10.comments.some((t11)=>t11.leading && e14(t11)
        );
    },
    isTypeCastComment: Fs,
    getGapRegex: function(t10) {
        if (t10 && "BinaryExpression" !== t10.type && "LogicalExpression" !== t10.type) return /^[\s&(|]*$/;
    },
    getCommentChildNodes: function(t10, e14) {
        if (("typescript" === e14.parser || "flow" === e14.parser || "espree" === e14.parser || "meriyah" === e14.parser) && "MethodDefinition" === t10.type && t10.value && "FunctionExpression" === t10.value.type && 0 === es1(t10.value).length && !t10.value.returnType && (!t10.value.typeParameters || 0 === t10.value.typeParameters.length) && t10.value.body) return [
            ...t10.decorators || [],
            t10.key,
            t10.value.body
        ];
    },
    willPrintOwnComments: function(t10) {
        const e14 = t10.getValue(), s5 = t10.getParentNode();
        return (e14 && (rs1(e14) || is1(e14) || s5 && ("CallExpression" === s5.type || "OptionalCallExpression" === s5.type) && (ns1(e14.leadingComments) || ns1(e14.trailingComments))) || s5 && ("JSXSpreadAttribute" === s5.type || "JSXSpreadChild" === s5.type || "UnionTypeAnnotation" === s5.type || "TSUnionType" === s5.type || ("ClassDeclaration" === s5.type || "ClassExpression" === s5.type) && s5.superClass === e14)) && (!as1(t10) || "UnionTypeAnnotation" === s5.type || "TSUnionType" === s5.type);
    }
};
const { getLast: bs1 , getNextNonSpaceNonCommentCharacter: Ps1 , getShebang: Ts1  } = It2, { composeLoc: ws1 , locStart: Bs1 , locEnd: Ss1  } = Jt1, { isTypeCastComment: Ns1  } = gs1;
function Ls1(t10) {
    return ks(t10) ? Ls1({
        type: "LogicalExpression",
        operator: t10.operator,
        left: Ls1({
            type: "LogicalExpression",
            operator: t10.operator,
            left: t10.left,
            right: t10.right.left,
            range: ws1(t10.left, t10.right.left)
        }),
        right: t10.right.right,
        range: ws1(t10)
    }) : t10;
}
var Os1 = function(e14, s5) {
    if (("typescript" !== s5.parser && "flow" !== s5.parser && "espree" !== s5.parser || function(t10, e15) {
        const s6 = Ts1(e15.originalText);
        s6 && t10.comments.unshift({
            type: "Line",
            value: s6.slice(2),
            range: [
                0,
                s6.length
            ]
        });
    }(e14, s5), "typescript" === s5.parser && s5.originalText.includes("@"))) {
        const { esTreeNodeToTSNodeMap: r4 , tsNodeToESTreeNodeMap: i5  } = s5.tsParseResult;
        e14 = vs(e14, (e15)=>{
            const s6 = r4.get(e15);
            if (!s6) return;
            const n5 = s6.decorators;
            if (!Array.isArray(n5)) return;
            const a4 = i5.get(s6);
            if (a4 !== e15) return;
            const o4 = a4.decorators;
            if (!Array.isArray(o4) || o4.length !== n5.length || n5.some((t10)=>{
                const e16 = i5.get(t10);
                return !e16 || !o4.includes(e16);
            })) {
                const { start: e16 , end: s7  } = a4.loc;
                throw t1("Leading decorators must be attached to a class declaration", {
                    start: {
                        line: e16.line,
                        column: e16.column + 1
                    },
                    end: {
                        line: s7.line,
                        column: s7.column + 1
                    }
                });
            }
        });
    }
    if ("typescript" !== s5.parser && "flow" !== s5.parser && "espree" !== s5.parser && "meriyah" !== s5.parser) {
        const t10 = new Set;
        e14 = vs(e14, (e15)=>{
            e15.leadingComments && e15.leadingComments.some(Ns1) && t10.add(Bs1(e15));
        }), e14 = vs(e14, (e15)=>{
            if ("ParenthesizedExpression" === e15.type) {
                const { expression: s6  } = e15;
                if ("TypeCastExpression" === s6.type) return s6.range = e15.range, s6;
                const r4 = Bs1(e15);
                if (!t10.has(r4)) return s6.extra = Object.assign({
                }, s6.extra, {
                    parenthesized: !0
                }), s6;
            }
        });
    }
    return e14 = vs(e14, (t10)=>{
        switch(t10.type){
            case "ChainExpression":
                return Is(t10.expression);
            case "LogicalExpression":
                if (ks(t10)) return Ls1(t10);
                break;
            case "VariableDeclaration":
                {
                    const e15 = bs1(t10.declarations);
                    e15 && e15.init && (function(t11, e16) {
                        if (";" === s5.originalText[Ss1(e16)]) return;
                        t11.range = ws1(t11, e16);
                    })(t10, e15);
                    break;
                }
            case "TSParenthesizedType":
                return t10.typeAnnotation.range = ws1(t10), t10.typeAnnotation;
            case "TSUnionType":
            case "TSIntersectionType":
                if (1 === t10.types.length) {
                    const [e15] = t10.types;
                    return e15.range = ws1(t10), e15;
                }
                break;
            case "TSTypeParameter":
                "string" == typeof t10.name && (t10.name = {
                    type: "Identifier",
                    name: t10.name,
                    range: ws1(t10, t10.name.length)
                });
                break;
            case "SequenceExpression":
                {
                    const e15 = bs1(t10.expressions);
                    Ss1(t10) > Ss1(e15) && (t10.range = ws1(t10, e15));
                    break;
                }
            case "ClassProperty":
                t10.key && "TSPrivateIdentifier" === t10.key.type && "?" === Ps1(s5.originalText, t10.key, Ss1) && (t10.optional = !0);
        }
    });
}, Ms1 = R1(function(t10, e14) {
    Object.defineProperty(e14, "__esModule", {
        value: !0
    });
    const s5 = !0, r4 = !0, i5 = !0, n5 = !0;
    class a4 {
        constructor(t11, e15 = {
        }){
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = t11, this.keyword = e15.keyword, this.beforeExpr = !!e15.beforeExpr, this.startsExpr = !!e15.startsExpr, this.rightAssociative = !!e15.rightAssociative, this.isLoop = !!e15.isLoop, this.isAssign = !!e15.isAssign, this.prefix = !!e15.prefix, this.postfix = !!e15.postfix, this.binop = null != e15.binop ? e15.binop : null, this.updateContext = null;
        }
    }
    const o4 = new Map;
    function u4(t12, e16 = {
    }) {
        e16.keyword = t12;
        const s6 = new a4(t12, e16);
        return (o4.set(t12, s6), s6);
    }
    function h4(t12, e16) {
        return new a4(t12, {
            beforeExpr: s5,
            binop: e16
        });
    }
    const c4 = {
        num: new a4("num", {
            startsExpr: r4
        }),
        bigint: new a4("bigint", {
            startsExpr: r4
        }),
        decimal: new a4("decimal", {
            startsExpr: r4
        }),
        regexp: new a4("regexp", {
            startsExpr: r4
        }),
        string: new a4("string", {
            startsExpr: r4
        }),
        name: new a4("name", {
            startsExpr: r4
        }),
        eof: new a4("eof"),
        bracketL: new a4("[", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        bracketHashL: new a4("#[", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        bracketBarL: new a4("[|", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        bracketR: new a4("]"),
        bracketBarR: new a4("|]"),
        braceL: new a4("{", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        braceBarL: new a4("{|", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        braceHashL: new a4("#{", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        braceR: new a4("}"),
        braceBarR: new a4("|}"),
        parenL: new a4("(", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        parenR: new a4(")"),
        comma: new a4(",", {
            beforeExpr: s5
        }),
        semi: new a4(";", {
            beforeExpr: s5
        }),
        colon: new a4(":", {
            beforeExpr: s5
        }),
        doubleColon: new a4("::", {
            beforeExpr: s5
        }),
        dot: new a4("."),
        question: new a4("?", {
            beforeExpr: s5
        }),
        questionDot: new a4("?."),
        arrow: new a4("=>", {
            beforeExpr: s5
        }),
        template: new a4("template"),
        ellipsis: new a4("...", {
            beforeExpr: s5
        }),
        backQuote: new a4("`", {
            startsExpr: r4
        }),
        dollarBraceL: new a4("${", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        at: new a4("@"),
        hash: new a4("#", {
            startsExpr: r4
        }),
        interpreterDirective: new a4("#!..."),
        eq: new a4("=", {
            beforeExpr: s5,
            isAssign: true
        }),
        assign: new a4("_=", {
            beforeExpr: s5,
            isAssign: true
        }),
        incDec: new a4("++/--", {
            prefix: n5,
            postfix: !0,
            startsExpr: r4
        }),
        bang: new a4("!", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        }),
        tilde: new a4("~", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        }),
        pipeline: h4("|>", 0),
        nullishCoalescing: h4("??", 1),
        logicalOR: h4("||", 1),
        logicalAND: h4("&&", 2),
        bitwiseOR: h4("|", 3),
        bitwiseXOR: h4("^", 4),
        bitwiseAND: h4("&", 5),
        equality: h4("==/!=/===/!==", 6),
        relational: h4("</>/<=/>=", 7),
        bitShift: h4("<</>>/>>>", 8),
        plusMin: new a4("+/-", {
            beforeExpr: s5,
            binop: 9,
            prefix: n5,
            startsExpr: r4
        }),
        modulo: new a4("%", {
            beforeExpr: s5,
            binop: 10,
            startsExpr: r4
        }),
        star: new a4("*", {
            binop: 10
        }),
        slash: h4("/", 10),
        exponent: new a4("**", {
            beforeExpr: s5,
            binop: 11,
            rightAssociative: !0
        }),
        _break: u4("break"),
        _case: u4("case", {
            beforeExpr: s5
        }),
        _catch: u4("catch"),
        _continue: u4("continue"),
        _debugger: u4("debugger"),
        _default: u4("default", {
            beforeExpr: s5
        }),
        _do: u4("do", {
            isLoop: i5,
            beforeExpr: s5
        }),
        _else: u4("else", {
            beforeExpr: s5
        }),
        _finally: u4("finally"),
        _for: u4("for", {
            isLoop: i5
        }),
        _function: u4("function", {
            startsExpr: r4
        }),
        _if: u4("if"),
        _return: u4("return", {
            beforeExpr: s5
        }),
        _switch: u4("switch"),
        _throw: u4("throw", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        }),
        _try: u4("try"),
        _var: u4("var"),
        _const: u4("const"),
        _while: u4("while", {
            isLoop: i5
        }),
        _with: u4("with"),
        _new: u4("new", {
            beforeExpr: s5,
            startsExpr: r4
        }),
        _this: u4("this", {
            startsExpr: r4
        }),
        _super: u4("super", {
            startsExpr: r4
        }),
        _class: u4("class", {
            startsExpr: r4
        }),
        _extends: u4("extends", {
            beforeExpr: s5
        }),
        _export: u4("export"),
        _import: u4("import", {
            startsExpr: r4
        }),
        _null: u4("null", {
            startsExpr: r4
        }),
        _true: u4("true", {
            startsExpr: r4
        }),
        _false: u4("false", {
            startsExpr: r4
        }),
        _in: u4("in", {
            beforeExpr: s5,
            binop: 7
        }),
        _instanceof: u4("instanceof", {
            beforeExpr: s5,
            binop: 7
        }),
        _typeof: u4("typeof", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        }),
        _void: u4("void", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        }),
        _delete: u4("delete", {
            beforeExpr: s5,
            prefix: n5,
            startsExpr: r4
        })
    }, p4 = 128, l4 = 128, d4 = 1024, D4 = 64, m4 = /\r\n?|[\n\u2028\u2029]/, f4 = new RegExp(m4.source, "g");
    function y4(t12) {
        switch(t12){
            case 10:
            case 13:
            case 8232:
            case 8233:
                return !0;
            default:
                return !1;
        }
    }
    const E4 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    function A3(t12) {
        switch(t12){
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
                return !0;
            default:
                return !1;
        }
    }
    class C4 {
        constructor(t12, e16){
            this.line = void 0, this.column = void 0, this.line = t12, this.column = e16;
        }
    }
    class x4 {
        constructor(t13, e17){
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t13, this.end = e17;
        }
    }
    function F3(t14) {
        return t14[t14.length - 1];
    }
    const g4 = Object.freeze({
        AccessorIsGenerator: "A %0ter cannot be a generator",
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
        AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions",
        BadGetterArity: "getter must not have any formal parameters",
        BadSetterArity: "setter must have exactly one formal parameter",
        BadSetterRestParameter: "setter function argument must not be a rest parameter",
        ConstructorClassField: "Classes may not have a field named 'constructor'",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
        ConstructorIsAccessor: "Class constructor may not be an accessor",
        ConstructorIsAsync: "Constructor can't be an async function",
        ConstructorIsGenerator: "Constructor can't be a generator",
        DeclarationMissingInitializer: "%0 require an initialization value",
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon",
        DecoratorStaticBlock: "Decorators can't be used with a static block",
        DeletePrivateField: "Deleting a private field is not allowed",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
        DuplicateProto: "Redefinition of __proto__ property",
        DuplicateRegExpFlags: "Duplicate regular expression flag",
        DuplicateStaticBlock: "Duplicate static block in the same class",
        ElementAfterRest: "Rest element must be last element",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape",
        ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { %0 as '%1' } from 'some-module'`?",
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
        ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
        IllegalBreakContinue: "Unsyntactic %0",
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
        IllegalReturn: "'return' outside of function",
        ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
        ImportCallArity: "import() requires exactly %0",
        ImportCallNotNewExpression: "Cannot use new with import(...)",
        ImportCallSpreadArgument: "... is not allowed in import()",
        ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
        ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
        InvalidBigIntLiteral: "Invalid BigIntLiteral",
        InvalidCodePoint: "Code point out of bounds",
        InvalidDecimal: "Invalid decimal",
        InvalidDigit: "Expected number in radix %0",
        InvalidEscapeSequence: "Bad character escape sequence",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
        InvalidEscapedReservedWord: "Escape sequence in keyword %0",
        InvalidIdentifier: "Invalid identifier %0",
        InvalidLhs: "Invalid left-hand side in %0",
        InvalidLhsBinding: "Binding invalid left-hand side in %0",
        InvalidNumber: "Invalid number",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'",
        InvalidOrUnexpectedToken: "Unexpected character '%0'",
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
        InvalidPrivateFieldResolution: "Private name #%0 is not defined",
        InvalidPropertyBindingPattern: "Binding member expression",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument",
        LabelRedeclaration: "Label '%0' is already declared",
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
        MalformedRegExpFlags: "Invalid regular expression flag",
        MissingClassName: "A class name is required",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
        ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
        ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'",
        ModuleExportUndefined: "Export '%0' is not defined",
        MultipleDefaultsInSwitch: "Multiple default clauses",
        NewlineAfterThrow: "Illegal newline after throw",
        NoCatchOrFinally: "Missing catch or finally clause",
        NumberIdentifier: "Identifier directly after number",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
        ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
        ParamDupe: "Argument name clash",
        PatternHasAccessor: "Object pattern can't contain getter or setter",
        PatternHasMethod: "Object pattern can't contain methods",
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
        PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
        PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
        PrivateNameRedeclaration: "Duplicate private name #%0",
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
        RecordNoProto: "'__proto__' is not allowed in Record expressions",
        RestTrailingComma: "Unexpected trailing comma after rest element",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
        StaticPrototype: "Classes may not have static property named prototype",
        StrictDelete: "Deleting local variable in strict mode",
        StrictEvalArguments: "Assigning to '%0' in strict mode",
        StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
        StrictWith: "'with' in strict mode",
        SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super",
        TrailingDecorator: "Decorators must be attached to a class element",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
        UnexpectedKeyword: "Unexpected keyword '%0'",
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
        UnexpectedNewTarget: "new.target can only be used in functions",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
        UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
        UnexpectedReservedWord: "Unexpected reserved word '%0'",
        UnexpectedSuper: "super is only allowed in object methods and classes",
        UnexpectedToken: "Unexpected token '%0'",
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "import can only be used in import() or import.meta",
        UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
        UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
        UnterminatedComment: "Unterminated comment",
        UnterminatedRegExp: "Unterminated regular expression",
        UnterminatedString: "Unterminated string constant",
        UnterminatedTemplate: "Unterminated template",
        VarRedeclaration: "Identifier '%0' has already been declared",
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
        YieldInParameter: "Yield expression is not allowed in formal parameters",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
    });
    function b3(t14) {
        return null != t14 && "Property" === t14.type && "init" === t14.kind && !1 === t14.method;
    }
    class P2 {
        constructor(t14, e18, s6, r5){
            this.token = void 0, this.isExpr = void 0, this.preserveSpace = void 0, this.override = void 0, this.token = t14, this.isExpr = !!e18, this.preserveSpace = !!s6, this.override = r5;
        }
    }
    const T4 = {
        braceStatement: new P2("{", !1),
        braceExpression: new P2("{", !0),
        recordExpression: new P2("#{", !0),
        templateQuasi: new P2("${", !1),
        parenStatement: new P2("(", !1),
        parenExpression: new P2("(", !0),
        template: new P2("`", !0, !0, (t15)=>t15.readTmplToken()
        ),
        functionExpression: new P2("function", !0),
        functionStatement: new P2("function", !1)
    };
    c4.parenR.updateContext = c4.braceR.updateContext = function() {
        if (1 === this.state.context.length) return void (this.state.exprAllowed = !0);
        let t15 = this.state.context.pop();
        t15 === T4.braceStatement && "function" === this.curContext().token && (t15 = this.state.context.pop()), this.state.exprAllowed = !t15.isExpr;
    }, c4.name.updateContext = function(t15) {
        let e19 = !1;
        t15 !== c4.dot && ("of" !== this.state.value || this.state.exprAllowed || t15 === c4._function || t15 === c4._class || (e19 = !0)), this.state.exprAllowed = e19, this.state.isIterator && (this.state.isIterator = !1);
    }, c4.braceL.updateContext = function(t15) {
        this.state.context.push(this.braceIsBlock(t15) ? T4.braceStatement : T4.braceExpression), this.state.exprAllowed = !0;
    }, c4.dollarBraceL.updateContext = function() {
        this.state.context.push(T4.templateQuasi), this.state.exprAllowed = !0;
    }, c4.parenL.updateContext = function(t15) {
        const e19 = t15 === c4._if || t15 === c4._for || t15 === c4._with || t15 === c4._while;
        this.state.context.push(e19 ? T4.parenStatement : T4.parenExpression), this.state.exprAllowed = !0;
    }, c4.incDec.updateContext = function() {
    }, c4._function.updateContext = c4._class.updateContext = function(t15) {
        !t15.beforeExpr || t15 === c4.semi || t15 === c4._else || t15 === c4._return && this.hasPrecedingLineBreak() || (t15 === c4.colon || t15 === c4.braceL) && this.curContext() === T4.b_stat ? this.state.context.push(T4.functionStatement) : this.state.context.push(T4.functionExpression), this.state.exprAllowed = !1;
    }, c4.backQuote.updateContext = function() {
        this.curContext() === T4.template ? this.state.context.pop() : this.state.context.push(T4.template), this.state.exprAllowed = !1;
    }, c4.braceHashL.updateContext = function() {
        this.state.context.push(T4.recordExpression), this.state.exprAllowed = !0;
    };
    let w3 = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc", B3 = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    const S3 = new RegExp("[" + w3 + "]"), N3 = new RegExp("[" + w3 + B3 + "]");
    w3 = B3 = null;
    const I4 = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        157,
        310,
        10,
        21,
        11,
        7,
        153,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        107,
        20,
        28,
        22,
        13,
        52,
        76,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        85,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        230,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        35,
        56,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        190,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2749,
        1070,
        4050,
        582,
        8634,
        568,
        8,
        30,
        114,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8952,
        286,
        50,
        2,
        18,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        2357,
        44,
        11,
        6,
        17,
        0,
        370,
        43,
        1301,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42717,
        35,
        4148,
        12,
        221,
        3,
        5761,
        15,
        7472,
        3104,
        541,
        1507,
        4938
    ], v3 = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        154,
        10,
        176,
        2,
        54,
        14,
        32,
        9,
        16,
        3,
        46,
        10,
        54,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        161,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        19306,
        9,
        135,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        5319,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        262,
        6,
        10,
        9,
        419,
        13,
        1495,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    function k4(t15, e19) {
        let s7 = 65536;
        for(let r6 = 0, i6 = e19.length; r6 < i6; r6 += 2){
            if ((s7 += e19[r6], s7 > t15)) return !1;
            if ((s7 += e19[r6 + 1], s7 >= t15)) return !0;
        }
        return !1;
    }
    function L2(t15) {
        return t15 < 65 ? 36 === t15 : t15 <= 90 || (t15 < 97 ? 95 === t15 : t15 <= 122 || (t15 <= 65535 ? t15 >= 170 && S3.test(String.fromCharCode(t15)) : k4(t15, I4)));
    }
    function O3(t15) {
        return t15 < 48 ? 36 === t15 : t15 < 58 || !(t15 < 65) && (t15 <= 90 || (t15 < 97 ? 95 === t15 : t15 <= 122 || (t15 <= 65535 ? t15 >= 170 && N3.test(String.fromCharCode(t15)) : k4(t15, I4) || k4(t15, v3))));
    }
    const M4 = [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ], R3 = [
        "eval",
        "arguments"
    ], _3 = new Set([
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ]), j4 = new Set(M4), U3 = new Set(R3);
    function q3(t15, e19) {
        return e19 && "await" === t15 || "enum" === t15;
    }
    function V3(t15, e19) {
        return q3(t15, e19) || j4.has(t15);
    }
    function z3(t15) {
        return U3.has(t15);
    }
    function H4(t15, e19) {
        return V3(t15, e19) || z3(t15);
    }
    function W2(t15) {
        return _3.has(t15);
    }
    const G3 = /^in(stanceof)?$/;
    const X3 = new Set([
        "_",
        "any",
        "bool",
        "boolean",
        "empty",
        "extends",
        "false",
        "interface",
        "mixed",
        "null",
        "number",
        "static",
        "string",
        "true",
        "typeof",
        "void"
    ]), K3 = Object.freeze({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
        AssignReservedType: "Cannot overwrite reserved type %0",
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
        EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
        EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
        EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
        EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
        EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
        EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
        EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
        EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
        EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
        InexactVariance: "Explicit inexact syntax cannot have variance",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment",
        OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
        SpreadVariance: "Spread properties cannot have variance",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
        UnexpectedReservedType: "Unexpected reserved type %0",
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`",
        UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
        UnterminatedFlowComment: "Unterminated flow-comment"
    });
    function J2(t15) {
        return "type" === t15.importKind || "typeof" === t15.importKind;
    }
    function $3(t15) {
        return (t15.type === c4.name || !!t15.type.keyword) && "from" !== t15.value;
    }
    const Y2 = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
    };
    const Q3 = /\*?\s*@((?:no)?flow)\b/;
    const Z4 = {
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xa0",
        iexcl: "\xa1",
        cent: "\xa2",
        pound: "\xa3",
        curren: "\xa4",
        yen: "\xa5",
        brvbar: "\xa6",
        sect: "\xa7",
        uml: "\xa8",
        copy: "\xa9",
        ordf: "\xaa",
        laquo: "\xab",
        not: "\xac",
        shy: "\xad",
        reg: "\xae",
        macr: "\xaf",
        deg: "\xb0",
        plusmn: "\xb1",
        sup2: "\xb2",
        sup3: "\xb3",
        acute: "\xb4",
        micro: "\xb5",
        para: "\xb6",
        middot: "\xb7",
        cedil: "\xb8",
        sup1: "\xb9",
        ordm: "\xba",
        raquo: "\xbb",
        frac14: "\xbc",
        frac12: "\xbd",
        frac34: "\xbe",
        iquest: "\xbf",
        Agrave: "\xc0",
        Aacute: "\xc1",
        Acirc: "\xc2",
        Atilde: "\xc3",
        Auml: "\xc4",
        Aring: "\xc5",
        AElig: "\xc6",
        Ccedil: "\xc7",
        Egrave: "\xc8",
        Eacute: "\xc9",
        Ecirc: "\xca",
        Euml: "\xcb",
        Igrave: "\xcc",
        Iacute: "\xcd",
        Icirc: "\xce",
        Iuml: "\xcf",
        ETH: "\xd0",
        Ntilde: "\xd1",
        Ograve: "\xd2",
        Oacute: "\xd3",
        Ocirc: "\xd4",
        Otilde: "\xd5",
        Ouml: "\xd6",
        times: "\xd7",
        Oslash: "\xd8",
        Ugrave: "\xd9",
        Uacute: "\xda",
        Ucirc: "\xdb",
        Uuml: "\xdc",
        Yacute: "\xdd",
        THORN: "\xde",
        szlig: "\xdf",
        agrave: "\xe0",
        aacute: "\xe1",
        acirc: "\xe2",
        atilde: "\xe3",
        auml: "\xe4",
        aring: "\xe5",
        aelig: "\xe6",
        ccedil: "\xe7",
        egrave: "\xe8",
        eacute: "\xe9",
        ecirc: "\xea",
        euml: "\xeb",
        igrave: "\xec",
        iacute: "\xed",
        icirc: "\xee",
        iuml: "\xef",
        eth: "\xf0",
        ntilde: "\xf1",
        ograve: "\xf2",
        oacute: "\xf3",
        ocirc: "\xf4",
        otilde: "\xf5",
        ouml: "\xf6",
        divide: "\xf7",
        oslash: "\xf8",
        ugrave: "\xf9",
        uacute: "\xfa",
        ucirc: "\xfb",
        uuml: "\xfc",
        yacute: "\xfd",
        thorn: "\xfe",
        yuml: "\xff",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02c6",
        tilde: "\u02dc",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039a",
        Lambda: "\u039b",
        Mu: "\u039c",
        Nu: "\u039d",
        Xi: "\u039e",
        Omicron: "\u039f",
        Pi: "\u03a0",
        Rho: "\u03a1",
        Sigma: "\u03a3",
        Tau: "\u03a4",
        Upsilon: "\u03a5",
        Phi: "\u03a6",
        Chi: "\u03a7",
        Psi: "\u03a8",
        Omega: "\u03a9",
        alpha: "\u03b1",
        beta: "\u03b2",
        gamma: "\u03b3",
        delta: "\u03b4",
        epsilon: "\u03b5",
        zeta: "\u03b6",
        eta: "\u03b7",
        theta: "\u03b8",
        iota: "\u03b9",
        kappa: "\u03ba",
        lambda: "\u03bb",
        mu: "\u03bc",
        nu: "\u03bd",
        xi: "\u03be",
        omicron: "\u03bf",
        pi: "\u03c0",
        rho: "\u03c1",
        sigmaf: "\u03c2",
        sigma: "\u03c3",
        tau: "\u03c4",
        upsilon: "\u03c5",
        phi: "\u03c6",
        chi: "\u03c7",
        psi: "\u03c8",
        omega: "\u03c9",
        thetasym: "\u03d1",
        upsih: "\u03d2",
        piv: "\u03d6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200c",
        zwj: "\u200d",
        lrm: "\u200e",
        rlm: "\u200f",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201a",
        ldquo: "\u201c",
        rdquo: "\u201d",
        bdquo: "\u201e",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203a",
        oline: "\u203e",
        frasl: "\u2044",
        euro: "\u20ac",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211c",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21b5",
        lArr: "\u21d0",
        uArr: "\u21d1",
        rArr: "\u21d2",
        dArr: "\u21d3",
        hArr: "\u21d4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220b",
        prod: "\u220f",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221a",
        prop: "\u221d",
        infin: "\u221e",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222a",
        int: "\u222b",
        there4: "\u2234",
        sim: "\u223c",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22a5",
        sdot: "\u22c5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230a",
        rfloor: "\u230b",
        lang: "\u2329",
        rang: "\u232a",
        loz: "\u25ca",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
    }, tt2 = /^[\da-fA-F]+$/, et3 = /^\d+$/, st3 = Object.freeze({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
        MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
        UnterminatedJsxContent: "Unterminated JSX contents",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function rt3(t15) {
        return !!t15 && ("JSXOpeningFragment" === t15.type || "JSXClosingFragment" === t15.type);
    }
    function it3(t15) {
        if ("JSXIdentifier" === t15.type) return t15.name;
        if ("JSXNamespacedName" === t15.type) return t15.namespace.name + ":" + t15.name.name;
        if ("JSXMemberExpression" === t15.type) return it3(t15.object) + "." + it3(t15.property);
        throw new Error("Node had unexpected type: " + t15.type);
    }
    T4.j_oTag = new P2("<tag", !1), T4.j_cTag = new P2("</tag", !1), T4.j_expr = new P2("<tag>...</tag>", !0, !0), c4.jsxName = new a4("jsxName"), c4.jsxText = new a4("jsxText", {
        beforeExpr: !0
    }), c4.jsxTagStart = new a4("jsxTagStart", {
        startsExpr: !0
    }), c4.jsxTagEnd = new a4("jsxTagEnd"), c4.jsxTagStart.updateContext = function() {
        this.state.context.push(T4.j_expr), this.state.context.push(T4.j_oTag), this.state.exprAllowed = !1;
    }, c4.jsxTagEnd.updateContext = function(t15) {
        const e19 = this.state.context.pop();
        e19 === T4.j_oTag && t15 === c4.slash || e19 === T4.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === T4.j_expr) : this.state.exprAllowed = !0;
    };
    class nt2 {
        constructor(t15){
            this.flags = void 0, this.var = [], this.lexical = [], this.functions = [], this.flags = t15;
        }
    }
    class at3 {
        constructor(t16, e19){
            this.scopeStack = [], this.undefinedExports = new Map, this.undefinedPrivateNames = new Map, this.raise = t16, this.inModule = e19;
        }
        get inFunction() {
            return (2 & this.currentVarScope().flags) > 0;
        }
        get allowSuper() {
            return (16 & this.currentThisScope().flags) > 0;
        }
        get allowDirectSuper() {
            return (32 & this.currentThisScope().flags) > 0;
        }
        get inClass() {
            return (64 & this.currentThisScope().flags) > 0;
        }
        get inNonArrowFunction() {
            return (2 & this.currentThisScope().flags) > 0;
        }
        get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(t) {
            return new nt2(t);
        }
        enter(t) {
            this.scopeStack.push(this.createScope(t));
        }
        exit() {
            this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(t) {
            return !!(2 & t.flags || !this.inModule && 1 & t.flags);
        }
        declareName(t, e, s) {
            let r6 = this.currentScope();
            if (8 & e || 16 & e) this.checkRedeclarationInScope(r6, t, e, s), 16 & e ? r6.functions.push(t) : r6.lexical.push(t), 8 & e && this.maybeExportDefined(r6, t);
            else if (4 & e) for(let i6 = this.scopeStack.length - 1; i6 >= 0 && (r6 = this.scopeStack[i6], this.checkRedeclarationInScope(r6, t, e, s), r6.var.push(t), this.maybeExportDefined(r6, t), !(131 & r6.flags)); --i6);
            this.inModule && 1 & r6.flags && this.undefinedExports.delete(t);
        }
        maybeExportDefined(t, e) {
            this.inModule && 1 & t.flags && this.undefinedExports.delete(e);
        }
        checkRedeclarationInScope(t, e, s, r) {
            this.isRedeclaredInScope(t, e, s) && this.raise(r, g4.VarRedeclaration, e);
        }
        isRedeclaredInScope(t, e, s) {
            return !!(1 & s) && (8 & s ? t.lexical.indexOf(e) > -1 || t.functions.indexOf(e) > -1 || t.var.indexOf(e) > -1 : 16 & s ? t.lexical.indexOf(e) > -1 || !this.treatFunctionsAsVarInScope(t) && t.var.indexOf(e) > -1 : t.lexical.indexOf(e) > -1 && !(8 & t.flags && t.lexical[0] === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.indexOf(e) > -1);
        }
        checkLocalExport(t) {
            -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && -1 === this.scopeStack[0].functions.indexOf(t.name) && this.undefinedExports.set(t.name, t.start);
        }
        currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScope() {
            for(let t17 = this.scopeStack.length - 1;; t17--){
                const e20 = this.scopeStack[t17];
                if (131 & e20.flags) return e20;
            }
        }
        currentThisScope() {
            for(let t17 = this.scopeStack.length - 1;; t17--){
                const e20 = this.scopeStack[t17];
                if ((131 & e20.flags || 64 & e20.flags) && !(4 & e20.flags)) return e20;
            }
        }
    }
    class ot3 extends nt2 {
        constructor(...t17){
            super(...t17), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], this.exportOnlyBindings = [];
        }
    }
    class ut3 extends at3 {
        createScope(t) {
            return new ot3(t);
        }
        declareName(t, e, s) {
            const r6 = this.currentScope();
            if (e & 1024) return this.maybeExportDefined(r6, t), void r6.exportOnlyBindings.push(t);
            super.declareName(...arguments), 2 & e && (1 & e || (this.checkRedeclarationInScope(r6, t, e, s), this.maybeExportDefined(r6, t)), r6.types.push(t)), 256 & e && r6.enums.push(t), 512 & e && r6.constEnums.push(t), e & 128 && r6.classes.push(t);
        }
        isRedeclaredInScope(t, e, s) {
            if (t.enums.indexOf(e) > -1) {
                if (256 & s) {
                    return !!(512 & s) !== t.constEnums.indexOf(e) > -1;
                }
                return !0;
            }
            return s & 128 && t.classes.indexOf(e) > -1 ? t.lexical.indexOf(e) > -1 && !!(1 & s) : !!(2 & s && t.types.indexOf(e) > -1) || super.isRedeclaredInScope(...arguments);
        }
        checkLocalExport(t) {
            -1 === this.scopeStack[0].types.indexOf(t.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(t.name) && super.checkLocalExport(t);
        }
    }
    class ht3 {
        constructor(){
            this.stacks = [];
        }
        enter(t) {
            this.stacks.push(t);
        }
        exit() {
            this.stacks.pop();
        }
        currentFlags() {
            return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
            return (2 & this.currentFlags()) > 0;
        }
        get hasYield() {
            return (1 & this.currentFlags()) > 0;
        }
        get hasReturn() {
            return (4 & this.currentFlags()) > 0;
        }
        get hasIn() {
            return (8 & this.currentFlags()) > 0;
        }
    }
    function ct2(t18, e20) {
        return (t18 ? 2 : 0) | (e20 ? 1 : 0);
    }
    function pt3(t18) {
        if (null == t18) throw new Error("Unexpected ".concat(t18, " value."));
        return t18;
    }
    function lt3(t18) {
        if (!t18) throw new Error("Assert fail");
    }
    const dt3 = Object.freeze({
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateModifier: "Duplicate modifier: '%0'",
        EmptyHeritageClauseType: "'%0' list cannot be empty.",
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
        IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
    });
    c4.placeholder = new a4("%%", {
        startsExpr: !0
    });
    function Dt3(t18, e20) {
        return t18.some((t19)=>Array.isArray(t19) ? t19[0] === e20 : t19 === e20
        );
    }
    function mt2(t18, e20, s7) {
        const r6 = t18.find((t19)=>Array.isArray(t19) ? t19[0] === e20 : t19 === e20
        );
        return r6 && Array.isArray(r6) ? r6[1][s7] : null;
    }
    const ft3 = [
        "minimal",
        "smart",
        "fsharp"
    ], yt2 = [
        "hash",
        "bar"
    ];
    const Et2 = {
        estree: (t18)=>class extends t18 {
                estreeParseRegExpLiteral({ pattern: t , flags: e  }) {
                    let s7 = null;
                    try {
                        s7 = new RegExp(t, e);
                    } catch (t) {
                    }
                    const r6 = this.estreeParseLiteral(s7);
                    return r6.regex = {
                        pattern: t,
                        flags: e
                    }, r6;
                }
                estreeParseBigIntLiteral(t) {
                    const e20 = "undefined" != typeof BigInt ? BigInt(t) : null, s7 = this.estreeParseLiteral(e20);
                    return s7.bigint = String(s7.value || t), s7;
                }
                estreeParseDecimalLiteral(t) {
                    const e20 = this.estreeParseLiteral(null);
                    return e20.decimal = String(e20.value || t), e20;
                }
                estreeParseLiteral(t) {
                    return this.parseLiteral(t, "Literal");
                }
                directiveToStmt(t) {
                    const e20 = t.value, s7 = this.startNodeAt(t.start, t.loc.start), r6 = this.startNodeAt(e20.start, e20.loc.start);
                    return r6.value = e20.value, r6.raw = e20.extra.raw, s7.expression = this.finishNodeAt(r6, "Literal", e20.end, e20.loc.end), s7.directive = e20.extra.raw.slice(1, -1), this.finishNodeAt(s7, "ExpressionStatement", t.end, t.loc.end);
                }
                initFunction(t, e) {
                    super.initFunction(t, e), t.expression = !1;
                }
                checkDeclaration(t) {
                    b3(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t);
                }
                getObjectOrClassMethodParams(t) {
                    return t.value.params;
                }
                checkLVal(t, e = 64, s, r, i) {
                    switch(t.type){
                        case "ObjectPattern":
                            t.properties.forEach((t19)=>{
                                this.checkLVal("Property" === t19.type ? t19.value : t19, e, s, "object destructuring pattern", i);
                            });
                            break;
                        default:
                            super.checkLVal(t, e, s, r, i);
                    }
                }
                checkProto(t, e, s, r) {
                    t.method || super.checkProto(t, e, s, r);
                }
                isValidDirective(t) {
                    var e20;
                    return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && !(null == (e20 = t.expression.extra) ? void 0 : e20.parenthesized);
                }
                stmtToDirective(t) {
                    const e20 = super.stmtToDirective(t), s7 = t.expression.value;
                    return e20.value.value = s7, e20;
                }
                parseBlockBody(t, e, s, r) {
                    super.parseBlockBody(t, e, s, r);
                    const i6 = t.directives.map((t19)=>this.directiveToStmt(t19)
                    );
                    t.body = i6.concat(t.body), delete t.directives;
                }
                pushClassMethod(t, e, s, r, i, n) {
                    this.parseMethod(e, s, r, i, n, "ClassMethod", !0), e.typeParameters && (e.value.typeParameters = e.typeParameters, delete e.typeParameters), t.body.push(e);
                }
                parseExprAtom(t) {
                    switch(this.state.type){
                        case c4.num:
                        case c4.string:
                            return this.estreeParseLiteral(this.state.value);
                        case c4.regexp:
                            return this.estreeParseRegExpLiteral(this.state.value);
                        case c4.bigint:
                            return this.estreeParseBigIntLiteral(this.state.value);
                        case c4.decimal:
                            return this.estreeParseDecimalLiteral(this.state.value);
                        case c4._null:
                            return this.estreeParseLiteral(null);
                        case c4._true:
                            return this.estreeParseLiteral(!0);
                        case c4._false:
                            return this.estreeParseLiteral(!1);
                        default:
                            return super.parseExprAtom(t);
                    }
                }
                parseLiteral(t, e, s, r) {
                    const i6 = super.parseLiteral(t, e, s, r);
                    return i6.raw = i6.extra.raw, delete i6.extra, i6;
                }
                parseFunctionBody(t, e, s = !1) {
                    super.parseFunctionBody(t, e, s), t.expression = "BlockStatement" !== t.body.type;
                }
                parseMethod(t, e, s, r, i, n, a = !1) {
                    let o5 = this.startNode();
                    return o5.kind = t.kind, o5 = super.parseMethod(o5, e, s, r, i, n, a), o5.type = "FunctionExpression", delete o5.kind, t.value = o5, n = "ClassMethod" === n ? "MethodDefinition" : n, this.finishNode(t, n);
                }
                parseObjectMethod(t, e, s, r, i) {
                    const n6 = super.parseObjectMethod(t, e, s, r, i);
                    return n6 && (n6.type = "Property", "method" === n6.kind && (n6.kind = "init"), n6.shorthand = !1), n6;
                }
                parseObjectProperty(t, e, s, r, i) {
                    const n6 = super.parseObjectProperty(t, e, s, r, i);
                    return n6 && (n6.kind = "init", n6.type = "Property"), n6;
                }
                toAssignable(t) {
                    return b3(t) ? (this.toAssignable(t.value), t) : super.toAssignable(t);
                }
                toAssignableObjectExpressionProp(t, e) {
                    if ("get" === t.kind || "set" === t.kind) throw this.raise(t.key.start, g4.PatternHasAccessor);
                    if (t.method) throw this.raise(t.key.start, g4.PatternHasMethod);
                    super.toAssignableObjectExpressionProp(t, e);
                }
                finishCallExpression(t, e) {
                    return super.finishCallExpression(t, e), "Import" === t.callee.type && (t.type = "ImportExpression", t.source = t.arguments[0], delete t.arguments, delete t.callee), t;
                }
                toReferencedArguments(t) {
                    "ImportExpression" !== t.type && super.toReferencedArguments(t);
                }
                parseExport(t) {
                    switch(super.parseExport(t), t.type){
                        case "ExportAllDeclaration":
                            t.exported = null;
                            break;
                        case "ExportNamedDeclaration":
                            1 === t.specifiers.length && "ExportNamespaceSpecifier" === t.specifiers[0].type && (t.type = "ExportAllDeclaration", t.exported = t.specifiers[0].exported, delete t.specifiers);
                    }
                    return t;
                }
                parseSubscript(t, e, s, r, i) {
                    const n6 = super.parseSubscript(t, e, s, r, i);
                    if (i.optionalChainMember) {
                        if ("OptionalMemberExpression" !== n6.type && "OptionalCallExpression" !== n6.type || (n6.type = n6.type.substring(8)), i.stop) {
                            const t19 = this.startNodeAtNode(n6);
                            return t19.expression = n6, this.finishNode(t19, "ChainExpression");
                        }
                    } else "MemberExpression" !== n6.type && "CallExpression" !== n6.type || (n6.optional = !1);
                    return n6;
                }
            }
        ,
        jsx: (t18)=>class extends t18 {
                jsxReadToken() {
                    let t19 = "", e20 = this.state.pos;
                    for(;;){
                        if (this.state.pos >= this.length) throw this.raise(this.state.start, st3.UnterminatedJsxContent);
                        const s7 = this.input.charCodeAt(this.state.pos);
                        switch(s7){
                            case 60:
                            case 123:
                                return this.state.pos === this.state.start ? 60 === s7 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(c4.jsxTagStart)) : super.getTokenFromCode(s7) : (t19 += this.input.slice(e20, this.state.pos), this.finishToken(c4.jsxText, t19));
                            case 38:
                                t19 += this.input.slice(e20, this.state.pos), t19 += this.jsxReadEntity(), e20 = this.state.pos;
                                break;
                            default:
                                y4(s7) ? (t19 += this.input.slice(e20, this.state.pos), t19 += this.jsxReadNewLine(!0), e20 = this.state.pos) : ++this.state.pos;
                        }
                    }
                }
                jsxReadNewLine(t) {
                    const e20 = this.input.charCodeAt(this.state.pos);
                    let s7;
                    return ++this.state.pos, 13 === e20 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, s7 = t ? "\n" : "\r\n") : s7 = String.fromCharCode(e20), ++this.state.curLine, this.state.lineStart = this.state.pos, s7;
                }
                jsxReadString(t) {
                    let e20 = "", s7 = ++this.state.pos;
                    for(;;){
                        if (this.state.pos >= this.length) throw this.raise(this.state.start, g4.UnterminatedString);
                        const r6 = this.input.charCodeAt(this.state.pos);
                        if (r6 === t) break;
                        38 === r6 ? (e20 += this.input.slice(s7, this.state.pos), e20 += this.jsxReadEntity(), s7 = this.state.pos) : y4(r6) ? (e20 += this.input.slice(s7, this.state.pos), e20 += this.jsxReadNewLine(!1), s7 = this.state.pos) : ++this.state.pos;
                    }
                    return e20 += this.input.slice(s7, this.state.pos++), this.finishToken(c4.string, e20);
                }
                jsxReadEntity() {
                    let t19, e20 = "", s7 = 0, r6 = this.input[this.state.pos];
                    const i6 = ++this.state.pos;
                    for(; this.state.pos < this.length && (s7++) < 10;){
                        if (r6 = this.input[this.state.pos++], ";" === r6) {
                            "#" === e20[0] ? "x" === e20[1] ? (e20 = e20.substr(2), tt2.test(e20) && (t19 = String.fromCodePoint(parseInt(e20, 16)))) : (e20 = e20.substr(1), et3.test(e20) && (t19 = String.fromCodePoint(parseInt(e20, 10)))) : t19 = Z4[e20];
                            break;
                        }
                        e20 += r6;
                    }
                    return t19 || (this.state.pos = i6, "&");
                }
                jsxReadWord() {
                    let t19;
                    const e20 = this.state.pos;
                    do {
                        t19 = this.input.charCodeAt(++this.state.pos);
                    }while (O3(t19) || 45 === t19)
                    return this.finishToken(c4.jsxName, this.input.slice(e20, this.state.pos));
                }
                jsxParseIdentifier() {
                    const t19 = this.startNode();
                    return this.match(c4.jsxName) ? t19.name = this.state.value : this.state.type.keyword ? t19.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t19, "JSXIdentifier");
                }
                jsxParseNamespacedName() {
                    const t19 = this.state.start, e20 = this.state.startLoc, s7 = this.jsxParseIdentifier();
                    if (!this.eat(c4.colon)) return s7;
                    const r6 = this.startNodeAt(t19, e20);
                    return r6.namespace = s7, r6.name = this.jsxParseIdentifier(), this.finishNode(r6, "JSXNamespacedName");
                }
                jsxParseElementName() {
                    const t19 = this.state.start, e20 = this.state.startLoc;
                    let s7 = this.jsxParseNamespacedName();
                    if ("JSXNamespacedName" === s7.type) return s7;
                    for(; this.eat(c4.dot);){
                        const r6 = this.startNodeAt(t19, e20);
                        r6.object = s7, r6.property = this.jsxParseIdentifier(), s7 = this.finishNode(r6, "JSXMemberExpression");
                    }
                    return s7;
                }
                jsxParseAttributeValue() {
                    let t19;
                    switch(this.state.type){
                        case c4.braceL:
                            return t19 = this.startNode(), this.next(), t19 = this.jsxParseExpressionContainer(t19), "JSXEmptyExpression" === t19.expression.type && this.raise(t19.start, st3.AttributeIsEmpty), t19;
                        case c4.jsxTagStart:
                        case c4.string:
                            return this.parseExprAtom();
                        default:
                            throw this.raise(this.state.start, st3.UnsupportedJsxValue);
                    }
                }
                jsxParseEmptyExpression() {
                    const t19 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
                    return this.finishNodeAt(t19, "JSXEmptyExpression", this.state.start, this.state.startLoc);
                }
                jsxParseSpreadChild(t) {
                    return this.next(), t.expression = this.parseExpression(), this.expect(c4.braceR), this.finishNode(t, "JSXSpreadChild");
                }
                jsxParseExpressionContainer(t) {
                    return this.match(c4.braceR) ? t.expression = this.jsxParseEmptyExpression() : t.expression = this.parseExpression(), this.expect(c4.braceR), this.finishNode(t, "JSXExpressionContainer");
                }
                jsxParseAttribute() {
                    const t19 = this.startNode();
                    return this.eat(c4.braceL) ? (this.expect(c4.ellipsis), t19.argument = this.parseMaybeAssignAllowIn(), this.expect(c4.braceR), this.finishNode(t19, "JSXSpreadAttribute")) : (t19.name = this.jsxParseNamespacedName(), t19.value = this.eat(c4.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t19, "JSXAttribute"));
                }
                jsxParseOpeningElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    return this.match(c4.jsxTagEnd) ? (this.expect(c4.jsxTagEnd), this.finishNode(s7, "JSXOpeningFragment")) : (s7.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s7));
                }
                jsxParseOpeningElementAfterName(t) {
                    const e20 = [];
                    for(; !this.match(c4.slash) && !this.match(c4.jsxTagEnd);)e20.push(this.jsxParseAttribute());
                    return t.attributes = e20, t.selfClosing = this.eat(c4.slash), this.expect(c4.jsxTagEnd), this.finishNode(t, "JSXOpeningElement");
                }
                jsxParseClosingElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    return this.match(c4.jsxTagEnd) ? (this.expect(c4.jsxTagEnd), this.finishNode(s7, "JSXClosingFragment")) : (s7.name = this.jsxParseElementName(), this.expect(c4.jsxTagEnd), this.finishNode(s7, "JSXClosingElement"));
                }
                jsxParseElementAt(t, e) {
                    const s7 = this.startNodeAt(t, e), r6 = [], i6 = this.jsxParseOpeningElementAt(t, e);
                    let n6 = null;
                    if (!i6.selfClosing) {
                        t: for(;;)switch(this.state.type){
                            case c4.jsxTagStart:
                                if (t = this.state.start, e = this.state.startLoc, this.next(), this.eat(c4.slash)) {
                                    n6 = this.jsxParseClosingElementAt(t, e);
                                    break t;
                                }
                                r6.push(this.jsxParseElementAt(t, e));
                                break;
                            case c4.jsxText:
                                r6.push(this.parseExprAtom());
                                break;
                            case c4.braceL:
                                {
                                    const t19 = this.startNode();
                                    this.next(), this.match(c4.ellipsis) ? r6.push(this.jsxParseSpreadChild(t19)) : r6.push(this.jsxParseExpressionContainer(t19));
                                    break;
                                }
                            default:
                                throw this.unexpected();
                        }
                        rt3(i6) && !rt3(n6) ? this.raise(n6.start, st3.MissingClosingTagFragment) : !rt3(i6) && rt3(n6) ? this.raise(n6.start, st3.MissingClosingTagElement, it3(i6.name)) : rt3(i6) || rt3(n6) || it3(n6.name) !== it3(i6.name) && this.raise(n6.start, st3.MissingClosingTagElement, it3(i6.name));
                    }
                    if (rt3(i6) ? (s7.openingFragment = i6, s7.closingFragment = n6) : (s7.openingElement = i6, s7.closingElement = n6), s7.children = r6, this.isRelational("<")) throw this.raise(this.state.start, st3.UnwrappedAdjacentJSXElements);
                    return rt3(i6) ? this.finishNode(s7, "JSXFragment") : this.finishNode(s7, "JSXElement");
                }
                jsxParseElement() {
                    const t19 = this.state.start, e20 = this.state.startLoc;
                    return this.next(), this.jsxParseElementAt(t19, e20);
                }
                parseExprAtom(t) {
                    return this.match(c4.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(c4.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(c4.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(t);
                }
                getTokenFromCode(t) {
                    if (this.state.inPropertyName) return super.getTokenFromCode(t);
                    const e20 = this.curContext();
                    if (e20 === T4.j_expr) return this.jsxReadToken();
                    if (e20 === T4.j_oTag || e20 === T4.j_cTag) {
                        if (L2(t)) return this.jsxReadWord();
                        if (62 === t) return ++this.state.pos, this.finishToken(c4.jsxTagEnd);
                        if ((34 === t || 39 === t) && e20 === T4.j_oTag) return this.jsxReadString(t);
                    }
                    return 60 === t && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(c4.jsxTagStart)) : super.getTokenFromCode(t);
                }
                updateContext(t) {
                    if (this.match(c4.braceL)) {
                        const e20 = this.curContext();
                        e20 === T4.j_oTag ? this.state.context.push(T4.braceExpression) : e20 === T4.j_expr ? this.state.context.push(T4.templateQuasi) : super.updateContext(t), this.state.exprAllowed = !0;
                    } else {
                        if (!this.match(c4.slash) || t !== c4.jsxTagStart) return super.updateContext(t);
                        this.state.context.length -= 2, this.state.context.push(T4.j_cTag), this.state.exprAllowed = !1;
                    }
                }
            }
        ,
        flow: (t18)=>class extends t18 {
                constructor(t19, e20){
                    super(t19, e20), this.flowPragma = void 0, this.flowPragma = void 0;
                }
                shouldParseTypes() {
                    return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
                }
                shouldParseEnums() {
                    return !!this.getPluginOption("flow", "enums");
                }
                finishToken(t, e) {
                    return t !== c4.string && t !== c4.semi && t !== c4.interpreterDirective && (void 0) === this.flowPragma && (this.flowPragma = null), super.finishToken(t, e);
                }
                addComment(t) {
                    if ((void 0) === this.flowPragma) {
                        const e23 = Q3.exec(t.value);
                        if (e23) {
                            if ("flow" === e23[1]) this.flowPragma = "flow";
                            else {
                                if ("noflow" !== e23[1]) throw new Error("Unexpected flow pragma");
                                this.flowPragma = "noflow";
                            }
                        } else ;
                    }
                    return super.addComment(t);
                }
                flowParseTypeInitialiser(t) {
                    const e23 = this.state.inType;
                    this.state.inType = !0, this.expect(t || c4.colon);
                    const s7 = this.flowParseType();
                    return this.state.inType = e23, s7;
                }
                flowParsePredicate() {
                    const t20 = this.startNode(), e23 = this.state.startLoc, s7 = this.state.start;
                    this.expect(c4.modulo);
                    const r6 = this.state.startLoc;
                    return this.expectContextual("checks"), e23.line === r6.line && e23.column === r6.column - 1 || this.raise(s7, K3.UnexpectedSpaceBetweenModuloChecks), this.eat(c4.parenL) ? (t20.value = this.parseExpression(), this.expect(c4.parenR), this.finishNode(t20, "DeclaredPredicate")) : this.finishNode(t20, "InferredPredicate");
                }
                flowParseTypeAndPredicateInitialiser() {
                    const t20 = this.state.inType;
                    this.state.inType = !0, this.expect(c4.colon);
                    let e23 = null, s7 = null;
                    return this.match(c4.modulo) ? (this.state.inType = t20, s7 = this.flowParsePredicate()) : (e23 = this.flowParseType(), this.state.inType = t20, this.match(c4.modulo) && (s7 = this.flowParsePredicate())), [
                        e23,
                        s7
                    ];
                }
                flowParseDeclareClass(t) {
                    return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, "DeclareClass");
                }
                flowParseDeclareFunction(t) {
                    this.next();
                    const e23 = t.id = this.parseIdentifier(), s7 = this.startNode(), r6 = this.startNode();
                    this.isRelational("<") ? s7.typeParameters = this.flowParseTypeParameterDeclaration() : s7.typeParameters = null, this.expect(c4.parenL);
                    const i6 = this.flowParseFunctionTypeParams();
                    return s7.params = i6.params, s7.rest = i6.rest, this.expect(c4.parenR), [s7.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), r6.typeAnnotation = this.finishNode(s7, "FunctionTypeAnnotation"), e23.typeAnnotation = this.finishNode(r6, "TypeAnnotation"), this.resetEndLocation(e23), this.semicolon(), this.finishNode(t, "DeclareFunction");
                }
                flowParseDeclare(t, e) {
                    if (this.match(c4._class)) return this.flowParseDeclareClass(t);
                    if (this.match(c4._function)) return this.flowParseDeclareFunction(t);
                    if (this.match(c4._var)) return this.flowParseDeclareVariable(t);
                    if (this.eatContextual("module")) return this.match(c4.dot) ? this.flowParseDeclareModuleExports(t) : (e && this.raise(this.state.lastTokStart, K3.NestedDeclareModule), this.flowParseDeclareModule(t));
                    if (this.isContextual("type")) return this.flowParseDeclareTypeAlias(t);
                    if (this.isContextual("opaque")) return this.flowParseDeclareOpaqueType(t);
                    if (this.isContextual("interface")) return this.flowParseDeclareInterface(t);
                    if (this.match(c4._export)) return this.flowParseDeclareExportDeclaration(t, e);
                    throw this.unexpected();
                }
                flowParseDeclareVariable(t) {
                    return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, 5, t.id.start), this.semicolon(), this.finishNode(t, "DeclareVariable");
                }
                flowParseDeclareModule(t) {
                    this.scope.enter(0), this.match(c4.string) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier();
                    const e23 = t.body = this.startNode(), s7 = e23.body = [];
                    for(this.expect(c4.braceL); !this.match(c4.braceR);){
                        let t20 = this.startNode();
                        this.match(c4._import) ? (this.next(), this.isContextual("type") || this.match(c4._typeof) || this.raise(this.state.lastTokStart, K3.InvalidNonTypeImportInDeclareModule), this.parseImport(t20)) : (this.expectContextual("declare", K3.UnsupportedStatementInDeclareModule), t20 = this.flowParseDeclare(t20, !0)), s7.push(t20);
                    }
                    this.scope.exit(), this.expect(c4.braceR), this.finishNode(e23, "BlockStatement");
                    let r6 = null, i6 = !1;
                    return s7.forEach((t20)=>{
                        !(function(t21) {
                            return "DeclareExportAllDeclaration" === t21.type || "DeclareExportDeclaration" === t21.type && (!t21.declaration || "TypeAlias" !== t21.declaration.type && "InterfaceDeclaration" !== t21.declaration.type);
                        })(t20) ? "DeclareModuleExports" === t20.type && (i6 && this.raise(t20.start, K3.DuplicateDeclareModuleExports), "ES" === r6 && this.raise(t20.start, K3.AmbiguousDeclareModuleKind), r6 = "CommonJS", i6 = !0) : ("CommonJS" === r6 && this.raise(t20.start, K3.AmbiguousDeclareModuleKind), r6 = "ES");
                    }), t.kind = r6 || "CommonJS", this.finishNode(t, "DeclareModule");
                }
                flowParseDeclareExportDeclaration(t, e) {
                    if (this.expect(c4._export), this.eat(c4._default)) return this.match(c4._function) || this.match(c4._class) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(c4._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !e) {
                        const t20 = this.state.value, e23 = Y2[t20];
                        throw this.raise(this.state.start, K3.UnsupportedDeclareExportKind, t20, e23);
                    }
                    if (this.match(c4._var) || this.match(c4._function) || this.match(c4._class) || this.isContextual("opaque")) return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, "DeclareExportDeclaration");
                    if (this.match(c4.star) || this.match(c4.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) return "ExportNamedDeclaration" === (t = this.parseExport(t)).type && (t.type = "ExportDeclaration", t.default = !1, delete t.exportKind), t.type = "Declare" + t.type, t;
                    throw this.unexpected();
                }
                flowParseDeclareModuleExports(t) {
                    return this.next(), this.expectContextual("exports"), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, "DeclareModuleExports");
                }
                flowParseDeclareTypeAlias(t) {
                    return this.next(), this.flowParseTypeAlias(t), t.type = "DeclareTypeAlias", t;
                }
                flowParseDeclareOpaqueType(t) {
                    return this.next(), this.flowParseOpaqueType(t, !0), t.type = "DeclareOpaqueType", t;
                }
                flowParseDeclareInterface(t) {
                    return this.next(), this.flowParseInterfaceish(t), this.finishNode(t, "DeclareInterface");
                }
                flowParseInterfaceish(t, e = !1) {
                    if (t.id = this.flowParseRestrictedIdentifier(!e, !0), this.scope.declareName(t.id.name, e ? 17 : 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], t.implements = [], t.mixins = [], this.eat(c4._extends)) do {
                        t.extends.push(this.flowParseInterfaceExtends());
                    }while (!e && this.eat(c4.comma))
                    if (this.isContextual("mixins")) {
                        this.next();
                        do {
                            t.mixins.push(this.flowParseInterfaceExtends());
                        }while (this.eat(c4.comma))
                    }
                    if (this.isContextual("implements")) {
                        this.next();
                        do {
                            t.implements.push(this.flowParseInterfaceExtends());
                        }while (this.eat(c4.comma))
                    }
                    t.body = this.flowParseObjectType({
                        allowStatic: e,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: e,
                        allowInexact: !1
                    });
                }
                flowParseInterfaceExtends() {
                    const t20 = this.startNode();
                    return t20.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? t20.typeParameters = this.flowParseTypeParameterInstantiation() : t20.typeParameters = null, this.finishNode(t20, "InterfaceExtends");
                }
                flowParseInterface(t) {
                    return this.flowParseInterfaceish(t), this.finishNode(t, "InterfaceDeclaration");
                }
                checkNotUnderscore(t) {
                    "_" === t && this.raise(this.state.start, K3.UnexpectedReservedUnderscore);
                }
                checkReservedType(t, e, s) {
                    X3.has(t) && this.raise(e, s ? K3.AssignReservedType : K3.UnexpectedReservedType, t);
                }
                flowParseRestrictedIdentifier(t, e) {
                    return this.checkReservedType(this.state.value, this.state.start, e), this.parseIdentifier(t);
                }
                flowParseTypeAlias(t) {
                    return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(c4.eq), this.semicolon(), this.finishNode(t, "TypeAlias");
                }
                flowParseOpaqueType(t, e) {
                    return this.expectContextual("type"), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(c4.colon) && (t.supertype = this.flowParseTypeInitialiser(c4.colon)), t.impltype = null, e || (t.impltype = this.flowParseTypeInitialiser(c4.eq)), this.semicolon(), this.finishNode(t, "OpaqueType");
                }
                flowParseTypeParameter(t = !1) {
                    const e23 = this.state.start, s7 = this.startNode(), r6 = this.flowParseVariance(), i6 = this.flowParseTypeAnnotatableIdentifier();
                    return s7.name = i6.name, s7.variance = r6, s7.bound = i6.typeAnnotation, this.match(c4.eq) ? (this.eat(c4.eq), s7.default = this.flowParseType()) : t && this.raise(e23, K3.MissingTypeParamDefault), this.finishNode(s7, "TypeParameter");
                }
                flowParseTypeParameterDeclaration() {
                    const t20 = this.state.inType, e23 = this.startNode();
                    e23.params = [], this.state.inType = !0, this.isRelational("<") || this.match(c4.jsxTagStart) ? this.next() : this.unexpected();
                    let s7 = !1;
                    do {
                        const t21 = this.flowParseTypeParameter(s7);
                        e23.params.push(t21), t21.default && (s7 = !0), this.isRelational(">") || this.expect(c4.comma);
                    }while (!this.isRelational(">"))
                    return this.expectRelational(">"), this.state.inType = t20, this.finishNode(e23, "TypeParameterDeclaration");
                }
                flowParseTypeParameterInstantiation() {
                    const t20 = this.startNode(), e23 = this.state.inType;
                    t20.params = [], this.state.inType = !0, this.expectRelational("<");
                    const s7 = this.state.noAnonFunctionType;
                    for(this.state.noAnonFunctionType = !1; !this.isRelational(">");)t20.params.push(this.flowParseType()), this.isRelational(">") || this.expect(c4.comma);
                    return this.state.noAnonFunctionType = s7, this.expectRelational(">"), this.state.inType = e23, this.finishNode(t20, "TypeParameterInstantiation");
                }
                flowParseTypeParameterInstantiationCallOrNew() {
                    const t20 = this.startNode(), e23 = this.state.inType;
                    for(t20.params = [], this.state.inType = !0, this.expectRelational("<"); !this.isRelational(">");)t20.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(c4.comma);
                    return this.expectRelational(">"), this.state.inType = e23, this.finishNode(t20, "TypeParameterInstantiation");
                }
                flowParseInterfaceType() {
                    const t20 = this.startNode();
                    if (this.expectContextual("interface"), t20.extends = [], this.eat(c4._extends)) do {
                        t20.extends.push(this.flowParseInterfaceExtends());
                    }while (this.eat(c4.comma))
                    return t20.body = this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: !1,
                        allowInexact: !1
                    }), this.finishNode(t20, "InterfaceTypeAnnotation");
                }
                flowParseObjectPropertyKey() {
                    return this.match(c4.num) || this.match(c4.string) ? this.parseExprAtom() : this.parseIdentifier(!0);
                }
                flowParseObjectTypeIndexer(t, e, s) {
                    return t.static = e, this.lookahead().type === c4.colon ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(c4.bracketR), t.value = this.flowParseTypeInitialiser(), t.variance = s, this.finishNode(t, "ObjectTypeIndexer");
                }
                flowParseObjectTypeInternalSlot(t, e) {
                    return t.static = e, t.id = this.flowParseObjectPropertyKey(), this.expect(c4.bracketR), this.expect(c4.bracketR), this.isRelational("<") || this.match(c4.parenL) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1, this.eat(c4.question) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, "ObjectTypeInternalSlot");
                }
                flowParseObjectTypeMethodish(t) {
                    for(t.params = [], t.rest = null, t.typeParameters = null, this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(c4.parenL); !this.match(c4.parenR) && !this.match(c4.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()), this.match(c4.parenR) || this.expect(c4.comma);
                    return this.eat(c4.ellipsis) && (t.rest = this.flowParseFunctionTypeParam()), this.expect(c4.parenR), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, "FunctionTypeAnnotation");
                }
                flowParseObjectTypeCallProperty(t, e) {
                    const s7 = this.startNode();
                    return t.static = e, t.value = this.flowParseObjectTypeMethodish(s7), this.finishNode(t, "ObjectTypeCallProperty");
                }
                flowParseObjectType({ allowStatic: t , allowExact: e , allowSpread: s , allowProto: r , allowInexact: i  }) {
                    const n6 = this.state.inType;
                    this.state.inType = !0;
                    const a5 = this.startNode();
                    let o5, u5;
                    a5.callProperties = [], a5.properties = [], a5.indexers = [], a5.internalSlots = [];
                    let h5 = !1;
                    for(e && this.match(c4.braceBarL) ? (this.expect(c4.braceBarL), o5 = c4.braceBarR, u5 = !0) : (this.expect(c4.braceL), o5 = c4.braceR, u5 = !1), a5.exact = u5; !this.match(o5);){
                        let e23 = !1, n7 = null, o6 = null;
                        const p5 = this.startNode();
                        if (r && this.isContextual("proto")) {
                            const e24 = this.lookahead();
                            e24.type !== c4.colon && e24.type !== c4.question && (this.next(), n7 = this.state.start, t = !1);
                        }
                        if (t && this.isContextual("static")) {
                            const t20 = this.lookahead();
                            t20.type !== c4.colon && t20.type !== c4.question && (this.next(), e23 = !0);
                        }
                        const l5 = this.flowParseVariance();
                        if (this.eat(c4.bracketL)) null != n7 && this.unexpected(n7), this.eat(c4.bracketL) ? (l5 && this.unexpected(l5.start), a5.internalSlots.push(this.flowParseObjectTypeInternalSlot(p5, e23))) : a5.indexers.push(this.flowParseObjectTypeIndexer(p5, e23, l5));
                        else if (this.match(c4.parenL) || this.isRelational("<")) null != n7 && this.unexpected(n7), l5 && this.unexpected(l5.start), a5.callProperties.push(this.flowParseObjectTypeCallProperty(p5, e23));
                        else {
                            let t20 = "init";
                            if (this.isContextual("get") || this.isContextual("set")) {
                                const e24 = this.lookahead();
                                e24.type !== c4.name && e24.type !== c4.string && e24.type !== c4.num || (t20 = this.state.value, this.next());
                            }
                            const r6 = this.flowParseObjectTypeProperty(p5, e23, n7, l5, t20, s, null != i ? i : !u5);
                            null === r6 ? (h5 = !0, o6 = this.state.lastTokStart) : a5.properties.push(r6);
                        }
                        this.flowObjectTypeSemicolon(), !o6 || this.match(c4.braceR) || this.match(c4.braceBarR) || this.raise(o6, K3.UnexpectedExplicitInexactInObject);
                    }
                    this.expect(o5), s && (a5.inexact = h5);
                    const p5 = this.finishNode(a5, "ObjectTypeAnnotation");
                    return this.state.inType = n6, p5;
                }
                flowParseObjectTypeProperty(t, e, s, r, i, n, a) {
                    if (this.eat(c4.ellipsis)) {
                        return this.match(c4.comma) || this.match(c4.semi) || this.match(c4.braceR) || this.match(c4.braceBarR) ? (n ? a || this.raise(this.state.lastTokStart, K3.InexactInsideExact) : this.raise(this.state.lastTokStart, K3.InexactInsideNonObject), r && this.raise(r.start, K3.InexactVariance), null) : (n || this.raise(this.state.lastTokStart, K3.UnexpectedSpreadType), null != s && this.unexpected(s), r && this.raise(r.start, K3.SpreadVariance), t.argument = this.flowParseType(), this.finishNode(t, "ObjectTypeSpreadProperty"));
                    }
                    {
                        t.key = this.flowParseObjectPropertyKey(), t.static = e, t.proto = null != s, t.kind = i;
                        let n6 = !1;
                        return this.isRelational("<") || this.match(c4.parenL) ? (t.method = !0, null != s && this.unexpected(s), r && this.unexpected(r.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)), "get" !== i && "set" !== i || this.flowCheckGetterSetterParams(t)) : ("init" !== i && this.unexpected(), t.method = !1, this.eat(c4.question) && (n6 = !0), t.value = this.flowParseTypeInitialiser(), t.variance = r), t.optional = n6, this.finishNode(t, "ObjectTypeProperty");
                    }
                }
                flowCheckGetterSetterParams(t) {
                    const e23 = "get" === t.kind ? 0 : 1, s7 = t.start;
                    t.value.params.length + (t.value.rest ? 1 : 0) !== e23 && ("get" === t.kind ? this.raise(s7, g4.BadGetterArity) : this.raise(s7, g4.BadSetterArity)), "set" === t.kind && t.value.rest && this.raise(s7, g4.BadSetterRestParameter);
                }
                flowObjectTypeSemicolon() {
                    this.eat(c4.semi) || this.eat(c4.comma) || this.match(c4.braceR) || this.match(c4.braceBarR) || this.unexpected();
                }
                flowParseQualifiedTypeIdentifier(t, e, s) {
                    t = t || this.state.start, e = e || this.state.startLoc;
                    let r6 = s || this.flowParseRestrictedIdentifier(!0);
                    for(; this.eat(c4.dot);){
                        const s7 = this.startNodeAt(t, e);
                        s7.qualification = r6, s7.id = this.flowParseRestrictedIdentifier(!0), r6 = this.finishNode(s7, "QualifiedTypeIdentifier");
                    }
                    return r6;
                }
                flowParseGenericType(t, e, s) {
                    const r6 = this.startNodeAt(t, e);
                    return r6.typeParameters = null, r6.id = this.flowParseQualifiedTypeIdentifier(t, e, s), this.isRelational("<") && (r6.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r6, "GenericTypeAnnotation");
                }
                flowParseTypeofType() {
                    const t20 = this.startNode();
                    return this.expect(c4._typeof), t20.argument = this.flowParsePrimaryType(), this.finishNode(t20, "TypeofTypeAnnotation");
                }
                flowParseTupleType() {
                    const t20 = this.startNode();
                    for(t20.types = [], this.expect(c4.bracketL); this.state.pos < this.length && !this.match(c4.bracketR) && (t20.types.push(this.flowParseType()), !this.match(c4.bracketR));)this.expect(c4.comma);
                    return this.expect(c4.bracketR), this.finishNode(t20, "TupleTypeAnnotation");
                }
                flowParseFunctionTypeParam() {
                    let t20 = null, e23 = !1, s7 = null;
                    const r6 = this.startNode(), i6 = this.lookahead();
                    return i6.type === c4.colon || i6.type === c4.question ? (t20 = this.parseIdentifier(), this.eat(c4.question) && (e23 = !0), s7 = this.flowParseTypeInitialiser()) : s7 = this.flowParseType(), r6.name = t20, r6.optional = e23, r6.typeAnnotation = s7, this.finishNode(r6, "FunctionTypeParam");
                }
                reinterpretTypeAsFunctionTypeParam(t) {
                    const e23 = this.startNodeAt(t.start, t.loc.start);
                    return e23.name = null, e23.optional = !1, e23.typeAnnotation = t, this.finishNode(e23, "FunctionTypeParam");
                }
                flowParseFunctionTypeParams(t = []) {
                    let e23 = null;
                    for(; !this.match(c4.parenR) && !this.match(c4.ellipsis);)t.push(this.flowParseFunctionTypeParam()), this.match(c4.parenR) || this.expect(c4.comma);
                    return this.eat(c4.ellipsis) && (e23 = this.flowParseFunctionTypeParam()), {
                        params: t,
                        rest: e23
                    };
                }
                flowIdentToTypeAnnotation(t, e, s, r) {
                    switch(r.name){
                        case "any":
                            return this.finishNode(s, "AnyTypeAnnotation");
                        case "bool":
                        case "boolean":
                            return this.finishNode(s, "BooleanTypeAnnotation");
                        case "mixed":
                            return this.finishNode(s, "MixedTypeAnnotation");
                        case "empty":
                            return this.finishNode(s, "EmptyTypeAnnotation");
                        case "number":
                            return this.finishNode(s, "NumberTypeAnnotation");
                        case "string":
                            return this.finishNode(s, "StringTypeAnnotation");
                        case "symbol":
                            return this.finishNode(s, "SymbolTypeAnnotation");
                        default:
                            return this.checkNotUnderscore(r.name), this.flowParseGenericType(t, e, r);
                    }
                }
                flowParsePrimaryType() {
                    const t20 = this.state.start, e23 = this.state.startLoc, s7 = this.startNode();
                    let r6, i6, n6 = !1;
                    const a5 = this.state.noAnonFunctionType;
                    switch(this.state.type){
                        case c4.name:
                            return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t20, e23, s7, this.parseIdentifier());
                        case c4.braceL:
                            return this.flowParseObjectType({
                                allowStatic: !1,
                                allowExact: !1,
                                allowSpread: !0,
                                allowProto: !1,
                                allowInexact: !0
                            });
                        case c4.braceBarL:
                            return this.flowParseObjectType({
                                allowStatic: !1,
                                allowExact: !0,
                                allowSpread: !0,
                                allowProto: !1,
                                allowInexact: !1
                            });
                        case c4.bracketL:
                            return this.state.noAnonFunctionType = !1, i6 = this.flowParseTupleType(), this.state.noAnonFunctionType = a5, i6;
                        case c4.relational:
                            if ("<" === this.state.value) return s7.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(c4.parenL), r6 = this.flowParseFunctionTypeParams(), s7.params = r6.params, s7.rest = r6.rest, this.expect(c4.parenR), this.expect(c4.arrow), s7.returnType = this.flowParseType(), this.finishNode(s7, "FunctionTypeAnnotation");
                            break;
                        case c4.parenL:
                            if (this.next(), !this.match(c4.parenR) && !this.match(c4.ellipsis)) {
                                if (this.match(c4.name)) {
                                    const t21 = this.lookahead().type;
                                    n6 = t21 !== c4.question && t21 !== c4.colon;
                                } else n6 = !0;
                            }
                            if (n6) {
                                if (this.state.noAnonFunctionType = !1, i6 = this.flowParseType(), this.state.noAnonFunctionType = a5, this.state.noAnonFunctionType || !(this.match(c4.comma) || this.match(c4.parenR) && this.lookahead().type === c4.arrow)) return this.expect(c4.parenR), i6;
                                this.eat(c4.comma);
                            }
                            return r6 = i6 ? this.flowParseFunctionTypeParams([
                                this.reinterpretTypeAsFunctionTypeParam(i6)
                            ]) : this.flowParseFunctionTypeParams(), s7.params = r6.params, s7.rest = r6.rest, this.expect(c4.parenR), this.expect(c4.arrow), s7.returnType = this.flowParseType(), s7.typeParameters = null, this.finishNode(s7, "FunctionTypeAnnotation");
                        case c4.string:
                            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                        case c4._true:
                        case c4._false:
                            return s7.value = this.match(c4._true), this.next(), this.finishNode(s7, "BooleanLiteralTypeAnnotation");
                        case c4.plusMin:
                            if ("-" === this.state.value) {
                                if (this.next(), this.match(c4.num)) return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", s7.start, s7.loc.start);
                                if (this.match(c4.bigint)) return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", s7.start, s7.loc.start);
                                throw this.raise(this.state.start, K3.UnexpectedSubtractionOperand);
                            }
                            throw this.unexpected();
                        case c4.num:
                            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                        case c4.bigint:
                            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                        case c4._void:
                            return this.next(), this.finishNode(s7, "VoidTypeAnnotation");
                        case c4._null:
                            return this.next(), this.finishNode(s7, "NullLiteralTypeAnnotation");
                        case c4._this:
                            return this.next(), this.finishNode(s7, "ThisTypeAnnotation");
                        case c4.star:
                            return this.next(), this.finishNode(s7, "ExistsTypeAnnotation");
                        default:
                            if ("typeof" === this.state.type.keyword) return this.flowParseTypeofType();
                            if (this.state.type.keyword) {
                                const t21 = this.state.type.label;
                                return this.next(), super.createIdentifier(s7, t21);
                            }
                    }
                    throw this.unexpected();
                }
                flowParsePostfixType() {
                    const t20 = this.state.start, e23 = this.state.startLoc;
                    let s7 = this.flowParsePrimaryType();
                    for(; this.match(c4.bracketL) && !this.canInsertSemicolon();){
                        const r6 = this.startNodeAt(t20, e23);
                        r6.elementType = s7, this.expect(c4.bracketL), this.expect(c4.bracketR), s7 = this.finishNode(r6, "ArrayTypeAnnotation");
                    }
                    return s7;
                }
                flowParsePrefixType() {
                    const t20 = this.startNode();
                    return this.eat(c4.question) ? (t20.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t20, "NullableTypeAnnotation")) : this.flowParsePostfixType();
                }
                flowParseAnonFunctionWithoutParens() {
                    const t20 = this.flowParsePrefixType();
                    if (!this.state.noAnonFunctionType && this.eat(c4.arrow)) {
                        const e23 = this.startNodeAt(t20.start, t20.loc.start);
                        return e23.params = [
                            this.reinterpretTypeAsFunctionTypeParam(t20)
                        ], e23.rest = null, e23.returnType = this.flowParseType(), e23.typeParameters = null, this.finishNode(e23, "FunctionTypeAnnotation");
                    }
                    return t20;
                }
                flowParseIntersectionType() {
                    const t20 = this.startNode();
                    this.eat(c4.bitwiseAND);
                    const e23 = this.flowParseAnonFunctionWithoutParens();
                    for(t20.types = [
                        e23
                    ]; this.eat(c4.bitwiseAND);)t20.types.push(this.flowParseAnonFunctionWithoutParens());
                    return 1 === t20.types.length ? e23 : this.finishNode(t20, "IntersectionTypeAnnotation");
                }
                flowParseUnionType() {
                    const t20 = this.startNode();
                    this.eat(c4.bitwiseOR);
                    const e23 = this.flowParseIntersectionType();
                    for(t20.types = [
                        e23
                    ]; this.eat(c4.bitwiseOR);)t20.types.push(this.flowParseIntersectionType());
                    return 1 === t20.types.length ? e23 : this.finishNode(t20, "UnionTypeAnnotation");
                }
                flowParseType() {
                    const t20 = this.state.inType;
                    this.state.inType = !0;
                    const e23 = this.flowParseUnionType();
                    return this.state.inType = t20, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e23;
                }
                flowParseTypeOrImplicitInstantiation() {
                    if (this.state.type === c4.name && "_" === this.state.value) {
                        const t20 = this.state.start, e23 = this.state.startLoc, s7 = this.parseIdentifier();
                        return this.flowParseGenericType(t20, e23, s7);
                    }
                    return this.flowParseType();
                }
                flowParseTypeAnnotation() {
                    const t20 = this.startNode();
                    return t20.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t20, "TypeAnnotation");
                }
                flowParseTypeAnnotatableIdentifier(t) {
                    const e23 = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                    return this.match(c4.colon) && (e23.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e23)), e23;
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;
                }
                flowParseVariance() {
                    let t20 = null;
                    return this.match(c4.plusMin) && (t20 = this.startNode(), "+" === this.state.value ? t20.kind = "plus" : t20.kind = "minus", this.next(), this.finishNode(t20, "Variance")), t20;
                }
                parseFunctionBody(t, e, s = !1) {
                    return e ? this.forwardNoArrowParamsConversionAt(t, ()=>super.parseFunctionBody(t, !0, s)
                    ) : super.parseFunctionBody(t, !1, s);
                }
                parseFunctionBodyAndFinish(t, e, s = !1) {
                    if (this.match(c4.colon)) {
                        const e23 = this.startNode();
                        [e23.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = e23.typeAnnotation ? this.finishNode(e23, "TypeAnnotation") : null;
                    }
                    super.parseFunctionBodyAndFinish(t, e, s);
                }
                parseStatement(t, e) {
                    if (this.state.strict && this.match(c4.name) && "interface" === this.state.value) {
                        const t20 = this.lookahead();
                        if (t20.type === c4.name || W2(t20.value)) {
                            const t21 = this.startNode();
                            return this.next(), this.flowParseInterface(t21);
                        }
                    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
                        const t20 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(t20);
                    }
                    const s7 = super.parseStatement(t, e);
                    return (void 0) !== this.flowPragma || this.isValidDirective(s7) || (this.flowPragma = null), s7;
                }
                parseExpressionStatement(t, e) {
                    if ("Identifier" === e.type) {
                        if ("declare" === e.name) {
                            if (this.match(c4._class) || this.match(c4.name) || this.match(c4._function) || this.match(c4._var) || this.match(c4._export)) return this.flowParseDeclare(t);
                        } else if (this.match(c4.name)) {
                            if ("interface" === e.name) return this.flowParseInterface(t);
                            if ("type" === e.name) return this.flowParseTypeAlias(t);
                            if ("opaque" === e.name) return this.flowParseOpaqueType(t, !1);
                        }
                    }
                    return super.parseExpressionStatement(t, e);
                }
                shouldParseExportDeclaration() {
                    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
                }
                isExportDefaultSpecifier() {
                    return (!this.match(c4.name) || !("type" === this.state.value || "interface" === this.state.value || "opaque" === this.state.value || this.shouldParseEnums() && "enum" === this.state.value)) && super.isExportDefaultSpecifier();
                }
                parseExportDefaultExpression() {
                    if (this.shouldParseEnums() && this.isContextual("enum")) {
                        const t20 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(t20);
                    }
                    return super.parseExportDefaultExpression();
                }
                parseConditional(t, e, s, r) {
                    if (!this.match(c4.question)) return t;
                    if (r) {
                        const i6 = this.tryParse(()=>super.parseConditional(t, e, s)
                        );
                        return i6.node ? (i6.error && (this.state = i6.failState), i6.node) : (r.start = i6.error.pos || this.state.start, t);
                    }
                    this.expect(c4.question);
                    const i6 = this.state.clone(), n6 = this.state.noArrowAt, a5 = this.startNodeAt(e, s);
                    let { consequent: o5 , failed: u5  } = this.tryParseConditionalConsequent(), [h5, p5] = this.getArrowLikeExpressions(o5);
                    if (u5 || p5.length > 0) {
                        const t20 = [
                            ...n6
                        ];
                        if (p5.length > 0) {
                            this.state = i6, this.state.noArrowAt = t20;
                            for(let e23 = 0; e23 < p5.length; e23++)t20.push(p5[e23].start);
                            ({ consequent: o5 , failed: u5  } = this.tryParseConditionalConsequent()), [h5, p5] = this.getArrowLikeExpressions(o5);
                        }
                        u5 && h5.length > 1 && this.raise(i6.start, K3.AmbiguousConditionalArrow), u5 && 1 === h5.length && (this.state = i6, this.state.noArrowAt = t20.concat(h5[0].start), { consequent: o5 , failed: u5  } = this.tryParseConditionalConsequent());
                    }
                    return this.getArrowLikeExpressions(o5, !0), this.state.noArrowAt = n6, this.expect(c4.colon), a5.test = t, a5.consequent = o5, a5.alternate = this.forwardNoArrowParamsConversionAt(a5, ()=>this.parseMaybeAssign(void 0, void 0, void 0)
                    ), this.finishNode(a5, "ConditionalExpression");
                }
                tryParseConditionalConsequent() {
                    this.state.noArrowParamsConversionAt.push(this.state.start);
                    const t20 = this.parseMaybeAssignAllowIn(), e23 = !this.match(c4.colon);
                    return this.state.noArrowParamsConversionAt.pop(), {
                        consequent: t20,
                        failed: e23
                    };
                }
                getArrowLikeExpressions(t, e) {
                    const s7 = [
                        t
                    ], r6 = [];
                    for(; 0 !== s7.length;){
                        const t20 = s7.pop();
                        "ArrowFunctionExpression" === t20.type ? (t20.typeParameters || !t20.returnType ? this.finishArrowValidation(t20) : r6.push(t20), s7.push(t20.body)) : "ConditionalExpression" === t20.type && (s7.push(t20.consequent), s7.push(t20.alternate));
                    }
                    return e ? (r6.forEach((t20)=>this.finishArrowValidation(t20)
                    ), [
                        r6,
                        []
                    ]) : (function(t20, e23) {
                        const s8 = [], r7 = [];
                        for(let i6 = 0; i6 < t20.length; i6++)(e23(t20[i6], i6, t20) ? s8 : r7).push(t20[i6]);
                        return [
                            s8,
                            r7
                        ];
                    })(r6, (t20)=>t20.params.every((t21)=>this.isAssignable(t21, !0)
                        )
                    );
                }
                finishArrowValidation(t) {
                    var e23;
                    this.toAssignableList(t.params, null == (e23 = t.extra) ? void 0 : e23.trailingComma), this.scope.enter(6), super.checkParams(t, !1, !0), this.scope.exit();
                }
                forwardNoArrowParamsConversionAt(t, e) {
                    let s7;
                    return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s7 = e(), this.state.noArrowParamsConversionAt.pop()) : s7 = e(), s7;
                }
                parseParenItem(t, e, s) {
                    if (t = super.parseParenItem(t, e, s), this.eat(c4.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(c4.colon)) {
                        const r6 = this.startNodeAt(e, s);
                        return r6.expression = t, r6.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r6, "TypeCastExpression");
                    }
                    return t;
                }
                assertModuleNodeAllowed(t) {
                    "ImportDeclaration" === t.type && ("type" === t.importKind || "typeof" === t.importKind) || "ExportNamedDeclaration" === t.type && "type" === t.exportKind || "ExportAllDeclaration" === t.type && "type" === t.exportKind || super.assertModuleNodeAllowed(t);
                }
                parseExport(t) {
                    const e23 = super.parseExport(t);
                    return "ExportNamedDeclaration" !== e23.type && "ExportAllDeclaration" !== e23.type || (e23.exportKind = e23.exportKind || "value"), e23;
                }
                parseExportDeclaration(t) {
                    if (this.isContextual("type")) {
                        t.exportKind = "type";
                        const e23 = this.startNode();
                        return this.next(), this.match(c4.braceL) ? (t.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t), null) : this.flowParseTypeAlias(e23);
                    }
                    if (this.isContextual("opaque")) {
                        t.exportKind = "type";
                        const e23 = this.startNode();
                        return this.next(), this.flowParseOpaqueType(e23, !1);
                    }
                    if (this.isContextual("interface")) {
                        t.exportKind = "type";
                        const e23 = this.startNode();
                        return this.next(), this.flowParseInterface(e23);
                    }
                    if (this.shouldParseEnums() && this.isContextual("enum")) {
                        t.exportKind = "value";
                        const e23 = this.startNode();
                        return this.next(), this.flowParseEnumDeclaration(e23);
                    }
                    return super.parseExportDeclaration(t);
                }
                eatExportStar(t) {
                    return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== c4.star) && (t.exportKind = "type", this.next(), this.next(), !0);
                }
                maybeParseExportNamespaceSpecifier(t) {
                    const e23 = this.state.start, s7 = super.maybeParseExportNamespaceSpecifier(t);
                    return s7 && "type" === t.exportKind && this.unexpected(e23), s7;
                }
                parseClassId(t, e, s) {
                    super.parseClassId(t, e, s), this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration());
                }
                parseClassMember(t, e, s) {
                    const r6 = this.state.start;
                    if (this.isContextual("declare")) {
                        if (this.parseClassMemberFromModifier(t, e)) return;
                        e.declare = !0;
                    }
                    super.parseClassMember(t, e, s), e.declare && ("ClassProperty" !== e.type && "ClassPrivateProperty" !== e.type ? this.raise(r6, K3.DeclareClassElement) : e.value && this.raise(e.value.start, K3.DeclareClassFieldInitializer));
                }
                getTokenFromCode(t) {
                    const e23 = this.input.charCodeAt(this.state.pos + 1);
                    return 123 === t && 124 === e23 ? this.finishOp(c4.braceBarL, 2) : !this.state.inType || 62 !== t && 60 !== t ? this.state.inType && 63 === t ? this.finishOp(c4.question, 1) : (function(t20, e24) {
                        return 64 === t20 && 64 === e24;
                    })(t, e23) ? (this.state.isIterator = !0, super.readWord()) : super.getTokenFromCode(t) : this.finishOp(c4.relational, 1);
                }
                isAssignable(t, e) {
                    switch(t.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                            return !0;
                        case "ObjectExpression":
                            {
                                const e23 = t.properties.length - 1;
                                return t.properties.every((t20, s7)=>"ObjectMethod" !== t20.type && (s7 === e23 || "SpreadElement" === t20.type) && this.isAssignable(t20)
                                );
                            }
                        case "ObjectProperty":
                            return this.isAssignable(t.value);
                        case "SpreadElement":
                            return this.isAssignable(t.argument);
                        case "ArrayExpression":
                            return t.elements.every((t20)=>this.isAssignable(t20)
                            );
                        case "AssignmentExpression":
                            return "=" === t.operator;
                        case "ParenthesizedExpression":
                        case "TypeCastExpression":
                            return this.isAssignable(t.expression);
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return !e;
                        default:
                            return !1;
                    }
                }
                toAssignable(t) {
                    return "TypeCastExpression" === t.type ? super.toAssignable(this.typeCastToParameter(t)) : super.toAssignable(t);
                }
                toAssignableList(t, e) {
                    for(let e23 = 0; e23 < t.length; e23++){
                        const s7 = t[e23];
                        "TypeCastExpression" === (null == s7 ? void 0 : s7.type) && (t[e23] = this.typeCastToParameter(s7));
                    }
                    return super.toAssignableList(t, e);
                }
                toReferencedList(t, e) {
                    for(let r6 = 0; r6 < t.length; r6++){
                        var s7;
                        const i6 = t[r6];
                        i6 && "TypeCastExpression" === i6.type && !(null == (s7 = i6.extra) ? void 0 : s7.parenthesized) && (t.length > 1 || !e) && this.raise(i6.typeAnnotation.start, K3.TypeCastInPattern);
                    }
                    return t;
                }
                parseArrayLike(t, e, s, r) {
                    const i6 = super.parseArrayLike(t, e, s, r);
                    return e && !this.state.maybeInArrowParameters && this.toReferencedList(i6.elements), i6;
                }
                checkLVal(t, e = 64, s, r) {
                    if ("TypeCastExpression" !== t.type) return super.checkLVal(t, e, s, r);
                }
                parseClassProperty(t) {
                    return this.match(c4.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t);
                }
                parseClassPrivateProperty(t) {
                    return this.match(c4.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t);
                }
                isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                }
                isClassProperty() {
                    return this.match(c4.colon) || super.isClassProperty();
                }
                isNonstaticConstructor(t) {
                    return !this.match(c4.colon) && super.isNonstaticConstructor(t);
                }
                pushClassMethod(t, e, s, r, i, n) {
                    e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t, e, s, r, i, n);
                }
                pushClassPrivateMethod(t, e, s, r) {
                    e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t, e, s, r);
                }
                parseClassSuper(t) {
                    if (super.parseClassSuper(t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
                        this.next();
                        const e23 = t.implements = [];
                        do {
                            const t20 = this.startNode();
                            t20.id = this.flowParseRestrictedIdentifier(!0), this.isRelational("<") ? t20.typeParameters = this.flowParseTypeParameterInstantiation() : t20.typeParameters = null, e23.push(this.finishNode(t20, "ClassImplements"));
                        }while (this.eat(c4.comma))
                    }
                }
                parsePropertyName(t, e) {
                    const s7 = this.flowParseVariance(), r6 = super.parsePropertyName(t, e);
                    return t.variance = s7, r6;
                }
                parseObjPropValue(t, e, s, r, i, n, a, o) {
                    let u5;
                    t.variance && this.unexpected(t.variance.start), delete t.variance, this.isRelational("<") && !a && (u5 = this.flowParseTypeParameterDeclaration(), this.match(c4.parenL) || this.unexpected()), super.parseObjPropValue(t, e, s, r, i, n, a, o), u5 && ((t.value || t).typeParameters = u5);
                }
                parseAssignableListItemTypes(t) {
                    return this.eat(c4.question) && ("Identifier" !== t.type && this.raise(t.start, K3.OptionalBindingPattern), t.optional = !0), this.match(c4.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t), t;
                }
                parseMaybeDefault(t, e, s) {
                    const r6 = super.parseMaybeDefault(t, e, s);
                    return "AssignmentPattern" === r6.type && r6.typeAnnotation && r6.right.start < r6.typeAnnotation.start && this.raise(r6.typeAnnotation.start, K3.TypeBeforeInitializer), r6;
                }
                shouldParseDefaultImport(t) {
                    return J2(t) ? $3(this.state) : super.shouldParseDefaultImport(t);
                }
                parseImportSpecifierLocal(t, e, s, r) {
                    e.local = J2(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, r), t.specifiers.push(this.finishNode(e, s));
                }
                maybeParseDefaultImportSpecifier(t) {
                    t.importKind = "value";
                    let e23 = null;
                    if (this.match(c4._typeof) ? e23 = "typeof" : this.isContextual("type") && (e23 = "type"), e23) {
                        const s7 = this.lookahead();
                        "type" === e23 && s7.type === c4.star && this.unexpected(s7.start), ($3(s7) || s7.type === c4.braceL || s7.type === c4.star) && (this.next(), t.importKind = e23);
                    }
                    return super.maybeParseDefaultImportSpecifier(t);
                }
                parseImportSpecifier(t) {
                    const e23 = this.startNode(), s7 = this.state.start, r6 = this.parseModuleExportName();
                    let i6 = null;
                    "Identifier" === r6.type && ("type" === r6.name ? i6 = "type" : "typeof" === r6.name && (i6 = "typeof"));
                    let n6 = !1;
                    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
                        const t20 = this.parseIdentifier(!0);
                        null === i6 || this.match(c4.name) || this.state.type.keyword ? (e23.imported = r6, e23.importKind = null, e23.local = this.parseIdentifier()) : (e23.imported = t20, e23.importKind = i6, e23.local = t20.__clone());
                    } else if (null !== i6 && (this.match(c4.name) || this.state.type.keyword)) e23.imported = this.parseIdentifier(!0), e23.importKind = i6, this.eatContextual("as") ? e23.local = this.parseIdentifier() : (n6 = !0, e23.local = e23.imported.__clone());
                    else {
                        if ("StringLiteral" === r6.type) throw this.raise(e23.start, g4.ImportBindingIsString, r6.value);
                        n6 = !0, e23.imported = r6, e23.importKind = null, e23.local = e23.imported.__clone();
                    }
                    const a5 = J2(t), o5 = J2(e23);
                    a5 && o5 && this.raise(s7, K3.ImportTypeShorthandOnlyInPureImport), (a5 || o5) && this.checkReservedType(e23.local.name, e23.local.start, !0), !n6 || a5 || o5 || this.checkReservedWord(e23.local.name, e23.start, !0, !0), this.checkLVal(e23.local, 9, void 0, "import specifier"), t.specifiers.push(this.finishNode(e23, "ImportSpecifier"));
                }
                parseFunctionParams(t, e) {
                    const s7 = t.kind;
                    "get" !== s7 && "set" !== s7 && this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t, e);
                }
                parseVarId(t, e) {
                    super.parseVarId(t, e), this.match(c4.colon) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id));
                }
                parseAsyncArrowFromCallExpression(t, e) {
                    if (this.match(c4.colon)) {
                        const e23 = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e23;
                    }
                    return super.parseAsyncArrowFromCallExpression(t, e);
                }
                shouldParseAsyncArrow() {
                    return this.match(c4.colon) || super.shouldParseAsyncArrow();
                }
                parseMaybeAssign(t, e, s) {
                    var r6;
                    let i6, n6 = null;
                    if (this.hasPlugin("jsx") && (this.match(c4.jsxTagStart) || this.isRelational("<"))) {
                        if (n6 = this.state.clone(), i6 = this.tryParse(()=>super.parseMaybeAssign(t, e, s)
                        , n6), !i6.error) return i6.node;
                        const { context: r7  } = this.state;
                        r7[r7.length - 1] === T4.j_oTag ? r7.length -= 2 : r7[r7.length - 1] === T4.j_expr && (r7.length -= 1);
                    }
                    if ((null == (r6 = i6) ? void 0 : r6.error) || this.isRelational("<")) {
                        var a5, o5;
                        let r7;
                        n6 = n6 || this.state.clone();
                        const u5 = this.tryParse((i7)=>{
                            var n7;
                            r7 = this.flowParseTypeParameterDeclaration();
                            const a6 = this.forwardNoArrowParamsConversionAt(r7, ()=>{
                                const i8 = super.parseMaybeAssign(t, e, s);
                                return this.resetStartLocationFromNode(i8, r7), i8;
                            });
                            "ArrowFunctionExpression" !== a6.type && (null == (n7 = a6.extra) ? void 0 : n7.parenthesized) && i7();
                            const o6 = this.maybeUnwrapTypeCastExpression(a6);
                            return o6.typeParameters = r7, this.resetStartLocationFromNode(o6, r7), a6;
                        }, n6);
                        let h5 = null;
                        if (u5.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(u5.node).type) {
                            if (!u5.error && !u5.aborted) return u5.node.async && this.raise(r7.start, K3.UnexpectedTypeParameterBeforeAsyncArrowFunction), u5.node;
                            h5 = u5.node;
                        }
                        if (null == (a5 = i6) ? void 0 : a5.node) return this.state = i6.failState, i6.node;
                        if (h5) return this.state = u5.failState, h5;
                        if (null == (o5 = i6) ? void 0 : o5.thrown) throw i6.error;
                        if (u5.thrown) throw u5.error;
                        throw this.raise(r7.start, K3.UnexpectedTokenAfterTypeParameter);
                    }
                    return super.parseMaybeAssign(t, e, s);
                }
                parseArrow(t) {
                    if (this.match(c4.colon)) {
                        const e23 = this.tryParse(()=>{
                            const e24 = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = !0;
                            const s7 = this.startNode();
                            return [s7.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e24, this.canInsertSemicolon() && this.unexpected(), this.match(c4.arrow) || this.unexpected(), s7;
                        });
                        if (e23.thrown) return null;
                        e23.error && (this.state = e23.failState), t.returnType = e23.node.typeAnnotation ? this.finishNode(e23.node, "TypeAnnotation") : null;
                    }
                    return super.parseArrow(t);
                }
                shouldParseArrow() {
                    return this.match(c4.colon) || super.shouldParseArrow();
                }
                setArrowFunctionParameters(t, e) {
                    -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? t.params = e : super.setArrowFunctionParameters(t, e);
                }
                checkParams(t, e, s) {
                    if (!s || -1 === this.state.noArrowParamsConversionAt.indexOf(t.start)) return super.checkParams(...arguments);
                }
                parseParenAndDistinguishExpression(t) {
                    return super.parseParenAndDistinguishExpression(t && -1 === this.state.noArrowAt.indexOf(this.state.start));
                }
                parseSubscripts(t, e, s, r) {
                    if ("Identifier" === t.type && "async" === t.name && -1 !== this.state.noArrowAt.indexOf(e)) {
                        this.next();
                        const r6 = this.startNodeAt(e, s);
                        r6.callee = t, r6.arguments = this.parseCallExpressionArguments(c4.parenR, !1), t = this.finishNode(r6, "CallExpression");
                    } else if ("Identifier" === t.type && "async" === t.name && this.isRelational("<")) {
                        const i6 = this.state.clone(), n6 = this.tryParse((t20)=>this.parseAsyncArrowWithTypeParameters(e, s) || t20()
                        , i6);
                        if (!n6.error && !n6.aborted) return n6.node;
                        const a5 = this.tryParse(()=>super.parseSubscripts(t, e, s, r)
                        , i6);
                        if (a5.node && !a5.error) return a5.node;
                        if (n6.node) return this.state = n6.failState, n6.node;
                        if (a5.node) return this.state = a5.failState, a5.node;
                        throw n6.error || a5.error;
                    }
                    return super.parseSubscripts(t, e, s, r);
                }
                parseSubscript(t, e, s, r, i) {
                    if (this.match(c4.questionDot) && this.isLookaheadToken_lt()) {
                        if (i.optionalChainMember = !0, r) return i.stop = !0, t;
                        this.next();
                        const n6 = this.startNodeAt(e, s);
                        return n6.callee = t, n6.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(c4.parenL), n6.arguments = this.parseCallExpressionArguments(c4.parenR, !1), n6.optional = !0, this.finishCallExpression(n6, !0);
                    }
                    if (!r && this.shouldParseTypes() && this.isRelational("<")) {
                        const r6 = this.startNodeAt(e, s);
                        r6.callee = t;
                        const n6 = this.tryParse(()=>(r6.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(c4.parenL), r6.arguments = this.parseCallExpressionArguments(c4.parenR, !1), i.optionalChainMember && (r6.optional = !1), this.finishCallExpression(r6, i.optionalChainMember))
                        );
                        if (n6.node) return n6.error && (this.state = n6.failState), n6.node;
                    }
                    return super.parseSubscript(t, e, s, r, i);
                }
                parseNewArguments(t) {
                    let e23 = null;
                    this.shouldParseTypes() && this.isRelational("<") && (e23 = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()
                    ).node), t.typeArguments = e23, super.parseNewArguments(t);
                }
                parseAsyncArrowWithTypeParameters(t, e) {
                    const s7 = this.startNodeAt(t, e);
                    if (this.parseFunctionParams(s7), this.parseArrow(s7)) return this.parseArrowExpression(s7, void 0, !0);
                }
                readToken_mult_modulo(t) {
                    const e23 = this.input.charCodeAt(this.state.pos + 1);
                    if (42 === t && 47 === e23 && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
                    super.readToken_mult_modulo(t);
                }
                readToken_pipe_amp(t) {
                    const e23 = this.input.charCodeAt(this.state.pos + 1);
                    124 !== t || 125 !== e23 ? super.readToken_pipe_amp(t) : this.finishOp(c4.braceBarR, 2);
                }
                parseTopLevel(t, e) {
                    const s7 = super.parseTopLevel(t, e);
                    return this.state.hasFlowComment && this.raise(this.state.pos, K3.UnterminatedFlowComment), s7;
                }
                skipBlockComment() {
                    if (this.hasPlugin("flowComments") && this.skipFlowComment()) return this.state.hasFlowComment && this.unexpected(null, K3.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0);
                    if (this.state.hasFlowComment) {
                        const t20 = this.input.indexOf("*-/", this.state.pos += 2);
                        if (-1 === t20) throw this.raise(this.state.pos - 2, g4.UnterminatedComment);
                        this.state.pos = t20 + 3;
                    } else super.skipBlockComment();
                }
                skipFlowComment() {
                    const { pos: t20  } = this.state;
                    let e23 = 2;
                    for(; [
                        32,
                        9
                    ].includes(this.input.charCodeAt(t20 + e23));)e23++;
                    const s7 = this.input.charCodeAt(e23 + t20), r6 = this.input.charCodeAt(e23 + t20 + 1);
                    return 58 === s7 && 58 === r6 ? e23 + 2 : "flow-include" === this.input.slice(e23 + t20, e23 + t20 + 12) ? e23 + 12 : 58 === s7 && 58 !== r6 && e23;
                }
                hasFlowCommentCompletion() {
                    if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(this.state.pos, g4.UnterminatedComment);
                }
                flowEnumErrorBooleanMemberNotInitialized(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K3.EnumBooleanMemberNotInitialized, s, e);
                }
                flowEnumErrorInvalidMemberName(t, { enumName: e , memberName: s  }) {
                    const r6 = s[0].toUpperCase() + s.slice(1);
                    this.raise(t, K3.EnumInvalidMemberName, s, r6, e);
                }
                flowEnumErrorDuplicateMemberName(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K3.EnumDuplicateMemberName, s, e);
                }
                flowEnumErrorInconsistentMemberValues(t, { enumName: e  }) {
                    this.raise(t, K3.EnumInconsistentMemberValues, e);
                }
                flowEnumErrorInvalidExplicitType(t, { enumName: e , suppliedType: s  }) {
                    return this.raise(t, null === s ? K3.EnumInvalidExplicitTypeUnknownSupplied : K3.EnumInvalidExplicitType, e, s);
                }
                flowEnumErrorInvalidMemberInitializer(t, { enumName: e , explicitType: s , memberName: r  }) {
                    let i6 = null;
                    switch(s){
                        case "boolean":
                        case "number":
                        case "string":
                            i6 = K3.EnumInvalidMemberInitializerPrimaryType;
                            break;
                        case "symbol":
                            i6 = K3.EnumInvalidMemberInitializerSymbolType;
                            break;
                        default:
                            i6 = K3.EnumInvalidMemberInitializerUnknownType;
                    }
                    return this.raise(t, i6, e, r, s);
                }
                flowEnumErrorNumberMemberNotInitialized(t, { enumName: e , memberName: s  }) {
                    this.raise(t, K3.EnumNumberMemberNotInitialized, e, s);
                }
                flowEnumErrorStringMemberInconsistentlyInitailized(t, { enumName: e  }) {
                    this.raise(t, K3.EnumStringMemberInconsistentlyInitailized, e);
                }
                flowEnumMemberInit() {
                    const t20 = this.state.start, e23 = ()=>this.match(c4.comma) || this.match(c4.braceR)
                    ;
                    switch(this.state.type){
                        case c4.num:
                            {
                                const s7 = this.parseLiteral(this.state.value, "NumericLiteral");
                                return e23() ? {
                                    type: "number",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t20
                                };
                            }
                        case c4.string:
                            {
                                const s7 = this.parseLiteral(this.state.value, "StringLiteral");
                                return e23() ? {
                                    type: "string",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t20
                                };
                            }
                        case c4._true:
                        case c4._false:
                            {
                                const s7 = this.parseBooleanLiteral();
                                return e23() ? {
                                    type: "boolean",
                                    pos: s7.start,
                                    value: s7
                                } : {
                                    type: "invalid",
                                    pos: t20
                                };
                            }
                        default:
                            return {
                                type: "invalid",
                                pos: t20
                            };
                    }
                }
                flowEnumMemberRaw() {
                    const t20 = this.state.start;
                    return {
                        id: this.parseIdentifier(!0),
                        init: this.eat(c4.eq) ? this.flowEnumMemberInit() : {
                            type: "none",
                            pos: t20
                        }
                    };
                }
                flowEnumCheckExplicitTypeMismatch(t, e, s) {
                    const { explicitType: r6  } = e;
                    null !== r6 && r6 !== s && this.flowEnumErrorInvalidMemberInitializer(t, e);
                }
                flowEnumMembers({ enumName: t , explicitType: e  }) {
                    const s7 = new Set, r6 = {
                        booleanMembers: [],
                        numberMembers: [],
                        stringMembers: [],
                        defaultedMembers: []
                    };
                    for(; !this.match(c4.braceR);){
                        const i6 = this.startNode(), { id: n6 , init: a5  } = this.flowEnumMemberRaw(), o5 = n6.name;
                        if ("" === o5) continue;
                        /^[a-z]/.test(o5) && this.flowEnumErrorInvalidMemberName(n6.start, {
                            enumName: t,
                            memberName: o5
                        }), s7.has(o5) && this.flowEnumErrorDuplicateMemberName(n6.start, {
                            enumName: t,
                            memberName: o5
                        }), s7.add(o5);
                        const u5 = {
                            enumName: t,
                            explicitType: e,
                            memberName: o5
                        };
                        switch(i6.id = n6, a5.type){
                            case "boolean":
                                this.flowEnumCheckExplicitTypeMismatch(a5.pos, u5, "boolean"), i6.init = a5.value, r6.booleanMembers.push(this.finishNode(i6, "EnumBooleanMember"));
                                break;
                            case "number":
                                this.flowEnumCheckExplicitTypeMismatch(a5.pos, u5, "number"), i6.init = a5.value, r6.numberMembers.push(this.finishNode(i6, "EnumNumberMember"));
                                break;
                            case "string":
                                this.flowEnumCheckExplicitTypeMismatch(a5.pos, u5, "string"), i6.init = a5.value, r6.stringMembers.push(this.finishNode(i6, "EnumStringMember"));
                                break;
                            case "invalid":
                                throw this.flowEnumErrorInvalidMemberInitializer(a5.pos, u5);
                            case "none":
                                switch(e){
                                    case "boolean":
                                        this.flowEnumErrorBooleanMemberNotInitialized(a5.pos, u5);
                                        break;
                                    case "number":
                                        this.flowEnumErrorNumberMemberNotInitialized(a5.pos, u5);
                                        break;
                                    default:
                                        r6.defaultedMembers.push(this.finishNode(i6, "EnumDefaultedMember"));
                                }
                        }
                        this.match(c4.braceR) || this.expect(c4.comma);
                    }
                    return r6;
                }
                flowEnumStringMembers(t, e, { enumName: s  }) {
                    if (0 === t.length) return e;
                    if (0 === e.length) return t;
                    if (e.length > t.length) {
                        for(let e23 = 0; e23 < t.length; e23++){
                            const r6 = t[e23];
                            this.flowEnumErrorStringMemberInconsistentlyInitailized(r6.start, {
                                enumName: s
                            });
                        }
                        return e;
                    }
                    for(let t20 = 0; t20 < e.length; t20++){
                        const r6 = e[t20];
                        this.flowEnumErrorStringMemberInconsistentlyInitailized(r6.start, {
                            enumName: s
                        });
                    }
                    return t;
                }
                flowEnumParseExplicitType({ enumName: t  }) {
                    if (this.eatContextual("of")) {
                        if (!this.match(c4.name)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                            enumName: t,
                            suppliedType: null
                        });
                        const { value: e23  } = this.state;
                        return this.next(), "boolean" !== e23 && "number" !== e23 && "string" !== e23 && "symbol" !== e23 && this.flowEnumErrorInvalidExplicitType(this.state.start, {
                            enumName: t,
                            suppliedType: e23
                        }), e23;
                    }
                    return null;
                }
                flowEnumBody(t, { enumName: e , nameLoc: s  }) {
                    const r6 = this.flowEnumParseExplicitType({
                        enumName: e
                    });
                    this.expect(c4.braceL);
                    const i6 = this.flowEnumMembers({
                        enumName: e,
                        explicitType: r6
                    });
                    switch(r6){
                        case "boolean":
                            return t.explicitType = !0, t.members = i6.booleanMembers, this.expect(c4.braceR), this.finishNode(t, "EnumBooleanBody");
                        case "number":
                            return t.explicitType = !0, t.members = i6.numberMembers, this.expect(c4.braceR), this.finishNode(t, "EnumNumberBody");
                        case "string":
                            return t.explicitType = !0, t.members = this.flowEnumStringMembers(i6.stringMembers, i6.defaultedMembers, {
                                enumName: e
                            }), this.expect(c4.braceR), this.finishNode(t, "EnumStringBody");
                        case "symbol":
                            return t.members = i6.defaultedMembers, this.expect(c4.braceR), this.finishNode(t, "EnumSymbolBody");
                        default:
                            {
                                const r7 = ()=>(t.members = [], this.expect(c4.braceR), this.finishNode(t, "EnumStringBody"))
                                ;
                                t.explicitType = !1;
                                const n6 = i6.booleanMembers.length, a5 = i6.numberMembers.length, o5 = i6.stringMembers.length, u5 = i6.defaultedMembers.length;
                                if (n6 || a5 || o5 || u5) {
                                    if (n6 || a5) {
                                        if (!a5 && !o5 && n6 >= u5) {
                                            for(let t20 = 0, s7 = i6.defaultedMembers; t20 < s7.length; t20++){
                                                const r8 = s7[t20];
                                                this.flowEnumErrorBooleanMemberNotInitialized(r8.start, {
                                                    enumName: e,
                                                    memberName: r8.id.name
                                                });
                                            }
                                            return t.members = i6.booleanMembers, this.expect(c4.braceR), this.finishNode(t, "EnumBooleanBody");
                                        }
                                        if (!n6 && !o5 && a5 >= u5) {
                                            for(let t20 = 0, s7 = i6.defaultedMembers; t20 < s7.length; t20++){
                                                const r8 = s7[t20];
                                                this.flowEnumErrorNumberMemberNotInitialized(r8.start, {
                                                    enumName: e,
                                                    memberName: r8.id.name
                                                });
                                            }
                                            return t.members = i6.numberMembers, this.expect(c4.braceR), this.finishNode(t, "EnumNumberBody");
                                        }
                                        return this.flowEnumErrorInconsistentMemberValues(s, {
                                            enumName: e
                                        }), r7();
                                    }
                                    return t.members = this.flowEnumStringMembers(i6.stringMembers, i6.defaultedMembers, {
                                        enumName: e
                                    }), this.expect(c4.braceR), this.finishNode(t, "EnumStringBody");
                                }
                                return r7();
                            }
                    }
                }
                flowParseEnumDeclaration(t) {
                    const e23 = this.parseIdentifier();
                    return t.id = e23, t.body = this.flowEnumBody(this.startNode(), {
                        enumName: e23.name,
                        nameLoc: e23.start
                    }), this.finishNode(t, "EnumDeclaration");
                }
                updateContext(t) {
                    this.match(c4.name) && "of" === this.state.value && t === c4.name && "interface" === this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ? this.state.exprAllowed = !1 : super.updateContext(t);
                }
                isLookaheadToken_lt() {
                    const t20 = this.nextTokenStart();
                    if (60 === this.input.charCodeAt(t20)) {
                        const e23 = this.input.charCodeAt(t20 + 1);
                        return 60 !== e23 && 61 !== e23;
                    }
                    return !1;
                }
                maybeUnwrapTypeCastExpression(t) {
                    return "TypeCastExpression" === t.type ? t.expression : t;
                }
            }
        ,
        typescript: (t18)=>class extends t18 {
                getScopeHandler() {
                    return ut3;
                }
                tsIsIdentifier() {
                    return this.match(c4.name);
                }
                tsNextTokenCanFollowModifier() {
                    return this.next(), !(this.hasPrecedingLineBreak() || this.match(c4.parenL) || this.match(c4.parenR) || this.match(c4.colon) || this.match(c4.eq) || this.match(c4.question) || this.match(c4.bang));
                }
                tsParseModifier(t) {
                    if (!this.match(c4.name)) return;
                    const e20 = this.state.value;
                    return -1 !== t.indexOf(e20) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e20 : void 0;
                }
                tsParseModifiers(t, e) {
                    for(;;){
                        const s7 = this.state.start, r6 = this.tsParseModifier(e);
                        if (!r6) break;
                        Object.hasOwnProperty.call(t, r6) && this.raise(s7, dt3.DuplicateModifier, r6), t[r6] = !0;
                    }
                }
                tsIsListTerminator(t) {
                    switch(t){
                        case "EnumMembers":
                        case "TypeMembers":
                            return this.match(c4.braceR);
                        case "HeritageClauseElement":
                            return this.match(c4.braceL);
                        case "TupleElementTypes":
                            return this.match(c4.bracketR);
                        case "TypeParametersOrArguments":
                            return this.isRelational(">");
                    }
                    throw new Error("Unreachable");
                }
                tsParseList(t, e) {
                    const s7 = [];
                    for(; !this.tsIsListTerminator(t);)s7.push(e());
                    return s7;
                }
                tsParseDelimitedList(t, e) {
                    return pt3(this.tsParseDelimitedListWorker(t, e, !0));
                }
                tsParseDelimitedListWorker(t, e, s) {
                    const r6 = [];
                    for(; !this.tsIsListTerminator(t);){
                        const i6 = e();
                        if (null == i6) return;
                        if (r6.push(i6), !this.eat(c4.comma)) {
                            if (this.tsIsListTerminator(t)) break;
                            return void (s && this.expect(c4.comma));
                        }
                    }
                    return r6;
                }
                tsParseBracketedList(t, e, s, r) {
                    r || (s ? this.expect(c4.bracketL) : this.expectRelational("<"));
                    const i6 = this.tsParseDelimitedList(t, e);
                    return s ? this.expect(c4.bracketR) : this.expectRelational(">"), i6;
                }
                tsParseImportType() {
                    const t19 = this.startNode();
                    return this.expect(c4._import), this.expect(c4.parenL), this.match(c4.string) || this.raise(this.state.start, dt3.UnsupportedImportTypeArgument), t19.argument = this.parseExprAtom(), this.expect(c4.parenR), this.eat(c4.dot) && (t19.qualifier = this.tsParseEntityName(!0)), this.isRelational("<") && (t19.typeParameters = this.tsParseTypeArguments()), this.finishNode(t19, "TSImportType");
                }
                tsParseEntityName(t) {
                    let e20 = this.parseIdentifier();
                    for(; this.eat(c4.dot);){
                        const s7 = this.startNodeAtNode(e20);
                        s7.left = e20, s7.right = this.parseIdentifier(t), e20 = this.finishNode(s7, "TSQualifiedName");
                    }
                    return e20;
                }
                tsParseTypeReference() {
                    const t19 = this.startNode();
                    return t19.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational("<") && (t19.typeParameters = this.tsParseTypeArguments()), this.finishNode(t19, "TSTypeReference");
                }
                tsParseThisTypePredicate(t) {
                    this.next();
                    const e20 = this.startNodeAtNode(t);
                    return e20.parameterName = t, e20.typeAnnotation = this.tsParseTypeAnnotation(!1), this.finishNode(e20, "TSTypePredicate");
                }
                tsParseThisTypeNode() {
                    const t19 = this.startNode();
                    return this.next(), this.finishNode(t19, "TSThisType");
                }
                tsParseTypeQuery() {
                    const t19 = this.startNode();
                    return this.expect(c4._typeof), this.match(c4._import) ? t19.exprName = this.tsParseImportType() : t19.exprName = this.tsParseEntityName(!0), this.finishNode(t19, "TSTypeQuery");
                }
                tsParseTypeParameter() {
                    const t19 = this.startNode();
                    return t19.name = this.parseIdentifierName(t19.start), t19.constraint = this.tsEatThenParseType(c4._extends), t19.default = this.tsEatThenParseType(c4.eq), this.finishNode(t19, "TSTypeParameter");
                }
                tsTryParseTypeParameters() {
                    if (this.isRelational("<")) return this.tsParseTypeParameters();
                }
                tsParseTypeParameters() {
                    const t19 = this.startNode();
                    return this.isRelational("<") || this.match(c4.jsxTagStart) ? this.next() : this.unexpected(), t19.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0), 0 === t19.params.length && this.raise(t19.start, dt3.EmptyTypeParameters), this.finishNode(t19, "TSTypeParameterDeclaration");
                }
                tsTryNextParseConstantContext() {
                    return this.lookahead().type === c4._const ? (this.next(), this.tsParseTypeReference()) : null;
                }
                tsFillSignature(t, e) {
                    const s7 = t === c4.arrow;
                    e.typeParameters = this.tsTryParseTypeParameters(), this.expect(c4.parenL), e.parameters = this.tsParseBindingListForSignature(), (s7 || this.match(t)) && (e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t));
                }
                tsParseBindingListForSignature() {
                    return this.parseBindingList(c4.parenR, 41).map((t19)=>("Identifier" !== t19.type && "RestElement" !== t19.type && "ObjectPattern" !== t19.type && "ArrayPattern" !== t19.type && this.raise(t19.start, dt3.UnsupportedSignatureParameterKind, t19.type), t19)
                    );
                }
                tsParseTypeMemberSemicolon() {
                    this.eat(c4.comma) || this.semicolon();
                }
                tsParseSignatureMember(t, e) {
                    return this.tsFillSignature(c4.colon, e), this.tsParseTypeMemberSemicolon(), this.finishNode(e, t);
                }
                tsIsUnambiguouslyIndexSignature() {
                    return this.next(), this.eat(c4.name) && this.match(c4.colon);
                }
                tsTryParseIndexSignature(t) {
                    if (!this.match(c4.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
                    this.expect(c4.bracketL);
                    const e20 = this.parseIdentifier();
                    e20.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e20), this.expect(c4.bracketR), t.parameters = [
                        e20
                    ];
                    const s7 = this.tsTryParseTypeAnnotation();
                    return s7 && (t.typeAnnotation = s7), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSIndexSignature");
                }
                tsParsePropertyOrMethodSignature(t, e) {
                    this.eat(c4.question) && (t.optional = !0);
                    const s7 = t;
                    if (e || !this.match(c4.parenL) && !this.isRelational("<")) {
                        const t19 = t;
                        e && (t.readonly = !0);
                        const r6 = this.tsTryParseTypeAnnotation();
                        return r6 && (t.typeAnnotation = r6), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSPropertySignature");
                    }
                    {
                        const t19 = t;
                        return this.tsFillSignature(c4.colon, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSMethodSignature");
                    }
                }
                tsParseTypeMember() {
                    const t19 = this.startNode();
                    if (this.match(c4.parenL) || this.isRelational("<")) return this.tsParseSignatureMember("TSCallSignatureDeclaration", t19);
                    if (this.match(c4._new)) {
                        const e20 = this.startNode();
                        return this.next(), this.match(c4.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t19) : (t19.key = this.createIdentifier(e20, "new"), this.tsParsePropertyOrMethodSignature(t19, !1));
                    }
                    const e20 = !!this.tsParseModifier([
                        "readonly"
                    ]), s7 = this.tsTryParseIndexSignature(t19);
                    return s7 ? (e20 && (t19.readonly = !0), s7) : (this.parsePropertyName(t19, !1), this.tsParsePropertyOrMethodSignature(t19, e20));
                }
                tsParseTypeLiteral() {
                    const t19 = this.startNode();
                    return t19.members = this.tsParseObjectTypeMembers(), this.finishNode(t19, "TSTypeLiteral");
                }
                tsParseObjectTypeMembers() {
                    this.expect(c4.braceL);
                    const t19 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                    return this.expect(c4.braceR), t19;
                }
                tsIsStartOfMappedType() {
                    return this.next(), this.eat(c4.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(c4.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(c4._in))));
                }
                tsParseMappedTypeParameter() {
                    const t19 = this.startNode();
                    return t19.name = this.parseIdentifierName(t19.start), t19.constraint = this.tsExpectThenParseType(c4._in), this.finishNode(t19, "TSTypeParameter");
                }
                tsParseMappedType() {
                    const t19 = this.startNode();
                    return this.expect(c4.braceL), this.match(c4.plusMin) ? (t19.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t19.readonly = !0), this.expect(c4.bracketL), t19.typeParameter = this.tsParseMappedTypeParameter(), t19.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(c4.bracketR), this.match(c4.plusMin) ? (t19.optional = this.state.value, this.next(), this.expect(c4.question)) : this.eat(c4.question) && (t19.optional = !0), t19.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(c4.braceR), this.finishNode(t19, "TSMappedType");
                }
                tsParseTupleType() {
                    const t19 = this.startNode();
                    t19.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
                    let e20 = !1, s7 = null;
                    return t19.elementTypes.forEach((t20)=>{
                        var r6;
                        let { type: i6  } = t20;
                        !e20 || "TSRestType" === i6 || "TSOptionalType" === i6 || "TSNamedTupleMember" === i6 && t20.optional || this.raise(t20.start, dt3.OptionalTypeBeforeRequired), e20 = e20 || "TSNamedTupleMember" === i6 && t20.optional || "TSOptionalType" === i6, "TSRestType" === i6 && (i6 = (t20 = t20.typeAnnotation).type);
                        const n6 = "TSNamedTupleMember" === i6;
                        s7 = null != (r6 = s7) ? r6 : n6, s7 !== n6 && this.raise(t20.start, dt3.MixedLabeledAndUnlabeledElements);
                    }), this.finishNode(t19, "TSTupleType");
                }
                tsParseTupleElementType() {
                    const { start: t19 , startLoc: e20  } = this.state, s7 = this.eat(c4.ellipsis);
                    let r6 = this.tsParseType();
                    const i6 = this.eat(c4.question);
                    if (this.eat(c4.colon)) {
                        const t20 = this.startNodeAtNode(r6);
                        t20.optional = i6, "TSTypeReference" !== r6.type || r6.typeParameters || "Identifier" !== r6.typeName.type ? (this.raise(r6.start, dt3.InvalidTupleMemberLabel), t20.label = r6) : t20.label = r6.typeName, t20.elementType = this.tsParseType(), r6 = this.finishNode(t20, "TSNamedTupleMember");
                    } else if (i6) {
                        const t20 = this.startNodeAtNode(r6);
                        t20.typeAnnotation = r6, r6 = this.finishNode(t20, "TSOptionalType");
                    }
                    if (s7) {
                        const s8 = this.startNodeAt(t19, e20);
                        s8.typeAnnotation = r6, r6 = this.finishNode(s8, "TSRestType");
                    }
                    return r6;
                }
                tsParseParenthesizedType() {
                    const t19 = this.startNode();
                    return this.expect(c4.parenL), t19.typeAnnotation = this.tsParseType(), this.expect(c4.parenR), this.finishNode(t19, "TSParenthesizedType");
                }
                tsParseFunctionOrConstructorType(t) {
                    const e20 = this.startNode();
                    return "TSConstructorType" === t && this.expect(c4._new), this.tsFillSignature(c4.arrow, e20), this.finishNode(e20, t);
                }
                tsParseLiteralTypeNode() {
                    const t19 = this.startNode();
                    return t19.literal = (()=>{
                        switch(this.state.type){
                            case c4.num:
                            case c4.bigint:
                            case c4.string:
                            case c4._true:
                            case c4._false:
                                return this.parseExprAtom();
                            default:
                                throw this.unexpected();
                        }
                    })(), this.finishNode(t19, "TSLiteralType");
                }
                tsParseTemplateLiteralType() {
                    const t19 = this.startNode();
                    return t19.literal = this.parseTemplate(!1), this.finishNode(t19, "TSLiteralType");
                }
                parseTemplateSubstitution() {
                    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
                }
                tsParseThisTypeOrThisTypePredicate() {
                    const t19 = this.tsParseThisTypeNode();
                    return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t19) : t19;
                }
                tsParseNonArrayType() {
                    switch(this.state.type){
                        case c4.name:
                        case c4._void:
                        case c4._null:
                            {
                                const t19 = this.match(c4._void) ? "TSVoidKeyword" : this.match(c4._null) ? "TSNullKeyword" : function(t20) {
                                    switch(t20){
                                        case "any":
                                            return "TSAnyKeyword";
                                        case "boolean":
                                            return "TSBooleanKeyword";
                                        case "bigint":
                                            return "TSBigIntKeyword";
                                        case "never":
                                            return "TSNeverKeyword";
                                        case "number":
                                            return "TSNumberKeyword";
                                        case "object":
                                            return "TSObjectKeyword";
                                        case "string":
                                            return "TSStringKeyword";
                                        case "symbol":
                                            return "TSSymbolKeyword";
                                        case "undefined":
                                            return "TSUndefinedKeyword";
                                        case "unknown":
                                            return "TSUnknownKeyword";
                                        default:
                                            return;
                                    }
                                }(this.state.value);
                                if ((void 0) !== t19 && 46 !== this.lookaheadCharCode()) {
                                    const e20 = this.startNode();
                                    return this.next(), this.finishNode(e20, t19);
                                }
                                return this.tsParseTypeReference();
                            }
                        case c4.string:
                        case c4.num:
                        case c4.bigint:
                        case c4._true:
                        case c4._false:
                            return this.tsParseLiteralTypeNode();
                        case c4.plusMin:
                            if ("-" === this.state.value) {
                                const t19 = this.startNode(), e20 = this.lookahead();
                                if (e20.type !== c4.num && e20.type !== c4.bigint) throw this.unexpected();
                                return t19.literal = this.parseMaybeUnary(), this.finishNode(t19, "TSLiteralType");
                            }
                            break;
                        case c4._this:
                            return this.tsParseThisTypeOrThisTypePredicate();
                        case c4._typeof:
                            return this.tsParseTypeQuery();
                        case c4._import:
                            return this.tsParseImportType();
                        case c4.braceL:
                            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                        case c4.bracketL:
                            return this.tsParseTupleType();
                        case c4.parenL:
                            return this.tsParseParenthesizedType();
                        case c4.backQuote:
                            return this.tsParseTemplateLiteralType();
                    }
                    throw this.unexpected();
                }
                tsParseArrayTypeOrHigher() {
                    let t19 = this.tsParseNonArrayType();
                    for(; !this.hasPrecedingLineBreak() && this.eat(c4.bracketL);)if (this.match(c4.bracketR)) {
                        const e20 = this.startNodeAtNode(t19);
                        e20.elementType = t19, this.expect(c4.bracketR), t19 = this.finishNode(e20, "TSArrayType");
                    } else {
                        const e20 = this.startNodeAtNode(t19);
                        e20.objectType = t19, e20.indexType = this.tsParseType(), this.expect(c4.bracketR), t19 = this.finishNode(e20, "TSIndexedAccessType");
                    }
                    return t19;
                }
                tsParseTypeOperator(t) {
                    const e20 = this.startNode();
                    return this.expectContextual(t), e20.operator = t, e20.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e20), this.finishNode(e20, "TSTypeOperator");
                }
                tsCheckTypeAnnotationForReadOnly(t) {
                    switch(t.typeAnnotation.type){
                        case "TSTupleType":
                        case "TSArrayType":
                            return;
                        default:
                            this.raise(t.start, dt3.UnexpectedReadonly);
                    }
                }
                tsParseInferType() {
                    const t19 = this.startNode();
                    this.expectContextual("infer");
                    const e20 = this.startNode();
                    return e20.name = this.parseIdentifierName(e20.start), t19.typeParameter = this.finishNode(e20, "TSTypeParameter"), this.finishNode(t19, "TSInferType");
                }
                tsParseTypeOperatorOrHigher() {
                    const t19 = [
                        "keyof",
                        "unique",
                        "readonly"
                    ].find((t20)=>this.isContextual(t20)
                    );
                    return t19 ? this.tsParseTypeOperator(t19) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
                }
                tsParseUnionOrIntersectionType(t, e, s) {
                    this.eat(s);
                    let r6 = e();
                    if (this.match(s)) {
                        const i6 = [
                            r6
                        ];
                        for(; this.eat(s);)i6.push(e());
                        const n6 = this.startNodeAtNode(r6);
                        n6.types = i6, r6 = this.finishNode(n6, t);
                    }
                    return r6;
                }
                tsParseIntersectionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), c4.bitwiseAND);
                }
                tsParseUnionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), c4.bitwiseOR);
                }
                tsIsStartOfFunctionType() {
                    return !!this.isRelational("<") || this.match(c4.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                }
                tsSkipParameterStart() {
                    if (this.match(c4.name) || this.match(c4._this)) return this.next(), !0;
                    if (this.match(c4.braceL)) {
                        let t19 = 1;
                        for(this.next(); t19 > 0;)this.match(c4.braceL) ? ++t19 : this.match(c4.braceR) && --t19, this.next();
                        return !0;
                    }
                    if (this.match(c4.bracketL)) {
                        let t19 = 1;
                        for(this.next(); t19 > 0;)this.match(c4.bracketL) ? ++t19 : this.match(c4.bracketR) && --t19, this.next();
                        return !0;
                    }
                    return !1;
                }
                tsIsUnambiguouslyStartOfFunctionType() {
                    if (this.next(), this.match(c4.parenR) || this.match(c4.ellipsis)) return !0;
                    if (this.tsSkipParameterStart()) {
                        if (this.match(c4.colon) || this.match(c4.comma) || this.match(c4.question) || this.match(c4.eq)) return !0;
                        if (this.match(c4.parenR) && (this.next(), this.match(c4.arrow))) return !0;
                    }
                    return !1;
                }
                tsParseTypeOrTypePredicateAnnotation(t) {
                    return this.tsInType(()=>{
                        const e20 = this.startNode();
                        this.expect(t);
                        const s7 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                        if (s7 && this.match(c4._this)) {
                            let t19 = this.tsParseThisTypeOrThisTypePredicate();
                            if ("TSThisType" === t19.type) {
                                const s8 = this.startNodeAtNode(e20);
                                s8.parameterName = t19, s8.asserts = !0, t19 = this.finishNode(s8, "TSTypePredicate");
                            } else t19.asserts = !0;
                            return e20.typeAnnotation = t19, this.finishNode(e20, "TSTypeAnnotation");
                        }
                        const r6 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                        if (!r6) {
                            if (!s7) return this.tsParseTypeAnnotation(!1, e20);
                            const t19 = this.startNodeAtNode(e20);
                            return t19.parameterName = this.parseIdentifier(), t19.asserts = s7, e20.typeAnnotation = this.finishNode(t19, "TSTypePredicate"), this.finishNode(e20, "TSTypeAnnotation");
                        }
                        const i6 = this.tsParseTypeAnnotation(!1), n6 = this.startNodeAtNode(e20);
                        return n6.parameterName = r6, n6.typeAnnotation = i6, n6.asserts = s7, e20.typeAnnotation = this.finishNode(n6, "TSTypePredicate"), this.finishNode(e20, "TSTypeAnnotation");
                    });
                }
                tsTryParseTypeOrTypePredicateAnnotation() {
                    return this.match(c4.colon) ? this.tsParseTypeOrTypePredicateAnnotation(c4.colon) : void 0;
                }
                tsTryParseTypeAnnotation() {
                    return this.match(c4.colon) ? this.tsParseTypeAnnotation() : void 0;
                }
                tsTryParseType() {
                    return this.tsEatThenParseType(c4.colon);
                }
                tsParseTypePredicatePrefix() {
                    const t19 = this.parseIdentifier();
                    if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), t19;
                }
                tsParseTypePredicateAsserts() {
                    if (!this.match(c4.name) || "asserts" !== this.state.value || this.hasPrecedingLineBreak()) return !1;
                    const t19 = this.state.containsEsc;
                    return this.next(), !(!this.match(c4.name) && !this.match(c4._this)) && (t19 && this.raise(this.state.lastTokStart, g4.InvalidEscapedReservedWord, "asserts"), !0);
                }
                tsParseTypeAnnotation(t = !0, e = this.startNode()) {
                    return this.tsInType(()=>{
                        t && this.expect(c4.colon), e.typeAnnotation = this.tsParseType();
                    }), this.finishNode(e, "TSTypeAnnotation");
                }
                tsParseType() {
                    lt3(this.state.inType);
                    const t19 = this.tsParseNonConditionalType();
                    if (this.hasPrecedingLineBreak() || !this.eat(c4._extends)) return t19;
                    const e20 = this.startNodeAtNode(t19);
                    return e20.checkType = t19, e20.extendsType = this.tsParseNonConditionalType(), this.expect(c4.question), e20.trueType = this.tsParseType(), this.expect(c4.colon), e20.falseType = this.tsParseType(), this.finishNode(e20, "TSConditionalType");
                }
                tsParseNonConditionalType() {
                    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(c4._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.tsParseUnionTypeOrHigher();
                }
                tsParseTypeAssertion() {
                    const t19 = this.startNode(), e20 = this.tsTryNextParseConstantContext();
                    return t19.typeAnnotation = e20 || this.tsNextThenParseType(), this.expectRelational(">"), t19.expression = this.parseMaybeUnary(), this.finishNode(t19, "TSTypeAssertion");
                }
                tsParseHeritageClause(t) {
                    const e20 = this.state.start, s7 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
                    return s7.length || this.raise(e20, dt3.EmptyHeritageClauseType, t), s7;
                }
                tsParseExpressionWithTypeArguments() {
                    const t19 = this.startNode();
                    return t19.expression = this.tsParseEntityName(!1), this.isRelational("<") && (t19.typeParameters = this.tsParseTypeArguments()), this.finishNode(t19, "TSExpressionWithTypeArguments");
                }
                tsParseInterfaceDeclaration(t) {
                    t.id = this.parseIdentifier(), this.checkLVal(t.id, 130, void 0, "typescript interface declaration"), t.typeParameters = this.tsTryParseTypeParameters(), this.eat(c4._extends) && (t.extends = this.tsParseHeritageClause("extends"));
                    const e20 = this.startNode();
                    return e20.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(e20, "TSInterfaceBody"), this.finishNode(t, "TSInterfaceDeclaration");
                }
                tsParseTypeAliasDeclaration(t) {
                    return t.id = this.parseIdentifier(), this.checkLVal(t.id, 2, void 0, "typescript type alias"), t.typeParameters = this.tsTryParseTypeParameters(), t.typeAnnotation = this.tsInType(()=>{
                        if (this.expect(c4.eq), this.isContextual("intrinsic") && this.lookahead().type !== c4.dot) {
                            const t19 = this.startNode();
                            return this.next(), this.finishNode(t19, "TSIntrinsicKeyword");
                        }
                        return this.tsParseType();
                    }), this.semicolon(), this.finishNode(t, "TSTypeAliasDeclaration");
                }
                tsInNoContext(t) {
                    const e20 = this.state.context;
                    this.state.context = [
                        e20[0]
                    ];
                    try {
                        return t();
                    } finally{
                        this.state.context = e20;
                    }
                }
                tsInType(t) {
                    const e20 = this.state.inType;
                    this.state.inType = !0;
                    try {
                        return t();
                    } finally{
                        this.state.inType = e20;
                    }
                }
                tsEatThenParseType(t) {
                    return this.match(t) ? this.tsNextThenParseType() : void 0;
                }
                tsExpectThenParseType(t) {
                    return this.tsDoThenParseType(()=>this.expect(t)
                    );
                }
                tsNextThenParseType() {
                    return this.tsDoThenParseType(()=>this.next()
                    );
                }
                tsDoThenParseType(t) {
                    return this.tsInType(()=>(t(), this.tsParseType())
                    );
                }
                tsParseEnumMember() {
                    const t19 = this.startNode();
                    return t19.id = this.match(c4.string) ? this.parseExprAtom() : this.parseIdentifier(!0), this.eat(c4.eq) && (t19.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(t19, "TSEnumMember");
                }
                tsParseEnumDeclaration(t, e) {
                    return e && (t.const = !0), t.id = this.parseIdentifier(), this.checkLVal(t.id, e ? 779 : 267, void 0, "typescript enum declaration"), this.expect(c4.braceL), t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(c4.braceR), this.finishNode(t, "TSEnumDeclaration");
                }
                tsParseModuleBlock() {
                    const t19 = this.startNode();
                    return this.scope.enter(0), this.expect(c4.braceL), this.parseBlockOrModuleBlockBody(t19.body = [], void 0, !0, c4.braceR), this.scope.exit(), this.finishNode(t19, "TSModuleBlock");
                }
                tsParseModuleOrNamespaceDeclaration(t, e = !1) {
                    if (t.id = this.parseIdentifier(), e || this.checkLVal(t.id, 1024, null, "module or namespace declaration"), this.eat(c4.dot)) {
                        const e20 = this.startNode();
                        this.tsParseModuleOrNamespaceDeclaration(e20, !0), t.body = e20;
                    } else this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
                    return this.finishNode(t, "TSModuleDeclaration");
                }
                tsParseAmbientExternalModuleDeclaration(t) {
                    return this.isContextual("global") ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(c4.string) ? t.id = this.parseExprAtom() : this.unexpected(), this.match(c4.braceL) ? (this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, "TSModuleDeclaration");
                }
                tsParseImportEqualsDeclaration(t, e) {
                    return t.isExport = e || !1, t.id = this.parseIdentifier(), this.checkLVal(t.id, 9, void 0, "import equals declaration"), this.expect(c4.eq), t.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t, "TSImportEqualsDeclaration");
                }
                tsIsExternalModuleReference() {
                    return this.isContextual("require") && 40 === this.lookaheadCharCode();
                }
                tsParseModuleReference() {
                    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
                }
                tsParseExternalModuleReference() {
                    const t19 = this.startNode();
                    if (this.expectContextual("require"), this.expect(c4.parenL), !this.match(c4.string)) throw this.unexpected();
                    return t19.expression = this.parseExprAtom(), this.expect(c4.parenR), this.finishNode(t19, "TSExternalModuleReference");
                }
                tsLookAhead(t) {
                    const e20 = this.state.clone(), s7 = t();
                    return this.state = e20, s7;
                }
                tsTryParseAndCatch(t) {
                    const e20 = this.tryParse((e23)=>t() || e23()
                    );
                    if (!e20.aborted && e20.node) return e20.error && (this.state = e20.failState), e20.node;
                }
                tsTryParse(t) {
                    const e20 = this.state.clone(), s7 = t();
                    return (void 0) !== s7 && !1 !== s7 ? s7 : void (this.state = e20);
                }
                tsTryParseDeclare(t) {
                    if (this.isLineTerminator()) return;
                    let e20, s7 = this.state.type;
                    return this.isContextual("let") && (s7 = c4._var, e20 = "let"), this.tsInDeclareContext(()=>{
                        switch(s7){
                            case c4._function:
                                return t.declare = !0, this.parseFunctionStatement(t, !1, !0);
                            case c4._class:
                                return t.declare = !0, this.parseClass(t, !0, !1);
                            case c4._const:
                                if (this.match(c4._const) && this.isLookaheadContextual("enum")) return this.expect(c4._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t, !0);
                            case c4._var:
                                return e20 = e20 || this.state.value, this.parseVarStatement(t, e20);
                            case c4.name:
                                {
                                    const e23 = this.state.value;
                                    return "global" === e23 ? this.tsParseAmbientExternalModuleDeclaration(t) : this.tsParseDeclaration(t, e23, !0);
                                }
                        }
                    });
                }
                tsTryParseExportDeclaration() {
                    return this.tsParseDeclaration(this.startNode(), this.state.value, !0);
                }
                tsParseExpressionStatement(t, e) {
                    switch(e.name){
                        case "declare":
                            {
                                const e20 = this.tsTryParseDeclare(t);
                                if (e20) return e20.declare = !0, e20;
                                break;
                            }
                        case "global":
                            if (this.match(c4.braceL)) {
                                this.scope.enter(128), this.prodParam.enter(0);
                                const s7 = t;
                                return t.global = !0, t.id = e, t.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(t, "TSModuleDeclaration");
                            }
                            break;
                        default:
                            return this.tsParseDeclaration(t, e.name, !1);
                    }
                }
                tsParseDeclaration(t, e, s) {
                    switch(e){
                        case "abstract":
                            if (this.tsCheckLineTerminatorAndMatch(c4._class, s)) {
                                const e20 = t;
                                return t.abstract = !0, s && (this.next(), this.match(c4._class) || this.unexpected(null, c4._class)), this.parseClass(t, !0, !1);
                            }
                            break;
                        case "enum":
                            if (s || this.match(c4.name)) return s && this.next(), this.tsParseEnumDeclaration(t, !1);
                            break;
                        case "interface":
                            if (this.tsCheckLineTerminatorAndMatch(c4.name, s)) return s && this.next(), this.tsParseInterfaceDeclaration(t);
                            break;
                        case "module":
                            if (s && this.next(), this.match(c4.string)) return this.tsParseAmbientExternalModuleDeclaration(t);
                            if (this.tsCheckLineTerminatorAndMatch(c4.name, s)) return this.tsParseModuleOrNamespaceDeclaration(t);
                            break;
                        case "namespace":
                            if (this.tsCheckLineTerminatorAndMatch(c4.name, s)) return s && this.next(), this.tsParseModuleOrNamespaceDeclaration(t);
                            break;
                        case "type":
                            if (this.tsCheckLineTerminatorAndMatch(c4.name, s)) return s && this.next(), this.tsParseTypeAliasDeclaration(t);
                    }
                }
                tsCheckLineTerminatorAndMatch(t, e) {
                    return (e || this.match(t)) && !this.isLineTerminator();
                }
                tsTryParseGenericAsyncArrowFunction(t, e) {
                    if (!this.isRelational("<")) return;
                    const s7 = this.state.maybeInArrowParameters;
                    this.state.maybeInArrowParameters = !0;
                    const r6 = this.tsTryParseAndCatch(()=>{
                        const s8 = this.startNodeAt(t, e);
                        return s8.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s8), s8.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(c4.arrow), s8;
                    });
                    return this.state.maybeInArrowParameters = s7, r6 ? this.parseArrowExpression(r6, null, !0) : void 0;
                }
                tsParseTypeArguments() {
                    const t19 = this.startNode();
                    return t19.params = this.tsInType(()=>this.tsInNoContext(()=>(this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this)))
                        )
                    ), 0 === t19.params.length && this.raise(t19.start, dt3.EmptyTypeArguments), this.state.exprAllowed = !1, this.expectRelational(">"), this.finishNode(t19, "TSTypeParameterInstantiation");
                }
                tsIsDeclarationStart() {
                    if (this.match(c4.name)) switch(this.state.value){
                        case "abstract":
                        case "declare":
                        case "enum":
                        case "interface":
                        case "module":
                        case "namespace":
                        case "type":
                            return !0;
                    }
                    return !1;
                }
                isExportDefaultSpecifier() {
                    return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
                }
                parseAssignableListItem(t, e) {
                    const s7 = this.state.start, r6 = this.state.startLoc;
                    let i6, n6 = !1;
                    (void 0) !== t && (i6 = this.parseAccessModifier(), n6 = !!this.tsParseModifier([
                        "readonly"
                    ]), !1 === t && (i6 || n6) && this.raise(s7, dt3.UnexpectedParameterModifier));
                    const a5 = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(a5);
                    const o5 = this.parseMaybeDefault(a5.start, a5.loc.start, a5);
                    if (i6 || n6) {
                        const t19 = this.startNodeAt(s7, r6);
                        return e.length && (t19.decorators = e), i6 && (t19.accessibility = i6), n6 && (t19.readonly = n6), "Identifier" !== o5.type && "AssignmentPattern" !== o5.type && this.raise(t19.start, dt3.UnsupportedParameterPropertyKind), t19.parameter = o5, this.finishNode(t19, "TSParameterProperty");
                    }
                    return e.length && (a5.decorators = e), o5;
                }
                parseFunctionBodyAndFinish(t, e, s = !1) {
                    this.match(c4.colon) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(c4.colon));
                    const r6 = "FunctionDeclaration" === e ? "TSDeclareFunction" : "ClassMethod" === e ? "TSDeclareMethod" : void 0;
                    r6 && !this.match(c4.braceL) && this.isLineTerminator() ? this.finishNode(t, r6) : "TSDeclareFunction" === r6 && this.state.isDeclareContext && (this.raise(t.start, dt3.DeclareFunctionHasImplementation), t.declare) ? super.parseFunctionBodyAndFinish(t, r6, s) : super.parseFunctionBodyAndFinish(t, e, s);
                }
                registerFunctionStatementId(t) {
                    !t.body && t.id ? this.checkLVal(t.id, 1024, null, "function name") : super.registerFunctionStatementId(...arguments);
                }
                tsCheckForInvalidTypeCasts(t) {
                    t.forEach((t19)=>{
                        "TSTypeCastExpression" === (null == t19 ? void 0 : t19.type) && this.raise(t19.typeAnnotation.start, dt3.UnexpectedTypeAnnotation);
                    });
                }
                toReferencedList(t, e) {
                    return this.tsCheckForInvalidTypeCasts(t), t;
                }
                parseArrayLike(...t) {
                    const e20 = super.parseArrayLike(...t);
                    return "ArrayExpression" === e20.type && this.tsCheckForInvalidTypeCasts(e20.elements), e20;
                }
                parseSubscript(t, e, s, r, i) {
                    if (!this.hasPrecedingLineBreak() && this.match(c4.bang)) {
                        this.state.exprAllowed = !1, this.next();
                        const r6 = this.startNodeAt(e, s);
                        return r6.expression = t, this.finishNode(r6, "TSNonNullExpression");
                    }
                    if (this.isRelational("<")) {
                        const n6 = this.tsTryParseAndCatch(()=>{
                            if (!r && this.atPossibleAsyncArrow(t)) {
                                const t19 = this.tsTryParseGenericAsyncArrowFunction(e, s);
                                if (t19) return t19;
                            }
                            const n7 = this.startNodeAt(e, s);
                            n7.callee = t;
                            const a5 = this.tsParseTypeArguments();
                            if (a5) {
                                if (!r && this.eat(c4.parenL)) return n7.arguments = this.parseCallExpressionArguments(c4.parenR, !1), this.tsCheckForInvalidTypeCasts(n7.arguments), n7.typeParameters = a5, this.finishCallExpression(n7, i.optionalChainMember);
                                if (this.match(c4.backQuote)) {
                                    const r6 = this.parseTaggedTemplateExpression(t, e, s, i);
                                    return r6.typeParameters = a5, r6;
                                }
                            }
                            this.unexpected();
                        });
                        if (n6) return n6;
                    }
                    return super.parseSubscript(t, e, s, r, i);
                }
                parseNewArguments(t) {
                    if (this.isRelational("<")) {
                        const e20 = this.tsTryParseAndCatch(()=>{
                            const t19 = this.tsParseTypeArguments();
                            return this.match(c4.parenL) || this.unexpected(), t19;
                        });
                        e20 && (t.typeParameters = e20);
                    }
                    super.parseNewArguments(t);
                }
                parseExprOp(t, e, s, r) {
                    if (pt3(c4._in.binop) > r && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
                        const i6 = this.startNodeAt(e, s);
                        i6.expression = t;
                        const n6 = this.tsTryNextParseConstantContext();
                        return i6.typeAnnotation = n6 || this.tsNextThenParseType(), this.finishNode(i6, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i6, e, s, r);
                    }
                    return super.parseExprOp(t, e, s, r);
                }
                checkReservedWord(t, e, s, r) {
                }
                checkDuplicateExports() {
                }
                parseImport(t) {
                    if (this.match(c4.name) || this.match(c4.star) || this.match(c4.braceL)) {
                        const e20 = this.lookahead();
                        if (this.match(c4.name) && e20.type === c4.eq) return this.tsParseImportEqualsDeclaration(t);
                        !this.isContextual("type") || e20.type === c4.comma || e20.type === c4.name && "from" === e20.value || (t.importKind = "type", this.next());
                    }
                    t.importKind || (t.importKind = "value");
                    const e20 = super.parseImport(t);
                    return "type" === e20.importKind && e20.specifiers.length > 1 && "ImportDefaultSpecifier" === e20.specifiers[0].type && this.raise(e20.start, "A type-only import can specify a default import or named bindings, but not both."), e20;
                }
                parseExport(t) {
                    if (this.match(c4._import)) return this.expect(c4._import), this.tsParseImportEqualsDeclaration(t, !0);
                    if (this.eat(c4.eq)) {
                        const e20 = t;
                        return t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "TSExportAssignment");
                    }
                    if (this.eatContextual("as")) {
                        const e20 = t;
                        return this.expectContextual("namespace"), t.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t, "TSNamespaceExportDeclaration");
                    }
                    return this.isContextual("type") && this.lookahead().type === c4.braceL ? (this.next(), t.exportKind = "type") : t.exportKind = "value", super.parseExport(t);
                }
                isAbstractClass() {
                    return this.isContextual("abstract") && this.lookahead().type === c4._class;
                }
                parseExportDefaultExpression() {
                    if (this.isAbstractClass()) {
                        const t19 = this.startNode();
                        return this.next(), this.parseClass(t19, !0, !0), t19.abstract = !0, t19;
                    }
                    if ("interface" === this.state.value) {
                        const t19 = this.tsParseDeclaration(this.startNode(), this.state.value, !0);
                        if (t19) return t19;
                    }
                    return super.parseExportDefaultExpression();
                }
                parseStatementContent(t, e) {
                    if (this.state.type === c4._const) {
                        const t19 = this.lookahead();
                        if (t19.type === c4.name && "enum" === t19.value) {
                            const t20 = this.startNode();
                            return this.expect(c4._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t20, !0);
                        }
                    }
                    return super.parseStatementContent(t, e);
                }
                parseAccessModifier() {
                    return this.tsParseModifier([
                        "public",
                        "protected",
                        "private"
                    ]);
                }
                parseClassMember(t, e, s) {
                    this.tsParseModifiers(e, [
                        "declare"
                    ]);
                    const r6 = this.parseAccessModifier();
                    r6 && (e.accessibility = r6), this.tsParseModifiers(e, [
                        "declare"
                    ]);
                    const i6 = ()=>{
                        super.parseClassMember(t, e, s);
                    };
                    e.declare ? this.tsInDeclareContext(i6) : i6();
                }
                parseClassMemberWithIsStatic(t, e, s, r) {
                    this.tsParseModifiers(e, [
                        "abstract",
                        "readonly",
                        "declare"
                    ]);
                    const i6 = this.tsTryParseIndexSignature(e);
                    if (i6) return t.body.push(i6), e.abstract && this.raise(e.start, dt3.IndexSignatureHasAbstract), r && this.raise(e.start, dt3.IndexSignatureHasStatic), e.accessibility && this.raise(e.start, dt3.IndexSignatureHasAccessibility, e.accessibility), void (e.declare && this.raise(e.start, dt3.IndexSignatureHasDeclare));
                    super.parseClassMemberWithIsStatic(t, e, s, r);
                }
                parsePostMemberNameModifiers(t) {
                    this.eat(c4.question) && (t.optional = !0), t.readonly && this.match(c4.parenL) && this.raise(t.start, dt3.ClassMethodHasReadonly), t.declare && this.match(c4.parenL) && this.raise(t.start, dt3.ClassMethodHasDeclare);
                }
                parseExpressionStatement(t, e) {
                    return ("Identifier" === e.type ? this.tsParseExpressionStatement(t, e) : void 0) || super.parseExpressionStatement(t, e);
                }
                shouldParseExportDeclaration() {
                    return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
                }
                parseConditional(t, e, s, r) {
                    if (!r || !this.match(c4.question)) return super.parseConditional(t, e, s, r);
                    const i6 = this.tryParse(()=>super.parseConditional(t, e, s)
                    );
                    return i6.node ? (i6.error && (this.state = i6.failState), i6.node) : (r.start = i6.error.pos || this.state.start, t);
                }
                parseParenItem(t, e, s) {
                    if (t = super.parseParenItem(t, e, s), this.eat(c4.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(c4.colon)) {
                        const r6 = this.startNodeAt(e, s);
                        return r6.expression = t, r6.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r6, "TSTypeCastExpression");
                    }
                    return t;
                }
                parseExportDeclaration(t) {
                    const e20 = this.state.start, s7 = this.state.startLoc, r6 = this.eatContextual("declare");
                    let i6;
                    return this.match(c4.name) && (i6 = this.tsTryParseExportDeclaration()), i6 || (i6 = super.parseExportDeclaration(t)), i6 && ("TSInterfaceDeclaration" === i6.type || "TSTypeAliasDeclaration" === i6.type || r6) && (t.exportKind = "type"), i6 && r6 && (this.resetStartLocation(i6, e20, s7), i6.declare = !0), i6;
                }
                parseClassId(t, e, s) {
                    if ((!e || s) && this.isContextual("implements")) return;
                    super.parseClassId(t, e, s, t.declare ? 1024 : 139);
                    const r6 = this.tsTryParseTypeParameters();
                    r6 && (t.typeParameters = r6);
                }
                parseClassPropertyAnnotation(t) {
                    !t.optional && this.eat(c4.bang) && (t.definite = !0);
                    const e20 = this.tsTryParseTypeAnnotation();
                    e20 && (t.typeAnnotation = e20);
                }
                parseClassProperty(t) {
                    return this.parseClassPropertyAnnotation(t), this.state.isDeclareContext && this.match(c4.eq) && this.raise(this.state.start, dt3.DeclareClassFieldHasInitializer), super.parseClassProperty(t);
                }
                parseClassPrivateProperty(t) {
                    return t.abstract && this.raise(t.start, dt3.PrivateElementHasAbstract), t.accessibility && this.raise(t.start, dt3.PrivateElementHasAccessibility, t.accessibility), this.parseClassPropertyAnnotation(t), super.parseClassPrivateProperty(t);
                }
                pushClassMethod(t, e, s, r, i, n) {
                    const a5 = this.tsTryParseTypeParameters();
                    a5 && i && this.raise(a5.start, dt3.ConstructorHasTypeParameters), a5 && (e.typeParameters = a5), super.pushClassMethod(t, e, s, r, i, n);
                }
                pushClassPrivateMethod(t, e, s, r) {
                    const i6 = this.tsTryParseTypeParameters();
                    i6 && (e.typeParameters = i6), super.pushClassPrivateMethod(t, e, s, r);
                }
                parseClassSuper(t) {
                    super.parseClassSuper(t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (t.implements = this.tsParseHeritageClause("implements"));
                }
                parseObjPropValue(t, ...e) {
                    const s7 = this.tsTryParseTypeParameters();
                    s7 && (t.typeParameters = s7), super.parseObjPropValue(t, ...e);
                }
                parseFunctionParams(t, e) {
                    const s7 = this.tsTryParseTypeParameters();
                    s7 && (t.typeParameters = s7), super.parseFunctionParams(t, e);
                }
                parseVarId(t, e) {
                    super.parseVarId(t, e), "Identifier" === t.id.type && this.eat(c4.bang) && (t.definite = !0);
                    const s7 = this.tsTryParseTypeAnnotation();
                    s7 && (t.id.typeAnnotation = s7, this.resetEndLocation(t.id));
                }
                parseAsyncArrowFromCallExpression(t, e) {
                    return this.match(c4.colon) && (t.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t, e);
                }
                parseMaybeAssign(...t) {
                    var e20, s7, r6, i6, n6, a5, o5;
                    let u5, h5, p5, l5;
                    if (this.match(c4.jsxTagStart)) {
                        if (u5 = this.state.clone(), h5 = this.tryParse(()=>super.parseMaybeAssign(...t)
                        , u5), !h5.error) return h5.node;
                        const { context: e23  } = this.state;
                        e23[e23.length - 1] === T4.j_oTag ? e23.length -= 2 : e23[e23.length - 1] === T4.j_expr && (e23.length -= 1);
                    }
                    if (!(null == (e20 = h5) ? void 0 : e20.error) && !this.isRelational("<")) return super.parseMaybeAssign(...t);
                    u5 = u5 || this.state.clone();
                    const d5 = this.tryParse((e23)=>{
                        var s8;
                        l5 = this.tsParseTypeParameters();
                        const r7 = super.parseMaybeAssign(...t);
                        return ("ArrowFunctionExpression" !== r7.type || r7.extra && r7.extra.parenthesized) && e23(), 0 !== (null == (s8 = l5) ? void 0 : s8.params.length) && this.resetStartLocationFromNode(r7, l5), r7.typeParameters = l5, r7;
                    }, u5);
                    if (!d5.error && !d5.aborted) return d5.node;
                    if (!h5 && (lt3(!this.hasPlugin("jsx")), p5 = this.tryParse(()=>super.parseMaybeAssign(...t)
                    , u5), !p5.error)) return p5.node;
                    if (null == (s7 = h5) ? void 0 : s7.node) return this.state = h5.failState, h5.node;
                    if (d5.node) return this.state = d5.failState, d5.node;
                    if (null == (r6 = p5) ? void 0 : r6.node) return this.state = p5.failState, p5.node;
                    if (null == (i6 = h5) ? void 0 : i6.thrown) throw h5.error;
                    if (d5.thrown) throw d5.error;
                    if (null == (n6 = p5) ? void 0 : n6.thrown) throw p5.error;
                    throw (null == (a5 = h5) ? void 0 : a5.error) || d5.error || (null == (o5 = p5) ? void 0 : o5.error);
                }
                parseMaybeUnary(t) {
                    return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t);
                }
                parseArrow(t) {
                    if (this.match(c4.colon)) {
                        const e20 = this.tryParse((t19)=>{
                            const e23 = this.tsParseTypeOrTypePredicateAnnotation(c4.colon);
                            return !this.canInsertSemicolon() && this.match(c4.arrow) || t19(), e23;
                        });
                        if (e20.aborted) return;
                        e20.thrown || (e20.error && (this.state = e20.failState), t.returnType = e20.node);
                    }
                    return super.parseArrow(t);
                }
                parseAssignableListItemTypes(t) {
                    this.eat(c4.question) && ("Identifier" === t.type || this.state.isDeclareContext || this.state.inType || this.raise(t.start, dt3.PatternIsOptional), t.optional = !0);
                    const e20 = this.tsTryParseTypeAnnotation();
                    return e20 && (t.typeAnnotation = e20), this.resetEndLocation(t), t;
                }
                toAssignable(t) {
                    switch(t.type){
                        case "TSTypeCastExpression":
                            return super.toAssignable(this.typeCastToParameter(t));
                        case "TSParameterProperty":
                            return super.toAssignable(t);
                        case "TSAsExpression":
                        case "TSNonNullExpression":
                        case "TSTypeAssertion":
                            return t.expression = this.toAssignable(t.expression), t;
                        default:
                            return super.toAssignable(t);
                    }
                }
                checkLVal(t, e = 64, s, r) {
                    switch(t.type){
                        case "TSTypeCastExpression":
                            return;
                        case "TSParameterProperty":
                            return void this.checkLVal(t.parameter, e, s, "parameter property");
                        case "TSAsExpression":
                        case "TSNonNullExpression":
                        case "TSTypeAssertion":
                            return void this.checkLVal(t.expression, e, s, r);
                        default:
                            return void super.checkLVal(t, e, s, r);
                    }
                }
                parseBindingAtom() {
                    switch(this.state.type){
                        case c4._this:
                            return this.parseIdentifier(!0);
                        default:
                            return super.parseBindingAtom();
                    }
                }
                parseMaybeDecoratorArguments(t) {
                    if (this.isRelational("<")) {
                        const e20 = this.tsParseTypeArguments();
                        if (this.match(c4.parenL)) {
                            const s7 = super.parseMaybeDecoratorArguments(t);
                            return s7.typeParameters = e20, s7;
                        }
                        this.unexpected(this.state.start, c4.parenL);
                    }
                    return super.parseMaybeDecoratorArguments(t);
                }
                isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                }
                isClassProperty() {
                    return this.match(c4.bang) || this.match(c4.colon) || super.isClassProperty();
                }
                parseMaybeDefault(...t) {
                    const e20 = super.parseMaybeDefault(...t);
                    return "AssignmentPattern" === e20.type && e20.typeAnnotation && e20.right.start < e20.typeAnnotation.start && this.raise(e20.typeAnnotation.start, dt3.TypeAnnotationAfterAssign), e20;
                }
                getTokenFromCode(t) {
                    return !this.state.inType || 62 !== t && 60 !== t ? super.getTokenFromCode(t) : this.finishOp(c4.relational, 1);
                }
                reScan_lt_gt() {
                    if (this.match(c4.relational)) {
                        const t19 = this.input.charCodeAt(this.state.start);
                        60 !== t19 && 62 !== t19 || (this.state.pos -= 1, this.readToken_lt_gt(t19));
                    }
                }
                toAssignableList(t) {
                    for(let e20 = 0; e20 < t.length; e20++){
                        const s7 = t[e20];
                        if (s7) switch(s7.type){
                            case "TSTypeCastExpression":
                                t[e20] = this.typeCastToParameter(s7);
                                break;
                            case "TSAsExpression":
                            case "TSTypeAssertion":
                                this.state.maybeInArrowParameters ? this.raise(s7.start, dt3.UnexpectedTypeCastInParameter) : t[e20] = this.typeCastToParameter(s7);
                        }
                    }
                    return super.toAssignableList(...arguments);
                }
                typeCastToParameter(t) {
                    return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;
                }
                shouldParseArrow() {
                    return this.match(c4.colon) || super.shouldParseArrow();
                }
                shouldParseAsyncArrow() {
                    return this.match(c4.colon) || super.shouldParseAsyncArrow();
                }
                canHaveLeadingDecorator() {
                    return super.canHaveLeadingDecorator() || this.isAbstractClass();
                }
                jsxParseOpeningElementAfterName(t) {
                    if (this.isRelational("<")) {
                        const e20 = this.tsTryParseAndCatch(()=>this.tsParseTypeArguments()
                        );
                        e20 && (t.typeParameters = e20);
                    }
                    return super.jsxParseOpeningElementAfterName(t);
                }
                getGetterSetterExpectedParamCount(t) {
                    const e20 = super.getGetterSetterExpectedParamCount(t), s7 = t.params[0];
                    return s7 && "Identifier" === s7.type && "this" === s7.name ? e20 + 1 : e20;
                }
                parseCatchClauseParam() {
                    const t19 = super.parseCatchClauseParam(), e20 = this.tsTryParseTypeAnnotation();
                    return e20 && (t19.typeAnnotation = e20, this.resetEndLocation(t19)), t19;
                }
                tsInDeclareContext(t) {
                    const e20 = this.state.isDeclareContext;
                    this.state.isDeclareContext = !0;
                    try {
                        return t();
                    } finally{
                        this.state.isDeclareContext = e20;
                    }
                }
            }
        ,
        v8intrinsic: (t18)=>class extends t18 {
                parseV8Intrinsic() {
                    if (this.match(c4.modulo)) {
                        const t19 = this.state.start, e20 = this.startNode();
                        if (this.eat(c4.modulo), this.match(c4.name)) {
                            const t20 = this.parseIdentifierName(this.state.start), s7 = this.createIdentifier(e20, t20);
                            if (s7.type = "V8IntrinsicIdentifier", this.match(c4.parenL)) return s7;
                        }
                        this.unexpected(t19);
                    }
                }
                parseExprAtom() {
                    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
                }
            }
        ,
        placeholders: (t18)=>class extends t18 {
                parsePlaceholder(t) {
                    if (this.match(c4.placeholder)) {
                        const e20 = this.startNode();
                        return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e20.name = super.parseIdentifier(!0), this.assertNoSpace("Unexpected space in placeholder."), this.expect(c4.placeholder), this.finishPlaceholder(e20, t);
                    }
                }
                finishPlaceholder(t, e) {
                    const s7 = !(!t.expectedNode || "Placeholder" !== t.type);
                    return t.expectedNode = e, s7 ? t : this.finishNode(t, "Placeholder");
                }
                getTokenFromCode(t) {
                    return 37 === t && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c4.placeholder, 2) : super.getTokenFromCode(...arguments);
                }
                parseExprAtom() {
                    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
                }
                parseIdentifier() {
                    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
                }
                checkReservedWord(t) {
                    (void 0) !== t && super.checkReservedWord(...arguments);
                }
                parseBindingAtom() {
                    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
                }
                checkLVal(t) {
                    "Placeholder" !== t.type && super.checkLVal(...arguments);
                }
                toAssignable(t) {
                    return t && "Placeholder" === t.type && "Expression" === t.expectedNode ? (t.expectedNode = "Pattern", t) : super.toAssignable(...arguments);
                }
                verifyBreakContinue(t) {
                    t.label && "Placeholder" === t.label.type || super.verifyBreakContinue(...arguments);
                }
                parseExpressionStatement(t, e) {
                    if ("Placeholder" !== e.type || e.extra && e.extra.parenthesized) return super.parseExpressionStatement(...arguments);
                    if (this.match(c4.colon)) {
                        const s7 = t;
                        return t.label = this.finishPlaceholder(e, "Identifier"), this.next(), t.body = this.parseStatement("label"), this.finishNode(t, "LabeledStatement");
                    }
                    return this.semicolon(), t.name = e.name, this.finishPlaceholder(t, "Statement");
                }
                parseBlock() {
                    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
                }
                parseFunctionId() {
                    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
                }
                parseClass(t, e, s) {
                    const r6 = e ? "ClassDeclaration" : "ClassExpression";
                    this.next(), this.takeDecorators(t);
                    const i6 = this.state.strict, n6 = this.parsePlaceholder("Identifier");
                    if (n6) {
                        if (this.match(c4._extends) || this.match(c4.placeholder) || this.match(c4.braceL)) t.id = n6;
                        else {
                            if (s || !e) return t.id = null, t.body = this.finishPlaceholder(n6, "ClassBody"), this.finishNode(t, r6);
                            this.unexpected(null, "A class name is required");
                        }
                    } else this.parseClassId(t, e, s);
                    return this.parseClassSuper(t), t.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t.superClass, i6), this.finishNode(t, r6);
                }
                parseExport(t) {
                    const e20 = this.parsePlaceholder("Identifier");
                    if (!e20) return super.parseExport(...arguments);
                    if (!this.isContextual("from") && !this.match(c4.comma)) return t.specifiers = [], t.source = null, t.declaration = this.finishPlaceholder(e20, "Declaration"), this.finishNode(t, "ExportNamedDeclaration");
                    this.expectPlugin("exportDefaultFrom");
                    const s7 = this.startNode();
                    return s7.exported = e20, t.specifiers = [
                        this.finishNode(s7, "ExportDefaultSpecifier")
                    ], super.parseExport(t);
                }
                isExportDefaultSpecifier() {
                    if (this.match(c4._default)) {
                        const t19 = this.nextTokenStart();
                        if (this.isUnparsedContextual(t19, "from") && this.input.startsWith(c4.placeholder.label, this.nextTokenStartSince(t19 + 4))) return !0;
                    }
                    return super.isExportDefaultSpecifier();
                }
                maybeParseExportDefaultSpecifier(t) {
                    return !!(t.specifiers && t.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
                }
                checkExport(t) {
                    const { specifiers: e20  } = t;
                    (null == e20 ? void 0 : e20.length) && (t.specifiers = e20.filter((t19)=>"Placeholder" === t19.exported.type
                    )), super.checkExport(t), t.specifiers = e20;
                }
                parseImport(t) {
                    const e20 = this.parsePlaceholder("Identifier");
                    if (!e20) return super.parseImport(...arguments);
                    if (t.specifiers = [], !this.isContextual("from") && !this.match(c4.comma)) return t.source = this.finishPlaceholder(e20, "StringLiteral"), this.semicolon(), this.finishNode(t, "ImportDeclaration");
                    const s7 = this.startNodeAtNode(e20);
                    if (s7.local = e20, this.finishNode(s7, "ImportDefaultSpecifier"), t.specifiers.push(s7), this.eat(c4.comma)) {
                        this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t);
                    }
                    return this.expectContextual("from"), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, "ImportDeclaration");
                }
                parseImportSource() {
                    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
                }
            }
    }, At2 = Object.keys(Et2), Ct2 = {
        sourceType: "script",
        sourceFilename: void 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1
    };
    class xt2 {
        constructor(){
            this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inPipeline = !1, this.inType = !1, this.noAnonFunctionType = !1, this.inPropertyName = !1, this.hasFlowComment = !1, this.isIterator = !1, this.isDeclareContext = !1, this.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.decoratorStack = [
                []
            ], this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = c4.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [
                T4.braceStatement
            ], this.exprAllowed = !0, this.containsEsc = !1, this.octalPositions = [], this.exportedIdentifiers = [], this.tokensLength = 0;
        }
        init(t) {
            this.strict = !1 !== t.strictMode && "module" === t.sourceType, this.curLine = t.startLine, this.startLoc = this.endLoc = this.curPosition();
        }
        curPosition() {
            return new C4(this.curLine, this.pos - this.lineStart);
        }
        clone(t) {
            const e20 = new xt2, s7 = Object.keys(this);
            for(let r6 = 0, i6 = s7.length; r6 < i6; r6++){
                const i6 = s7[r6];
                let n6 = this[i6];
                !t && Array.isArray(n6) && (n6 = n6.slice()), e20[i6] = n6;
            }
            return e20;
        }
    }
    var Ft2 = function(t18) {
        return t18 >= 48 && t18 <= 57;
    };
    const gt2 = new Set([
        "g",
        "m",
        "s",
        "i",
        "y",
        "u"
    ]), bt2 = {
        decBinOct: [
            46,
            66,
            69,
            79,
            95,
            98,
            101,
            111
        ],
        hex: [
            46,
            88,
            95,
            120
        ]
    }, Pt2 = {
        bin: [
            48,
            49
        ]
    };
    Pt2.oct = [
        ...Pt2.bin,
        50,
        51,
        52,
        53,
        54,
        55
    ], Pt2.dec = [
        ...Pt2.oct,
        56,
        57
    ], Pt2.hex = [
        ...Pt2.dec,
        65,
        66,
        67,
        68,
        69,
        70,
        97,
        98,
        99,
        100,
        101,
        102
    ];
    class Tt2 {
        constructor(t18){
            this.type = t18.type, this.value = t18.value, this.start = t18.start, this.end = t18.end, this.loc = new x4(t18.startLoc, t18.endLoc);
        }
    }
    class wt2 {
        constructor(){
            this.shorthandAssign = -1, this.doubleProto = -1;
        }
    }
    class Bt3 {
        constructor(t19, e20, s7){
            this.type = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.range = void 0, this.leadingComments = void 0, this.trailingComments = void 0, this.innerComments = void 0, this.extra = void 0, this.type = "", this.start = e20, this.end = 0, this.loc = new x4(s7), (null == t19 ? void 0 : t19.options.ranges) && (this.range = [
                e20,
                0
            ]), (null == t19 ? void 0 : t19.filename) && (this.loc.filename = t19.filename);
        }
        __clone() {
            const t20 = new Bt3, e23 = Object.keys(this);
            for(let s8 = 0, r6 = e23.length; s8 < r6; s8++){
                const r6 = e23[s8];
                "leadingComments" !== r6 && "trailingComments" !== r6 && "innerComments" !== r6 && (t20[r6] = this[r6]);
            }
            return t20;
        }
    }
    const St2 = (t20)=>"ParenthesizedExpression" === t20.type ? St2(t20.expression) : t20
    ;
    class Nt2 {
        constructor(t20 = 0){
            this.type = void 0, this.type = t20;
        }
        canBeArrowParameterDeclaration() {
            return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
            return 3 === this.type;
        }
    }
    class It3 extends Nt2 {
        constructor(t21){
            super(t21), this.errors = new Map;
        }
        recordDeclarationError(t, e) {
            this.errors.set(t, e);
        }
        clearDeclarationError(t) {
            this.errors.delete(t);
        }
        iterateErrors(t) {
            this.errors.forEach(t);
        }
    }
    class vt2 {
        constructor(t22){
            this.stack = [
                new Nt2
            ], this.raise = t22;
        }
        enter(t) {
            this.stack.push(t);
        }
        exit() {
            this.stack.pop();
        }
        recordParameterInitializerError(t, e) {
            const { stack: s8  } = this;
            let r6 = s8.length - 1, i6 = s8[r6];
            for(; !i6.isCertainlyParameterDeclaration();){
                if (!i6.canBeArrowParameterDeclaration()) return;
                i6.recordDeclarationError(t, e), i6 = s8[--r6];
            }
            this.raise(t, e);
        }
        recordAsyncArrowParametersError(t, e) {
            const { stack: s8  } = this;
            let r6 = s8.length - 1, i6 = s8[r6];
            for(; i6.canBeArrowParameterDeclaration();)2 === i6.type && i6.recordDeclarationError(t, e), i6 = s8[--r6];
        }
        validateAsPattern() {
            const { stack: t23  } = this, e23 = t23[t23.length - 1];
            e23.canBeArrowParameterDeclaration() && e23.iterateErrors((e24, s8)=>{
                this.raise(s8, e24);
                let r6 = t23.length - 2, i6 = t23[r6];
                for(; i6.canBeArrowParameterDeclaration();)i6.clearDeclarationError(s8), i6 = t23[--r6];
            });
        }
    }
    function kt2() {
        return new Nt2;
    }
    const Lt3 = {
        kind: "loop"
    }, Ot2 = {
        kind: "switch"
    }, Mt3 = /[\uD800-\uDFFF]/u;
    class Rt2 {
        constructor(){
            this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
        }
    }
    class _t3 {
        constructor(t23){
            this.stack = [], this.undefinedPrivateNames = new Map, this.raise = t23;
        }
        current() {
            return this.stack[this.stack.length - 1];
        }
        enter() {
            this.stack.push(new Rt2);
        }
        exit() {
            const t24 = this.stack.pop(), e23 = this.current();
            for(let s8 = 0, r6 = Array.from(t24.undefinedPrivateNames); s8 < r6.length; s8++){
                const [t25, i6] = r6[s8];
                e23 ? e23.undefinedPrivateNames.has(t25) || e23.undefinedPrivateNames.set(t25, i6) : this.raise(i6, g4.InvalidPrivateFieldResolution, t25);
            }
        }
        declarePrivateName(t, e, s) {
            const r6 = this.current();
            let i6 = r6.privateNames.has(t);
            if (3 & e) {
                const s8 = i6 && r6.loneAccessors.get(t);
                if (s8) {
                    const n6 = 4 & s8, a5 = 4 & e;
                    i6 = (3 & s8) === (3 & e) || n6 !== a5, i6 || r6.loneAccessors.delete(t);
                } else i6 || r6.loneAccessors.set(t, e);
            }
            i6 && this.raise(s, g4.PrivateNameRedeclaration, t), r6.privateNames.add(t), r6.undefinedPrivateNames.delete(t);
        }
        usePrivateName(t, e) {
            let s8;
            for(let e23 = 0, r6 = this.stack; e23 < r6.length; e23++)if (s8 = r6[e23], s8.privateNames.has(t)) return;
            s8 ? s8.undefinedPrivateNames.set(t, e) : this.raise(e, g4.InvalidPrivateFieldResolution, t);
        }
    }
    class jt3 extends class extends class extends class extends class extends class extends class extends class extends class extends class {
        constructor(){
            this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
        }
        hasPlugin(t) {
            return this.plugins.has(t);
        }
        getPluginOption(t, e) {
            if (this.hasPlugin(t)) return this.plugins.get(t)[e];
        }
    } {
        addComment(t) {
            this.filename && (t.loc.filename = this.filename), this.state.trailingComments.push(t), this.state.leadingComments.push(t);
        }
        adjustCommentsAfterTrailingComma(t, e, s) {
            if (0 === this.state.leadingComments.length) return;
            let r6 = null, i6 = e.length;
            for(; null === r6 && i6 > 0;)r6 = e[--i6];
            if (null === r6) return;
            for(let t24 = 0; t24 < this.state.leadingComments.length; t24++)this.state.leadingComments[t24].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(t24, 1), t24--);
            const n6 = [];
            for(let e23 = 0; e23 < this.state.leadingComments.length; e23++){
                const r7 = this.state.leadingComments[e23];
                r7.end < t.end ? (n6.push(r7), s || (this.state.leadingComments.splice(e23, 1), e23--)) : ((void 0) === t.trailingComments && (t.trailingComments = []), t.trailingComments.push(r7));
            }
            s && (this.state.leadingComments = []), n6.length > 0 ? r6.trailingComments = n6 : (void 0) !== r6.trailingComments && (r6.trailingComments = []);
        }
        processComment(t) {
            if ("Program" === t.type && t.body.length > 0) return;
            const e23 = this.state.commentStack;
            let s8, r6, i6, n6, a5;
            if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= t.end ? (i6 = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;
            else if (e23.length > 0) {
                const s9 = F3(e23);
                s9.trailingComments && s9.trailingComments[0].start >= t.end && (i6 = s9.trailingComments, delete s9.trailingComments);
            }
            for(e23.length > 0 && F3(e23).start >= t.start && (s8 = e23.pop()); e23.length > 0 && F3(e23).start >= t.start;)r6 = e23.pop();
            if (!r6 && s8 && (r6 = s8), s8) switch(t.type){
                case "ObjectExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.properties);
                    break;
                case "ObjectPattern":
                    this.adjustCommentsAfterTrailingComma(t, t.properties, !0);
                    break;
                case "CallExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.arguments);
                    break;
                case "ArrayExpression":
                    this.adjustCommentsAfterTrailingComma(t, t.elements);
                    break;
                case "ArrayPattern":
                    this.adjustCommentsAfterTrailingComma(t, t.elements, !0);
            }
            else this.state.commentPreviousNode && ("ImportSpecifier" === this.state.commentPreviousNode.type && "ImportSpecifier" !== t.type || "ExportSpecifier" === this.state.commentPreviousNode.type && "ExportSpecifier" !== t.type) && this.adjustCommentsAfterTrailingComma(t, [
                this.state.commentPreviousNode
            ]);
            if (r6) {
                if (r6.leadingComments) {
                    if (r6 !== t && r6.leadingComments.length > 0 && F3(r6.leadingComments).end <= t.start) t.leadingComments = r6.leadingComments, delete r6.leadingComments;
                    else for(n6 = r6.leadingComments.length - 2; n6 >= 0; --n6)if (r6.leadingComments[n6].end <= t.start) {
                        t.leadingComments = r6.leadingComments.splice(0, n6 + 1);
                        break;
                    }
                }
            } else if (this.state.leadingComments.length > 0) {
                if (F3(this.state.leadingComments).end <= t.start) {
                    if (this.state.commentPreviousNode) for(a5 = 0; a5 < this.state.leadingComments.length; a5++)this.state.leadingComments[a5].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(a5, 1), a5--);
                    this.state.leadingComments.length > 0 && (t.leadingComments = this.state.leadingComments, this.state.leadingComments = []);
                } else {
                    for(n6 = 0; n6 < this.state.leadingComments.length && !(this.state.leadingComments[n6].end > t.start); n6++);
                    const e24 = this.state.leadingComments.slice(0, n6);
                    e24.length && (t.leadingComments = e24), i6 = this.state.leadingComments.slice(n6), 0 === i6.length && (i6 = null);
                }
            }
            if (this.state.commentPreviousNode = t, i6) {
                if (i6.length && i6[0].start >= t.start && F3(i6).end <= t.end) t.innerComments = i6;
                else {
                    const e24 = i6.findIndex((e25)=>e25.end >= t.end
                    );
                    e24 > 0 ? (t.innerComments = i6.slice(0, e24), t.trailingComments = i6.slice(e24)) : t.trailingComments = i6;
                }
            }
            e23.push(t);
        }
    } {
        getLocationForPosition(t) {
            let e23;
            return e23 = t === this.state.start ? this.state.startLoc : t === this.state.lastTokStart ? this.state.lastTokStartLoc : t === this.state.end ? this.state.endLoc : t === this.state.lastTokEnd ? this.state.lastTokEndLoc : (function(t24, e24) {
                let s8, r6 = 1, i6 = 0;
                for(f4.lastIndex = 0; (s8 = f4.exec(t24)) && s8.index < e24;)r6++, i6 = f4.lastIndex;
                return new C4(r6, e24 - i6);
            })(this.input, t), e23;
        }
        raise(t, e, ...s) {
            return this.raiseWithData(t, void 0, e, ...s);
        }
        raiseWithData(t, e, s, ...r) {
            const i6 = this.getLocationForPosition(t), n6 = s.replace(/%(\d+)/g, (t24, e23)=>r[e23]
            ) + " (".concat(i6.line, ":").concat(i6.column, ")");
            return this._raise(Object.assign({
                loc: i6,
                pos: t
            }, e), n6);
        }
        _raise(t, e) {
            const s8 = new SyntaxError(e);
            if (Object.assign(s8, t), this.options.errorRecovery) return this.isLookahead || this.state.errors.push(s8), s8;
            throw s8;
        }
    } {
        constructor(t24, e23){
            super(), this.isLookahead = void 0, this.tokens = [], this.state = new xt2, this.state.init(t24), this.input = e23, this.length = e23.length, this.isLookahead = !1;
        }
        pushToken(t) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
        }
        next() {
            this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Tt2(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
        }
        eat(t) {
            return !!this.match(t) && (this.next(), !0);
        }
        match(t) {
            return this.state.type === t;
        }
        lookahead() {
            const t25 = this.state;
            this.state = t25.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1;
            const e24 = this.state;
            return this.state = t25, e24;
        }
        nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(t) {
            E4.lastIndex = t;
            return t + E4.exec(this.input)[0].length;
        }
        lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
        }
        setStrict(t) {
            if (this.state.strict = t, this.match(c4.num) || this.match(c4.string)) {
                for(this.state.pos = this.state.start; this.state.pos < this.state.lineStart;)this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1, --this.state.curLine;
                this.nextToken();
            }
        }
        curContext() {
            return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
            const t25 = this.curContext();
            if ((null == t25 ? void 0 : t25.preserveSpace) || this.skipSpace(), this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length) return void this.finishToken(c4.eof);
            const e24 = null == t25 ? void 0 : t25.override;
            e24 ? e24(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));
        }
        pushComment(t, e, s, r, i, n) {
            const a5 = {
                type: t ? "CommentBlock" : "CommentLine",
                value: e,
                start: s,
                end: r,
                loc: new x4(i, n)
            };
            this.options.tokens && this.pushToken(a5), this.state.comments.push(a5), this.addComment(a5);
        }
        skipBlockComment() {
            const t25 = this.state.curPosition(), e24 = this.state.pos, s8 = this.input.indexOf("*/", this.state.pos + 2);
            if (-1 === s8) throw this.raise(e24, g4.UnterminatedComment);
            let r6;
            for(this.state.pos = s8 + 2, f4.lastIndex = e24; (r6 = f4.exec(this.input)) && r6.index < this.state.pos;)++this.state.curLine, this.state.lineStart = r6.index + r6[0].length;
            this.isLookahead || this.pushComment(!0, this.input.slice(e24 + 2, s8), e24, this.state.pos, t25, this.state.curPosition());
        }
        skipLineComment(t) {
            const e24 = this.state.pos, s8 = this.state.curPosition();
            let r6 = this.input.charCodeAt(this.state.pos += t);
            if (this.state.pos < this.length) for(; !y4(r6) && (++this.state.pos) < this.length;)r6 = this.input.charCodeAt(this.state.pos);
            this.isLookahead || this.pushComment(!1, this.input.slice(e24 + t, this.state.pos), e24, this.state.pos, s8, this.state.curPosition());
        }
        skipSpace() {
            t: for(; this.state.pos < this.length;){
                const t25 = this.input.charCodeAt(this.state.pos);
                switch(t25){
                    case 32:
                    case 160:
                    case 9:
                        ++this.state.pos;
                        break;
                    case 13:
                        10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                        break;
                    case 47:
                        switch(this.input.charCodeAt(this.state.pos + 1)){
                            case 42:
                                this.skipBlockComment();
                                break;
                            case 47:
                                this.skipLineComment(2);
                                break;
                            default: break t;
                        }
                        break;
                    default:
                        if (!A3(t25)) break t;
                        ++this.state.pos;
                }
            }
        }
        finishToken(t, e) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const s8 = this.state.type;
            this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s8);
        }
        readToken_numberSign() {
            if (0 === this.state.pos && this.readToken_interpreter()) return;
            const t25 = this.state.pos + 1, e24 = this.input.charCodeAt(t25);
            if (e24 >= 48 && e24 <= 57) throw this.raise(this.state.pos, g4.UnexpectedDigitAfterHash);
            if (123 === e24 || 91 === e24 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, 123 === e24 ? g4.RecordExpressionHashIncorrectStartSyntaxType : g4.TupleExpressionHashIncorrectStartSyntaxType);
                123 === e24 ? this.finishToken(c4.braceHashL) : this.finishToken(c4.bracketHashL), this.state.pos += 2;
            } else this.finishOp(c4.hash, 1);
        }
        readToken_dot() {
            const t25 = this.input.charCodeAt(this.state.pos + 1);
            t25 >= 48 && t25 <= 57 ? this.readNumber(!0) : 46 === t25 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(c4.ellipsis)) : (++this.state.pos, this.finishToken(c4.dot));
        }
        readToken_slash() {
            if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp();
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c4.assign, 2) : this.finishOp(c4.slash, 1);
        }
        readToken_interpreter() {
            if (0 !== this.state.pos || this.length < 2) return !1;
            let t25 = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== t25) return !1;
            const e24 = this.state.pos;
            for(this.state.pos += 1; !y4(t25) && (++this.state.pos) < this.length;)t25 = this.input.charCodeAt(this.state.pos);
            const s8 = this.input.slice(e24 + 2, this.state.pos);
            return this.finishToken(c4.interpreterDirective, s8), !0;
        }
        readToken_mult_modulo(t) {
            let e24 = 42 === t ? c4.star : c4.modulo, s8 = 1, r6 = this.input.charCodeAt(this.state.pos + 1);
            const i6 = this.state.exprAllowed;
            42 === t && 42 === r6 && (s8++, r6 = this.input.charCodeAt(this.state.pos + 2), e24 = c4.exponent), 61 !== r6 || i6 || (s8++, e24 = c4.assign), this.finishOp(e24, s8);
        }
        readToken_pipe_amp(t) {
            const e24 = this.input.charCodeAt(this.state.pos + 1);
            if (e24 !== t) {
                if (124 === t) {
                    if (62 === e24) return void this.finishOp(c4.pipeline, 2);
                    if (this.hasPlugin("recordAndTuple") && 125 === e24) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g4.RecordExpressionBarIncorrectEndSyntaxType);
                        return void this.finishOp(c4.braceBarR, 2);
                    }
                    if (this.hasPlugin("recordAndTuple") && 93 === e24) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g4.TupleExpressionBarIncorrectEndSyntaxType);
                        return void this.finishOp(c4.bracketBarR, 2);
                    }
                }
                61 !== e24 ? this.finishOp(124 === t ? c4.bitwiseOR : c4.bitwiseAND, 1) : this.finishOp(c4.assign, 2);
            } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(c4.assign, 3) : this.finishOp(124 === t ? c4.logicalOR : c4.logicalAND, 2);
        }
        readToken_caret() {
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c4.assign, 2) : this.finishOp(c4.bitwiseXOR, 1);
        }
        readToken_plus_min(t) {
            const e24 = this.input.charCodeAt(this.state.pos + 1);
            if (e24 === t) return 45 !== e24 || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !this.hasPrecedingLineBreak() ? void this.finishOp(c4.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());
            61 === e24 ? this.finishOp(c4.assign, 2) : this.finishOp(c4.plusMin, 1);
        }
        readToken_lt_gt(t) {
            const e24 = this.input.charCodeAt(this.state.pos + 1);
            let s8 = 1;
            return e24 === t ? (s8 = 62 === t && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s8) ? void this.finishOp(c4.assign, s8 + 1) : void this.finishOp(c4.bitShift, s8)) : 33 !== e24 || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e24 && (s8 = 2), void this.finishOp(c4.relational, s8)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());
        }
        readToken_eq_excl(t) {
            const e24 = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== e24) return 61 === t && 62 === e24 ? (this.state.pos += 2, void this.finishToken(c4.arrow)) : void this.finishOp(61 === t ? c4.eq : c4.bang, 1);
            this.finishOp(c4.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
            const t25 = this.input.charCodeAt(this.state.pos + 1), e24 = this.input.charCodeAt(this.state.pos + 2);
            63 === t25 ? 61 === e24 ? this.finishOp(c4.assign, 3) : this.finishOp(c4.nullishCoalescing, 2) : 46 !== t25 || e24 >= 48 && e24 <= 57 ? (++this.state.pos, this.finishToken(c4.question)) : (this.state.pos += 2, this.finishToken(c4.questionDot));
        }
        getTokenFromCode(t) {
            switch(t){
                case 46:
                    return void this.readToken_dot();
                case 40:
                    return ++this.state.pos, void this.finishToken(c4.parenL);
                case 41:
                    return ++this.state.pos, void this.finishToken(c4.parenR);
                case 59:
                    return ++this.state.pos, void this.finishToken(c4.semi);
                case 44:
                    return ++this.state.pos, void this.finishToken(c4.comma);
                case 91:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g4.TupleExpressionBarIncorrectStartSyntaxType);
                        this.finishToken(c4.bracketBarL), this.state.pos += 2;
                    } else ++this.state.pos, this.finishToken(c4.bracketL);
                    return;
                case 93:
                    return ++this.state.pos, void this.finishToken(c4.bracketR);
                case 123:
                    if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                        if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, g4.RecordExpressionBarIncorrectStartSyntaxType);
                        this.finishToken(c4.braceBarL), this.state.pos += 2;
                    } else ++this.state.pos, this.finishToken(c4.braceL);
                    return;
                case 125:
                    return ++this.state.pos, void this.finishToken(c4.braceR);
                case 58:
                    return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(c4.doubleColon, 2) : (++this.state.pos, this.finishToken(c4.colon)));
                case 63:
                    return void this.readToken_question();
                case 96:
                    return ++this.state.pos, void this.finishToken(c4.backQuote);
                case 48:
                    {
                        const t25 = this.input.charCodeAt(this.state.pos + 1);
                        if (120 === t25 || 88 === t25) return void this.readRadixNumber(16);
                        if (111 === t25 || 79 === t25) return void this.readRadixNumber(8);
                        if (98 === t25 || 66 === t25) return void this.readRadixNumber(2);
                    }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return void this.readNumber(!1);
                case 34:
                case 39:
                    return void this.readString(t);
                case 47:
                    return void this.readToken_slash();
                case 37:
                case 42:
                    return void this.readToken_mult_modulo(t);
                case 124:
                case 38:
                    return void this.readToken_pipe_amp(t);
                case 94:
                    return void this.readToken_caret();
                case 43:
                case 45:
                    return void this.readToken_plus_min(t);
                case 60:
                case 62:
                    return void this.readToken_lt_gt(t);
                case 61:
                case 33:
                    return void this.readToken_eq_excl(t);
                case 126:
                    return void this.finishOp(c4.tilde, 1);
                case 64:
                    return ++this.state.pos, void this.finishToken(c4.at);
                case 35:
                    return void this.readToken_numberSign();
                case 92:
                    return void this.readWord();
                default:
                    if (L2(t)) return void this.readWord();
            }
            throw this.raise(this.state.pos, g4.InvalidOrUnexpectedToken, String.fromCodePoint(t));
        }
        finishOp(t, e) {
            const s8 = this.input.slice(this.state.pos, this.state.pos + e);
            this.state.pos += e, this.finishToken(t, s8);
        }
        readRegexp() {
            const t25 = this.state.pos;
            let e24, s8;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(t25, g4.UnterminatedRegExp);
                const r6 = this.input.charAt(this.state.pos);
                if (m4.test(r6)) throw this.raise(t25, g4.UnterminatedRegExp);
                if (e24) e24 = !1;
                else {
                    if ("[" === r6) s8 = !0;
                    else if ("]" === r6 && s8) s8 = !1;
                    else if ("/" === r6 && !s8) break;
                    e24 = "\\" === r6;
                }
                ++this.state.pos;
            }
            const r6 = this.input.slice(t25, this.state.pos);
            ++this.state.pos;
            let i6 = "";
            for(; this.state.pos < this.length;){
                const t26 = this.input[this.state.pos], e25 = this.input.codePointAt(this.state.pos);
                if (gt2.has(t26)) i6.indexOf(t26) > -1 && this.raise(this.state.pos + 1, g4.DuplicateRegExpFlags);
                else {
                    if (!O3(e25) && 92 !== e25) break;
                    this.raise(this.state.pos + 1, g4.MalformedRegExpFlags);
                }
                ++this.state.pos, i6 += t26;
            }
            this.finishToken(c4.regexp, {
                pattern: r6,
                flags: i6
            });
        }
        readInt(t, e, s, r = !0) {
            const i6 = this.state.pos, n6 = 16 === t ? bt2.hex : bt2.decBinOct, a5 = 16 === t ? Pt2.hex : 10 === t ? Pt2.dec : 8 === t ? Pt2.oct : Pt2.bin;
            let o5 = !1, u5 = 0;
            for(let i7 = 0, h5 = null == e ? 1 / 0 : e; i7 < h5; ++i7){
                const e24 = this.input.charCodeAt(this.state.pos);
                let h5;
                if (95 !== e24) {
                    if (h5 = e24 >= 97 ? e24 - 97 + 10 : e24 >= 65 ? e24 - 65 + 10 : Ft2(e24) ? e24 - 48 : 1 / 0, h5 >= t) {
                        if (this.options.errorRecovery && h5 <= 9) h5 = 0, this.raise(this.state.start + i7 + 2, g4.InvalidDigit, t);
                        else {
                            if (!s) break;
                            h5 = 0, o5 = !0;
                        }
                    }
                    ++this.state.pos, u5 = u5 * t + h5;
                } else {
                    const t25 = this.input.charCodeAt(this.state.pos - 1), e25 = this.input.charCodeAt(this.state.pos + 1);
                    (-1 === a5.indexOf(e25) || n6.indexOf(t25) > -1 || n6.indexOf(e25) > -1 || Number.isNaN(e25)) && this.raise(this.state.pos, g4.UnexpectedNumericSeparator), r || this.raise(this.state.pos, g4.NumericSeparatorInEscapeSequence), ++this.state.pos;
                }
            }
            return this.state.pos === i6 || null != e && this.state.pos - i6 !== e || o5 ? null : u5;
        }
        readRadixNumber(t) {
            const e24 = this.state.pos;
            let s8 = !1;
            this.state.pos += 2;
            const r6 = this.readInt(t);
            null == r6 && this.raise(this.state.start + 2, g4.InvalidDigit, t);
            const i6 = this.input.charCodeAt(this.state.pos);
            if (110 === i6) ++this.state.pos, s8 = !0;
            else if (109 === i6) throw this.raise(e24, g4.InvalidDecimal);
            if (L2(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, g4.NumberIdentifier);
            if (s8) {
                const t25 = this.input.slice(e24, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(c4.bigint, t25);
            } else this.finishToken(c4.num, r6);
        }
        readNumber(t) {
            const e24 = this.state.pos;
            let s8 = !1, r6 = !1, i6 = !1, n6 = !1, a5 = !1;
            t || null !== this.readInt(10) || this.raise(e24, g4.InvalidNumber);
            const o5 = this.state.pos - e24 >= 2 && 48 === this.input.charCodeAt(e24);
            if (o5) {
                const t25 = this.input.slice(e24, this.state.pos);
                if (this.state.strict) this.raise(e24, g4.StrictOctalLiteral);
                else {
                    const s9 = t25.indexOf("_");
                    s9 > 0 && this.raise(s9 + e24, g4.ZeroDigitNumericSeparator);
                }
                a5 = o5 && !/[89]/.test(t25);
            }
            let u5 = this.input.charCodeAt(this.state.pos);
            if (46 !== u5 || a5 || (++this.state.pos, this.readInt(10), s8 = !0, u5 = this.input.charCodeAt(this.state.pos)), 69 !== u5 && 101 !== u5 || a5 || (u5 = this.input.charCodeAt(++this.state.pos), 43 !== u5 && 45 !== u5 || ++this.state.pos, null === this.readInt(10) && this.raise(e24, g4.InvalidOrMissingExponent), s8 = !0, n6 = !0, u5 = this.input.charCodeAt(this.state.pos)), 110 === u5 && ((s8 || o5) && this.raise(e24, g4.InvalidBigIntLiteral), ++this.state.pos, r6 = !0), 109 === u5 && (this.expectPlugin("decimal", this.state.pos), (n6 || o5) && this.raise(e24, g4.InvalidDecimal), ++this.state.pos, i6 = !0), L2(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, g4.NumberIdentifier);
            const h5 = this.input.slice(e24, this.state.pos).replace(/[_mn]/g, "");
            if (r6) return void this.finishToken(c4.bigint, h5);
            if (i6) return void this.finishToken(c4.decimal, h5);
            const p5 = a5 ? parseInt(h5, 8) : parseFloat(h5);
            this.finishToken(c4.num, p5);
        }
        readCodePoint(t) {
            let e24;
            if (123 === this.input.charCodeAt(this.state.pos)) {
                const s8 = ++this.state.pos;
                if (e24 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, t), ++this.state.pos, null !== e24 && e24 > 1114111) {
                    if (!t) return null;
                    this.raise(s8, g4.InvalidCodePoint);
                }
            } else e24 = this.readHexChar(4, !1, t);
            return e24;
        }
        readString(t) {
            let e24 = "", s8 = ++this.state.pos;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, g4.UnterminatedString);
                const r6 = this.input.charCodeAt(this.state.pos);
                if (r6 === t) break;
                if (92 === r6) e24 += this.input.slice(s8, this.state.pos), e24 += this.readEscapedChar(!1), s8 = this.state.pos;
                else if (8232 === r6 || 8233 === r6) ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                else {
                    if (y4(r6)) throw this.raise(this.state.start, g4.UnterminatedString);
                    ++this.state.pos;
                }
            }
            e24 += this.input.slice(s8, this.state.pos++), this.finishToken(c4.string, e24);
        }
        readTmplToken() {
            let t25 = "", e24 = this.state.pos, s8 = !1;
            for(;;){
                if (this.state.pos >= this.length) throw this.raise(this.state.start, g4.UnterminatedTemplate);
                const r6 = this.input.charCodeAt(this.state.pos);
                if (96 === r6 || 36 === r6 && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(c4.template) ? 36 === r6 ? (this.state.pos += 2, void this.finishToken(c4.dollarBraceL)) : (++this.state.pos, void this.finishToken(c4.backQuote)) : (t25 += this.input.slice(e24, this.state.pos), void this.finishToken(c4.template, s8 ? null : t25));
                if (92 === r6) {
                    t25 += this.input.slice(e24, this.state.pos);
                    const r7 = this.readEscapedChar(!0);
                    null === r7 ? s8 = !0 : t25 += r7, e24 = this.state.pos;
                } else if (y4(r6)) {
                    switch(t25 += this.input.slice(e24, this.state.pos), ++this.state.pos, r6){
                        case 13:
                            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                        case 10:
                            t25 += "\n";
                            break;
                        default:
                            t25 += String.fromCharCode(r6);
                    }
                    ++this.state.curLine, this.state.lineStart = this.state.pos, e24 = this.state.pos;
                } else ++this.state.pos;
            }
        }
        readEscapedChar(t) {
            const e24 = !t, s8 = this.input.charCodeAt(++this.state.pos);
            switch(++this.state.pos, s8){
                case 110:
                    return "\n";
                case 114:
                    return "\r";
                case 120:
                    {
                        const t25 = this.readHexChar(2, !1, e24);
                        return null === t25 ? null : String.fromCharCode(t25);
                    }
                case 117:
                    {
                        const t25 = this.readCodePoint(e24);
                        return null === t25 ? null : String.fromCodePoint(t25);
                    }
                case 116:
                    return "\t";
                case 98:
                    return "\b";
                case 118:
                    return "\v";
                case 102:
                    return "\f";
                case 13:
                    10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                case 10:
                    this.state.lineStart = this.state.pos, ++this.state.curLine;
                case 8232:
                case 8233:
                    return "";
                case 56:
                case 57:
                    if (t) return null;
                    this.state.strict && this.raise(this.state.pos - 1, g4.StrictNumericEscape);
                default:
                    if (s8 >= 48 && s8 <= 55) {
                        const e25 = this.state.pos - 1;
                        let s9 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r6 = parseInt(s9, 8);
                        r6 > 255 && (s9 = s9.slice(0, -1), r6 = parseInt(s9, 8)), this.state.pos += s9.length - 1;
                        const i6 = this.input.charCodeAt(this.state.pos);
                        if ("0" !== s9 || 56 === i6 || 57 === i6) {
                            if (t) return null;
                            this.state.strict ? this.raise(e25, g4.StrictNumericEscape) : this.state.octalPositions.push(e25);
                        }
                        return String.fromCharCode(r6);
                    }
                    return String.fromCharCode(s8);
            }
        }
        readHexChar(t, e, s) {
            const r6 = this.state.pos, i6 = this.readInt(16, t, e, !1);
            return null === i6 && (s ? this.raise(r6, g4.InvalidEscapeSequence) : this.state.pos = r6 - 1), i6;
        }
        readWord1() {
            let t25 = "";
            this.state.containsEsc = !1;
            const e24 = this.state.pos;
            let s8 = this.state.pos;
            for(; this.state.pos < this.length;){
                const r6 = this.input.codePointAt(this.state.pos);
                if (O3(r6)) this.state.pos += r6 <= 65535 ? 1 : 2;
                else if (this.state.isIterator && 64 === r6) ++this.state.pos;
                else {
                    if (92 !== r6) break;
                    {
                        this.state.containsEsc = !0, t25 += this.input.slice(s8, this.state.pos);
                        const r7 = this.state.pos, i6 = this.state.pos === e24 ? L2 : O3;
                        if (117 !== this.input.charCodeAt(++this.state.pos)) {
                            this.raise(this.state.pos, g4.MissingUnicodeEscape);
                            continue;
                        }
                        ++this.state.pos;
                        const n6 = this.readCodePoint(!0);
                        null !== n6 && (i6(n6) || this.raise(r7, g4.EscapedCharNotAnIdentifier), t25 += String.fromCodePoint(n6)), s8 = this.state.pos;
                    }
                }
            }
            return t25 + this.input.slice(s8, this.state.pos);
        }
        isIterator(t) {
            return "@@iterator" === t || "@@asyncIterator" === t;
        }
        readWord() {
            const t25 = this.readWord1(), e24 = o4.get(t25) || c4.name;
            !this.state.isIterator || this.isIterator(t25) && this.state.inType || this.raise(this.state.pos, g4.InvalidIdentifier, t25), this.finishToken(e24, t25);
        }
        checkKeywordEscapes() {
            const t25 = this.state.type.keyword;
            t25 && this.state.containsEsc && this.raise(this.state.start, g4.InvalidEscapedReservedWord, t25);
        }
        braceIsBlock(t) {
            const e24 = this.curContext();
            return e24 === T4.functionExpression || e24 === T4.functionStatement || (t !== c4.colon || e24 !== T4.braceStatement && e24 !== T4.braceExpression ? t === c4._return || t === c4.name && this.state.exprAllowed ? this.hasPrecedingLineBreak() : t === c4._else || t === c4.semi || t === c4.eof || t === c4.parenR || t === c4.arrow || (t === c4.braceL ? e24 === T4.braceStatement : t !== c4._var && t !== c4._const && t !== c4.name && (t === c4.relational || !this.state.exprAllowed)) : !e24.isExpr);
        }
        updateContext(t) {
            const e24 = this.state.type;
            let s8;
            !e24.keyword || t !== c4.dot && t !== c4.questionDot ? (s8 = e24.updateContext) ? s8.call(this, t) : this.state.exprAllowed = e24.beforeExpr : this.state.exprAllowed = !1;
        }
    } {
        addExtra(t, e, s) {
            if (!t) return;
            (t.extra = t.extra || {
            })[e] = s;
        }
        isRelational(t) {
            return this.match(c4.relational) && this.state.value === t;
        }
        expectRelational(t) {
            this.isRelational(t) ? this.next() : this.unexpected(null, c4.relational);
        }
        isContextual(t) {
            return this.match(c4.name) && this.state.value === t && !this.state.containsEsc;
        }
        isUnparsedContextual(t, e) {
            const s8 = t + e.length;
            return this.input.slice(t, s8) === e && (s8 === this.input.length || !O3(this.input.charCodeAt(s8)));
        }
        isLookaheadContextual(t) {
            const e24 = this.nextTokenStart();
            return this.isUnparsedContextual(e24, t);
        }
        eatContextual(t) {
            return this.isContextual(t) && this.eat(c4.name);
        }
        expectContextual(t, e) {
            this.eatContextual(t) || this.unexpected(null, e);
        }
        canInsertSemicolon() {
            return this.match(c4.eof) || this.match(c4.braceR) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
            return m4.test(this.input.slice(this.state.lastTokEnd, this.state.start));
        }
        isLineTerminator() {
            return this.eat(c4.semi) || this.canInsertSemicolon();
        }
        semicolon() {
            this.isLineTerminator() || this.unexpected(null, c4.semi);
        }
        expect(t, e) {
            this.eat(t) || this.unexpected(e, t);
        }
        assertNoSpace(t = "Unexpected space.") {
            this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, t);
        }
        unexpected(t, e = "Unexpected token") {
            throw "string" != typeof e && (e = 'Unexpected token, expected "'.concat(e.label, '"')), this.raise(null != t ? t : this.state.start, e);
        }
        expectPlugin(t, e) {
            if (!this.hasPlugin(t)) throw this.raiseWithData(null != e ? e : this.state.start, {
                missingPlugin: [
                    t
                ]
            }, "This experimental syntax requires enabling the parser plugin: '".concat(t, "'"));
            return !0;
        }
        expectOnePlugin(t, e) {
            if (!t.some((t25)=>this.hasPlugin(t25)
            )) throw this.raiseWithData(null != e ? e : this.state.start, {
                missingPlugin: t
            }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t.join(", "), "'"));
        }
        tryParse(t, e = this.state.clone()) {
            const s8 = {
                node: null
            };
            try {
                const r6 = t((t25 = null)=>{
                    throw s8.node = t25, s8;
                });
                if (this.state.errors.length > e.errors.length) {
                    const t25 = this.state;
                    return this.state = e, {
                        node: r6,
                        error: t25.errors[e.errors.length],
                        thrown: !1,
                        aborted: !1,
                        failState: t25
                    };
                }
                return {
                    node: r6,
                    error: null,
                    thrown: !1,
                    aborted: !1,
                    failState: null
                };
            } catch (t) {
                const r7 = this.state;
                if (this.state = e, t instanceof SyntaxError) return {
                    node: null,
                    error: t,
                    thrown: !0,
                    aborted: !1,
                    failState: r7
                };
                if (t === s8) return {
                    node: s8.node,
                    error: null,
                    thrown: !1,
                    aborted: !0,
                    failState: r7
                };
                throw t;
            }
        }
        checkExpressionErrors(t, e) {
            if (!t) return !1;
            const { shorthandAssign: s8 , doubleProto: r6  } = t;
            if (!e) return s8 >= 0 || r6 >= 0;
            s8 >= 0 && this.unexpected(s8), r6 >= 0 && this.raise(r6, g4.DuplicateProto);
        }
        isLiteralPropertyName() {
            return this.match(c4.name) || !!this.state.type.keyword || this.match(c4.string) || this.match(c4.num) || this.match(c4.bigint) || this.match(c4.decimal);
        }
    } {
        startNode() {
            return new Bt3(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(t, e) {
            return new Bt3(this, t, e);
        }
        startNodeAtNode(t) {
            return this.startNodeAt(t.start, t.loc.start);
        }
        finishNode(t, e) {
            return this.finishNodeAt(t, e, this.state.lastTokEnd, this.state.lastTokEndLoc);
        }
        finishNodeAt(t, e, s, r) {
            return t.type = e, t.end = s, t.loc.end = r, this.options.ranges && (t.range[1] = s), this.processComment(t), t;
        }
        resetStartLocation(t, e, s) {
            t.start = e, t.loc.start = s, this.options.ranges && (t.range[0] = e);
        }
        resetEndLocation(t, e = this.state.lastTokEnd, s = this.state.lastTokEndLoc) {
            t.end = e, t.loc.end = s, this.options.ranges && (t.range[1] = e);
        }
        resetStartLocationFromNode(t, e) {
            this.resetStartLocation(t, e.start, e.loc.start);
        }
    } {
        toAssignable(t) {
            var e24, s8;
            let r6 = void 0;
            switch(("ParenthesizedExpression" === t.type || (null == (e24 = t.extra) ? void 0 : e24.parenthesized)) && (r6 = St2(t), "Identifier" !== r6.type && "MemberExpression" !== r6.type && this.raise(t.start, g4.InvalidParenthesizedAssignment)), t.type){
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern": break;
                case "ObjectExpression":
                    t.type = "ObjectPattern";
                    for(let e25 = 0, s9 = t.properties.length, r7 = s9 - 1; e25 < s9; e25++){
                        var i6;
                        const s9 = t.properties[e25], n6 = e25 === r7;
                        this.toAssignableObjectExpressionProp(s9, n6), n6 && "RestElement" === s9.type && (null == (i6 = t.extra) ? void 0 : i6.trailingComma) && this.raiseRestNotLast(t.extra.trailingComma);
                    }
                    break;
                case "ObjectProperty":
                    this.toAssignable(t.value);
                    break;
                case "SpreadElement":
                    {
                        this.checkToRestConversion(t), t.type = "RestElement";
                        const e26 = t.argument;
                        this.toAssignable(e26);
                        break;
                    }
                case "ArrayExpression":
                    t.type = "ArrayPattern", this.toAssignableList(t.elements, null == (s8 = t.extra) ? void 0 : s8.trailingComma);
                    break;
                case "AssignmentExpression":
                    "=" !== t.operator && this.raise(t.left.end, g4.MissingEqInAssignment), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left);
                    break;
                case "ParenthesizedExpression":
                    this.toAssignable(r6);
            }
            return t;
        }
        toAssignableObjectExpressionProp(t, e) {
            if ("ObjectMethod" === t.type) {
                const e24 = "get" === t.kind || "set" === t.kind ? g4.PatternHasAccessor : g4.PatternHasMethod;
                this.raise(t.key.start, e24);
            } else "SpreadElement" !== t.type || e ? this.toAssignable(t) : this.raiseRestNotLast(t.start);
        }
        toAssignableList(t, e) {
            let s8 = t.length;
            if (s8) {
                const r6 = t[s8 - 1];
                if ("RestElement" === (null == r6 ? void 0 : r6.type)) --s8;
                else if ("SpreadElement" === (null == r6 ? void 0 : r6.type)) {
                    r6.type = "RestElement";
                    const t25 = r6.argument;
                    this.toAssignable(t25), "Identifier" !== t25.type && "MemberExpression" !== t25.type && "ArrayPattern" !== t25.type && "ObjectPattern" !== t25.type && this.unexpected(t25.start), e && this.raiseTrailingCommaAfterRest(e), --s8;
                }
            }
            for(let e24 = 0; e24 < s8; e24++){
                const s9 = t[e24];
                s9 && (this.toAssignable(s9), "RestElement" === s9.type && this.raiseRestNotLast(s9.start));
            }
            return t;
        }
        toReferencedList(t, e) {
            return t;
        }
        toReferencedListDeep(t, e) {
            this.toReferencedList(t, e);
            for(let e24 = 0; e24 < t.length; e24++){
                const s8 = t[e24];
                "ArrayExpression" === (null == s8 ? void 0 : s8.type) && this.toReferencedListDeep(s8.elements);
            }
        }
        parseSpread(t, e) {
            const s8 = this.startNode();
            return this.next(), s8.argument = this.parseMaybeAssignAllowIn(t, void 0, e), this.finishNode(s8, "SpreadElement");
        }
        parseRestBinding() {
            const t25 = this.startNode();
            return this.next(), t25.argument = this.parseBindingAtom(), this.finishNode(t25, "RestElement");
        }
        parseBindingAtom() {
            switch(this.state.type){
                case c4.bracketL:
                    {
                        const t25 = this.startNode();
                        return this.next(), t25.elements = this.parseBindingList(c4.bracketR, 93, !0), this.finishNode(t25, "ArrayPattern");
                    }
                case c4.braceL:
                    return this.parseObjectLike(c4.braceR, !0);
            }
            return this.parseIdentifier();
        }
        parseBindingList(t, e, s, r) {
            const i6 = [];
            let n6 = !0;
            for(; !this.eat(t);)if (n6 ? n6 = !1 : this.expect(c4.comma), s && this.match(c4.comma)) i6.push(null);
            else {
                if (this.eat(t)) break;
                if (this.match(c4.ellipsis)) {
                    i6.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e), this.expect(t);
                    break;
                }
                {
                    const t25 = [];
                    for(this.match(c4.at) && this.hasPlugin("decorators") && this.raise(this.state.start, g4.UnsupportedParameterDecorator); this.match(c4.at);)t25.push(this.parseDecorator());
                    i6.push(this.parseAssignableListItem(r, t25));
                }
            }
            return i6;
        }
        parseAssignableListItem(t, e) {
            const s8 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s8);
            const r6 = this.parseMaybeDefault(s8.start, s8.loc.start, s8);
            return e.length && (s8.decorators = e), r6;
        }
        parseAssignableListItemTypes(t) {
            return t;
        }
        parseMaybeDefault(t, e, s) {
            var r6, i6, n6;
            if (e = null != (r6 = e) ? r6 : this.state.startLoc, t = null != (i6 = t) ? i6 : this.state.start, s = null != (n6 = s) ? n6 : this.parseBindingAtom(), !this.eat(c4.eq)) return s;
            const a5 = this.startNodeAt(t, e);
            return a5.left = s, a5.right = this.parseMaybeAssignAllowIn(), this.finishNode(a5, "AssignmentPattern");
        }
        checkLVal(t, e = 64, s, r, i, n = !1) {
            switch(t.type){
                case "Identifier":
                    if (this.state.strict && (n ? H4(t.name, this.inModule) : z3(t.name)) && this.raise(t.start, e === 64 ? g4.StrictEvalArguments : g4.StrictEvalArgumentsBinding, t.name), s) {
                        const e24 = "_".concat(t.name);
                        s[e24] ? this.raise(t.start, g4.ParamDupe) : s[e24] = !0;
                    }
                    i && "let" === t.name && this.raise(t.start, g4.LetInLexicalBinding), e & 64 || this.scope.declareName(t.name, e, t.start);
                    break;
                case "MemberExpression":
                    e !== 64 && this.raise(t.start, g4.InvalidPropertyBindingPattern);
                    break;
                case "ObjectPattern":
                    for(let r6 = 0, n6 = t.properties; r6 < n6.length; r6++){
                        let t25 = n6[r6];
                        if ("ObjectProperty" === t25.type) t25 = t25.value;
                        else if ("ObjectMethod" === t25.type) continue;
                        this.checkLVal(t25, e, s, "object destructuring pattern", i);
                    }
                    break;
                case "ArrayPattern":
                    for(let r7 = 0, n7 = t.elements; r7 < n7.length; r7++){
                        const t25 = n7[r7];
                        t25 && this.checkLVal(t25, e, s, "array destructuring pattern", i);
                    }
                    break;
                case "AssignmentPattern":
                    this.checkLVal(t.left, e, s, "assignment pattern");
                    break;
                case "RestElement":
                    this.checkLVal(t.argument, e, s, "rest element");
                    break;
                case "ParenthesizedExpression":
                    this.checkLVal(t.expression, e, s, "parenthesized expression");
                    break;
                default:
                    this.raise(t.start, e === 64 ? g4.InvalidLhs : g4.InvalidLhsBinding, r);
            }
        }
        checkToRestConversion(t) {
            "Identifier" !== t.argument.type && "MemberExpression" !== t.argument.type && this.raise(t.argument.start, g4.InvalidRestAssignmentPattern);
        }
        checkCommaAfterRest(t) {
            this.match(c4.comma) && (this.lookaheadCharCode() === t ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
        }
        raiseRestNotLast(t) {
            throw this.raise(t, g4.ElementAfterRest);
        }
        raiseTrailingCommaAfterRest(t) {
            this.raise(t, g4.RestTrailingComma);
        }
    } {
        checkProto(t, e, s, r) {
            if ("SpreadElement" === t.type || "ObjectMethod" === t.type || t.computed || t.shorthand) return;
            const i6 = t.key;
            if ("__proto__" === ("Identifier" === i6.type ? i6.name : i6.value)) {
                if (e) return void this.raise(i6.start, g4.RecordNoProto);
                s.used && (r ? -1 === r.doubleProto && (r.doubleProto = i6.start) : this.raise(i6.start, g4.DuplicateProto)), s.used = !0;
            }
        }
        shouldExitDescending(t, e) {
            return "ArrowFunctionExpression" === t.type && t.start === e;
        }
        getExpression() {
            let t25 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t25 |= 2), this.scope.enter(1), this.prodParam.enter(t25), this.nextToken();
            const e24 = this.parseExpression();
            return this.match(c4.eof) || this.unexpected(), e24.comments = this.state.comments, e24.errors = this.state.errors, e24;
        }
        parseExpression(t, e) {
            return t ? this.disallowInAnd(()=>this.parseExpressionBase(e)
            ) : this.allowInAnd(()=>this.parseExpressionBase(e)
            );
        }
        parseExpressionBase(t) {
            const e24 = this.state.start, s8 = this.state.startLoc, r6 = this.parseMaybeAssign(t);
            if (this.match(c4.comma)) {
                const i6 = this.startNodeAt(e24, s8);
                for(i6.expressions = [
                    r6
                ]; this.eat(c4.comma);)i6.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(i6.expressions), this.finishNode(i6, "SequenceExpression");
            }
            return r6;
        }
        parseMaybeAssignDisallowIn(t, e, s) {
            return this.disallowInAnd(()=>this.parseMaybeAssign(t, e, s)
            );
        }
        parseMaybeAssignAllowIn(t, e, s) {
            return this.allowInAnd(()=>this.parseMaybeAssign(t, e, s)
            );
        }
        parseMaybeAssign(t, e, s) {
            const r6 = this.state.start, i6 = this.state.startLoc;
            if (this.isContextual("yield") && this.prodParam.hasYield) {
                this.state.exprAllowed = !0;
                let t25 = this.parseYield();
                return e && (t25 = e.call(this, t25, r6, i6)), t25;
            }
            let n6;
            t ? n6 = !1 : (t = new wt2, n6 = !0), (this.match(c4.parenL) || this.match(c4.name)) && (this.state.potentialArrowAt = this.state.start);
            let a5 = this.parseMaybeConditional(t, s);
            if (e && (a5 = e.call(this, a5, r6, i6)), this.state.type.isAssign) {
                const e24 = this.startNodeAt(r6, i6), s8 = this.state.value;
                return e24.operator = s8, this.match(c4.eq) ? (e24.left = this.toAssignable(a5), t.doubleProto = -1) : e24.left = a5, t.shorthandAssign >= e24.left.start && (t.shorthandAssign = -1), this.checkLVal(a5, void 0, void 0, "assignment expression"), this.next(), e24.right = this.parseMaybeAssign(), this.finishNode(e24, "AssignmentExpression");
            }
            return n6 && this.checkExpressionErrors(t, !0), a5;
        }
        parseMaybeConditional(t, e) {
            const s8 = this.state.start, r6 = this.state.startLoc, i6 = this.state.potentialArrowAt, n6 = this.parseExprOps(t);
            return this.shouldExitDescending(n6, i6) ? n6 : this.parseConditional(n6, s8, r6, e);
        }
        parseConditional(t, e, s, r) {
            if (this.eat(c4.question)) {
                const r6 = this.startNodeAt(e, s);
                return r6.test = t, r6.consequent = this.parseMaybeAssignAllowIn(), this.expect(c4.colon), r6.alternate = this.parseMaybeAssign(), this.finishNode(r6, "ConditionalExpression");
            }
            return t;
        }
        parseExprOps(t) {
            const e24 = this.state.start, s8 = this.state.startLoc, r6 = this.state.potentialArrowAt, i6 = this.parseMaybeUnary(t);
            return this.shouldExitDescending(i6, r6) ? i6 : this.parseExprOp(i6, e24, s8, -1);
        }
        parseExprOp(t, e, s, r) {
            let i6 = this.state.type.binop;
            if (null != i6 && (this.prodParam.hasIn || !this.match(c4._in)) && i6 > r) {
                const n6 = this.state.type;
                if (n6 === c4.pipeline) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                    this.state.inPipeline = !0, this.checkPipelineAtInfixOperator(t, e);
                }
                const a5 = this.startNodeAt(e, s);
                a5.left = t, a5.operator = this.state.value, n6 !== c4.exponent || "UnaryExpression" !== t.type || !this.options.createParenthesizedExpressions && t.extra && t.extra.parenthesized || this.raise(t.argument.start, g4.UnexpectedTokenUnaryExponentiation);
                const o5 = n6 === c4.logicalOR || n6 === c4.logicalAND, u5 = n6 === c4.nullishCoalescing;
                if (u5 && (i6 = c4.logicalAND.binop), this.next(), n6 === c4.pipeline && "minimal" === this.getPluginOption("pipelineOperator", "proposal") && this.match(c4.name) && "await" === this.state.value && this.prodParam.hasAwait) throw this.raise(this.state.start, g4.UnexpectedAwaitAfterPipelineBody);
                a5.right = this.parseExprOpRightExpr(n6, i6), this.finishNode(a5, o5 || u5 ? "LogicalExpression" : "BinaryExpression");
                const h5 = this.state.type;
                if (u5 && (h5 === c4.logicalOR || h5 === c4.logicalAND) || o5 && h5 === c4.nullishCoalescing) throw this.raise(this.state.start, g4.MixingCoalesceWithLogical);
                return this.parseExprOp(a5, e, s, r);
            }
            return t;
        }
        parseExprOpRightExpr(t, e) {
            const s8 = this.state.start, r6 = this.state.startLoc;
            switch(t){
                case c4.pipeline:
                    switch(this.getPluginOption("pipelineOperator", "proposal")){
                        case "smart":
                            return this.withTopicPermittingContext(()=>this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t, e), s8, r6)
                            );
                        case "fsharp":
                            return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(e)
                            );
                    }
                default:
                    return this.parseExprOpBaseRightExpr(t, e);
            }
        }
        parseExprOpBaseRightExpr(t, e) {
            const s8 = this.state.start, r6 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnary(), s8, r6, t.rightAssociative ? e - 1 : e);
        }
        parseMaybeUnary(t) {
            if (this.isContextual("await") && this.isAwaitAllowed()) return this.parseAwait();
            const e24 = this.match(c4.incDec), s8 = this.startNode();
            if (this.state.type.prefix) {
                s8.operator = this.state.value, s8.prefix = !0, this.match(c4._throw) && this.expectPlugin("throwExpressions");
                const r6 = this.match(c4._delete);
                if (this.next(), s8.argument = this.parseMaybeUnary(), this.checkExpressionErrors(t, !0), this.state.strict && r6) {
                    const t25 = s8.argument;
                    "Identifier" === t25.type ? this.raise(s8.start, g4.StrictDelete) : "MemberExpression" !== t25.type && "OptionalMemberExpression" !== t25.type || "PrivateName" !== t25.property.type || this.raise(s8.start, g4.DeletePrivateField);
                }
                if (!e24) return this.finishNode(s8, "UnaryExpression");
            }
            return this.parseUpdate(s8, e24, t);
        }
        parseUpdate(t, e, s) {
            if (e) return this.checkLVal(t.argument, void 0, void 0, "prefix operation"), this.finishNode(t, "UpdateExpression");
            const r6 = this.state.start, i6 = this.state.startLoc;
            let n6 = this.parseExprSubscripts(s);
            if (this.checkExpressionErrors(s, !1)) return n6;
            for(; this.state.type.postfix && !this.canInsertSemicolon();){
                const t25 = this.startNodeAt(r6, i6);
                t25.operator = this.state.value, t25.prefix = !1, t25.argument = n6, this.checkLVal(n6, void 0, void 0, "postfix operation"), this.next(), n6 = this.finishNode(t25, "UpdateExpression");
            }
            return n6;
        }
        parseExprSubscripts(t) {
            const e24 = this.state.start, s8 = this.state.startLoc, r6 = this.state.potentialArrowAt, i6 = this.parseExprAtom(t);
            return this.shouldExitDescending(i6, r6) ? i6 : this.parseSubscripts(i6, e24, s8);
        }
        parseSubscripts(t, e, s, r) {
            const i6 = {
                optionalChainMember: !1,
                maybeAsyncArrow: this.atPossibleAsyncArrow(t),
                stop: !1
            };
            do {
                t = this.parseSubscript(t, e, s, r, i6), i6.maybeAsyncArrow = !1;
            }while (!i6.stop)
            return t;
        }
        parseSubscript(t, e, s, r, i) {
            if (!r && this.eat(c4.doubleColon)) return this.parseBind(t, e, s, r, i);
            if (this.match(c4.backQuote)) return this.parseTaggedTemplateExpression(t, e, s, i);
            let n6 = !1;
            if (this.match(c4.questionDot)) {
                if (i.optionalChainMember = n6 = !0, r && 40 === this.lookaheadCharCode()) return i.stop = !0, t;
                this.next();
            }
            return !r && this.match(c4.parenL) ? this.parseCoverCallAndAsyncArrowHead(t, e, s, i, n6) : n6 || this.match(c4.bracketL) || this.eat(c4.dot) ? this.parseMember(t, e, s, i, n6) : (i.stop = !0, t);
        }
        parseMember(t, e, s, r, i) {
            const n6 = this.startNodeAt(e, s), a5 = this.eat(c4.bracketL);
            n6.object = t, n6.computed = a5;
            const o5 = a5 ? this.parseExpression() : this.parseMaybePrivateName(!0);
            return "PrivateName" === o5.type && ("Super" === n6.object.type && this.raise(e, g4.SuperPrivateField), this.classScope.usePrivateName(o5.id.name, o5.start)), n6.property = o5, a5 && this.expect(c4.bracketR), r.optionalChainMember ? (n6.optional = i, this.finishNode(n6, "OptionalMemberExpression")) : this.finishNode(n6, "MemberExpression");
        }
        parseBind(t, e, s, r, i) {
            const n6 = this.startNodeAt(e, s);
            return n6.object = t, n6.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(n6, "BindExpression"), e, s, r);
        }
        parseCoverCallAndAsyncArrowHead(t, e, s, r, i) {
            const n6 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0, this.next();
            let a5 = this.startNodeAt(e, s);
            return a5.callee = t, r.maybeAsyncArrow && this.expressionScope.enter(new It3(2)), r.optionalChainMember && (a5.optional = i), a5.arguments = i ? this.parseCallExpressionArguments(c4.parenR, !1) : this.parseCallExpressionArguments(c4.parenR, r.maybeAsyncArrow, "Import" === t.type, "Super" !== t.type, a5), this.finishCallExpression(a5, r.optionalChainMember), r.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i ? (r.stop = !0, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), a5 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), a5)) : (r.maybeAsyncArrow && this.expressionScope.exit(), this.toReferencedArguments(a5)), this.state.maybeInArrowParameters = n6, a5;
        }
        toReferencedArguments(t, e) {
            this.toReferencedListDeep(t.arguments, e);
        }
        parseTaggedTemplateExpression(t, e, s, r) {
            const i6 = this.startNodeAt(e, s);
            return i6.tag = t, i6.quasi = this.parseTemplate(!0), r.optionalChainMember && this.raise(e, g4.OptionalChainingNoTemplate), this.finishNode(i6, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(t) {
            return "Identifier" === t.type && "async" === t.name && this.state.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && t.start === this.state.potentialArrowAt;
        }
        finishCallExpression(t, e) {
            if ("Import" === t.callee.type) {
                if (2 === t.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), 0 === t.arguments.length || t.arguments.length > 2) this.raise(t.start, g4.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
                else for(let e24 = 0, s8 = t.arguments; e24 < s8.length; e24++){
                    const t25 = s8[e24];
                    "SpreadElement" === t25.type && this.raise(t25.start, g4.ImportCallSpreadArgument);
                }
            }
            return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(t, e, s, r, i) {
            const n6 = [];
            let a5, o5 = !0;
            const u5 = this.state.inFSharpPipelineDirectBody;
            for(this.state.inFSharpPipelineDirectBody = !1; !this.eat(t);){
                if (o5) o5 = !1;
                else if (this.expect(c4.comma), this.match(t)) {
                    !s || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, g4.ImportCallArgumentTrailingComma), i && this.addExtra(i, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                }
                this.match(c4.parenL) && !a5 && (a5 = this.state.start), n6.push(this.parseExprListItem(!1, e ? new wt2 : void 0, e ? {
                    start: 0
                } : void 0, r));
            }
            return e && a5 && this.shouldParseAsyncArrow() && this.unexpected(), this.state.inFSharpPipelineDirectBody = u5, n6;
        }
        shouldParseAsyncArrow() {
            return this.match(c4.arrow) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(t, e) {
            var s8;
            return this.expect(c4.arrow), this.parseArrowExpression(t, e.arguments, !0, null == (s8 = e.extra) ? void 0 : s8.trailingComma), t;
        }
        parseNoCallExpr() {
            const t25 = this.state.start, e24 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t25, e24, !0);
        }
        parseExprAtom(t) {
            this.state.type === c4.slash && this.readRegexp();
            const e24 = this.state.potentialArrowAt === this.state.start;
            let s8;
            switch(this.state.type){
                case c4._super:
                    return this.parseSuper();
                case c4._import:
                    return s8 = this.startNode(), this.next(), this.match(c4.dot) ? this.parseImportMetaProperty(s8) : (this.match(c4.parenL) || this.raise(this.state.lastTokStart, g4.UnsupportedImport), this.finishNode(s8, "Import"));
                case c4._this:
                    return s8 = this.startNode(), this.next(), this.finishNode(s8, "ThisExpression");
                case c4.name:
                    {
                        const t25 = this.state.containsEsc, s9 = this.parseIdentifier();
                        if (!t25 && "async" === s9.name && !this.canInsertSemicolon()) {
                            if (this.match(c4._function)) {
                                const t26 = this.state.context.length - 1;
                                if (this.state.context[t26] !== T4.functionStatement) throw new Error("Internal error");
                                return this.state.context[t26] = T4.functionExpression, this.next(), this.parseFunction(this.startNodeAtNode(s9), void 0, !0);
                            }
                            if (this.match(c4.name)) return this.parseAsyncArrowUnaryFunction(s9);
                        }
                        return e24 && this.match(c4.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s9), [
                            s9
                        ], !1)) : s9;
                    }
                case c4._do:
                    return this.parseDo();
                case c4.regexp:
                    {
                        const t25 = this.state.value;
                        return s8 = this.parseLiteral(t25.value, "RegExpLiteral"), s8.pattern = t25.pattern, s8.flags = t25.flags, s8;
                    }
                case c4.num:
                    return this.parseLiteral(this.state.value, "NumericLiteral");
                case c4.bigint:
                    return this.parseLiteral(this.state.value, "BigIntLiteral");
                case c4.decimal:
                    return this.parseLiteral(this.state.value, "DecimalLiteral");
                case c4.string:
                    return this.parseLiteral(this.state.value, "StringLiteral");
                case c4._null:
                    return s8 = this.startNode(), this.next(), this.finishNode(s8, "NullLiteral");
                case c4._true:
                case c4._false:
                    return this.parseBooleanLiteral();
                case c4.parenL:
                    return this.parseParenAndDistinguishExpression(e24);
                case c4.bracketBarL:
                case c4.bracketHashL:
                    return this.parseArrayLike(this.state.type === c4.bracketBarL ? c4.bracketBarR : c4.bracketR, !1, !0, t);
                case c4.bracketL:
                    return this.parseArrayLike(c4.bracketR, !0, !1, t);
                case c4.braceBarL:
                case c4.braceHashL:
                    return this.parseObjectLike(this.state.type === c4.braceBarL ? c4.braceBarR : c4.braceR, !1, !0, t);
                case c4.braceL:
                    return this.parseObjectLike(c4.braceR, !1, !1, t);
                case c4._function:
                    return this.parseFunctionOrFunctionSent();
                case c4.at:
                    this.parseDecorators();
                case c4._class:
                    return s8 = this.startNode(), this.takeDecorators(s8), this.parseClass(s8, !1);
                case c4._new:
                    return this.parseNewOrNewTarget();
                case c4.backQuote:
                    return this.parseTemplate(!1);
                case c4.doubleColon:
                    {
                        s8 = this.startNode(), this.next(), s8.object = null;
                        const t25 = s8.callee = this.parseNoCallExpr();
                        if ("MemberExpression" === t25.type) return this.finishNode(s8, "BindExpression");
                        throw this.raise(t25.start, g4.UnsupportedBind);
                    }
                case c4.hash:
                    {
                        if (this.state.inPipeline) return s8 = this.startNode(), "smart" !== this.getPluginOption("pipelineOperator", "proposal") && this.raise(s8.start, g4.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(s8.start, g4.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(s8, "PipelinePrimaryTopicReference");
                        const t25 = this.input.codePointAt(this.state.end);
                        if (L2(t25) || 92 === t25) {
                            const t26 = this.state.start;
                            if (s8 = this.parseMaybePrivateName(!0), this.match(c4._in)) this.expectPlugin("privateIn"), this.classScope.usePrivateName(s8.id.name, s8.start);
                            else {
                                if (!this.hasPlugin("privateIn")) throw this.unexpected(t26);
                                this.raise(this.state.start, g4.PrivateInExpectedIn, s8.id.name);
                            }
                            return s8;
                        }
                    }
                case c4.relational:
                    if ("<" === this.state.value) {
                        const t25 = this.input.codePointAt(this.nextTokenStart());
                        (L2(t25) || 62 === t25) && this.expectOnePlugin([
                            "jsx",
                            "flow",
                            "typescript"
                        ]);
                    }
                default:
                    throw this.unexpected();
            }
        }
        parseAsyncArrowUnaryFunction(t) {
            const e24 = this.startNodeAtNode(t);
            this.prodParam.enter(ct2(!0, this.prodParam.hasYield));
            const s8 = [
                this.parseIdentifier()
            ];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, g4.LineTerminatorBeforeArrow), this.expect(c4.arrow), this.parseArrowExpression(e24, s8, !0), e24;
        }
        parseDo() {
            this.expectPlugin("doExpressions");
            const t25 = this.startNode();
            this.next();
            const e24 = this.state.labels;
            return this.state.labels = [], t25.body = this.parseBlock(), this.state.labels = e24, this.finishNode(t25, "DoExpression");
        }
        parseSuper() {
            const t25 = this.startNode();
            return this.next(), !this.match(c4.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t25.start, g4.UnexpectedSuper) : this.raise(t25.start, g4.SuperNotAllowed), this.match(c4.parenL) || this.match(c4.bracketL) || this.match(c4.dot) || this.raise(t25.start, g4.UnsupportedSuper), this.finishNode(t25, "Super");
        }
        parseBooleanLiteral() {
            const t25 = this.startNode();
            return t25.value = this.match(c4._true), this.next(), this.finishNode(t25, "BooleanLiteral");
        }
        parseMaybePrivateName(t) {
            if (this.match(c4.hash)) {
                this.expectOnePlugin([
                    "classPrivateProperties",
                    "classPrivateMethods"
                ]), t || this.raise(this.state.pos, g4.UnexpectedPrivateField);
                const e24 = this.startNode();
                return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), e24.id = this.parseIdentifier(!0), this.finishNode(e24, "PrivateName");
            }
            return this.parseIdentifier(!0);
        }
        parseFunctionOrFunctionSent() {
            const t25 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(c4.dot)) {
                const e24 = this.createIdentifier(this.startNodeAtNode(t25), "function");
                return this.next(), this.parseMetaProperty(t25, e24, "sent");
            }
            return this.parseFunction(t25);
        }
        parseMetaProperty(t, e, s) {
            t.meta = e, "function" === e.name && "sent" === s && (this.isContextual(s) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
            const r6 = this.state.containsEsc;
            return t.property = this.parseIdentifier(!0), (t.property.name !== s || r6) && this.raise(t.property.start, g4.UnsupportedMetaProperty, e.name, s), this.finishNode(t, "MetaProperty");
        }
        parseImportMetaProperty(t) {
            const e24 = this.createIdentifier(this.startNodeAtNode(t), "import");
            return this.next(), this.isContextual("meta") && (this.inModule || this.raiseWithData(e24.start, {
                code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            }, g4.ImportMetaOutsideModule), this.sawUnambiguousESM = !0), this.parseMetaProperty(t, e24, "meta");
        }
        parseLiteral(t, e, s, r) {
            s = s || this.state.start, r = r || this.state.startLoc;
            const i6 = this.startNodeAt(s, r);
            return this.addExtra(i6, "rawValue", t), this.addExtra(i6, "raw", this.input.slice(s, this.state.end)), i6.value = t, this.next(), this.finishNode(i6, e);
        }
        parseParenAndDistinguishExpression(t) {
            const e24 = this.state.start, s8 = this.state.startLoc;
            let r6;
            this.next(), this.expressionScope.enter(new It3(1));
            const i6 = this.state.maybeInArrowParameters, n6 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
            const a5 = this.state.start, o5 = this.state.startLoc, u5 = [], h5 = new wt2, p5 = {
                start: 0
            };
            let l5, d5, D5 = !0;
            for(; !this.match(c4.parenR);){
                if (D5) D5 = !1;
                else if (this.expect(c4.comma, p5.start || null), this.match(c4.parenR)) {
                    d5 = this.state.start;
                    break;
                }
                if (this.match(c4.ellipsis)) {
                    const t25 = this.state.start, e25 = this.state.startLoc;
                    l5 = this.state.start, u5.push(this.parseParenItem(this.parseRestBinding(), t25, e25)), this.checkCommaAfterRest(41);
                    break;
                }
                u5.push(this.parseMaybeAssignAllowIn(h5, this.parseParenItem, p5));
            }
            const m5 = this.state.lastTokEnd, f5 = this.state.lastTokEndLoc;
            this.expect(c4.parenR), this.state.maybeInArrowParameters = i6, this.state.inFSharpPipelineDirectBody = n6;
            let y5 = this.startNodeAt(e24, s8);
            if (t && this.shouldParseArrow() && (y5 = this.parseArrow(y5))) {
                this.expressionScope.validateAsPattern(), this.expressionScope.exit();
                for(let t25 = 0; t25 < u5.length; t25++){
                    const e25 = u5[t25];
                    e25.extra && e25.extra.parenthesized && this.unexpected(e25.extra.parenStart);
                }
                return this.parseArrowExpression(y5, u5, !1), y5;
            }
            if (this.expressionScope.exit(), u5.length || this.unexpected(this.state.lastTokStart), d5 && this.unexpected(d5), l5 && this.unexpected(l5), this.checkExpressionErrors(h5, !0), p5.start && this.unexpected(p5.start), this.toReferencedListDeep(u5, !0), u5.length > 1 ? (r6 = this.startNodeAt(a5, o5), r6.expressions = u5, this.finishNodeAt(r6, "SequenceExpression", m5, f5)) : r6 = u5[0], !this.options.createParenthesizedExpressions) return this.addExtra(r6, "parenthesized", !0), this.addExtra(r6, "parenStart", e24), r6;
            const E5 = this.startNodeAt(e24, s8);
            return E5.expression = r6, this.finishNode(E5, "ParenthesizedExpression"), E5;
        }
        shouldParseArrow() {
            return !this.canInsertSemicolon();
        }
        parseArrow(t) {
            if (this.eat(c4.arrow)) return t;
        }
        parseParenItem(t, e, s) {
            return t;
        }
        parseNewOrNewTarget() {
            const t25 = this.startNode();
            if (this.next(), this.match(c4.dot)) {
                const e24 = this.createIdentifier(this.startNodeAtNode(t25), "new");
                this.next();
                const s8 = this.parseMetaProperty(t25, e24, "target");
                if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                    let t26 = g4.UnexpectedNewTarget;
                    this.hasPlugin("classProperties") && (t26 += " or class properties"), this.raise(s8.start, t26);
                }
                return s8;
            }
            return this.parseNew(t25);
        }
        parseNew(t) {
            return t.callee = this.parseNoCallExpr(), "Import" === t.callee.type ? this.raise(t.callee.start, g4.ImportCallNotNewExpression) : "OptionalMemberExpression" === t.callee.type || "OptionalCallExpression" === t.callee.type ? this.raise(this.state.lastTokEnd, g4.OptionalChainingNoNew) : this.eat(c4.questionDot) && this.raise(this.state.start, g4.OptionalChainingNoNew), this.parseNewArguments(t), this.finishNode(t, "NewExpression");
        }
        parseNewArguments(t) {
            if (this.eat(c4.parenL)) {
                const e24 = this.parseExprList(c4.parenR);
                this.toReferencedList(e24), t.arguments = e24;
            } else t.arguments = [];
        }
        parseTemplateElement(t) {
            const e24 = this.startNode();
            return null === this.state.value && (t || this.raise(this.state.start + 1, g4.InvalidEscapeSequenceTemplate)), e24.value = {
                raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
                cooked: this.state.value
            }, this.next(), e24.tail = this.match(c4.backQuote), this.finishNode(e24, "TemplateElement");
        }
        parseTemplate(t) {
            const e24 = this.startNode();
            this.next(), e24.expressions = [];
            let s8 = this.parseTemplateElement(t);
            for(e24.quasis = [
                s8
            ]; !s8.tail;)this.expect(c4.dollarBraceL), e24.expressions.push(this.parseTemplateSubstitution()), this.expect(c4.braceR), e24.quasis.push(s8 = this.parseTemplateElement(t));
            return this.next(), this.finishNode(e24, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
            return this.parseExpression();
        }
        parseObjectLike(t, e, s, r) {
            s && this.expectPlugin("recordAndTuple");
            const i6 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const n6 = Object.create(null);
            let a5 = !0;
            const o5 = this.startNode();
            for(o5.properties = [], this.next(); !this.match(t);){
                if (a5) a5 = !1;
                else if (this.expect(c4.comma), this.match(t)) {
                    this.addExtra(o5, "trailingComma", this.state.lastTokStart);
                    break;
                }
                const i7 = this.parsePropertyDefinition(e, r);
                e || this.checkProto(i7, s, n6, r), s && "ObjectProperty" !== i7.type && "SpreadElement" !== i7.type && this.raise(i7.start, g4.InvalidRecordProperty), i7.shorthand && this.addExtra(i7, "shorthand", !0), o5.properties.push(i7);
            }
            this.state.exprAllowed = !1, this.next(), this.state.inFSharpPipelineDirectBody = i6;
            let u5 = "ObjectExpression";
            return e ? u5 = "ObjectPattern" : s && (u5 = "RecordExpression"), this.finishNode(o5, u5);
        }
        maybeAsyncOrAccessorProp(t) {
            return !t.computed && "Identifier" === t.key.type && (this.isLiteralPropertyName() || this.match(c4.bracketL) || this.match(c4.star));
        }
        parsePropertyDefinition(t, e) {
            let s8 = [];
            if (this.match(c4.at)) for(this.hasPlugin("decorators") && this.raise(this.state.start, g4.UnsupportedPropertyDecorator); this.match(c4.at);)s8.push(this.parseDecorator());
            const r6 = this.startNode();
            let i6, n6, a5 = !1, o5 = !1, u5 = !1;
            if (this.match(c4.ellipsis)) return s8.length && this.unexpected(), t ? (this.next(), r6.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r6, "RestElement")) : this.parseSpread();
            s8.length && (r6.decorators = s8, s8 = []), r6.method = !1, (t || e) && (i6 = this.state.start, n6 = this.state.startLoc), t || (a5 = this.eat(c4.star));
            const h5 = this.state.containsEsc, p5 = this.parsePropertyName(r6, !1);
            if (!t && !a5 && !h5 && this.maybeAsyncOrAccessorProp(r6)) {
                const t25 = p5.name;
                "async" !== t25 || this.hasPrecedingLineBreak() || (o5 = !0, a5 = this.eat(c4.star), this.parsePropertyName(r6, !1)), "get" !== t25 && "set" !== t25 || (u5 = !0, r6.kind = t25, this.match(c4.star) && (a5 = !0, this.raise(this.state.pos, g4.AccessorIsGenerator, t25), this.next()), this.parsePropertyName(r6, !1));
            }
            return this.parseObjPropValue(r6, i6, n6, a5, o5, t, u5, e), r6;
        }
        getGetterSetterExpectedParamCount(t) {
            return "get" === t.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(t) {
            return t.params;
        }
        checkGetterSetterParams(t) {
            var e24;
            const s8 = this.getGetterSetterExpectedParamCount(t), r6 = this.getObjectOrClassMethodParams(t), i6 = t.start;
            r6.length !== s8 && ("get" === t.kind ? this.raise(i6, g4.BadGetterArity) : this.raise(i6, g4.BadSetterArity)), "set" === t.kind && "RestElement" === (null == (e24 = r6[r6.length - 1]) ? void 0 : e24.type) && this.raise(i6, g4.BadSetterRestParameter);
        }
        parseObjectMethod(t, e, s, r, i) {
            return i ? (this.parseMethod(t, e, !1, !1, !1, "ObjectMethod"), this.checkGetterSetterParams(t), t) : s || e || this.match(c4.parenL) ? (r && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, e, s, !1, !1, "ObjectMethod")) : void 0;
        }
        parseObjectProperty(t, e, s, r, i) {
            return t.shorthand = !1, this.eat(c4.colon) ? (t.value = r ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProperty")) : t.computed || "Identifier" !== t.key.type ? void 0 : (this.checkReservedWord(t.key.name, t.key.start, !0, !1), r ? t.value = this.parseMaybeDefault(e, s, t.key.__clone()) : this.match(c4.eq) && i ? (-1 === i.shorthandAssign && (i.shorthandAssign = this.state.start), t.value = this.parseMaybeDefault(e, s, t.key.__clone())) : t.value = t.key.__clone(), t.shorthand = !0, this.finishNode(t, "ObjectProperty"));
        }
        parseObjPropValue(t, e, s, r, i, n, a, o) {
            const u5 = this.parseObjectMethod(t, r, i, n, a) || this.parseObjectProperty(t, e, s, n, o);
            return u5 || this.unexpected(), u5;
        }
        parsePropertyName(t, e) {
            if (this.eat(c4.bracketL)) t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(c4.bracketR);
            else {
                const s8 = this.state.inPropertyName;
                this.state.inPropertyName = !0, t.key = this.match(c4.num) || this.match(c4.string) || this.match(c4.bigint) || this.match(c4.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(e), "PrivateName" !== t.key.type && (t.computed = !1), this.state.inPropertyName = s8;
            }
            return t.key;
        }
        initFunction(t, e) {
            t.id = null, t.generator = !1, t.async = !!e;
        }
        parseMethod(t, e, s, r, i, n, a = !1) {
            this.initFunction(t, s), t.generator = !!e;
            const o5 = r;
            return this.scope.enter(18 | (a ? 64 : 0) | (i ? 32 : 0)), this.prodParam.enter(ct2(s, t.generator)), this.parseFunctionParams(t, r), this.parseFunctionBodyAndFinish(t, n, !0), this.prodParam.exit(), this.scope.exit(), t;
        }
        parseArrayLike(t, e, s, r) {
            s && this.expectPlugin("recordAndTuple");
            const i6 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const n6 = this.startNode();
            return this.next(), n6.elements = this.parseExprList(t, !s, r, n6), this.state.inFSharpPipelineDirectBody = i6, this.finishNode(n6, s ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(t, e, s, r) {
            this.scope.enter(6);
            let i6 = ct2(s, !1);
            !this.match(c4.bracketL) && this.prodParam.hasIn && (i6 |= 8), this.prodParam.enter(i6), this.initFunction(t, s);
            const n6 = this.state.maybeInArrowParameters;
            return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, r)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n6, this.finishNode(t, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(t, e, s) {
            t.params = this.toAssignableList(e, s);
        }
        parseFunctionBodyAndFinish(t, e, s = !1) {
            this.parseFunctionBody(t, !1, s), this.finishNode(t, e);
        }
        parseFunctionBody(t, e, s = !1) {
            const r6 = e && !this.match(c4.braceL);
            if (this.expressionScope.enter(kt2()), r6) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1);
            else {
                const r7 = this.state.strict, i6 = this.state.labels;
                this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t.body = this.parseBlock(!0, !1, (i7)=>{
                    const n6 = !this.isSimpleParamList(t.params);
                    if (i7 && n6) {
                        const e24 = "method" !== t.kind && "constructor" !== t.kind || !t.key ? t.start : t.key.end;
                        this.raise(e24, g4.IllegalLanguageModeDirective);
                    }
                    const a5 = !r7 && this.state.strict;
                    this.checkParams(t, !(this.state.strict || e || s || n6), e, a5), this.state.strict && t.id && this.checkLVal(t.id, 65, void 0, "function name", void 0, a5);
                }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i6;
            }
        }
        isSimpleParamList(t) {
            for(let e24 = 0, s8 = t.length; e24 < s8; e24++)if ("Identifier" !== t[e24].type) return !1;
            return !0;
        }
        checkParams(t, e, s, r = !0) {
            const i6 = Object.create(null);
            for(let s8 = 0; s8 < t.params.length; s8++)this.checkLVal(t.params[s8], 5, e ? null : i6, "function parameter list", void 0, r);
        }
        parseExprList(t, e, s, r) {
            const i6 = [];
            let n6 = !0;
            for(; !this.eat(t);){
                if (n6) n6 = !1;
                else if (this.expect(c4.comma), this.match(t)) {
                    r && this.addExtra(r, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                }
                i6.push(this.parseExprListItem(e, s));
            }
            return i6;
        }
        parseExprListItem(t, e, s, r) {
            let i6;
            if (this.match(c4.comma)) t || this.raise(this.state.pos, g4.UnexpectedToken, ","), i6 = null;
            else if (this.match(c4.ellipsis)) {
                const t25 = this.state.start, r6 = this.state.startLoc;
                i6 = this.parseParenItem(this.parseSpread(e, s), t25, r6);
            } else if (this.match(c4.question)) {
                this.expectPlugin("partialApplication"), r || this.raise(this.state.start, g4.UnexpectedArgumentPlaceholder);
                const t25 = this.startNode();
                this.next(), i6 = this.finishNode(t25, "ArgumentPlaceholder");
            } else i6 = this.parseMaybeAssignAllowIn(e, this.parseParenItem, s);
            return i6;
        }
        parseIdentifier(t) {
            const e24 = this.startNode(), s8 = this.parseIdentifierName(e24.start, t);
            return this.createIdentifier(e24, s8);
        }
        createIdentifier(t, e) {
            return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
        }
        parseIdentifierName(t, e) {
            let s8;
            const { start: r6 , type: i6  } = this.state;
            if (i6 === c4.name) s8 = this.state.value;
            else {
                if (!i6.keyword) throw this.unexpected();
                {
                    s8 = i6.keyword;
                    const t25 = this.curContext();
                    i6 !== c4._class && i6 !== c4._function || t25 !== T4.functionStatement && t25 !== T4.functionExpression || this.state.context.pop();
                }
            }
            return e ? this.state.type = c4.name : this.checkReservedWord(s8, r6, !!i6.keyword, !1), this.next(), s8;
        }
        checkReservedWord(t, e, s, r) {
            if (this.prodParam.hasYield && "yield" === t) return void this.raise(e, g4.YieldBindingIdentifier);
            if ("await" === t) {
                if (this.prodParam.hasAwait) return void this.raise(e, g4.AwaitBindingIdentifier);
                this.expressionScope.recordAsyncArrowParametersError(e, g4.AwaitBindingIdentifier);
            }
            if (this.scope.inClass && !this.scope.inNonArrowFunction && "arguments" === t) return void this.raise(e, g4.ArgumentsInClass);
            if (s && W2(t)) return void this.raise(e, g4.UnexpectedKeyword, t);
            (this.state.strict ? r ? H4 : V3 : q3)(t, this.inModule) && (this.prodParam.hasAwait || "await" !== t ? this.raise(e, g4.UnexpectedReservedWord, t) : this.raise(e, this.hasPlugin("topLevelAwait") ? g4.AwaitNotInAsyncContext : g4.AwaitNotInAsyncFunction));
        }
        isAwaitAllowed() {
            return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin("topLevelAwait") && (this.inModule && this.prodParam.hasAwait);
        }
        parseAwait() {
            const t25 = this.startNode();
            return this.next(), this.expressionScope.recordParameterInitializerError(t25.start, g4.AwaitExpressionFormalParameter), this.eat(c4.star) && this.raise(t25.start, g4.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(c4.plusMin) || this.match(c4.parenL) || this.match(c4.bracketL) || this.match(c4.backQuote) || this.match(c4.regexp) || this.match(c4.slash) || this.hasPlugin("v8intrinsic") && this.match(c4.modulo) ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t25.argument = this.parseMaybeUnary()), this.finishNode(t25, "AwaitExpression");
        }
        parseYield() {
            const t25 = this.startNode();
            return this.expressionScope.recordParameterInitializerError(t25.start, g4.YieldInParameter), this.next(), this.match(c4.semi) || !this.match(c4.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (t25.delegate = !1, t25.argument = null) : (t25.delegate = this.eat(c4.star), t25.argument = this.parseMaybeAssign()), this.finishNode(t25, "YieldExpression");
        }
        checkPipelineAtInfixOperator(t, e) {
            "smart" === this.getPluginOption("pipelineOperator", "proposal") && "SequenceExpression" === t.type && this.raise(e, g4.PipelineHeadSequenceExpression);
        }
        parseSmartPipelineBody(t, e, s) {
            return this.checkSmartPipelineBodyEarlyErrors(t, e), this.parseSmartPipelineBodyInStyle(t, e, s);
        }
        checkSmartPipelineBodyEarlyErrors(t, e) {
            if (this.match(c4.arrow)) throw this.raise(this.state.start, g4.PipelineBodyNoArrow);
            "SequenceExpression" === t.type && this.raise(e, g4.PipelineBodySequenceExpression);
        }
        parseSmartPipelineBodyInStyle(t, e, s) {
            const r6 = this.startNodeAt(e, s), i6 = this.isSimpleReference(t);
            return i6 ? r6.callee = t : (this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(e, g4.PipelineTopicUnused), r6.expression = t), this.finishNode(r6, i6 ? "PipelineBareFunction" : "PipelineTopicExpression");
        }
        isSimpleReference(t) {
            switch(t.type){
                case "MemberExpression":
                    return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                    return !0;
                default:
                    return !1;
            }
        }
        withTopicPermittingContext(t) {
            const e24 = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 1,
                maxTopicIndex: null
            };
            try {
                return t();
            } finally{
                this.state.topicContext = e24;
            }
        }
        withTopicForbiddingContext(t) {
            const e24 = this.state.topicContext;
            this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            };
            try {
                return t();
            } finally{
                this.state.topicContext = e24;
            }
        }
        withSoloAwaitPermittingContext(t) {
            const e24 = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
                return t();
            } finally{
                this.state.soloAwait = e24;
            }
        }
        allowInAnd(t) {
            const e24 = this.prodParam.currentFlags();
            if (8 & ~e24) {
                this.prodParam.enter(8 | e24);
                try {
                    return t();
                } finally{
                    this.prodParam.exit();
                }
            }
            return t();
        }
        disallowInAnd(t) {
            const e24 = this.prodParam.currentFlags();
            if (8 & e24) {
                this.prodParam.enter(-9 & e24);
                try {
                    return t();
                } finally{
                    this.prodParam.exit();
                }
            }
            return t();
        }
        registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
        }
        primaryTopicReferenceIsAllowedInCurrentTopicContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentTopicContext() {
            return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(t) {
            const e24 = this.state.start, s8 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const r6 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            const i6 = this.parseExprOp(this.parseMaybeUnary(), e24, s8, t);
            return this.state.inFSharpPipelineDirectBody = r6, i6;
        }
    } {
        parseTopLevel(t, e) {
            if (e.sourceType = this.options.sourceType, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, c4.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for(let t25 = 0, e24 = Array.from(this.scope.undefinedExports); t25 < e24.length; t25++){
                const [s8] = e24[t25], r6 = this.scope.undefinedExports.get(s8);
                this.raise(r6, g4.ModuleExportUndefined, s8);
            }
            return t.program = this.finishNode(e, "Program"), t.comments = this.state.comments, this.options.tokens && (t.tokens = this.tokens), this.finishNode(t, "File");
        }
        stmtToDirective(t) {
            const e24 = t.expression, s8 = this.startNodeAt(e24.start, e24.loc.start), r6 = this.startNodeAt(t.start, t.loc.start), i6 = this.input.slice(e24.start, e24.end), n6 = s8.value = i6.slice(1, -1);
            return this.addExtra(s8, "raw", i6), this.addExtra(s8, "rawValue", n6), r6.value = this.finishNodeAt(s8, "DirectiveLiteral", e24.end, e24.loc.end), this.finishNodeAt(r6, "Directive", t.end, t.loc.end);
        }
        parseInterpreterDirective() {
            if (!this.match(c4.interpreterDirective)) return null;
            const t25 = this.startNode();
            return t25.value = this.state.value, this.next(), this.finishNode(t25, "InterpreterDirective");
        }
        isLet(t) {
            if (!this.isContextual("let")) return !1;
            const e24 = this.nextTokenStart(), s8 = this.input.charCodeAt(e24);
            if (91 === s8) return !0;
            if (t) return !1;
            if (123 === s8) return !0;
            if (L2(s8)) {
                let t25 = e24 + 1;
                for(; O3(this.input.charCodeAt(t25));)++t25;
                const s9 = this.input.slice(e24, t25);
                if (!G3.test(s9)) return !0;
            }
            return !1;
        }
        parseStatement(t, e) {
            return this.match(c4.at) && this.parseDecorators(!0), this.parseStatementContent(t, e);
        }
        parseStatementContent(t, e) {
            let s8 = this.state.type;
            const r6 = this.startNode();
            let i6;
            switch(this.isLet(t) && (s8 = c4._var, i6 = "let"), s8){
                case c4._break:
                case c4._continue:
                    return this.parseBreakContinueStatement(r6, s8.keyword);
                case c4._debugger:
                    return this.parseDebuggerStatement(r6);
                case c4._do:
                    return this.parseDoStatement(r6);
                case c4._for:
                    return this.parseForStatement(r6);
                case c4._function:
                    if (46 === this.lookaheadCharCode()) break;
                    return t && (this.state.strict ? this.raise(this.state.start, g4.StrictFunction) : "if" !== t && "label" !== t && this.raise(this.state.start, g4.SloppyFunction)), this.parseFunctionStatement(r6, !1, !t);
                case c4._class:
                    return t && this.unexpected(), this.parseClass(r6, !0);
                case c4._if:
                    return this.parseIfStatement(r6);
                case c4._return:
                    return this.parseReturnStatement(r6);
                case c4._switch:
                    return this.parseSwitchStatement(r6);
                case c4._throw:
                    return this.parseThrowStatement(r6);
                case c4._try:
                    return this.parseTryStatement(r6);
                case c4._const:
                case c4._var:
                    return i6 = i6 || this.state.value, t && "var" !== i6 && this.raise(this.state.start, g4.UnexpectedLexicalDeclaration), this.parseVarStatement(r6, i6);
                case c4._while:
                    return this.parseWhileStatement(r6);
                case c4._with:
                    return this.parseWithStatement(r6);
                case c4.braceL:
                    return this.parseBlock();
                case c4.semi:
                    return this.parseEmptyStatement(r6);
                case c4._import:
                    {
                        const t25 = this.lookaheadCharCode();
                        if (40 === t25 || 46 === t25) break;
                    }
                case c4._export:
                    {
                        let t25;
                        return this.options.allowImportExportEverywhere || e || this.raise(this.state.start, g4.UnexpectedImportExport), this.next(), s8 === c4._import ? (t25 = this.parseImport(r6), "ImportDeclaration" !== t25.type || t25.importKind && "value" !== t25.importKind || (this.sawUnambiguousESM = !0)) : (t25 = this.parseExport(r6), ("ExportNamedDeclaration" !== t25.type || t25.exportKind && "value" !== t25.exportKind) && ("ExportAllDeclaration" !== t25.type || t25.exportKind && "value" !== t25.exportKind) && "ExportDefaultDeclaration" !== t25.type || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(r6), t25;
                    }
                default:
                    if (this.isAsyncFunction()) return t && this.raise(this.state.start, g4.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r6, !0, !t);
            }
            const n6 = this.state.value, a5 = this.parseExpression();
            return s8 === c4.name && "Identifier" === a5.type && this.eat(c4.colon) ? this.parseLabeledStatement(r6, n6, a5, t) : this.parseExpressionStatement(r6, a5);
        }
        assertModuleNodeAllowed(t) {
            this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(t.start, {
                code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            }, g4.ImportOutsideModule);
        }
        takeDecorators(t) {
            const e24 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            e24.length && (t.decorators = e24, this.resetStartLocationFromNode(t, e24[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
        }
        canHaveLeadingDecorator() {
            return this.match(c4._class);
        }
        parseDecorators(t) {
            const e24 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            for(; this.match(c4.at);){
                const t25 = this.parseDecorator();
                e24.push(t25);
            }
            if (this.match(c4._export)) t || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, g4.DecoratorExportClass);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, g4.UnexpectedLeadingDecorator);
        }
        parseDecorator() {
            this.expectOnePlugin([
                "decorators-legacy",
                "decorators"
            ]);
            const t25 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
                this.state.decoratorStack.push([]);
                const e24 = this.state.start, s8 = this.state.startLoc;
                let r6;
                if (this.eat(c4.parenL)) r6 = this.parseExpression(), this.expect(c4.parenR);
                else for(r6 = this.parseIdentifier(!1); this.eat(c4.dot);){
                    const t26 = this.startNodeAt(e24, s8);
                    t26.object = r6, t26.property = this.parseIdentifier(!0), t26.computed = !1, r6 = this.finishNode(t26, "MemberExpression");
                }
                t25.expression = this.parseMaybeDecoratorArguments(r6), this.state.decoratorStack.pop();
            } else t25.expression = this.parseExprSubscripts();
            return this.finishNode(t25, "Decorator");
        }
        parseMaybeDecoratorArguments(t) {
            if (this.eat(c4.parenL)) {
                const e24 = this.startNodeAtNode(t);
                return e24.callee = t, e24.arguments = this.parseCallExpressionArguments(c4.parenR, !1), this.toReferencedList(e24.arguments), this.finishNode(e24, "CallExpression");
            }
            return t;
        }
        parseBreakContinueStatement(t, e) {
            const s8 = "break" === e;
            return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, s8 ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(t, e) {
            const s8 = "break" === e;
            let r6;
            for(r6 = 0; r6 < this.state.labels.length; ++r6){
                const e24 = this.state.labels[r6];
                if (null == t.label || e24.name === t.label.name) {
                    if (null != e24.kind && (s8 || "loop" === e24.kind)) break;
                    if (t.label && s8) break;
                }
            }
            r6 === this.state.labels.length && this.raise(t.start, g4.IllegalBreakContinue, e);
        }
        parseDebuggerStatement(t) {
            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
        }
        parseHeaderExpression() {
            this.expect(c4.parenL);
            const t25 = this.parseExpression();
            return this.expect(c4.parenR), t25;
        }
        parseDoStatement(t) {
            return this.next(), this.state.labels.push(Lt3), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("do")
            ), this.state.labels.pop(), this.expect(c4._while), t.test = this.parseHeaderExpression(), this.eat(c4.semi), this.finishNode(t, "DoWhileStatement");
        }
        parseForStatement(t) {
            this.next(), this.state.labels.push(Lt3);
            let e24 = -1;
            if (this.isAwaitAllowed() && this.eatContextual("await") && (e24 = this.state.lastTokStart), this.scope.enter(0), this.expect(c4.parenL), this.match(c4.semi)) return e24 > -1 && this.unexpected(e24), this.parseFor(t, null);
            const s8 = this.isLet();
            if (this.match(c4._var) || this.match(c4._const) || s8) {
                const r6 = this.startNode(), i6 = s8 ? "let" : this.state.value;
                return this.next(), this.parseVar(r6, !0, i6), this.finishNode(r6, "VariableDeclaration"), (this.match(c4._in) || this.isContextual("of")) && 1 === r6.declarations.length ? this.parseForIn(t, r6, e24) : (e24 > -1 && this.unexpected(e24), this.parseFor(t, r6));
            }
            const r6 = new wt2, i6 = this.parseExpression(!0, r6);
            if (this.match(c4._in) || this.isContextual("of")) {
                this.toAssignable(i6);
                const s9 = this.isContextual("of") ? "for-of statement" : "for-in statement";
                return this.checkLVal(i6, void 0, void 0, s9), this.parseForIn(t, i6, e24);
            }
            return this.checkExpressionErrors(r6, !0), e24 > -1 && this.unexpected(e24), this.parseFor(t, i6);
        }
        parseFunctionStatement(t, e, s) {
            return this.next(), this.parseFunction(t, 1 | (s ? 0 : 2), e);
        }
        parseIfStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(c4._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
        }
        parseReturnStatement(t) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, g4.IllegalReturn), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
        }
        parseSwitchStatement(t) {
            this.next(), t.discriminant = this.parseHeaderExpression();
            const e24 = t.cases = [];
            let s8, r6;
            for(this.expect(c4.braceL), this.state.labels.push(Ot2), this.scope.enter(0); !this.match(c4.braceR);)if (this.match(c4._case) || this.match(c4._default)) {
                const t25 = this.match(c4._case);
                s8 && this.finishNode(s8, "SwitchCase"), e24.push(s8 = this.startNode()), s8.consequent = [], this.next(), t25 ? s8.test = this.parseExpression() : (r6 && this.raise(this.state.lastTokStart, g4.MultipleDefaultsInSwitch), r6 = !0, s8.test = null), this.expect(c4.colon);
            } else s8 ? s8.consequent.push(this.parseStatement(null)) : this.unexpected();
            return this.scope.exit(), s8 && this.finishNode(s8, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
        }
        parseThrowStatement(t) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, g4.NewlineAfterThrow), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
        }
        parseCatchClauseParam() {
            const t25 = this.parseBindingAtom(), e24 = "Identifier" === t25.type;
            return this.scope.enter(e24 ? 8 : 0), this.checkLVal(t25, 9, null, "catch clause"), t25;
        }
        parseTryStatement(t) {
            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(c4._catch)) {
                const e24 = this.startNode();
                this.next(), this.match(c4.parenL) ? (this.expect(c4.parenL), e24.param = this.parseCatchClauseParam(), this.expect(c4.parenR)) : (e24.param = null, this.scope.enter(0)), e24.body = this.withTopicForbiddingContext(()=>this.parseBlock(!1, !1)
                ), this.scope.exit(), t.handler = this.finishNode(e24, "CatchClause");
            }
            return t.finalizer = this.eat(c4._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, g4.NoCatchOrFinally), this.finishNode(t, "TryStatement");
        }
        parseVarStatement(t, e) {
            return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
        }
        parseWhileStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Lt3), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("while")
            ), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
        }
        parseWithStatement(t) {
            return this.state.strict && this.raise(this.state.start, g4.StrictWith), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("with")
            ), this.finishNode(t, "WithStatement");
        }
        parseEmptyStatement(t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
        }
        parseLabeledStatement(t, e, s, r) {
            for(let t25 = 0, r6 = this.state.labels; t25 < r6.length; t25++){
                r6[t25].name === e && this.raise(s.start, g4.LabelRedeclaration, e);
            }
            const i6 = this.state.type.isLoop ? "loop" : this.match(c4._switch) ? "switch" : null;
            for(let e24 = this.state.labels.length - 1; e24 >= 0; e24--){
                const s8 = this.state.labels[e24];
                if (s8.statementStart !== t.start) break;
                s8.statementStart = this.state.start, s8.kind = i6;
            }
            return this.state.labels.push({
                name: e,
                kind: i6,
                statementStart: this.state.start
            }), t.body = this.parseStatement(r ? -1 === r.indexOf("label") ? r + "label" : r : "label"), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
        }
        parseExpressionStatement(t, e) {
            return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
        }
        parseBlock(t = !1, e = !0, s) {
            const r6 = this.startNode();
            return this.expect(c4.braceL), e && this.scope.enter(0), this.parseBlockBody(r6, t, !1, c4.braceR, s), e && this.scope.exit(), this.finishNode(r6, "BlockStatement");
        }
        isValidDirective(t) {
            return "ExpressionStatement" === t.type && "StringLiteral" === t.expression.type && !t.expression.extra.parenthesized;
        }
        parseBlockBody(t, e, s, r, i) {
            const n6 = t.body = [], a5 = t.directives = [];
            this.parseBlockOrModuleBlockBody(n6, e ? a5 : void 0, s, r, i);
        }
        parseBlockOrModuleBlockBody(t, e, s, r, i) {
            const n6 = [], a5 = this.state.strict;
            let o5 = !1, u5 = !1;
            for(; !this.match(r);){
                !u5 && this.state.octalPositions.length && n6.push(...this.state.octalPositions);
                const r6 = this.parseStatement(null, s);
                if (e && !u5 && this.isValidDirective(r6)) {
                    const t25 = this.stmtToDirective(r6);
                    e.push(t25), o5 || "use strict" !== t25.value.value || (o5 = !0, this.setStrict(!0));
                } else u5 = !0, t.push(r6);
            }
            if (this.state.strict && n6.length) for(let t25 = 0; t25 < n6.length; t25++){
                const e24 = n6[t25];
                this.raise(e24, g4.StrictOctalLiteral);
            }
            i && i.call(this, o5), a5 || this.setStrict(!1), this.next();
        }
        parseFor(t, e) {
            return t.init = e, this.expect(c4.semi), t.test = this.match(c4.semi) ? null : this.parseExpression(), this.expect(c4.semi), t.update = this.match(c4.parenR) ? null : this.parseExpression(), this.expect(c4.parenR), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("for")
            ), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
        }
        parseForIn(t, e, s) {
            const r6 = this.match(c4._in);
            return this.next(), r6 ? s > -1 && this.unexpected(s) : t.await = s > -1, "VariableDeclaration" !== e.type || null == e.declarations[0].init || r6 && !this.state.strict && "var" === e.kind && "Identifier" === e.declarations[0].id.type ? "AssignmentPattern" === e.type && this.raise(e.start, g4.InvalidLhs, "for-loop") : this.raise(e.start, g4.ForInOfLoopInitializer, r6 ? "for-in" : "for-of"), t.left = e, t.right = r6 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(c4.parenR), t.body = this.withTopicForbiddingContext(()=>this.parseStatement("for")
            ), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, r6 ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(t, e, s) {
            const r6 = t.declarations = [], i6 = this.hasPlugin("typescript");
            for(t.kind = s;;){
                const t25 = this.startNode();
                if (this.parseVarId(t25, s), this.eat(c4.eq) ? t25.init = e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : ("const" !== s || this.match(c4._in) || this.isContextual("of") ? "Identifier" === t25.id.type || e && (this.match(c4._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, g4.DeclarationMissingInitializer, "Complex binding patterns") : i6 || this.raise(this.state.lastTokEnd, g4.DeclarationMissingInitializer, "Const declarations"), t25.init = null), r6.push(this.finishNode(t25, "VariableDeclarator")), !this.eat(c4.comma)) break;
            }
            return t;
        }
        parseVarId(t, e) {
            t.id = this.parseBindingAtom(), this.checkLVal(t.id, "var" === e ? 5 : 9, void 0, "variable declaration", "var" !== e);
        }
        parseFunction(t, e = 0, s = !1) {
            const r6 = 1 & e, i6 = 2 & e, n6 = !(!r6 || 4 & e);
            this.initFunction(t, s), this.match(c4.star) && i6 && this.raise(this.state.start, g4.GeneratorInSingleStatementContext), t.generator = this.eat(c4.star), r6 && (t.id = this.parseFunctionId(n6));
            const a5 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ct2(s, t.generator)), r6 || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withTopicForbiddingContext(()=>{
                this.parseFunctionBodyAndFinish(t, r6 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), r6 && !i6 && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = a5, t;
        }
        parseFunctionId(t) {
            return t || this.match(c4.name) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(t, e) {
            this.expect(c4.parenL), this.expressionScope.enter(new Nt2(3)), t.params = this.parseBindingList(c4.parenR, 41, !1, e), this.expressionScope.exit();
        }
        registerFunctionStatementId(t) {
            t.id && this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t.id.start);
        }
        parseClass(t, e, s) {
            this.next(), this.takeDecorators(t);
            const r6 = this.state.strict;
            return this.state.strict = !0, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, r6), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
            return this.match(c4.eq) || this.match(c4.semi) || this.match(c4.braceR);
        }
        isClassMethod() {
            return this.match(c4.parenL);
        }
        isNonstaticConstructor(t) {
            return !(t.computed || t.static || "constructor" !== t.key.name && "constructor" !== t.key.value);
        }
        parseClassBody(t, e) {
            this.classScope.enter();
            const s8 = {
                constructorAllowsSuper: t,
                hadConstructor: !1,
                hadStaticBlock: !1
            };
            let r6 = [];
            const i6 = this.startNode();
            if (i6.body = [], this.expect(c4.braceL), this.withTopicForbiddingContext(()=>{
                for(; !this.match(c4.braceR);){
                    if (this.eat(c4.semi)) {
                        if (r6.length > 0) throw this.raise(this.state.lastTokEnd, g4.DecoratorSemicolon);
                        continue;
                    }
                    if (this.match(c4.at)) {
                        r6.push(this.parseDecorator());
                        continue;
                    }
                    const t25 = this.startNode();
                    r6.length && (t25.decorators = r6, this.resetStartLocationFromNode(t25, r6[0]), r6 = []), this.parseClassMember(i6, t25, s8), "constructor" === t25.kind && t25.decorators && t25.decorators.length > 0 && this.raise(t25.start, g4.DecoratorConstructor);
                }
            }), this.state.strict = e, this.next(), r6.length) throw this.raise(this.state.start, g4.TrailingDecorator);
            return this.classScope.exit(), this.finishNode(i6, "ClassBody");
        }
        parseClassMemberFromModifier(t, e) {
            const s8 = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
                const r6 = e;
                return e.kind = "method", e.computed = !1, e.key = s8, e.static = !1, this.pushClassMethod(t, e, !1, !1, !1, !1), !0;
            }
            if (this.isClassProperty()) {
                const r6 = e;
                return e.computed = !1, e.key = s8, e.static = !1, t.body.push(this.parseClassProperty(e)), !0;
            }
            return !1;
        }
        parseClassMember(t, e, s) {
            const r6 = this.isContextual("static");
            if (r6) {
                if (this.parseClassMemberFromModifier(t, e)) return;
                if (this.eat(c4.braceL)) return void this.parseClassStaticBlock(t, e, s);
            }
            this.parseClassMemberWithIsStatic(t, e, s, r6);
        }
        parseClassMemberWithIsStatic(t, e, s, r) {
            const i6 = e, n6 = e, a5 = e, o5 = e, u5 = i6, h5 = i6;
            if (e.static = r, this.eat(c4.star)) return i6.kind = "method", this.parseClassElementName(i6), "PrivateName" === i6.key.type ? void this.pushClassPrivateMethod(t, e, !0, !1) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g4.ConstructorIsGenerator), void this.pushClassMethod(t, e, !0, !1, !1, !1));
            const p5 = this.state.containsEsc, l5 = this.parseClassElementName(e), d5 = "PrivateName" === l5.type, D5 = "Identifier" === l5.type, m5 = this.state.start;
            if (this.parsePostMemberNameModifiers(i6), this.isClassMethod()) {
                if (i6.kind = "method", d5) return void this.pushClassPrivateMethod(t, e, !1, !1);
                const e24 = this.isNonstaticConstructor(e);
                let r6 = !1;
                e24 && (e.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(l5.start, g4.DuplicateConstructor), s.hadConstructor = !0, r6 = s.constructorAllowsSuper), this.pushClassMethod(t, e, !1, !1, e24, r6);
            } else if (this.isClassProperty()) d5 ? this.pushClassPrivateProperty(t, e) : this.pushClassProperty(t, e);
            else if (!D5 || "async" !== l5.name || p5 || this.isLineTerminator()) !D5 || "get" !== l5.name && "set" !== l5.name || p5 || this.match(c4.star) && this.isLineTerminator() ? this.isLineTerminator() ? d5 ? this.pushClassPrivateProperty(t, e) : this.pushClassProperty(t, e) : this.unexpected() : (i6.kind = l5.name, this.parseClassElementName(e), "PrivateName" === i6.key.type ? this.pushClassPrivateMethod(t, e, !1, !1) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g4.ConstructorIsAccessor), this.pushClassMethod(t, e, !1, !1, !1, !1)), this.checkGetterSetterParams(e));
            else {
                const e24 = this.eat(c4.star);
                i6.optional && this.unexpected(m5), i6.kind = "method", this.parseClassElementName(i6), this.parsePostMemberNameModifiers(i6), "PrivateName" === i6.key.type ? this.pushClassPrivateMethod(t, e, e24, !0) : (this.isNonstaticConstructor(e) && this.raise(e.key.start, g4.ConstructorIsAsync), this.pushClassMethod(t, e, e24, !0, !1, !1));
            }
        }
        parseClassElementName(t) {
            const e24 = this.parsePropertyName(t, !0);
            return t.computed || !t.static || "prototype" !== e24.name && "prototype" !== e24.value || this.raise(e24.start, g4.StaticPrototype), "PrivateName" === e24.type && "constructor" === e24.id.name && this.raise(e24.start, g4.ConstructorClassPrivateField), e24;
        }
        parseClassStaticBlock(t, e, s) {
            var r6;
            this.expectPlugin("classStaticBlock", e.start), this.scope.enter(80), this.expressionScope.enter(kt2());
            const i6 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const n6 = e.body = [];
            this.parseBlockOrModuleBlockBody(n6, void 0, !1, c4.braceR), this.prodParam.exit(), this.expressionScope.exit(), this.scope.exit(), this.state.labels = i6, t.body.push(this.finishNode(e, "StaticBlock")), s.hadStaticBlock && this.raise(e.start, g4.DuplicateStaticBlock), (null == (r6 = e.decorators) ? void 0 : r6.length) && this.raise(e.start, g4.DecoratorStaticBlock), s.hadStaticBlock = !0;
        }
        pushClassProperty(t, e) {
            e.computed || "constructor" !== e.key.name && "constructor" !== e.key.value || this.raise(e.key.start, g4.ConstructorClassField), t.body.push(this.parseClassProperty(e));
        }
        pushClassPrivateProperty(t, e) {
            this.expectPlugin("classPrivateProperties", e.key.start);
            const s8 = this.parseClassPrivateProperty(e);
            t.body.push(s8), this.classScope.declarePrivateName(s8.key.id.name, 0, s8.key.start);
        }
        pushClassMethod(t, e, s, r, i, n) {
            t.body.push(this.parseMethod(e, s, r, i, n, "ClassMethod", !0));
        }
        pushClassPrivateMethod(t, e, s, r) {
            this.expectPlugin("classPrivateMethods", e.key.start);
            const i6 = this.parseMethod(e, s, r, !1, !1, "ClassPrivateMethod", !0);
            t.body.push(i6);
            const n6 = "get" === i6.kind ? i6.static ? 6 : 2 : "set" === i6.kind ? i6.static ? 5 : 1 : 0;
            this.classScope.declarePrivateName(i6.key.id.name, n6, i6.key.start);
        }
        parsePostMemberNameModifiers(t) {
        }
        parseClassPrivateProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
        }
        parseClassProperty(t) {
            return t.typeAnnotation && !this.match(c4.eq) || this.expectPlugin("classProperties"), this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
        }
        parseInitializer(t) {
            this.scope.enter(80), this.expressionScope.enter(kt2()), this.prodParam.enter(0), t.value = this.eat(c4.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(t, e, s, r = 139) {
            this.match(c4.name) ? (t.id = this.parseIdentifier(), e && this.checkLVal(t.id, r, void 0, "class name")) : s || !e ? t.id = null : this.unexpected(null, g4.MissingClassName);
        }
        parseClassSuper(t) {
            t.superClass = this.eat(c4._extends) ? this.parseExprSubscripts() : null;
        }
        parseExport(t) {
            const e24 = this.maybeParseExportDefaultSpecifier(t), s8 = !e24 || this.eat(c4.comma), r6 = s8 && this.eatExportStar(t), i6 = r6 && this.maybeParseExportNamespaceSpecifier(t), n6 = s8 && (!i6 || this.eat(c4.comma)), a5 = e24 || r6;
            if (r6 && !i6) return e24 && this.unexpected(), this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
            const o5 = this.maybeParseExportNamedSpecifiers(t);
            if (e24 && s8 && !r6 && !o5 || i6 && n6 && !o5) throw this.unexpected(null, c4.braceL);
            let u5;
            if (a5 || o5 ? (u5 = !1, this.parseExportFrom(t, a5)) : u5 = this.maybeParseExportDeclaration(t), a5 || o5 || u5) return this.checkExport(t, !0, !1, !!t.source), this.finishNode(t, "ExportNamedDeclaration");
            if (this.eat(c4._default)) return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, !0, !0), this.finishNode(t, "ExportDefaultDeclaration");
            throw this.unexpected(null, c4.braceL);
        }
        eatExportStar(t) {
            return this.eat(c4.star);
        }
        maybeParseExportDefaultSpecifier(t) {
            if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                const e24 = this.startNode();
                return e24.exported = this.parseIdentifier(!0), t.specifiers = [
                    this.finishNode(e24, "ExportDefaultSpecifier")
                ], !0;
            }
            return !1;
        }
        maybeParseExportNamespaceSpecifier(t) {
            if (this.isContextual("as")) {
                t.specifiers || (t.specifiers = []);
                const e24 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                return this.next(), e24.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e24, "ExportNamespaceSpecifier")), !0;
            }
            return !1;
        }
        maybeParseExportNamedSpecifiers(t) {
            return !!this.match(c4.braceL) && (t.specifiers || (t.specifiers = []), t.specifiers.push(...this.parseExportSpecifiers()), t.source = null, t.declaration = null, !0);
        }
        maybeParseExportDeclaration(t) {
            return !!this.shouldParseExportDeclaration() && (t.specifiers = [], t.source = null, t.declaration = this.parseExportDeclaration(t), !0);
        }
        isAsyncFunction() {
            if (!this.isContextual("async")) return !1;
            const t25 = this.nextTokenStart();
            return !m4.test(this.input.slice(this.state.pos, t25)) && this.isUnparsedContextual(t25, "function");
        }
        parseExportDefaultExpression() {
            const t25 = this.startNode(), e24 = this.isAsyncFunction();
            if (this.match(c4._function) || e24) return this.next(), e24 && this.next(), this.parseFunction(t25, 5, e24);
            if (this.match(c4._class)) return this.parseClass(t25, !0, !0);
            if (this.match(c4.at)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, g4.DecoratorBeforeExport), this.parseDecorators(!1), this.parseClass(t25, !0, !0);
            if (this.match(c4._const) || this.match(c4._var) || this.isLet()) throw this.raise(this.state.start, g4.UnsupportedDefaultExport);
            {
                const t26 = this.parseMaybeAssignAllowIn();
                return this.semicolon(), t26;
            }
        }
        parseExportDeclaration(t) {
            return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
            if (this.match(c4.name)) {
                const t25 = this.state.value;
                if ("async" === t25 && !this.state.containsEsc || "let" === t25) return !1;
                if (("type" === t25 || "interface" === t25) && !this.state.containsEsc) {
                    const t26 = this.lookahead();
                    if (t26.type === c4.name && "from" !== t26.value || t26.type === c4.braceL) return this.expectOnePlugin([
                        "flow",
                        "typescript"
                    ]), !1;
                }
            } else if (!this.match(c4._default)) return !1;
            const t25 = this.nextTokenStart(), e24 = this.isUnparsedContextual(t25, "from");
            if (44 === this.input.charCodeAt(t25) || this.match(c4.name) && e24) return !0;
            if (this.match(c4._default) && e24) {
                const e25 = this.input.charCodeAt(this.nextTokenStartSince(t25 + 4));
                return 34 === e25 || 39 === e25;
            }
            return !1;
        }
        parseExportFrom(t, e) {
            if (this.eatContextual("from")) {
                t.source = this.parseImportSource(), this.checkExport(t);
                const e24 = this.maybeParseImportAssertions();
                e24 && (t.assertions = e24);
            } else e ? this.unexpected() : t.source = null;
            this.semicolon();
        }
        shouldParseExportDeclaration() {
            if (this.match(c4.at) && (this.expectOnePlugin([
                "decorators",
                "decorators-legacy"
            ]), this.hasPlugin("decorators"))) {
                if (!this.getPluginOption("decorators", "decoratorsBeforeExport")) return !0;
                this.unexpected(this.state.start, g4.DecoratorBeforeExport);
            }
            return "var" === this.state.type.keyword || "const" === this.state.type.keyword || "function" === this.state.type.keyword || "class" === this.state.type.keyword || this.isLet() || this.isAsyncFunction();
        }
        checkExport(t, e, s, r) {
            if (e) {
                if (s) {
                    if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                        var i6;
                        const e24 = t.declaration;
                        "Identifier" !== e24.type || "from" !== e24.name || e24.end - e24.start != 4 || (null == (i6 = e24.extra) ? void 0 : i6.parenthesized) || this.raise(e24.start, g4.ExportDefaultFromAsIdentifier);
                    }
                } else if (t.specifiers && t.specifiers.length) for(let e24 = 0, s8 = t.specifiers; e24 < s8.length; e24++){
                    const t25 = s8[e24], { exported: i6  } = t25, n6 = "Identifier" === i6.type ? i6.name : i6.value;
                    if (this.checkDuplicateExports(t25, n6), !r && t25.local) {
                        const { local: e25  } = t25;
                        "StringLiteral" === e25.type ? this.raise(t25.start, g4.ExportBindingIsString, e25.extra.raw, n6) : (this.checkReservedWord(e25.name, e25.start, !0, !1), this.scope.checkLocalExport(e25));
                    }
                }
                else if (t.declaration) {
                    if ("FunctionDeclaration" === t.declaration.type || "ClassDeclaration" === t.declaration.type) {
                        const e25 = t.declaration.id;
                        if (!e25) throw new Error("Assertion failure");
                        this.checkDuplicateExports(t, e25.name);
                    } else if ("VariableDeclaration" === t.declaration.type) for(let e25 = 0, s9 = t.declaration.declarations; e25 < s9.length; e25++){
                        const t25 = s9[e25];
                        this.checkDeclaration(t25.id);
                    }
                }
            }
            if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) throw this.raise(t.start, g4.UnsupportedDecoratorExport);
        }
        checkDeclaration(t) {
            if ("Identifier" === t.type) this.checkDuplicateExports(t, t.name);
            else if ("ObjectPattern" === t.type) for(let e24 = 0, s8 = t.properties; e24 < s8.length; e24++){
                const t25 = s8[e24];
                this.checkDeclaration(t25);
            }
            else if ("ArrayPattern" === t.type) for(let e25 = 0, s9 = t.elements; e25 < s9.length; e25++){
                const t25 = s9[e25];
                t25 && this.checkDeclaration(t25);
            }
            else "ObjectProperty" === t.type ? this.checkDeclaration(t.value) : "RestElement" === t.type ? this.checkDeclaration(t.argument) : "AssignmentPattern" === t.type && this.checkDeclaration(t.left);
        }
        checkDuplicateExports(t, e) {
            this.state.exportedIdentifiers.indexOf(e) > -1 && this.raise(t.start, "default" === e ? g4.DuplicateDefaultExport : g4.DuplicateExport, e), this.state.exportedIdentifiers.push(e);
        }
        parseExportSpecifiers() {
            const t25 = [];
            let e24 = !0;
            for(this.expect(c4.braceL); !this.eat(c4.braceR);){
                if (e24) e24 = !1;
                else if (this.expect(c4.comma), this.eat(c4.braceR)) break;
                const s8 = this.startNode();
                s8.local = this.parseModuleExportName(), s8.exported = this.eatContextual("as") ? this.parseModuleExportName() : s8.local.__clone(), t25.push(this.finishNode(s8, "ExportSpecifier"));
            }
            return t25;
        }
        parseModuleExportName() {
            if (this.match(c4.string)) {
                this.expectPlugin("moduleStringNames");
                const t25 = this.parseLiteral(this.state.value, "StringLiteral"), e24 = t25.value.match(Mt3);
                return e24 && this.raise(t25.start, g4.ModuleExportNameHasLoneSurrogate, e24[0].charCodeAt(0).toString(16)), t25;
            }
            return this.parseIdentifier(!0);
        }
        parseImport(t) {
            if (t.specifiers = [], !this.match(c4.string)) {
                const e24 = !this.maybeParseDefaultImportSpecifier(t) || this.eat(c4.comma), s8 = e24 && this.maybeParseStarImportSpecifier(t);
                e24 && !s8 && this.parseNamedImportSpecifiers(t), this.expectContextual("from");
            }
            t.source = this.parseImportSource();
            const e24 = this.maybeParseImportAssertions();
            if (e24) t.assertions = e24;
            else {
                const e25 = this.maybeParseModuleAttributes();
                e25 && (t.attributes = e25);
            }
            return this.semicolon(), this.finishNode(t, "ImportDeclaration");
        }
        parseImportSource() {
            return this.match(c4.string) || this.unexpected(), this.parseExprAtom();
        }
        shouldParseDefaultImport(t) {
            return this.match(c4.name);
        }
        parseImportSpecifierLocal(t, e, s, r) {
            e.local = this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, r), t.specifiers.push(this.finishNode(e, s));
        }
        parseAssertEntries() {
            const t25 = [], e24 = new Set;
            do {
                if (this.match(c4.braceR)) break;
                const s8 = this.startNode(), r6 = this.state.value;
                if (this.match(c4.string) ? s8.key = this.parseLiteral(r6, "StringLiteral") : s8.key = this.parseIdentifier(!0), this.expect(c4.colon), "type" !== r6 && this.raise(s8.key.start, g4.ModuleAttributeDifferentFromType, r6), e24.has(r6) && this.raise(s8.key.start, g4.ModuleAttributesWithDuplicateKeys, r6), e24.add(r6), !this.match(c4.string)) throw this.unexpected(this.state.start, g4.ModuleAttributeInvalidValue);
                s8.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s8, "ImportAttribute"), t25.push(s8);
            }while (this.eat(c4.comma))
            return t25;
        }
        maybeParseModuleAttributes() {
            if (!this.match(c4._with) || this.hasPrecedingLineBreak()) return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            const t25 = [], e24 = new Set;
            do {
                const s8 = this.startNode();
                if (s8.key = this.parseIdentifier(!0), "type" !== s8.key.name && this.raise(s8.key.start, g4.ModuleAttributeDifferentFromType, s8.key.name), e24.has(s8.key.name) && this.raise(s8.key.start, g4.ModuleAttributesWithDuplicateKeys, s8.key.name), e24.add(s8.key.name), this.expect(c4.colon), !this.match(c4.string)) throw this.unexpected(this.state.start, g4.ModuleAttributeInvalidValue);
                s8.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s8, "ImportAttribute"), t25.push(s8);
            }while (this.eat(c4.comma))
            return t25;
        }
        maybeParseImportAssertions() {
            if (!this.isContextual("assert") || this.hasPrecedingLineBreak()) return this.hasPlugin("importAssertions") ? [] : null;
            this.expectPlugin("importAssertions"), this.next(), this.eat(c4.braceL);
            const t25 = this.parseAssertEntries();
            return this.eat(c4.braceR), t25;
        }
        maybeParseDefaultImportSpecifier(t) {
            return !!this.shouldParseDefaultImport(t) && (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), !0);
        }
        maybeParseStarImportSpecifier(t) {
            if (this.match(c4.star)) {
                const e24 = this.startNode();
                return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(t, e24, "ImportNamespaceSpecifier", "import namespace specifier"), !0;
            }
            return !1;
        }
        parseNamedImportSpecifiers(t) {
            let e24 = !0;
            for(this.expect(c4.braceL); !this.eat(c4.braceR);){
                if (e24) e24 = !1;
                else {
                    if (this.eat(c4.colon)) throw this.raise(this.state.start, g4.DestructureNamedImport);
                    if (this.expect(c4.comma), this.eat(c4.braceR)) break;
                }
                this.parseImportSpecifier(t);
            }
        }
        parseImportSpecifier(t) {
            const e24 = this.startNode();
            if (e24.imported = this.parseModuleExportName(), this.eatContextual("as")) e24.local = this.parseIdentifier();
            else {
                const { imported: t25  } = e24;
                if ("StringLiteral" === t25.type) throw this.raise(e24.start, g4.ImportBindingIsString, t25.value);
                this.checkReservedWord(t25.name, e24.start, !0, !0), e24.local = t25.__clone();
            }
            this.checkLVal(e24.local, 9, void 0, "import specifier"), t.specifiers.push(this.finishNode(e24, "ImportSpecifier"));
        }
    } {
        constructor(t25, e24){
            super(t25 = function(t26) {
                const e25 = {
                };
                for(let s8 = 0, r6 = Object.keys(Ct2); s8 < r6.length; s8++){
                    const i6 = r6[s8];
                    e25[i6] = t26 && null != t26[i6] ? t26[i6] : Ct2[i6];
                }
                return e25;
            }(t25), e24);
            const s8 = this.getScopeHandler();
            this.options = t25, this.inModule = "module" === this.options.sourceType, this.scope = new s8(this.raise.bind(this), this.inModule), this.prodParam = new ht3, this.classScope = new _t3(this.raise.bind(this)), this.expressionScope = new vt2(this.raise.bind(this)), this.plugins = (function(t26) {
                const e25 = new Map;
                for(let s9 = 0; s9 < t26.length; s9++){
                    const r6 = t26[s9], [i6, n6] = Array.isArray(r6) ? r6 : [
                        r6,
                        {
                        }
                    ];
                    e25.has(i6) || e25.set(i6, n6 || {
                    });
                }
                return e25;
            })(this.options.plugins), this.filename = t25.sourceFilename;
        }
        getScopeHandler() {
            return at3;
        }
        parse() {
            let t26 = 0;
            this.hasPlugin("topLevelAwait") && this.inModule && (t26 |= 2), this.scope.enter(1), this.prodParam.enter(t26);
            const e25 = this.startNode(), s9 = this.startNode();
            return this.nextToken(), e25.errors = null, this.parseTopLevel(e25, s9), e25.errors = this.state.errors, e25;
        }
    }
    function Ut3(t26, e25) {
        let s9 = jt3;
        return ((null == t26 ? void 0 : t26.plugins) && (!function(t27) {
            if (Dt3(t27, "decorators")) {
                if (Dt3(t27, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                const e26 = mt2(t27, "decorators", "decoratorsBeforeExport");
                if (null == e26) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
                if ("boolean" != typeof e26) throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (Dt3(t27, "flow") && Dt3(t27, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
            if (Dt3(t27, "placeholders") && Dt3(t27, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (Dt3(t27, "pipelineOperator") && !ft3.includes(mt2(t27, "pipelineOperator", "proposal"))) throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + ft3.map((t28)=>"'".concat(t28, "'")
            ).join(", "));
            if (Dt3(t27, "moduleAttributes")) {
                if (Dt3(t27, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
                if ("may-2020" !== mt2(t27, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (Dt3(t27, "recordAndTuple") && !yt2.includes(mt2(t27, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + yt2.map((t28)=>"'".concat(t28, "'")
            ).join(", "));
        }(t26.plugins), s9 = function(t27) {
            const e26 = At2.filter((e27)=>Dt3(t27, e27)
            ), s10 = e26.join("/");
            let r6 = qt3[s10];
            if (!r6) {
                r6 = jt3;
                for(let t28 = 0; t28 < e26.length; t28++){
                    const s11 = e26[t28];
                    r6 = Et2[s11](r6);
                }
                qt3[s10] = r6;
            }
            return r6;
        }(t26.plugins)), new s9(t26, e25));
    }
    const qt3 = {
    };
    e14.parse = function(t26, e25) {
        var s9;
        if ("unambiguous" !== (null == (s9 = e25) ? void 0 : s9.sourceType)) return Ut3(e25, t26).parse();
        e25 = Object.assign({
        }, e25);
        try {
            e25.sourceType = "module";
            const s10 = Ut3(e25, t26), r6 = s10.parse();
            if (s10.sawUnambiguousESM) return r6;
            if (s10.ambiguousScriptDifferentAst) try {
                return e25.sourceType = "script", Ut3(e25, t26).parse();
            } catch (t) {
            }
            else r6.program.sourceType = "script";
            return r6;
        } catch (s) {
            try {
                return e25.sourceType = "script", Ut3(e25, t26).parse();
            } catch (t) {
            }
            throw s;
        }
    }, e14.parseExpression = function(t26, e25) {
        const s9 = Ut3(e25, t26);
        return s9.options.strictMode && (s9.state.strict = !0), s9.getExpression();
    }, e14.tokTypes = c4;
});
const { getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Rs1 , getShebang: _s1  } = It2, { hasPragma: js1  } = Wt2, { locStart: Us1 , locEnd: qs1  } = Jt1;
function zs1(e14, ...s5) {
    return (r4, i5, n5 = {
    })=>{
        if ("babel" === n5.parser && (function(t10, e15) {
            if (e15.filepath && e15.filepath.endsWith(".js.flow")) return !0;
            const s6 = _s1(t10);
            s6 && (t10 = t10.slice(s6.length));
            const r5 = Rs1(t10, 0);
            return !1 !== r5 && (t10 = t10.slice(0, r5)), Vs1.test(t10);
        })(r4, n5)) return n5.parser = "babel-flow", Ws2(r4, i5, n5);
        const a4 = Ms1, o4 = "script" === n5.__babelSourceType ? "script" : "module";
        let u4;
        try {
            u4 = (function(t10, e15) {
                let s6;
                for(let r5 = 0; r5 < e15.length; r5++)try {
                    return Js1(t10(e15[r5]));
                } catch (t) {
                    s6 || (s6 = t);
                }
                throw s6;
            })((t10)=>Ms1[e14](r4, t10)
            , (function(t10, e15, s6) {
                if (!t10) return e15;
                const r5 = [];
                for (const t11 of e15)for (const e16 of s6)r5.push([
                    ...t11,
                    e16
                ]);
                return r5;
            })(r4.includes("|>"), s5, [
                [
                    "pipelineOperator",
                    {
                        proposal: "smart"
                    }
                ],
                [
                    "pipelineOperator",
                    {
                        proposal: "minimal"
                    }
                ],
                [
                    "pipelineOperator",
                    {
                        proposal: "fsharp"
                    }
                ]
            ]).map((t10)=>(function({ sourceType: t11 , extraPlugins: e15 = []  }) {
                    return {
                        sourceType: t11,
                        allowAwaitOutsideFunction: !0,
                        allowImportExportEverywhere: !0,
                        allowReturnOutsideFunction: !0,
                        allowSuperOutsideMethod: !0,
                        allowUndeclaredExports: !0,
                        errorRecovery: !0,
                        createParenthesizedExpressions: !0,
                        plugins: [
                            "doExpressions",
                            "classProperties",
                            "exportDefaultFrom",
                            "functionBind",
                            "functionSent",
                            "classPrivateProperties",
                            "throwExpressions",
                            "classPrivateMethods",
                            "v8intrinsic",
                            "partialApplication",
                            [
                                "decorators",
                                {
                                    decoratorsBeforeExport: !1
                                }
                            ],
                            "privateIn",
                            "importAssertions",
                            [
                                "recordAndTuple",
                                {
                                    syntaxType: "hash"
                                }
                            ],
                            "decimal",
                            "moduleStringNames",
                            "classStaticBlock",
                            ...e15
                        ],
                        tokens: !0,
                        ranges: !0
                    };
                })({
                    sourceType: o4,
                    extraPlugins: t10
                })
            ));
        } catch (e) {
            const { message: s6 , loc: r5  } = e;
            throw t1(s6.replace(/ \(.*\)/, ""), {
                start: {
                    line: r5 ? r5.line : 0,
                    column: r5 ? r5.column + 1 : 0
                }
            });
        }
        return Os1(u4, Object.assign({
        }, n5, {
            originalText: r4
        }));
    };
}
const Ws2 = zs1("parse", [
    "jsx",
    [
        "flow",
        {
            all: !0,
            enums: !0
        }
    ]
]), Xs1 = zs1("parseExpression", [
    "jsx"
]);
function L2() {
    O1 && N2 && (O1 = !1, N2.length ? x2 = N2.concat(x2) : R2 = -1, x2.length && P3());
}
function P3() {
    if (!O1) {
        var e14 = k2(L2);
        O1 = !0;
        for(var t10 = x2.length; t10;){
            for(N2 = x2, x2 = []; (++R2) < t10;)N2 && N2[R2].run();
            R2 = -1, t10 = x2.length;
        }
        N2 = null, O1 = !1, (function(e15) {
            if (w2 === clearTimeout) return clearTimeout(e15);
            if ((w2 === A2 || !w2) && clearTimeout) return w2 = clearTimeout, clearTimeout(e15);
            try {
                w2(e15);
            } catch (t) {
                try {
                    return w2.call(null, e15);
                } catch (t) {
                    return w2.call(this, e15);
                }
            }
        })(e14);
    }
}
var W2 = {
    nextTick: function(e14) {
        var t10 = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n5 = 1; n5 < arguments.length; n5++)t10[n5 - 1] = arguments[n5];
        x2.push(new B1(e14, t10)), 1 !== x2.length || O1 || k2(P3);
    },
    title: "browser",
    browser: !0,
    env: {
    },
    argv: [],
    version: "",
    versions: {
    },
    on: q2,
    addListener: $1,
    once: M1,
    off: U2,
    removeListener: G1,
    removeAllListeners: V2,
    emit: j1,
    binding: function(e14) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(e14) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(e14) {
        var t10 = 0.001 * X1.call(H1), n5 = Math.floor(t10), r4 = Math.floor(t10 % 1 * 1000000000);
        return (e14 && (n5 -= e14[0], (r4 -= e14[1]) < 0 && (n5--, r4 += 1000000000)), [
            n5,
            r4
        ]);
    },
    platform: "browser",
    release: {
    },
    config: {
    },
    uptime: function() {
        return (new Date - z1) / 1000;
    }
};
var Q3 = "object" == typeof W2 && W2.env && W2.env.NODE_DEBUG && /\bsemver\b/i.test(W2.env.NODE_DEBUG) ? (...e14)=>console.error("SEMVER", ...e14)
 : ()=>{
};
var Y2 = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16
}, J2 = t2(function(e14, t10) {
    const { MAX_SAFE_COMPONENT_LENGTH: n5  } = Y2, r4 = (t10 = e14.exports = {
    }).re = [], s5 = t10.src = [], i5 = t10.t = {
    };
    let o4 = 0;
    const a4 = (e15, t11, n6)=>{
        const a5 = o4++;
        Q3(a5, t11), i5[e15] = a5, s5[a5] = t11, r4[a5] = new RegExp(t11, n6 ? "g" : void 0);
    };
    a4("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a4("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a4("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a4("MAINVERSION", "(".concat(s5[i5.NUMERICIDENTIFIER], ")\\.") + "(".concat(s5[i5.NUMERICIDENTIFIER], ")\\.") + "(".concat(s5[i5.NUMERICIDENTIFIER], ")")), a4("MAINVERSIONLOOSE", "(".concat(s5[i5.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s5[i5.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(s5[i5.NUMERICIDENTIFIERLOOSE], ")")), a4("PRERELEASEIDENTIFIER", "(?:".concat(s5[i5.NUMERICIDENTIFIER], "|").concat(s5[i5.NONNUMERICIDENTIFIER], ")")), a4("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(s5[i5.NUMERICIDENTIFIERLOOSE], "|").concat(s5[i5.NONNUMERICIDENTIFIER], ")")), a4("PRERELEASE", "(?:-(".concat(s5[i5.PRERELEASEIDENTIFIER], "(?:\\.").concat(s5[i5.PRERELEASEIDENTIFIER], ")*))")), a4("PRERELEASELOOSE", "(?:-?(".concat(s5[i5.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(s5[i5.PRERELEASEIDENTIFIERLOOSE], ")*))")), a4("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a4("BUILD", "(?:\\+(".concat(s5[i5.BUILDIDENTIFIER], "(?:\\.").concat(s5[i5.BUILDIDENTIFIER], ")*))")), a4("FULLPLAIN", "v?".concat(s5[i5.MAINVERSION]).concat(s5[i5.PRERELEASE], "?").concat(s5[i5.BUILD], "?")), a4("FULL", "^".concat(s5[i5.FULLPLAIN], "$")), a4("LOOSEPLAIN", "[v=\\s]*".concat(s5[i5.MAINVERSIONLOOSE]).concat(s5[i5.PRERELEASELOOSE], "?").concat(s5[i5.BUILD], "?")), a4("LOOSE", "^".concat(s5[i5.LOOSEPLAIN], "$")), a4("GTLT", "((?:<|>)?=?)"), a4("XRANGEIDENTIFIERLOOSE", "".concat(s5[i5.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a4("XRANGEIDENTIFIER", "".concat(s5[i5.NUMERICIDENTIFIER], "|x|X|\\*")), a4("XRANGEPLAIN", "[v=\\s]*(".concat(s5[i5.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s5[i5.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(s5[i5.XRANGEIDENTIFIER], ")") + "(?:".concat(s5[i5.PRERELEASE], ")?").concat(s5[i5.BUILD], "?") + ")?)?"), a4("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(s5[i5.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s5[i5.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(s5[i5.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(s5[i5.PRERELEASELOOSE], ")?").concat(s5[i5.BUILD], "?") + ")?)?"), a4("XRANGE", "^".concat(s5[i5.GTLT], "\\s*").concat(s5[i5.XRANGEPLAIN], "$")), a4("XRANGELOOSE", "^".concat(s5[i5.GTLT], "\\s*").concat(s5[i5.XRANGEPLAINLOOSE], "$")), a4("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n5, "})") + "(?:\\.(\\d{1,".concat(n5, "}))?") + "(?:\\.(\\d{1,".concat(n5, "}))?") + "(?:$|[^\\d])"), a4("COERCERTL", s5[i5.COERCE], !0), a4("LONETILDE", "(?:~>?)"), a4("TILDETRIM", "(\\s*)".concat(s5[i5.LONETILDE], "\\s+"), !0), t10.tildeTrimReplace = "$1~", a4("TILDE", "^".concat(s5[i5.LONETILDE]).concat(s5[i5.XRANGEPLAIN], "$")), a4("TILDELOOSE", "^".concat(s5[i5.LONETILDE]).concat(s5[i5.XRANGEPLAINLOOSE], "$")), a4("LONECARET", "(?:\\^)"), a4("CARETTRIM", "(\\s*)".concat(s5[i5.LONECARET], "\\s+"), !0), t10.caretTrimReplace = "$1^", a4("CARET", "^".concat(s5[i5.LONECARET]).concat(s5[i5.XRANGEPLAIN], "$")), a4("CARETLOOSE", "^".concat(s5[i5.LONECARET]).concat(s5[i5.XRANGEPLAINLOOSE], "$")), a4("COMPARATORLOOSE", "^".concat(s5[i5.GTLT], "\\s*(").concat(s5[i5.LOOSEPLAIN], ")$|^$")), a4("COMPARATOR", "^".concat(s5[i5.GTLT], "\\s*(").concat(s5[i5.FULLPLAIN], ")$|^$")), a4("COMPARATORTRIM", "(\\s*)".concat(s5[i5.GTLT], "\\s*(").concat(s5[i5.LOOSEPLAIN], "|").concat(s5[i5.XRANGEPLAIN], ")"), !0), t10.comparatorTrimReplace = "$1$2$3", a4("HYPHENRANGE", "^\\s*(".concat(s5[i5.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(s5[i5.XRANGEPLAIN], ")") + "\\s*$"), a4("HYPHENRANGELOOSE", "^\\s*(".concat(s5[i5.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(s5[i5.XRANGEPLAINLOOSE], ")") + "\\s*$"), a4("STAR", "(<|>)?=?\\s*\\*"), a4("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a4("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
const { MAX_LENGTH: te2 , MAX_SAFE_INTEGER: ne3  } = Y2, { re: re2 , t: se2  } = J2, { compareIdentifiers: ie2  } = ee1;
class oe2 {
    constructor(e14, t10){
        if (t10 && "object" == typeof t10 || (t10 = {
            loose: !!t10,
            includePrerelease: !1
        }), e14 instanceof oe2) {
            if (e14.loose === !!t10.loose && e14.includePrerelease === !!t10.includePrerelease) return e14;
            e14 = e14.version;
        } else if ("string" != typeof e14) throw new TypeError("Invalid Version: ".concat(e14));
        if (e14.length > te2) throw new TypeError("version is longer than ".concat(te2, " characters"));
        Q3("SemVer", e14, t10), this.options = t10, this.loose = !!t10.loose, this.includePrerelease = !!t10.includePrerelease;
        const n5 = e14.trim().match(t10.loose ? re2[se2.LOOSE] : re2[se2.FULL]);
        if (!n5) throw new TypeError("Invalid Version: ".concat(e14));
        if (this.raw = e14, this.major = +n5[1], this.minor = +n5[2], this.patch = +n5[3], this.major > ne3 || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > ne3 || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > ne3 || this.patch < 0) throw new TypeError("Invalid patch version");
        n5[4] ? this.prerelease = n5[4].split(".").map((e15)=>{
            if (/^[0-9]+$/.test(e15)) {
                const t11 = +e15;
                if (t11 >= 0 && t11 < ne3) return t11;
            }
            return e15;
        }) : this.prerelease = [], this.build = n5[5] ? n5[5].split(".") : [], this.format();
    }
    format() {
        return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
        return this.version;
    }
    compare(e) {
        if (Q3("SemVer.compare", this.version, this.options, e), !(e instanceof oe2)) {
            if ("string" == typeof e && e === this.version) return 0;
            e = new oe2(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
    }
    compareMain(e) {
        return e instanceof oe2 || (e = new oe2(e, this.options)), ie2(this.major, e.major) || ie2(this.minor, e.minor) || ie2(this.patch, e.patch);
    }
    comparePre(e) {
        if (e instanceof oe2 || (e = new oe2(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t11 = 0;
        do {
            const n6 = this.prerelease[t11], r4 = e.prerelease[t11];
            if (Q3("prerelease compare", t11, n6, r4), (void 0) === n6 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === n6) return -1;
            if (n6 !== r4) return ie2(n6, r4);
        }while (++t11)
    }
    compareBuild(e) {
        e instanceof oe2 || (e = new oe2(e, this.options));
        let t11 = 0;
        do {
            const n6 = this.build[t11], r4 = e.build[t11];
            if (Q3("prerelease compare", t11, n6, r4), (void 0) === n6 && (void 0) === r4) return 0;
            if ((void 0) === r4) return 1;
            if ((void 0) === n6) return -1;
            if (n6 !== r4) return ie2(n6, r4);
        }while (++t11)
    }
    inc(e, t) {
        switch(e){
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                break;
            case "prerelease":
                0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                break;
            case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
            case "pre":
                if (0 === this.prerelease.length) this.prerelease = [
                    0
                ];
                else {
                    let e15 = this.prerelease.length;
                    for(; (--e15) >= 0;)"number" == typeof this.prerelease[e15] && (this.prerelease[e15]++, e15 = -2);
                    -1 === e15 && this.prerelease.push(0);
                }
                t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [
                    t,
                    0
                ]) : this.prerelease = [
                    t,
                    0
                ]);
                break;
            default:
                throw new Error("invalid increment argument: ".concat(e));
        }
        return this.format(), this.raw = this.version, this;
    }
}
var ae2 = oe2;
var ue2 = (e15, t11, n6)=>new ae2(e15, n6).compare(new ae2(t11, n6))
;
var ce3 = (e15, t11, n6)=>ue2(e15, t11, n6) < 0
;
var le2 = (e15, t11, n6)=>ue2(e15, t11, n6) >= 0
, pe3 = "2.2.1", De3 = t2(function(e15, t11) {
    function n6() {
        for(var e16 = [], t12 = 0; t12 < arguments.length; t12++)e16[t12] = arguments[t12];
    }
    function r4() {
        return "undefined" != typeof WeakMap ? new WeakMap : {
            add: n6,
            delete: n6,
            get: n6,
            set: n6,
            has: function(e16) {
                return !1;
            }
        };
    }
    Object.defineProperty(t11, "__esModule", {
        value: !0
    });
    var s5 = Object.prototype.hasOwnProperty, i5 = function(e16, t12) {
        return s5.call(e16, t12);
    };
    function o4(e16, t12) {
        for(var n7 in t12)i5(t12, n7) && (e16[n7] = t12[n7]);
        return e16;
    }
    var a4 = /^[ \t]*(?:\r\n|\r|\n)/, u4 = /(?:\r\n|\r|\n)[ \t]*$/, c4 = /^(?:[\r\n]|$)/, l4 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p4 = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function D4(e16, t12, n7) {
        var r5 = 0, s6 = e16[0].match(l4);
        s6 && (r5 = s6[1].length);
        var i6 = new RegExp("(\\r\\n|\\r|\\n).{0," + r5 + "}", "g");
        t12 && (e16 = e16.slice(1));
        var o5 = n7.newline, c5 = n7.trimLeadingNewline, p5 = n7.trimTrailingNewline, D4 = "string" == typeof o5, h4 = e16.length;
        return e16.map(function(e17, t13) {
            return (e17 = e17.replace(i6, "$1"), 0 === t13 && c5 && (e17 = e17.replace(a4, "")), t13 === h4 - 1 && p5 && (e17 = e17.replace(u4, "")), D4 && (e17 = e17.replace(/\r\n|\n|\r/g, function(e18) {
                return o5;
            })), e17);
        });
    }
    function h4(e16, t12) {
        for(var n7 = "", r5 = 0, s6 = e16.length; r5 < s6; r5++)n7 += e16[r5], r5 < s6 - 1 && (n7 += t12[r5]);
        return n7;
    }
    function d4(e16) {
        return i5(e16, "raw") && i5(e16, "length");
    }
    var f4 = function e15(t12) {
        var n7 = r4(), s6 = r4();
        return o4(function r5(i6) {
            for(var a5 = [], u5 = 1; u5 < arguments.length; u5++)a5[u5 - 1] = arguments[u5];
            if (d4(i6)) {
                var l5 = i6, m4 = (a5[0] === r5 || a5[0] === f4) && p4.test(l5[0]) && c4.test(l5[1]), g4 = m4 ? s6 : n7, E4 = g4.get(l5);
                if ((E4 || (E4 = D4(l5, m4, t12), g4.set(l5, E4)), 0 === a5.length)) return E4[0];
                var C4 = h4(E4, m4 ? a5.slice(1) : a5);
                return C4;
            }
            return e15(o4(o4({
            }, t12), i6 || {
            }));
        }, {
            string: function(e16) {
                return D4([
                    e16
                ], !1, t12)[0];
            }
        });
    }({
        trimLeadingNewline: !0,
        trimTrailingNewline: !0
    });
    t11.outdent = f4, t11.default = f4;
    try {
        e15.exports = f4, Object.defineProperty(f4, "__esModule", {
            value: !0
        }), f4.default = f4, f4.outdent = f4;
    } catch (e) {
    }
});
const { outdent: Ce3  } = De3, Te2 = {
    cursorOffset: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: -1,
        range: {
            start: -1,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(Ee1()),
        cliCategory: "Editor"
    },
    endOfLine: {
        since: "1.15.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "1.15.0",
                value: "auto"
            },
            {
                since: "2.0.0",
                value: "lf"
            }
        ],
        description: "Which end of line characters to apply.",
        choices: [
            {
                value: "lf",
                description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
            },
            {
                value: "crlf",
                description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
            },
            {
                value: "cr",
                description: "Carriage Return character only (\\r), used very rarely"
            },
            {
                value: "auto",
                description: Ce3(ge2())
            }
        ]
    },
    filepath: {
        since: "1.4.0",
        category: "Special",
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: "Other",
        cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
        since: "1.8.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: "Other"
    },
    parser: {
        since: "0.0.10",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "0.0.10",
                value: "babylon"
            },
            {
                since: "1.13.0",
                value: void 0
            }
        ],
        description: "Which parser to use.",
        exception: (e15)=>"string" == typeof e15 || "function" == typeof e15
        ,
        choices: [
            {
                value: "flow",
                description: "Flow"
            },
            {
                value: "babel",
                since: "1.16.0",
                description: "JavaScript"
            },
            {
                value: "babel-flow",
                since: "1.16.0",
                description: "Flow"
            },
            {
                value: "babel-ts",
                since: "2.0.0",
                description: "TypeScript"
            },
            {
                value: "typescript",
                since: "1.4.0",
                description: "TypeScript"
            },
            {
                value: "espree",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "meriyah",
                since: "2.2.0",
                description: "JavaScript"
            },
            {
                value: "css",
                since: "1.7.1",
                description: "CSS"
            },
            {
                value: "less",
                since: "1.7.1",
                description: "Less"
            },
            {
                value: "scss",
                since: "1.7.1",
                description: "SCSS"
            },
            {
                value: "json",
                since: "1.5.0",
                description: "JSON"
            },
            {
                value: "json5",
                since: "1.13.0",
                description: "JSON5"
            },
            {
                value: "json-stringify",
                since: "1.13.0",
                description: "JSON.stringify"
            },
            {
                value: "graphql",
                since: "1.5.0",
                description: "GraphQL"
            },
            {
                value: "markdown",
                since: "1.8.0",
                description: "Markdown"
            },
            {
                value: "mdx",
                since: "1.15.0",
                description: "MDX"
            },
            {
                value: "vue",
                since: "1.10.0",
                description: "Vue"
            },
            {
                value: "yaml",
                since: "1.14.0",
                description: "YAML"
            },
            {
                value: "glimmer",
                since: null,
                description: "Handlebars"
            },
            {
                value: "html",
                since: "1.15.0",
                description: "HTML"
            },
            {
                value: "angular",
                since: "1.15.0",
                description: "Angular"
            },
            {
                value: "lwc",
                since: "1.17.0",
                description: "Lightning Web Components"
            }
        ]
    },
    plugins: {
        since: "1.10.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (e15)=>"string" == typeof e15 || "object" == typeof e15
        ,
        cliName: "plugin",
        cliCategory: "Config"
    },
    pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: !0,
        default: [
            {
                value: []
            }
        ],
        category: "Global",
        description: Ce3(me2()),
        exception: (e15)=>"string" == typeof e15 || "object" == typeof e15
        ,
        cliName: "plugin-search-dir",
        cliCategory: "Config"
    },
    printWidth: {
        since: "0.0.0",
        category: "Global",
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    rangeEnd: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 1 / 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(fe2()),
        cliCategory: "Editor"
    },
    rangeStart: {
        since: "1.4.0",
        category: "Special",
        type: "int",
        default: 0,
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        },
        description: Ce3(de2()),
        cliCategory: "Editor"
    },
    requirePragma: {
        since: "1.7.0",
        category: "Special",
        type: "boolean",
        default: !1,
        description: Ce3(he2()),
        cliCategory: "Other"
    },
    tabWidth: {
        type: "int",
        category: "Global",
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
            start: 0,
            end: 1 / 0,
            step: 1
        }
    },
    useTabs: {
        since: "1.0.0",
        category: "Global",
        type: "boolean",
        default: !1,
        description: "Indent with tabs instead of spaces."
    },
    embeddedLanguageFormatting: {
        since: "2.1.0",
        category: "Global",
        type: "choice",
        default: [
            {
                since: "2.1.0",
                value: "auto"
            }
        ],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [
            {
                value: "auto",
                description: "Format embedded code if Prettier can automatically identify it."
            },
            {
                value: "off",
                description: "Never automatically format embedded code."
            }
        ]
    }
};
const ye3 = {
    compare: ue2,
    lt: ce3,
    gte: le2
}, _e2 = {
    CATEGORY_CONFIG: "Config",
    CATEGORY_EDITOR: "Editor",
    CATEGORY_FORMAT: "Format",
    CATEGORY_OTHER: "Other",
    CATEGORY_OUTPUT: "Output",
    CATEGORY_GLOBAL: "Global",
    CATEGORY_SPECIAL: "Special",
    options: Te2
}.options;
var be3 = {
    getSupportInfo: function({ plugins: e15 = [] , showUnreleased: t11 = !1 , showDeprecated: n6 = !1 , showInternal: r4 = !1  } = {
    }) {
        const s5 = pe3.split("-", 1)[0], i5 = e15.reduce((e16, t12)=>e16.concat(t12.languages || [])
        , []).filter(a4), o4 = ((e16, t12)=>Object.entries(e16).map(([e17, n7])=>Object.assign({
                    [t12]: e17
                }, n7)
            )
        )(Object.assign({
        }, ...e15.map(({ options: e16  })=>e16
        ), _e2), "name").filter((e16)=>a4(e16) && u4(e16)
        ).sort((e16, t12)=>e16.name === t12.name ? 0 : e16.name < t12.name ? -1 : 1
        ).map(function(e16) {
            if (r4) return e16;
            return function(e17, t12) {
                if (null == e17) return {
                };
                var n7, r5, s6 = {
                }, i6 = Object.keys(e17);
                for(r5 = 0; r5 < i6.length; r5++)n7 = i6[r5], t12.indexOf(n7) >= 0 || (s6[n7] = e17[n7]);
                return s6;
            }(e16, [
                "cliName",
                "cliCategory",
                "cliDescription"
            ]);
        }).map((t12)=>{
            t12 = Object.assign({
            }, t12), Array.isArray(t12.default) && (t12.default = 1 === t12.default.length ? t12.default[0].value : t12.default.filter(a4).sort((e16, t13)=>ye3.compare(t13.since, e16.since)
            )[0].value), Array.isArray(t12.choices) && (t12.choices = t12.choices.filter((e16)=>a4(e16) && u4(e16)
            ), "parser" === t12.name && (function(e16, t13, n7) {
                const r5 = new Set(e16.choices.map((e17)=>e17.value
                ));
                for (const s6 of t13)if (s6.parsers) for (const t14 of s6.parsers)if (!r5.has(t14)) {
                    r5.add(t14);
                    const i6 = n7.find((e17)=>e17.parsers && e17.parsers[t14]
                    );
                    let o5 = s6.name;
                    i6 && i6.name && (o5 += " (plugin: ".concat(i6.name, ")")), e16.choices.push({
                        value: t14,
                        description: o5
                    });
                }
            })(t12, i5, e15));
            const n7 = e15.filter((e16)=>e16.defaultOptions && (void 0) !== e16.defaultOptions[t12.name]
            ).reduce((e16, n8)=>(e16[n8.name] = n8.defaultOptions[t12.name], e16)
            , {
            });
            return Object.assign({
            }, t12, {
                pluginDefaults: n7
            });
        });
        return {
            languages: i5,
            options: o4
        };
        function a4(e16) {
            return t11 || !("since" in e16) || e16.since && ye3.gte(s5, e16.since);
        }
        function u4(e16) {
            return n6 || !("deprecated" in e16) || e16.deprecated && ye3.lt(s5, e16.deprecated);
        }
    }
};
const { getSupportInfo: Fe2  } = be3, Ae2 = /[^\x20-\x7F]/;
var Ve2 = {
    inferParserByLanguage: function(e15, t11) {
        const { languages: n6  } = Fe2({
            plugins: t11.plugins
        }), r4 = n6.find(({ name: t12  })=>t12.toLowerCase() === e15
        ) || n6.find(({ aliases: t12  })=>Array.isArray(t12) && t12.includes(e15)
        ) || n6.find(({ extensions: t12  })=>Array.isArray(t12) && t12.includes(".".concat(e15))
        );
        return r4 && r4.parsers[0];
    },
    replaceEndOfLineWith: function(e15, t11) {
        const n6 = [];
        for (const r4 of e15.split("\n"))0 !== n6.length && n6.push(t11), n6.push(r4);
        return n6;
    },
    getStringWidth: function(e15) {
        return e15 ? Ae2.test(e15) ? y3(e15) : e15.length : 0;
    },
    getMaxContinuousCount: function(e15, t11) {
        const n6 = e15.match(new RegExp("(".concat(a3(t11), ")+"), "g"));
        return null === n6 ? 0 : n6.reduce((e16, n7)=>Math.max(e16, n7.length / t11.length)
        , 0);
    },
    getMinNotPresentContinuousCount: function(e15, t11) {
        const n6 = e15.match(new RegExp("(".concat(a3(t11), ")+"), "g"));
        if (null === n6) return 0;
        const r4 = new Map;
        let s5 = 0;
        for (const e16 of n6){
            const n7 = e16.length / t11.length;
            r4.set(n7, !0), n7 > s5 && (s5 = n7);
        }
        for(let e17 = 1; e17 < s5; e17++)if (!r4.get(e17)) return e17;
        return s5 + 1;
    },
    getPenultimate: (e15)=>e15[e15.length - 2]
    ,
    getLast: (e15)=>e15[e15.length - 1]
    ,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ie1,
    getNextNonSpaceNonCommentCharacterIndex: qe2,
    getNextNonSpaceNonCommentCharacter: function(e15, t11, n6) {
        return e15.charAt(qe2(e15, t11, n6));
    },
    skip: ve2,
    skipWhitespace: we2,
    skipSpaces: ke2,
    skipToLineEnd: Ne2,
    skipEverythingButNewLine: xe1,
    skipInlineComment: Oe1,
    skipTrailingComment: Re1,
    skipNewline: Le2,
    isNextLineEmptyAfterIndex: Be1,
    isNextLineEmpty: function(e15, t11, n6) {
        return Be1(e15, n6(t11));
    },
    isPreviousLineEmpty: function(e15, t11, n6) {
        let r4 = n6(t11) - 1;
        return (r4 = ke2(e15, r4, {
            backwards: !0
        }), r4 = Le2(e15, r4, {
            backwards: !0
        }), r4 = ke2(e15, r4, {
            backwards: !0
        }), r4 !== Le2(e15, r4, {
            backwards: !0
        }));
    },
    hasNewline: Pe2,
    hasNewlineInRange: function(e15, t11, n6) {
        for(let r4 = t11; r4 < n6; ++r4)if ("\n" === e15.charAt(r4)) return !0;
        return !1;
    },
    hasSpaces: function(e15, t11, n6) {
        return ke2(e15, (n6 = n6 || {
        }).backwards ? t11 - 1 : t11, n6) !== t11;
    },
    getAlignmentSize: $e1,
    getIndentSize: function(e15, t11) {
        const n6 = e15.lastIndexOf("\n");
        return -1 === n6 ? 0 : $e1(e15.slice(n6 + 1).match(/^[\t ]*/)[0], t11);
    },
    getPreferredQuote: Me2,
    printString: function(e15, t11, n6) {
        const r4 = e15.slice(1, -1), s5 = !r4.includes('"') && !r4.includes("'"), i5 = "json" === t11.parser ? '"' : t11.__isInHtmlAttribute ? "'" : Me2(e15, t11.singleQuote ? "'" : '"');
        return n6 ? s5 ? i5 + r4 + i5 : e15 : Ue1(r4, i5, !("css" === t11.parser || "less" === t11.parser || "scss" === t11.parser || t11.embeddedInHtml));
    },
    printNumber: function(e15) {
        return e15.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    },
    isNodeIgnoreComment: function(e15) {
        return "prettier-ignore" === e15.value.trim();
    },
    makeString: Ue1,
    addLeadingComment: function(e15, t11) {
        t11.leading = !0, t11.trailing = !1, Ge(e15, t11);
    },
    addDanglingComment: function(e15, t11, n6) {
        t11.leading = !1, t11.trailing = !1, n6 && (t11.marker = n6), Ge(e15, t11);
    },
    addTrailingComment: function(e15, t11) {
        t11.leading = !1, t11.trailing = !0, Ge(e15, t11);
    },
    isFrontMatterNode: function(e15) {
        return e15 && "front-matter" === e15.type;
    },
    getShebang: function(e15) {
        if (!e15.startsWith("#!")) return "";
        const t11 = e15.indexOf("\n");
        return -1 === t11 ? e15 : e15.slice(0, t11);
    }
};
const { getStringWidth: He2  } = Ve2, { convertEndOfLineToChars: Xe2  } = je2, { concat: ze2 , fill: We2 , cursor: Qe2  } = f3;
function tt2(e15, t11, n6, r4, s5) {
    let i5 = t11.length;
    const o4 = [
        e15
    ], a4 = [];
    for(; n6 >= 0;){
        if (0 === o4.length) {
            if (0 === i5) return !0;
            o4.push(t11[i5 - 1]), i5--;
            continue;
        }
        const [e16, u4, c4] = o4.pop();
        if ("string" == typeof c4) a4.push(c4), n6 -= He2(c4);
        else switch(c4.type){
            case "concat":
                for(let t12 = c4.parts.length - 1; t12 >= 0; t12--)o4.push([
                    e16,
                    u4,
                    c4.parts[t12]
                ]);
                break;
            case "indent":
                o4.push([
                    Je(e16, r4),
                    u4,
                    c4.contents
                ]);
                break;
            case "align":
                o4.push([
                    Ze(e16, c4.n, r4),
                    u4,
                    c4.contents
                ]);
                break;
            case "trim":
                n6 += et2(a4);
                break;
            case "group":
                if (s5 && c4.break) return !1;
                o4.push([
                    e16,
                    c4.break ? 1 : u4,
                    c4.contents
                ]), c4.id && (Ye[c4.id] = o4[o4.length - 1][1]);
                break;
            case "fill":
                for(let t13 = c4.parts.length - 1; t13 >= 0; t13--)o4.push([
                    e16,
                    u4,
                    c4.parts[t13]
                ]);
                break;
            case "if-break":
                {
                    const t14 = c4.groupId ? Ye[c4.groupId] : u4;
                    1 === t14 && c4.breakContents && o4.push([
                        e16,
                        u4,
                        c4.breakContents
                    ]), 2 === t14 && c4.flatContents && o4.push([
                        e16,
                        u4,
                        c4.flatContents
                    ]);
                    break;
                }
            case "line":
                switch(u4){
                    case 2:
                        if (!c4.hard) {
                            c4.soft || (a4.push(" "), n6 -= 1);
                            break;
                        }
                        return !0;
                    case 1:
                        return !0;
                }
        }
    }
    return !1;
}
var nt2 = {
    printDocToString: function(e15, t11) {
        Ye = {
        };
        const n6 = t11.printWidth, r4 = Xe2(t11.endOfLine);
        let s5 = 0;
        const i5 = [
            [
                {
                    value: "",
                    length: 0,
                    queue: []
                },
                1,
                e15
            ]
        ], o4 = [];
        let a4 = !1, u4 = [];
        for(; 0 !== i5.length;){
            const [e16, c4, l4] = i5.pop();
            if ("string" == typeof l4) {
                const e17 = "\n" !== r4 && l4.includes("\n") ? l4.replace(/\n/g, r4) : l4;
                o4.push(e17), s5 += He2(e17);
            } else switch(l4.type){
                case "cursor":
                    o4.push(Qe2.placeholder);
                    break;
                case "concat":
                    for(let t12 = l4.parts.length - 1; t12 >= 0; t12--)i5.push([
                        e16,
                        c4,
                        l4.parts[t12]
                    ]);
                    break;
                case "indent":
                    i5.push([
                        Je(e16, t11),
                        c4,
                        l4.contents
                    ]);
                    break;
                case "align":
                    i5.push([
                        Ze(e16, l4.n, t11),
                        c4,
                        l4.contents
                    ]);
                    break;
                case "trim":
                    s5 -= et2(o4);
                    break;
                case "group":
                    switch(c4){
                        case 2:
                            if (!a4) {
                                i5.push([
                                    e16,
                                    l4.break ? 1 : 2,
                                    l4.contents
                                ]);
                                break;
                            }
                        case 1:
                            {
                                a4 = !1;
                                const r5 = [
                                    e16,
                                    2,
                                    l4.contents
                                ], o5 = n6 - s5;
                                if (!l4.break && tt2(r5, i5, o5, t11)) i5.push(r5);
                                else if (l4.expandedStates) {
                                    const n7 = l4.expandedStates[l4.expandedStates.length - 1];
                                    if (l4.break) {
                                        i5.push([
                                            e16,
                                            1,
                                            n7
                                        ]);
                                        break;
                                    }
                                    for(let r6 = 1; r6 < l4.expandedStates.length + 1; r6++){
                                        if (r6 >= l4.expandedStates.length) {
                                            i5.push([
                                                e16,
                                                1,
                                                n7
                                            ]);
                                            break;
                                        }
                                        {
                                            const n8 = [
                                                e16,
                                                2,
                                                l4.expandedStates[r6]
                                            ];
                                            if (tt2(n8, i5, o5, t11)) {
                                                i5.push(n8);
                                                break;
                                            }
                                        }
                                    }
                                } else i5.push([
                                    e16,
                                    1,
                                    l4.contents
                                ]);
                                break;
                            }
                    }
                    l4.id && (Ye[l4.id] = i5[i5.length - 1][1]);
                    break;
                case "fill":
                    {
                        const r5 = n6 - s5, { parts: o5  } = l4;
                        if (0 === o5.length) break;
                        const [a5, u5] = o5, p4 = [
                            e16,
                            2,
                            a5
                        ], D4 = [
                            e16,
                            1,
                            a5
                        ], h4 = tt2(p4, [], r5, t11, !0);
                        if (1 === o5.length) {
                            h4 ? i5.push(p4) : i5.push(D4);
                            break;
                        }
                        const d4 = [
                            e16,
                            2,
                            u5
                        ], f4 = [
                            e16,
                            1,
                            u5
                        ];
                        if (2 === o5.length) {
                            h4 ? (i5.push(d4), i5.push(p4)) : (i5.push(f4), i5.push(D4));
                            break;
                        }
                        o5.splice(0, 2);
                        const m4 = [
                            e16,
                            c4,
                            We2(o5)
                        ], g4 = o5[0];
                        tt2([
                            e16,
                            2,
                            ze2([
                                a5,
                                u5,
                                g4
                            ])
                        ], [], r5, t11, !0) ? (i5.push(m4), i5.push(d4), i5.push(p4)) : h4 ? (i5.push(m4), i5.push(f4), i5.push(p4)) : (i5.push(m4), i5.push(f4), i5.push(D4));
                        break;
                    }
                case "if-break":
                    {
                        const t13 = l4.groupId ? Ye[l4.groupId] : c4;
                        1 === t13 && l4.breakContents && i5.push([
                            e16,
                            c4,
                            l4.breakContents
                        ]), 2 === t13 && l4.flatContents && i5.push([
                            e16,
                            c4,
                            l4.flatContents
                        ]);
                        break;
                    }
                case "line-suffix":
                    u4.push([
                        e16,
                        c4,
                        l4.contents
                    ]);
                    break;
                case "line-suffix-boundary":
                    u4.length > 0 && i5.push([
                        e16,
                        c4,
                        {
                            type: "line",
                            hard: !0
                        }
                    ]);
                    break;
                case "line":
                    switch(c4){
                        case 2:
                            if (!l4.hard) {
                                l4.soft || (o4.push(" "), s5 += 1);
                                break;
                            }
                            a4 = !0;
                        case 1:
                            if (u4.length) {
                                i5.push([
                                    e16,
                                    c4,
                                    l4
                                ]), i5.push(...u4.reverse()), u4 = [];
                                break;
                            }
                            l4.literal ? e16.root ? (o4.push(r4, e16.root.value), s5 = e16.root.length) : (o4.push(r4), s5 = 0) : (s5 -= et2(o4), o4.push(r4 + e16.value), s5 = e16.length);
                    }
            }
            0 === i5.length && u4.length && (i5.push(...u4.reverse()), u4 = []);
        }
        const c4 = o4.indexOf(Qe2.placeholder);
        if (-1 !== c4) {
            const e16 = o4.indexOf(Qe2.placeholder, c4 + 1), t12 = o4.slice(0, c4).join(""), n7 = o4.slice(c4 + 1, e16).join("");
            return {
                formatted: t12 + n7 + o4.slice(e16 + 1).join(""),
                cursorNodeStart: t12.length,
                cursorNodeText: n7
            };
        }
        return {
            formatted: o4.join("")
        };
    }
};
var mt2 = {
    builders: f3,
    printer: nt2,
    utils: {
        isEmpty: function(e15) {
            return "string" == typeof e15 && 0 === e15.length;
        },
        willBreak: function(e15) {
            return ut1(e15, lt, !1);
        },
        isLineNext: function(e15) {
            return ut1(e15, ct, !1);
        },
        traverseDoc: ot1,
        findInDoc: ut1,
        mapDoc: at1,
        propagateBreaks: function(e15) {
            const t11 = new Set, n6 = [];
            ot1(e15, function(e16) {
                if (("break-parent" === e16.type && pt(n6), "group" === e16.type)) {
                    if ((n6.push(e16), t11.has(e16))) return !1;
                    t11.add(e16);
                }
            }, function(e16) {
                if ("group" === e16.type) {
                    n6.pop().break && pt(n6);
                }
            }, !0);
        },
        removeLines: function(e15) {
            return at1(e15, Dt1);
        },
        stripTrailingHardline: function e15(t11, n6 = !1) {
            if ("concat" === t11.type && 0 !== t11.parts.length) {
                const r4 = n6 ? function(e16) {
                    let t12, { parts: n7  } = e16;
                    for(let r5 = e16.parts.length; r5 > 0 && !t12; r5--)t12 = n7[r5 - 1];
                    return "group" === t12.type && (n7 = t12.contents.parts), n7;
                }(t11) : t11.parts, s5 = r4[r4.length - 1];
                if ("concat" === s5.type) return 2 === s5.parts.length && s5.parts[0].hard && "break-parent" === s5.parts[1].type ? {
                    type: "concat",
                    parts: r4.slice(0, -1)
                } : {
                    type: "concat",
                    parts: t11.parts.slice(0, -1).concat(e15(s5))
                };
            }
            return t11;
        },
        normalizeParts: ht1,
        normalizeDoc: function(e16) {
            return at1(e16, (e17)=>e17.parts ? Object.assign({
                }, e17, {
                    parts: ht1(e17.parts)
                }) : e17
            );
        },
        replaceNewlinesWithLiterallines: function(e16) {
            return at1(e16, (e17)=>"string" == typeof e17 && e17.includes("\n") ? st1(e17.split(/(\n)/g).map((e18, t11)=>t11 % 2 == 0 ? e18 : rt2
                )) : e17
            );
        }
    },
    debug: {
        printDocToDebug: (e15)=>ft1(dt(e15))
    }
};
const { builders: { hardline: gt2 , concat: Et2 , markAsRoot: Ct2  }  } = mt2, Tt2 = {
    "---": "yaml",
    "+++": "toml"
};
var yt2 = {
    parse: function(e15) {
        const t11 = Object.keys(Tt2).map(a3).join("|"), n6 = e15.match(new RegExp("^(".concat(t11, ")([^\\n]*)\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));
        if (null === n6) return {
            frontMatter: null,
            content: e15
        };
        const [r4, s5, i5, o4] = n6;
        let u4 = Tt2[s5];
        return ("toml" !== u4 && i5 && i5.trim() && (u4 = i5.trim()), {
            frontMatter: {
                type: "front-matter",
                lang: u4,
                value: o4,
                raw: r4.replace(/\n$/, "")
            },
            content: r4.replace(/[^\n]/g, " ") + e15.slice(r4.length)
        });
    },
    print: function(e15, t11) {
        if ("yaml" === e15.lang) {
            const n6 = e15.value.trim(), r4 = n6 ? t11(n6, {
                parser: "yaml"
            }, {
                stripTrailingHardline: !0
            }) : "";
            return Ct2(Et2([
                "---",
                gt2,
                r4,
                r4 ? gt2 : "",
                "---"
            ]));
        }
    }
};
const { inferParserByLanguage: bt2 , isFrontMatterNode: Ft2  } = Ve2, { CSS_DISPLAY_TAGS: At2 , CSS_DISPLAY_DEFAULT: vt2 , CSS_WHITE_SPACE_TAGS: wt2 , CSS_WHITE_SPACE_DEFAULT: kt2  } = {
    CSS_DISPLAY_TAGS: {
        area: "none",
        base: "none",
        basefont: "none",
        datalist: "none",
        head: "none",
        link: "none",
        meta: "none",
        noembed: "none",
        noframes: "none",
        param: "block",
        rp: "none",
        script: "block",
        source: "block",
        style: "none",
        template: "inline",
        track: "block",
        title: "none",
        html: "block",
        body: "block",
        address: "block",
        blockquote: "block",
        center: "block",
        div: "block",
        figure: "block",
        figcaption: "block",
        footer: "block",
        form: "block",
        header: "block",
        hr: "block",
        legend: "block",
        listing: "block",
        main: "block",
        p: "block",
        plaintext: "block",
        pre: "block",
        xmp: "block",
        slot: "contents",
        ruby: "ruby",
        rt: "ruby-text",
        article: "block",
        aside: "block",
        h1: "block",
        h2: "block",
        h3: "block",
        h4: "block",
        h5: "block",
        h6: "block",
        hgroup: "block",
        nav: "block",
        section: "block",
        dir: "block",
        dd: "block",
        dl: "block",
        dt: "block",
        ol: "block",
        ul: "block",
        li: "list-item",
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell",
        fieldset: "block",
        button: "inline-block",
        details: "block",
        summary: "block",
        dialog: "block",
        meter: "inline-block",
        progress: "inline-block",
        object: "inline-block",
        video: "inline-block",
        audio: "inline-block",
        select: "inline-block",
        option: "block",
        optgroup: "block"
    },
    CSS_DISPLAY_DEFAULT: "inline",
    CSS_WHITE_SPACE_TAGS: {
        listing: "pre",
        plaintext: "pre",
        pre: "pre",
        xmp: "pre",
        nobr: "nowrap",
        table: "initial",
        textarea: "pre-wrap"
    },
    CSS_WHITE_SPACE_DEFAULT: "normal"
}, Nt2 = Lt1([
    "a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "command",
    "content",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "image",
    "img",
    "input",
    "ins",
    "isindex",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "math",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "multicol",
    "nav",
    "nextid",
    "nobr",
    "noembed",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "plaintext",
    "pre",
    "progress",
    "q",
    "rb",
    "rbc",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "slot",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "svg",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp"
]), xt2 = function(e15, t11) {
    const n6 = Object.create(null);
    for (const r4 of Object.keys(e15))n6[r4] = t11(e15[r4], r4);
    return n6;
}(_t, Lt1), Ot2 = new Set([
    "\t",
    "\n",
    "\f",
    "\r",
    " "
]), Rt2 = (e15)=>e15.replace(/[\t\n\f\r ]+$/, "")
;
function Pt2(e15, t11) {
    return !("ieConditionalComment" !== e15.type || !e15.lastChild || e15.lastChild.isSelfClosing || e15.lastChild.endSourceSpan) || ("ieConditionalComment" === e15.type && !e15.complete || (!(!zt3(e15) || !e15.children.some((e16)=>"text" !== e16.type && "interpolation" !== e16.type
    )) || !(!Kt2(e15, t11) || It(e15) || "interpolation" === e15.type)));
}
function qt3(e15) {
    return Qt3(e15).startsWith("pre");
}
function zt3(e15) {
    return Qt3(e15).startsWith("pre");
}
function Qt3(e15) {
    return "element" === e15.type && (!e15.namespace || Wt(e15)) && wt2[e15.name] || kt2;
}
var en1 = {
    HTML_ELEMENT_ATTRIBUTES: xt2,
    HTML_TAGS: Nt2,
    htmlTrim: (e15)=>((e16)=>e16.replace(/^[\t\n\f\r ]+/, "")
        )(Rt2(e15))
    ,
    htmlTrimPreserveIndentation: (e15)=>((e16)=>e16.replace(/^[\t\f\r ]*?\n/g, "")
        )(Rt2(e15))
    ,
    splitByHtmlWhitespace: (e15)=>e15.split(/[\t\n\f\r ]+/)
    ,
    hasHtmlWhitespace: (e15)=>/[\t\n\f\r ]/.test(e15)
    ,
    getLeadingAndTrailingHtmlWhitespace: (e15)=>{
        const [, t11, n6, r4] = e15.match(/^([\t\n\f\r ]*)([\S\s]*?)([\t\n\f\r ]*)$/);
        return {
            leadingWhitespace: t11,
            trailingWhitespace: r4,
            text: n6
        };
    },
    canHaveInterpolation: function(e15) {
        return e15.children && !It(e15);
    },
    countChars: function(e15, t11) {
        let n6 = 0;
        for(let r4 = 0; r4 < e15.length; r4++)e15[r4] === t11 && n6++;
        return n6;
    },
    countParents: function(e15, t11) {
        let n6 = 0;
        for(let r4 = e15.stack.length - 1; r4 >= 0; r4--){
            const s5 = e15.stack[r4];
            s5 && "object" == typeof s5 && !Array.isArray(s5) && t11(s5) && n6++;
        }
        return n6;
    },
    dedentString: function(e15, t11 = function(e16) {
        let t12 = 1 / 0;
        for (const r4 of e16.split("\n")){
            if (0 === r4.length) continue;
            if (!Ot2.has(r4[0])) return 0;
            const e17 = (n6 = r4, n6.match(/^[\t\n\f\r ]*/)[0]).length;
            r4.length !== e17 && e17 < t12 && (t12 = e17);
        }
        var n6;
        return t12 === 1 / 0 ? 0 : t12;
    }(e15)) {
        return 0 === t11 ? e15 : e15.split("\n").map((e16)=>e16.slice(t11)
        ).join("\n");
    },
    forceBreakChildren: $t2,
    forceBreakContent: function(e15) {
        return $t2(e15) || "element" === e15.type && 0 !== e15.children.length && ([
            "body",
            "script",
            "style"
        ].includes(e15.name) || e15.children.some((e16)=>(function(e17) {
                return e17.children && e17.children.some((e18)=>"text" !== e18.type
                );
            })(e16)
        )) || e15.firstChild && e15.firstChild === e15.lastChild && "text" !== e15.firstChild.type && Gt2(e15.firstChild) && (!e15.lastChild.isTrailingSpaceSensitive || Vt1(e15.lastChild));
    },
    forceNextEmptyLine: function(e15) {
        return Ft2(e15) || e15.next && e15.sourceSpan.end && e15.sourceSpan.end.line + 1 < e15.next.sourceSpan.start.line;
    },
    getLastDescendant: function e15(t11) {
        return t11.lastChild ? e15(t11.lastChild) : t11;
    },
    getNodeCssStyleDisplay: function(e16, t11) {
        if (e16.prev && "comment" === e16.prev.type) {
            const t12 = e16.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
            if (t12) return t12[1];
        }
        let n6 = !1;
        if ("element" === e16.type && "svg" === e16.namespace) {
            if (!function(e17, t12) {
                let n7 = e17;
                for(; n7;){
                    if (t12(n7)) return !0;
                    n7 = n7.parent;
                }
                return !1;
            }(e16, (e17)=>"svg:foreignObject" === e17.fullName
            )) return "svg" === e16.name ? "inline-block" : "block";
            n6 = !0;
        }
        switch(t11.htmlWhitespaceSensitivity){
            case "strict":
                return "inline";
            case "ignore":
                return "block";
            default:
                return "vue" === t11.parser && e16.parent && "root" === e16.parent.type ? "block" : "element" === e16.type && (!e16.namespace || n6 || Wt(e16)) && At2[e16.name] || vt2;
        }
    },
    getNodeCssStyleWhiteSpace: Qt3,
    getPrettierIgnoreAttributeCommentData: function(e16) {
        const t11 = e16.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);
        return !!t11 && (!t11[1] || t11[1].split(/\s+/));
    },
    hasPrettierIgnore: Bt2,
    inferScriptParser: function(e16, t11) {
        return "script" !== e16.name || e16.attrMap.src ? "style" === e16.name ? function(e17) {
            const { lang: t12  } = e17.attrMap;
            return t12 && "postcss" !== t12 && "css" !== t12 ? "scss" === t12 ? "scss" : "less" === t12 ? "less" : void 0 : "css";
        }(e16) : t11 && Kt2(e16, t11) ? Ht1(e16) || !("src" in e16.attrMap) && bt2(e16.attrMap.lang, t11) : void 0 : e16.attrMap.lang || e16.attrMap.type ? Ht1(e16) : "babel";
    },
    isVueCustomBlock: Jt2,
    isVueNonHtmlBlock: Kt2,
    isVueSlotAttribute: function(e16) {
        const t11 = e16.fullName;
        return "#" === t11.charAt(0) || "slot-scope" === t11 || "v-slot" === t11 || t11.startsWith("v-slot:");
    },
    isVueSfcBindingsAttribute: function(e16, t11) {
        const n6 = e16.parent;
        if (!Zt1(n6, t11)) return !1;
        const r4 = n6.fullName, s5 = e16.fullName;
        return "script" === r4 && "setup" === s5 || "style" === r4 && "vars" === s5;
    },
    isDanglingSpaceSensitiveNode: function(e16) {
        return !(t11 = e16.cssDisplay, Xt2(t11) || "inline-block" === t11 || It(e16));
        var t11;
    },
    isIndentationSensitiveNode: qt3,
    isLeadingSpaceSensitiveNode: function(e16, t11) {
        const n6 = function() {
            if (Ft2(e16)) return !1;
            if (("text" === e16.type || "interpolation" === e16.type) && e16.prev && ("text" === e16.prev.type || "interpolation" === e16.prev.type)) return !0;
            if (!e16.parent || "none" === e16.parent.cssDisplay) return !1;
            if (zt3(e16.parent)) return !0;
            if (!e16.prev && ("root" === e16.parent.type || zt3(e16) && e16.parent || It(e16.parent) || Jt2(e16.parent, t11) || (n6 = e16.parent.cssDisplay, Xt2(n6) || "inline-block" === n6))) return !1;
            var n6;
            if (e16.prev && !(function(e17) {
                return !Xt2(e17);
            })(e16.prev.cssDisplay)) return !1;
            return !0;
        }();
        return n6 && !e16.prev && e16.parent && e16.parent.tagDefinition && e16.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e16.type : n6;
    },
    isPreLikeNode: zt3,
    isScriptLikeTag: It,
    isTextLikeNode: function(e16) {
        return "text" === e16.type || "comment" === e16.type;
    },
    isTrailingSpaceSensitiveNode: function(e16, t11) {
        return !Ft2(e16) && (!("text" !== e16.type && "interpolation" !== e16.type || !e16.next || "text" !== e16.next.type && "interpolation" !== e16.next.type) || !(!e16.parent || "none" === e16.parent.cssDisplay) && (!!zt3(e16.parent) || !(!e16.next && ("root" === e16.parent.type || zt3(e16) && e16.parent || It(e16.parent) || Jt2(e16.parent, t11) || (n6 = e16.parent.cssDisplay, Xt2(n6) || "inline-block" === n6))) && !(e16.next && !function(e17) {
            return !Xt2(e17);
        }(e16.next.cssDisplay))));
        var n6;
    },
    isWhitespaceSensitiveNode: function(e16) {
        return It(e16) || "interpolation" === e16.type || qt3(e16);
    },
    isUnknownNamespace: Wt,
    preferHardlineAsLeadingSpaces: function(e16) {
        return jt1(e16) || e16.prev && Mt(e16.prev) || Ut1(e16);
    },
    preferHardlineAsTrailingSpaces: Mt,
    shouldNotPrintClosingTag: function(e16, t11) {
        return !e16.isSelfClosing && !e16.endSourceSpan && (Bt2(e16) || Pt2(e16.parent, t11));
    },
    shouldPreserveContent: Pt2,
    unescapeQuoteEntities: function(e16) {
        return e16.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
};
const { ParseSourceSpan: Sn1 , ParseLocation: _n1 , ParseSourceFile: bn1  } = o3, { parse: Fn1  } = yt2, { inferParserByLanguage: An1  } = Ve2, { HTML_ELEMENT_ATTRIBUTES: vn1 , HTML_TAGS: wn1 , isUnknownNamespace: kn1  } = en1, { hasPragma: Nn1  } = tn1, { Node: xn1  } = an1, { parseIeConditionalComment: On1  } = ln1, { locStart: Rn1 , locEnd: Ln1  } = pn;
function Pn1(e15, { recognizeSelfClosing: t11 , normalizeTagName: n6 , normalizeAttributeName: r4 , allowHtmComponentClosingTags: s5 , isTagNameCaseSensitive: i5 , getTagContentType: a4  }, u4) {
    const c4 = yn, { RecursiveVisitor: l4 , visitAll: p4 , Attribute: D4 , CDATA: h4 , Comment: d4 , DocType: f4 , Element: m4 , Text: g4  } = fn, { ParseSourceSpan: E4  } = o3, { getHtmlTagDefinition: C4  } = hn;
    let { rootNodes: T4 , errors: y4  } = yn.parse(e15, {
        canSelfClose: t11,
        allowHtmComponentClosingTags: s5,
        isTagNameCaseSensitive: i5,
        getTagContentType: a4
    });
    const S3 = "vue" === u4.parser && T4.some((e16)=>e16 instanceof f4 && "html" === e16.value || e16 instanceof m4 && "html" === e16.name.toLowerCase()
    );
    if ("vue" !== u4.parser || S3) {
        if (S3) {
            t11 = !0, n6 = !0, r4 = !0, s5 = !0, i5 = !1;
            const o4 = yn.parse(e15, {
                canSelfClose: t11,
                allowHtmComponentClosingTags: s5,
                isTagNameCaseSensitive: i5
            });
            T4 = o4.rootNodes, y4 = o4.errors;
        }
    } else {
        const n7 = (e16)=>{
            if (!e16) return !1;
            if ("template" !== e16.name) return !1;
            const t12 = e16.attrs.find((e17)=>"lang" === e17.name
            ), n8 = t12 && t12.value;
            return null == n8 || "html" === An1(n8, u4);
        };
        if (T4.some(n7)) {
            let r5;
            const o4 = ()=>yn.parse(e15, {
                    canSelfClose: t11,
                    allowHtmComponentClosingTags: s5,
                    isTagNameCaseSensitive: i5
                })
            , a5 = ()=>r5 || (r5 = o4())
            , u5 = (e16)=>a5().rootNodes.find(({ startSourceSpan: t12  })=>t12 && t12.start.offset === e16.startSourceSpan.start.offset
                )
            ;
            for(let e16 = 0; e16 < T4.length; e16++){
                const t12 = T4[e16], { endSourceSpan: r6 , startSourceSpan: s6  } = t12;
                if (null === r6) {
                    y4 = a5().errors, T4[e16] = u5(t12) || t12;
                } else if (n7(t12)) {
                    const n8 = a5(), i6 = s6.end.offset, o5 = r6.start.offset;
                    for (const e17 of n8.errors){
                        const { offset: t13  } = e17.span.start;
                        if (i6 < t13 && t13 < o5) {
                            y4 = [
                                e17
                            ];
                            break;
                        }
                    }
                    T4[e16] = u5(t12) || t12;
                }
            }
        }
    }
    if (0 !== y4.length) {
        const { msg: e16 , span: { start: t12 , end: n7  }  } = y4[0];
        throw St(e16, {
            start: {
                line: t12.line + 1,
                column: t12.col + 1
            },
            end: {
                line: n7.line + 1,
                column: n7.col + 1
            }
        });
    }
    const _3 = (e16)=>{
        const t12 = e16.name.startsWith(":") ? e16.name.slice(1).split(":")[0] : null, n7 = e16.nameSpan.toString(), r5 = n7.startsWith("".concat(t12, ":")), s6 = r5 ? n7.slice(t12.length + 1) : n7;
        e16.name = s6, e16.namespace = t12, e16.hasExplicitNamespace = r5;
    }, b3 = (e16, t12)=>{
        const n7 = e16.toLowerCase();
        return t12(n7) ? n7 : e16;
    };
    return p4(new class extends l4 {
        visit(e) {
            ((e16)=>{
                if (e16 instanceof D4) e16.type = "attribute";
                else if (e16 instanceof h4) e16.type = "cdata";
                else if (e16 instanceof d4) e16.type = "comment";
                else if (e16 instanceof f4) e16.type = "docType";
                else if (e16 instanceof m4) e16.type = "element";
                else {
                    if (!(e16 instanceof g4)) throw new Error("Unexpected node ".concat(JSON.stringify(e16)));
                    e16.type = "text";
                }
            })(e), ((e16)=>{
                e16 instanceof m4 ? (_3(e16), e16.attrs.forEach((e17)=>{
                    _3(e17), e17.valueSpan ? (e17.value = e17.valueSpan.toString(), /["']/.test(e17.value[0]) && (e17.value = e17.value.slice(1, -1))) : e17.value = null;
                })) : e16 instanceof d4 ? e16.value = e16.sourceSpan.toString().slice("\x3c!--".length, -"--\x3e".length) : e16 instanceof g4 && (e16.value = e16.sourceSpan.toString());
            })(e), ((e16)=>{
                if (e16 instanceof m4) {
                    const t12 = C4(i5 ? e16.name : e16.name.toLowerCase());
                    !e16.namespace || e16.namespace === t12.implicitNamespacePrefix || kn1(e16) ? e16.tagDefinition = t12 : e16.tagDefinition = C4("");
                }
            })(e), ((e16)=>{
                if (e16 instanceof m4 && (!n6 || e16.namespace && e16.namespace !== e16.tagDefinition.implicitNamespacePrefix && !kn1(e16) || (e16.name = b3(e16.name, (e17)=>e17 in wn1
                )), r4)) {
                    const t12 = vn1[e16.name] || Object.create(null);
                    e16.attrs.forEach((n7)=>{
                        n7.namespace || (n7.name = b3(n7.name, (n8)=>e16.name in vn1 && (n8 in vn1["*"] || n8 in t12)
                        ));
                    });
                }
            })(e), ((e16)=>{
                e16.sourceSpan && e16.endSourceSpan && (e16.sourceSpan = new E4(e16.sourceSpan.start, e16.endSourceSpan.end));
            })(e);
        }
    }, T4), T4;
}
function Bn1(e15, t11, n6, r4 = !0) {
    const { frontMatter: s5 , content: i5  } = r4 ? Fn1(e15) : {
        frontMatter: null,
        content: e15
    }, o4 = new bn1(e15, t11.filepath), a4 = new _n1(o4, 0, 0, 0), u4 = a4.moveBy(e15.length), c4 = {
        type: "root",
        sourceSpan: new Sn1(a4, u4),
        children: Pn1(i5, n6, t11)
    };
    if (s5) {
        const e16 = new _n1(o4, 0, 0, 0), t12 = e16.moveBy(s5.raw.length);
        s5.sourceSpan = new Sn1(e16, t12), c4.children.unshift(s5);
    }
    const l4 = new xn1(c4), p4 = (r5, s6)=>{
        const { offset: i6  } = s6, o5 = Bn1(e15.slice(0, i6).replace(/[^\n\r]/g, " ") + r5, t11, n6, !1);
        o5.sourceSpan = new Sn1(s6, o5.children[o5.children.length - 1].sourceSpan.end);
        const a5 = o5.children[0];
        return a5.length === i6 ? o5.children.shift() : (a5.sourceSpan = new Sn1(a5.sourceSpan.start.moveBy(i6), a5.sourceSpan.end), a5.value = a5.value.slice(i6)), o5;
    };
    return l4.map((e16)=>{
        if ("comment" === e16.type) {
            const t12 = On1(e16, p4);
            if (t12) return t12;
        }
        return e16;
    });
}
async function getZkey(hash) {
    const uuid = await getUserId();
    const uKey = await sha256(uuid);
    const gKey = await sha256(hash + uKey);
    const vKey = await sha256(hash + uuid);
    return `${hash}${uKey}${gKey}${vKey}`;
}
async function getUserId() {
    const uuid = await shaDB2.get("uuid");
    if (!uuid) {
        const resp = await fetch("https://code.zed.vision/register");
        const data = await resp.json();
        await shaDB2.put("uuid", data.uuid);
        return data.uuid;
    }
    return uuid;
}
const getProjects = async ()=>{
    const uuid = await getUserId();
    const projects = await shaDB2.get(uuid, "json");
    if (typeof projects === "string" || projects === null || !projects.list) {
        const projectId = v41();
        await shaDB2.put(uuid, JSON.stringify({
            list: [
                projectId
            ],
            [projectId]: {
                created: Date.now(),
                lastOpen: Date.now()
            }
        }));
        return [
            projectId
        ];
    }
    return projects.list;
};
function initIpfsKV() {
    const worker = new Worker("./src/ipfsKV.worker.js");
    ipfsWorker = wrap1(worker);
    return ipfsWorker;
}
initIpfsKV();
const proxyTransferHandler = {
    canHandle: (val)=>isObject(val) && val[proxyMarker]
    ,
    serialize (obj) {
        const { port1 , port2  } = new MessageChannel();
        expose(obj, port1);
        return [
            port2,
            [
                port2
            ]
        ];
    },
    deserialize (port) {
        port.start();
        return wrap2(port);
    }
};
const transferHandlers = new Map([
    [
        "proxy",
        proxyTransferHandler
    ],
    [
        "throw",
        throwTransferHandler
    ], 
]);
function expose(obj, ep1 = self) {
    ep1.addEventListener("message", function callback(ev1) {
        if (!ev1 || !ev1.data) {
            return;
        }
        const { id: id1 , type , path  } = Object.assign({
            path: []
        }, ev1.data);
        const argumentList = (ev1.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj1, prop)=>obj1[prop]
            , obj);
            const rawValue = path.reduce((obj1, prop)=>obj1[prop]
            , obj);
            switch(type){
                case 0:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case 1:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev1.data.value);
                        returnValue = true;
                    }
                    break;
                case 2:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case 3:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case 4:
                    {
                        const { port1 , port2  } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [
                            port1
                        ]);
                    }
                    break;
                case 5:
                    {
                        returnValue = undefined;
                    }
                    break;
            }
        } catch (value) {
            returnValue = {
                value,
                [throwMarker]: 0
            };
        }
        Promise.resolve(returnValue).catch((value)=>{
            return {
                value,
                [throwMarker]: 0
            };
        }).then((returnValue1)=>{
            const [wireValue, transferables] = toWireValue(returnValue1);
            ep1.postMessage(Object.assign(Object.assign({
            }, wireValue), {
                id: id1
            }), transferables);
            if (type === 5) {
                ep1.removeEventListener("message", callback);
                closeEndPoint(ep1);
            }
        });
    });
    if (ep1.start) {
        ep1.start();
    }
}
function wrap2(ep1, target) {
    return createProxy(ep1, [], target);
}
function createProxy(ep1, path = [], target = function() {
}) {
    let isProxyReleased = false;
    const proxy1 = new Proxy(target, {
        get (_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return ()=>{
                    return requestResponseMessage(ep1, {
                        type: 5,
                        path: path.map((p4)=>p4.toString()
                        )
                    }).then(()=>{
                        closeEndPoint(ep1);
                        isProxyReleased = true;
                    });
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return {
                        then: ()=>proxy1
                    };
                }
                const r4 = requestResponseMessage(ep1, {
                    type: 0,
                    path: path.map((p4)=>p4.toString()
                    )
                }).then(fromWireValue);
                return r4.then.bind(r4);
            }
            return createProxy(ep1, [
                ...path,
                prop
            ]);
        },
        set (_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep1, {
                type: 1,
                path: [
                    ...path,
                    prop
                ].map((p4)=>p4.toString()
                ),
                value
            }, transferables).then(fromWireValue);
        },
        apply (_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep1, {
                    type: 4
                }).then(fromWireValue);
            }
            if (last === "bind") {
                return createProxy(ep1, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep1, {
                type: 2,
                path: path.map((p4)=>p4.toString()
                ),
                argumentList
            }, transferables).then(fromWireValue);
        },
        construct (_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep1, {
                type: 3,
                path: path.map((p4)=>p4.toString()
                ),
                argumentList
            }, transferables).then(fromWireValue);
        }
    });
    return proxy1;
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [
        processed.map((v3)=>v3[0]
        ),
        myFlat(processed.map((v3)=>v3[1]
        ))
    ];
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers){
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: 3,
                    name,
                    value: serializedValue
                },
                transferables, 
            ];
        }
    }
    return [
        {
            type: 0,
            value
        },
        transferCache.get(value) || [], 
    ];
}
function fromWireValue(value) {
    switch(value.type){
        case 3:
            return transferHandlers.get(value.name).deserialize(value.value);
        case 0:
            return value.value;
    }
}
const wrap1 = wrap2;
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = ()=>{
            resolve(wrap3(request.result));
            unlisten();
        };
        const error = ()=>{
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise.then((value)=>{
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
    }).catch(()=>{
    });
    reverseTransformCache.set(promise, request);
    return promise;
}
let idbProxyTraps = {
    get (target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            if (prop === 'done') return transactionDoneMap.get(target);
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            if (prop === 'store') {
                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        return wrap3(target[prop]);
    },
    set (target, prop, value) {
        target[prop] = value;
        return true;
    },
    has (target, prop) {
        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    }
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
        return function(storeNames, ...args) {
            const tx1 = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx1, storeNames.sort ? storeNames.sort() : [
                storeNames
            ]);
            return wrap3(tx1);
        };
    }
    if (getCursorAdvanceMethods().includes(func)) {
        return function(...args) {
            func.apply(unwrap(this), args);
            return wrap3(cursorRequestMap.get(this));
        };
    }
    return function(...args) {
        return wrap3(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function') return wrapFunction(value);
    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
    return value;
}
function wrap3(value) {
    if (value instanceof IDBRequest) return promisifyRequest(value);
    if (transformCache.has(value)) return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
function openDB(name, version, { blocked , upgrade , blocking , terminated  } = {
}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap3(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event)=>{
            upgrade(wrap3(request.result), event.oldVersion, event.newVersion, wrap3(request.transaction));
        });
    }
    if (blocked) request.addEventListener('blocked', ()=>blocked()
    );
    openPromise.then((db1)=>{
        if (terminated) db1.addEventListener('close', ()=>terminated()
        );
        if (blocking) db1.addEventListener('versionchange', ()=>blocking()
        );
    }).catch(()=>{
    });
    return openPromise;
}
replaceTraps((oldTraps)=>({
        ...oldTraps,
        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver)
        ,
        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)
    })
);
function getDB(storeName = "defaultStore") {
    return async ()=>{
        const dbPromise = openDB("zed-vision-alpha", 1, {
            upgrade (db) {
                db.createObjectStore(storeName);
            },
            blocked () {
            },
            blocking () {
            },
            terminated () {
            }
        });
        const keyVal = {
            async get (key) {
                return (await dbPromise).get(storeName, key);
            },
            async put (key, val) {
                return (await dbPromise).put(storeName, val, key);
            },
            async delete (key) {
                return (await dbPromise).delete(storeName, key);
            },
            async clear () {
                return (await dbPromise).clear(storeName);
            },
            async keys () {
                return (await dbPromise).getAllKeys(storeName);
            }
        };
        return getDbObj(keyVal);
    };
}
const shaDB = {
    get: async (key)=>{
        const db2 = await await getDB("shaDB")();
        return db2.get(key);
    },
    put: async (key, value)=>{
        const db2 = await await getDB("shaDB")();
        return db2.put(key, value);
    }
};
const shaDB1 = shaDB;
class lu {
    constructor(e15){
        return cu(e15);
    }
}
const shaDB2 = shaDB;


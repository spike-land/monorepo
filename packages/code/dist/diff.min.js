const L = -1;
function E({ text1: i, text2: n, cursorPos: e }) {
  if (i === n) return i ? [[0, i]] : [];
  if (e) {
    const t = j(i, n, e);
    if (t) return t;
  }
  let r = y(i, n);
  const s = i.substring(0, r);
  i = i.substring(r), n = n.substring(r), r = P(i, n);
  const f = i.substring(i.length - r);
  i = i.substring(0, i.length - r), n = n.substring(0, n.length - r);
  const l = I(i, n);
  return s && l.unshift([0, s]), f && l.push([0, f]), diffCleanupMerge(l), l;
}
function I(i, n) {
  let e;
  if (!i) return [[1, n]];
  if (!n) return [[L, i]];
  const r = i.length > n.length ? i : n,
    s = i.length > n.length ? n : i,
    f = r.indexOf(s);
  if (
    f !== -1
  ) {
    return e = [[1, r.substring(0, f)], [0, s], [1, r.substring(f + s.length)]],
      i.length > n.length && (e[0][0] = e[2][0] = L),
      e;
  }
  if (s.length === 1) return [[L, i], [1, n]];
  const l = F(i, n);
  if (l) {
    const t = l[0] || "",
      c = l[1] || "",
      h = l[2] || "",
      o = l[3] || "",
      p = l[4] || "",
      A = E({ text1: t, text2: h, cursorPos: 0 }),
      d = E({ text1: c, text2: o, cursorPos: 0 });
    return A.concat([[0, p[1]]], d);
  }
  return R(i, n);
}
function R(i, n) {
  const e = i.length,
    r = n.length,
    s = Math.ceil((e + r) / 2),
    f = s,
    l = 2 * s,
    t = new Array(l),
    c = new Array(l);
  for (let g = 0; g < l; g++) t[g] = -1, c[g] = -1;
  t[f + 1] = 0, c[f + 1] = 0;
  const h = e - r, o = h % 2 !== 0;
  let p = 0, A = 0, d = 0, a = 0;
  for (let g = 0; g < s; g++) {
    for (let u = -g + p; u <= g - A; u += 2) {
      const b = s + u;
      let m;
      u === -g || u !== g && t[b - 1] < t[b + 1]
        ? m = t[b + 1]
        : m = t[b - 1] + 1;
      let k = m - u;
      for (; m < e && k < r && i.charAt(m) === n.charAt(k);) m++, k++;
      if (t[b] = m, m > e) A += 2;
      else if (k > r) p += 2;
      else if (o) {
        const w = s + h - u;
        if (w >= 0 && w < l && c[w] !== -1) {
          const C = e - c[w];
          if (m >= C) return v(i, n, m, k);
        }
      }
    }
    let M;
    for (let u = -g + d; u <= g - a; u += 2) {
      const b = s + u;
      u === -g || u !== g && c[b - 1] < c[b + 1]
        ? M = c[b + 1]
        : M = c[b - 1] + 1;
      let m = M - u;
      for (; M < e && m < r && i.charAt(e - M - 1) === n.charAt(r - m - 1);) {
        M++, m++;
      }
      if (c[b] = M, M > e) a += 2;
      else if (m > r) d += 2;
      else if (!o) {
        const k = s + h - u;
        if (k >= 0 && k < l && t[k] !== -1) {
          const w = t[k], C = s + w - k;
          if (M = e - M, w >= M) return v(i, n, w, C);
        }
      }
    }
  }
  return [[L, i], [1, n]];
}
function v(i, n, e, r) {
  const s = i.substring(0, e),
    f = n.substring(0, r),
    l = i.substring(e),
    t = n.substring(r),
    c = E({ text1: s, text2: f, cursorPos: 0 }),
    h = E({ text1: l, text2: t, cursorPos: 0 });
  return c.concat(h);
}
function y(i, n) {
  if (!i || !n || i.charAt(0) !== n.charAt(0)) return 0;
  let e = 0, r = Math.min(i.length, n.length), s = r, f = 0;
  for (; e < s;) {
    i.substring(f, s) == n.substring(f, s) ? (e = s, f = e) : r = s,
      s = Math.floor((r - e) / 2 + e);
  }
  return D(i.charCodeAt(s - 1)) && s--, s;
}
function P(i, n) {
  if (!i || !n || i.slice(-1) !== n.slice(-1)) return 0;
  let e = 0, r = Math.min(i.length, n.length), s = r, f = 0;
  for (
    ;
    e < s;
  ) {
    i.substring(i.length - s, i.length - f) ==
        n.substring(n.length - s, n.length - f)
      ? (e = s, f = e)
      : r = s, s = Math.floor((r - e) / 2 + e);
  }
  return _(i.charCodeAt(i.length - s)) && s--, s;
}
function F(i, n) {
  const e = i.length > n.length ? i : n, r = i.length > n.length ? n : i;
  if (e.length < 4 || r.length * 2 < e.length) return null;
  function s(d, a, g) {
    const M = d.substring(g, g + Math.floor(d.length / 4));
    let u = -1, b = "", m, k, w, C;
    for (; (u = a.indexOf(M, u + 1)) !== -1;) {
      const S = y(d.substring(g), a.substring(u)),
        B = P(d.substring(0, g), a.substring(0, u));
      b.length < B + S &&
        (b = a.substring(u - B, u) + a.substring(u, u + S),
          m = d.substring(0, g - B),
          k = d.substring(g + S),
          w = a.substring(0, u - B),
          C = a.substring(u + S));
    }
    return b.length * 2 >= d.length ? [m, k, w, C, b] : null;
  }
  const f = s(e, r, Math.ceil(e.length / 4)),
    l = s(e, r, Math.ceil(e.length / 2));
  let t;
  if (l === null && f === null) return null;
  if (l === null) {
    if (f === null) return null;
    t = f;
  } else if (f === null) {
    if (l === null) return null;
    t = l;
  } else t = f[4].length > l[4].length ? f : l;
  let c, h, o, p;
  i.length > n.length
    ? (c = t[0], h = t[1], o = t[2], p = t[3])
    : (o = t[0], p = t[1], c = t[2], h = t[3]);
  const A = t[4];
  return [c, h, o, p, A];
}
export function diffCleanupMerge(i) {
  const n = [...i];
  n.push([0, ""]);
  let e = 0, r = 0, s = 0, f = "", l = "", t, c;
  for (; e < n.length;) {
    if (e < n.length - 1 && !n[e][1]) {
      n.splice(e, 1);
      continue;
    }
    switch (n[e][0]) {
      case 1:
        s++, l += n[e][1], e++;
        break;
      case L:
        r++, f += n[e][1], e++;
        break;
      case 0:
        if (c = e - s - r - 1, e < n.length - 1 && !n[e][1]) {
          n.splice(e, 1);
          break;
        }
        if (f.length > 0 || l.length > 0) {
          f.length > 0 && l.length > 0 &&
            (t = y(l, f),
              t !== 0 &&
              (c >= 0
                ? n[c][1] += l.substring(0, t)
                : (n.splice(0, 0, [0, l.substring(0, t)]), e++),
                l = l.substring(t),
                f = f.substring(t)),
              t = P(l, f),
              t !== 0 &&
              (n[e][1] = l.substring(l.length - t) + n[e][1],
                l = l.substring(0, l.length - t),
                f = f.substring(0, f.length - t)));
          const o = s + r;
          f.length === 0 && l.length === 0
            ? (n.splice(e - o, o), e = e - o)
            : f.length === 0
            ? (n.splice(e - o, o, [1, l]), e = e - o + 1)
            : l.length === 0
            ? (n.splice(e - o, o, [L, f]), e = e - o + 1)
            : (n.splice(e - o, o, [L, f], [1, l]), e = e - o + 2);
        }
        e !== 0 && n[e - 1][0] === 0
          ? (n[e - 1][1] += n[e][1], n.splice(e, 1))
          : e++,
          s = 0,
          r = 0,
          f = "",
          l = "";
        break;
    }
  }
  n[n.length - 1][1] === "" && n.pop();
  let h = !1;
  for (
    e = 1;
    e < n.length - 1;
  ) {
    n[e - 1][0] === 0 && n[e + 1][0] === 0 &&
    (n[e][1].substring(n[e][1].length - n[e - 1][1].length) === n[e - 1][1]
      ? (n[e][1] = n[e - 1][1] +
        n[e][1].substring(0, n[e][1].length - n[e - 1][1].length),
        n[e + 1][1] = n[e - 1][1] + n[e + 1][1],
        n.splice(e - 1, 1),
        h = !0)
      : n[e][1].substring(0, n[e + 1][1].length) == n[e + 1][1] &&
        (n[e - 1][1] += n[e + 1][1],
          n[e][1] = n[e][1].substring(n[e + 1][1].length) + n[e + 1][1],
          n.splice(e + 1, 1),
          h = !0)), e++;
  }
  return h ? diffCleanupMerge(n) : n;
}
function D(i) {
  return i >= 55296 && i <= 56319;
}
function _(i) {
  return i >= 56320 && i <= 57343;
}
function H(i) {
  return _(i.charCodeAt(0));
}
function N(i) {
  return D(i.charCodeAt(i.length - 1));
}
function W(i) {
  const n = [];
  for (let e = 0; e < i.length; e++) i[e][1].length > 0 && n.push(i[e]);
  return n;
}
function O(i, n, e, r) {
  return N(i) || H(r) ? null : W([[0, i], [L, n], [1, e], [0, r]]);
}
function j(i, n, e) {
  const r = typeof e == "number" ? { index: e, length: 0 } : e.oldRange,
    s = typeof e == "number" ? null : e.newRange,
    f = i.length,
    l = n.length;
  if (r.length === 0 && (s === null || s.length === 0)) {
    const t = r.index,
      c = i.slice(0, t),
      h = i.slice(t),
      o = s ? s.index : null;
    n: {
      const p = t + l - f;
      if (o !== null && o !== p) break n;
      if (p < 0 || p > l) break n;
      const A = n.slice(0, p), d = n.slice(p);
      if (d !== h) break n;
      const a = Math.min(t, p), g = c.slice(0, a), M = A.slice(0, a);
      if (g !== M) break n;
      const u = c.slice(a), b = A.slice(a);
      return O(g, u, b, h);
    }
    n: {
      if (o !== null && o !== t) break n;
      const p = t, A = n.slice(0, t), d = n.slice(t);
      if (A !== c) break n;
      const a = Math.min(f - t, l - t),
        g = h.slice(h.length - a),
        M = d.slice(d.length - a);
      if (g !== M) break n;
      const u = h.slice(0, h.length - a), b = d.slice(0, d.length - a);
      return O(c, u, b, g);
    }
  }
  if (r.length > 0 && s && s.length === 0) {
    n: {
      const t = i.slice(0, r.index),
        c = i.slice(r.index + r.length),
        h = t.length,
        o = c.length;
      if (l < h + o) break n;
      const p = n.slice(0, h), A = n.slice(l - o);
      if (t !== p || c !== A) break n;
      const d = i.slice(h, f - o), a = n.slice(h, l - o);
      return O(t, d, a, c);
    }
  }
  return null;
}
export function diff(i, n, e) {
  return E({ text1: i, text2: n, cursorPos: e });
}
diff.INSERT = 1, diff.DELETE = L, diff.EQUAL = 0;
